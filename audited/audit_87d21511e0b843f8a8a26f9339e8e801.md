# Audit Report

## Title
Inadequate Validation Allows Time Slot Collisions via Duplicate FinalOrderOfNextRound Values

## Summary
The `NextRoundMiningOrderValidationProvider` incorrectly validates uniqueness of `FinalOrderOfNextRound` values by calling `.Distinct()` on `MinerInRound` objects instead of on the order values themselves. This allows malicious miners to set duplicate mining orders through `TuneOrderInformation`, causing multiple miners to receive identical time slots in the next round and compromising consensus integrity.

## Finding Description

The vulnerability exists in the validation logic that checks uniqueness of mining orders for the next round. [1](#0-0) 

The validation calls `.Distinct()` on a collection of `MinerInRound` objects. Since `MinerInRound` is a protobuf-generated message type with 17 fields including the unique `pubkey` field, [2](#0-1)  its auto-generated `Equals()` method compares all fields. This means two `MinerInRound` objects with different pubkeys are never considered equal even if they have identical `FinalOrderOfNextRound` values, causing the validation to always pass regardless of duplicate order values.

**Attack Vector - Via TuneOrderInformation:**

Miners can manipulate other miners' `FinalOrderOfNextRound` values through the `TuneOrderInformation` field in `UpdateValueInput`. [3](#0-2)  The contract directly applies these values without validation: [4](#0-3) 

Additionally, miners set their own `FinalOrderOfNextRound` directly from input: [5](#0-4) 

The `UpdateValue` method is a public RPC that accepts arbitrary `UpdateValueInput` parameters, [6](#0-5)  and only validates that the sender is an active miner. [7](#0-6) 

**Consequence - Time Slot Collision:**

When generating the next round, duplicate `FinalOrderOfNextRound` values directly cause mining time slot collisions. [8](#0-7)  If multiple miners have the same order value, they receive identical `ExpectedMiningTime` values since the calculation is `currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order))`.

The `NextRoundMiningOrderValidationProvider` is only invoked during `NextRound` behavior, [9](#0-8)  not during `UpdateValue` transactions when the malicious values are set. By the time validation runs, the duplicate orders are already committed to state.

## Impact Explanation

**Severity: HIGH**

This vulnerability directly compromises the core consensus mechanism. The AEDPoS protocol relies on each miner having a unique, non-overlapping time slot to produce blocks. When multiple miners receive identical `ExpectedMiningTime` values:

- Multiple miners attempt to produce blocks simultaneously, creating ambiguity about which block is legitimate
- This can lead to competing forks, consensus deadlock, or complete block production stalls
- The network becomes unable to reliably advance the blockchain
- Recovery requires manual intervention or chain restart

The impact affects the entire network's operation, not just individual miners or users.

## Likelihood Explanation

**Probability: HIGH**

The attack is straightforward to execute:
- Any active miner (elected through normal processes) can exploit this vulnerability
- Requires only a single `UpdateValue` transaction with malicious `TuneOrderInformation` 
- No complex timing, state manipulation, or collusion required
- The broken validation provides a false sense of security while allowing duplicates through

The preconditions are realistic: the attacker must be an active miner in the current round, which is achievable through the election process. The attack complexity is low with no special privileges needed beyond standard miner capabilities.

## Recommendation

Fix the validation to check uniqueness of the `FinalOrderOfNextRound` values themselves, not the `MinerInRound` objects:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var providedRound = validationContext.ProvidedRound;
    
    // Get miners with FinalOrderOfNextRound set
    var minersWithOrders = providedRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0).ToList();
    
    // Check for duplicate order values
    var distinctOrderCount = minersWithOrders
        .Select(m => m.FinalOrderOfNextRound)
        .Distinct()
        .Count();
    
    var minersWhoMinedCount = providedRound.RealTimeMinersInformation.Values
        .Count(m => m.OutValue != null);
    
    if (distinctOrderCount != minersWhoMinedCount)
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound - duplicate orders detected.";
        return validationResult;
    }

    validationResult.Success = true;
    return validationResult;
}
```

Additionally, add uniqueness validation in `ProcessUpdateValue` when applying `TuneOrderInformation` to reject duplicate values before they are committed to state.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Set up a round with multiple active miners
2. Have one miner submit an `UpdateValue` transaction with `TuneOrderInformation` containing duplicate `FinalOrderOfNextRound` values (e.g., {"minerB": 3, "minerC": 3})
3. Verify the transaction succeeds and state is updated with duplicates
4. Trigger `NextRound` generation
5. Verify that multiple miners receive identical `ExpectedMiningTime` values
6. Confirm the validation incorrectly passes due to `.Distinct()` comparing full `MinerInRound` objects

The test would prove that the validation fails to detect duplicate mining orders, allowing consensus-breaking time slot collisions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L30-31)
```text
    rpc UpdateValue (UpdateValueInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** protobuf/aedpos_contract.proto (L266-300)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L247-247)
```csharp
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```
