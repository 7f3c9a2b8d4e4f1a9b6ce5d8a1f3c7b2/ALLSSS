### Title
Missing Authorization Check in Economic Contract Initialization Allows Attacker to Control Blockchain Economic Parameters

### Summary
The `InitialEconomicSystem` method in the Economic contract lacks authorization checks and only verifies that initialization hasn't occurred, not who is performing it. An attacker can front-run the legitimate initialization transaction to set malicious native token parameters, mining rewards, and other critical economic values, permanently compromising the blockchain's economic system.

### Finding Description

The `InitialEconomicSystem` method in the Economic contract only checks if the contract has been initialized, but performs no authorization check on the caller: [1](#0-0) 

The method performs critical initialization operations including creating the native token, resource tokens, election tokens, setting mining rewards, and initializing the token converter: [2](#0-1) 

**Root Cause:** The method lacks a `Context.Sender` authorization check. Compare this with the Genesis contract's `Initialize` method, which properly enforces authorization: [3](#0-2) 

The Genesis contract requires `Context.Sender == Context.Self`, ensuring only the contract itself can initialize during deployment. The Economic contract has no such protection.

**Why Protections Fail:** While the normal genesis deployment flow uses atomic inline transactions via `DeploySystemSmartContract`: [4](#0-3) 

This atomic protection ONLY applies during genesis block creation. Test code demonstrates that deployment and initialization are separable operations: [5](#0-4) 

And initialization is called separately: [6](#0-5) 

This creates an exploitable window where the contract exists but `State.Initialized.Value` is false.

### Impact Explanation

**Critical Impact on Blockchain Economics:**

1. **Native Token Control**: Attacker sets arbitrary token symbol, total supply, decimals, and burnability parameters affecting all token operations [7](#0-6) 

2. **Mining Reward Manipulation**: Attacker controls `MiningRewardTotalAmount`, potentially setting it to zero (breaking consensus incentives) or maximum value (causing inflation) [8](#0-7) 

3. **Resource Token Compromise**: Creates resource tokens with attacker-chosen parameters [9](#0-8) 

4. **Token Converter Configuration**: Malicious initialization of converter contracts and connectors [10](#0-9) 

5. **Irreversible Damage**: Once `State.Initialized.Value = true`, legitimate initialization is permanently blocked, requiring contract redeployment.

**Affected Parties:** All blockchain participants - miners lose proper rewards, users receive wrong token properties, entire economic model collapses.

### Likelihood Explanation

**High Likelihood of Exploitation:**

**Attacker Capabilities Required:**
- Monitor blockchain for Economic contract deployment
- Submit one transaction calling `InitialEconomicSystem` with malicious `InitialEconomicSystemInput`
- No special privileges needed - method is publicly accessible

**Attack Complexity:** Low - single transaction with custom parameters.

**Feasible Scenarios:**
1. **Manual Deployments**: Test environments, debugging sessions, or staged rollouts where deployment and initialization are separate transactions (demonstrated by test code pattern)
2. **Genesis Block Construction Bugs**: Errors in initialization provider configuration or genesis block assembly could delay/skip initialization
3. **Contract Upgrade Scenarios**: If Economic contract needs redeployment, same vulnerability applies
4. **Transaction Ordering**: In any scenario where deployment transaction is mined before initialization transaction, attacker can front-run

**Detection Constraints:** The initialization transaction appears legitimate - only the input parameters differ from expected values. No obvious red flags until economic operations begin failing.

**Probability Assessment:** Medium-High in non-genesis scenarios. While production genesis blocks should initialize atomically, the pattern demonstrated in test code (separate deployment and initialization) indicates real deployment scenarios where this window exists. Defense-in-depth principle demands authorization regardless of timing assumptions.

### Recommendation

**Immediate Fix - Add Authorization Check:**

Add a sender authorization check at the beginning of `InitialEconomicSystem` method to ensure only authorized entities (e.g., Genesis contract or a specific deployer address) can initialize:

```csharp
public override Empty InitialEconomicSystem(InitialEconomicSystemInput input)
{
    Assert(!State.Initialized.Value, "Already initialized.");
    
    // Add authorization check - only Genesis contract can initialize
    var genesisContractAddress = Context.GetZeroSmartContractAddress();
    Assert(Context.Sender == genesisContractAddress, 
           "Only genesis contract can initialize economic system.");
    
    // ... rest of initialization
}
```

**Alternative Approaches:**

1. **Self-authorization pattern** (like Genesis contract): `Assert(Context.Sender == Context.Self, "No permission.");` - Only works if initialization is always via inline call during deployment

2. **Deployer-based authorization**: Store authorized deployer address in state during contract creation, check against it

3. **Parliament-based authorization**: Require initialization to come from Parliament contract

**Invariant to Enforce:** 
`InitialEconomicSystem` can only be called by an authorized system address (Genesis contract or Parliament), never by arbitrary external accounts.

**Test Cases to Add:**
1. Test that unauthorized accounts cannot call `InitialEconomicSystem`
2. Test that initialization fails with proper error message when called by non-authorized address
3. Test that only Genesis/authorized contract can successfully initialize
4. Test protection against initialization parameter manipulation

### Proof of Concept

**Initial State:**
- Economic contract deployed but not initialized
- `State.Initialized.Value == false`
- Attacker monitors mempool or blockchain for deployment

**Attack Steps:**

1. **Attacker observes Economic contract deployment** at address `X`

2. **Before legitimate initialization, attacker submits transaction:**
   ```
   Transaction to: EconomicContract(X)
   Method: InitialEconomicSystem
   Input: InitialEconomicSystemInput {
     NativeTokenSymbol: "HACK",
     NativeTokenTotalSupply: 1, // Minimal supply
     NativeTokenDecimals: 0,
     IsNativeTokenBurnable: false,
     MiningRewardTotalAmount: 0, // No mining rewards
     // ... other malicious parameters
   }
   Sender: AttackerAddress
   ```

3. **Attacker's transaction executes:**
   - Assertion `!State.Initialized.Value` passes (still false)
   - No authorization check exists
   - Creates native token with symbol "HACK", supply 1, decimals 0
   - Sets mining rewards to 0
   - Sets `State.Initialized.Value = true`
   - Returns success

4. **Legitimate initialization attempts to execute:**
   ```
   Method: InitialEconomicSystem
   Input: InitialEconomicSystemInput {
     NativeTokenSymbol: "ELF",
     NativeTokenTotalSupply: 10_000_000_000_00000000,
     // ... legitimate parameters
   }
   ```
   - Assertion `!State.Initialized.Value` **FAILS** (now true)
   - Transaction reverts with "Already initialized."

**Expected Result:** Legitimate initialization should succeed with correct economic parameters.

**Actual Result:** Attacker's initialization succeeds. Blockchain launches with compromised native token ("HACK" with supply 1), zero mining rewards, and malicious economic configuration. Legitimate initialization permanently blocked.

**Success Condition:** Attacker controls all economic parameters set by `InitialEconomicSystem` for the lifetime of the contract.

### Citations

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L16-18)
```csharp
    public override Empty InitialEconomicSystem(InitialEconomicSystemInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L24-38)
```csharp
        CreateNativeToken(input);
        CreateResourceTokens();
        CreateElectionTokens();

        Context.LogDebug(() => "Finished creating tokens.");

        InitialMiningReward(input.MiningRewardTotalAmount);

        RegisterElectionVotingEvent();
        SetTreasurySchemeIdsToElectionContract();

        InitializeTokenConverterContract();
        State.TokenContract.InitialCoefficients.Send(new Empty());
        State.TokenContract.InitializeAuthorizedController.Send(new Empty());
        State.Initialized.Value = true;
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L42-68)
```csharp
    private void CreateNativeToken(InitialEconomicSystemInput input)
    {
        var lockWhiteListBackups = new List<Address>
        {
            Context.GetContractAddressByName(SmartContractConstants.VoteContractSystemName),
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName),
            Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName),
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName),
            Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName),
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName)
        };
        var lockWhiteList = lockWhiteListBackups.Where(address => address != null).ToList();
        State.TokenContract.Create.Send(new CreateInput
        {
            Symbol = input.NativeTokenSymbol,
            TokenName = "Native Token",
            TotalSupply = input.NativeTokenTotalSupply,
            Decimals = input.NativeTokenDecimals,
            IsBurnable = input.IsNativeTokenBurnable,
            Issuer = Context.Self,
            LockWhiteList = { lockWhiteList },
            Owner = Context.Self
        });

        State.TokenContract.SetPrimaryTokenSymbol.Send(new SetPrimaryTokenSymbolInput
            { Symbol = input.NativeTokenSymbol });
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L70-104)
```csharp
    private void CreateResourceTokens()
    {
        var tokenConverter =
            Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName);
        var lockWhiteListBackups = new List<Address>
        {
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName),
            Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName)
        };
        var lockWhiteList = lockWhiteListBackups.Where(address => address != null).ToList();
        foreach (var resourceTokenSymbol in Context.Variables
                     .GetStringArray(EconomicContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(EconomicContractConstants.PayRentalSymbolListName)))
        {
            State.TokenContract.Create.Send(new CreateInput
            {
                Symbol = resourceTokenSymbol,
                TokenName = $"{resourceTokenSymbol} Token",
                TotalSupply = EconomicContractConstants.ResourceTokenTotalSupply,
                Decimals = EconomicContractConstants.ResourceTokenDecimals,
                Issuer = Context.Self,
                LockWhiteList = { lockWhiteList },
                IsBurnable = true,
                Owner = Context.Self
            });

            State.TokenContract.Issue.Send(new IssueInput
            {
                Symbol = resourceTokenSymbol,
                Amount = EconomicContractConstants.ResourceTokenTotalSupply,
                To = tokenConverter,
                Memo = "Initialize for resource trade"
            });
        }
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L166-178)
```csharp
    private void InitialMiningReward(long miningRewardAmount)
    {
        var consensusContractAddress =
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        State.TokenContract.Issue.Send(new IssueInput
        {
            To = consensusContractAddress,
            Amount = miningRewardAmount,
            Symbol = Context.Variables.NativeSymbol,
            Memo = "Initial mining reward."
        });
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L211-260)
```csharp
    private void InitializeTokenConverterContract()
    {
        State.TokenConverterContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName);
        var connectors = new List<Connector>
        {
            new()
            {
                Symbol = Context.Variables.NativeSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.5",
                VirtualBalance = EconomicContractConstants.NativeTokenConnectorInitialVirtualBalance
            }
        };
        foreach (var resourceTokenSymbol in Context.Variables
                     .GetStringArray(EconomicContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(EconomicContractConstants.PayRentalSymbolListName)))
        {
            var resourceTokenConnector = new Connector
            {
                Symbol = resourceTokenSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.ResourceTokenInitialVirtualBalance,
                RelatedSymbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsDepositAccount = false
            };
            var nativeTokenConnector = new Connector
            {
                Symbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
                RelatedSymbol = resourceTokenSymbol,
                IsDepositAccount = true
            };
            connectors.Add(resourceTokenConnector);
            connectors.Add(nativeTokenConnector);
        }

        State.TokenConverterContract.Initialize.Send(new InitializeInput
        {
            FeeRate = EconomicContractConstants.TokenConverterFeeRate,
            Connectors = { connectors },
            BaseTokenSymbol = Context.Variables.NativeSymbol
        });
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L102-117)
```csharp
    public override Address DeploySystemSmartContract(SystemContractDeploymentInput input)
    {
        Assert(!State.Initialized.Value || !State.ContractDeploymentAuthorityRequired.Value,
            "System contract deployment failed.");
        RequireSenderAuthority();
        var name = input.Name;
        var category = input.Category;
        var code = input.Code.ToByteArray();
        var transactionMethodCallList = input.TransactionMethodCallList;

        // Context.Sender should be identical to Genesis contract address before initialization in production
        var address = DeploySmartContract(name, category, code, true, Context.Sender, false);

        if (transactionMethodCallList != null)
            foreach (var methodCall in transactionMethodCallList.Value)
                Context.SendInline(address, methodCall.MethodName, methodCall.Params);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L339-342)
```csharp
    public override Empty Initialize(InitializeInput input)
    {
        Assert(!State.Initialized.Value, "Contract zero already initialized.");
        Assert(Context.Sender == Context.Self, "No permission.");
```

**File:** test/AElf.Contracts.Economic.TestBase/ContractsPreparation.cs (L269-294)
```csharp
    private async Task<Address> DeployContract(Contracts contract)
    {
        var code = Codes.Single(kv => kv.Key.Contains(contract.ToString())).Value;
        Hash hash;
        switch (contract)
        {
            case Contracts.Parliament:
                hash = HashHelper.ComputeFrom("AElf.ContractNames.Parliament");
                break;
            case Contracts.AEDPoS:
                hash = HashHelper.ComputeFrom("AElf.ContractNames.Consensus");
                break;
            case Contracts.MultiToken:
                hash = HashHelper.ComputeFrom("AElf.ContractNames.Token");
                break;
            case Contracts.TransactionFee:
                hash = HashHelper.ComputeFrom("AElf.ContractNames.TransactionFeeCharging");
                break;
            default:
                hash = HashHelper.ComputeFrom($"AElf.ContractNames.{contract.ToString()}");
                break;
        }

        var address = await DeploySystemSmartContract(Category, code, hash, BootMinerKeyPair);

        return address;
```

**File:** test/AElf.Contracts.Economic.TestBase/ContractsPreparation.cs (L383-396)
```csharp
    protected async Task InitializeEconomicContract()
    {
        //create native token
        {
            var result = await EconomicContractStub.InitialEconomicSystem.SendAsync(new InitialEconomicSystemInput
            {
                NativeTokenDecimals = EconomicContractsTestConstants.Decimals,
                IsNativeTokenBurnable = EconomicContractsTestConstants.IsBurnable,
                NativeTokenSymbol = EconomicContractsTestConstants.NativeTokenSymbol,
                NativeTokenTotalSupply = EconomicContractsTestConstants.TotalSupply,
                MiningRewardTotalAmount = EconomicContractsTestConstants.TotalSupply / 5
            });
            CheckResult(result.TransactionResult);
        }
```
