# Audit Report

## Title
Race Condition in Round Termination Behavior Causes Consensus Fork Between NextRound and NextTerm

## Summary
Multiple miners calling the view method `GetConsensusCommand` during round termination can receive different consensus behaviors (NextRound vs NextTerm) due to concurrent state changes in `ActualMiningTimes`. The validation logic only verifies structural correctness without re-evaluating whether term change conditions are actually met, allowing incompatible blocks to pass validation and create network forks with different term numbers and miner sets.

## Finding Description

The vulnerability exists in the consensus command generation and validation flow where miners independently query their next action without synchronization.

**Command Generation Flow:**
When miners call `GetConsensusCommand`, it invokes the behavior provider to determine the consensus action [1](#0-0) 

For main chain, the behavior is determined by checking if term change is needed [2](#0-1) 

**Race Condition Source:**
The `NeedToChangeTerm()` method counts how many miners have their latest `ActualMiningTimes` meeting the term threshold (requires ≥ 2/3+1 miners) [3](#0-2) 

The `ActualMiningTimes` field is continuously updated when miners produce blocks through `ProcessUpdateValue` [4](#0-3)  and `ProcessTinyBlock` [5](#0-4) 

**Round Generation Divergence:**
NextRound generates a round with incremented round number but same term [6](#0-5) 

NextTerm generates a round with both incremented round AND term numbers, fetching a new miner list [7](#0-6) [8](#0-7) 

**Insufficient Validation:**
The validation logic only performs structural checks without re-evaluating behavioral correctness. For NextRound, it only verifies round number increment [9](#0-8) 

For NextTerm, it checks both round and term increments but never validates if `NeedToChangeTerm()` should actually return true [10](#0-9) 

**Lack of Exclusive Termination Rights:**
Any miner can attempt round termination when their behavior provider returns termination behavior [11](#0-10) 

There is no validation enforcing that only a specific designated miner can terminate the round [12](#0-11) 

## Impact Explanation

**Consensus Fork with Incompatible States:**
When the threshold is crossed (e.g., exactly 7 of 10 miners meet criteria), miners querying before and after the state change receive different behaviors. Both produce blocks at the same height with:
- Fork A (NextRound): Round R+1, Term T, same miner set
- Fork B (NextTerm): Round R+1, Term T+1, potentially different miner set from Election contract

These forks are fundamentally incompatible because NextTerm changes the validator set and increments term number, while NextRound maintains the existing validator set.

**Network Integrity Compromise:**
- Block finality is delayed as the network resolves the fork through longest-chain selection
- Different nodes may follow different forks based on block propagation timing
- Transactions may be processed on one fork but not the other
- The resolution is non-deterministic (depends on propagation speed), violating consensus invariants

**Operational Disruption:**
- Consensus becomes unstable during term transition periods
- Miners waste resources on losing fork blocks  
- Network partition risk during fork resolution
- May require manual intervention if forks persist

## Likelihood Explanation

**Natural Occurrence (High):**
The vulnerability triggers naturally during every term transition when the 2/3+1 threshold is crossed. As miners continuously update their `ActualMiningTimes` through normal block production, the count naturally fluctuates around the threshold. When exactly at the threshold boundary (e.g., 6 of 10 miners), the next block production flips the state, causing different miners querying at different times to receive conflicting behaviors.

**Intentional Exploitation (Feasible):**
A malicious miner can deliberately time their `UpdateValue` transaction to cause threshold crossing when other miners are preparing termination blocks. By monitoring the network state, they can identify when the system is one miner away from threshold and strategically execute their update to trigger the race condition. The attack requires no special privileges beyond normal miner capabilities.

**Preconditions:**
- Multiple miners near round termination time (inherent to round-based consensus)
- System near 2/3 threshold for term change (occurs naturally each term period)  
- Network latency allowing sequential state queries (always present in distributed systems)

All preconditions are normal operational states, making this vulnerability highly likely to manifest.

## Recommendation

Implement deterministic term change consensus by adding behavioral validation:

1. **Add Behavioral Validation:** In `RoundTerminateValidationProvider.ValidationForNextTerm()`, re-evaluate `NeedToChangeTerm()` against the base round state and reject NextTerm blocks if the condition is not met:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // NEW: Validate that term change is actually required
    if (!validationContext.BaseRound.NeedToChangeTerm(
        GetBlockchainStartTimestamp(), 
        validationContext.CurrentTermNumber, 
        State.PeriodSeconds.Value))
    {
        return new ValidationResult { Message = "Term change conditions not met" };
    }

    return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
        ? new ValidationResult { Message = "Incorrect term number for next round." }
        : new ValidationResult { Success = true };
}
```

2. **Enforce Exclusive Termination:** Validate that only the designated extra block producer for the current round can produce termination blocks, or implement a commit-reveal scheme where miners pre-commit to their termination choice before observing state changes.

## Proof of Concept

The vulnerability cannot be demonstrated with a simple unit test as it requires concurrent execution across multiple miners with precise timing. However, the logical proof is evident from the code:

**Scenario Setup:**
- Current state: Round R=100, Term T=10  
- 6 of 10 miners have ActualMiningTimes meeting term threshold
- MinersCountOfConsent = 7 (2/3+1 of 10)

**Execution Flow:**
1. Miner A calls `GetConsensusCommand` at time T1
   - Reads current state: 6 miners meet threshold
   - `NeedToChangeTerm()` returns false (6 < 7)
   - Receives `NextRound` behavior with Round=101, Term=10

2. Miner B produces block at time T2, updates their `ActualMiningTimes`
   - Now 7 miners meet threshold in state

3. Miner C calls `GetConsensusCommand` at time T3
   - Reads updated state: 7 miners meet threshold  
   - `NeedToChangeTerm()` returns true (7 >= 7)
   - Receives `NextTerm` behavior with Round=101, Term=11

4. Both miners produce blocks at same height H
   - Block A: Round=101, Term=10 (passes validation: 101=100+1 ✓)
   - Block C: Round=101, Term=11 (passes validation: 101=100+1 ✓, 11=10+1 ✓)

5. Network fork created with incompatible consensus states

**Notes**

This vulnerability represents a fundamental flaw in the consensus protocol where view-based queries without state locking combined with insufficient behavioral validation create non-deterministic round transitions. The issue is exacerbated by the lack of exclusive termination rights, allowing any miner to attempt round termination based on their local view of mutable state. This breaks the core consensus invariant that all honest nodes should agree on the next consensus state transition.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L304-304)
```csharp
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L21-23)
```csharp
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L40-42)
```csharp
        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-242)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-83)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
