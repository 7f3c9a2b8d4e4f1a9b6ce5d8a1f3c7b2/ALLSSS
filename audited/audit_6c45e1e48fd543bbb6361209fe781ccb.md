### Title
Context.Sender Dependency in View Functions Breaks Locked Amount Query Consistency

### Summary
The `GetVirtualAddressForLocking` and `GetLockedAmount` view functions include `Context.Sender` in the virtual address computation, causing different callers to receive different results for identical input parameters. This breaks the invariant that locked amounts should be consistent regardless of querier and renders these view functions unusable for external queries.

### Finding Description

The vulnerability exists in the virtual address computation for token locking queries: [1](#0-0) 

The `GetVirtualAddressForLocking` function computes the virtual address by hashing `Context.Sender.Value` concatenated with `input.Address.Value` and `input.LockId.Value`. This design means that the same `Address+LockId` combination produces different virtual addresses depending on who calls the function.

The `GetLockedAmount` view function relies on this flawed computation: [2](#0-1) 

While the `Lock` and `Unlock` operations consistently use `Context.Sender` in their virtual address computations [3](#0-2)  and [4](#0-3) , this is correct for those operations because they enforce that only the locker can unlock.

However, both functions are marked as view functions in the proto definitions: [5](#0-4) [6](#0-5) 

The proto input messages lack a "locker" parameter to specify which contract locked the tokens: [7](#0-6) 

**Root Cause:** View functions should be deterministic and return consistent results for the same input parameters, but these functions implicitly use `Context.Sender` which varies by caller, making them non-deterministic.

**Execution Path:**
1. TokenHolder contract locks 1000 ELF for User Alice with LockId X
   - Virtual address = `Hash(TokenHolder_Address || Alice || X)`
   - Tokens stored at this virtual address
2. User Alice queries `GetLockedAmount(Address=Alice, LockId=X, Symbol=ELF)`
   - `Context.Sender` = Alice's address
   - Virtual address = `Hash(Alice || Alice || X)` ≠ `Hash(TokenHolder_Address || Alice || X)`
   - Returns balance at wrong virtual address (typically 0)
3. dApp queries same parameters to display UI
   - `Context.Sender` = dApp's address
   - Virtual address = `Hash(dApp_Address || Alice || X)` ≠ actual locked address
   - Returns incorrect amount

### Impact Explanation

**Information Inconsistency:**
- External callers (users, dApps, explorers, monitoring systems) cannot correctly query locked token amounts
- Each caller receives a different result for the same query parameters
- Users see incorrect locked balances (typically 0 when tokens are actually locked)

**Broken View Function Semantics:**
- View functions are expected to be read-only and deterministic
- These functions violate this principle by depending on caller identity
- The public RPC interface is effectively non-functional for external use

**Potential for Incorrect Decisions:**
- If any external system or user interface relies on querying locked amounts to make decisions, they will use incorrect data
- Users might attempt operations thinking they have no locked tokens when they actually do
- Third-party integrations cannot reliably query lock states

**Affected Parties:**
- All external users attempting to query their locked balances
- dApps and UIs displaying locked token information
- Blockchain explorers and analytics platforms
- Any cross-contract logic that needs to verify lock states (though current contracts only query their own locks, avoiding the issue)

The only scenario where these functions work correctly is when called by the same contract that performed the locking, as seen in TokenHolderContract usage [8](#0-7) 

### Likelihood Explanation

**Reachability:** 100% - These are public view methods exposed via RPC endpoints, callable by any user or application.

**Preconditions:** None - Any external caller can invoke these functions through the blockchain API.

**Execution Complexity:** Trivial - A simple read-only RPC call triggers the issue.

**Detection:** The issue manifests immediately upon any external query, though it may go unnoticed if users don't understand the locking mechanism or don't check their locked balances.

**Probability:** Certain - Every external query to these functions returns incorrect results unless the caller happens to be the original locker contract.

The vulnerability is not an attack scenario requiring attacker sophistication, but rather a fundamental design flaw that breaks normal, expected usage patterns. Any legitimate user or application attempting to query locked amounts will encounter incorrect results.

### Recommendation

**Code-Level Fix:**

Modify the proto definition to include an explicit `locker` parameter:

```protobuf
message GetVirtualAddressForLockingInput {
    aelf.Address locker = 1;      // The contract that locked the tokens
    aelf.Address address = 2;      // The token owner
    aelf.Hash lock_id = 3;         // The lock identifier
}
```

Update the implementation to use the explicit locker parameter instead of `Context.Sender`:

```csharp
public override Address GetVirtualAddressForLocking(GetVirtualAddressForLockingInput input)
{
    var fromVirtualAddress = HashHelper.ComputeFrom(
        input.Locker.Value
            .Concat(input.Address.Value)
            .Concat(input.LockId.Value)
            .ToArray()
    );
    var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
    return virtualAddress;
}
```

Similarly update `GetLockedAmountInput`:

```protobuf
message GetLockedAmountInput {
    aelf.Address locker = 1;       // The contract that locked the tokens
    aelf.Address address = 2;      // The token owner
    string symbol = 3;             // The token symbol
    aelf.Hash lock_id = 4;         // The lock identifier
}
```

**Invariant Checks:**
- Add documentation clearly specifying that callers must provide the locker contract address
- Add validation that the provided locker address is in the lock whitelist for the queried token

**Test Cases:**
- Test that the same query parameters return identical results regardless of caller identity
- Test that queries with different locker addresses return different results (correct namespace isolation)
- Test external caller scenarios (user, dApp) to ensure they can query locked amounts correctly
- Test that Lock/Unlock still work correctly with the updated function signatures

### Proof of Concept

**Initial State:**
1. TokenHolder contract (address: `0xTokenHolder`) is in the lock whitelist
2. User Alice (address: `0xAlice`) has 10,000 ELF tokens
3. Alice has approved TokenHolder to spend her tokens

**Exploitation Steps:**

**Step 1:** TokenHolder locks 5,000 ELF for Alice
- Transaction: `TokenHolder.Lock(Address=0xAlice, LockId=Hash("lock1"), Symbol="ELF", Amount=5000)`
- `Context.Sender` in MultiToken = `0xTokenHolder`
- Virtual address computed = `Hash(0xTokenHolder || 0xAlice || Hash("lock1"))`
- 5,000 ELF transferred to virtual address
- Alice's balance: 5,000 ELF (5,000 locked at virtual address)

**Step 2:** Alice queries her locked amount
- Query: `GetLockedAmount(Address=0xAlice, LockId=Hash("lock1"), Symbol="ELF")`
- `Context.Sender` = `0xAlice`
- Virtual address computed = `Hash(0xAlice || 0xAlice || Hash("lock1"))` ≠ actual virtual address
- Query returns balance at wrong virtual address

**Expected Result:** 5,000 ELF

**Actual Result:** 0 ELF (or whatever balance exists at the wrong virtual address)

**Step 3:** dApp queries Alice's locked amount for UI display
- Query: `GetLockedAmount(Address=0xAlice, LockId=Hash("lock1"), Symbol="ELF")`
- `Context.Sender` = `0xDApp`
- Virtual address computed = `Hash(0xDApp || 0xAlice || Hash("lock1"))` ≠ actual virtual address
- Query returns incorrect balance

**Expected Result:** 5,000 ELF

**Actual Result:** 0 ELF (different wrong virtual address than Step 2)

**Success Condition:** The vulnerability is confirmed when external callers receive incorrect locked amounts (typically 0) despite tokens being legitimately locked, while the locker contract itself (TokenHolder) can query the correct amount because its `Context.Sender` matches the original locker.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-116)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L118-124)
```csharp
    public override Address GetVirtualAddressForLocking(GetVirtualAddressForLockingInput input)
    {
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        return virtualAddress;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-210)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L234-235)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
```

**File:** protobuf/token_contract.proto (L192-194)
```text
    rpc GetLockedAmount (GetLockedAmountInput) returns (GetLockedAmountOutput) {
        option (aelf.is_view) = true;
    }
```

**File:** protobuf/token_contract_impl.proto (L149-151)
```text
    rpc GetVirtualAddressForLocking (GetVirtualAddressForLockingInput) returns (aelf.Address) {
        option (aelf.is_view) = true;
    }
```

**File:** protobuf/token_contract_impl.proto (L287-292)
```text
message GetVirtualAddressForLockingInput {
    // The address of the lock. 
    aelf.Address address = 1;
    // The id of the lock. 
    aelf.Hash lock_id = 2;
}
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L220-225)
```csharp
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
```
