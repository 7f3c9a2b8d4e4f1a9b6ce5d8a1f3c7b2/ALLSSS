### Title
Incorrect Use of TotalSupply Instead of Supply in GetNeededDeposit Causes Inflated Deposit Requirements

### Summary
The `GetNeededDeposit` function uses `tokenInfo.TotalSupply` instead of `tokenInfo.Supply` to calculate the amount of tokens in external circulation. Since `TotalSupply` represents the maximum issuable amount and never decreases, while `Supply` represents actual circulating tokens and decreases on burn, this causes the function to overcount tokens in circulation whenever tokens are burned or remain unissued. This forces users to deposit significantly more base tokens than necessary when enabling connectors.

### Finding Description

The vulnerability exists in the `GetNeededDeposit` function [1](#0-0) , which calculates:

`amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert`

The issue is that `TotalSupply` is the maximum amount that can be issued (set at token creation) [2](#0-1) , while `Supply` is the actual circulating supply [3](#0-2) .

When tokens are burned, only `Supply` decreases [4](#0-3) , but `TotalSupply` remains constant. The TokenConverter contract itself burns tokens through the `HandleFee` function [5](#0-4) .

The inflated `amountOutOfTokenConvert` value is then used in the Bancor formula [6](#0-5)  to calculate `needDeposit`, which determines how much base token users must deposit in `EnableConnector` [7](#0-6) .

### Impact Explanation

**Economic Impact**: Users enabling connectors must deposit excessive base tokens. The overcount equals `(TotalSupply - Supply)`, which grows as tokens are burned or remain unissued.

**Quantified Example**: If a token has `TotalSupply = 1000`, `Supply = 600` (400 burned/unissued), contract `balance = 300`, and `AmountToTokenConvert = 200`:
- Wrong calculation: `1000 - 300 - 200 = 500` tokens externally
- Correct calculation: `600 - 300 - 200 = 100` tokens externally  
- Result: **5x more deposit required than necessary**

**Who is Affected**: Any user attempting to enable a connector for a token where `Supply < TotalSupply`, including:
- New token listings on the converter
- Tokens with burn mechanisms (including the base token ELF which burns fees [8](#0-7) )

**Severity**: If the gap is large enough, the deposit requirement could be prohibitively expensive, effectively preventing tokens from being listed on the converter and locking excess capital.

### Likelihood Explanation

**Attacker Capabilities**: No special privileges required. Any user calling `EnableConnector` is affected. An attacker could burn tokens to widen the `TotalSupply - Supply` gap, but this costs them their tokens.

**Attack Complexity**: Not an active attack but a systemic issue. The vulnerability triggers automatically whenever:
1. Tokens are burned (via `HandleFee` during Buy/Sell operations or user burns)
2. Tokens remain unissued (issuer hasn't issued up to `TotalSupply`)

**Feasibility**: High probability. Tokens are burned on every Buy/Sell transaction via the fee mechanism. Many tokens intentionally have high `TotalSupply` with gradual issuance schedules.

**Detection**: Users will notice abnormally high deposit requirements but may attribute it to the Bancor pricing model rather than a calculation error.

### Recommendation

**Code-level Fix**: Change line 73 in `TokenConvert_Views.cs` to use `Supply` instead of `TotalSupply`:

```csharp
var amountOutOfTokenConvert = tokenInfo.Supply - balance - input.AmountToTokenConvert;
```

**Invariant Check**: Add assertion to verify that `Supply >= balance + input.AmountToTokenConvert` to prevent underflow.

**Test Cases**: Add tests covering:
1. Scenario where tokens are burned before `EnableConnector`
2. Scenario where only partial `TotalSupply` is issued
3. Verify deposit calculation matches actual external token circulation

### Proof of Concept

**Initial State**:
1. Create token "TEST" with `TotalSupply = 1000` [9](#0-8) 
2. Issue only 600 tokens (400 remain unissued)
3. Burn 100 tokens → `Supply = 500`
4. Transfer 300 tokens to TokenConverter contract → `balance = 300`
5. External holdings = 200 (= `Supply - balance`)

**Transaction Steps**:
1. Call `AddPairConnector` for "TEST" token
2. Call `GetNeededDeposit` with `TokenSymbol = "TEST"`, `AmountToTokenConvert = 100`

**Expected Result** (correct formula):
- `amountOutOfTokenConvert = Supply - balance - AmountToTokenConvert = 500 - 300 - 100 = 100`
- Deposit calculated for 100 tokens of external circulation

**Actual Result** (current formula):
- `amountOutOfTokenConvert = TotalSupply - balance - AmountToTokenConvert = 1000 - 300 - 100 = 600`  
- Deposit calculated for 600 tokens (overcounting by 500)
- **6x higher deposit requirement**

**Success Condition**: The function returns a `needDeposit` amount that is 6x higher than necessary, directly proportional to the `(TotalSupply - Supply)` gap.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-73)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L81-83)
```csharp
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
```

**File:** protobuf/token_contract.proto (L255-256)
```text
    // The current supply of the token.
    int64 supply = 3;
```

**File:** protobuf/token_contract.proto (L257-258)
```text
    // The total supply of the token.
    int64 total_supply = 4;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L328-328)
```csharp
        tokenInfo.Supply = tokenInfo.Supply.Sub(amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L252-257)
```csharp
        State.TokenContract.Burn.Send(
            new BurnInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                Amount = burnFee
            });
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L276-285)
```csharp
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConverterTestBase.cs (L59-59)
```csharp
                IsBurnable = true,
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConvertConnectorTest.cs (L505-517)
```csharp
    private async Task CreateTokenAsync(string symbol, long totalSupply = 100_0000_0000)
    {
        await ExecuteProposalForParliamentTransaction(TokenContractAddress, nameof(TokenContractStub.Create),
            new CreateInput
            {
                Symbol = symbol,
                TokenName = symbol + " name",
                TotalSupply = totalSupply,
                Issuer = DefaultSender,
                Owner = DefaultSender,
                IsBurnable = true,
                LockWhiteList = { TokenContractAddress, TokenConverterContractAddress }
            });
```
