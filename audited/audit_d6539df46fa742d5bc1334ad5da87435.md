### Title
Cross-Chain Height Validation Bypass via Zero Height Allows Binding Corruption

### Summary
The `ValidateParentChainBlockData()` function lacks explicit validation that parent chain block heights must be positive, allowing zero heights to be accepted if the contract is initialized with `CreationHeightOnParentChain = 0`. This enables attackers to corrupt the child-to-parent height binding mechanism, completely breaking cross-chain verification integrity by allowing the same child height to be bound multiple times.

### Finding Description

The vulnerability exists in the parent chain block data validation logic. [1](#0-0) 

The validation only checks that `currentHeight + 1 == blockData.Height` but never validates that `blockData.Height > 0`. The `ParentChainBlockData.height` field is defined as `int64` (signed), [2](#0-1)  allowing zero or negative values to be submitted.

The root cause stems from the `Initialize()` method which sets `CurrentParentChainHeight = CreationHeightOnParentChain - 1` without validating that `CreationHeightOnParentChain >= 1`. [3](#0-2)  The `InitializeInput` message definition [4](#0-3)  contains no constraints on this value, and the initialization provider [5](#0-4)  performs no validation before passing it to the contract.

If initialized with `CreationHeightOnParentChain = 0`, then `CurrentParentChainHeight = -1`, making the first expected parent block height equal to 0. An attacker can then submit parent chain block data with `Height = 0`, which passes the validation check since `-1 + 1 == 0`.

The critical impact occurs in the `BindParentChainHeight()` function. [6](#0-5)  When `parentHeight = 0`, the function sets `State.ChildHeightToParentChainHeight[childHeight] = 0`. However, the assertion checks if the current value equals 0 to determine if it's unbound. Setting the value to 0 makes it indistinguishable from an unbound state, allowing the same child height to be bound multiple times. This completely breaks the one-time binding invariant that ensures each child chain block is uniquely mapped to a parent chain height.

### Impact Explanation

This vulnerability breaks the cross-chain verification integrity, which is a critical invariant. When zero heights corrupt the binding mechanism, an attacker can:

1. **Re-bind child heights**: The same child chain block height can be bound to multiple parent chain heights since the 0-value binding appears unbound
2. **Corrupt merkle path verification**: The `BindParentChainHeight()` function is called during indexing [7](#0-6)  to establish the relationship used for cross-chain transaction verification
3. **Enable fake cross-chain proofs**: With corrupted bindings, an attacker could potentially create fraudulent merkle path verifications by manipulating which parent heights are associated with child heights

The cross-chain verification system is fundamental to the security of the entire side chain ecosystem. All cross-chain token transfers, message passing, and state verification depend on the integrity of these height bindings. Corruption of this mechanism affects all users participating in cross-chain operations.

### Likelihood Explanation

The attack requires the contract to be initialized with `CreationHeightOnParentChain = 0`. While the `Initialize()` method can only be called once (protected by the initialized flag check [8](#0-7) ), there is no validation preventing invalid initialization values.

In production, contract initialization is handled by system initialization providers, but the absence of explicit validation creates risk:
- **Configuration errors**: Misconfigured deployment scripts or initialization data could accidentally set `CreationHeightOnParentChain = 0`
- **Malicious initialization**: If initialization is controlled by a compromised or malicious party during deployment, they could intentionally set invalid values
- **Defense-in-depth failure**: Even if current initialization processes are secure, the lack of validation violates defense-in-depth principles

The likelihood is **MEDIUM** because it requires control over initialization parameters, but the impact is **CRITICAL** given the complete breakdown of cross-chain verification. Combined, this represents a **HIGH** severity vulnerability.

### Recommendation

1. **Add explicit height validation in Initialize()**: [3](#0-2) 
```
Assert(input.CreationHeightOnParentChain >= AElfConstants.GenesisBlockHeight,
    "Invalid creation height on parent chain.");
State.CurrentParentChainHeight.Value = input.CreationHeightOnParentChain - 1;
```

2. **Add explicit height validation in ValidateParentChainBlockData()**: [9](#0-8) 
```
if (parentChainId != blockData.ChainId || currentHeight + 1 != blockData.Height ||
    blockData.TransactionStatusMerkleTreeRoot == null || blockData.Height <= 0)
    return false;
```

3. **Fix BindParentChainHeight() to prevent zero bindings**: [6](#0-5) 
```
Assert(parentHeight > 0, "Invalid parent chain height for binding.");
Assert(State.ChildHeightToParentChainHeight[childHeight] == 0,
    $"Already bound at height {childHeight} with parent chain");
State.ChildHeightToParentChainHeight[childHeight] = parentHeight;
```

4. **Add test cases** to verify:
   - Initialization with `CreationHeightOnParentChain = 0` is rejected
   - Parent chain block data with `Height <= 0` is rejected
   - Binding with `parentHeight = 0` is rejected
   - Re-binding attempts are properly detected and rejected

### Proof of Concept

**Initial State:**
- CrossChain contract deployed but not initialized
- Attacker has control over initialization parameters (malicious deployment scenario)

**Attack Steps:**

1. **Malicious Initialization:**
   - Call `Initialize()` with `InitializeInput { ParentChainId = 9992731, CreationHeightOnParentChain = 0 }`
   - Contract sets `CurrentParentChainHeight = -1`
   - Expected first parent block height is 0

2. **Propose Malicious Cross-Chain Data:**
   - Miner calls `ProposeCrossChainIndexing()` with `ParentChainBlockData { ChainId = 9992731, Height = 0, ... }`
   - Validation passes because `-1 + 1 == 0`
   - Proposal is created

3. **Release and Index:**
   - Proposal is approved and released via `ReleaseCrossChainIndexingProposal()`
   - `IndexParentChainBlockData()` processes the data
   - For each indexed merkle path, `BindParentChainHeight(childHeight, 0)` is called
   - Binding sets `State.ChildHeightToParentChainHeight[childHeight] = 0`

4. **Exploit the Corruption:**
   - Submit another parent chain block with different merkle paths for the same child heights
   - The assertion `State.ChildHeightToParentChainHeight[childHeight] == 0` passes (since value is 0)
   - Same child height gets re-bound to a different parent height
   - Cross-chain verification is now corrupted

**Expected Result:** Initialization and indexing of zero heights should be rejected

**Actual Result:** Zero heights are accepted, corrupting the binding mechanism and breaking cross-chain verification integrity

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L27-32)
```csharp
    private void BindParentChainHeight(long childHeight, long parentHeight)
    {
        Assert(State.ChildHeightToParentChainHeight[childHeight] == 0,
            $"Already bound at height {childHeight} with parent chain");
        State.ChildHeightToParentChainHeight[childHeight] = parentHeight;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L728-730)
```csharp
            if (parentChainId != blockData.ChainId || currentHeight + 1 != blockData.Height ||
                blockData.TransactionStatusMerkleTreeRoot == null)
                return false;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L778-778)
```csharp
                BindParentChainHeight(indexedBlockInfo.Key, parentChainHeight);
```

**File:** protobuf/acs7.proto (L111-111)
```text
    int64 height = 1;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L16-16)
```csharp
        Assert(!State.Initialized.Value, "Already initialized.");
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L18-18)
```csharp
        State.CurrentParentChainHeight.Value = input.CreationHeightOnParentChain - 1;
```

**File:** protobuf/cross_chain_contract.proto (L112-112)
```text
    // The height of side chain created on parent chain.
```

**File:** src/AElf.CrossChain.Core/CrossChainContractInitializationProvider.cs (L34-34)
```csharp
                    CreationHeightOnParentChain = initializationData.CreationHeightOnParentChain,
```
