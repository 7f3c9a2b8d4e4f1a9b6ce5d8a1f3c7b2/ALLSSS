### Title
NFT Contract Burn Function Allows Unauthorized Token Minting via Negative Amount Input

### Summary
The `Burn()` function in the NFT contract lacks input validation to ensure `input.Amount` is positive. This allows minters to pass negative amounts, which causes the SafeMath `.Sub()` operations to effectively add tokens instead of removing them, bypassing all mint authorization checks and supply limits. This breaks the fundamental invariant that burning should reduce token supply, not increase it.

### Finding Description

The root cause is at [1](#0-0) 

The `Burn()` function performs the following checks and operations:
1. Lines 87-88: Verifies the protocol is burnable
2. Lines 90-93: Asserts `State.BalanceMap[tokenHash][Context.Sender] >= input.Amount` AND sender is a minter
3. Line 94: Executes `State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount)`
4. Line 95: Executes `nftProtocolInfo.Supply.Sub(input.Amount)`
5. Line 96: Executes `nftInfo.Quantity.Sub(input.Amount)`

**The critical flaw**: When `input.Amount` is negative (e.g., -1000):
- The assertion at line 91 passes because any balance ≥ -1000 evaluates to true
- The `.Sub(-1000)` operations at lines 94-96 become `balance - (-1000) = balance + 1000`, **increasing** values instead of decreasing them

This is confirmed by the SafeMath implementation: [2](#0-1) 

The `.Sub()` method uses checked arithmetic but does NOT validate sign - it only prevents overflow/underflow of the arithmetic operation itself.

**Why existing protections fail**:
- The balance check `>= input.Amount` is designed for positive amounts and fails to reject negatives
- No input validation exists before the assertions (unlike MultiToken contract)
- The protobuf definition allows `int64` which includes negative values: [3](#0-2) 

**Comparison with MultiToken contract** (the correct implementation):
The MultiToken `Burn()` function properly validates input: [4](#0-3) 

It calls `AssertValidToken()` at line 325, which validates: [5](#0-4) 

This explicitly checks `Assert(amount > 0, "Invalid amount.")` - a check that is **completely missing** in the NFT contract.

### Impact Explanation

**Direct Fund Impact - Token Inflation**:
1. A minter can mint unlimited tokens to themselves by calling `Burn()` with negative amounts, bypassing the proper `Mint()` function
2. The legitimate `Mint()` function enforces `protocolInfo.Issued <= protocolInfo.TotalSupply`: [6](#0-5) 
3. The malicious burn bypasses this check, allowing Supply to exceed TotalSupply
4. Example: With TotalSupply=1000, Issued=800, Supply=800, burning -500 results in Supply=1300, violating the supply cap by 30%

**Who is affected**:
- NFT protocol creators who set supply limits expecting them to be enforced
- NFT holders whose tokens are diluted by unauthorized inflation
- Secondary markets and price discovery mechanisms relying on accurate supply data

**Severity justification**: 
- **Critical** - Allows privilege escalation from limited minting rights to unlimited minting
- Breaks core token supply invariants
- Enables economic attack (token value dilution)
- The minted tokens are fully functional and transferable

### Likelihood Explanation

**Reachable Entry Point**: Public method `Burn()` at line 82

**Attacker Capabilities Required**:
- Must be in the minter list for the target NFT protocol (checked at line 92)
- While minters are privileged, they are intended to mint through `Mint()` with enforced limits
- This represents privilege escalation, not normal minter behavior

**Attack Complexity**: Trivial
1. Call `Burn(BurnInput { Symbol = "TARGET", TokenId = X, Amount = -1000 })`
2. Instant execution, no timing requirements
3. No complex state setup needed

**Execution Practicality**: 
- Fully executable under AElf contract semantics
- The `.Sub()` method will execute successfully with negative input
- No VM-level restrictions prevent this

**Detection**: 
- The `Burned` event fires with the negative amount, which would appear anomalous in logs
- However, detection after-the-fact doesn't prevent the damage

**Economic Rationality**: 
- Zero cost attack for a minter
- High reward: unlimited token creation
- Rational for malicious or compromised minter accounts

### Recommendation

**Immediate Fix**: Add input validation at the start of the `Burn()` function:

```csharp
public override Empty Burn(BurnInput input)
{
    Assert(input.Amount > 0, "Invalid burn amount. Amount must be positive.");
    // ... existing code
}
```

**Alternative approach**: Reuse the validation pattern from MultiToken contract by creating a shared helper method.

**Invariant checks to add**:
1. Validate all amount inputs are positive at function entry
2. Consider adding post-condition checks: `Assert(newSupply < oldSupply, "Burn must reduce supply")`

**Test cases to prevent regression**:
1. Test burning with amount = -1 (should revert)
2. Test burning with amount = -1000000 (should revert)
3. Test burning with amount = 0 (define desired behavior - currently allowed)
4. Verify Supply, Quantity, and Balance decrease after legitimate burns
5. Integration test: Verify Supply cannot exceed TotalSupply through any code path

### Proof of Concept

**Initial State**:
- NFT Protocol "TEST" exists with TotalSupply = 1000, IsBurnable = true
- NFT Token "TEST"-1 has been minted with Quantity = 100, Supply = 100
- Attacker is in minter list for "TEST"
- Attacker's balance of "TEST"-1 = 10

**Attack Steps**:
1. Attacker calls `Burn(BurnInput { Symbol = "TEST", TokenId = 1, Amount = -1000 })`

**Expected Result** (if properly validated):
- Transaction reverts with "Invalid amount" or similar error

**Actual Result** (current vulnerable code):
- Line 91: Assertion passes (10 >= -1000 ✓, attacker is minter ✓)
- Line 94: Attacker's balance becomes 10 - (-1000) = 1010 tokens
- Line 95: Protocol Supply becomes 100 - (-1000) = 1100 (exceeds TotalSupply!)
- Line 96: Token Quantity becomes 100 - (-1000) = 1100
- Transaction succeeds
- `Burned` event emitted with Amount = -1000

**Success Condition**: 
- Attacker balance increased by 1000 instead of decreased
- Supply exceeded TotalSupply limit
- Token economics fundamentally broken

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L402-406)
```csharp
        var quantity = input.Quantity > 0 ? input.Quantity : 1;
        protocolInfo.Supply = protocolInfo.Supply.Add(quantity);
        protocolInfo.Issued = protocolInfo.Issued.Add(quantity);
        Assert(protocolInfo.Issued <= protocolInfo.TotalSupply, "Total supply exceeded.");
        State.NftProtocolMap[input.Symbol] = protocolInfo;
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** protobuf/nft_contract.proto (L182-186)
```text
message BurnInput {
    string symbol = 1;
    int64 token_id = 2;
    int64 amount = 3;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L318-337)
```csharp
    public override Empty Burn(BurnInput input)
    {
        return Burn(Context.Sender, input.Symbol, input.Amount);
    }

    private Empty Burn(Address address, string symbol, long amount)
    {
        var tokenInfo = AssertValidToken(symbol, amount);
        Assert(tokenInfo.IsBurnable, "The token is not burnable.");
        ModifyBalance(address, symbol, -amount);
        tokenInfo.Supply = tokenInfo.Supply.Sub(amount);

        Context.Fire(new Burned
        {
            Burner = address,
            Symbol = symbol,
            Amount = amount
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```
