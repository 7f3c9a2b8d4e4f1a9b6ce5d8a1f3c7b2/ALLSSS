### Title
Missing Validation of ExtraBlockProducerOfPreviousRound Enables Fake Extra Block Attribution

### Summary
The `NextRoundInput.Create()` method and associated validation logic fail to verify that `ExtraBlockProducerOfPreviousRound` exists in the previous round's `RealTimeMinersInformation`, allowing a malicious miner to claim fake extra block producer status and gain unfair mining privileges and rewards.

### Finding Description

**Root Cause:**

The `NextRoundInput.Create()` method blindly copies the `ExtraBlockProducerOfPreviousRound` field without validation: [1](#0-0) 

When a NextRound block is produced, `GetConsensusExtraDataForNextRound` sets this field to the sender's pubkey: [2](#0-1) 

However, critical validation gaps exist:

1. **Not included in hash validation**: The `GetCheckableRound()` method used for hash comparison excludes `ExtraBlockProducerOfPreviousRound`: [3](#0-2) 

2. **No explicit existence check**: Grep search confirms no validation checks `previousRound.RealTimeMinersInformation.ContainsKey(ExtraBlockProducerOfPreviousRound)` exists in the codebase.

3. **Validation providers insufficient**: The NextRound validators only check round number increment and null InValues: [4](#0-3) [5](#0-4) 

**Exploitation Path:**

A malicious miner producing a NextRound block can modify the `ExtraBlockProducerOfPreviousRound` field in the consensus header to any value (their own pubkey or a non-existent one) before broadcasting. Since this field is not validated against the previous round's miner list and is not included in the hash verification, the modified block passes all validation checks.

### Impact Explanation

**Direct Mining Privilege Abuse:**

The fake `ExtraBlockProducerOfPreviousRound` grants special consensus privileges in the next round: [6](#0-5) [7](#0-6) 

**Unfair Reward Allocation:**

Extra blocks produced translate directly to higher mining rewards. The reward calculation is based on total blocks mined: [8](#0-7) [9](#0-8) 

An attacker gaining extra block production slots can produce up to `maximumBlocksCount` additional blocks before the round starts, directly increasing their share of mining rewards at the expense of honest miners. With typical mining rewards in the hundreds of thousands of tokens per term, even a 10% increase in blocks (via fake extra block status) represents significant economic theft.

### Likelihood Explanation

**Attack Requirements:**
- Attacker must be a legitimate miner in the current round (realistic for any miner)
- Attacker must win the right to produce a NextRound block (happens naturally in rotation)
- Attacker can modify consensus header data before broadcasting (standard blockchain attack vector)

**Attack Complexity:** Low
- Single field modification in block header
- No complex state manipulation required
- No need to compromise other parties

**Detection Difficulty:** High
- No on-chain validation catches this
- Field appears legitimate (valid pubkey format)
- Only detectable through off-chain round transition analysis comparing actual vs claimed extra block producers

**Economic Rationality:** Highly rational
- Zero additional cost beyond normal block production
- Direct reward increase proportional to extra blocks
- Risk of detection is low due to lack of validation
- Can be repeated every time attacker produces NextRound block

### Recommendation

**Immediate Fix:**

Add explicit validation in `ProcessNextRound` to verify the `ExtraBlockProducerOfPreviousRound` exists in the previous round:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    // VALIDATION: Verify ExtraBlockProducerOfPreviousRound exists in previous round
    if (!string.IsNullOrEmpty(nextRound.ExtraBlockProducerOfPreviousRound))
    {
        TryToGetPreviousRoundInformation(out var previousRound);
        Assert(
            previousRound != null && 
            previousRound.RealTimeMinersInformation.ContainsKey(nextRound.ExtraBlockProducerOfPreviousRound),
            "ExtraBlockProducerOfPreviousRound must exist in previous round's miner list."
        );
    }
    
    RecordMinedMinerListOfCurrentRound();
    // ... rest of method
}
```

**Additional Hardening:**

1. Include `ExtraBlockProducerOfPreviousRound` in `GetCheckableRound()` hash calculation to prevent tampering
2. Add a validation provider specifically for ExtraBlockProducerOfPreviousRound verification
3. Add regression tests that attempt to set fake ExtraBlockProducerOfPreviousRound values

### Proof of Concept

**Initial State:**
- Previous round (R100) has miners: {MinerA, MinerB, MinerC}
- Current round (R101) has miners: {MinerA, MinerB, MinerC, MinerD}
- MinerD is new and was NOT in round R100

**Attack Sequence:**

1. MinerD produces NextRound block to transition from R101 to R102
2. `GetConsensusExtraDataForNextRound` sets `ExtraBlockProducerOfPreviousRound = MinerD`
3. MinerD broadcasts block with this header
4. Validation passes because:
   - `ValidateBeforeExecution`: No check for ExtraBlockProducerOfPreviousRound existence
   - `ValidateAfterExecution`: Hash comparison excludes ExtraBlockProducerOfPreviousRound
5. Round R102 begins with `ExtraBlockProducerOfPreviousRound = MinerD`
6. In R102, when determining consensus behavior for MinerD:
   - Check at line 71: `CurrentRound.ExtraBlockProducerOfPreviousRound == MinerD` â†’ TRUE
   - MinerD granted extra tiny block production slots
   - MinerD produces additional blocks beyond fair allocation
7. MinerD's `ProducedBlocks` counter increases unfairly
8. At term transition, mining rewards calculated include MinerD's inflated block count
9. MinerD receives disproportionate share of mining rewards

**Expected Result:** Validation should reject NextRound with ExtraBlockProducerOfPreviousRound not in previous round

**Actual Result:** Block accepted, fake extra block producer status granted, unfair rewards distributed

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L124-127)
```csharp
    public long GetMinedBlocks()
    {
        return RealTimeMinersInformation.Values.Sum(minerInRound => minerInRound.ProducedBlocks);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L71-79)
```csharp
                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```
