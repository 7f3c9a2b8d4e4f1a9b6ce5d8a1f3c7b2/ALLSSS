### Title
Information Disclosure of Consensus Cryptographic Values Through Validation Error Messages

### Summary
The `ValidateInformation()` method at line 22 returns validation providers' error messages unchanged, which can contain full Round object serialization including sensitive consensus cryptographic values (InValue, OutValue, Signature, PreviousInValue). These error messages propagate through the public `ValidateConsensusBeforeExecution()` method, exposing internal consensus state to external observers. [1](#0-0) 

### Finding Description

The vulnerability exists in a chain of error message propagation:

1. **Entry Point**: `ValidateConsensusBeforeExecution()` is a public view method that calls `ValidateBeforeExecution()`: [2](#0-1) 

2. **Validation Service**: `ValidateBeforeExecution()` invokes the validation service which returns provider results unchanged: [3](#0-2) 

3. **Critical Path**: `TimeSlotValidationProvider` calls `CheckRoundTimeSlots()` on the provided round: [4](#0-3) 

4. **Root Cause**: `CheckRoundTimeSlots()` returns error messages containing full Round serialization via `{this}`: [5](#0-4) 

5. **Data Exposure**: `Round.ToString()` implementation exposes all consensus cryptographic values: [6](#0-5) 

The Round object contains sensitive consensus information for all miners: [7](#0-6) 

The validation result is defined with a public message field: [8](#0-7) 

### Impact Explanation

**Information Disclosed:**
- **InValue**: Consensus secret value used for random number generation and miner validation
- **OutValue**: Cryptographic value derived from InValue
- **Signature**: Consensus signature computed from InValue and previous signatures
- **PreviousInValue**: Previous round's InValue
- Exposed for all miners in the round, not just the sender

**Concrete Harm:**
1. **Consensus Pattern Analysis**: Attackers can analyze consensus cryptographic values to understand miner behavior and protocol implementation details
2. **Premature State Disclosure**: Internal consensus state is exposed before normal block acceptance, violating minimal information disclosure principles
3. **Attack Surface Expansion**: Detailed error messages provide attackers with intelligence about consensus mechanism internals that could facilitate more sophisticated attacks
4. **Protocol Implementation Leakage**: Reveals how consensus values are structured and computed, aiding reverse engineering efforts

**Affected Parties:**
- All network participants whose consensus data appears in failed validation attempts
- The protocol's security posture through unnecessary information disclosure

**Severity Justification (Medium):**
- No direct fund theft or privilege escalation
- Does not expose private keys (InValue is a consensus secret, not a private key)
- Information disclosed is from failed/invalid blocks that won't be accepted
- However, violates security best practices and could enable reconnaissance for future attacks

### Likelihood Explanation

**Attacker Capabilities:**
- Any participant can call the public `ValidateConsensusBeforeExecution()` view method
- Attacker can craft consensus extra data with invalid time slot configurations
- No special privileges required

**Attack Complexity:**
- **Trigger Condition 1**: Craft a NextRound transaction where any miner has null `ExpectedMiningTime`
- **Trigger Condition 2**: Craft a NextRound transaction where mining interval ≤ 0
- Both are simple to construct and submit

**Feasibility:**
The attack is highly feasible because:
1. `ValidateConsensusBeforeExecution()` is marked as view (no state changes, no gas cost for queries)
2. An attacker can repeatedly craft invalid consensus data to trigger error paths
3. Legitimate implementation bugs could also accidentally trigger these error messages, exposing data unintentionally

**Detection/Operational Constraints:**
- View method calls may not be logged on-chain
- Error messages are returned directly to callers
- No rate limiting on view method calls
- Legitimate validation failures from buggy nodes would also leak this information

**Probability Assessment:**
High probability of exploitation for reconnaissance purposes, though direct impact is limited to information disclosure rather than fund loss or system compromise.

### Recommendation

**Immediate Fix:**
Sanitize error messages in `CheckRoundTimeSlots()` to remove full Round serialization:

```csharp
// In Round.cs, lines 40-47
if (miners.Any(m => m.ExpectedMiningTime == null))
    return new ValidationResult { Message = "Incorrect expected mining time." }; // Remove {this}

if (baseMiningInterval <= 0)
    return new ValidationResult { Message = "Mining interval must be greater than 0." }; // Remove {this}
```

**Additional Hardening:**
1. **Audit All ValidationResult Messages**: Review all validation providers to ensure no sensitive data appears in error messages: [9](#0-8) 

2. **Implement Message Sanitization Layer**: Add a sanitization method in `HeaderInformationValidationService` before returning results:
```csharp
private ValidationResult SanitizeValidationResult(ValidationResult result)
{
    if (!result.Success && !string.IsNullOrEmpty(result.Message))
    {
        // Ensure message doesn't contain sensitive consensus data
        // Log full details internally, return generic message externally
    }
    return result;
}
```

3. **Separate Logging from Public Messages**: Maintain detailed error information for internal logging while returning sanitized messages to callers

4. **Test Cases**: Add unit tests verifying that validation error messages do not contain:
   - Cryptographic values (InValue, OutValue, Signature)
   - Full object serializations
   - Implementation-specific details

### Proof of Concept

**Initial State:**
- AEDPoS consensus is running with multiple miners
- Current round number is N, term number is T

**Attack Sequence:**

1. **Craft Invalid Round Data:**
   - Create a Round object with RoundNumber = N+1
   - Set one miner's `ExpectedMiningTime` to null OR
   - Set mining intervals such that interval ≤ 0

2. **Package as Consensus Extra Data:**
   - Create `AElfConsensusHeaderInformation` with:
     - Behaviour = `AElfConsensusBehaviour.NextRound`
     - Round = crafted invalid round
     - SenderPubkey = attacker's public key

3. **Invoke Validation:**
   - Call `ValidateConsensusBeforeExecution(BytesValue)` with serialized header information
   - This is a view method, so can be called without transaction cost

**Expected Result:**
- Validation should fail with generic error: "Incorrect expected mining time."

**Actual Result:**
- Validation fails with error message containing full Round serialization:
  ```
  "Incorrect expected mining time.\n[Round Details with OutValue, InValue, Signature for all miners]"
  ```

**Success Condition:**
- Attacker receives ValidationResult.Message containing:
  - `Out: [hex values]`
  - `In: [hex values]`
  - `Sig: [hex values]`
  - `PreIn: [hex values]`
  For all miners in the round, as formatted by Round_GetLogs.cs ToString() method

**Demonstration:**
The attacker can observe internal consensus cryptographic values that should not be exposed in error messages, violating the principle of minimal information disclosure and providing reconnaissance data about the consensus mechanism's internal state.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ValidationService.cs (L16-26)
```csharp
    public ValidationResult ValidateInformation(ConsensusValidationContext validationContext)
    {
        foreach (var headerInformationValidationProvider in _headerInformationValidationProviders)
        {
            var result =
                headerInformationValidationProvider.ValidateHeaderInformation(validationContext);
            if (!result.Success) return result;
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L94-103)
```csharp
        var service = new HeaderInformationValidationService(validationProviders);

        Context.LogDebug(() => $"Validating behaviour: {extraData.Behaviour.ToString()}");

        var validationResult = service.ValidateInformation(validationContext);

        if (validationResult.Success == false)
            Context.LogDebug(() => $"Consensus Validation before execution failed : {validationResult.Message}");

        return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-19)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L40-47)
```csharp
        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_GetLogs.cs (L50-55)
```csharp
            minerInformation = minerInformation.AppendLine($"Out:\t {minerInRound.OutValue?.ToHex()}");
            if (RoundNumber != 1)
                minerInformation = minerInformation.AppendLine($"PreIn:\t {minerInRound.PreviousInValue?.ToHex()}");

            minerInformation = minerInformation.AppendLine($"In:\t {minerInRound.InValue?.ToHex()}");
            minerInformation = minerInformation.AppendLine($"Sig:\t {minerInRound.Signature?.ToHex()}");
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** protobuf/acs4.proto (L58-65)
```text
message ValidationResult {
    // Is successful.
    bool success = 1;
    // The error message.
    string message = 2;
    // Whether to trigger mining again.
    bool is_re_trigger = 3;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
