### Title
Cross-Contract Call Validation Bypass in Method Fee Controller Change

### Summary
The `ChangeMethodFeeController` function trusts an attacker-controlled contract address to validate organization existence. A malicious contract can return a fake validation result, allowing governance bypass by setting the method fee controller to a non-governance address that bypasses proper organizational approval mechanisms.

### Finding Description

The vulnerability exists in the `CheckOrganizationExist` helper function which performs a cross-contract call to validate organization existence: [1](#0-0) 

This function is called by `ChangeMethodFeeController` to validate the new authority: [2](#0-1) 

**Root Cause:** The `authorityInfo.ContractAddress` parameter is user-supplied through the `input` parameter. The contract makes a `Context.Call` to this arbitrary address and trusts the returned `BoolValue` to validate that the organization exists. A malicious contract deployed by an attacker can implement `ValidateOrganizationExist` to always return `true`, regardless of whether a legitimate organization exists.

**Why Protections Fail:** While legitimate governance contracts (Parliament, Association, Referendum) correctly implement this method by checking their organization state mappings: [3](#0-2) [4](#0-3) 

There is **no validation** that `authorityInfo.ContractAddress` actually points to one of these trusted governance contracts. The code accepts any contract address and trusts its response.

**Systemic Issue:** This same vulnerable pattern exists across multiple critical system contracts:
- Genesis contract for contract deployment/code check controllers: [5](#0-4) 
- CrossChain contract for side chain lifecycle control: [6](#0-5) 
- Six additional MultiToken controller functions: [7](#0-6) 

### Impact Explanation

**Auth/Governance Impact - HIGH SEVERITY:**

1. **Complete Governance Bypass:** Once the method fee controller is set to a malicious organization, future calls to `SetMethodFee` only check if the sender matches the controller's owner address, with no governance validation: [8](#0-7) 

2. **Protocol-Wide Authority Compromise:** The same vulnerability affects:
   - **Contract Deployment Authority:** Attackers can deploy arbitrary contracts without governance approval
   - **Code Check Authority:** Attackers can bypass code validation requirements  
   - **Cross-Chain Authority:** Attackers can control side chain lifecycle operations
   - **Fee Controllers:** Attackers can manipulate transaction fees, user fees, developer fees, side chain rental fees, and transfer blacklists

3. **Critical Invariant Violation:** This breaks the fundamental security invariant: "Organization thresholds, proposer whitelist checks, proposal lifetime/expiration, correct organization hash resolution, method-fee provider authority" must be properly validated.

4. **Affected Parties:** All protocol users are affected as governance controls protect the economic security and operational integrity of the entire blockchain.

### Likelihood Explanation

**HIGH Likelihood:**

1. **Reachable Entry Point:** `ChangeMethodFeeController` is a public method accessible through governance proposals.

2. **Feasible Preconditions:** 
   - Attacker deploys a malicious contract implementing `ValidateOrganizationExist` to return `true`
   - Attacker creates a governance proposal with the malicious `AuthorityInfo` containing their contract address
   - The proposal parameters may appear legitimate to voters who don't inspect the contract address
   - Proposal gets approved through normal governance process

3. **Execution Practicality:** 
   - Malicious contract deployment is straightforward
   - Proposal creation follows standard governance flow
   - No unusual transaction sequencing required
   - Fully compatible with AElf contract execution model

4. **Economic Rationality:**
   - Low cost: Only requires contract deployment and proposal creation fees
   - High reward: Complete control over critical system parameters
   - Detection difficulty: Malicious contract address in proposal parameters may go unnoticed during voting

5. **Realistic Attack Scenario:** Governance voters may not thoroughly audit every proposal parameter, especially complex `AuthorityInfo` structures with contract addresses. Social engineering or proposal obfuscation could lead to approval of a malicious controller change.

### Recommendation

**Immediate Fix - Add Contract Address Whitelist Validation:**

Add a validation check in the `CheckOrganizationExist` function (or before calling it) to ensure the contract address is one of the known governance contracts:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a known governance contract
    var knownGovernanceContracts = new List<Address>
    {
        State.ParliamentContract.Value,
        State.AssociationContract.Value, 
        State.ReferendumContract.Value
    };
    
    Assert(knownGovernanceContracts.Contains(authorityInfo.ContractAddress), 
           "Authority contract must be a recognized governance contract");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**System-Wide Remediation:**
- Apply the same fix to all instances of this pattern across Genesis, CrossChain, and all other contracts
- Consider adding a centralized governance contract registry maintained by the default Parliament organization
- Add unit tests that attempt to pass malicious contract addresses and verify they are rejected

**Test Cases to Prevent Regression:**
1. Test that `ChangeMethodFeeController` rejects non-governance contract addresses
2. Test that only Parliament/Association/Referendum contract addresses are accepted
3. Test that a malicious contract returning `true` is still rejected due to whitelist check
4. Integration tests for all affected controller change functions across all contracts

### Proof of Concept

**Initial State:**
- Method fee controller is set to legitimate Parliament organization
- Attacker deploys malicious validation contract at address `MALICIOUS_ADDR`

**Malicious Contract Code:**
```csharp
public class MaliciousValidator : MaliciousValidatorContainer.MaliciousValidatorBase
{
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        // Always returns true regardless of input
        return new BoolValue { Value = true };
    }
}
```

**Attack Sequence:**

1. **Deploy Malicious Contract:** Attacker deploys the malicious validator contract

2. **Create Governance Proposal:** Using current governance system, create a proposal to execute `ChangeMethodFeeController` with:
   ```
   AuthorityInfo {
       ContractAddress: MALICIOUS_ADDR,  // Points to attacker's contract
       OwnerAddress: ATTACKER_ADDR       // Attacker-controlled address
   }
   ```

3. **Proposal Approval:** Proposal gets approved by voters who don't scrutinize the contract address parameter

4. **Proposal Execution:** Parliament organization executes the proposal, calling `ChangeMethodFeeController`

5. **Validation Bypass:** 
   - Line 28 calls `CheckOrganizationExist(input)`
   - Line 118 calls `MALICIOUS_ADDR.ValidateOrganizationExist(ATTACKER_ADDR)`
   - Malicious contract returns `BoolValue { Value = true }`
   - Line 29 assertion passes
   - Line 31 updates controller to attacker's fake organization

6. **Governance Bypass Achieved:** Attacker can now call `SetMethodFee` directly as `ATTACKER_ADDR` without any governance approval, completely bypassing Parliament/Association/Referendum controls

**Expected Result:** Validation should fail, rejecting non-governance contract addresses

**Actual Result:** Validation passes, method fee controller is updated to attacker-controlled fake organization

**Success Condition:** `State.MethodFeeController.Value.ContractAddress == MALICIOUS_ADDR` and `State.MethodFeeController.Value.OwnerAddress == ATTACKER_ADDR`, allowing future ungoverned fee changes

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-32)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L676-681)
```csharp
    private bool ValidateAuthorityInfoExists(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L45-96)
```csharp
    public override Empty ChangeSymbolsToPayTXSizeFeeController(AuthorityInfo input)
    {
        AssertControllerForSymbolToPayTxSizeFee();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.SymbolToPayTxFeeController.Value = input;
        return new Empty();
    }

    public override Empty ChangeSideChainRentalController(AuthorityInfo input)
    {
        AssertControllerForSideChainRental();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.SideChainRentalController.Value = input;
        return new Empty();
    }

    public override Empty ChangeCrossChainTokenContractRegistrationController(AuthorityInfo input)
    {
        CheckCrossChainTokenContractRegistrationControllerAuthority();
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.CrossChainTokenContractRegistrationController.Value = input;
        return new Empty();
    }

    public override Empty ChangeUserFeeController(AuthorityInfo input)
    {
        AssertUserFeeController();
        Assert(CheckOrganizationExist(input), "Invalid authority input.");
        State.UserFeeController.Value.RootController = input;
        State.UserFeeController.Value.ParliamentController = null;
        State.UserFeeController.Value.ReferendumController = null;
        return new Empty();
    }

    public override Empty ChangeDeveloperController(AuthorityInfo input)
    {
        AssertDeveloperFeeController();
        Assert(CheckOrganizationExist(input), "Invalid authority input.");
        State.DeveloperFeeController.Value.RootController = input;
        State.DeveloperFeeController.Value.ParliamentController = null;
        State.DeveloperFeeController.Value.DeveloperController = null;
        return new Empty();
    }

    public override Empty ChangeTransferBlackListController(AuthorityInfo input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.TransferBlackListController.Value = input;
        return new Empty();
```
