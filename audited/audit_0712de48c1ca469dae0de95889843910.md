### Title
NextRound Validation Fails to Detect Duplicate Mining Orders Due to Incorrect Distinct() Usage on Protobuf Objects

### Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` validation uses `Distinct()` on `MinerInRound` objects instead of their `FinalOrderOfNextRound` values. Since protobuf-generated classes implement field-based equality across ALL properties, miners with duplicate `FinalOrderOfNextRound` values pass as distinct due to differing `pubkey` and other fields. This allows malicious round data with duplicate mining orders to pass validation and break the consensus invariant that each miner must have a unique mining order.

### Finding Description

**Root Cause:**

The validation logic in `NextRoundMiningOrderValidationProvider` incorrectly applies `Distinct()` to `MinerInRound` objects rather than extracting and deduplicating their `FinalOrderOfNextRound` values: [1](#0-0) 

The validation compares the count of distinct `MinerInRound` objects against the count of miners who mined blocks. However, `MinerInRound` is a protobuf-generated message type with 17 fields: [2](#0-1) 

Protobuf-generated C# classes implement `Equals()` and `GetHashCode()` by comparing ALL fields. Since each miner has unique values for `pubkey` (line 284), `order` (line 268), `out_value` (line 274), `signature` (line 276), etc., two `MinerInRound` objects will NEVER be considered equal by `Distinct()` even if they have identical `final_order_of_next_round` values (line 290).

**Why Protection Fails:**

The intended validation is to ensure all `FinalOrderOfNextRound` VALUES are unique across miners. The comment explicitly states this intent: [3](#0-2) 

However, the actual implementation validates object uniqueness, not value uniqueness. Consider 3 miners with `FinalOrderOfNextRound` values of 1, 2, and 2 (duplicate):
- Current code: `Distinct()` returns count 3 (all objects distinct due to different pubkeys)
- Expected validation: Should detect only 2 distinct order values and fail
- Result: Validation incorrectly passes (3 == 3)

**Exploitation Path:**

During `NextRound` consensus behavior, the validation provider is registered: [4](#0-3) 

After passing this flawed validation, the malicious round data is saved to state: [5](#0-4) 

When the next round is generated, `FinalOrderOfNextRound` values are directly used as the `Order` for each miner: [6](#0-5) 

With duplicate `FinalOrderOfNextRound` values, multiple miners receive the same `Order` assignment (line 32), breaking the consensus invariant.

### Impact Explanation

**Consensus Integrity Breach:**

The vulnerability breaks a fundamental consensus invariant: each miner must have a unique mining order. When duplicate orders are assigned:

1. **Mining Order Conflicts**: Multiple miners are scheduled to mine at the same time slot, calculated using the same order value: [7](#0-6) 

2. **Available Order Miscalculation**: The `occupiedOrders` list contains the duplicate value, but two miners claim that order: [8](#0-7) 

This leaves insufficient orders for miners who didn't mine in the current round, potentially causing array out-of-bounds or incorrect order assignments.

3. **Double Block Production**: Multiple miners with the same order attempt to produce blocks simultaneously, leading to fork risks and consensus failures.

4. **Network Disruption**: The corrupted round data persists in state and propagates to subsequent rounds, causing sustained consensus instability.

**Severity:** CRITICAL - Directly undermines consensus mechanism integrity, enabling network-wide disruption.

### Likelihood Explanation

**Attacker Capabilities:**

An attacker must be a valid miner in the current round to propose a `NextRound` block. This is a realistic precondition in AEDPoS where miners rotate and any current miner can propose the next round transition.

**Attack Complexity:**

The attack is straightforward:
1. Attacker monitors when they are scheduled to produce the `NextRound` block
2. Attacker crafts a `NextRoundInput` where multiple miners have duplicate `FinalOrderOfNextRound` values
3. The flawed validation passes because `Distinct()` sees distinct objects
4. The malicious round data is committed to state

**Feasibility Conditions:**

- **Entry Point**: Public `NextRound` method is reachable by any valid miner
- **Preconditions**: Attacker is a current miner (rotates among participants)
- **Detection**: The malicious data passes all validation checks and appears valid
- **Cost**: No additional economic cost beyond normal block production

**Probability:** HIGH - Any malicious miner can exploit this during their scheduled `NextRound` turn with minimal complexity.

### Recommendation

**Immediate Fix:**

Change the validation to check distinctness of `FinalOrderOfNextRound` VALUES, not objects:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Extract the value
    .Distinct()
    .Count();
```

**Additional Validation:**

Add an explicit check that all `FinalOrderOfNextRound` values are within valid range [1, minersCount] and form a contiguous set:

```csharp
var finalOrders = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .OrderBy(o => o)
    .ToList();

// Check no duplicates
if (finalOrders.Count != finalOrders.Distinct().Count())
{
    validationResult.Message = "Duplicate FinalOrderOfNextRound values detected.";
    return validationResult;
}

// Check values are in valid range
var minersCount = providedRound.RealTimeMinersInformation.Count;
if (finalOrders.Any(o => o < 1 || o > minersCount))
{
    validationResult.Message = "FinalOrderOfNextRound out of valid range.";
    return validationResult;
}
```

**Test Cases:**

Add regression tests covering:
1. Scenario with duplicate `FinalOrderOfNextRound` values (should fail validation)
2. Scenario with out-of-range `FinalOrderOfNextRound` values (should fail validation)
3. Scenario with valid unique `FinalOrderOfNextRound` values (should pass validation)

### Proof of Concept

**Initial State:**
- Current round has 5 miners: A, B, C, D, E
- Miners A, B, C have produced blocks (OutValue != null)
- Miner A is scheduled to produce the NextRound block

**Attack Sequence:**

1. **Miner A crafts malicious NextRoundInput:**
   - Miner A: FinalOrderOfNextRound = 1
   - Miner B: FinalOrderOfNextRound = 2
   - Miner C: FinalOrderOfNextRound = 2 (duplicate)
   - Miners D, E: FinalOrderOfNextRound = 0 (didn't mine)

2. **Validation executed:**
   - `Where(m => m.FinalOrderOfNextRound > 0)` returns 3 MinerInRound objects (A, B, C)
   - `Distinct().Count()` returns 3 (objects are distinct due to different pubkeys)
   - `Count(m => m.OutValue != null)` returns 3 (A, B, C mined)
   - Check passes: 3 == 3 âœ“

3. **Expected vs Actual:**
   - **Expected**: Validation should fail because only 2 distinct FinalOrderOfNextRound values exist (1, 2)
   - **Actual**: Validation passes, malicious round committed to state

4. **Next Round Generation:**
   - GenerateNextRoundInformation iterates miners ordered by FinalOrderOfNextRound
   - Miner A assigned Order = 1
   - Miner B assigned Order = 2
   - Miner C assigned Order = 2 (duplicate!)
   - occupiedOrders = [1, 2], but only 2 positions claimed by 3 miners
   - ableOrders = [3, 4, 5]
   - Miner D assigned Order = 3
   - Miner E assigned Order = 4

5. **Consensus Failure:**
   - Two miners (B and C) both have Order = 2
   - Both attempt to mine at the same time slot
   - Block production conflict and fork risk

**Success Condition:** The malicious NextRoundInput with duplicate FinalOrderOfNextRound values passes validation and causes mining order collision in the next round.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L11-12)
```csharp
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-86)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```
