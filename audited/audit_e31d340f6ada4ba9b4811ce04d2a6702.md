# Audit Report

## Title
Hardcoded Election Lock Amount Causes DoS or Incorrect Economic Security When Native Token Decimals Differ from 8

## Summary
The Election contract uses a hardcoded lock amount of `100_000_00000000` that assumes the native token has exactly 8 decimal places. However, native token decimals are configurable from 0 to 18 during chain initialization. When a chain is deployed with different decimals, the election system will either fail completely (DoS) or lock incorrect amounts, undermining the economic security model.

## Finding Description

The Election contract defines a hardcoded constant [1](#0-0)  that represents 100,000 tokens assuming 8 decimal places.

This constant is used directly when locking tokens during election announcement [2](#0-1)  and when refunding during quit election [3](#0-2) .

However, the native token decimals are fully configurable during economic system initialization [4](#0-3) . The token creation validates only that decimals are between 0 and 18 [5](#0-4) , with no enforcement that the native token must have 8 decimals.

The MultiToken contract's validation only checks that amounts are positive [6](#0-5) , without verifying that amounts align with the token's configured decimal precision.

When a transfer exceeds the available balance, the transaction fails [7](#0-6) . The transfer flow validates allowances and balances [8](#0-7) .

## Impact Explanation

**Critical DoS Scenario (decimals < 8):**
With 2 decimals, the hardcoded amount `100_000_00000000` represents 1,000,000,000,000 tokens (1 trillion). Given the typical total supply of 1 billion tokens [9](#0-8) , no user can possess this amount. All election announcements will fail with "Insufficient balance", causing complete DoS of the governance system.

**High Security Reduction (decimals > 8):**
With 10 decimals, the same amount represents only 10,000 tokens instead of the intended 100,000 tokens - a 90% reduction in the economic barrier to candidacy. This severely undermines the election security model by making it 10x cheaper to announce candidacy.

**Critical DoS Scenario (decimals = 6):**
With 6 decimals, the amount represents 100,000,000 tokens (100 million) - 1000x the intended amount. Unless candidates have enormous balances, this effectively blocks all election participation.

## Likelihood Explanation

The vulnerability is triggered through the public methods `AnnounceElection` [10](#0-9)  and `AnnounceElectionFor` [11](#0-10) , both callable by any user without special privileges.

The precondition is that the chain must be initialized with native token decimals different from 8. This is explicitly supported by the system - decimals are configurable [12](#0-11)  and test code demonstrates native tokens with 2 decimals are valid [13](#0-12) .

While the default is 8 decimals, side chains or custom deployments may legitimately choose different decimals for compatibility with existing tokens or specific precision requirements. There is no validation preventing this configuration, making the likelihood medium-high for any non-standard deployment.

## Recommendation

The Election contract should query the native token's decimal configuration at runtime and adjust the lock amount accordingly:

```csharp
private void LockCandidateNativeToken()
{
    if (State.TokenContract.Value == null)
        State.TokenContract.Value = 
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

    // Get native token info to determine decimals
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(
        new GetTokenInfoInput { Symbol = Context.Variables.NativeSymbol });
    
    // Calculate lock amount: 100,000 tokens adjusted for actual decimals
    var lockAmount = 100_000L * (long)Math.Pow(10, tokenInfo.Decimals);
    
    var lockId = Context.OriginTransactionId;
    var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
    var sponsorAddress = Context.Sender;
    
    State.TokenContract.TransferFrom.Send(new TransferFromInput
    {
        From = sponsorAddress,
        To = lockVirtualAddress,
        Symbol = Context.Variables.NativeSymbol,
        Amount = lockAmount,
        Memo = "Lock for announcing election."
    });
}
```

The same adjustment should be made in the `QuitElection` refund logic.

## Proof of Concept

```csharp
[Fact]
public async Task ElectionDoS_WhenNativeTokenHasTwoDecimals()
{
    // Initialize chain with native token having 2 decimals instead of 8
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "ELF",
        Decimals = 2,  // Different from assumed 8
        TokenName = "Native Token",
        TotalSupply = 1_000_000_000_00,  // 1 billion with 2 decimals
        Issuer = DefaultAddress,
        IsBurnable = true,
        Owner = DefaultAddress
    });
    
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "ELF",
        Amount = 1_000_000_000_00,  // Issue all supply
        To = CandidateAddress,
        Memo = "Initial issue"
    });
    
    // Attempt to announce election
    // This will fail because hardcoded 100_000_00000000 with 2 decimals
    // requires 1 trillion tokens, but only 1 billion exist
    var result = await ElectionContractStub.AnnounceElection.SendWithExceptionAsync(
        new Address { Value = ByteString.CopyFrom(new byte[32]) });
    
    // Verify transaction failed with insufficient balance
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Insufficient balance");
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-118)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L187-194)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L242-249)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L54-64)
```csharp
        State.TokenContract.Create.Send(new CreateInput
        {
            Symbol = input.NativeTokenSymbol,
            TokenName = "Native Token",
            TotalSupply = input.NativeTokenTotalSupply,
            Decimals = input.NativeTokenDecimals,
            IsBurnable = input.IsNativeTokenBurnable,
            Issuer = Context.Self,
            LockWhiteList = { lockWhiteList },
            Owner = Context.Self
        });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L116-125)
```csharp
    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-277)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** src/AElf.OS.Core/EconomicOptions.cs (L8-8)
```csharp
    public long TotalSupply { get; set; } = 1_000_000_000_00000000;
```

**File:** src/AElf.EconomicSystem/EconomicContractInitializationProvider.cs (L38-48)
```csharp
                Params = new InitialEconomicSystemInput
                {
                    NativeTokenDecimals = _economicOptions.Decimals,
                    IsNativeTokenBurnable = _economicOptions.IsBurnable,
                    NativeTokenSymbol = _economicOptions.Symbol,
                    NativeTokenName = _economicOptions.TokenName,
                    NativeTokenTotalSupply = _economicOptions.TotalSupply,
                    MiningRewardTotalAmount =
                        Convert.ToInt64(_economicOptions.TotalSupply * _economicOptions.DividendPoolRatio),
                    TransactionSizeFeeUnitPrice = _economicOptions.TransactionSizeFeeUnitPrice
                }.ToByteString()
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/MethodFeeTestTokenContractInitializationProvider.cs (L21-34)
```csharp
        methodList.Add(new ContractInitializationMethodCall
        {
            MethodName = nameof(TokenContractContainer.TokenContractStub.Create),
            Params = new CreateInput
            {
                Symbol = "ELF",
                Decimals = 2,
                IsBurnable = true,
                TokenName = "elf token",
                TotalSupply = 1_000_000_00000000L,
                Issuer = SampleAccount.Accounts[0].Address,
                Owner = SampleAccount.Accounts[0].Address
            }.ToByteString()
        });
```
