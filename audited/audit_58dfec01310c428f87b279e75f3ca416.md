### Title
Guaranteed Infinite Loop DoS in NFT Symbol Generation Causes Transaction Failure on Collision

### Summary
The `GenerateSymbolNumber()` function computes a random hash once before entering a do-while loop, then repeatedly calls `ConvertHashToInt64()` with the same hash value to check for collisions. Since `ConvertHashToInt64()` is deterministic, any collision results in an infinite loop that causes out-of-gas transaction failure, permanently blocking NFT protocol creation for affected users.

### Finding Description

The vulnerability exists in the `GenerateSymbolNumber()` helper function. [1](#0-0) 

**Root Cause:**

The random hash is computed once outside the loop using random bytes from the consensus contract and the sender's address. [2](#0-1) 

Inside the do-while loop, `Context.ConvertHashToInt64(randomHash, from, from.Mul(10))` is called with this same hash on every iteration. [3](#0-2) 

The `ConvertHashToInt64()` method is deterministic - it converts a hash to an integer within a range using modulo arithmetic. [4](#0-3) 

**Why Protections Fail:**

Since the hash never changes during loop iterations, `ConvertHashToInt64()` returns the identical `randomNumber` every time. If `State.IsCreatedMap[randomNumber]` is true (collision detected), the while condition remains perpetually true, creating an infinite loop with no escape condition.

**Execution Path:**

The public `Create()` method is the entry point. [5](#0-4) 

It calls `GetSymbol()`, which invokes `GenerateSymbolNumber()` and marks the returned number as used. [6](#0-5) 

### Impact Explanation

**Operational DoS:**
Any user experiencing a collision cannot create an NFT protocol. Their transaction will loop infinitely until gas exhaustion, resulting in transaction failure. This is a permanent DoS for that specific user and transaction parameters.

**Affected Parties:**
- Users attempting to create NFT protocols when their generated random number collides with existing entries
- The protocol as a whole, as collision probability increases with each created NFT protocol
- Initially with 900 million possible values (range [10^8, 10^9)), but birthday paradox means collisions become likely far sooner

**Severity Justification:**
HIGH severity because:
1. Guaranteed transaction failure on collision (100% DoS when triggered)
2. No recovery mechanism - retry with same parameters will always fail
3. Collision probability increases monotonically with protocol usage
4. Affects core protocol functionality (NFT creation)
5. Users lose gas fees on failed transactions

### Likelihood Explanation

**Attacker Capabilities:**
No special capabilities required. Any user calling the public `Create()` method can trigger this vulnerability when their random generation collides with existing entries.

**Attack Complexity:**
This is not an intentional attack but rather a design flaw that manifests naturally:
- As more NFT protocols are created, the collision probability increases
- Birthday paradox: with 900M values, ~50% collision probability occurs at approximately √(900M) ≈ 30,000 protocols
- Once a collision occurs for a specific user/height/hash combination, that transaction will always fail

**Feasibility Conditions:**
The initial number range is 900 million values. [7](#0-6) 

However, the space expansion logic increases length when approaching capacity, but this doesn't prevent collisions within each range. [8](#0-7) 

**Probability:**
This WILL occur with certainty as the protocol grows. The vulnerability is not about "high collision rates" but about the fact that ANY collision causes a guaranteed infinite loop due to the deterministic nature of hash conversion.

### Recommendation

**Code-Level Mitigation:**

Regenerate the random hash inside the loop to ensure different values are tried on each iteration:

```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    long randomNumber;
    var maxAttempts = 100; // Add safety limit
    var attempts = 0;
    
    do
    {
        // Generate new random hash on each iteration
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1).Add(attempts)
        }.ToBytesValue());
        var randomHash = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(Context.Sender),
            HashHelper.ComputeFrom(randomBytes),
            HashHelper.ComputeFrom(attempts));
        
        randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        attempts++;
        
        Assert(attempts < maxAttempts, "Failed to generate unique symbol number after maximum attempts.");
    } while (State.IsCreatedMap[randomNumber]);

    return randomNumber;
}
```

**Invariant Checks:**
- Add maximum iteration limit to prevent infinite loops
- Include attempt counter in hash generation to ensure different values
- Consider pre-expanding number space when utilization reaches threshold

**Test Cases:**
1. Test with artificially populated `IsCreatedMap` to force collisions
2. Verify different random numbers generated on each iteration
3. Test with near-full number space to validate space expansion
4. Verify max attempts assertion triggers correctly

### Proof of Concept

**Initial State:**
1. Deploy NFT contract
2. Create N NFT protocols where N creates reasonable collision probability
3. Populate `State.IsCreatedMap` with specific values for testing

**Transaction Steps:**
1. User A calls `Create()` with valid NFT parameters
2. Execution enters `GetSymbol()` → `GenerateSymbolNumber()`
3. Random hash is computed once: `randomHash = HashHelper.ConcatAndCompute(...)`
4. Loop executes: `randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10))`
5. If `State.IsCreatedMap[randomNumber] == true`, loop condition is true
6. Loop repeats step 4 with SAME hash → SAME randomNumber → SAME collision
7. Loop continues infinitely until gas exhaustion

**Expected vs Actual:**
- **Expected**: Generate different random numbers on each iteration until finding an unused one
- **Actual**: Generate the same random number infinitely, causing transaction failure with out-of-gas error

**Success Condition for Exploit:**
Transaction fails with out-of-gas error when a collision occurs, proving the infinite loop vulnerability.

### Notes

The vulnerability stems from a fundamental misunderstanding of the deterministic nature of hash-to-integer conversion. The current implementation assumes that calling `ConvertHashToInt64()` multiple times would produce different results, but this is incorrect - it's a pure function that always returns the same output for the same input.

The issue is exacerbated by the fact that the random bytes are fetched from the consensus contract at a specific height, which is also fixed for the transaction duration, meaning even regenerating the hash with the same inputs would produce the same result. The fix must incorporate a changing element (like an iteration counter) into the hash generation to ensure uniqueness across attempts.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L87-116)
```csharp
    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L169-178)
```csharp
    public long ConvertHashToInt64(Hash hash, long start = 0, long end = long.MaxValue)
    {
        if (start < 0 || start > end) throw new ArgumentException("Incorrect arguments.");

        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```
