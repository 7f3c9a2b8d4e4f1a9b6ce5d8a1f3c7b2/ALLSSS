### Title
Insufficient Validation in ChangeMethodFeeController Enables Permanent Control Hijacking via Malicious Organization Rotation

### Summary
The `ChangeMethodFeeController` function lacks semantic validation of the new controller organization, only verifying sender authorization and organization existence. An attacker who successfully gets a single malicious Parliament proposal approved can permanently hijack method fee control by rotating to a single-member Association organization they control, bypassing all future governance oversight.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController` function which performs only two validation checks: [1](#0-0) 

**Root Cause:** The function validates that (1) the sender is the current controller's OwnerAddress and (2) the new organization exists, but critically fails to validate whether the new controller organization has appropriate security properties for the governance role. [2](#0-1) 

The `CheckOrganizationExist` function only calls `ValidateOrganizationExist`, which merely confirms the organization exists in storage: [3](#0-2) 

**Why Existing Protections Fail:** An attacker can create an Association organization with minimal security controls - a single member (themselves) with `MinimalApprovalThreshold=1` and `MinimalVoteThreshold=1`. The Association contract's validation only requires thresholds greater than zero: [4](#0-3) 

**Exploitation Path:** Test evidence demonstrates this attack path is technically viable. The codebase contains a test showing successful controller rotation from Parliament to a single-member Association organization: [5](#0-4) 

### Impact Explanation

**Governance Control Hijacking:** Once the controller is changed to the attacker's single-member Association organization, the attacker gains permanent unilateral control over all method fees for the Vote contract without requiring any further governance approvals.

**Concrete Harms:**
- **DoS Attack:** Attacker can set arbitrarily high fees (e.g., 1,000,000 tokens per transaction) making the Vote contract economically unusable
- **Resource Drain:** Attacker can set fees to zero, bypassing normal economic protections and enabling spam attacks
- **Fee Extraction:** Attacker can set custom fees benefiting their own accounts
- **Irreversibility:** The attack is permanent - recovering control requires convincing the attacker's organization to approve a reversal, which they control

**Affected Parties:** All users and integrations depending on the Vote contract for voting functionality, registration, and vote management operations.

**Severity:** HIGH - The vulnerability enables complete bypass of governance controls through a single malicious proposal, with permanent and irreversible consequences affecting core protocol functionality.

### Likelihood Explanation

**Attacker Capabilities Required:** The attacker must successfully get ONE malicious Parliament proposal approved to call `ChangeMethodFeeController` with their controlled Association organization as the new controller. Parliament requires 2/3 miner approval by default: [6](#0-5) 

**Attack Complexity:** MEDIUM - While obtaining 2/3 miner approval is difficult under normal circumstances, several realistic scenarios enable this:
1. **Social Engineering:** Disguising the malicious proposal as a legitimate governance upgrade
2. **Emergency Conditions:** Miners rushing approvals during crisis situations without careful review
3. **Compromised Accounts:** Single compromised high-influence miner account combined with social engineering of others
4. **Economic Attacks:** Bribing miners when the permanent control value exceeds bribery costs

**Detection Constraints:** The attack appears as a normal governance proposal until executed, providing no warning that the controller change represents a permanent control transfer rather than a legitimate upgrade.

**Probability Assessment:** MEDIUM - The requirement for Parliament approval is a significant barrier, but the permanent nature of the impact means the attack only needs to succeed ONCE. The asymmetry between effort (one proposal approval) and outcome (permanent control) makes this attractive to sophisticated attackers.

### Recommendation

**Code-Level Mitigation:** Add semantic validation to `ChangeMethodFeeController` to ensure new controllers have appropriate security properties:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    // NEW: Validate new controller has appropriate security properties
    ValidateControllerSecurityProperties(input);
    
    State.MethodFeeController.Value = input;
    return new Empty();
}

private void ValidateControllerSecurityProperties(AuthorityInfo input)
{
    // Option 1: Whitelist approach - only allow known governance contracts
    var allowedContracts = new[] { 
        State.ParliamentContract.Value,
        State.AssociationContract.Value,
        State.ReferendumContract.Value
    };
    Assert(allowedContracts.Contains(input.ContractAddress), 
        "Controller must be from approved governance contract.");
    
    // Option 2: Threshold validation - ensure adequate multi-sig requirements
    // Call GetOrganization and validate MinimalApprovalThreshold >= MIN_REQUIRED_APPROVERS
    
    // Option 3: Timelock - require controller changes to have a delay period
}
```

**Invariant Checks:** Add assertions that controller organizations maintain minimum security thresholds (e.g., `MinimalApprovalThreshold >= 3` for production systems).

**Test Cases:** Add negative test cases verifying that:
1. Controller cannot be changed to single-member Association organizations
2. Controller cannot be changed to organizations with approval thresholds below system minimum
3. Controller changes to non-whitelisted governance contracts are rejected

### Proof of Concept

**Initial State:**
- Vote contract deployed with default Parliament controller (2/3 miner approval required)
- Attacker creates Association organization with parameters:
  - OrganizationMemberList: [AttackerAddress]
  - ProposerWhiteList: [AttackerAddress]  
  - MinimalApprovalThreshold: 1
  - MinimalVoteThreshold: 1

**Attack Steps:**

1. **Create Malicious Organization:**
   ```
   Call: AssociationContract.CreateOrganization(
       OrganizationMemberList: [Attacker],
       MinimalApprovalThreshold: 1,
       MinimalVoteThreshold: 1
   )
   Returns: AttackerOrgAddress
   ```

2. **Create Parliament Proposal:**
   ```
   Call: ParliamentContract.CreateProposal(
       ToAddress: VoteContract,
       MethodName: "ChangeMethodFeeController",
       Params: AuthorityInfo {
           OwnerAddress: AttackerOrgAddress,
           ContractAddress: AssociationContract
       }
   )
   ```

3. **Obtain Miner Approvals:** Through social engineering, emergency conditions, or other means, get 2/3 miners to approve the proposal

4. **Release Proposal:**
   ```
   Call: ParliamentContract.Release(ProposalId)
   Executes: VoteContract.ChangeMethodFeeController(AttackerOrgAddress)
   ```

**Expected Result:** Transaction should fail with "Controller does not meet minimum security requirements"

**Actual Result:** Transaction succeeds. Controller is permanently changed to AttackerOrgAddress. Attacker now has unilateral control over Vote contract method fees with no governance oversight.

**Success Condition Verification:**
```
Call: VoteContract.GetMethodFeeController()
Returns: AuthorityInfo { 
    OwnerAddress: AttackerOrgAddress,
    ContractAddress: AssociationContract 
}
```

Attacker can now set arbitrary fees by creating and immediately approving proposals in their single-member Association organization, bypassing all governance controls permanently.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L92-97)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L1273-1315)
```csharp
    public async Task ChangeMethodFeeControllerByAssociation_Test()
    {
        var createOrganizationResult = await Tester.ExecuteContractWithMiningAsync(AssociationContractAddress,
            nameof(AssociationContractImplContainer.AssociationContractImplStub.CreateOrganization),
            new Association.CreateOrganizationInput
            {
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1,
                    MinimalVoteThreshold = 1
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { AnotherMinerAddress }
                },
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { AnotherMinerAddress }
                }
            });

        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.ReturnValue);

        var methodFeeController = await GetMethodFeeController(Tester, BasicContractZeroAddress);
        const string proposalCreationMethodName =
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ChangeMethodFeeController);
        var proposalId = await CreateProposalAsync(Tester, methodFeeController.ContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName,
            new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = AssociationContractAddress
            });
        await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);
        var txResult2 = await ReleaseProposalAsync(Tester, ParliamentAddress, proposalId);
        txResult2.Status.ShouldBe(TransactionResultStatus.Mined);

        var methodFeeControllerAfterChange =
            await GetMethodFeeController(Tester, BasicContractZeroAddress);

        methodFeeControllerAfterChange.ContractAddress.ShouldBe(AssociationContractAddress);
        methodFeeControllerAfterChange.OwnerAddress.ShouldBe(organizationAddress);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L11-36)
```csharp
    public override Empty Initialize(InitializeInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        var proposerWhiteList = new ProposerWhiteList();

        if (input.PrivilegedProposer != null)
            proposerWhiteList.Proposers.Add(input.PrivilegedProposer);

        State.ProposerWhiteList.Value = proposerWhiteList;
        var organizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = DefaultOrganizationMinimalApprovalThreshold,
                MinimalVoteThreshold = DefaultOrganizationMinimalVoteThresholdThreshold,
                MaximalAbstentionThreshold = DefaultOrganizationMaximalAbstentionThreshold,
                MaximalRejectionThreshold = DefaultOrganizationMaximalRejectionThreshold
            },
            ProposerAuthorityRequired = input.ProposerAuthorityRequired,
            ParliamentMemberProposingAllowed = true
        };
        var defaultOrganizationAddress = CreateNewOrganization(organizationInput);
        State.DefaultOrganizationAddress.Value = defaultOrganizationAddress;
        return new Empty();
```
