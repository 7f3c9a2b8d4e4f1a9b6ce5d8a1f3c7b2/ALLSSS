# Audit Report

## Title
Vote Contract Timestamp Enforcement Missing - Sponsor Can Manipulate Snapshot Timing

## Summary
The Vote contract accepts `StartTimestamp` and `EndTimestamp` parameters during voting item registration but never enforces these time constraints. The sponsor has unrestricted control over when to call `TakeSnapshot()`, allowing strategic timing to capture favorable voting states, even indefinitely past the declared end time. This enables timing-based manipulation of voting outcomes and violates voter expectations about voting deadlines.

## Finding Description

The Vote contract stores timestamp fields but lacks enforcement logic in critical functions. During registration, the contract accepts and stores `StartTimestamp` and `EndTimestamp` fields [1](#0-0) , with protocol documentation describing these as "The start time of the voting" and "The end time of the voting" [2](#0-1) .

The only timestamp validation occurs during registration, checking that `EndTimestamp > StartTimestamp` [3](#0-2) . However, these timestamps are never validated afterward in any execution path.

The `Vote()` function validates voting eligibility through `AssertValidVoteInput()` [4](#0-3) , which only checks snapshot numbers with no comparison of `Context.CurrentBlockTime` against the voting item's timestamps [5](#0-4) .

The `TakeSnapshot()` function similarly lacks any timestamp validation [6](#0-5) . It only verifies sponsor permission, snapshot number limits, and sequential snapshot numbers. No code prevents the sponsor from delaying `TakeSnapshot()` indefinitely, even past `EndTimestamp`.

Test evidence confirms this behavior: a voting item registered with 100 days duration can be immediately "ended" by taking a snapshot, demonstrating that the voting period is controlled entirely by snapshot mechanics rather than timestamp constraints [7](#0-6) .

## Impact Explanation

**Governance Manipulation:**
Sponsors can strategically time snapshot captures to include or exclude specific votes. If early votes are unfavorable, the sponsor waits for more votes before taking a snapshot. If votes become unfavorable later, the sponsor can take a snapshot immediately. Voting can continue indefinitely past the declared `EndTimestamp`, allowing the sponsor to optimize outcomes.

**Voter Expectation Violation:**
Voters see `StartTimestamp` and `EndTimestamp` in the voting item structure and reasonably believe voting ends at that time. This can cause voters to either not cast votes thinking the period has ended, or rush to vote before `EndTimestamp` when timing is actually irrelevant to the snapshot process.

**Protocol-Level Impact:**
While the Election contract registers voting items with effectively infinite timestamps [8](#0-7) , the Vote contract is a generic infrastructure component. Any external contracts or systems using it to create voting items with meaningful time constraints would find those constraints completely unenforced, creating a timing attack surface for governance decisions.

## Likelihood Explanation

**Attacker Capabilities:**
The attacker is the voting item sponsor who registered the voting system. No special privileges beyond being the sponsor are needed, and no collusion is required.

**Attack Complexity:**
Trivial - the sponsor simply delays calling `TakeSnapshot()`. No complex transactions, state manipulation, or timing precision is required.

**Economic Rationality:**
Zero cost to execute (just delay action), with high benefit from controlling voting outcome timing. This is particularly valuable in close votes or important governance decisions, making it economically rational for sponsors to optimize snapshot timing.

## Recommendation

Add timestamp validation to enforce the declared voting period:

1. In `AssertValidVoteInput()`, add checks to ensure votes only occur within the time window:
```csharp
Assert(Context.CurrentBlockTime >= votingItem.StartTimestamp, "Voting has not started yet.");
Assert(Context.CurrentBlockTime <= votingItem.EndTimestamp, "Voting has already ended.");
```

2. In `TakeSnapshot()`, add validation to prevent premature snapshots:
```csharp
Assert(Context.CurrentBlockTime >= votingItem.EndTimestamp, "Cannot take snapshot before voting period ends.");
```

Alternatively, if timestamps are not intended to be enforced, remove these fields from the API to avoid creating misleading expectations about voting period constraints.

## Proof of Concept

The existing test at [7](#0-6)  demonstrates this vulnerability. A voting item registered with `lastingDays = 100` can be immediately ended by calling `TakeSnapshot()`, proving that the 100-day timestamp constraint is completely ignored and only snapshot number mechanics control the voting lifecycle.

---

**Notes:**
This vulnerability affects the Vote contract's design as generic voting infrastructure. While the Election contract works around this by setting infinite timestamps, any other contract or system using the Vote contract with meaningful time constraints would find those constraints unenforced, creating governance manipulation risks.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L45-47)
```csharp
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L92-92)
```csharp
        var votingItem = AssertValidVoteInput(input);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L241-273)
```csharp
    public override Empty TakeSnapshot(TakeSnapshotInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);

        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");

        Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");

        // Update previous voting going information.
        var previousVotingResultHash = GetVotingResultHash(input.VotingItemId, votingItem.CurrentSnapshotNumber);
        var previousVotingResult = State.VotingResults[previousVotingResultHash];
        previousVotingResult.SnapshotEndTimestamp = Context.CurrentBlockTime;
        State.VotingResults[previousVotingResultHash] = previousVotingResult;

        Assert(votingItem.CurrentSnapshotNumber == input.SnapshotNumber,
            $"Can only take snapshot of current snapshot number: {votingItem.CurrentSnapshotNumber}, but {input.SnapshotNumber}");
        var nextSnapshotNumber = input.SnapshotNumber.Add(1);
        votingItem.CurrentSnapshotNumber = nextSnapshotNumber;
        State.VotingItems[votingItem.VotingItemId] = votingItem;

        // Initial next voting going information.
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L361-361)
```csharp
        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** protobuf/vote_contract.proto (L88-91)
```text
    // The start time of the voting.
    google.protobuf.Timestamp start_timestamp = 1;
    // The end time of the voting.
    google.protobuf.Timestamp end_timestamp = 2;
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L92-102)
```csharp
        //voting item have been out of date
        {
            var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1);
            await TakeSnapshot(registerItem.VotingItemId, 1);

            var voter = Accounts[11].KeyPair;
            var voteResult =
                await VoteWithException(voter, registerItem.VotingItemId, registerItem.Options[0], 100);
            voteResult.Status.ShouldBe(TransactionResultStatus.Failed);
            voteResult.Error.Contains("Current voting item already ended").ShouldBeTrue();
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L60-68)
```csharp
        var votingRegisterInput = new VotingRegisterInput
        {
            IsLockToken = false,
            AcceptedCurrency = Context.Variables.NativeSymbol,
            TotalSnapshotNumber = long.MaxValue,
            StartTimestamp = TimestampHelper.MinValue,
            EndTimestamp = TimestampHelper.MaxValue
        };
        State.VoteContract.Register.Send(votingRegisterInput);
```
