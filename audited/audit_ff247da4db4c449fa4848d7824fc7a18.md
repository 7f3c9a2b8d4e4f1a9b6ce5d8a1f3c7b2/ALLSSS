### Title
Inconsistent Vote Counting Allows Governance Bypass Through Member Removal

### Summary
The `IsReleaseThresholdReached()` function contains a critical inconsistency where rejection/approval votes are filtered by current membership, but the total vote count for `MinimalVoteThreshold` includes all votes including those from removed members. This allows a legitimately rejected proposal to become releasable by removing members who voted to reject it after voting has occurred.

### Finding Description

The vulnerability exists in the vote counting logic within `IsReleaseThresholdReached()`. [1](#0-0) 

The `IsProposalRejected()` method filters rejections to count only votes from current organization members. This means that if a member votes to reject and is subsequently removed from the organization, their rejection vote is no longer counted toward the `MaximalRejectionThreshold`. [2](#0-1) 

However, `CheckEnoughVoteAndApprovals()` counts ALL votes (line 56-58) without filtering by current membership when checking `MinimalVoteThreshold`, while only counting current members' approvals (line 49) for `MinimalApprovalThreshold`. [3](#0-2) 

Members can be removed from an organization through the `RemoveMember()` method, which is callable by the organization itself (typically through a proposal). [4](#0-3) 

The `Release()` method checks `IsReleaseThresholdReached()` before executing a proposal.

**Root Cause:** The inconsistency between filtering logic - rejection/abstention/approval counts filter by current membership, but the total vote count for `MinimalVoteThreshold` includes all historical votes regardless of current membership status.

**Execution Path:**
1. Members cast votes on a proposal (approve/reject/abstain)
2. Proposal is initially rejected due to exceeding `MaximalRejectionThreshold`
3. Organization creates and passes a separate proposal to remove members who voted to reject
4. After removal, `IsProposalRejected()` now counts fewer rejections (only current members)
5. `CheckEnoughVoteAndApprovals()` still counts all votes toward `MinimalVoteThreshold`
6. The originally rejected proposal becomes releasable

### Impact Explanation

**Direct Governance Impact:** This vulnerability allows bypassing the rejection threshold protection mechanism, enabling proposals that were legitimately rejected by the organization to be forced through.

**Concrete Scenario:**
- Organization with 10 members
- Thresholds: `MinimalVoteThreshold=7`, `MinimalApprovalThreshold=4`, `MaximalRejectionThreshold=3`
- Proposal receives 4 approvals and 4 rejections (rejected since 4 > 3)
- Organization removes 3 of the rejecting members
- Rejection count drops to 1 (only current members counted)
- Total vote count remains 8 (all votes counted)
- Proposal becomes releasable with 4 approvals, 1 rejection (filtered), despite 4 actual rejections

**Affected Parties:** All organizations using the Association contract for multi-signature governance, as their rejection thresholds can be circumvented post-voting.

**Severity Justification:** HIGH - This directly violates the "Organization thresholds" critical invariant and enables unauthorized proposal execution by manipulating the member list after voting, fundamentally undermining the governance security model.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Control or majority influence over the organization to pass a member removal proposal
- Ability to coordinate timing between voting on a controversial proposal and removing dissenting members

**Attack Complexity:** MEDIUM
- Requires two proposals: the target proposal and a member removal proposal
- Both proposals must be managed strategically
- Attack is deterministic once conditions are met

**Feasibility Conditions:**
- Attacker has sufficient influence to pass member removal proposals
- Organization allows member management through proposals (inherent design)
- No time restrictions prevent sequential proposal execution

**Detection Constraints:** The attack appears as legitimate governance activity - member removal and proposal release are both authorized operations. The vulnerability is in the logical inconsistency, not unauthorized access.

**Probability Assessment:** MEDIUM-HIGH in organizations where a coalition controls enough votes to pass proposals but faces opposition from a minority that could block through rejection thresholds.

### Recommendation

**Code-Level Mitigation:**

Modify `CheckEnoughVoteAndApprovals()` to count only current members' votes for the `MinimalVoteThreshold` check, consistent with how approvals, rejections, and abstentions are counted:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter vote count by current membership
    var currentMemberVoteCount = 
        proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
        proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
        proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
    
    var isVoteThresholdReached =
        currentMemberVoteCount >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

**Additional Invariant Check:**
Consider adding a check to prevent member removal while they have active votes on non-expired proposals, or implement vote invalidation when members are removed.

**Test Cases:**
1. Create proposal with rejection threshold exceeded
2. Remove rejecting members through separate proposal
3. Verify original proposal cannot be released (should fail after fix)
4. Test edge cases with multiple concurrent proposals and member changes

### Proof of Concept

**Initial State:**
- Organization created with 10 members (M1-M10)
- Thresholds: `MinimalVoteThreshold=7`, `MinimalApprovalThreshold=4`, `MaximalRejectionThreshold=3`

**Transaction Sequence:**

1. **Create Proposal P1** (controversial proposal):
   - Proposer: M1
   - Target: Any contract/method

2. **Vote on P1:**
   - M1, M2, M3, M4 call `Approve(P1)` → 4 approvals
   - M5, M6, M7, M8 call `Reject(P1)` → 4 rejections
   - Total: 8 votes

3. **Check P1 status:**
   - `GetProposal(P1).ToBeReleased` returns `false`
   - Reason: `rejectionMemberCount = 4 > MaximalRejectionThreshold (3)`

4. **Create and pass Proposal P2** (to remove rejecting members):
   - Create proposal calling `RemoveMember(M5)`
   - Create proposal calling `RemoveMember(M6)` 
   - Create proposal calling `RemoveMember(M7)`
   - Get sufficient approvals and release each

5. **Check P1 status again:**
   - `GetProposal(P1).ToBeReleased` now returns `true`
   - Current member rejection count: only M8 still a member = 1 rejection
   - Total vote count: still 8 (includes removed members)
   - Both thresholds passed: 4 >= 4 (approval), 8 >= 7 (vote), 1 <= 3 (rejection)

6. **Release P1:**
   - M1 calls `Release(P1)` → **SUCCESS** (should have failed)

**Expected Result:** P1 should remain blocked due to exceeding rejection threshold.

**Actual Result:** P1 becomes releasable and executes after removing rejecting members.

**Success Condition:** The vulnerability is confirmed if a proposal that was rejected (rejection count > MaximalRejectionThreshold with all members present) becomes releasable (ToBeReleased = true) after removing members who voted to reject, without any new votes being cast.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
