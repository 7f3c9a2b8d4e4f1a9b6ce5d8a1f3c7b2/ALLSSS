### Title
Evil Miners Can Propose Cross-Chain Indexing Data After Being Banned Due to Missing BannedPubkey Validation

### Summary
The `CheckCrossChainIndexingPermission` function only validates whether an address is a current miner by checking their presence in the current round's miner list, without verifying if they have been marked as evil in the Election contract's `BannedPubkeyMap`. This creates a one-round timing window where miners detected as evil can still propose and release cross-chain indexing data, potentially allowing them to submit fraudulent cross-chain block information before being fully removed from the system.

### Finding Description

The authorization check for cross-chain indexing operations relies on `CheckCrossChainIndexingPermission`, which simply delegates to `IsCurrentMiner`: [1](#0-0) 

The `IsCurrentMiner` function only checks if the pubkey exists in `currentRound.RealTimeMinersInformation`: [2](#0-1) 

However, it never validates against the Election contract's `BannedPubkeyMap` which tracks evil miners.

The vulnerability arises from the consensus round transition sequence. Evil miners are detected based on missed time slots: [3](#0-2) 

During `ProcessNextRound`, evil miners are marked in the Election contract AFTER the next round has already been pre-generated: [4](#0-3) 

The critical issue: line 110 shows `nextRound` is already created (from pre-generated consensus data), then lines 139-154 detect and mark evil miners, and line 156 adds this pre-generated round. This means evil miners detected at round N's end are marked as banned but still remain in round N+1's miner list.

When the next round is generated, it queries `GetMinerReplacementInformation` to remove evil miners: [5](#0-4) 

But this happens BEFORE the evil miners are detected and marked. The `GetEvilMinersPubkeys` function checks the `BannedPubkeyMap`: [6](#0-5) 

**Execution Flow Demonstrating the Gap:**

1. Round N: Miner accumulates excessive missed time slots
2. Round N ends, extra block producer generates Round N+1 via `GenerateNextRoundInformation` - at this point the miner is NOT yet in `BannedPubkeyMap`, so they remain in Round N+1
3. Block executes, `ProcessNextRound` detects the evil miner and marks them in `BannedPubkeyMap`
4. Round N+1 becomes current - evil miner is NOW banned BUT still in `RealTimeMinersInformation`
5. Evil miner can call `ProposeCrossChainIndexing` and `ReleaseCrossChainIndexingProposal` because `IsCurrentMiner` returns true
6. Only when Round N+2 is generated will the miner be removed

The cross-chain contract enforces this insufficient check: [7](#0-6) 

And both critical cross-chain indexing entry points use this check: [8](#0-7) [9](#0-8) 

### Impact Explanation

**Cross-Chain Data Integrity Compromise**: Evil miners who have been detected and banned can still propose and release cross-chain indexing data for one complete round. This allows them to potentially submit fraudulent parent chain or side chain block data, which could include:
- Invalid merkle tree roots
- Incorrect block heights
- Malicious transaction status information

**Consensus System Trust Violation**: The system explicitly detects and bans malicious miners, yet the authorization system continues to trust them for critical cross-chain operations. This undermines the entire evil node detection mechanism.

**Affected Parties**: 
- All chains relying on cross-chain indexing integrity
- Side chains trusting parent chain data indexed by evil miners
- Parent chains trusting side chain data indexed by evil miners
- Users performing cross-chain transactions during this window

**Severity**: High - While the window is limited to one round, cross-chain data integrity is critical for the security of the entire multi-chain ecosystem. Fraudulent cross-chain data could enable double-spending or other attacks across chain boundaries.

### Likelihood Explanation

**Attack Practicality**: The attack is highly practical and requires minimal sophistication:
1. Attacker operates a miner node and intentionally misses time slots to accumulate `MissedTimeSlots >= TolerableMissedTimeSlotsCount`
2. When detected and banned at round transition, they immediately call `ProposeCrossChainIndexing` during the subsequent round
3. No special privileges beyond being an existing miner are required

**Preconditions**:
- Attacker must be an active miner (realistic for malicious actors)
- Must accumulate sufficient missed time slots to trigger evil detection
- Timing must be coordinated to act within the one-round window

**Detection Difficulty**: The attack is difficult to detect because:
- The miner appears legitimate to the `IsCurrentMiner` check
- Cross-chain proposals go through normal governance flow
- Only the Election contract knows they are banned

**Economic Feasibility**: The cost is reasonable - the attacker loses their miner position but gains the ability to submit one round of potentially malicious cross-chain data before full removal. For high-value cross-chain attacks, this trade-off is economically rational.

**Probability**: Medium-to-High - Any miner approaching the missed time slot threshold knows they have one round to act maliciously before complete removal from the system.

### Recommendation

**Primary Fix**: Add `BannedPubkeyMap` validation to the `IsCurrentMiner` function:

```csharp
private bool IsCurrentMiner(string pubkey)
{
    if (pubkey == null) return false;
    
    // Check if miner has been banned (marked as evil)
    if (State.IsMainChain.Value)
    {
        var isBanned = State.ElectionContract.GetPubkeyBannedStatus.Call(new StringValue { Value = pubkey }).Value;
        if (isBanned) return false;
    }
    
    if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;
    // ... rest of existing logic
}
```

This requires adding a new view method to the Election contract:
```csharp
public override BoolValue GetPubkeyBannedStatus(StringValue input)
{
    return new BoolValue { Value = State.BannedPubkeyMap[input.Value] };
}
```

**Alternative Fix**: Add the check directly in `CheckCrossChainIndexingPermission` before delegating to `IsCurrentMiner`.

**Invariant to Enforce**: No address marked in `BannedPubkeyMap` should pass any miner permission check, regardless of their presence in the current round's miner list.

**Test Cases**:
1. Verify evil miner cannot call `ProposeCrossChainIndexing` in the round immediately after being banned
2. Verify evil miner cannot call `ReleaseCrossChainIndexingProposal` in the round immediately after being banned
3. Verify normal miners unaffected by the additional check
4. Verify the check works correctly across round transitions

### Proof of Concept

**Initial State**:
- Blockchain at round N with miner M active
- Miner M has accumulated `MissedTimeSlots = TolerableMissedTimeSlotsCount` in round N
- Cross-chain indexing controller organization configured

**Attack Sequence**:

1. **Round N ends, transition begins**:
   - Extra block producer calls consensus to generate round N+1
   - `GenerateNextRoundInformation` queries `GetMinerReplacementInformation`
   - Miner M NOT yet in `BannedPubkeyMap`, so included in round N+1
   
2. **Block execution completes round transition**:
   - `ProcessNextRound` detects M as evil (line 140)
   - M marked in `BannedPubkeyMap` via `UpdateCandidateInformation` (lines 148-152)
   - Round N+1 added to state with M still in `RealTimeMinersInformation` (line 156)
   - Current round number updated to N+1 (line 158)

3. **Round N+1 is now current - attack window opens**:
   - Call `CheckCrossChainIndexingPermission(M.Address)` â†’ returns `true`
   - M calls `ProposeCrossChainIndexing` with malicious cross-chain data
   - Transaction succeeds because `AssertAddressIsCurrentMiner` check passes
   - Malicious proposal created

4. **M can continue malicious actions throughout round N+1**:
   - M calls `ReleaseCrossChainIndexingProposal` 
   - If proposal approved by governance, fraudulent cross-chain data indexed

5. **Round N+1 ends, round N+2 begins**:
   - `GenerateNextRoundInformation` queries `GetMinerReplacementInformation`
   - M now in `BannedPubkeyMap`, removed from round N+2
   - Attack window closes

**Expected vs Actual Result**:
- **Expected**: Once marked as evil, miner M should fail all permission checks immediately
- **Actual**: Miner M can propose and release cross-chain indexing data for entire round N+1

**Success Condition**: Execute `ProposeCrossChainIndexing` as banned miner M during round N+1 without transaction reverting, demonstrating the authorization bypass.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L136-144)
```csharp
    private bool IsCurrentMiner(string pubkey)
    {
        if (pubkey == null) return false;

        if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;

        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-342)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-156)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-291)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```
