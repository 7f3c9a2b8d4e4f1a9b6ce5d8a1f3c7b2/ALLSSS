# Audit Report

## Title
Division by Zero DoS in Consensus Miner Count Calculation Due to Missing Validation in SetMinerIncreaseInterval

## Summary
The `SetMinerIncreaseInterval()` function lacks validation to prevent setting `State.MinerIncreaseInterval.Value` to zero, allowing Parliament governance to cause a division by zero exception in critical consensus operations, resulting in permanent blockchain halt with no self-recovery mechanism.

## Finding Description

The vulnerability exists in `SetMinerIncreaseInterval()` which only validates that the new interval is less than or equal to the current value, but does not enforce a minimum positive value: [1](#0-0) 

The assertion on line 61 allows zero: `Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval")`. If the current value is 31536000 (default) and an input of 0 is provided, the assertion passes since 0 â‰¤ 31536000.

This zero value is then used as a divisor in two critical locations:

**Location 1 - GetAutoIncreasedMinersCount():** [2](#0-1) 

Line 94 performs `.Div(State.MinerIncreaseInterval.Value)` which will throw `DivideByZeroException` if the value is 0.

**Location 2 - GetMinersCount():** [3](#0-2) 

Line 390 performs the same division operation.

The `Div()` extension method throws `DivideByZeroException` for integer division by zero: [4](#0-3) 

This behavior is confirmed by tests: [5](#0-4) 

**Critical Call Paths:**

`GetMinersCount()` is called during consensus operations in `ProcessNextRound()` during first round initialization: [6](#0-5) 

And in `UpdateMinersCountToElectionContract()` during term transitions: [7](#0-6) 

Which is invoked by `ProcessNextTerm()`: [8](#0-7) 

Both NextRound and NextTerm are essential consensus operations that must succeed for blockchain operation.

## Impact Explanation

**Operational Impact - Complete Consensus DoS:**
- Once `MinerIncreaseInterval` is set to 0, any subsequent call to `NextRound` or `NextTerm` will fail with `DivideByZeroException`
- These are mandatory consensus operations executed every round (typically every few minutes) and term (typically every week)
- The blockchain becomes permanently stuck and cannot progress
- No transactions can be processed, including governance transactions to fix the issue
- Only solution is validator coordination for hard fork or contract upgrade through off-chain means

**Affected Operations:**
1. Round transitions (NextRound) - required for block production
2. Term transitions (NextTerm) - required for miner rotation
3. Election contract miner count updates - breaks election mechanics
4. View methods like `GetMaximumMinersCount()` - breaks external integrations

**Severity: Critical** - Complete halt of blockchain operation with no self-recovery mechanism.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Control of `MaximumMinersCountController`, which defaults to Parliament's default organization: [9](#0-8) 

This requires either compromise of governance or approval from Parliament majority.

**Attack Complexity:**
- Single governance transaction: `SetMinerIncreaseInterval(0)`
- The validation at line 61 only checks upper bound, allowing zero to pass
- No recovery mechanism exists once set

**Feasibility Conditions:**
- Contract must be initialized (always true in production)
- `BlockchainStartTimestamp` must be set (happens during first round): [10](#0-9) 

Both conditions are always true after genesis.

**Validation Gap:**
Test coverage shows the zero case was never validated: [11](#0-10) 

Tests only check `currentValue + 1` (fails) and `currentValue - 1` (passes), not zero or negative values.

**Overall Likelihood:** Medium - While governance control is required, the missing validation represents a significant oversight. Zero is mathematically invalid for an "interval", and proper bounds checking could prevent catastrophic misconfiguration or malicious governance actions.

## Recommendation

Add validation to enforce a minimum positive value for `MinerIncreaseInterval`:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Miner increase interval must be positive.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

Additionally, add test coverage for zero and negative value scenarios to prevent regression.

## Proof of Concept

```csharp
[Fact]
public async Task SetMinerIncreaseInterval_WithZero_ShouldCauseConsensusFailure()
{
    // Setup: Initialize consensus and parliament
    await InitializeContracts();
    
    // Create and approve Parliament proposal to set interval to 0
    var proposalId = await CreateProposalAsync(
        ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        nameof(ConsensusStub.SetMinerIncreaseInterval),
        new Int64Value { Value = 0 }
    );
    await ApproveWithMinersAsync(proposalId);
    await ReleaseProposalAsync(proposalId);
    
    // Attempt next round/term transition - should fail with DivideByZeroException
    var result = await ConsensusStub.NextRound.SendWithExceptionAsync(new NextRoundInput { /* ... */ });
    result.TransactionResult.Error.ShouldContain("DivideByZeroException");
    
    // Blockchain is now permanently halted - cannot recover via transactions
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L31-43)
```csharp
    private void RequiredMaximumMinersCountControllerSet()
    {
        if (State.MaximumMinersCountController.Value != null) return;
        EnsureParliamentContractAddressSet();

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MaximumMinersCountController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L49-56)
```csharp
        number2.Mul(6).ShouldBe(36L);
        Should.Throw<DivideByZeroException>(() => { number1.Div(0); });
        Should.Throw<DivideByZeroException>(() => { number2.Div(0); });

        number1.Div(2).ShouldBe(3UL);
        number2.Div(-2).ShouldBe(-3L);
        Should.Throw<DivideByZeroException>(() => { 5.Div(0); });
        Should.Throw<DivideByZeroException>(() => { (-5).Div(0); });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L117-137)
```csharp
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-177)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L121-135)
```csharp
        var transactionResult = await ParliamentReachAnAgreementWithExceptionAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = minerIncreaseInterval.Value + 1
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        transactionResult.Error.ShouldContain("Invalid interval");
        var newMinerIncreaseInterval = minerIncreaseInterval.Value - 1;
        await ParliamentReachAnAgreementAsync(new CreateProposalInput
        {
```
