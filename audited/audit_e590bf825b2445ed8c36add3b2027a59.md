### Title
ContractVersion Downgrade Attack via Self-Declared Assembly Metadata

### Summary
The `UpdateSmartContract` function's version check (lines 125-126) can be bypassed because it relies on assembly version metadata that is controlled by the contract deployer. An attacker with contract update authorization can recompile old vulnerable code with a higher assembly version number, bypassing version checks designed to prevent downgrades, and successfully deploy vulnerable code as an "upgrade".

### Finding Description

The vulnerability exists in the contract version validation mechanism used during smart contract updates: [1](#0-0) 

The `IsSubsequentVersion` check validates that the new contract version is higher than the current version. However, the `ContractVersion` value is extracted from the .NET assembly metadata of the contract code being deployed: [2](#0-1) 

This extraction occurs through the SmartContractService when loading the contract: [3](#0-2) 

The version comparison logic only checks string-based semantic versioning: [4](#0-3) 

**Root Cause**: The system trusts the assembly version metadata embedded in the contract code by the deployer. There is no verification that the assembly version accurately represents the actual evolution of contract logic. An attacker can:

1. Take old vulnerable contract code (e.g., from version 1.0.0.0)
2. Make trivial modifications (comments, whitespace) to change the code hash and bypass the uniqueness check: [5](#0-4) 

3. Recompile with a higher assembly version number (e.g., 3.0.0.0) than the current deployed version (e.g., 2.0.0.0)
4. Submit as an upgrade through the governance process or as contract author

Both pre-deployment and deployment version checks will pass because they only validate the self-declared assembly version: [6](#0-5) [7](#0-6) 

### Impact Explanation

**Security Degradation**: This vulnerability allows deploying old vulnerable code disguised as an upgrade, defeating the entire purpose of version checking and security improvements through contract updates.

**Affected Parties**:
- **System Contracts**: If governance is compromised or deceived, critical system contracts (Consensus, Token, Treasury, etc.) could be downgraded to vulnerable versions
- **User Contracts**: Contract authors with compromised keys could have their contracts downgraded without users' knowledge
- **End Users**: Users relying on version numbers to assess contract security would be misled

**Concrete Harm**:
1. Previously patched vulnerabilities can be reintroduced
2. Security audits become ineffective if version numbers don't reflect actual code evolution  
3. The version check provides false security assurance
4. Automated monitoring systems tracking contract versions would be bypassed

**Severity Justification**: HIGH - While authorization is required, the fundamental design flaw allows circumventing a critical security mechanism (version checking) that should enforce forward-only progression regardless of who has authorization.

### Likelihood Explanation

**Attacker Capabilities Required**:
- **For System Contracts**: Governance approval through Parliament/Association, or compromised CodeCheckController [8](#0-7) 

- **For User Contracts**: Contract author credentials or governance authority [9](#0-8) 

**Attack Complexity**: Low - The technical execution is straightforward:
1. Obtain old contract source code (often public)
2. Modify assembly version in compilation
3. Make trivial code changes for unique hash
4. Submit through standard update process

**Feasibility Conditions**:
- Governance compromise (realistic through social engineering, key compromise, or malicious proposals that pass review)
- Contract author key compromise (realistic through phishing, malware, or insider threat)
- Code review failures by block producers (realistic if changes are subtle or reviewers focus only on new features)

**Detection Constraints**: The attack is difficult to detect because:
- Version numbers appear to progress forward (3.0.0.0 > 2.0.0.0)
- Code changes would be visible but might be overlooked if disguised among other modifications
- Existing test only validates version comparison logic, not prevention of code regression: [10](#0-9) 

**Probability**: MEDIUM - Requires authorization but governance attacks and key compromises are realistic threat models in blockchain systems.

### Recommendation

**Primary Fix**: Decouple version validation from self-declared assembly metadata. Use the system-managed sequential `Version` field for enforcement:

1. **Modify UpdateSmartContract** to validate against the sequential integer version rather than assembly version string
2. **Remove reliance on assembly metadata** for version checking - use it only for informational purposes
3. **Implement code lineage tracking** - maintain cryptographic hashes of previous contract versions and prevent reintroduction of old code patterns even with different hashes

**Specific Code Changes**:
- In `UpdateSmartContract` helper, compare against `info.Version` increments only
- Store historical code hashes and check new code doesn't match patterns from older versions
- Make assembly version purely informational, displayed in events but not used for validation

**Additional Invariant Checks**:
- Assert that code changes between versions introduce actual modifications beyond trivial changes
- Implement structural code analysis to detect functional rollbacks
- Require explicit governance votes for any update that reduces code functionality

**Test Cases to Add**:
1. Test attempting to deploy old code with higher assembly version number - should FAIL
2. Test that trivial modifications (comments/whitespace) don't bypass version protection  
3. Test that assembly version mismatches with sequential version increments are rejected
4. Integration test simulating governance-approved downgrade attempt - should FAIL

### Proof of Concept

**Initial State**:
- Contract deployed at version 2.0.0.0 with secure code (CodeB)
- Previous version 1.0.0.0 had vulnerability (CodeA)
- ContractInfo.Version = 2, ContractInfo.ContractVersion = "2.0.0.0"

**Attack Sequence**:

1. **Obtain Old Code**: Attacker retrieves CodeA (version 1.0.0.0) from git history or public repositories

2. **Modify Assembly Version**: Recompile CodeA with assembly version set to "3.0.0.0" in project properties

3. **Bypass Hash Check**: Add trivial comment `// Update for v3` to change code hash from `Hash(CodeA)` to `Hash(CodeA')`

4. **Submit Update Proposal**:
   - Call `ProposeUpdateContract` with address and CodeA' bytes
   - AssertContractVersion check at line 184 extracts version from CodeA' → "3.0.0.0"
   - Comparison: "3.0.0.0" > "2.0.0.0" → CHECK PASSES
   - AssertContractNotExists check: Hash(CodeA') ≠ Hash(CodeA) and Hash(CodeA') ≠ Hash(CodeB) → CHECK PASSES

5. **Governance Approval**: Proposal approved through Parliament (requires governance compromise or deception)

6. **Execute Update**:
   - `UpdateSmartContract` called with CodeA'
   - Context.UpdateSmartContract extracts version from CodeA' → "3.0.0.0"  
   - IsSubsequentVersion check: "3.0.0.0" > "2.0.0.0" → TRUE → CHECK PASSES
   - ContractInfo updated: Version = 3, ContractVersion = "3.0.0.0", CodeHash = Hash(CodeA')

**Expected vs Actual Result**:
- **Expected**: Update rejected because CodeA' represents a functional downgrade despite higher version number
- **Actual**: Update succeeds, vulnerable code from v1.0 deployed as v3.0

**Success Condition**: Contract at address now runs CodeA' (vulnerable logic) with ContractInfo showing Version=3 and ContractVersion="3.0.0.0", bypassing version protection.

### Notes

This vulnerability represents a fundamental design flaw where security-critical version enforcement relies on attacker-controlled metadata rather than system-enforced invariants. While authorization is required to exploit it, the version check mechanism itself provides inadequate protection against downgrades. The separate sequential `Version` field (int32) exists but is not used for validation - only the self-declared `ContractVersion` string is checked, creating the bypass opportunity.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L107-107)
```csharp
        AssertContractNotExists(newCodeHash);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L124-126)
```csharp
        var contractInfo = Context.UpdateSmartContract(contractAddress, reg, null, info.ContractVersion);
        Assert(contractInfo.IsSubsequentVersion,
            $"The version to be deployed is lower than the effective version({info.ContractVersion}), please correct the version number.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L366-377)
```csharp
    private void AssertContractVersion(string currentVersion, ByteString code, int category)
    {
        var contractVersionCheckResult =
            Context.CheckContractVersion(currentVersion, new SmartContractRegistration
            {
                Code = code,
                Category = category,
                CodeHash = HashHelper.ComputeFrom(code.ToByteArray())
            });
        Assert(contractVersionCheckResult.IsSubsequentVersion,
            $"The version to be deployed is lower than the effective version({currentVersion}), please correct the version number.");
    }
```

**File:** src/AElf.Runtime.CSharp/CSharpSmartContractRunner.cs (L33-33)
```csharp
        ContractVersion = assembly.GetName().Version?.ToString();
```

**File:** src/AElf.Kernel.SmartContract/Application/SmartContractService.cs (L42-51)
```csharp
    public async Task<ContractInfoDto> UpdateContractAsync(string previousContractVersion,SmartContractRegistration registration)
    {
        var newContractVersion = await GetVersion(registration);
        var isSubsequentVersion = CheckVersion(previousContractVersion,newContractVersion);
        return new ContractInfoDto
        {
            ContractVersion = newContractVersion,
            IsSubsequentVersion = isSubsequentVersion
        };
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/SmartContractService.cs (L77-90)
```csharp
    private bool CheckVersion(string previousContractVersion,string newContractVersion)
    {
        if (newContractVersion.IsNullOrEmpty())
        {
            return false;
        }

        if (previousContractVersion.IsNullOrEmpty())
        {
            return true;
        }

        return  new Version(previousContractVersion) < new Version(newContractVersion);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L183-184)
```csharp
        AssertAuthorityByContractInfo(info, Context.Sender);
        AssertContractVersion(info.ContractVersion, input.Code, info.Category);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L324-337)
```csharp
    public override Address UpdateSmartContract(ContractUpdateInput input)
    {
        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        var inputHash = CalculateHashFromInput(input);

        if (!TryClearContractProposingData(inputHash, out _))
            Assert(Context.Sender == info.Author, "No permission.");

        UpdateSmartContract(contractAddress, input.Code.ToByteArray(), info.Author, false);

        return contractAddress;
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L569-573)
```csharp
        var proposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeUpdateContract), contractUpdateInput);
        proposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
        proposingTxResult.Error.ShouldContain("The version to be deployed is lower than the effective version");
    }
```
