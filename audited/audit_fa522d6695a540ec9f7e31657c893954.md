### Title
Unauthorized ExtraBlockProducer Assignment Allows Any Miner to Gain Privileged Mining Rights

### Summary
The `GenerateFirstRoundOfNextTerm()` function unconditionally sets `ExtraBlockProducerOfPreviousRound` to the sender's public key without validating that the sender was the legitimate extra block producer of the previous round. This allows any miner in the current term to produce the NextTerm block and gain unauthorized mining privileges at the start of the new term, disrupting fair block production and consensus integrity.

### Finding Description

**Root Cause Location:** [1](#0-0) 

The vulnerable line unconditionally assigns the sender's public key to `ExtraBlockProducerOfPreviousRound` without any verification that the sender was the designated extra block producer (the miner with `IsExtraBlockProducer = true`) in the previous round.

**Why Existing Protections Fail:**

1. **Insufficient Authorization Check in PreCheck:** [2](#0-1) 

The PreCheck only validates if the sender is in the current or previous miner list, not whether they were the extra block producer.

2. **Missing Validation in MiningPermissionValidationProvider:** [3](#0-2) 

This validator only checks if the sender is in the miner list, not their specific role as extra block producer.

3. **Inadequate TimeSlotValidationProvider:** [4](#0-3) 

For NextTerm behavior, the validator only checks that the new round's time slots are properly spaced (CheckRoundTimeSlots), not whether the sender is authorized to produce the term-ending block.

4. **No Extra Block Producer Validation in RoundTerminateValidationProvider:** [5](#0-4) 

The NextTerm validation only checks round and term number increments, not who can produce the block.

**Exploitation Path:**

The consensus behavior provider determines NextTerm based on time/duration, not on whether the miner is the extra block producer: [6](#0-5) 

Any miner can trigger NextTerm behavior when term change conditions are met, allowing them to produce the NextTerm block and have their public key incorrectly recorded.

**Critical Authorization Usage:** [7](#0-6) 

The `ExtraBlockProducerOfPreviousRound` field is used to authorize block production at the start of a new round, making this assignment critical for consensus security.

### Impact Explanation

**Consensus Integrity Violation:**
- The attacker gains unauthorized mining privileges at the start of the new term, allowing them to produce blocks during a time slot that should belong to the legitimate extra block producer
- This violates the fair block production schedule and miner rotation mechanism
- The legitimate extra block producer loses their earned privilege

**Reward Misallocation:**
- The attacker can produce additional blocks beyond their allocated time slot
- This results in the attacker receiving more block rewards than deserved
- Mining rewards become unfairly distributed among miners

**Operational Disruption:**
- The extra block producer mechanism is designed to ensure smooth round transitions
- Incorrect assignment can lead to timing conflicts and consensus instability
- Multiple miners may compete for the same time slot, potentially causing forking

**Severity: High**
This is a critical consensus mechanism vulnerability that allows privilege escalation and disrupts the fundamental fairness guarantees of the AEDPoS consensus protocol.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Attacker must be a legitimate miner in the current term's miner list (realistic for a motivated attacker through staking/election)
- No special permissions beyond being an active miner

**Attack Complexity: Low**
1. Monitor blockchain state to detect when term change is approaching
2. Query `GetConsensusCommand` to receive NextTerm behavior
3. Produce NextTerm block (racing with legitimate extra block producer)
4. If block is accepted first, gain unauthorized privileges

**Feasibility Conditions:**
- Term change occurs regularly (every period, e.g., 7 days based on `PeriodSeconds`)
- Multiple miners can receive NextTerm behavior simultaneously since there's no restriction
- Network latency and block propagation dynamics allow for racing

**Detection Difficulty:**
- Attack is difficult to detect as the attacker is a legitimate miner
- The consensus mechanism has no explicit check to verify correct extra block producer assignment
- Appears as normal consensus operation from external view

**Economic Rationality:**
- Low cost: attacker only needs to be in the miner list (achievable through normal election process)
- High benefit: gain extra mining opportunities and rewards
- Attack can be repeated at every term change

**Probability: Medium-High**
Given that any of the ~17-19 miners can attempt this attack at each term change, and term changes occur regularly, the probability of exploitation is significant.

### Recommendation

**1. Validate Sender is Extra Block Producer:**
Add validation in `GenerateFirstRoundOfNextTerm()` to verify the sender was the designated extra block producer in the previous round:

```csharp
private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
{
    // ... existing code ...
    
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // CRITICAL FIX: Validate sender is the legitimate extra block producer
    var extraBlockProducer = currentRound.RealTimeMinersInformation
        .FirstOrDefault(m => m.Value.IsExtraBlockProducer);
    
    Assert(extraBlockProducer.Key == senderPubkey, 
        "Only the designated extra block producer can initiate next term.");
    
    // ... rest of existing code ...
    newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;
    
    return newRound;
}
```

**2. Add Validation Provider:**
Create a new `ExtraBlockProducerValidationProvider` to enforce this check during `ValidateBeforeExecution`: [8](#0-7) 

Add this validator for NextTerm behavior to ensure only the extra block producer can produce term-ending blocks.

**3. Test Cases:**
- Verify non-extra-block-producer cannot produce NextTerm block
- Verify legitimate extra block producer can produce NextTerm block
- Verify `ExtraBlockProducerOfPreviousRound` is correctly set only when legitimate producer creates NextTerm
- Test race condition scenarios with multiple miners attempting NextTerm simultaneously

### Proof of Concept

**Initial State:**
- Current term has 17 miners (Miner A through Q)
- Miner A has `IsExtraBlockProducer = true` (legitimate extra block producer)
- Attacker is Miner B (regular miner, not extra block producer)
- Term duration has elapsed, term change is required

**Attack Steps:**

1. **Attacker queries consensus command:**
   - Miner B calls `GetConsensusCommand` with their public key
   - Receives `AElfConsensusBehaviour.NextTerm` because term needs to change [9](#0-8) 

2. **Attacker produces NextTerm block:**
   - Miner B produces block with NextTerm consensus data
   - Block passes `ValidateBeforeExecution` because:
     - Miner B is in miner list ✓
     - Time slots are properly spaced ✓
     - Term number increments correctly ✓
     - **No check that Miner B should be extra block producer** ✗

3. **Vulnerable assignment executes:**
   - `GetConsensusExtraDataForNextTerm` calls `GenerateFirstRoundOfNextTerm(MinerB_pubkey, ...)` [10](#0-9) 
   - Line 254 sets: `newRound.ExtraBlockProducerOfPreviousRound = MinerB_pubkey`
   - NextTerm transaction executes successfully

4. **Attacker gains unauthorized privilege:**
   - In next term's first round, when `Context.CurrentBlockTime <= nextRound.GetRoundStartTime()`
   - `IsCurrentMiner` check allows Miner B to mine because `nextRound.ExtraBlockProducerOfPreviousRound == MinerB_pubkey` [7](#0-6) 
   - Miner B produces blocks during time that should belong to legitimate extra block producer (Miner A)

**Expected Result:** Only Miner A (with `IsExtraBlockProducer = true`) should be able to produce NextTerm block and be recorded as `ExtraBlockProducerOfPreviousRound`

**Actual Result:** Miner B (without extra block producer privilege) successfully produces NextTerm block and gains unauthorized `ExtraBlockProducerOfPreviousRound` status, allowing extra mining opportunities in the next term

**Success Condition:** Attacker verifies `State.Rounds[newTermRound].ExtraBlockProducerOfPreviousRound == MinerB_pubkey` and successfully produces blocks at start of new term outside their normal time slot.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L150-155)
```csharp
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L254-254)
```csharp
        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-46)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L39-46)
```csharp
        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L209-209)
```csharp
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
```
