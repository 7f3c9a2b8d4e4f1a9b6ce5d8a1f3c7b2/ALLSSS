### Title
EnableConnector Allows Permanent DoS When Token TotalSupply is Zero Without Virtual Balance

### Summary
The `GetNeededDeposit` function fails to validate that a token's effective balance (TotalSupply + VirtualBalance) is greater than zero before allowing connector enablement. This allows connectors to be enabled in an unusable state where all Buy/Sell operations will permanently fail due to zero balance, and the connector cannot be updated post-activation.

### Finding Description

The vulnerability exists in the `GetNeededDeposit` function which calculates required deposits before enabling a token connector pair. [1](#0-0) 

When a token has `TotalSupply = 0` and the resource connector has `IsVirtualBalanceEnabled = false` (the default when created via `AddPairConnector`): [2](#0-1) 

The calculation at line 73 yields: `amountOutOfTokenConvert = 0 - 0 - 0 = 0`, causing the condition at line 75 to be false, resulting in `needDeposit = 0`. This allows `EnableConnector` to proceed without any validation: [3](#0-2) 

Once enabled, all Buy operations fail because `BancorHelper.GetAmountToPayFromReturn` requires positive connector balances: [4](#0-3) 

When `GetSelfBalance` is called for a resource connector with no virtual balance and TotalSupply = 0, it returns 0: [5](#0-4) 

The connector cannot be fixed post-activation because `UpdateConnector` explicitly prevents updating enabled connectors: [6](#0-5) 

### Impact Explanation

This vulnerability causes **permanent Denial of Service** for token conversion operations:

1. **Operational Harm**: All Buy operations throw "Connector balance needs to be a positive number" exception
2. **Sell Operations**: Similarly fail with the same validation error in `GetReturnFromPaid`
3. **Permanence**: No recovery mechanism exists - connectors cannot be updated, disabled, or removed once enabled
4. **Affected Parties**: Any users attempting to trade the affected token pair
5. **Severity Justification**: While not directly causing fund loss, it creates permanently unusable infrastructure that wastes governance resources and breaks protocol functionality

### Likelihood Explanation

**Attacker Capabilities**: 
- Token creator or governance controller can create tokens with TotalSupply = 0
- Anyone can call `EnableConnector` (no access control on the function itself)

**Attack Complexity**: Low
1. Create token without minting (TotalSupply = 0) or burn all tokens
2. Add connector pair via governance (resource connector defaults to no virtual balance)
3. Call `EnableConnector` with `AmountToTokenConvert = 0`
4. Connector enables with zero effective balance

**Feasibility Conditions**:
- Requires governance approval for `AddPairConnector` or token owner cooperation
- Token must not have virtual balance enabled for resource connector
- Realistic scenario: accidental early enablement before token distribution

**Probability**: Medium - While requiring governance involvement or token owner action, the scenario is plausible during token initialization phases where connectors might be set up before token minting/distribution begins.

### Recommendation

**Code-Level Mitigation**:

Add validation in `GetNeededDeposit` to ensure effective balance will be positive after enablement:

```csharp
// After line 80, add:
var effectiveBalance = toConnector.IsVirtualBalanceEnabled 
    ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
    : tokenInfo.TotalSupply;
    
Assert(effectiveBalance > 0 || (toConnector.IsVirtualBalanceEnabled && toConnector.VirtualBalance > 0),
    "Cannot enable connector: token effective balance must be greater than zero. " +
    "Either mint tokens, enable virtual balance, or set virtual balance > 0.");
```

**Invariant Checks**:
- Resource connector effective balance (real + virtual) must be > 0 before enabling
- Deposit connector balance must be > 0 before enabling

**Test Cases**:
1. Test `GetNeededDeposit` with TotalSupply = 0 and no virtual balance (should fail)
2. Test `EnableConnector` with TotalSupply = 0 and no virtual balance (should fail)
3. Test successful enablement only when TotalSupply > 0 OR VirtualBalance > 0
4. Test that Buy/Sell work correctly after proper enablement

### Proof of Concept

**Required Initial State**:
- TokenConverter contract initialized
- Token "TEST" created with TotalSupply = 100_0000_0000 but 0 issued
- Parliament governance configured

**Transaction Steps**:

1. **Add Connector Pair** (via governance):
   - Call `AddPairConnector` with ResourceConnectorSymbol = "TEST"
   - Resource connector created with `IsVirtualBalanceEnabled = false` (default)
   - Deposit connector created with virtual balance

2. **Burn All Tokens**:
   - Burn all 100_0000_0000 tokens
   - TotalSupply becomes 0

3. **Query Needed Deposit**:
   - Call `GetNeededDeposit({TokenSymbol: "TEST", AmountToTokenConvert: 0})`
   - **Expected**: Error or warning about zero balance
   - **Actual**: Returns `{NeedAmount: 0, AmountOutOfTokenConvert: 0}`

4. **Enable Connector**:
   - Call `EnableConnector({TokenSymbol: "TEST", AmountToTokenConvert: 0})`
   - **Expected**: Should fail validation
   - **Actual**: Succeeds, sets `IsPurchaseEnabled = true`

5. **Attempt Buy Operation**:
   - Call `Buy({Symbol: "TEST", Amount: 100})`
   - **Expected**: Should work or fail gracefully
   - **Actual**: Throws exception "Connector balance needs to be a positive number."

6. **Attempt Fix via UpdateConnector**:
   - Try `UpdateConnector` to add virtual balance
   - **Expected**: Should allow fixing the issue
   - **Actual**: Fails with "connector can not be updated because it has been activated"

**Success Condition**: Connector is enabled with zero effective balance, all trading operations fail permanently, and no recovery mechanism exists.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L62-90)
```csharp
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(
            new GetTokenInfoInput
            {
                Symbol = input.TokenSymbol
            });
        var balance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = input.TokenSymbol
            }).Balance;
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }

        return new DepositInfo
        {
            NeedAmount = needDeposit,
            AmountOutOfTokenConvert = amountOutOfTokenConvert
        };
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L64-64)
```csharp
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L87-93)
```csharp
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L70-71)
```csharp
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");
```
