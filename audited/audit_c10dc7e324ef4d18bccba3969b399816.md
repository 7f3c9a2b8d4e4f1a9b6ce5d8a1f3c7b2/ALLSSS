# Audit Report

## Title
Missing Authorization Check on InitialCoefficients Enables Privilege Escalation in Fee Configuration

## Summary
The `InitialCoefficients` method in the MultiToken contract lacks sender authorization validation, creating a privilege escalation vulnerability. While normal deployment atomically initializes coefficients, any deployment misconfiguration that omits this initialization would allow an arbitrary attacker to gain complete control over system-wide transaction fee calculation formulas, bypassing the governance framework entirely.

## Finding Description

The MultiToken contract manages fee calculation coefficients through `State.AllCalculateFeeCoefficients`, which controls formulas for all transaction types (READ, STORAGE, WRITE, TRAFFIC, TX) affecting every transaction on the chain.

Three methods can modify these coefficients:

1. **InitialCoefficients** - Publicly accessible with NO authorization check, only validates coefficients aren't already set [1](#0-0) 

2. **UpdateCoefficientsForContract** - Protected by `AssertDeveloperFeeController()` requiring governance approval [2](#0-1) 

3. **UpdateCoefficientsForSender** - Protected by `AssertUserFeeController()` requiring governance approval [3](#0-2) 

The authorization assertions verify the sender matches governance-controlled organization addresses [4](#0-3) 

The method is exposed as a public RPC endpoint [5](#0-4)  and only performs a state-based check, not a sender authorization check.

In normal operation, initialization occurs atomically:
- Main chain: EconomicContract.InitialEconomicSystem calls InitialCoefficients [6](#0-5) 
- Side chain: TokenContractInitializationProvider includes InitialCoefficients in the method call list [7](#0-6) 
- Deployment uses Context.SendInline for atomic execution [8](#0-7) 

However, the initialization method list is configurable and constructed externally. If a deployment uses a misconfigured initialization provider that omits InitialCoefficients, the contract would be deployed with uninitialized coefficients, allowing any address to call the method and set malicious fee formulas.

## Impact Explanation

**Critical System Control:** An attacker successfully calling `InitialCoefficients` before legitimate initialization gains complete, irreversible control over fee calculation for all transaction types system-wide.

**Economic Attack Vectors:**
- Setting exponential coefficient values (e.g., x^10 instead of x^2) would cause transaction fees to grow exponentially with resource usage
- Making all transactions prohibitively expensive effectively DoSes the chain
- Targeting specific fee types (e.g., STORAGE at x^5) could selectively drain funds from contract developers
- All users across the entire chain are affected by every transaction they attempt

**Governance Bypass:** Legitimate fee updates require multi-organization approval through DeveloperFeeController (Parliament + Association) or UserFeeController (Parliament + Referendum + Association). An attacker setting initial coefficients completely bypasses this governance framework with a single transaction.

**Operational Impact:** Malicious configuration could halt all chain operations until governance can coordinate a contract upgrade, which itself would be blocked by the excessive fees the attacker controls.

The impact is HIGH because it grants system-level control over a critical economic parameter affecting all chain participants, despite requiring specific preconditions.

## Likelihood Explanation

**Attacker Requirements:** Any address that can send transactions to the deployed Token contract can call InitialCoefficients - no special privileges required.

**Attack Complexity:** Extremely low - single method call with empty parameter, no multi-step setup.

**Preconditions Required:**
1. Token contract deployed without InitialCoefficients in the initialization method list (configuration error)
2. Contract exists in deployed state with `State.AllCalculateFeeCoefficients.Value == null`

**Normal Deployment Protection:** Production deployments use IContractInitializationProvider implementations that include InitialCoefficients, and Context.SendInline ensures atomic execution where initialization either fully succeeds or the entire deployment reverts.

**Vulnerability Trigger:** The initialization method list is constructed by external configuration providers, not enforced by the contract itself. A misconfigured provider, incorrect deployment script, or future changes to deployment logic could omit this call.

**Likelihood Assessment:** LOW in current production due to established deployment patterns, but NON-ZERO because:
- Configuration is external to the contract
- No on-chain enforcement of proper initialization
- Violates defense-in-depth principles - a single configuration error creates critical vulnerability

The stark contrast between InitialCoefficients (no authorization) and UpdateCoefficients methods (strict governance checks) indicates this is a design flaw rather than intentional behavior.

## Recommendation

Add sender authorization to `InitialCoefficients` following the same pattern as the Update methods:

```csharp
public override Empty InitialCoefficients(Empty input)
{
    Assert(State.AllCalculateFeeCoefficients.Value == null, "Coefficient already initialized");
    
    // Add authorization check - only genesis contract or authorized deployer
    if (State.Initialized.Value) // After contract initialization
    {
        AssertDeveloperFeeController(); // Require governance approval
    }
    else // During initial deployment
    {
        // Only allow Economic contract or genesis contract to initialize
        var economicContract = Context.GetContractAddressByName(SmartContractConstants.EconomicContractSystemName);
        Assert(Context.Sender == economicContract || Context.Sender == Context.Self, 
               "No permission to initialize coefficients");
    }
    
    // ... existing initialization logic
}
```

This provides defense-in-depth by ensuring that even if deployment misconfiguration occurs, unauthorized addresses cannot exploit the uninitialized state.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task InitialCoefficients_MissingAuthorizationCheck_AllowsUnauthorizedInitialization()
{
    // Deploy Token contract WITHOUT calling InitialCoefficients in initialization
    var tokenContract = await DeployTokenContractWithoutInitialization();
    
    // Verify coefficients are not initialized
    var coefficients = await tokenContract.GetCalculateFeeCoefficientsForSender.CallAsync(new Empty());
    coefficients.ShouldBeNull(); // Or check that AllCalculateFeeCoefficients is null
    
    // Attacker (unauthorized address) calls InitialCoefficients
    var attackerKeyPair = CryptoHelper.GenerateKeyPair();
    var attackerStub = GetTokenContractStub(attackerKeyPair);
    
    // This should FAIL but actually SUCCEEDS due to missing authorization check
    var result = await attackerStub.InitialCoefficients.SendAsync(new Empty());
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Succeeds!
    
    // Verify attacker successfully initialized coefficients
    coefficients = await tokenContract.GetCalculateFeeCoefficientsForSender.CallAsync(new Empty());
    coefficients.ShouldNotBeNull();
    
    // Now legitimate governance cannot reinitialize (blocked by "already initialized" check)
    await tokenContract.InitialCoefficients.SendWithExceptionAsync(new Empty());
    // Throws: "Coefficient already initialized"
}
```

The test demonstrates that an arbitrary unauthorized address can successfully initialize fee coefficients if the contract is deployed without proper initialization, and this action is irreversible, permanently locking out legitimate governance.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L16-23)
```csharp
    public override Empty UpdateCoefficientsForContract(UpdateCoefficientsInput input)
    {
        Assert(input.Coefficients != null, "Invalid input coefficients.");
        Assert(input.Coefficients.FeeTokenType != (int)FeeTypeEnum.Tx, "Invalid fee type.");
        AssertDeveloperFeeController();
        UpdateCoefficients(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L25-32)
```csharp
    public override Empty UpdateCoefficientsForSender(UpdateCoefficientsInput input)
    {
        Assert(input.Coefficients != null, "Invalid input coefficients.");
        AssertUserFeeController();
        input.Coefficients.FeeTokenType = (int)FeeTypeEnum.Tx; // The only possible for now.
        UpdateCoefficients(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L108-130)
```csharp
    public override Empty InitialCoefficients(Empty input)
    {
        Assert(State.AllCalculateFeeCoefficients.Value == null, "Coefficient already initialized");
        var allCalculateFeeCoefficients = new AllCalculateFeeCoefficients();
        if (allCalculateFeeCoefficients.Value.All(x => x.FeeTokenType != (int)FeeTypeEnum.Read))
            allCalculateFeeCoefficients.Value.Add(GetReadFeeInitialCoefficient());
        if (allCalculateFeeCoefficients.Value.All(x => x.FeeTokenType != (int)FeeTypeEnum.Storage))
            allCalculateFeeCoefficients.Value.Add(GetStorageFeeInitialCoefficient());
        if (allCalculateFeeCoefficients.Value.All(x => x.FeeTokenType != (int)FeeTypeEnum.Write))
            allCalculateFeeCoefficients.Value.Add(GetWriteFeeInitialCoefficient());
        if (allCalculateFeeCoefficients.Value.All(x => x.FeeTokenType != (int)FeeTypeEnum.Traffic))
            allCalculateFeeCoefficients.Value.Add(GetTrafficFeeInitialCoefficient());
        if (allCalculateFeeCoefficients.Value.All(x => x.FeeTokenType != (int)FeeTypeEnum.Tx))
            allCalculateFeeCoefficients.Value.Add(GetTxFeeInitialCoefficient());
        State.AllCalculateFeeCoefficients.Value = allCalculateFeeCoefficients;

        Context.Fire(new CalculateFeeAlgorithmUpdated
        {
            AllTypeFeeCoefficients = allCalculateFeeCoefficients
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L383-397)
```csharp
    private void AssertDeveloperFeeController()
    {
        Assert(State.DeveloperFeeController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");

        Assert(Context.Sender == State.DeveloperFeeController.Value.RootController.OwnerAddress, "no permission");
    }

    private void AssertUserFeeController()
    {
        Assert(State.UserFeeController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");
        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == State.UserFeeController.Value.RootController.OwnerAddress, "no permission");
    }
```

**File:** protobuf/token_contract.proto (L99-101)
```text
    // Initialize coefficients of every type of tokens supporting charging fee.
    rpc InitialCoefficients (google.protobuf.Empty) returns (google.protobuf.Empty){
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L36-36)
```csharp
        State.TokenContract.InitialCoefficients.Send(new Empty());
```

**File:** src/AElf.Kernel.Token/TokenContractInitializationProvider.cs (L53-57)
```csharp
            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractContainer.TokenContractStub.InitialCoefficients),
                Params = new Empty().ToByteString()
            });
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L115-117)
```csharp
        if (transactionMethodCallList != null)
            foreach (var methodCall in transactionMethodCallList.Value)
                Context.SendInline(address, methodCall.MethodName, methodCall.Params);
```
