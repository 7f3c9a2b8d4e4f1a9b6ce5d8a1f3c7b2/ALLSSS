### Title
TokenConverter Exp Function Convergence Failure Due to Unbounded Connector Weight Ratios

### Summary
The `BancorHelper.Exp` function uses only 20 terms of Taylor series expansion, providing accurate approximation only for inputs roughly in the range |y| ≤ 10. However, connector weight ratios are not bounded, allowing governance to create pairs where `y = weight1/weight2` can reach 99 (e.g., 0.99/0.01). When combined with large trades relative to connector balances, `y * Ln(x)` can produce values like -684 or +456, causing transaction reverts and DoS of affected connector pairs.

### Finding Description [1](#0-0) 

In `GetReturnFromPaid` (Sell operation), line 53 computes `Exp(y * Ln(x))` where:
- `x = fromConnectorBalance / (fromConnectorBalance + paidAmount)` (line 51) results in 0 < x < 1
- `y = fromConnectorWeight / toConnectorWeight` (line 52) is unbounded except individual weights must satisfy 0 < w < 1
- `Ln(x)` for small x produces large negative values (e.g., Ln(0.001) ≈ -6.908)
- Large y multiplied by large negative Ln(x) produces values far outside Exp's convergence range [2](#0-1) 

Similarly in `GetAmountToPayFromReturn` (Buy operation), line 93 computes `Exp(y * Ln(x))` where:
- `x = toConnectorBalance / (toConnectorBalance - amountToReceive)` (line 91) results in x > 1
- `y = toConnectorWeight / fromConnectorWeight` (line 92)
- `Ln(x)` for x > 1 produces positive values that multiply with large y [3](#0-2) 

The `Exp` function uses only `_LOOPS = 20` iterations of Taylor series. For large magnitude inputs (|y| > 20), the 20-term approximation fails catastrophically - alternating terms grow explosively, and with overflow checking enabled, transactions revert. [4](#0-3) 

Connector weight validation only checks individual weights are between 0 and 1, but does NOT validate the ratio between paired connector weights. [5](#0-4) 

The `AddPairConnector` function allows governance to add connector pairs with arbitrary weight combinations (lines 92, 103), as long as each individual weight passes `AssertValidConnectorWeight` (lines 95, 106).

### Impact Explanation

**Operational Impact - DoS of Token Converter:**
When connector pairs with extreme weight ratios exist (e.g., 0.99/0.01 = ratio of 99), users attempting trades with amounts large relative to connector balances will trigger decimal overflow in the Exp calculation, causing transaction revert.

**Concrete scenario:**
- Connector pair: ResourceToken (weight 0.99) ↔ NativeToken (weight 0.01)
- Sell operation with fromBalance = 1,000 tokens, paidAmount = 999,000 tokens
- x = 1000/1000000 = 0.001, Ln(0.001) ≈ -6.908
- y = 0.99/0.01 = 99
- y * Ln(x) ≈ 99 × (-6.908) ≈ -684
- Exp(-684) with 20 terms causes overflow/incorrect result → transaction reverts

**Affected parties:**
- Users cannot complete trades on affected connector pairs
- Connector pairs become partially or completely unusable
- Governance would need to disable and recreate connectors with corrected weights

**Severity:** High - Complete DoS of specific connector pairs, preventing legitimate token exchange operations.

### Likelihood Explanation

**Preconditions:**
1. Governance (Parliament by default) must call `AddPairConnector` with extreme weight ratios
2. Connectors must be enabled via `EnableConnector`
3. Users must attempt trades with amounts that produce large |y * Ln(x)| values

**Attacker capabilities:**
- Does NOT require direct attacker control of governance
- Can occur through governance error or intentional misconfiguration
- Once misconfigured connectors exist, any user can trigger the DoS by attempting large trades

**Feasibility:** [6](#0-5) 

Current production deployment uses weight ratios of 1.0 (0.005/0.005), avoiding the issue. However, the contract design allows future connector additions with dangerous ratios.

**Attack complexity:** Low once misconfigured connectors exist - requires only calling public Buy/Sell methods with appropriate trade amounts.

**Detection:** Transaction failures would be immediately visible, but root cause may be non-obvious.

### Recommendation

**Add connector weight ratio validation in `AddPairConnector` and `UpdateConnector`:**

```csharp
private void AssertValidConnectorWeightRatio(decimal weight1, decimal weight2)
{
    var ratio = Math.Max(weight1 / weight2, weight2 / weight1);
    Assert(ratio <= 10m, "Connector weight ratio must not exceed 10:1 to ensure Exp convergence.");
}
```

Call this validation in:
- `AddPairConnector` after lines 95 and 106
- `UpdateConnector` when weight is modified (line 69)

**Rationale:** Limiting weight ratios to 10:1 ensures |y| ≤ 10, keeping `y * Ln(x)` within the 20-term Taylor series convergence range for realistic trade amounts.

**Additional safeguards:**
- Consider increasing `_LOOPS` from 20 to 50 for better convergence
- Add input validation in `Exp` function to reject |y| > safe_threshold
- Add comprehensive tests for extreme weight ratios and large trade amounts

### Proof of Concept

**Initial State:**
1. Deploy TokenConverter with existing connectors (current production state)
2. Governance calls `AddPairConnector`:
   - ResourceConnectorSymbol: "EXTREME"
   - ResourceWeight: "0.99"
   - NativeWeight: "0.01"
   - NativeVirtualBalance: 1000000
3. Governance calls `EnableConnector` for "EXTREME" token
4. Mint sufficient EXTREME tokens to a user address

**Exploitation Steps:**
1. User calls `Sell` with:
   - Symbol: "EXTREME"
   - Amount: 999000 (large amount relative to connector balance)

**Expected Result:** 
Transaction completes with calculated return amount based on Bancor formula

**Actual Result:**
Transaction reverts with overflow exception when `Exp(-684)` is calculated at line 53 of BancorHelper.cs, as the 20-term Taylor series cannot handle such extreme input.

**Success Condition:** 
Transaction revert proves DoS vulnerability; affected connector pair becomes unusable for large trades.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L67-94)
```csharp
    public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = amountToReceive;
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }

        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-110)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L215-260)
```csharp
        var connectors = new List<Connector>
        {
            new()
            {
                Symbol = Context.Variables.NativeSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.5",
                VirtualBalance = EconomicContractConstants.NativeTokenConnectorInitialVirtualBalance
            }
        };
        foreach (var resourceTokenSymbol in Context.Variables
                     .GetStringArray(EconomicContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(EconomicContractConstants.PayRentalSymbolListName)))
        {
            var resourceTokenConnector = new Connector
            {
                Symbol = resourceTokenSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.ResourceTokenInitialVirtualBalance,
                RelatedSymbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsDepositAccount = false
            };
            var nativeTokenConnector = new Connector
            {
                Symbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
                RelatedSymbol = resourceTokenSymbol,
                IsDepositAccount = true
            };
            connectors.Add(resourceTokenConnector);
            connectors.Add(nativeTokenConnector);
        }

        State.TokenConverterContract.Initialize.Send(new InitializeInput
        {
            FeeRate = EconomicContractConstants.TokenConverterFeeRate,
            Connectors = { connectors },
            BaseTokenSymbol = Context.Variables.NativeSymbol
        });
    }
```
