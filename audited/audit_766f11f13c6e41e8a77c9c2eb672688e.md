# Audit Report

## Title
Fee Atomicity Violation: Partial Charge Applied on Transaction Failure

## Summary
The AElf transaction fee charging mechanism violates atomicity by deducting users' available balance even when transactions fail due to insufficient fees. When a user lacks sufficient funds, the system adds their existing balance to a transaction bill and unconditionally deducts it, despite returning `Success = false` and preventing the main transaction from executing.

## Finding Description

The vulnerability exists in the fee charging flow where partial balances are charged even when fee charging fails:

**Root Cause - Partial Balance Added to Bill on Failure:**
In the `ChargeBaseFee` function, when `ChargeFirstSufficientToken` returns false (insufficient funds), the code still adds the user's existing balance to the bill if a token symbol was identified. [1](#0-0) 

**Unconditional Bill Processing:**
The `TryToChargeTransactionFee` method calls `ModifyBalance` unconditionally regardless of whether `chargingResult` is true or false. This processes whatever amounts exist in the bill. [2](#0-1) 

**Balance Deduction Execution:**
The `ModifyBalance` function iterates through all positive amounts in the bill and deducts them from the user's balance, firing `TransactionFeeCharged` events for each deduction. [3](#0-2) 

**State Commitment Despite Failure:**
The transaction execution service commits pre-transaction state changes to the state cache before checking if execution should stop. The explicit comment states "If pre-tx fails, still commit the changes, but return false to notice outside to stop the execution." [4](#0-3) 

**Execution Flow:**
1. User with 5 ELF balance attempts transaction requiring 10 ELF fee
2. `ChargeBaseFee` fails but adds 5 ELF to bill at lines 349-353
3. `ModifyBalance` deducts the 5 ELF at line 118
4. Function returns `Success = false` with "Transaction fee not enough"
5. Pre-execution plugin stops main transaction via `IsStopExecuting` [5](#0-4) 
6. **Result: User loses 5 ELF but transaction never executes**

**Test Verification:**
Existing tests confirm this behavior. A test case with insufficient balance (50 tokens when 80 required) shows that `ChargeTransactionFees` returns `Success = false` with "Transaction fee not enough", yet the user's balance becomes 0 after the call. [6](#0-5) 

## Impact Explanation

This breaks the fundamental atomicity principle of transaction fees: fees should only be charged when transactions successfully execute.

**Direct Fund Loss:**
- Users with balance B and required fee F where B < F lose min(B, F) tokens
- These tokens are permanently deducted with no service provided
- No recovery mechanism exists

**Affected Users:**
- Any user with insufficient transaction fees
- Occurs naturally when balances deplete, fees increase, or users miscalculate
- No malicious actor required - systemic protocol flaw

**Severity Justification:**
- **Critical Impact**: Direct, permanent fund loss
- **Core Mechanism**: Affects all transaction fee charging
- **Invariant Violation**: Breaks atomic fee charging guarantee
- **High Frequency**: Triggered on every insufficient-balance transaction

## Likelihood Explanation

**Directly Reachable:**
The `ChargeTransactionFees` method is automatically invoked by the ACS1 pre-execution plugin for every transaction. [7](#0-6) 

**No Special Preconditions:**
- User simply needs insufficient balance for transaction fees
- No malicious intent, special permissions, or complex setup required
- Natural occurrence in normal blockchain operation

**Automatic Trigger:**
The vulnerability activates automatically in the transaction execution flow without any explicit exploitation attempt.

**High Probability:**
Given the frequency of blockchain transactions and inevitable cases of users having insufficient balances (balance depletion, fee changes, multiple concurrent transactions), this affects users regularly in production.

## Recommendation

Modify the `TryToChargeTransactionFee` function to only call `ModifyBalance` when `chargingResult` is true:

```csharp
private ChargeTransactionFeesOutput TryToChargeTransactionFee(...)
{
    // ... existing charging logic ...
    
    // Only apply charges if successful
    if (chargingResult)
    {
        ModifyBalance(fromAddress, bill, allowanceBill);
    }
    
    var chargingOutput = new ChargeTransactionFeesOutput { Success = chargingResult };
    if (!chargingResult)
        chargingOutput.ChargingInformation = "Transaction fee not enough.";
    
    return chargingOutput;
}
```

Additionally, remove the logic that adds partial balances to the bill when charging fails (lines 349-353 in `ChargeBaseFee`), as these amounts should not be collected when the transaction cannot proceed.

## Proof of Concept

The existing test at lines 572-739 in `ExecutePluginTransactionDirectlyTest.cs` demonstrates this vulnerability:

```csharp
// Test setup: User has 50 tokens, fee requires 80 tokens
[InlineData(1000, 1000, 1000, 1000, 1000, 1000, 1000, 50, 50, 100, 100, 50, 50, 10, 10, 80, 80, 50, 30, 920)]
public async Task ChargeTransactionFee_Delegate(...)

// Result verification:
var chargeFeeRetUser = await TokenContractStub3.ChargeTransactionFees.SendAsync(chargeTransactionFeesInput);
chargeFeeRetUser.Output.Success.ShouldBe(false); // Charging failed
chargeFeeRetUser.Output.ChargingInformation.ShouldBe("Transaction fee not enough.");

var afterBalance = await TokenContractStub.GetBalance.CallAsync(...);
afterBalance.Balance.ShouldBe(0); // But balance was still deducted!
```

This test confirms users lose their available balance even when fee charging fails and transactions don't execute.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-52)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }

        // Record tx fee bill during current charging process.
        var bill = new TransactionFeeBill();
        var allowanceBill = new TransactionFreeFeeAllowanceBill();
        var fromAddress = Context.Sender;
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L118-118)
```csharp
        ModifyBalance(fromAddress, bill, allowanceBill);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L245-255)
```csharp
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            ModifyBalance(fromAddress, symbol, -amount);
            Context.Fire(new TransactionFeeCharged
            {
                Symbol = symbol,
                Amount = amount,
                ChargingAddress = fromAddress
            });
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L343-356)
```csharp
        if (!ChargeFirstSufficientToken(methodFeeMap, fromAddress, out var symbolToChargeBaseFee,
                out var amountToChargeBaseFee, out var existingBalance, out var existingAllowance,
                transactionFeeFreeAllowancesMap,
                delegations))
        {
            Context.LogDebug(() => "Failed to charge first sufficient token.");
            if (symbolToChargeBaseFee != null)
            {
                bill.FeesMap.Add(symbolToChargeBaseFee, existingBalance);
                allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, existingAllowance);
            } // If symbol == 

            return false;
        }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L283-293)
```csharp
                var stateSets = preTrace.GetStateSets().ToList();
                internalStateCache.Update(stateSets);
                var parentStateCache = txContext.StateCache as TieredStateCache;
                parentStateCache?.Update(stateSets);

                if (!plugin.IsStopExecuting(preTrace.ReturnValue, out var error)) continue;

                // If pre-tx fails, still commit the changes, but return false to notice outside to stop the execution.
                preTrace.Error = error;
                preTrace.ExecutionStatus = ExecutionStatus.Executed;
                return false;
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L123-129)
```csharp
    public bool IsStopExecuting(ByteString txReturnValue, out string preExecutionInformation)
    {
        var chargeTransactionFeesOutput = new ChargeTransactionFeesOutput();
        chargeTransactionFeesOutput.MergeFrom(txReturnValue);
        preExecutionInformation = chargeTransactionFeesOutput.ChargingInformation;
        return !chargeTransactionFeesOutput.Success;
    }
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutePluginTransactionDirectlyTest.cs (L730-739)
```csharp
            var chargeFeeRetUser = await TokenContractStub3.ChargeTransactionFees.SendAsync(chargeTransactionFeesInput);
            chargeFeeRetUser.Output.Success.ShouldBe(false);
            chargeFeeRetUser.Output.ChargingInformation.ShouldBe("Transaction fee not enough.");

            var afterBalance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Symbol = basicFeeSymbol,
                Owner = userAddress
            });
            afterBalance.Balance.ShouldBe(0);
```
