### Title
Association Governance Bypass via Post-Vote Membership Manipulation

### Summary
The Association contract's `IsReleaseThresholdReached()` function contains a critical inconsistency in vote counting logic. While abstention and rejection checks filter votes by current organization membership, the total vote threshold check counts ALL historical votes regardless of membership status. This allows organizations to bypass `MaximalAbstentionThreshold` and `MaximalRejectionThreshold` constraints by removing members after they vote, enabling proposals that should be blocked to be released.

### Finding Description

The vulnerability exists in the `CheckEnoughVoteAndApprovals` helper function within the Association contract's threshold validation logic. [1](#0-0) 

**Root Cause:**

The code exhibits inconsistent membership filtering across vote counting operations:

1. **Rejection count** (correctly filtered): [2](#0-1) 

2. **Abstention count** (correctly filtered): [3](#0-2) 

3. **Approval count** (correctly filtered): [4](#0-3) 

4. **Total vote count** (INCORRECTLY unfiltered): [5](#0-4) 

The total vote count uses `.Count()` on concatenated lists without applying `.Contains()` membership filtering, unlike all other vote counting operations.

**Why Existing Protections Fail:**

The `Validate()` function only checks threshold consistency at organization creation/modification time and does not prevent retroactive manipulation: [6](#0-5) 

Member removal operations (`RemoveMember`) do not invalidate or adjust existing proposals: [7](#0-6) 

The validation occurs at `Release()` time, checking against the current (modified) membership list: [8](#0-7) 

### Impact Explanation

**Direct Harm:**
- Organizations can execute proposals that were legitimately blocked by exceeding `MaximalAbstentionThreshold` or `MaximalRejectionThreshold`
- Governance rules designed to require broad consensus are completely bypassed
- Minority factions can force through contentious proposals by strategically removing dissenting/abstaining members

**Affected Parties:**
- All Association-based organizations relying on abstention/rejection thresholds for governance protection
- Organization members who voted to block proposals through abstention or rejection
- Downstream contracts/systems governed by compromised Association organizations

**Severity Justification:**
This is a **HIGH severity** governance bypass vulnerability because:
1. It directly violates critical governance invariants (MaximalAbstentionThreshold and MaximalRejectionThreshold)
2. It enables unauthorized proposal execution that should have been blocked
3. It undermines the fundamental trust model of multi-signature governance
4. The attack requires only normal governance operations (no external compromise needed)

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must control enough organization members to pass a separate `RemoveMember` proposal
- Requires coordination to execute removal proposal between voting and release of target proposal
- Uses only standard contract methods available to any organization

**Attack Complexity:**
- **LOW**: Requires only two standard governance proposals (target proposal + member removal proposal)
- No special permissions beyond normal member voting rights needed
- No timing constraints beyond proposal expiration periods

**Feasibility Conditions:**
- Organization must have `MaximalAbstentionThreshold` or `MaximalRejectionThreshold` configured (common for security-conscious organizations)
- Target proposal must be blocked by exceeding these thresholds
- Attacker faction must have sufficient votes to pass a member removal proposal (easier if original proposal had narrow margins)

**Detection/Operational Constraints:**
- Member removal is a legitimate operation, making suspicious activity hard to detect
- No on-chain alerts or restrictions prevent this attack pattern
- The inconsistency is in internal logic, invisible to external observers

**Probability:** **MEDIUM-to-HIGH** - Organizations commonly use abstention/rejection thresholds for important decisions, and the attack requires only coordination among existing members with no external resources.

### Recommendation

**Code-Level Mitigation:**

Modify the total vote count in `CheckEnoughVoteAndApprovals` to filter by current membership consistently with other vote counts:

```csharp
// BEFORE (line 55-57):
var isVoteThresholdReached =
    proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
    organization.ProposalReleaseThreshold.MinimalVoteThreshold;

// AFTER (apply membership filtering):
var totalVoteCount = 
    proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
    proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
    proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
var isVoteThresholdReached = totalVoteCount >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**Invariant Checks:**
- Add assertion: `totalVoteCount <= organization.OrganizationMemberList.Count()` (each member votes at most once)
- Consider adding proposal versioning tied to membership changes to explicitly invalidate proposals when membership changes significantly

**Test Cases to Add:**
1. Test releasing a proposal after removing abstaining members - should still be blocked if original abstention count exceeded threshold
2. Test releasing a proposal after removing rejecting members - should still be blocked if original rejection count exceeded threshold
3. Test that total vote count decreases when members are removed
4. Test edge case where all voters are removed - proposal should fail all thresholds

### Proof of Concept

**Required Initial State:**
- Association organization with 10 members: [M1, M2, M3, M4, M5, M6, M7, M8, M9, M10]
- Thresholds configured:
  - `MinimalApprovalThreshold = 5`
  - `MinimalVoteThreshold = 8`
  - `MaximalAbstentionThreshold = 2`
  - `MaximalRejectionThreshold = 2`

**Transaction Steps:**

1. **Create Proposal A** (target proposal to be manipulated):
   - Proposer: M1
   - Action: Transfer organization funds to M1's address

2. **Vote on Proposal A:**
   - M1, M2, M3, M4, M5: Call `Approve(ProposalA)`
   - M6, M7, M8, M9: Call `Abstain(ProposalA)`
   - M10: Call `Reject(ProposalA)`
   - Total: 5 approvals, 4 abstentions, 1 rejection = 10 votes

3. **Attempt Release (fails as expected):**
   - M1 calls `Release(ProposalA)`
   - **Expected:** Transaction fails with "Not approved" error
   - **Reason:** `abstentionMemberCount = 4 > MaximalAbstentionThreshold (2)`

4. **Create Proposal B** (member removal proposal):
   - Proposer: M1
   - Action: Call `RemoveMember(M6)`, `RemoveMember(M7)`, `RemoveMember(M8)`, `RemoveMember(M9)`

5. **Vote on and Release Proposal B:**
   - M1, M2, M3, M4, M5 call `Approve(ProposalB)`
   - M1 calls `Release(ProposalB)`
   - **Result:** M6, M7, M8, M9 removed from organization
   - Organization now has 6 members: [M1, M2, M3, M4, M5, M10]

6. **Attempt Release of Proposal A (now succeeds - VULNERABILITY):**
   - M1 calls `Release(ProposalA)`
   - **Vote Count Calculation:**
     - `rejectionMemberCount = 1` (M10 still member) ≤ 2 ✓
     - `abstentionMemberCount = 0` (M6-M9 no longer members, filtered out) ≤ 2 ✓
     - `approvedMemberCount = 5` (M1-M5 still members) ≥ 5 ✓
     - `totalVoteCount = 10` (ALL historical votes, including removed members) ≥ 8 ✓
   - **Actual Result:** Transaction succeeds, Proposal A released, funds transferred
   - **Expected Result:** Should fail because original abstention count (4) exceeded threshold (2)

**Clear Success Condition:**
The vulnerability is confirmed when Proposal A, which was legitimately blocked by 4 abstentions exceeding `MaximalAbstentionThreshold = 2`, becomes releasable after removing the abstaining members, despite the governance rules intended to prevent such proposals from passing.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-38)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-44)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
