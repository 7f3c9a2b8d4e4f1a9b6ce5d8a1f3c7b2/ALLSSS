### Title
Retroactive Vote Manipulation Through Member List Changes in Association Contract

### Summary
The Association contract's vote counting mechanism filters votes by current membership at release time rather than membership at voting time, allowing organizations to retroactively manipulate proposal outcomes by removing members who voted against proposals. This breaks the fundamental integrity of the governance system, enabling blocked proposals to pass by strategically removing dissenting voters.

### Finding Description

The vulnerability exists in the threshold checking logic within `IsProposalAbstained()`, `IsProposalRejected()`, and `CheckEnoughVoteAndApprovals()` functions. [1](#0-0) 

At line 43, abstention votes are filtered by current membership: [2](#0-1) 

The same pattern applies to rejections (line 36) and approvals (line 49): [3](#0-2) [4](#0-3) 

When members vote, their addresses are permanently recorded in the proposal's vote lists: [5](#0-4) 

However, the organization can modify its member list through `RemoveMember()`, `AddMember()`, and `ChangeMember()` functions: [6](#0-5) 

These functions only require the organization itself to call them (via proposal execution), and validate that the organization remains mathematically valid after changes: [7](#0-6) 

Critically, there is **no check** that prevents member changes while proposals are active, nor any mechanism to snapshot membership at voting time. When `IsReleaseThresholdReached()` is called during proposal release, it recalculates vote counts using the current (modified) member list: [8](#0-7) 

### Impact Explanation

**Governance Integrity Compromise**: The voting system's fundamental invariant—that votes cast at time T should count regardless of future organizational changes—is violated. This enables the following attacks:

1. **Abstention Threshold Bypass**: A proposal with 5 abstentions (exceeding MaximalAbstentionThreshold of 2) can be unblocked by removing 3 abstaining members, reducing the counted abstentions to 2.

2. **Rejection Threshold Bypass**: A proposal with 5 rejections (exceeding MaximalRejectionThreshold of 4) can be forced through by removing 1 rejecting member.

3. **Approval Dilution**: Conversely, removing approving members could prevent legitimate proposals from passing, though this is less incentivized.

**Quantified Harm**: 
- Any organization-controlled asset or permission can be compromised
- Multi-signature security guarantees are undermined
- Treasury funds, token permissions, or contract upgrades controlled by Association organizations become vulnerable
- The severity depends on the Association's authority—if it controls high-value assets or critical system permissions, the impact is critical

**Affected Parties**: All Association-based organizations and stakeholders who rely on multi-sig governance guarantees.

### Likelihood Explanation

**Attacker Capabilities**: The attacker must control sufficient members to:
1. Pass proposals to remove dissenting voters (requires MinimalApprovalThreshold votes)
2. Have these removal proposals not be blocked by remaining members

**Attack Complexity**: Medium. The attack requires:
- Coordination among enough members to pass removal proposals
- Multiple sequential proposals (one per member to remove)
- Time to execute these proposals before the original proposal expires

**Feasibility Conditions**: This is highly practical because:
1. Member removal proposals are distinct from the controversial original proposal—different members may support "cleaning up membership" vs supporting a contentious action
2. The attack exploits legitimate functionality (member management) for malicious purposes
3. No on-chain mechanism prevents or detects this pattern

**Detection Constraints**: The attack is difficult to detect because:
- Member management is a legitimate operation
- The connection between member removal and vote manipulation may not be obvious without analyzing proposal histories
- Each step (removal proposal, release, original proposal release) appears valid in isolation

**Economic Rationality**: If the Association controls valuable assets (treasury funds, contract upgrade authority, etc.) exceeding the cost of coordination among colluding members, the attack is economically rational.

### Recommendation

**Code-Level Mitigation**: Implement membership snapshots at voting time and use these snapshots for vote counting:

1. Add a `membershipSnapshot` field to `ProposalInfo` that captures the organization's member list when votes are cast
2. Modify vote counting to use the snapshot instead of current membership:
   ```csharp
   var abstentionMemberCount = proposal.Abstentions.Count(proposal.MembershipSnapshot.Contains);
   ```

3. Alternatively, store vote weights at voting time rather than just addresses, making them immutable.

**Invariant Checks**: Add validation that prevents member removal/addition while proposals referencing that organization are active:
- In `RemoveMember()`, `AddMember()`, and `ChangeMember()`, check if any non-expired proposals exist for this organization
- If active proposals exist, either reject the member change or invalidate affected proposals

**Test Cases**:
1. Create proposal, collect votes, remove abstaining member, verify original vote count is preserved
2. Create proposal exceeding abstention threshold, remove abstainers, attempt release, verify it fails
3. Test that member changes after proposal expiration do not affect historical records

### Proof of Concept

**Initial State**:
- Organization created with 10 members: M1, M2, M3, M4, M5, M6, M7, M8, M9, M10
- Thresholds set: MinimalApprovalThreshold=5, MaximalAbstentionThreshold=2, MinimalVoteThreshold=5

**Transaction Sequence**:

1. **Create Proposal A** (controversial action, e.g., "Transfer 1000 ELF from Treasury"):
   - M1-M5 approve
   - M6-M10 abstain
   - Result: abstentionMemberCount = 5 > MaximalAbstentionThreshold (2)
   - Expected: Proposal A is BLOCKED and cannot be released

2. **Create Proposal B** ("Remove member M6"):
   - M1-M5 and M7 approve (6 votes)
   - Release Proposal B → M6 is removed from organization

3. **Create Proposal C** ("Remove member M7"):
   - M1-M5 and M8 approve (6 votes)
   - Release Proposal C → M7 is removed from organization

4. **Create Proposal D** ("Remove member M8"):
   - M1-M5 and M9 approve (6 votes)
   - Release Proposal D → M8 is removed from organization

5. **Attempt to Release Proposal A**:
   - Organization now has 7 members: M1-M5, M9, M10
   - proposal.Abstentions still contains [M6, M7, M8, M9, M10]
   - But abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) = 2 (only M9, M10)
   - abstentionMemberCount (2) ≤ MaximalAbstentionThreshold (2) ✓
   - approvedMemberCount = 5 (M1-M5) ≥ MinimalApprovalThreshold (5) ✓
   - totalVotes = 7 ≥ MinimalVoteThreshold (5) ✓
   - **Actual Result**: Proposal A can now be RELEASED despite being legitimately blocked by abstentions
   - **Expected Result**: Proposal A should remain BLOCKED as 5 members abstained

**Success Condition**: The attacker successfully releases a proposal that had insufficient support by retroactively manipulating the vote count through member removal, demonstrating complete governance bypass.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L163-180)
```csharp
    public override Empty Abstain(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Abstentions.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Abstain),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-280)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }

    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
    }

    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
