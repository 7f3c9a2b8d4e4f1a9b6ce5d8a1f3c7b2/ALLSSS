### Title
Insufficient Validation of Next Round Miner List Allows Consensus Manipulation

### Summary
The `ValidationForNextRound` method in `RoundTerminateValidationProvider` only validates that the round number increments by one and that all `InValue` fields are null, but fails to validate the integrity of `RealTimeMinersInformation`. This allows a malicious miner to produce a NextRound block with arbitrary miner list (e.g., duplicate themselves, exclude legitimate miners) which will pass validation and be stored in consensus state, enabling them to monopolize block production and rewards in the next round.

### Finding Description

The vulnerability exists in the `ValidationForNextRound` method which performs only two checks: [1](#0-0) 

**Root Cause**: The validation only checks:
1. Round number is exactly `BaseRound.RoundNumber + 1`
2. All miners have `InValue == null`

**Missing Validations**:
- No check that the miner list in `extraData.Round.RealTimeMinersInformation` matches the current round's miner list
- No check that each miner appears exactly once
- No check that the total number of miners is correct
- No validation of miner identities or their properties beyond `InValue`

The companion validator `NextRoundMiningOrderValidationProvider` also fails to prevent this attack: [2](#0-1) 

This validator checks that miners with `FinalOrderOfNextRound > 0` equals miners with `OutValue != null` in the provided round. However, in a legitimately generated next round, both counts should be 0 (no mining has occurred yet), so this check becomes `0 == 0` and passes regardless of which miners are included.

**Execution Path**:

1. Validation occurs in `ValidateBeforeExecution` which is called before block execution: [3](#0-2) 

2. If validation passes, the `NextRound` method executes: [4](#0-3) 

3. The `ProcessNextRound` method stores the malicious round directly: [5](#0-4) 

4. The round is stored without any validation of miner list integrity: [6](#0-5) 

The legitimate next round generation properly maintains the miner list from the current round: [7](#0-6) 

However, an attacker can bypass this legitimate generation by directly calling the public `NextRound` method with malicious input.

### Impact Explanation

**Consensus Integrity Breach**: An attacker who is a current miner can manipulate the consensus protocol by:
- Adding multiple instances of themselves to the next round (e.g., 5 copies of attacker's pubkey with different orders)
- Removing legitimate miners from the next round
- Arbitrarily rearranging time slots and mining orders

**Block Reward Theft**: If an attacker adds 5 instances of themselves and removes all other miners:
- They can mine all blocks in round N+1
- They receive 100% of block rewards for that round instead of their fair share (e.g., 20% in a 5-miner setup)
- Other legitimate miners receive no rewards despite being entitled to them

**Network Disruption**: 
- Legitimate miners cannot produce blocks in the manipulated round
- Chain progression depends entirely on the attacker
- The attacker can create an extended DoS by repeatedly manipulating subsequent rounds

**Severity Justification**: Critical impact on consensus mechanism integrity, direct theft of block rewards from honest miners, and potential for sustained network disruption. This violates the critical invariant "Correct round transitions and miner schedule integrity."

### Likelihood Explanation

**Attacker Capabilities**: 
- Must be a current miner (in the active miner set)
- Must be able to produce blocks during their time slot
- Standard miner privileges only - no special authorization required

**Attack Complexity**: Low
- Single transaction call to public `NextRound` method
- Simple construction of malicious `NextRoundInput` with modified `RealTimeMinersInformation`
- No complex state manipulation or timing requirements beyond normal block production

**Feasibility Conditions**:
- Attacker must wait for their extra block production opportunity (when they should trigger NextRound)
- Requires producing one block with malicious consensus extra data
- All current miners have this opportunity periodically

**Detection Constraints**:
- Post-execution validation only checks hash equality between header and stored state, which will match for malicious data [8](#0-7) 

- The malicious round will appear valid in state with correct round number
- Other miners will notice they cannot mine, but the attacker has already captured the round

**Economic Rationality**: Highly profitable - cost is minimal (one block production), gain is all block rewards for an entire round (potentially hundreds or thousands of blocks depending on round length).

**Probability**: High - any current miner can execute this attack during their extra block production slot.

### Recommendation

**Add Miner List Integrity Validation** in `RoundTerminateValidationProvider.ValidationForNextRound`:

1. Validate that the miner count in `extraData.Round.RealTimeMinersInformation` equals the count in `BaseRound.RealTimeMinersInformation`
2. Validate that each miner pubkey from `BaseRound` exists exactly once in `extraData.Round`
3. Validate that no duplicate pubkeys exist in `extraData.Round.RealTimeMinersInformation`
4. Optionally validate that miner orders are within valid range [1, minerCount] and each order appears exactly once

**Example validation logic to add after line 30**:
```csharp
// Validate miner list integrity
var baseMiners = validationContext.BaseRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
var nextMiners = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();

if (baseMiners.Count != nextMiners.Count)
    return new ValidationResult { Message = "Miner count mismatch between current and next round." };

if (!baseMiners.SequenceEqual(nextMiners))
    return new ValidationResult { Message = "Miner list must remain consistent across rounds." };

// Validate no duplicate orders
var orders = extraData.Round.RealTimeMinersInformation.Values.Select(m => m.Order).ToList();
if (orders.Distinct().Count() != orders.Count)
    return new ValidationResult { Message = "Duplicate mining orders detected in next round." };

// Validate order range
if (orders.Any(o => o < 1 || o > nextMiners.Count))
    return new ValidationResult { Message = "Invalid mining order in next round." };
```

**Test Cases**:
1. Test that NextRound with duplicate miner pubkeys is rejected
2. Test that NextRound with removed miners is rejected  
3. Test that NextRound with additional miners is rejected
4. Test that NextRound with correct miner list but wrong order count is rejected
5. Test that legitimate NextRound with correct miner list passes validation

### Proof of Concept

**Initial State**:
- Current round N has 5 miners: [Alice, Bob, Carol, Dave, Eve]
- Alice is a malicious miner
- Current round number: 100
- All miners have mined their blocks in round 100

**Attack Steps**:

1. Alice waits for her extra block production opportunity (to trigger NextRound)

2. Alice constructs malicious `NextRoundInput`:
   - `RoundNumber = 101`
   - `TermNumber = current term`
   - `RealTimeMinersInformation = {`
     - `"Alice_pubkey": { Order: 1, InValue: null, OutValue: null, FinalOrderOfNextRound: 0, ... }`
     - `"Alice_pubkey": { Order: 2, InValue: null, OutValue: null, FinalOrderOfNextRound: 0, ... }`
     - `"Alice_pubkey": { Order: 3, InValue: null, OutValue: null, FinalOrderOfNextRound: 0, ... }`
     - `"Alice_pubkey": { Order: 4, InValue: null, OutValue: null, FinalOrderOfNextRound: 0, ... }`
     - `"Alice_pubkey": { Order: 5, InValue: null, OutValue: null, FinalOrderOfNextRound: 0, ... }`
   - `}`
   - (Note: In practice, the keys in the map must be unique, so attacker would use modified keys like "Alice_1", "Alice_2", etc., or exploit implementation-specific behavior)

3. Alice produces a block with this consensus extra data and calls `NextRound` transaction

4. **Expected Result**: Validation should reject due to invalid miner list
   **Actual Result**: 
   - Validation passes (round number check: 100+1==101 ✓, InValue check: all null ✓)
   - Round 101 is stored with Alice having all 5 mining slots
   - Bob, Carol, Dave, and Eve cannot mine any blocks in round 101
   - Alice mines all blocks and receives 100% of round 101 rewards

**Success Condition**: 
- Query `State.Rounds[101].RealTimeMinersInformation.Keys` returns only Alice's pubkey(s)
- Query `State.CurrentRoundNumber` returns 101
- Other miners' attempts to mine in round 101 fail due to not being in the miner list

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-91)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```
