### Title
VOTE/SHARE Token Transfer Restriction Bypass Enabling Vote Market Creation

### Summary
VOTE and SHARE tokens lack transfer restrictions, allowing users to freely trade these tokens on external markets after receiving them through the voting process. This enables vote buying/selling that undermines election integrity and can permanently lock voters' native tokens when they cannot return the required VOTE/SHARE tokens during withdrawal.

### Finding Description

The VOTE and SHARE token symbols are defined as constants [1](#0-0)  but these tokens are created without any transfer restrictions or hooks.

When VOTE and SHARE tokens are created during economic system initialization [2](#0-1) , they only include a `LockWhiteList` containing the Election and Vote contracts. No `ExternalInfo` field is set, meaning no transfer callbacks are configured [3](#0-2) .

The token transfer implementation only checks if the sender is in the transfer blacklist and that sender != receiver [4](#0-3) . There are no symbol-specific restrictions for VOTE or SHARE tokens.

When users vote, they receive VOTE and SHARE tokens via standard transfer [5](#0-4) . These tokens sit in their balance as freely transferable assets.

During withdrawal, the Election Contract attempts to retrieve tokens using `TransferFrom` [6](#0-5) . While the Election Contract is whitelisted to bypass allowance checks [7](#0-6) , this only works if the voter still possesses the tokens. The whitelist check [8](#0-7)  does not prevent users from transferring their VOTE/SHARE tokens to other addresses before withdrawal.

### Impact Explanation

**Vote Market Creation**: Users who receive VOTE/SHARE tokens can sell them to other addresses via the standard Transfer method [9](#0-8) , creating a secondary market for voting power. Buyers accumulate voting power without locking native tokens, while sellers profit while keeping their ELF locked.

**Permanent Token Lockup**: When voters who sold their VOTE/SHARE tokens attempt withdrawal, the `RetrieveTokensFromVoter` call will fail due to insufficient balance, permanently locking their native ELF tokens. The withdrawal process requires the exact amount of VOTE/SHARE tokens to be returned [10](#0-9) .

**Election Integrity Compromise**: The election system assumes voting power is tied to locked native tokens. Free transferability of VOTE tokens breaks this assumption, allowing concentration of voting power without corresponding token locks.

**Quantified Impact**: With 1 billion VOTE tokens issued [11](#0-10) , the entire voting power distribution can be manipulated through market trading.

### Likelihood Explanation

**Attack Complexity**: Trivial - requires only calling the standard `Transfer` method available to all token holders.

**Attacker Capabilities**: Any user who has voted and received VOTE/SHARE tokens can execute this. No special permissions required.

**Preconditions**: User must have voted to receive VOTE/SHARE tokens through the normal voting flow [12](#0-11) .

**Economic Rationality**: Highly profitable - sellers receive payment while keeping locked ELF (which unlocks after lock period), buyers gain voting power without locking tokens.

**Detection**: Difficult to prevent as transfers appear as legitimate token operations.

### Recommendation

**Immediate Fix**: Add VOTE and SHARE token symbols to the transfer blacklist during initialization, or implement transfer callback in ExternalInfo that restricts transfers to only the Election Contract address.

**Option 1 - Transfer Blacklist**: After token creation, add both addresses that hold VOTE/SHARE tokens to the transfer blacklist [13](#0-12) , preventing user-to-user transfers while allowing Election Contract operations.

**Option 2 - Transfer Callback**: Set ExternalInfo with `aelf_transfer_callback` key pointing to a validation contract that only permits transfers where `To` address is the Election Contract, blocking all user-to-user transfers.

**Invariant to Enforce**: VOTE/SHARE token transfers must only occur between users and the Election Contract, never between arbitrary user addresses.

**Test Cases**: Add tests verifying that direct Transfer calls between user addresses fail for VOTE/SHARE tokens, while Election Contract transfers succeed.

### Proof of Concept

**Initial State**:
- User A votes 1000 ELF for a candidate, receives 1000 VOTE and 1000 SHARE tokens
- User A's 1000 ELF is locked with the vote ID

**Attack Sequence**:
1. User A calls `TokenContract.Transfer(to: UserB, symbol: "VOTE", amount: 1000)`
2. Transfer succeeds (no restrictions in place)
3. User A calls `TokenContract.Transfer(to: UserB, symbol: "SHARE", amount: 1000)`  
4. Transfer succeeds
5. User B now has voting power without locking any native tokens
6. User A waits for lock period to expire
7. User A calls `ElectionContract.Withdraw(voteId)` 
8. Transaction fails at `RetrieveTokensFromVoter` due to insufficient VOTE/SHARE balance
9. User A's 1000 ELF remains permanently locked

**Expected Result**: Transfer calls in steps 1 and 3 should fail with "Transfer not permitted for VOTE/SHARE tokens"

**Actual Result**: Transfers succeed, enabling vote market and permanent token lockup

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L7-9)
```csharp
    public const string VoteSymbol = "VOTE";

    public const string ShareSymbol = "SHARE";
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L106-136)
```csharp
    private void CreateElectionTokens()
    {
        var lockWhiteListBackups = new List<Address>
        {
            Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName),
            Context.GetContractAddressByName(SmartContractConstants.VoteContractSystemName)
        };
        var lockWhiteList = lockWhiteListBackups.Where(address => address != null).ToList();
        foreach (var symbol in new List<string>
                     { EconomicContractConstants.ElectionTokenSymbol, EconomicContractConstants.ShareTokenSymbol })
        {
            State.TokenContract.Create.Send(new CreateInput
            {
                Symbol = symbol,
                TokenName = $"{symbol} Token",
                TotalSupply = EconomicContractConstants.ElectionTokenTotalSupply,
                Decimals = EconomicContractConstants.ElectionTokenDecimals,
                Issuer = Context.Self,
                IsBurnable = true,
                LockWhiteList = { lockWhiteList },
                Owner = Context.Self
            });
            State.TokenContract.Issue.Send(new IssueInput
            {
                Symbol = symbol,
                Amount = EconomicContractConstants.ElectionTokenTotalSupply,
                To = Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName),
                Memo = "Issue all election tokens to Election Contract."
            });
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-15)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
    public const string LockCallbackExternalInfoKey = "aelf_lock_callback";
    public const string UnlockCallbackExternalInfoKey = "aelf_unlock_callback";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L99-114)
```csharp
    private void DoTransfer(Address from, Address to, string symbol, long amount, string memo = null)
    {
        Assert(!IsInTransferBlackListInternal(from), "From address is in transfer blacklist.");
        Assert(from != to, "Can't do transfer to sender itself.");
        AssertValidMemo(memo);
        ModifyBalance(from, symbol, -amount);
        ModifyBalance(to, symbol, amount);
        Context.Fire(new Transferred
        {
            From = from,
            To = to,
            Symbol = symbol,
            Amount = amount,
            Memo = memo ?? string.Empty
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L282-294)
```csharp
    private void RetrieveTokensFromVoter(long amount, Address voterAddress = null)
    {
        foreach (var symbol in new List<string>
                     { ElectionContractConstants.ShareSymbol, ElectionContractConstants.VoteSymbol })
            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = voterAddress ?? Context.Sender,
                To = Context.Self,
                Amount = amount,
                Symbol = symbol,
                Memo = $"Return {symbol} tokens."
            });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L344-355)
```csharp
    private void TransferTokensToVoter(long amount)
    {
        foreach (var symbol in new List<string>
                     { ElectionContractConstants.ShareSymbol, ElectionContractConstants.VoteSymbol })
            State.TokenContract.Transfer.Send(new TransferInput
            {
                Symbol = symbol,
                To = Context.Sender,
                Amount = amount,
                Memo = $"Transfer {symbol}."
            });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L421-467)
```csharp
    public override Hash Vote(VoteMinerInput input)
    {
        // Check candidate information map instead of candidates. 
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);

        var electorPubkey = Context.RecoverPublicKey();

        var lockSeconds = (input.EndTimestamp - Context.CurrentBlockTime).Seconds;
        AssertValidLockSeconds(lockSeconds);

        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;

        UpdateElectorInformation(electorPubkey, input.Amount, voteId);

        var candidateVotesAmount = UpdateCandidateInformation(input.CandidatePubkey, input.Amount, voteId);

        LockTokensOfVoter(input.Amount, voteId);
        TransferTokensToVoter(input.Amount);
        CallVoteContractVote(input.Amount, input.CandidatePubkey, voteId);
        AddBeneficiaryToVoter(GetVotesWeight(input.Amount, lockSeconds), lockSeconds, voteId);

        var rankingList = State.DataCentersRankingList.Value;
        if (rankingList.DataCenters.ContainsKey(input.CandidatePubkey))
        {
            rankingList.DataCenters[input.CandidatePubkey] =
                rankingList.DataCenters[input.CandidatePubkey].Add(input.Amount);
            State.DataCentersRankingList.Value = rankingList;
        }
        else
        {
            if (rankingList.DataCenters.Count < GetValidationDataCenterCount())
            {
                State.DataCentersRankingList.Value.DataCenters.Add(input.CandidatePubkey,
                    candidateVotesAmount);
                AddBeneficiary(input.CandidatePubkey);
            }
            else
            {
                TryToBecomeAValidationDataCenter(input, candidateVotesAmount, rankingList);
            }
        }

        return voteId;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L629-679)
```csharp
    public override Empty Withdraw(Hash input)
    {
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input);

        var actualLockedTime = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockDays = State.LockTimeMap[input];
        Assert(actualLockedTime >= claimedLockDays,
            $"Still need {claimedLockDays.Sub(actualLockedTime).Div(86400)} days to unlock your token.");

        var voterPublicKey = Context.RecoverPublicKey();

        var voterVotes = GetElectorVote(voterPublicKey);

        Assert(voterVotes != null, $"Voter {Context.Sender.ToBase58()} never votes before");

        voterVotes.ActiveVotingRecordIds.Remove(input);
        voterVotes.WithdrawnVotingRecordIds.Add(input);
        voterVotes.ActiveVotedVotesAmount = voterVotes.ActiveVotedVotesAmount.Sub(votingRecord.Amount);

        State.ElectorVotes[Context.Sender.ToBase58()] = voterVotes;

        // Update Candidate's Votes information.
        var newestPubkey = GetNewestPubkey(votingRecord.Option);
        var candidateVotes = State.CandidateVotes[newestPubkey];

        Assert(candidateVotes != null, $"Newest pubkey {newestPubkey} is invalid. Old pubkey is {votingRecord.Option}");

        candidateVotes.ObtainedActiveVotingRecordIds.Remove(input);
        candidateVotes.ObtainedWithdrawnVotingRecordIds.Add(input);
        candidateVotes.ObtainedActiveVotedVotesAmount =
            candidateVotes.ObtainedActiveVotedVotesAmount.Sub(votingRecord.Amount);
        State.CandidateVotes[newestPubkey] = candidateVotes;

        UnlockTokensOfVoter(input, votingRecord.Amount);
        RetrieveTokensFromVoter(votingRecord.Amount);
        WithdrawTokensOfVoter(input);
        if (!State.WeightsAlreadyFixedMap[input])
        {
            RemoveBeneficiaryOfVoter();
            State.WeightsAlreadyFixedMap.Remove(input);
        }

        var rankingList = State.DataCentersRankingList.Value;
        if (!rankingList.DataCenters.ContainsKey(newestPubkey)) return new Empty();
        rankingList.DataCenters[newestPubkey] =
            rankingList.DataCenters[newestPubkey].Sub(votingRecord.Amount);
        UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, newestPubkey);
        State.DataCentersRankingList.Value = rankingList;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L96-99)
```csharp
    public override BoolValue IsInWhiteList(IsInWhiteListInput input)
    {
        return new BoolValue { Value = State.LockWhiteLists[input.Symbol][input.Address] };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L854-860)
```csharp
    public override Empty AddToTransferBlackList(Address input)
    {
        AssertControllerForTransferBlackList();
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid address.");
        State.TransferBlackList[input] = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L23-26)
```csharp
    public const string ElectionTokenSymbol = "VOTE";
    public const string ShareTokenSymbol = "SHARE";
    public const long ElectionTokenTotalSupply = 1_000_000_000_00000000;
    public const int ElectionTokenDecimals = 8;
```
