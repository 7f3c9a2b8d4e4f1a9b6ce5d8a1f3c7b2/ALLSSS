### Title
Integer Overflow in RoundId Calculation Enables Consensus Denial of Service

### Summary
The `RoundId` property calculates the sum of all miners' `ExpectedMiningTime.Seconds` values without validating that individual values are reasonable. Malicious miners can submit `NextRoundInput` with `ExpectedMiningTime.Seconds` values near `long.MaxValue`, causing an `OverflowException` during round validation and blocking consensus progression.

### Finding Description

The vulnerability exists in the `RoundId` property getter: [1](#0-0) 

When a new round is proposed via `NextRound` transaction, the provided round information includes `MinerInRound` objects with `expected_mining_time` fields that miners can set to arbitrary values: [2](#0-1) 

During validation, `TimeSlotValidationProvider` accesses the `RoundId` property to determine if the provided round is new: [3](#0-2) 

The time slot validation only checks that intervals between consecutive miners are consistent and positive, but does NOT validate that `ExpectedMiningTime` values are reasonable or based on current time: [4](#0-3) 

The AEDPoS contract has overflow checking enabled in both Debug and Release configurations: [5](#0-4) 

When `CheckForOverflowUnderflow=true`, LINQ's `Sum()` operation will throw an `OverflowException` if the result exceeds `long.MaxValue`, causing validation to fail catastrophically.

### Impact Explanation

**Consensus Denial of Service**: A malicious miner (or colluding miners) can repeatedly submit `NextRound` transactions with `ExpectedMiningTime.Seconds` values set to `(long.MaxValue - small_offset)` for all miners. For example, with 17 miners each having `ExpectedMiningTime.Seconds = long.MaxValue - 1000`, the sum would be `17 * (9.22E18 - 1000) ≈ 1.57E20`, which massively exceeds `long.MaxValue (9.22E18)`.

This causes:
1. `OverflowException` during `ValidateConsensusBeforeExecution` 
2. Block validation failure
3. Inability to progress to the next round
4. Complete consensus halt if the malicious miner is the designated extra block producer

**Severity**: High - This is a critical consensus integrity violation that can halt the entire blockchain. Any miner in the current round can trigger this attack, and the cost is minimal (just crafting a malicious transaction).

### Likelihood Explanation

**Attack Feasibility**: HIGH

- **Reachable Entry Point**: The `NextRound` method is a public method callable by any current miner [6](#0-5) 

- **Attacker Capabilities**: Any miner in the current round can construct and submit a `NextRoundInput` with arbitrary `ExpectedMiningTime` values

- **Execution Practicality**: The attack requires:
  1. Being a miner in the current round (achievable through normal election)
  2. Constructing a `NextRoundInput` where all miners have `ExpectedMiningTime.Seconds` near `long.MaxValue` with consistent 4-second intervals
  3. Submitting the malicious transaction when entitled to produce the next round

- **Validation Bypass**: The `CheckRoundTimeSlots()` validation only verifies relative intervals, not absolute timestamp values, so malicious values pass validation until the `Sum()` operation is executed

- **Economic Rationality**: Attack cost is negligible (transaction fee only), while the impact is complete consensus halt

### Recommendation

**Immediate Fix**: Add validation in `CheckRoundTimeSlots()` to ensure `ExpectedMiningTime` values are reasonable relative to current time:

```csharp
public ValidationResult CheckRoundTimeSlots()
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

    // ADD: Validate ExpectedMiningTime values are reasonable
    var maxReasonableTime = Context.CurrentBlockTime.AddSeconds(86400); // 24 hours
    var minReasonableTime = Context.CurrentBlockTime;
    if (miners.Any(m => m.ExpectedMiningTime > maxReasonableTime || m.ExpectedMiningTime < minReasonableTime))
        return new ValidationResult { Message = "ExpectedMiningTime values are unreasonable." };

    // ADD: Validate sum won't overflow before calculating RoundId
    try
    {
        checked
        {
            var testSum = miners.Select(m => m.ExpectedMiningTime.Seconds).Sum();
        }
    }
    catch (OverflowException)
    {
        return new ValidationResult { Message = "RoundId calculation would overflow." };
    }

    // ... existing interval validation ...
}
```

**Alternative Fix**: Compare the provided round's `ExpectedMiningTime` values against the expected values generated by `GenerateNextRoundInformation`: [7](#0-6) 

**Test Cases**: Add unit tests that verify:
1. `NextRoundInput` with `ExpectedMiningTime` near `long.MaxValue` is rejected
2. `RoundId` calculation never throws `OverflowException`
3. Round validation fails gracefully with clear error messages for invalid timestamp ranges

### Proof of Concept

**Initial State**:
- 17 miners in current round
- Current block time: 1,700,000,000 seconds (year 2023)
- Malicious miner M1 is designated to produce next round

**Attack Steps**:
1. M1 constructs `NextRoundInput` with:
   - Miner 1: `ExpectedMiningTime.Seconds = 9223372036854775800` (near `long.MaxValue`)
   - Miner 2: `ExpectedMiningTime.Seconds = 9223372036854775804` (4 seconds later)
   - ... (each miner 4 seconds apart)
   - Miner 17: `ExpectedMiningTime.Seconds = 9223372036854775864`

2. M1 submits `NextRound` transaction with this malicious input

3. During `ValidateConsensusBeforeExecution`:
   - `TimeSlotValidationProvider.ValidateHeaderInformation` is called
   - Line 14 accesses `ProvidedRound.RoundId`
   - `RoundId` getter attempts: `Sum(17 values each ≈ 9.22E18)`
   - Result: `≈ 1.57E20` which exceeds `long.MaxValue (9.22E18)`
   - `OverflowException` is thrown due to `CheckForOverflowUnderflow=true`

**Expected Result**: Transaction validated and round progresses normally

**Actual Result**: `OverflowException` thrown, validation fails, consensus cannot progress to next round

**Success Condition**: The blockchain cannot produce new blocks as the next round cannot be established, effectively halting the network until manual intervention or miner replacement occurs.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** protobuf/aedpos_contract.proto (L33-35)
```text
    // Update consensus information, create a new round.
    rpc NextRound (NextRoundInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/aedpos_contract.proto (L458-481)
```text
message NextRoundInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producers’ expecting time (second).
    int64 round_id_for_validation = 10;
    // The random number.
    bytes random_number = 11;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElf.Contracts.Consensus.AEDPoS.csproj (L11-17)
```text
    <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>

    <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```
