### Title
Retroactive Vote Manipulation Through Dynamic Membership Changes in Association Contract

### Summary
The Association contract's vote counting mechanism evaluates votes based on current membership status rather than membership status at the time of voting. This allows organizations to retroactively invalidate or resurrect votes by removing and re-adding members after they have voted, enabling manipulation of proposal outcomes without requiring members to cast new votes.

### Finding Description

The vulnerability exists in how the Association contract counts votes for proposal release threshold checks. The core issue spans multiple functions:

**Vote Recording (at vote time):**
When members vote via `Approve()`, `Reject()`, or `Abstain()` methods, the contract verifies current membership and records the vote: [1](#0-0) 

The vote is permanently added to the proposal's approval/rejection/abstention list after membership verification at vote time.

**Vote Counting (at release time):**
When `Release()` is called, the contract re-evaluates vote counts by filtering votes through current membership: [2](#0-1) 

The critical flaw is in these counting functions that use `Contains()` against the current membership list: [3](#0-2) 

The `Contains()` method checks against the organization's current member list: [4](#0-3) 

**Membership Manipulation:**
Organizations can modify membership through `AddMember()` and `RemoveMember()` methods that are callable by the organization address itself (typically via governance proposals): [5](#0-4) [6](#0-5) 

**Root Cause:**
Votes are immutably recorded at vote time, but vote counting dynamically evaluates against current membership at release time. This temporal inconsistency allows retroactive vote manipulation through membership changes that occur between voting and release.

### Impact Explanation

**Governance Manipulation:**
- Proposals that legitimately reached approval thresholds can be prevented from passing by removing approving members
- Proposals that should fail can be made to pass by removing rejecting members
- Organizations can strategically time membership changes to achieve desired proposal outcomes

**Concrete Attack Scenarios:**

1. **Vote Suppression:** Organization with 7 members needs 4 approvals (MinimalApprovalThreshold=4). Proposal P1 receives 4 approvals from members A, B, C, D. Organization passes separate proposal P2 that removes member B. Now P1 only has 3 valid approvals (A, C, D) and cannot be released despite having met the threshold when votes were cast.

2. **Vote Resurrection:** Same organization, proposal P1 has 3 approvals. Organization removes a non-voting member E and adds cooperative member F who votes to approve. Organization can also remove/re-add previous voters to manipulate timing of when their votes count.

**Affected Parties:**
- Organization members whose votes are retroactively invalidated without their knowledge
- Proposers whose proposals fail due to vote manipulation
- The integrity of the entire governance process for Association organizations

**Severity Justification:**
Medium severity because while it requires passing a membership change proposal first (which itself requires threshold votes), such changes are legitimate operations that mask the manipulation. The impact is governance integrity compromise rather than direct fund loss.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker needs majority control to pass membership change proposals
- Once in control, attacker can systematically manipulate any pending proposals through strategic membership changes

**Attack Complexity:**
- Low - only requires calling standard `AddMember`/`RemoveMember` through governance proposals
- The membership change proposals themselves serve as the attack vector
- No complex transaction sequences or external dependencies required

**Feasibility Conditions:**
- Active proposals must exist with votes already cast
- Attacker must have sufficient votes to pass membership change proposals
- Target members can be removed and re-added without triggering obvious red flags

**Detection Constraints:**
- Membership changes appear as legitimate governance actions
- The connection between membership changes and vote count manipulation is not transparent
- No events or warnings indicate that existing votes are being invalidated

**Probability Reasoning:**
Medium-high likelihood once an attacker gains governance majority. Membership changes are expected operations, making the attack vector unobvious. The lack of vote immutability protection makes this exploitable in any scenario where membership changes occur during active proposal voting periods.

### Recommendation

**Immediate Fix:**
Capture and freeze membership status at the time of voting, not at release time:

```csharp
// In ProposalInfo, add:
message ProposalInfo {
    // ... existing fields ...
    repeated aelf.Address valid_voters_snapshot = 14; // Members at creation time
}

// In CreateNewProposal:
proposal.ValidVotersSnapshot.AddRange(organization.OrganizationMemberList.OrganizationMembers);

// In vote counting methods:
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    // Count only votes from addresses that were members when proposal was created
    var approvedMemberCount = proposal.Approvals
        .Count(addr => proposal.ValidVotersSnapshot.Contains(addr));
    // ... rest of logic
}
```

**Alternative Approach:**
Store voter eligibility status at vote time:

```csharp
// Create mapping of voter address to vote type with validation timestamp
message VoteRecord {
    aelf.Address voter = 1;
    string vote_type = 2; // "Approve", "Reject", "Abstain"
    google.protobuf.Timestamp vote_time = 3;
    bool was_valid_member = 4; // True if member at vote time
}

// Store these records and count only votes where was_valid_member == true
```

**Invariant Checks:**
1. Vote counts should never decrease due to membership changes after votes are cast
2. A voter's eligibility should be immutably determined at vote time, not release time
3. Add assertion: `ValidVotersSnapshot` must not be modified after proposal creation

**Test Cases:**
1. Member votes, gets removed, proposal release should still count their vote
2. Non-member added after proposal creation cannot have vote counted even if they vote
3. Member removed and re-added should have consistent vote counting
4. Verify vote counts remain stable across multiple membership changes

### Proof of Concept

**Initial State:**
- Organization with 5 members: [Alice, Bob, Charlie, David, Eve]
- MinimalApprovalThreshold = 3
- MinimalVoteThreshold = 3

**Attack Sequence:**

1. **Proposal P1 Created:**
   - Proposer: Alice
   - Target: Execute some critical governance action
   - Status: Pending votes

2. **Members Vote on P1:**
   - Alice: Approve
   - Bob: Approve  
   - Charlie: Approve
   - Result: 3 approvals = threshold met

3. **Attacker Creates P2 to Remove Bob:**
   - P2 proposes: RemoveMember(Bob)
   - Alice, David, Eve vote to approve P2
   - P2 is released, Bob is removed

4. **Attempt to Release P1:**
   - `IsReleaseThresholdReached()` is called
   - Line 49 executes: `proposal.Approvals.Count(organization.OrganizationMemberList.Contains)`
   - Approvals list contains [Alice, Bob, Charlie]
   - Bob is no longer in OrganizationMemberList
   - `Contains(Bob)` returns false
   - Counted approvals: 2 (only Alice and Charlie)
   - 2 < 3 (MinimalApprovalThreshold)
   - **Result: Proposal FAILS despite having received 3 valid approval votes**

5. **Attacker Re-adds Bob via P3:**
   - P3 proposes: AddMember(Bob)
   - P3 is approved and released
   - Bob is back in organization

6. **Attempt to Release P1 Again:**
   - `Contains(Bob)` now returns true
   - Counted approvals: 3 (Alice, Bob, Charlie)
   - **Result: Proposal NOW PASSES**

**Expected vs Actual:**
- **Expected:** P1 should be releasable after step 2 and remain releasable regardless of membership changes
- **Actual:** P1's releasability changes based on current membership, allowing retroactive vote manipulation

**Success Condition:**
The same proposal with identical votes changes from non-releasable to releasable solely due to membership changes, demonstrating that vote counting is not immutable and can be manipulated through membership management.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-45)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```
