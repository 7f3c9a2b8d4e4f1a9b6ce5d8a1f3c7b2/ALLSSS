### Title
Term Transition Bypass via Tiny Block Strategy Hardcoded Behaviour

### Summary
The `TinyBlockCommandStrategy` hardcodes `isNewTerm=false` when the arranged mining time exceeds the time slot, bypassing the term change detection logic in `MainChainConsensusBehaviourProvider`. This allows miners producing tiny blocks to skip term transitions, preventing miner re-election, reward distribution, and causing consensus state desynchronization.

### Finding Description

**Root Cause:**

In [1](#0-0) , when the arranged mining time for a tiny block exceeds the current time slot, the strategy creates a `TerminateRoundCommandStrategy` with `isNewTerm` hardcoded to `false`, regardless of whether a term change is actually needed.

**Correct Behaviour Path:**

The main consensus command path uses [2](#0-1)  to determine whether `NextTerm` or `NextRound` behaviour is needed by checking `CurrentRound.NeedToChangeTerm()`. This is correctly passed to [3](#0-2)  where `isNewTerm` is set based on the behaviour.

**Behaviour Mismatch:**

The hardcoded `false` in `TinyBlockCommandStrategy` causes [4](#0-3)  to generate `NextRound` behaviour instead of `NextTerm` when term change is needed.

**Execution Path Divergence:**

The incorrect `NextRound` behaviour causes [5](#0-4)  to execute instead of [6](#0-5) . The `ProcessNextRound` method skips critical term transition logic including term number updates, miner re-election, mining reward donations, Treasury releases, and election snapshots.

**Validation Bypass:**

The validation in [7](#0-6)  only checks that round numbers increment correctly and InValues are null. It does NOT validate whether the chosen behaviour (NextRound vs NextTerm) matches what should have been selected based on term timing via `NeedToChangeTerm()`. The grep search confirms [8](#0-7)  is only called by the behaviour provider, never by validation logic.

### Impact Explanation

**Consensus State Desynchronization:**
When term change is due but a miner produces tiny blocks, the system remains in the old term indefinitely. Term numbers don't increment, causing consensus state to diverge from the expected term progression based on blockchain age.

**Miner Set Manipulation:**
Current miners can remain in power beyond their term period by triggering this bug during term transitions. The miner re-election process in [9](#0-8)  is bypassed, allowing the current miner set to continue mining blocks indefinitely.

**Economic Impact:**
Mining rewards for the previous term are not donated to Treasury via [10](#0-9) , and Treasury releases are skipped. Election snapshots are not taken via [11](#0-10) , preventing proper reward distribution to voters.

**Protocol Integrity:**
The fundamental consensus invariant of periodic miner rotation is violated. Terms are designed to last `periodSeconds` (typically days), but can be extended indefinitely.

### Likelihood Explanation

**Attack Feasibility:**
Any miner can trigger this vulnerability by producing tiny blocks when their arranged mining time exceeds their time slot. This occurs naturally when a miner produces multiple blocks rapidly (minimum 50ms interval per [12](#0-11) ).

**Entry Point:**
The attack uses the standard tiny block production mechanism in [13](#0-12) . No special privileges beyond being an active miner are required.

**Attack Timing:**
Attackers can monitor term expiration by observing blockchain start timestamp and period seconds. When `NeedToChangeTerm()` would return true, they produce tiny blocks to trigger the buggy code path.

**Repeatability:**
The attack can be repeated each time term change is due, allowing indefinite term extension. Multiple miners in collusion can coordinate to ensure at least one produces tiny blocks during each critical transition.

**Detection Difficulty:**
Tiny block production appears legitimate. Distinguishing malicious term delay from normal network behavior is challenging without analyzing term timing expectations vs actual transitions.

### Recommendation

**Fix TinyBlockCommandStrategy:**

Modify [1](#0-0)  to check whether term change is needed:

```csharp
var isTermChangeNeeded = CurrentRound.RoundNumber != 1 &&
    CurrentRound.NeedToChangeTerm(blockchainStartTimestamp, 
        CurrentRound.TermNumber, periodSeconds) &&
    CurrentRound.RealTimeMinersInformation.Keys.Count > 1;
return new TerminateRoundCommandStrategy(CurrentRound, Pubkey, 
    CurrentBlockTime, isTermChangeNeeded)
    .GetAEDPoSConsensusCommand();
```

This requires passing `blockchainStartTimestamp` and `periodSeconds` to `TinyBlockCommandStrategy` constructor.

**Add Validation:**

Enhance [7](#0-6)  to validate behaviour choice correctness:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext ctx) {
    // Existing checks...
    
    // NEW: Check if NextTerm should have been chosen instead
    if (ctx.BaseRound.RoundNumber != 1 && 
        ctx.BaseRound.NeedToChangeTerm(...) &&
        ctx.BaseRound.RealTimeMinersInformation.Keys.Count > 1) {
        return new ValidationResult { 
            Message = "NextTerm behaviour required when term period expired." 
        };
    }
    return new ValidationResult { Success = true };
}
```

**Test Cases:**

Add tests validating:
1. Tiny block production during term transition triggers NextTerm (not NextRound)
2. Validation rejects NextRound when NeedToChangeTerm() returns true
3. Multiple tiny blocks cannot delay term change beyond period
4. Term transitions occur correctly regardless of tiny block production

### Proof of Concept

**Initial State:**
- Blockchain running with current term number = N
- Term period = 7 days (604800 seconds)
- Current time = blockchain_start + (7 * 86400 * N) seconds (term change due)
- Attacker is active miner with tiny block production capability

**Attack Sequence:**

1. **Monitor Term Timing:** Attacker calculates when `NeedToChangeTerm()` returns true based on [14](#0-13) 

2. **Produce Tiny Blocks:** During attacker's time slot when term change is due, produce rapid tiny blocks (max 8 per slot, 50ms intervals)

3. **Trigger Bug:** After producing multiple tiny blocks, the next arranged mining time exceeds the time slot, triggering [1](#0-0) 

4. **Generate NextRound:** The hardcoded `false` generates `NextRound` behaviour via [4](#0-3) 

5. **Execute NextRound:** Transaction calls [5](#0-4)  instead of NextTerm

6. **Verify Bypass:** Check term number remains N (should be N+1), current miner list unchanged, Treasury not released, election snapshot not taken

**Expected vs Actual:**
- **Expected:** Term number increments to N+1, miners re-elected, rewards distributed
- **Actual:** Term number stays N, same miners continue, term transition bypassed

**Success Condition:** 
Term number remains unchanged for multiple rounds beyond the period seconds threshold, proving term transition was skipped despite timing requirements being met.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L40-42)
```csharp
            return arrangedMiningTime > currentTimeSlotEndTime
                ? new TerminateRoundCommandStrategy(CurrentRound, Pubkey, CurrentBlockTime, false)
                    .GetAEDPoSConsensusCommand() // The arranged mining time already beyond the time slot.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-35)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L40-44)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                return new ConsensusCommandProvider(
                        new TerminateRoundCommandStrategy(currentRound, pubkey, currentBlockTime,
                            behaviour == AElfConsensusBehaviour.NextTerm))
                    .GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L31-31)
```csharp
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-223)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L239-242)
```csharp
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L22-22)
```csharp
        protected const int TinyBlockMinimumInterval = 50;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-62)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```
