### Title
Specific Delegation Permanently Shadows General Delegation After Delegatee Removal

### Summary
The null coalescing fallback logic in `GetDelegateeList()` fails to properly fall back from specific delegation to general delegation when all delegatees are removed from a specific delegation. After removal, an empty `TransactionFeeDelegatees` object (not null) is stored in state, which prevents the `??` operator from falling back to the general delegation map. This causes transaction fee delegation to permanently fail for specific contract methods even when valid general delegations exist.

### Finding Description

The vulnerability exists in the delegation fallback logic across multiple locations: [1](#0-0) 

The `GetDelegateeList()` function uses the null coalescing operator (`??`) to fall back from `TransactionFeeDelegateInfoMap` (specific delegation) to `TransactionFeeDelegateesMap` (general delegation). However, the root cause occurs in the delegation management logic: [2](#0-1) 

When a delegatee is removed and their delegations become empty, the code removes that individual delegatee from the `Delegatees` dictionary (line 236), but then unconditionally stores the entire `existDelegateeInfoList` object back to state (line 244-245). If this was the last delegatee, an empty `TransactionFeeDelegatees` object with an empty `Delegatees` dictionary is stored, which is NOT null.

The same issue occurs in the removal methods: [3](#0-2) 

This empty-but-not-null object breaks the fallback logic in fee charging: [4](#0-3) [5](#0-4) 

The `??` operator only checks for null, not for empty collections. When `TransactionFeeDelegateInfoMap[delegator][contract][method]` returns an empty `TransactionFeeDelegatees` object, the operator returns it instead of falling back to `TransactionFeeDelegateesMap[delegator]`. The subsequent iteration over `Delegatees` (line 106) finds no entries, and the general delegation is never consulted.

### Impact Explanation

**Operational Impact - DoS of Transaction Fee Delegation:**

1. **Transaction Failure**: Users who rely on delegation to pay transaction fees will experience transaction failures for specific contract methods, even when they have valid general delegations with sufficient funds.

2. **Permanent State Corruption**: Once a specific delegation is created and all its delegatees removed, that contract/method combination is permanently "poisoned" - the general delegation will never be consulted again for those specific transactions.

3. **User Experience Degradation**: Users who set up general delegations (thinking they cover all transactions) will be surprised when specific methods fail after they temporarily set up and remove specific delegations.

4. **Protocol Reliability**: This breaks the expected delegation hierarchy where specific delegations should only override general delegations when they contain valid delegatees, not when they're empty.

**Affected Users**: Any user who:
- Has set up a general delegation via `SetTransactionFeeDelegations`
- Later sets up a specific delegation via `SetTransactionFeeDelegateInfos` for certain contract methods
- Removes all delegatees from that specific delegation

**Severity Justification (Medium)**: While this doesn't directly lead to fund theft, it creates a permanent DoS condition for affected users' transaction fee delegation functionality. Users cannot recover without contract upgrades, as the empty state persists.

### Likelihood Explanation

**Reachable Entry Point**: The exploit path starts from public methods accessible to any user:
- `SetTransactionFeeDelegateInfos` (to create specific delegation)
- `SetTransactionFeeDelegateInfos` with empty delegations (to remove delegatees)
- `RemoveTransactionFeeDelegateeInfos` (to remove delegatees)

**Feasible Preconditions**:
1. User has established a general delegation via `SetTransactionFeeDelegations`
2. User creates a specific delegation for a contract/method via `SetTransactionFeeDelegateInfos`
3. All delegatees are removed from the specific delegation

**Execution Practicality**: The scenario is highly practical and can occur through normal usage:
- A user might temporarily set up specific delegations for testing
- A delegatee might request removal via `RemoveTransactionFeeDelegatorInfos`
- A delegator might clean up specific delegations thinking they'll fall back to general delegations
- Multiple delegatees could be removed one by one until none remain

**Economic Rationality**: No attack cost required - this is a normal operational scenario. Users might inadvertently trigger this by managing their delegations.

**Probability**: HIGH - This can happen through legitimate delegation management without any malicious intent. Users are likely to create and remove specific delegations as they test different delegation configurations.

### Recommendation

**Option 1 - Remove Empty Entries (Recommended)**:

Modify the delegation storage logic to delete the entire map entry when all delegatees are removed:

In `SetTransactionFeeDelegateInfos()` at line 244-245:
```csharp
// Only store if there are delegatees remaining
if (existDelegateeInfoList.Delegatees.Count > 0)
{
    State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
        [delegateInfo.MethodName] = existDelegateeInfoList;
}
else
{
    State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
        [delegateInfo.MethodName] = null; // or don't store anything
}
```

In `RemoveTransactionFeeDelegateInfo()` at line 385-386:
```csharp
if (delegateeInfo.Delegatees.Count > 0)
{
    State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateTransaction.ContractAddress][
        delegateTransaction.MethodName] = delegateeInfo;
}
else
{
    State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateTransaction.ContractAddress][
        delegateTransaction.MethodName] = null;
}
```

**Option 2 - Enhanced Fallback Logic**:

Modify the fallback logic to check for empty delegatees:

In `GetDelegateeList()` and similar locations:
```csharp
var specificDelegation = State.TransactionFeeDelegateInfoMap[delegator][to][methodName];
var allDelegatees = (specificDelegation?.Delegatees?.Count > 0 ? specificDelegation : null)
                    ?? State.TransactionFeeDelegateesMap[delegator];
```

**Test Cases to Add**:
1. Test creating specific delegation, removing all delegatees, then verify general delegation is used
2. Test that `TransactionFeeDelegateInfoMap` does not contain empty entries after full delegatee removal
3. Integration test: set general delegation, create and remove specific delegation, execute transaction, verify fee charged from general delegation

### Proof of Concept

**Initial State Setup**:
1. Alice has 100 ELF balance
2. Bob has 1000 ELF balance (will be general delegatee)
3. Charlie has 1000 ELF balance (will be specific delegatee, then removed)

**Exploitation Steps**:

1. **Setup General Delegation** - Alice calls `SetTransactionFeeDelegations`:
   - DelegatorAddress: Alice
   - Delegatee: Bob (via Context.Sender)
   - Delegations: {ELF: 500}
   
2. **Setup Specific Delegation** - Alice calls `SetTransactionFeeDelegateInfos`:
   - DelegatorAddress: Alice
   - DelegateInfo: {ContractAddress: TokenContract, MethodName: "Transfer", Delegations: {ELF: 500}}
   - Delegatee: Charlie (via Context.Sender)

3. **Remove All Specific Delegatees** - Charlie calls `RemoveTransactionFeeDelegatorInfos`:
   - DelegatorAddress: Alice
   - DelegateTransaction: {ContractAddress: TokenContract, MethodName: "Transfer"}
   - Result: Empty `TransactionFeeDelegatees` object stored at `TransactionFeeDelegateInfoMap[Alice][TokenContract]["Transfer"]`

4. **Attempt Transaction** - Alice calls `Transfer`:
   - Transaction fee: 10 ELF
   - Alice's balance: 100 ELF (insufficient if charged directly)
   - Bob's general delegation: 500 ELF available
   - Expected: Fee charged from Bob's general delegation
   - **Actual**: Transaction fails because specific delegation returns empty list, general delegation never checked

**Success Condition**:
The transaction fails with "Transaction fee not enough" even though Bob's general delegation has sufficient funds to pay the fee.

**Evidence of Bug**:
Query `State.TransactionFeeDelegateInfoMap[Alice][TokenContract]["Transfer"]` returns a non-null `TransactionFeeDelegatees` object with `Delegatees.Count == 0`, proving the empty object blocks the fallback to general delegation.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L134-146)
```csharp
    private List<string> GetDelegateeList(Address delegator, Address to, string methodName)
    {
        var delegateeList = new List<string>();
        var allDelegatees = State.TransactionFeeDelegateInfoMap[delegator][to][methodName] 
                            ?? State.TransactionFeeDelegateesMap[delegator];
            
        if (allDelegatees != null)
        {
            delegateeList.AddRange(allDelegatees.Delegatees.Keys.ToList());
        } 

        return delegateeList;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L233-245)
```csharp
            if (existDelegateeInfoList.Delegatees[delegateeAddress].Delegations.Count == 0 &&
                !existDelegateeInfoList.Delegatees[delegateeAddress].IsUnlimitedDelegate)
            {
                existDelegateeInfoList.Delegatees.Remove(delegateeAddress);
                toCancelTransactionList.Value.Add(new DelegateTransaction
                {
                    ContractAddress = delegateInfo.ContractAddress,
                    MethodName = delegateInfo.MethodName
                });
            }

            State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
                [delegateInfo.MethodName] = existDelegateeInfoList;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L371-387)
```csharp
    private void RemoveTransactionFeeDelegateInfo(List<DelegateTransaction> delegateTransactionList,Address delegatorAddress,string delegateeAddress)
    {
        var toCancelTransactionList = new DelegateTransactionList();
        foreach (var delegateTransaction in delegateTransactionList.Distinct())
        {
            Assert(delegateTransaction.ContractAddress != null && !string.IsNullOrEmpty(delegateTransaction.MethodName),
                "Invalid contract address and method name.");

            var delegateeInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateTransaction.ContractAddress][
                    delegateTransaction.MethodName];
            if (delegateeInfo == null || !delegateeInfo.Delegatees.ContainsKey(delegateeAddress)) continue;
            delegateeInfo.Delegatees.Remove(delegateeAddress);
            toCancelTransactionList.Value.Add(delegateTransaction);
            State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateTransaction.ContractAddress][
                delegateTransaction.MethodName] = delegateeInfo;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L100-116)
```csharp
            var transactionFeeDelegatees =
                State.TransactionFeeDelegateInfoMap[fromAddress][input.ContractAddress][input.MethodName] ??
                State.TransactionFeeDelegateesMap[fromAddress];
            if (transactionFeeDelegatees != null)
            {
                var delegateeAddress = transactionFeeDelegatees.Delegatees;
                foreach (var (delegatee, _) in delegateeAddress)
                {
                    chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                        isSizeFeeFree, Address.FromBase58(delegatee));
                    if (chargingResult)
                    {
                        break;
                    }
                }
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L174-176)
```csharp
        var delegationInfo =
            State.TransactionFeeDelegateInfoMap[delegatorAddress][input.ContractAddress][input.MethodName]?.Delegatees ?? 
            State.TransactionFeeDelegateesMap[delegatorAddress]?.Delegatees;
```
