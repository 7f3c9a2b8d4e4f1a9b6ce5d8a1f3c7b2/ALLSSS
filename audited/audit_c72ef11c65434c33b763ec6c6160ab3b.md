### Title
Quadratic Voting Amount Mismatch Causes Permanent Token Lock and Withdrawal DoS

### Summary
In the Vote contract's quadratic voting implementation, the `UpdateVotingResult` method receives only `1` as the vote amount while the full calculated token amount is locked. Upon withdrawal, the system attempts to subtract the full locked amount from voting results that only have `1` recorded, causing an arithmetic underflow exception that permanently prevents token withdrawal and creates a complete denial-of-service for quadratic voting functionality.

### Finding Description

The vulnerability exists in the `Vote()` method's handling of quadratic voting amounts:

**Vote Flow - Amount Calculation:** [1](#0-0) 

For quadratic voting, `amount` is calculated as `TicketCost * currentVotesCount`. For example, on the 3rd vote with `TicketCost=100`, the amount would be `300` tokens.

**Vote Flow - Recording:** [2](#0-1) 

The VotingRecord correctly stores the full calculated amount (e.g., 300).

**Vote Flow - Results Update Mismatch:** [3](#0-2) 

The critical bug: `UpdateVotingResult` receives `votingItem.IsQuadratic ? 1 : amount`, passing only `1` for quadratic votes instead of the full amount.

**Vote Flow - Token Locking:** [4](#0-3) 

Tokens are locked using the full calculated amount (e.g., 300 tokens).

**UpdateVotingResult Implementation:** [5](#0-4) 

This method adds the passed amount to both `Results[option]` and `VotesAmount`. For quadratic votes, it adds only `1`.

**Withdrawal Flow - The Failure Point:** [6](#0-5) 

During withdrawal, the code attempts to subtract `votingRecord.Amount` (e.g., 300) from `VotingResult` fields that only have `1` recorded.

**SafeMath Overflow Protection:** [7](#0-6) 

The `Sub()` method uses checked arithmetic, which throws `OverflowException` on underflow (e.g., `1 - 300`), causing the withdrawal transaction to fail.

### Impact Explanation

**Direct Financial Impact:**
- All tokens locked through quadratic voting become **permanently locked** and unrecoverable
- Users lose access to their staked funds indefinitely
- No recovery mechanism exists in the contract

**Operational Impact:**
- Complete denial-of-service for quadratic voting feature
- Users cannot withdraw after voting, making the feature unusable
- Voting results are corrupted even if withdrawals somehow succeed (negative values would break result integrity)

**Severity Justification:**
This is a **CRITICAL** vulnerability because:
1. Results in permanent, irreversible loss of user funds
2. Affects 100% of quadratic voting participants
3. No workaround or recovery path exists
4. Breaks a core contract invariant (lock/unlock correctness)

### Likelihood Explanation

**Exploitability: CERTAIN (100%)**

**Attacker Capabilities Required:**
- None - this is triggered by normal user operations
- Any user participating in quadratic voting is affected
- No special permissions or attack setup needed

**Attack Complexity:**
- Trivial - occurs through standard vote and withdraw calls
- Steps: (1) Register quadratic voting item, (2) User votes, (3) User attempts withdrawal

**Execution Practicality:**
- Fully executable under normal AElf contract semantics
- No special preconditions beyond having a quadratic voting item
- Withdrawal attempts guaranteed to fail due to arithmetic underflow

**Detection/Operational Constraints:**
- Bug activates on first withdrawal attempt after any quadratic vote
- Immediately observable through transaction failure
- No way to prevent or mitigate once voting has occurred

**Probability Reasoning:**
This is not a probabilistic vulnerability - it occurs with 100% certainty on every quadratic vote withdrawal attempt due to the fundamental arithmetic mismatch.

### Recommendation

**Immediate Fix:**
Modify line 119 in the Vote() method to pass the full amount for quadratic voting:

Change from:
```csharp
UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
```

To:
```csharp
UpdateVotingResult(votingItem, input.Option, amount);
```

**Invariant Checks to Add:**
1. Add assertion in Withdraw() to verify `votingResult.VotesAmount >= votingRecord.Amount` before subtraction
2. Add assertion to verify `votingResult.Results[option] >= votingRecord.Amount` before subtraction
3. These checks will provide clearer error messages if similar bugs exist

**Required Test Cases:**
1. Test quadratic voting with multiple sequential votes
2. Test withdrawal after quadratic voting
3. Test that VotingResult amounts match sum of VotingRecord amounts
4. Test edge cases: first vote, multiple votes, partial withdrawals
5. Verify VotesAmount consistency after vote/withdraw cycles

**Additional Considerations:**
- Audit all existing quadratic voting items for locked tokens that cannot be recovered
- Consider implementing an emergency unlock mechanism for affected users
- Review whether the intended design should record voting power (1 vote) or token amount in results

### Proof of Concept

**Initial State:**
- Quadratic voting item registered with `IsQuadratic = true`, `TicketCost = 100`
- User has sufficient token balance
- VotingResult.VotesAmount = 0, VotingResult.Results["OptionA"] = 0

**Transaction 1 - First Vote:**
- User calls Vote() with Option "OptionA"
- QuadraticVotesCountMap[VoteId] = 0 → 1
- Calculated amount = 100 * 1 = 100 tokens
- VotingRecord.Amount = 100 stored
- UpdateVotingResult receives **1** (not 100)
- VotingResult.VotesAmount = 0 + 1 = **1**
- VotingResult.Results["OptionA"] = 0 + 1 = **1**
- Tokens locked: **100**

**Transaction 2 - Second Vote:**
- User calls Vote() again with Option "OptionA"
- QuadraticVotesCountMap[VoteId] = 1 → 2
- Calculated amount = 100 * 2 = 200 tokens
- VotingRecord.Amount = 200 stored
- UpdateVotingResult receives **1** (not 200)
- VotingResult.VotesAmount = 1 + 1 = **2**
- VotingResult.Results["OptionA"] = 1 + 1 = **2**
- Tokens locked: **200**

**Current State:**
- Total locked tokens: 300
- VotingResult.VotesAmount: 2
- VotingResult.Results["OptionA"]: 2

**Transaction 3 - Withdrawal Attempt (FAILS):**
- User calls Withdraw() for first vote (VoteId from Transaction 1)
- System attempts: VotingResult.Results["OptionA"].Sub(100)
- Calculation: 2 - 100 = -98 (underflow!)
- SafeMath.Sub() throws OverflowException
- Transaction status: FAILED
- Tokens remain locked permanently

**Expected vs Actual Result:**
- **Expected:** User can withdraw and unlock their 100 tokens
- **Actual:** Transaction fails with OverflowException, tokens permanently locked

**Success Condition for Exploit:**
The vulnerability is proven by the withdrawal transaction failure with overflow exception, demonstrating that all quadratic voting participants cannot recover their locked tokens.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L99-103)
```csharp
        {
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L105-115)
```csharp
        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L119-119)
```csharp
        UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L124-130)
```csharp
            State.TokenContract.Lock.Send(new LockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                LockId = input.VoteId,
                Amount = amount
            });
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L214-220)
```csharp
        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-97)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
```
