### Title
Incomplete Auto-Distribution Logic Causes Profit Misallocation Across Multiple Token Types

### Summary
The auto-distribution logic in `RegisterForProfits()` prematurely breaks after finding the first token that meets its threshold, leaving other qualifying tokens undistributed. This causes tokens contributed in the same period to be distributed across different periods with different beneficiary sets, resulting in unfair profit allocation where early registrants receive disproportionately higher rewards.

### Finding Description

The auto-distribution implementation contains a critical logic error: [1](#0-0) 

The loop iterates through `AutoDistributeThreshold` entries, but executes `break` at line 199 after finding the FIRST token whose balance meets its threshold. This means only ONE token symbol is added to `distributedInput.AmountsMap`, even when multiple tokens meet their respective thresholds.

The problematic flow:
1. User calls `RegisterForProfits()` 
2. `AddBeneficiary()` is executed first, adding the user to the current period [2](#0-1) 

3. Auto-distribution check runs - only distributes FIRST qualifying token
4. Period increments after distribution [3](#0-2) 

5. Remaining tokens stay in general ledger until next registration triggers their distribution

When beneficiaries are added, their `StartPeriod` is set to the scheme's current period: [4](#0-3) 

This means beneficiaries who register AFTER the first auto-distribution are ineligible for profits from the already-distributed token, despite that token being contributed in the same timeframe as tokens they ARE eligible for.

### Impact Explanation

**Direct Fund Impact - Reward Misallocation:**

Concrete exploitation scenario:
- Scheme created with `AutoDistributeThreshold = {ELF: 1000, JUN: 1000}`
- Both ELF (1000) and JUN (1000) contributed to general ledger in Period 1
- User A registers with 100 shares:
  - Added as beneficiary starting Period 1
  - Auto-distribution triggers: only ELF distributed to Period 1
  - Period increments to 2
  - JUN remains in general ledger
- User B registers with 100 shares:
  - Added as beneficiary starting Period 2 (cannot claim Period 1)
  - Auto-distribution triggers: JUN distributed to Period 2
  - Period increments to 3

**Result:**
- User A claims: 100% of ELF (100/100 shares in Period 1) + 50% of JUN (100/200 shares in Period 2)
- User B claims: 0% of ELF (not beneficiary in Period 1) + 50% of JUN (100/200 shares in Period 2)

Despite equal 100-share contributions, User A receives significantly more value. The test case demonstrates this expectation: [5](#0-4) [6](#0-5) 

The test expects BOTH tokens to be claimable, indicating the intended behavior is to distribute ALL qualifying tokens, not just one.

**Who is affected:** All schemes using multi-token auto-distribution. Early registrants gain unfair advantage over later registrants with equal stakes.

### Likelihood Explanation

**Attack Complexity:** TRIVIAL
- Attacker simply needs to monitor when multiple thresholds are met
- Race to be first to call `RegisterForProfits()` 
- Gains exclusive access to first token's profits

**Preconditions:**
- Scheme has multiple `AutoDistributeThreshold` entries (common for multi-token dividend schemes)
- Multiple tokens simultaneously meet their thresholds (realistic when contributions arrive together)
- No special permissions required - any user can register

**Detection:** Difficult to detect as it appears as normal contract usage. Victims only discover misallocation when claiming profits and finding discrepancies.

**Probability:** HIGH - occurs deterministically whenever multiple thresholds are met and users register sequentially.

### Recommendation

**Code Fix:**
Remove the `break` statement at line 199 to allow the loop to check ALL thresholds and add ALL qualifying tokens to `AmountsMap`:

```csharp
foreach (var threshold in scheme.AutoDistributeThreshold)
{
    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
    {
        Owner = virtualAddress,
        Symbol = threshold.Key
    }).Balance;
    if (balance < threshold.Value) continue;
    if (distributedInput == null)
        distributedInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
    distributedInput.AmountsMap[threshold.Key] = 0;
    // Remove: break;
}
```

**Invariant to Enforce:**
When auto-distribution is triggered, ALL tokens meeting their respective thresholds MUST be distributed in the same period to maintain fair profit allocation.

**Test Case:**
Add assertion to verify that when multiple thresholds are met, `distributedInput.AmountsMap` contains ALL qualifying token symbols before calling `DistributeProfits`.

### Proof of Concept

**Initial State:**
1. Create scheme: `AutoDistributeThreshold = {ELF: 1000, JUN: 1000}`
2. Contribute: 1000 ELF to general ledger
3. Contribute: 1000 JUN to general ledger
4. Current Period = 1, TotalShares = 0

**Exploitation Steps:**
1. **User A** calls `RegisterForProfits(amount: 100)`
   - AddBeneficiary: User A added with StartPeriod=1, TotalShares=100
   - Auto-distribution: ELF threshold met → distributes only ELF to Period 1
   - Period increments to 2
   - JUN remains undistributed in general ledger

2. **User B** calls `RegisterForProfits(amount: 100)`
   - AddBeneficiary: User B added with StartPeriod=2, TotalShares=200
   - Auto-distribution: JUN threshold met → distributes JUN to Period 2
   - Period increments to 3

**Expected vs Actual:**
- **Expected:** Both ELF and JUN distributed in Period 1; both users receive 50% of each token
- **Actual:** ELF in Period 1 (User A: 100%), JUN in Period 2 (User A: 50%, User B: 50%)

**Success Condition:**
User A receives MORE total token value than User B despite equal share contributions, demonstrating profit misallocation vulnerability.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L168-176)
```csharp
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L184-199)
```csharp
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L203-205)
```csharp
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L368-372)
```csharp
            AutoDistributeThreshold =
            {
                { nativeTokenSymbol, amount },
                { tokenA, amount }
            }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L412-414)
```csharp
        profitMap.Value.Count.ShouldBe(2);
        profitMap.Value.ContainsKey(nativeTokenSymbol).ShouldBeTrue();
        profitMap.Value[nativeTokenSymbol].ShouldBe(amount);
```
