### Title
Vote Weight Interest Changes Create Unfair Profit Distribution Between Temporally-Separated Equal Voters

### Summary
The `SetVoteWeightInterest()` function allows the Parliament to change vote weight calculation parameters at any time, but existing votes retain weights calculated at their creation time with no migration mechanism. This creates a fairness violation where voters making identical commitments (same amount and lock duration) at different times receive different profit shares based solely on when they voted, violating the principle that equal contributions should receive equal rewards.

### Finding Description

The Election contract calculates vote weights using a configurable interest formula in `GetVotesWeight()` [1](#0-0) . When a user votes, this weight is calculated once and stored permanently in the Profit contract as beneficiary shares [2](#0-1) .

The Parliament can change the interest calculation parameters via `SetVoteWeightInterest()` at any time [3](#0-2) . This function is protected only by governance authorization [4](#0-3) , with no checks for existing active votes or migration mechanisms.

**Root Cause:** When the interest list changes, new voters get weights calculated with the new parameters while existing voters permanently retain their old weights. The `FixProfitDetail()` method in the Profit contract only updates period timing, NOT shares [5](#0-4) . Even when voters change their vote target via `ExtendVoterWelfareProfits()`, the recalculated weight in the view layer [6](#0-5)  is NOT used to update stored shares [7](#0-6) .

**Why Protections Fail:** The system has no mechanism to:
1. Notify or compensate existing voters when rates change
2. Recalculate existing voter weights with new parameters
3. Prevent rate changes while active votes exist
4. Track which rate regime each voter's weight was calculated under

### Impact Explanation

**Concrete Harm:** Two voters committing identical resources (same token amount, same lock duration) receive different profit shares from the Welfare scheme based purely on when they voted relative to interest rate changes.

**Quantified Example:**
- Alice votes 10,000 tokens for 365 days under original interest settings (e.g., 1% daily compound) → Weight = 12,000 shares
- Parliament legitimately adjusts to 2% daily compound to incentivize voting
- Bob votes 10,000 tokens for 365 days under new settings → Weight = 18,000 shares
- Bob receives 50% more profit distribution than Alice despite identical commitment

**Who Is Affected:** All election voters participating in the welfare profit distribution. The unfairness compounds over time as the voting population is split between different rate regimes.

**Severity Justification:** Medium - This constitutes reward misallocation (Direct Fund Impact criterion) affecting economic fairness across the entire voting system, though it requires legitimate governance action rather than adversarial exploitation.

### Likelihood Explanation

**Entry Point:** `SetVoteWeightInterest()` is publicly callable by the VoteWeightInterestController (Parliament by default) [3](#0-2) .

**Preconditions:** Parliament proposes and executes a change to the vote weight interest parameters. This is a **legitimate governance action**, not a security compromise. Valid reasons include:
- Responding to token price volatility
- Adjusting voting incentives based on participation rates
- Rebalancing economic parameters for network health

**Execution Practicality:** Straightforward - a single Parliament proposal to call `SetVoteWeightInterest()` with new parameters immediately creates the unfairness condition for all subsequent voters.

**Detection Constraints:** The unfairness is not immediately visible to users. Voters must manually compare their profit shares with others who voted at different times with same parameters to detect the discrepancy.

**Probability:** High - Given that economic conditions change over time, it is reasonable to expect Parliament will adjust interest parameters during the system's lifetime. Each adjustment creates or exacerbates cross-temporal unfairness.

### Recommendation

**Code-Level Mitigation:**

1. **Add Migration Mechanism:** Implement a function to recalculate and update existing voters' weights when interest parameters change:
```solidity
public override Empty MigrateVoteWeights(MigrateVoteWeightsInput input)
{
    AssertPerformedByVoteWeightInterestController();
    
    // For each active vote in the specified range
    foreach (var voteId in input.VoteIds)
    {
        var votingRecord = State.VoteContract.GetVotingRecord.Call(voteId);
        var lockSeconds = State.LockTimeMap[voteId];
        
        // Recalculate weight with current interest list
        var newWeight = GetVotesWeight(votingRecord.Amount, lockSeconds);
        
        // Update profit detail shares
        State.ProfitContract.UpdateBeneficiaryShares.Send(new UpdateBeneficiarySharesInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = votingRecord.Voter,
                Shares = newWeight
            },
            ProfitDetailId = voteId
        });
    }
}
```

2. **Add Transition Period:** Store both old and new interest lists with effective timestamps, applying prorated weights during a transition window.

3. **Add Rate Change Delay:** Implement a time lock requiring N days notice before interest rate changes take effect, giving voters time to respond.

**Invariant Checks:**
- Assert that cross-temporal fairness is maintained: voters with equal commitments receive proportional shares regardless of vote timing
- Track the interest list version used for each vote's weight calculation
- Log interest list changes with timestamps for auditability

**Test Cases:**
1. Vote with parameters A, change interest list, vote with same parameters → verify equal share allocation
2. Change interest list multiple times with active votes → verify no voter is disadvantaged
3. Call migration function after rate change → verify all existing voters get updated weights

### Proof of Concept

**Initial State:**
- Default VoteWeightInterestList is configured [8](#0-7) 
- Welfare profit scheme is active

**Transaction Sequence:**

1. **Alice votes** (Day 1):
   - Call `Vote()` with 10,000 tokens, 365-day lock
   - Weight calculated: `GetVotesWeight(10000, 31536000)` using default interest (1% interest, 1000 capital)
   - Result: ~10,365 shares stored in Profit contract

2. **Parliament changes interest rates** (Day 5):
   - Parliament calls `SetVoteWeightInterest()` with higher rates (2% interest, 1000 capital)
   - Transaction succeeds [9](#0-8) 

3. **Bob votes** (Day 6):
   - Call `Vote()` with 10,000 tokens, 365-day lock
   - Weight calculated: `GetVotesWeight(10000, 31536000)` using new interest (2% interest, 1000 capital)  
   - Result: ~14,778 shares stored in Profit contract

4. **Verify unfairness**:
   - Query Alice's profit detail: 10,365 shares
   - Query Bob's profit detail: 14,778 shares
   - Bob receives 42.6% more profit share than Alice despite identical commitment

**Expected Result:** Both Alice and Bob should have equal shares for equal commitments.

**Actual Result:** Bob has 42.6% more shares than Alice, violating cross-temporal fairness and causing permanent reward misallocation in the welfare profit distribution.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L126-160)
```csharp
    private void ExtendVoterWelfareProfits(Hash voteId)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);

        // Extend endPeriod from now no, so the lockTime will *NOT* be changed.
        var lockTime = State.LockTimeMap[voteId];
        var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
        if (lockPeriod == 0)
        {
            return;
        }

        var endPeriod = lockPeriod.Add(treasury.CurrentPeriod);
        var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
        if (extendingDetail != null)
        {
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
        }
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L189-208)
```csharp
    public override Empty SetVoteWeightInterest(VoteWeightInterestList input)
    {
        AssertPerformedByVoteWeightInterestController();
        Assert(input.VoteWeightInterestInfos.Count > 0, "invalid input");
        // ReSharper disable once PossibleNullReferenceException
        foreach (var info in input.VoteWeightInterestInfos)
        {
            Assert(info.Capital > 0, "invalid input");
            Assert(info.Day > 0, "invalid input");
            Assert(info.Interest > 0, "invalid input");
        }

        Assert(input.VoteWeightInterestInfos.GroupBy(x => x.Day).Count() == input.VoteWeightInterestInfos.Count,
            "repeat day input");
        var orderList = input.VoteWeightInterestInfos.OrderBy(x => x.Day).ToArray();
        input.VoteWeightInterestInfos.Clear();
        input.VoteWeightInterestInfos.AddRange(orderList);
        State.VoteWeightInterestList.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L226-252)
```csharp
    private VoteWeightInterestList GetDefaultVoteWeightInterest()
    {
        return new VoteWeightInterestList
        {
            VoteWeightInterestInfos =
            {
                new VoteWeightInterest
                {
                    Day = 365,
                    Interest = 1,
                    Capital = 1000
                },
                new VoteWeightInterest
                {
                    Day = 730,
                    Interest = 15,
                    Capital = 10000
                },
                new VoteWeightInterest
                {
                    Day = 1095,
                    Interest = 2,
                    Capital = 1000
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L385-391)
```csharp
    private void AssertPerformedByVoteWeightInterestController()
    {
        if (State.VoteWeightInterestController.Value == null)
            State.VoteWeightInterestController.Value = GetDefaultVoteWeightInterestController();

        Assert(Context.Sender == State.VoteWeightInterestController.Value.OwnerAddress, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L296-305)
```csharp
        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L337-355)
```csharp
    private ElectionVotingRecord TransferVotingRecordToElectionVotingRecord(VotingRecord votingRecord, Hash voteId)
    {
        var lockSeconds = State.LockTimeMap[voteId];
        return new ElectionVotingRecord
        {
            Voter = votingRecord.Voter,
            Candidate = GetNewestPubkey(votingRecord.Option),
            Amount = votingRecord.Amount,
            TermNumber = votingRecord.SnapshotNumber,
            VoteId = voteId,
            LockTime = lockSeconds,
            VoteTimestamp = votingRecord.VoteTimestamp,
            WithdrawTimestamp = votingRecord.WithdrawTimestamp,
            UnlockTimestamp = votingRecord.VoteTimestamp.AddSeconds(lockSeconds),
            IsWithdrawn = votingRecord.IsWithdrawn,
            Weight = GetVotesWeight(votingRecord.Amount, lockSeconds),
            IsChangeTarget = votingRecord.IsChangeTarget
        };
    }
```
