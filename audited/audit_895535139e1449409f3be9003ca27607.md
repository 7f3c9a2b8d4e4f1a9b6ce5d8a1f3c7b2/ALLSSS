# Audit Report

## Title
Unhandled KeyNotFoundException in IsCurrentMiner During Term Transitions Causes DoS of Critical Authorization Checks

## Summary
The `IsCurrentMiner` function contains a logic flaw that causes unhandled `KeyNotFoundException` during term transitions when checking authorization for miners removed from the new term's miner list. This occurs because `ConvertAddressToPubkey` returns pubkeys from previous rounds, but `IsCurrentMiner` skips the existence check when `IsMinerListJustChanged = true`, then directly accesses the dictionary without a guard. This blocks critical operations including transaction fee claims and cross-chain indexing during the first round of each new term.

## Finding Description

The vulnerability stems from an unsafe dictionary access pattern in the consensus contract's miner authorization logic.

**Root Cause Chain:**

1. The `ConvertAddressToPubkey` helper function combines miners from both current AND previous rounds when looking up addresses. [1](#0-0) 

2. The private `IsCurrentMiner(string pubkey)` method has conditional logic that skips the safety check. When `IsMinerListJustChanged` is `false`, it properly validates key existence before dictionary access. However, when `IsMinerListJustChanged` is `true` (set during term transitions), it skips this validation. [2](#0-1) 

3. After skipping the validation, the code has a special case handler for `ExtraBlockProducerOfPreviousRound` that returns early. [3](#0-2) 

4. However, for all other miners from the previous round who are NOT in the current round and NOT the extra block producer, execution continues to line 158 where it performs an unguarded dictionary access: `var minerInRound = currentRound.RealTimeMinersInformation[pubkey]`. This throws `KeyNotFoundException` if the pubkey doesn't exist in the current round. [4](#0-3) 

5. The `IsMinerListJustChanged` flag is set to `true` during term transitions when generating the first round of a new term. [5](#0-4) 

**Affected Operations:**

1. **Transaction Fee Claims**: The `ClaimTransactionFees` method requires sender to be a current miner via `AssertSenderIsCurrentMiner()`. [6](#0-5)  This assertion calls `IsCurrentMiner` with the sender's address. [7](#0-6) 

2. **Cross-Chain Indexing**: Both `ProposeCrossChainIndexing` and `ReleaseCrossChainIndexingProposal` require the sender to be a current miner. [8](#0-7)  These methods call `AssertAddressIsCurrentMiner`, which invokes `CheckCrossChainIndexingPermission`. [9](#0-8)  This ultimately calls `IsCurrentMiner`. [10](#0-9) 

## Impact Explanation

**Severity: Medium**

This vulnerability causes a **Denial of Service** during term transitions with the following impacts:

1. **Disrupted Fee Distribution**: Removed miners attempting to claim transaction fees will experience unhandled exceptions instead of receiving a clear "No permission" error. While this is their expected fate (they're no longer miners), the exception propagates incorrectly and could affect other legitimate operations if the same code path is used.

2. **Cross-Chain Communication Breakdown**: Cross-chain indexing operations fail with unhandled exceptions during the vulnerable window, potentially disrupting cross-chain message relaying and side-chain coordination.

3. **Degraded User Experience**: Instead of receiving controlled authorization failures with clear error messages, operations fail with low-level exceptions, making debugging difficult and potentially masking the actual issue.

4. **Operational Disruption Window**: The vulnerability persists for the duration of the first round of each new term (while `IsMinerListJustChanged = true`), which occurs at every term transition.

The impact is limited to availability rather than fund loss or unauthorized access, but affects critical protocol infrastructure during predictable windows.

## Likelihood Explanation

**Likelihood: Moderate to High**

The vulnerability is highly likely to occur due to:

1. **Regular Occurrence**: Term transitions happen periodically as part of AElf's normal consensus cycle. During each transition where the miner list changes, `IsMinerListJustChanged` is set to `true`, creating the vulnerable condition.

2. **Natural Triggering**: Removed miners may legitimately attempt to claim fees or perform operations without realizing they've been removed, naturally triggering the bug. No malicious intent is required.

3. **Low Complexity**: Any user can trigger the exception by calling `IsCurrentMiner` with an address of a removed miner during the vulnerable window. The public nature of the `IsCurrentMiner` method means external actors could deliberately trigger this for any removed miner's address.

4. **Predictable Conditions**:
   - Term transitions are observable on-chain
   - Miner list changes are public information
   - The vulnerable state persists for the entire first round of the new term

5. **No Special Privileges Required**: The affected public methods can be called by any address, making the attack surface broad.

## Recommendation

Add a defensive key existence check before accessing the dictionary at line 158, regardless of the `IsMinerListJustChanged` state:

```csharp
private bool IsCurrentMiner(string pubkey)
{
    if (pubkey == null) return false;
    
    if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;
    
    // Always check if pubkey exists in current round before accessing
    if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
    {
        // Special case: allow ExtraBlockProducerOfPreviousRound during round start
        if (currentRound.IsMinerListJustChanged && 
            Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            return true;
        }
        return false;
    }
    
    var miningInterval = currentRound.GetMiningInterval();
    var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
    // ... rest of the logic
}
```

This ensures that:
1. Key existence is always validated before dictionary access
2. The special case for `ExtraBlockProducerOfPreviousRound` is preserved
3. Removed miners receive a clear boolean `false` result instead of an exception
4. Authorization failures are handled through the normal `Assert` mechanism with clear error messages

## Proof of Concept

```csharp
[Fact]
public async Task IsCurrentMiner_ThrowsKeyNotFoundException_WhenRemovedMinerCheckedDuringTermTransition()
{
    // Setup: Create initial term with 5 miners
    var initialMiners = new[] { "MinerA", "MinerB", "MinerC", "MinerD", "MinerE" };
    var initialRound = CreateRound(initialMiners, roundNumber: 1, termNumber: 1);
    initialRound.IsMinerListJustChanged = false;
    await consensusContract.UpdateCurrentRound(initialRound);
    
    // Simulate term transition: Remove MinerD and MinerE, keep A, B, C
    var newTermMiners = new[] { "MinerA", "MinerB", "MinerC" };
    var newTermRound = CreateRound(newTermMiners, roundNumber: 2, termNumber: 2);
    newTermRound.IsMinerListJustChanged = true; // First round of new term
    newTermRound.ExtraBlockProducerOfPreviousRound = "MinerA"; // Not MinerD or MinerE
    await consensusContract.UpdateCurrentRound(newTermRound);
    
    // Attempt to check if removed MinerD is current miner
    var minerDAddress = Address.FromPublicKey(GetPubkeyBytes("MinerD"));
    
    // This should throw KeyNotFoundException instead of returning false
    var exception = await Assert.ThrowsAsync<KeyNotFoundException>(async () =>
    {
        var result = await consensusContract.IsCurrentMiner(minerDAddress);
    });
    
    // Expected behavior: should return BoolValue { Value = false } without throwing
    // Actual behavior: throws KeyNotFoundException at line 158 of IsCurrentMiner
    Assert.NotNull(exception);
}
```

**Notes:**
- The vulnerability only manifests during the first round of a new term when `IsMinerListJustChanged = true`
- The removed miner must not be the `ExtraBlockProducerOfPreviousRound` to trigger the bug
- In subsequent rounds of the same term, `IsMinerListJustChanged` becomes `false` and the ContainsKey check prevents the exception
- The same issue can occur during mid-term miner replacements when evil miners are replaced with alternatives, as this also sets `IsMinerListJustChanged = true` [11](#0-10)

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L125-134)
```csharp
    private string ConvertAddressToPubkey(Address address)
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return null;
        var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
        if (TryToGetPreviousRoundInformation(out var previousRound))
            possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys);

        return possibleKeys.FirstOrDefault(k =>
            Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)) == address);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L142-144)
```csharp
        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L150-155)
```csharp
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L158-159)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
        var timeSlotStartTime = minerInRound.ExpectedMiningTime;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L298-346)
```csharp
        var isMinerListChanged = false;
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
        }

        currentRound.GenerateNextRoundInformation(currentBlockTime, blockchainStartTimestamp, out nextRound,
            isMinerListChanged);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L40-42)
```csharp
        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L867-869)
```csharp
    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L897-906)
```csharp
    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-290)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```
