### Title
Miner Can Bypass Consensus Validation by Using TinyBlock Behaviour When UpdateValue is Required

### Summary
Miners can claim `TinyBlock` behaviour when they should use `UpdateValue` behaviour for their first block in a time slot, bypassing validation that ensures cryptographic consensus data (OutValue, Signature, PreviousInValue) is properly set. This allows miners to inflate their `ProducedBlocks` count without contributing to the consensus cryptographic chain, resulting in unearned mining rewards from the Treasury contract.

### Finding Description

**Root Cause**: Missing validation that the claimed consensus behaviour matches the expected behaviour based on round state.

The vulnerability exists in the consensus block production flow:

1. **Behaviour Selection**: The expected behaviour is deterministically calculated in `GetConsensusCommand()` [1](#0-0)  based on round state via `ConsensusBehaviourProviderBase.GetConsensusBehaviour()`. When a miner's `OutValue` is null (first block of time slot), `UpdateValue` behaviour should be used [2](#0-1) .

2. **Miner-Provided Behaviour**: However, in `GetConsensusBlockExtraData()`, the actual behaviour used comes from `triggerInformation.Behaviour` [3](#0-2) , which is provided by the miner in the input, not validated against the expected behaviour.

3. **Simplified Round Creation**: When `TinyBlock` behaviour is used, `GetTinyBlockRound()` creates a stripped-down Round object [4](#0-3)  containing only basic mining information (pubkey, mining times, block counts) without cryptographic consensus data (OutValue, Signature, PreviousInValue).

4. **Bypassed Validation**: The `ValidateBeforeExecution()` applies behaviour-specific validators [5](#0-4) . `UpdateValue` behaviour gets `UpdateValueValidationProvider` which checks that OutValue and Signature are properly filled [6](#0-5) . When `TinyBlock` is claimed instead, this validator is not applied, allowing the block to pass validation without setting consensus cryptographic data.

5. **State Update**: `ProcessTinyBlock()` increments `ProducedBlocks` and `ProducedTinyBlocks` counts [7](#0-6)  regardless of whether consensus data was properly set.

6. **Recovery Mechanism**: `RecoverFromTinyBlock()` only restores minimal state (ActualMiningTimes, ImpliedIrreversibleBlockHeight) [8](#0-7) , leaving OutValue, Signature, and PreviousInValue unset.

### Impact Explanation

**Economic Impact**: The `ProducedBlocks` count directly determines mining reward shares in the Treasury contract [9](#0-8) . Specifically:
- Average `ProducedBlocks` is calculated across all miners
- Each miner's reward share is calculated based on their `ProducedBlocks` count [10](#0-9) 
- Miners with inflated counts receive disproportionate rewards

**Consensus Quality Impact**: 
- Missing cryptographic contributions weaken the consensus signature chain
- The system compensates by supplying fake consensus data for non-participating miners [11](#0-10) , reducing overall consensus security
- Legitimate miners who properly participate are disadvantaged

**Who is Affected**:
- Honest miners receive reduced reward shares as dishonest miners claim unearned rewards
- The protocol's consensus quality degrades
- Treasury funds are misallocated

**Severity Justification**: Medium severity due to direct economic impact on reward distribution and consensus quality degradation, though the system has built-in resilience mechanisms that prevent complete consensus failure.

### Likelihood Explanation

**Attacker Capabilities**: Any block-producing miner can exploit this vulnerability.

**Attack Complexity**: Low - the miner simply claims `TinyBlock` behaviour in `triggerInformation.Behaviour` when `UpdateValue` is expected.

**Feasibility Conditions**:
- Miner must be in the active miner list (normal precondition for block production)
- Miner's time slot must be active
- No additional resources or permissions required beyond normal block production rights

**Detection Constraints**: 
- The miner's `OutValue` remaining null is observable in the round state
- However, this may be attributed to normal missed blocks rather than intentional exploitation
- The attack could be performed selectively to avoid detection

**Economic Rationality**: Highly rational - minimal additional cost (just claiming wrong behaviour) with direct reward gain from inflated `ProducedBlocks` count.

**Probability**: High - easy to execute, economically beneficial, and difficult to distinguish from legitimate missed blocks.

### Recommendation

**Code-Level Mitigation**:

Add behaviour validation in `ValidateBeforeExecution()` to verify the claimed behaviour matches the expected behaviour based on current round state:

```csharp
// In ValidateBeforeExecution, after line 20:
var expectedBehaviour = IsMainChain
    ? new MainChainConsensusBehaviourProvider(baseRound, extraData.SenderPubkey.ToHex(),
            GetMaximumBlocksCount(), Context.CurrentBlockTime, 
            GetBlockchainStartTimestamp(), State.PeriodSeconds.Value)
        .GetConsensusBehaviour()
    : new SideChainConsensusBehaviourProvider(baseRound, extraData.SenderPubkey.ToHex(),
            GetMaximumBlocksCount(), Context.CurrentBlockTime)
        .GetConsensusBehaviour();

if (expectedBehaviour != extraData.Behaviour)
{
    return new ValidationResult 
    { 
        Success = false, 
        Message = $"Behaviour mismatch: expected {expectedBehaviour}, got {extraData.Behaviour}"
    };
}
```

**Invariant Checks to Add**:
- Assert that when `OutValue` is null for a miner in their time slot, only `UpdateValue` behaviour is allowed (except for specific edge cases like extra block producer scenarios)
- Validate that `TinyBlock` behaviour is only used after `OutValue` has been set in the current round

**Test Cases**:
1. Test that claiming `TinyBlock` when `OutValue` is null results in validation failure
2. Test that claiming `UpdateValue` when `OutValue` is already set results in validation failure  
3. Test that correct behaviour sequences (UpdateValue followed by TinyBlocks) pass validation
4. Test that reward distribution correctly reflects only legitimate block production

### Proof of Concept

**Initial State**:
- Round N has started
- Miner A has time slot with `OutValue == null` (first block of slot)
- Expected behaviour: `UpdateValue`

**Attack Steps**:

1. Miner A requests consensus command via `GetConsensusCommand()` - receives `UpdateValue` behaviour instruction

2. Instead of following the instruction, Miner A produces a block with:
   - `triggerInformation.Behaviour = AElfConsensusBehaviour.TinyBlock`
   - Minimal consensus data (no OutValue/Signature/PreviousInValue)

3. Block validation occurs:
   - `ValidateBeforeExecution()` calls `RecoverFromTinyBlock()` [12](#0-11) 
   - Basic validators pass (time slot, mining permission, continuous blocks)
   - `UpdateValueValidationProvider` is NOT applied (only added for UpdateValue behaviour)
   - Block passes validation

4. Block execution:
   - `ProcessTinyBlock()` increments `ProducedBlocks` and `ProducedTinyBlocks`
   - `OutValue`, `Signature`, `PreviousInValue` remain null in state

5. At term end, Treasury distribution:
   - Miner A's inflated `ProducedBlocks` count is used to calculate reward shares
   - Miner A receives unearned rewards based on blocks that didn't contribute to consensus

**Expected vs Actual Result**:
- Expected: Miner must use `UpdateValue` behaviour, setting cryptographic consensus data, or block is rejected
- Actual: Miner can use `TinyBlock` behaviour, bypass consensus data requirements, and still receive reward credit

**Success Condition**: Miner A has `ProducedBlocks > 0` but `OutValue == null` in round state, and receives proportional BasicReward shares from Treasury contract.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L39-46)
```csharp
        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L49-114)
```csharp
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }

        /// <summary>
        ///     If this miner come to a new round, normally, there are three possible behaviour:
        ///     UPDATE_VALUE (most common)
        ///     TINY_BLOCK (happens if this miner is mining blocks for extra block time slot of previous round)
        ///     NEXT_ROUND (only happens in first round)
        /// </summary>
        /// <returns></returns>
        private AElfConsensusBehaviour HandleMinerInNewRound()
        {
            if (
                // For first round, the expected mining time is incorrect (due to configuration),
                CurrentRound.RoundNumber == 1 &&
                // so we'd better prevent miners' ain't first order (meanwhile he isn't boot miner) from mining fork blocks
                _minerInRound.Order != 1 &&
                // by postpone their mining time
                CurrentRound.FirstMiner().OutValue == null
            )
                return AElfConsensusBehaviour.NextRound;

            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;

            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L26-38)
```csharp
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L58-82)
```csharp
    public Round GetTinyBlockRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = minerInRound.Pubkey,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight
                }
            }
        };

        foreach (var otherPubkey in RealTimeMinersInformation.Keys.Except(new List<string> { pubkey }))
            round.RealTimeMinersInformation.Add(otherPubkey, new MinerInRound());

        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L49-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L789-821)
```csharp
        var averageProducedBlocksCount = CalculateAverage(previousTermInformation.Last().RealTimeMinersInformation
            .Values
            .Select(i => i.ProducedBlocks).ToList());
        // Manage weights of `MinerBasicReward`
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L171-221)
```csharp
    private void SupplyCurrentRoundInformation()
    {
        var currentRound = GetCurrentRoundInformation(new Empty());
        Context.LogDebug(() => $"Before supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
        var notMinedMiners = currentRound.RealTimeMinersInformation.Values.Where(m => m.OutValue == null).ToList();
        if (!notMinedMiners.Any()) return;
        TryToGetPreviousRoundInformation(out var previousRound);
        foreach (var miner in notMinedMiners)
        {
            Context.LogDebug(() => $"Miner pubkey {miner.Pubkey}");

            Hash previousInValue = null;
            Hash signature = null;

            // Normal situation: previous round information exists and contains this miner.
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
            }

            if (previousInValue == null)
            {
                // Handle abnormal situation.

                // The fake in value shall only use once during one term.
                previousInValue = HashHelper.ComputeFrom(miner);
                signature = previousInValue;
            }

            // Fill this two fields at last.
            miner.InValue = previousInValue;
            miner.Signature = signature;

            currentRound.RealTimeMinersInformation[miner.Pubkey] = miner;
        }

        TryToUpdateRoundInformation(currentRound);
        Context.LogDebug(() => $"After supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
    }
```
