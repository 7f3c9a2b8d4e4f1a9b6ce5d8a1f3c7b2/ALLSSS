### Title
Weak Referendum Thresholds Enable Governance Bypass for User Fee Changes

### Summary
The referendum controller for user fee changes uses extremely weak thresholds (MinimalApprovalThreshold=1, MaximalRejectionThreshold=0, MaximalAbstentionThreshold=0), allowing Parliament to bypass community consensus. A referendum proposal can pass with just 1 token of approval if no community member votes against it before expiration, enabling rapid user fee coefficient changes without meaningful community participation.

### Finding Description

The `GetReferendumControllerCreateInputForUserFee()` function creates a referendum organization with critically weak voting thresholds: [1](#0-0) 

This referendum organization is used as part of the UserFeeController governance structure, where both Parliament and Referendum must approve changes to user transaction fee coefficients: [2](#0-1) 

The root cause is the referendum release threshold validation logic that requires only 1 token of approval while allowing zero rejections or abstentions: [3](#0-2) 

Parliament is the only authorized proposer for this referendum organization: [4](#0-3) 

In the referendum voting mechanism, anyone holding the token can vote by locking tokens, with vote weight determined by token amount: [5](#0-4) 

The vulnerability exists because:
1. Parliament creates a referendum proposal with an arbitrarily short expiration time (no minimum duration enforced)
2. A single token holder (potentially controlled by Parliament or an ally) approves with just 1 token
3. If no community member votes reject or abstain before expiration, the proposal passes
4. The released referendum then votes in the Association, combining with Parliament's vote to authorize user fee changes

This bypasses the intended purpose of having community referendum oversight, as the threshold doesn't require meaningful community participation.

### Impact Explanation

**Authorization & Governance Impact**: User transaction fee coefficients can be manipulated without genuine community consensus, violating the governance invariant that organization thresholds must ensure proper authorization.

The protected resource is the user fee calculation coefficients: [6](#0-5) 

These coefficients directly control how much users pay for transactions, making them critical economic parameters. Initial coefficients show the fee structure affects all transactions: [7](#0-6) 

**Concrete Harm**:
- Parliament can increase transaction fees arbitrarily (e.g., from x/800 to x/8, a 100x increase)
- Users pay higher fees without community approval
- Economic parameters meant for community governance become centrally controlled
- Undermines trust in the governance system

**Affected Parties**: All network users paying transaction fees, which represents the entire user base for any blockchain operation.

**Severity Justification**: HIGH - This is a governance bypass affecting critical economic parameters with network-wide impact. While it requires Parliament participation (a semi-trusted role), the design explicitly includes referendum oversight to prevent unilateral Parliament actions, which this vulnerability circumvents.

### Likelihood Explanation

**Reachable Entry Point**: Parliament can create referendum proposals through the standard CreateProposal mechanism: [8](#0-7) 

**Attacker Capabilities**: Parliament (a semi-trusted role) plus any single token holder (potentially controlled address or ally).

**Attack Complexity**: LOW
1. Parliament creates referendum proposal with short expiration (e.g., 1 hour or less)
2. Controlled address or ally approves with 1 token
3. Release before community can react
4. Parliament also approves in Association
5. Execute fee coefficient change

**Feasibility Conditions**:
- No minimum proposal duration enforced (proposals only need future expiration time)
- No community notification delay or voting period requirements
- Events are only observable after proposal creation, giving limited reaction time
- Short expiration times can exploit timezone differences or low-activity periods (weekends, holidays)

**Detection Constraints**: Community members must actively monitor ProposalCreated events and vote reject/abstain before the proposal expires, which may be minutes or hours depending on Parliament's chosen expiration time.

**Economic Rationality**: Cost is just 1 token plus transaction fees. Benefit could be significant if Parliament wants to change fees for any reason (reduce user costs to attract users, or increase to generate revenue).

**Probability**: MEDIUM-HIGH - While requiring Parliament cooperation, the governance design explicitly includes referendum oversight as a check on Parliament, indicating the system designers intended community participation. The weak threshold defeats this design, making exploitation straightforward if Parliament desires to act without community consensus.

### Recommendation

**Code-Level Mitigation**:

Modify `GetReferendumControllerCreateInputForUserFee()` to use meaningful thresholds that require substantial community participation: [9](#0-8) 

Recommended changes:
```
MinimalApprovalThreshold = 100_000_000  // 100M tokens (adjust based on total supply)
MinimalVoteThreshold = 200_000_000      // 200M total votes required
MaximalRejectionThreshold = 80_000_000  // Max 80M rejections allowed
MaximalAbstentionThreshold = 80_000_000 // Max 80M abstentions allowed
```

These values should be calibrated based on the primary token's total supply and expected community participation rates, ensuring:
1. Meaningful portion of token supply must participate (e.g., 10-20% quorum)
2. Approval threshold requires majority support from participants
3. Rejection/abstention limits prevent minority blocking while allowing legitimate dissent

**Invariant Checks to Add**:
1. Enforce minimum referendum threshold values during organization creation
2. Add proposal minimum duration requirements (e.g., 72 hours minimum)
3. Consider implementing time-locked voting periods after proposal creation

**Test Cases**:
1. Test that referendum proposals with insufficient approval fail
2. Test that proposals with any rejection/abstention when limits are 0 fail correctly
3. Test attack scenario with 1 token approval succeeds under current code
4. Test that new thresholds prevent 1-token approvals
5. Test edge cases around threshold boundaries

### Proof of Concept

**Required Initial State**:
- UserFeeController initialized with weak referendum thresholds (default state)
- Parliament has default organization address
- At least one address holds >= 1 primary token (e.g., ELF)

**Attack Sequence**:

1. **Parliament creates malicious fee coefficient proposal to Association**:
   - Target: UpdateCoefficientsForSender with increased fee coefficients
   - Organization: UserFeeController.RootController (Association)
   - Requires both Parliament and Referendum approval

2. **Parliament creates referendum proposal to approve Association proposal**:
   - Method: ReferendumContract.CreateProposal
   - Target: AssociationContract.Approve(associationProposalId)
   - Organization: UserFeeController.ReferendumController
   - Expiration: CurrentTime + 1 hour (short window)
   - Proposer: Parliament (whitelisted)

3. **Attacker (or controlled address) approves referendum with 1 token**:
   - Approve 1 token allowance to referendum proposal virtual address
   - Call ReferendumContract.Approve(referendumProposalId)
   - Locks 1 token, adds to ApprovalCount

4. **Release referendum proposal** (after 1 hour, before community reaction):
   - Call ReferendumContract.Release(referendumProposalId)
   - Threshold check: ApprovalCount(1) >= MinimalApprovalThreshold(1) ✓
   - Threshold check: RejectionCount(0) <= MaximalRejectionThreshold(0) ✓
   - Threshold check: AbstentionCount(0) <= MaximalAbstentionThreshold(0) ✓
   - Executes: AssociationContract.Approve(associationProposalId) from referendum address

5. **Parliament approves Association proposal** (through normal Parliament process)

6. **Release Association proposal**:
   - Both members (Parliament and Referendum) have approved
   - Executes: TokenContract.UpdateCoefficientsForSender with malicious coefficients

**Expected Result**: Fee coefficients updated with only Parliament + 1 token approval, no genuine community consensus

**Actual Result**: Same as expected - vulnerability confirmed by code analysis

**Success Condition**: User fee coefficients changed despite lacking broad community participation, demonstrating governance bypass.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L133-156)
```csharp
    private CreateOrganizationBySystemContractInput GetReferendumControllerCreateInputForUserFee(
        Address parliamentAddress)
    {
        var whiteList = new List<Address> { parliamentAddress };
        var tokenSymbol = GetPrimaryTokenSymbol(new Empty()).Value;
        return new CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new CreateOrganizationInput
            {
                TokenSymbol = tokenSymbol,
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1,
                    MinimalVoteThreshold = 1,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { whiteList }
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L158-184)
```csharp
    private Association.CreateOrganizationBySystemContractInput GetAssociationControllerCreateInputForUserFee(
        Address parliamentAddress, Address referendumAddress)
    {
        var proposers = new List<Address>
            { referendumAddress, parliamentAddress };
        return new Association.CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new Association.CreateOrganizationInput
            {
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { proposers }
                },
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = proposers.Count,
                    MinimalVoteThreshold = proposers.Count,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { proposers }
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-59)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L70-83)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        var organization = State.Organizations[proposal.OrganizationAddress];
        var allowance = GetAllowance(Context.Sender, organization.TokenSymbol, input);

        proposal.ApprovalCount = proposal.ApprovalCount.Add(allowance);
        State.Proposals[input] = proposal;
        var referendumReceiptCreated = LockToken(organization.TokenSymbol, allowance, input, Context.Sender,
            proposal.OrganizationAddress);
        referendumReceiptCreated.ReceiptType = nameof(Approve);
        Context.Fire(referendumReceiptCreated);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L25-32)
```csharp
    public override Empty UpdateCoefficientsForSender(UpdateCoefficientsInput input)
    {
        Assert(input.Coefficients != null, "Invalid input coefficients.");
        AssertUserFeeController();
        input.Coefficients.FeeTokenType = (int)FeeTypeEnum.Tx; // The only possible for now.
        UpdateCoefficients(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L274-312)
```csharp
    private CalculateFeeCoefficients GetTxFeeInitialCoefficient()
    {
        return new CalculateFeeCoefficients
        {
            FeeTokenType = (int)FeeTypeEnum.Tx,
            PieceCoefficientsList =
            {
                new CalculateFeePieceCoefficients
                {
                    // Interval [0, 1000000]: x / 800 + 1 / 10000
                    Value =
                    {
                        1000000,
                        1, 1, 800,
                        0, 1, 10000
                    }
                },
                new CalculateFeePieceCoefficients
                {
                    // Interval (1000000, 5000000): x / 80
                    Value =
                    {
                        5000000,
                        1, 1, 80
                    }
                },
                new CalculateFeePieceCoefficients
                {
                    // Interval (5000000, ∞): x / 80 + x^2 / 100000
                    Value =
                    {
                        int.MaxValue,
                        1, 1, 80,
                        2, 1, 100000
                    }
                }
            }
        };
    }
```
