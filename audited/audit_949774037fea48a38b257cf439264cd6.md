### Title
Banned Candidates Can Be Selected as Miner Replacements Due to Missing Ban Status Check

### Summary
The `GetMinerReplacementInformation()` function fails to verify if alternative candidates from the previous term snapshot are currently banned before selecting them. This allows banned candidates to be returned as valid alternatives to replace evil miners, undermining the consensus integrity and ban mechanism.

### Finding Description
The vulnerability exists in the alternative candidate selection logic where candidates from the previous term snapshot are filtered and selected. [1](#0-0) 

At line 377, the code uses `.Take(take)` to select alternative candidates from `maybeNextCandidates` without checking if these candidates are currently banned. The filtering at lines 370-374 only excludes:
- Initial miners
- Current miners

However, it completely omits checking `State.BannedPubkeyMap[cs.Key]` to filter out banned candidates.

This is inconsistent with the logic for selecting initial miners as alternatives, where banned status IS checked: [2](#0-1) 

Line 389 explicitly filters banned initial miners with `.Where(k => !State.BannedPubkeyMap[k])`, demonstrating that the developers understood the need to check ban status but failed to apply it consistently.

The root cause is that `GetPreviousTermSnapshotWithNewestPubkey()` only handles candidates that were banned BEFORE the snapshot was taken: [3](#0-2) 

This does not protect against candidates who are banned AFTER the snapshot was taken but BEFORE the alternative selection occurs.

Candidates are banned via `UpdateCandidateInformation()`: [4](#0-3) 

### Impact Explanation
This vulnerability allows banned evil nodes to be returned as valid alternative candidates for miner replacement. The specific harms include:

1. **Consensus Integrity Violation**: Banned candidates could be provided to the consensus contract as legitimate alternatives to replace evil miners, potentially allowing them back into the active miner set.

2. **Ban Mechanism Circumvention**: The entire purpose of the ban system (implemented via `State.BannedPubkeyMap`) is defeated when banned candidates can still be selected as alternatives.

3. **Protocol Trust Degradation**: If nodes that were identified as evil/banned can return to the miner set, it undermines the security model and trust in the consensus mechanism.

The impact is critical because it directly affects the integrity of the miner selection process, which is foundational to the blockchain's consensus security.

### Likelihood Explanation
This vulnerability has HIGH likelihood of exploitation because:

**Reachable Entry Point**: The `GetMinerReplacementInformation()` function is a public view method called by the consensus contract during normal miner replacement operations. [5](#0-4) 

**Feasible Preconditions**: The vulnerability triggers naturally when:
1. A candidate exists in the previous term's election results
2. That candidate is banned during the current term (via `UpdateCandidateInformation` with `IsEvilNode=true`)
3. The candidate is not an initial miner and not currently in the miner list
4. An evil miner needs to be replaced

**Execution Practicality**: This scenario occurs in normal blockchain operations without requiring any attacker action. Miners can be banned at any time during a term for malicious behavior, and the snapshot from the previous term would still contain their pre-ban voting results.

**No Attack Required**: This is a pure logic bug that manifests during legitimate protocol operations, making it extremely likely to occur.

### Recommendation
Add a ban status check to filter out banned candidates before the `.Take(take)` operation. Modify line 377 in `ViewMethods.cs`:

**Current code:**
```csharp
alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
```

**Fixed code:**
```csharp
alternativeCandidates.AddRange(maybeNextCandidates
    .Where(c => !State.BannedPubkeyMap[c.Key])
    .Select(c => c.Key)
    .Take(take));
```

This ensures consistency with the ban check already applied to initial miners at line 389 and prevents any banned candidate from being selected as an alternative.

**Additional test case**: Add a unit test that:
1. Creates a candidate in term N with votes
2. Takes a snapshot at end of term N
3. Bans that candidate in term N+1
4. Calls `GetMinerReplacementInformation()` in term N+1
5. Asserts that the banned candidate is NOT in the returned alternative candidates list

### Proof of Concept

**Initial State:**
- Term N: Candidate X participates in election with valid votes
- Candidate X is included in the term N election results snapshot

**Exploitation Steps:**
1. Term N ends, `TakeSnapshot()` is called, saving candidate X's voting results
2. Early in term N+1: Candidate X is detected as malicious
3. `UpdateCandidateInformation()` is called with `IsEvilNode=true` for candidate X
4. This sets `State.BannedPubkeyMap[X] = true`
5. Later in term N+1: Another evil miner Y is detected
6. Consensus contract calls `GetMinerReplacementInformation(currentMinerList)` where Y is in the current miner list
7. Function executes line 363: retrieves term N snapshot (still contains candidate X from before ban)
8. Function executes lines 368-375: filters candidates, X passes (not initial miner, not current miner)
9. Function executes line 377: `.Take(take)` selects X without checking ban status

**Expected Result:** Candidate X should be excluded from alternative candidates because `State.BannedPubkeyMap[X] = true`

**Actual Result:** Candidate X is included in `AlternativeCandidatePubkeys` and returned to the consensus contract as a valid alternative to replace evil miner Y

**Success Condition:** The consensus contract receives a banned candidate as a "valid" alternative, demonstrating the vulnerability allows circumvention of the ban mechanism.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L145-158)
```csharp
        var bannedCandidates = snapshot.ElectionResult.Keys.Where(IsPubkeyBanned).ToList();
        Context.LogDebug(() => $"Banned candidates count: {bannedCandidates.Count}");
        if (!bannedCandidates.Any()) return snapshot;
        Context.LogDebug(() => "Getting snapshot and there's miner replaced during current term.");
        foreach (var bannedCandidate in bannedCandidates)
        {
            var newestPubkey = GetNewestPubkey(bannedCandidate);
            // If newest pubkey not exists or same as old pubkey (which is banned), skip.
            if (newestPubkey == null || newestPubkey == bannedCandidate ||
                snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
            if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-359)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L368-377)
```csharp
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L387-391)
```csharp
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```
