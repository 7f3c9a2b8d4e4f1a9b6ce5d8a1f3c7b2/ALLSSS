### Title
Non-Deterministic Extra Block Producer Selection Due to Insufficient Order Uniqueness Validation in Round Transitions

### Summary
The `CalculateNextExtraBlockProducerOrder()` function relies on sorting miners by their `Order` field using `OrderBy()` on a non-deterministically ordered `MapField.Values` collection. If multiple miners have duplicate `Order` values, different nodes will select different extra block producers due to stable sort preserving different original enumerations, causing immediate consensus failure. The existing validation in `NextRoundMiningOrderValidationProvider` is ineffective at preventing duplicate orders, as it checks object distinctness rather than `FinalOrderOfNextRound` value uniqueness.

### Finding Description

**Location:** [1](#0-0) 

The vulnerable code at line 112 performs:
```csharp
var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
    .FirstOrDefault(m => m.Signature != null);
```

**Root Cause:** `RealTimeMinersInformation` is a protobuf map field [2](#0-1)  which in C# becomes a `MapField<string, MinerInRound>`. Protobuf map iteration order is non-deterministic and can vary between nodes. When `OrderBy(m => m.Order)` encounters duplicate `Order` values, it performs a stable sort that preserves the relative ordering from the original collection. If two nodes have different internal map orderings and multiple miners share the same `Order`, they will select different miners after sorting.

**Why Existing Protections Fail:**

1. **Flawed Validation Logic:** [3](#0-2) 

The validation checks `distinctCount` of objects, not distinctness of `FinalOrderOfNextRound` values. Since each `MinerInRound` object has a unique `Pubkey`, calling `.Distinct()` on the collection returns all miners even if their `FinalOrderOfNextRound` values are identical. This allows duplicate order values to pass validation.

2. **Order Assignment Without Uniqueness Check:** [4](#0-3) 

When generating the next round, `Order` is directly assigned from `FinalOrderOfNextRound`. If duplicates exist in `FinalOrderOfNextRound`, they propagate to `Order` without detection.

3. **No FirstRound Validation:** [5](#0-4) 

The `FirstRound` method accepts external input without validating `Order` uniqueness, relying only on mining interval calculation which doesn't enforce uniqueness.

4. **Additional Vulnerable Patterns:** Multiple code locations assume Order uniqueness: [6](#0-5)  and [7](#0-6) 

### Impact Explanation

**Consensus Failure (Critical):**
- When nodes disagree on the extra block producer, they reject each other's blocks as invalid
- Chain immediately splits into multiple forks based on which miner each node group expects
- No block can achieve consensus finality as different node groups follow different chains
- The entire network halts until manual intervention

**Affected Parties:**
- All network validators and nodes
- All users and applications depending on the blockchain
- Economic damage from halted transactions and loss of confidence

**Severity:** CRITICAL - Results in immediate, deterministic consensus failure the moment duplicate orders exist during extra block production calculation.

### Likelihood Explanation

**Feasibility: MEDIUM-HIGH**

**Preconditions:**
1. Duplicate `FinalOrderOfNextRound` values must exist in current round when transitioning to next round
2. At least one of the miners with duplicate orders must have a non-null `Signature`

**Attack Vectors:**

1. **Conflict Resolution Edge Cases:** [8](#0-7) 
   
   While conflict resolution attempts to reassign duplicate orders, edge cases exist:
   - Race conditions if multiple `UpdateValue` transactions process concurrently
   - Modulo arithmetic edge cases producing collisions
   - Insufficient search range if all orders already occupied

2. **Validation Bypass:** The ineffective validation allows any round with duplicate `FinalOrderOfNextRound` values to be accepted and stored [9](#0-8) 

3. **Uninitialized Orders:** If miners have `Order = 0` (protobuf default value), multiple miners would share the same order value, all sorting to the front.

**Detection:** Would manifest immediately as block rejection and consensus split - easily detectable but catastrophic.

### Recommendation

**1. Fix Order Uniqueness Validation:**

Replace the validation logic to check actual value uniqueness:
```csharp
// In NextRoundMiningOrderValidationProvider.cs
var finalOrders = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
var distinctOrderCount = finalOrders.Distinct().Count();
if (distinctOrderCount != finalOrders.Count || 
    distinctOrderCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
{
    validationResult.Message = "Duplicate FinalOrderOfNextRound values detected.";
    return validationResult;
}
```

**2. Add Explicit Order Validation in GenerateNextRoundInformation:**

Before line 59, add:
```csharp
// Validate Order uniqueness in next round
var orderCounts = nextRound.RealTimeMinersInformation.Values
    .GroupBy(m => m.Order)
    .Where(g => g.Count() > 1)
    .ToList();
Assert(orderCounts.Count == 0, "Duplicate Order values detected in next round");
```

**3. Add FirstRound Order Validation:** [5](#0-4) 

**4. Use Deterministic Sorting Key:**

Replace line 112 to explicitly break ties deterministically:
```csharp
var firstPlaceInfo = RealTimeMinersInformation.Values
    .OrderBy(m => m.Order)
    .ThenBy(m => m.Pubkey) // Deterministic tie-breaker
    .FirstOrDefault(m => m.Signature != null);
```

However, this is a workaround - proper fix is preventing duplicates entirely.

**5. Add Unit Tests:**
- Test round generation with manually crafted duplicate `FinalOrderOfNextRound`
- Verify validation rejects duplicates
- Test with Order = 0 for multiple miners
- Test FirstRound input validation

### Proof of Concept

**Initial State:**
1. Current round with 5 miners, all have mined blocks (OutValue != null)
2. Through signature hash collision or conflict resolution bug, miners A and B both have `FinalOrderOfNextRound = 1`
3. Other miners have `FinalOrderOfNextRound = 2, 3, 4`

**Transaction Sequence:**

**Step 1:** Miner calls `NextRound` with round containing the duplicate orders
- `NextRoundMiningOrderValidationProvider` validation runs
- `.Distinct()` checks object distinctness: 5 distinct miner objects
- Count matches 5 miners with OutValue != null
- **Validation passes despite duplicate order values**

**Step 2:** `ProcessNextRound` calls `GenerateNextRoundInformation` [10](#0-9) 
- Miners A and B both assigned `Order = 1` in next round
- Next round stored with duplicate orders

**Step 3:** Extra block production time arrives, `CalculateNextExtraBlockProducerOrder()` executes on all nodes

**Node 1 (MapField enumeration: A, B, C, D, E):**
- `Values.OrderBy(m => m.Order)`: stable sort keeps A before B for Order=1
- `FirstOrDefault(m => m.Signature != null)`: selects miner A

**Node 2 (MapField enumeration: B, A, C, D, E):**
- `Values.OrderBy(m => m.Order)`: stable sort keeps B before A for Order=1  
- `FirstOrDefault(m => m.Signature != null)`: selects miner B

**Result:**
- Node 1 expects miner A to produce extra block
- Node 2 expects miner B to produce extra block
- When extra block arrives from A, Node 2 rejects it as invalid producer
- When extra block arrives from B, Node 1 rejects it as invalid producer
- **Consensus split - chain halts**

**Success Condition:** Different nodes calculate different extra block producers and reject each other's blocks, causing permanent consensus failure.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** protobuf/aedpos_contract.proto (L243-264)
```text
message Round {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producersâ€™ expecting time (second).
    int64 round_id_for_validation = 10;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L74-92)
```csharp
    public override Empty FirstRound(Round input)
    {
        /* Basic checks. */
        Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");

        /* Initial settings. */
        State.CurrentTermNumber.Value = 1;
        State.CurrentRoundNumber.Value = 1;
        State.FirstRoundNumberOfEachTerm[1] = 1;
        State.MiningInterval.Value = input.GetMiningInterval();
        SetMinerList(input.GetMinerList(), 1);

        AddRoundInformation(input);

        Context.LogDebug(() =>
            $"Initial Miners: {input.RealTimeMinersInformation.Keys.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L76-80)
```csharp
        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L142-148)
```csharp
    public MinerInRound FirstMiner()
    {
        return RealTimeMinersInformation.Count > 0
            ? RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == 1)
            // Unlikely.
            : new MinerInRound();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-40)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```
