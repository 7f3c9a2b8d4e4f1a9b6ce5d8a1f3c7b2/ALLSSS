### Title
Unvalidated Round Data Manipulation via TuneOrderInformation Allows Consensus Mining Order Exploitation

### Summary
The `TryToUpdateRoundInformation()` function only validates that a round exists (null check) but does not validate the contents of the round object before storage. This allows authorized miners to manipulate `FinalOrderOfNextRound` values for any miner through the `TuneOrderInformation` parameter in `UpdateValue`, enabling consensus order manipulation and providing unfair mining advantages in subsequent rounds.

### Finding Description
The vulnerability exists in the interaction between three components:

**1. Insufficient Validation in TryToUpdateRoundInformation:** [1](#0-0) 

This function performs only a null check (`if (ri == null) return false;`) to verify a round exists, but does not validate the round object's contents before storing it to `State.Rounds[round.RoundNumber]`.

**2. Unvalidated Application of TuneOrderInformation:** [2](#0-1) 

The `ProcessUpdateValue` function applies user-provided `TuneOrderInformation` values directly to any miner's `FinalOrderOfNextRound` without:
- Bounds checking (values should be 1 to minerCount)
- Uniqueness validation (preventing duplicate orders)
- Authorization checks (whether the caller can modify other miners' orders)

**3. Direct Usage in Next Round Generation:** [3](#0-2) 

The next round generation directly uses these manipulated `FinalOrderOfNextRound` values to determine mining order and expected mining times, propagating the malicious data into the consensus schedule.

**Why Existing Protections Fail:**

The `PreCheck()` authorization: [4](#0-3) 

Only verifies the sender is a current miner, not the validity of the data they provide.

The `UpdateValueValidationProvider`: [5](#0-4) 

Only validates OutValue, Signature, and PreviousInValue fields - it does not validate TuneOrderInformation contents.

### Impact Explanation
**Consensus Integrity Compromise:**
- A malicious miner can set their own `FinalOrderOfNextRound` to 1, guaranteeing they mine first in the next round
- First mining position provides advantages: priority transaction selection, MEV opportunities, and extra block producer role probability

**Round Generation Disruption:**
- Setting invalid order values (0, negative, or > minerCount) can break the round generation logic [6](#0-5) 

- Duplicate orders across multiple miners violate consensus assumptions and may cause calculation errors

**Unfair Mining Schedule:**
- Manipulating other miners' orders can push them to unfavorable time slots
- Repeated exploitation across multiple rounds compounds the advantage
- Affects block reward distribution and consensus fairness

**Severity Justification:** Medium - Does not directly steal funds but compromises consensus fairness and provides systematic mining advantages to malicious actors.

### Likelihood Explanation
**Attacker Capabilities:**
- Attacker must be an authorized miner in the current round
- This is a realistic precondition as miners are elected participants in the network

**Attack Complexity:**
- Low complexity: Simply call `UpdateValue` with crafted `TuneOrderInformation` in the `UpdateValueInput` [7](#0-6) 

- No complex cryptographic operations or timing requirements beyond normal block production

**Feasibility Conditions:**
- The entry point `UpdateValue` is a public RPC method [8](#0-7) 

- Exploitation occurs during normal consensus participation

**Detection Constraints:**
- Malicious orders may appear as legitimate consensus behavior
- No automatic detection mechanism exists for invalid order values
- Would require manual review of round transition data

**Economic Rationality:**
- Cost: One transaction during normal block production (minimal)
- Benefit: Guaranteed first mining position in subsequent rounds, potential MEV capture, increased block rewards
- Risk/reward ratio favors exploitation

### Recommendation
**1. Add Content Validation to TryToUpdateRoundInformation:**
```csharp
private bool TryToUpdateRoundInformation(Round round)
{
    var ri = State.Rounds[round.RoundNumber];
    if (ri == null) return false;
    
    // Validate round contents before storage
    if (!ValidateRoundOrderIntegrity(round, ri)) return false;
    
    State.Rounds[round.RoundNumber] = round;
    return true;
}

private bool ValidateRoundOrderIntegrity(Round newRound, Round existingRound)
{
    var minersCount = newRound.RealTimeMinersInformation.Count;
    var orders = new HashSet<int>();
    
    foreach (var miner in newRound.RealTimeMinersInformation.Values)
    {
        // Validate FinalOrderOfNextRound is in valid range
        if (miner.FinalOrderOfNextRound < 0 || 
            miner.FinalOrderOfNextRound > minersCount)
            return false;
            
        // Check for duplicate non-zero orders
        if (miner.FinalOrderOfNextRound > 0)
        {
            if (orders.Contains(miner.FinalOrderOfNextRound))
                return false;
            orders.Add(miner.FinalOrderOfNextRound);
        }
    }
    
    return true;
}
```

**2. Restrict TuneOrderInformation Authority in ProcessUpdateValue:**
```csharp
// Only allow miners to set their own FinalOrderOfNextRound
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    // Validate the miner can only tune their own order
    if (tuneOrder.Key != _processingBlockMinerPubkey)
        continue; // Or Assert(false, "Cannot tune other miners' orders");
        
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}
```

**3. Add Test Cases:**
- Test with out-of-bounds order values (0, negative, > minerCount)
- Test with duplicate FinalOrderOfNextRound values across miners
- Test attempting to modify other miners' orders
- Verify round generation handles invalid orders gracefully

### Proof of Concept
**Initial State:**
- Current round has 5 miners with public keys: [Miner1, Miner2, Miner3, Miner4, Miner5]
- Current round number: 100
- Miner3 (attacker) is producing a block

**Attack Steps:**
1. Miner3 constructs malicious `UpdateValueInput`:
   ```
   UpdateValueInput {
       OutValue: [valid hash],
       Signature: [valid signature],
       RoundId: 100,
       TuneOrderInformation: {
           "Miner3": 1,        // Attacker gives themselves first position
           "Miner1": 5,        // Pushes previous first miner to last
           "Miner2": 0         // Sets invalid order for another miner
       },
       // ... other required fields
   }
   ```

2. Miner3 calls `UpdateValue(UpdateValueInput)`

3. `ProcessConsensusInformation` executes:
   - PreCheck passes (Miner3 is authorized)
   - VRF verification passes
   - `ProcessUpdateValue` applies TuneOrderInformation values
   - `TryToUpdateRoundInformation` performs only null check - passes
   - Malicious round is stored

4. Next round (101) is generated using manipulated orders:
   - Miner3 gets Order=1 (first mining position)
   - Miner1 gets Order=5 (last position)
   - Miner2's invalid Order=0 may cause generation errors

**Expected Result:**
Validation should reject the round update due to invalid order values and unauthorized order manipulation.

**Actual Result:**
The malicious round is stored successfully, and Miner3 gains first mining position in round 101 with systematic advantage over other miners.

**Success Condition:**
Query `GetRoundInformation(101)` shows Miner3 with Order=1 and Miner2 with the invalid Order=0, confirming the manipulation was stored.

### Notes
The intended design per `ExtractInformationToUpdateConsensus` suggests `TuneOrderInformation` should only contain miners whose `FinalOrderOfNextRound` differs from `SupposedOrderOfNextRound`: [9](#0-8) 

However, no enforcement of this design exists in `ProcessUpdateValue`, allowing arbitrary manipulation. The vulnerability exploits the gap between the helper method's intended usage and the lack of validation in the actual processing logic.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L126-132)
```csharp
    private bool TryToUpdateRoundInformation(Round round)
    {
        var ri = State.Rounds[round.RoundNumber];
        if (ri == null) return false;
        State.Rounds[round.RoundNumber] = round;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L27-28)
```csharp
        /* Privilege check. */
        if (!PreCheck()) Assert(false, "No permission.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** protobuf/aedpos_contract.proto (L30-31)
```text
    rpc UpdateValue (UpdateValueInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/aedpos_contract.proto (L194-221)
```text
message UpdateValueInput {
    // Calculated from current in value.
    aelf.Hash out_value = 1;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 2;
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
    // Publish previous in value for validation previous signature and previous out value.
    aelf.Hash previous_in_value = 4;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    google.protobuf.Timestamp actual_mining_time = 5;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 6;
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 8;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 9;
    // The amount of produced blocks.
    int64 produced_blocks = 10;
    // The InValue in the previous round, miner public key -> InValue.
    map<string, aelf.Hash> miners_previous_in_values = 11;
    // The irreversible block height that miner recorded.
    int64 implied_irreversible_block_height = 12;
    // The random number.
    bytes random_number = 13;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```
