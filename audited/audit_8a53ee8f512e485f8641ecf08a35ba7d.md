### Title
Insufficient Input Validation in SetMinerIncreaseInterval Allows Zero/Negative Values Causing Consensus DoS

### Summary
The `SetMinerIncreaseInterval` function lacks proper validation to prevent zero or negative values for `MinerIncreaseInterval`. When set to zero, division operations in miner count calculations throw `DivideByZeroException`, causing denial of service on consensus processing. When set to negative values, it produces incorrect miner count calculations that could reduce the active miner set below safe thresholds.

### Finding Description

**Root Cause:**
The validation check in `SetMinerIncreaseInterval` is insufficient: [1](#0-0) 

This assertion only verifies that the new value is less than or equal to the current value, allowing decreases to zero or negative values. There is no lower bound check to ensure the value remains positive.

The `MinerIncreaseInterval` is stored as a signed 64-bit integer: [2](#0-1) 

During initialization, the value is set without validation: [3](#0-2) 

**Critical Usage Points:**

1. In `GetAutoIncreasedMinersCount()`, the value is used in division: [4](#0-3) 

2. In `GetMinersCount(Round input)`, similar division occurs: [5](#0-4) 

3. This function is called during consensus processing: [6](#0-5) 

**Why Protections Fail:**
The AElf safe math library's `Div` operation throws `DivideByZeroException` for zero divisors, as confirmed by tests: [7](#0-6) 

For negative divisors, the division succeeds but returns negative results: [8](#0-7) 

### Impact Explanation

**Scenario 1: Zero Value - Consensus DoS**
- If `MinerIncreaseInterval` is set to 0, any consensus update calling `GetMinersCount()` will throw `DivideByZeroException`
- This blocks round transitions and term updates
- The blockchain's consensus mechanism becomes stuck
- **Severity: CRITICAL** - Complete consensus failure

**Scenario 2: Negative Value - Miner Count Manipulation**
- If set to a negative value (e.g., -31536000 after default of 31536000)
- After 1 year of operation: `(31536000 seconds) / (-31536000) * 2 = -2`
- Results in `SupposedMinersCount + (-2)`, artificially reducing miner count
- Could decrease active miners below minimum safe thresholds (e.g., reducing from 5 to 3 or fewer)
- Compromises consensus security and network resilience
- **Severity: HIGH** - Undermines consensus integrity

**Who is affected:**
- All network participants (consensus failure)
- Election contract (receives incorrect miner counts)
- Network security (reduced validator set)

### Likelihood Explanation

**Attacker Capabilities Required:**
The `SetMinerIncreaseInterval` function requires the caller to be the MaximumMinersCountController: [9](#0-8) 

By default, this is the Parliament default organization: [10](#0-9) 

**Attack Complexity:**
- Requires governance approval through Parliament proposal
- Parliament is controlled by miners/stakeholders voting
- Requires either:
  - Compromise of governance majority
  - Malicious proposal approval
  - Accidental misconfiguration during governance action

**Likelihood Assessment:**
- **LOW to MEDIUM** - Requires governance control but:
  - Governance attacks are realistic threat vectors
  - No secondary validation prevents obviously invalid values
  - Accidental misconfiguration is possible (no warning for extreme decreases)
  - Once exploited, impact is immediate and severe

**Detection Constraints:**
- The change is visible on-chain through governance proposal
- However, without explicit bounds checking, reviewers may not recognize the danger
- Test coverage does not include boundary cases (zero/negative): [11](#0-10) 

### Recommendation

**Code-Level Mitigation:**

1. Add positive value validation in `SetMinerIncreaseInterval`:
```
Assert(input.Value > 0, "MinerIncreaseInterval must be positive.");
Assert(input.Value <= State.MinerIncreaseInterval.Value, "Can only decrease interval.");
```

2. Add validation in `InitialAElfConsensusContract`:
```
Assert(input.MinerIncreaseInterval > 0, "MinerIncreaseInterval must be positive.");
```

3. Add defensive check in calculation functions:
```
private int GetAutoIncreasedMinersCount()
{
    if (State.BlockchainStartTimestamp.Value == null) 
        return AEDPoSContractConstants.SupposedMinersCount;
    
    var interval = State.MinerIncreaseInterval.Value;
    Assert(interval > 0, "Invalid MinerIncreaseInterval configuration.");
    
    return AEDPoSContractConstants.SupposedMinersCount.Add(
        (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
        .Div(interval).Mul(2));
}
```

**Test Cases:**
1. Attempt to set `MinerIncreaseInterval` to 0 - should fail
2. Attempt to set `MinerIncreaseInterval` to negative value - should fail
3. Attempt to initialize contract with zero/negative interval - should fail
4. Verify existing behavior for valid decreases still works

### Proof of Concept

**Initial State:**
- Blockchain initialized with default `MinerIncreaseInterval` = 31536000 (1 year)
- Parliament governance configured with default organization
- Multiple miners active in consensus

**Exploitation Steps:**

**Step 1: Create Malicious Proposal**
```
Parliament.CreateProposal({
  ToAddress: ConsensusContract,
  Method: "SetMinerIncreaseInterval",
  Params: Int64Value { Value: 0 },  // or negative value
  OrganizationAddress: DefaultOrganization
})
```

**Step 2: Approve and Execute Proposal**
- Governance members approve the proposal
- Proposal reaches threshold and executes
- `State.MinerIncreaseInterval.Value` becomes 0 (or negative)

**Step 3: Trigger Consensus Update**
- Next block production attempts round/term transition
- Calls `GetMinersCount()` â†’ `GetAutoIncreasedMinersCount()`
- Executes division: `.Div(State.MinerIncreaseInterval.Value)`

**Expected Result:**
Normal consensus processing with valid miner count calculation

**Actual Result:**
- **If set to 0:** `DivideByZeroException` thrown, consensus processing fails, blockchain stuck
- **If set to negative:** Negative miner count increase calculated, miner set artificially reduced

**Success Condition:**
System accepts the invalid value and either crashes (zero) or produces incorrect calculations (negative), demonstrating the validation failure and its operational impact.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L36-42)
```csharp
        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MaximumMinersCountController.Value = defaultAuthority;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L59-60)
```csharp
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L61-61)
```csharp
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L92-94)
```csharp
        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L40-40)
```csharp
    public Int64State MinerIncreaseInterval { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L31-31)
```csharp
        State.MinerIncreaseInterval.Value = input.MinerIncreaseInterval;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L388-390)
```csharp
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L128-128)
```csharp
                var minersCount = GetMinersCount(nextRound);
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L50-51)
```csharp
        Should.Throw<DivideByZeroException>(() => { number1.Div(0); });
        Should.Throw<DivideByZeroException>(() => { number2.Div(0); });
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L54-54)
```csharp
        number2.Div(-2).ShouldBe(-3L);
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L133-146)
```csharp
        var newMinerIncreaseInterval = minerIncreaseInterval.Value - 1;
        await ParliamentReachAnAgreementAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = newMinerIncreaseInterval
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
        minerIncreaseInterval.Value.ShouldBe(newMinerIncreaseInterval);
```
