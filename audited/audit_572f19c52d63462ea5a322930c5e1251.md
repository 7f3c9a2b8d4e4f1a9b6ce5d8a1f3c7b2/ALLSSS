# Audit Report

## Title
Missing Authorization Check in ContributeProfits Allows Unauthorized Profit Contributions and Forced Auto-Distributions

## Summary
The `ContributeProfits()` function in both TokenHolderContract and ProfitContract lacks authorization validation, allowing any user to contribute profits to any scheme without the scheme manager's permission. When combined with the `AutoDistributeThreshold` mechanism, this enables attackers to force premature profit distributions, disrupting the scheme manager's intended distribution schedule.

## Finding Description

The vulnerability exists at two layers:

**TokenHolderContract Layer:**
The `ContributeProfits()` function calls `GetValidScheme(input.SchemeManager)` which only validates that the scheme exists but does not verify that `Context.Sender` is authorized to contribute. [1](#0-0) 

This is inconsistent with other scheme management methods like `AddBeneficiary()` which properly validate authorization by calling `GetValidScheme(Context.Sender)`, ensuring only the scheme manager can modify the scheme: [2](#0-1) 

The `GetValidScheme()` helper only asserts the scheme exists, with no authorization verification: [3](#0-2) 

**ProfitContract Layer:**
The underlying `ProfitContract.ContributeProfits()` also lacks authorization checks, only validating that the scheme exists: [4](#0-3) 

Compare this to `DistributeProfits()` which has proper authorization: [5](#0-4) 

**Auto-Distribution Bypass:**
When a scheme has `AutoDistributeThreshold` configured, the `RegisterForProfits()` function automatically triggers profit distribution if the virtual address balance meets the threshold: [6](#0-5) 

The auto-distribution calls `State.ProfitContract.DistributeProfits.Send()` directly. Since this call originates from the TokenHolder contract, the `Context.Sender` in the Profit contract is the TokenHolder contract address, which passes the authorization check. This allows any user to force distribution by:
1. Contributing profits via `ContributeProfits()` to push balance over threshold
2. Calling `RegisterForProfits()` to trigger auto-distribution
3. Bypassing the scheme manager's control over distribution timing

## Impact Explanation

**Authorization Invariant Violation**: The security model assumes that only scheme managers have control over when profits are contributed and distributed. This vulnerability breaks that invariant, allowing unauthorized users to inject profits and trigger distributions.

**Loss of Scheme Manager Control**: While `DistributeProfits()` itself requires authorization, the auto-distribution mechanism in `RegisterForProfits()` bypasses this when the threshold is reached. The scheme manager loses control over:
- When profits are contributed to their scheme
- When distributions occur (if AutoDistributeThreshold is configured)
- The operational schedule for profit management

**Operational Disruption**: Although the attacker must spend real tokens to contribute profits, they can disrupt the scheme manager's intended distribution schedule at relatively low cost (just enough to push over the threshold). This affects:
- Schemes relying on AutoDistributeThreshold for automated management
- Time-sensitive distribution schedules
- Operational planning and coordination

**Severity Justification**: Medium severity - this vulnerability does not directly steal funds or corrupt beneficiary shares, but it violates critical authorization controls and allows operational disruption of profit distribution schedules. The impact is limited by requiring the attacker to spend real tokens, but the authorization bypass itself is a significant security flaw.

## Likelihood Explanation

**Reachable Entry Point**: `ContributeProfits()` is a public method with no access restrictions: [7](#0-6) 

**Minimal Attacker Requirements**:
- Tokens of the target symbol
- Standard token approval for TokenHolder contract
- Knowledge of the scheme manager address (publicly available on-chain)

**Straightforward Execution**:
1. Identify a scheme with AutoDistributeThreshold configured
2. Calculate contribution amount needed to reach threshold
3. Approve TokenHolder contract for token transfer
4. Call `ContributeProfits()` with scheme manager address
5. Call `RegisterForProfits()` to trigger auto-distribution

**Test Coverage Gap**: The codebase has authorization tests for `DistributeProfits_Without_Authority_Test` but no corresponding test for `ContributeProfits` authorization validation: [8](#0-7) 

This gap confirms the missing security control was not validated during testing.

## Recommendation

Add authorization checks to `ContributeProfits()` in both TokenHolderContract and ProfitContract to ensure only the scheme manager can contribute profits:

**TokenHolderContract Fix:**
```csharp
public override Empty ContributeProfits(ContributeProfitsInput input)
{
    var scheme = GetValidScheme(input.SchemeManager);
    // Add authorization check
    Assert(Context.Sender == input.SchemeManager, "Only scheme manager can contribute profits.");
    
    if (State.TokenContract.Value == null)
        State.TokenContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
    // ... rest of the function
}
```

**ProfitContract Fix:**
```csharp
public override Empty ContributeProfits(ContributeProfitsInput input)
{
    if (State.TokenContract.Value == null)
        State.TokenContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
    AssertTokenExists(input.Symbol);
    
    var scheme = State.SchemeInfos[input.SchemeId];
    if (scheme == null)
    {
        throw new AssertionException("Scheme not found.");
    }
    
    // Add authorization check
    Assert(Context.Sender == scheme.Manager || 
           Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
           "Only scheme manager or token holder contract can contribute profits.");
    
    // ... rest of the function
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ContributeProfits_Without_Authority_Should_Fail()
{
    // Scheme manager creates a scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        AutoDistributeThreshold = { {"ELF", 10000} }
    });
    
    // Attacker (unauthorized user) attempts to contribute profits
    var attackerStub = GetTester<TokenHolderContractImplContainer.TokenHolderContractImplStub>(
        TokenHolderContractAddress, 
        UserKeyPairs.First());
    
    var result = await attackerStub.ContributeProfits.SendWithExceptionAsync(
        new ContributeProfitsInput
        {
            SchemeManager = Starter, // Target scheme manager
            Symbol = "ELF",
            Amount = 10000 // Enough to trigger AutoDistributeThreshold
        });
    
    // This should fail but currently succeeds - demonstrating the vulnerability
    result.TransactionResult.Error.ShouldContain("Only scheme manager can contribute profits");
}
```

## Notes

This vulnerability specifically affects the authorization model of the Profit/TokenHolder scheme system. While the attacker must spend real tokens to exploit this vulnerability, the authorization bypass itself violates the fundamental security principle that only scheme managers should control their schemes' operations. The combination with AutoDistributeThreshold amplifies the impact by allowing forced distributions, but even without auto-distribution, the ability to inject unauthorized profits into a scheme is a security concern that should be addressed.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-39)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L100-102)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L178-206)
```csharp
        // Check auto-distribute threshold.
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-284)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L417-428)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        if (input.AmountsMap.Any())
            Assert(input.AmountsMap.All(a => !string.IsNullOrEmpty(a.Key)), "Invalid token symbol.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-666)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }

        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null)
        {
            throw new AssertionException("Scheme not found.");
        }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L287-303)
```csharp
    [Fact]
    public async Task DistributeProfits_Without_Authority_Test()
    {
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "Test"
        });
        var senderWithoutAuthority =
            GetTester<TokenHolderContractImplContainer.TokenHolderContractImplStub>(TokenHolderContractAddress,
                UserKeyPairs.First());
        var distributeRet = await senderWithoutAuthority.DistributeProfits.SendWithExceptionAsync(
            new DistributeProfitsInput
            {
                SchemeManager = Starter
            });
        distributeRet.TransactionResult.Error.ShouldContain("No permission to distribute profits");
    }
```
