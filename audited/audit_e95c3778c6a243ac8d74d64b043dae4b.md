# Audit Report

## Title
Scheme Overwriting Causes Permanent Token Lock Due to Symbol Mismatch

## Summary
When a manager calls `CreateScheme` multiple times, the new scheme overwrites the previous one in the TokenHolder contract state, but existing user lock records persist with the old scheme's token symbol. Users cannot withdraw their locked tokens because the `Withdraw` function queries locked amounts using the new scheme's symbol with the old lock ID, returning zero balance and leaving original tokens permanently locked.

## Finding Description

The `CreateScheme` method directly overwrites the scheme stored at `State.TokenHolderProfitSchemes[Context.Sender]` without any validation to prevent duplicate calls or check for existing registrations. [1](#0-0) 

Each call to `CreateScheme` creates a new scheme in the underlying Profit contract because the scheme ID generation uses `createdSchemeCount` as the seed when no token is specified. [2](#0-1)  This means the Profit contract's "Already exists" check does not prevent multiple scheme creation. [3](#0-2) 

The lock ID is generated deterministically based only on the manager address and user address, making it identical across different schemes with the same manager. [4](#0-3) 

During registration, tokens are locked with the scheme's symbol at that time. [5](#0-4)  The lock ID mapping persists at `State.LockIds[manager][user]`. [6](#0-5) 

When `Withdraw` is called, it retrieves the current scheme (which may have different parameters including a different symbol), then attempts to get the locked amount using the current scheme's symbol with the old lock ID. [7](#0-6) 

The `GetLockedAmount` method queries the balance for a specific symbol at the virtual address derived from the lock ID. [8](#0-7)  Since the tokens were locked under a different symbol (e.g., "ELF"), but the query uses the new symbol (e.g., "USDT"), it returns zero.

The unlock operation then unlocks zero tokens with the new symbol, leaving the original tokens locked forever at the virtual address. [9](#0-8)  The lock ID is removed from state, [10](#0-9)  but this does not help recover the original tokens.

## Impact Explanation

**HIGH Severity** - This vulnerability results in permanent, unrecoverable loss of user funds through normal contract operations:

1. **Direct Fund Loss**: Users lose access to all their locked tokens permanently. The tokens remain locked at a virtual address but cannot be accessed through any TokenHolder contract method.

2. **Multiple Victims**: All users who registered for the original scheme before it was overwritten are affected simultaneously.

3. **No Recovery Path**: While the lock ID is removed from state after calling `Withdraw`, the original tokens remain at the virtual address with the old symbol. There is no method in the TokenHolder contract to recover these funds. Users would need deep technical knowledge to directly interact with the MultiToken contract, compute the deterministic lock ID, and know the original token symbol - information that is not readily available to them.

4. **Large Amounts at Risk**: Token holder schemes are typically used for staking and profit distribution, meaning substantial amounts can be locked.

## Likelihood Explanation

**MEDIUM Likelihood** - The vulnerability can be triggered through straightforward operations:

1. **Reachable Entry Point**: The `CreateScheme` method is publicly accessible to any address. [11](#0-10) 

2. **Simple Preconditions**: The manager only needs to call `CreateScheme` twice - no complex state manipulation required.

3. **Realistic Scenarios**:
   - **Accidental**: A manager might call `CreateScheme` again thinking it will update scheme parameters rather than understanding it overwrites the entire scheme
   - **Malicious**: A manager could intentionally lock user funds to prevent withdrawals, gaining time advantage in profit distribution

4. **Low Complexity**: Requires only two standard contract calls with no special privileges beyond being the scheme creator.

**Execution Example**:
1. Manager calls `CreateScheme(Symbol="ELF", MinimumLockMinutes=1000)`
2. User calls `RegisterForProfits` and locks 10,000 ELF tokens
3. Manager calls `CreateScheme(Symbol="USDT", MinimumLockMinutes=10)` 
4. User calls `Withdraw` but receives 0 tokens, original 10,000 ELF remains permanently locked

## Recommendation

Add validation to the `CreateScheme` method to prevent overwriting an existing scheme:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add this validation check
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
           "Scheme already exists for this manager.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, if scheme updates are intended functionality, implement a separate `UpdateScheme` method that:
1. Validates no users are currently registered (or handle migration properly)
2. Only updates specific parameters without changing the token symbol
3. Maintains backward compatibility with existing locks

## Proof of Concept

```csharp
[Fact]
public async Task SchemeOverwrite_CausesPermanentTokenLock()
{
    // Setup: Manager creates first scheme with ELF
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1000
    });
    
    // User registers and locks 10,000 ELF
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = ManagerAddress,
        Amount = 10000_00000000
    });
    
    // Verify user has 10,000 ELF locked
    var userBalanceBefore = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserAddress,
        Symbol = "ELF"
    });
    
    // Manager overwrites scheme with USDT
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "USDT",
        MinimumLockMinutes = 10
    });
    
    // Advance time past lock period
    BlockTimeProvider.SetBlockTime(BlockTimeProvider.GetBlockTime().AddMinutes(1001));
    
    // User attempts to withdraw
    await TokenHolderContractStub.Withdraw.SendAsync(ManagerAddress);
    
    // Verify: User's ELF balance didn't increase (tokens still locked)
    var userBalanceAfter = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserAddress,
        Symbol = "ELF"
    });
    
    // Assert: Balance unchanged - tokens permanently locked
    userBalanceAfter.Balance.ShouldBe(userBalanceBefore.Balance);
    
    // The 10,000 ELF remains locked at the virtual address with no recovery path
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-14)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L157-158)
```csharp
        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-165)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L166-166)
```csharp
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L213-225)
```csharp
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L230-236)
```csharp
        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L238-238)
```csharp
        State.LockIds[input].Remove(Context.Sender);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L59-60)
```csharp
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
        State.SchemeInfos[schemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-115)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
```
