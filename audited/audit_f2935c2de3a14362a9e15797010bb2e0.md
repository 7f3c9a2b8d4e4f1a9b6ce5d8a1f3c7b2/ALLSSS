### Title
ImpliedIrreversibleBlockHeight Validation Bypassed Due to Premature State Recovery

### Summary
The validation that prevents miners from decreasing their `ImpliedIrreversibleBlockHeight` is completely ineffective because `RecoverFromUpdateValue` overwrites the original baseRound value before the validation check occurs. This allows malicious miners to arbitrarily decrease their implied LIB height, breaking the monotonicity invariant and potentially manipulating the Last Irreversible Block (LIB) calculation used for chain finality.

### Finding Description

The vulnerability exists in the consensus validation flow for `UpdateValue` behavior. The validation is intended to prevent miners from reporting a lower `ImpliedIrreversibleBlockHeight` than previously recorded, but the implementation is fundamentally broken.

**Root Cause:**

In the validation flow, `RecoverFromUpdateValue` is called on the `baseRound` object BEFORE the `LibInformationValidationProvider` validation executes: [1](#0-0) 

The `RecoverFromUpdateValue` method overwrites the original baseRound's `ImpliedIrreversibleBlockHeight` with the provided value: [2](#0-1) 

After this overwrite, the validation check compares the modified baseRound against the providedRound: [3](#0-2) 

Since both values are now identical (both contain the provided value), the condition `baseRound.ImpliedIrreversibleBlockHeight > providedRound.ImpliedIrreversibleBlockHeight` is never true, causing the validation to always pass even when the provided value has decreased.

**Execution Path:**

1. Miner's node generates `UpdateValueInput` with `ImpliedIrreversibleBlockHeight` value (can be manipulated by modifying the node): [4](#0-3) 

2. During validation, `baseRound` is loaded from state with the ORIGINAL stored value: [5](#0-4) 

3. `RecoverFromUpdateValue` destroys this original value before validation

4. If validation passes, the malicious lower value is persisted to state: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Breach:**

The `ImpliedIrreversibleBlockHeight` is used to calculate the Last Irreversible Block height, which determines chain finality. The LIB calculation takes the value at the 1/3 threshold from sorted implied heights: [7](#0-6) 

**Concrete Harm:**

1. **Monotonicity Violation**: The critical invariant that `ImpliedIrreversibleBlockHeight` should never decrease is broken, undermining the finality guarantee

2. **LIB Manipulation**: A single malicious miner can lower their implied LIB height from 1000 to 500, directly affecting the consensus calculation. If multiple colluding miners (>1/3 of the miner set) exploit this, they can significantly lower the calculated LIB height

3. **Chain Finality Compromise**: Incorrect LIB values can cause:
   - Blocks that should be irreversible to be treated as reversible
   - Delayed finality confirmation affecting cross-chain operations and user confidence
   - Potential for chain reorganizations beyond what should be allowed

**Affected Parties:**
- The entire blockchain network's finality guarantees
- Cross-chain operations that depend on LIB heights
- Any protocol logic relying on irreversible block confirmation

**Severity Justification:** High - This directly undermines consensus integrity, a critical invariant for blockchain security. While requiring miner participation, miners are not fully trusted parties in a decentralized consensus system.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires being an active miner in the consensus round
- Requires modifying the miner node software to generate `UpdateValueInput` with a decreased `ImpliedIrreversibleBlockHeight`
- No additional privileges beyond being a miner are needed

**Attack Complexity:** Low
- The exploit is straightforward: modify node to output lower values
- No timing constraints or race conditions
- No need to coordinate with other parties (though coordination amplifies impact)

**Feasibility Conditions:**
- Attacker must be an elected miner (achievable through staking/election process)
- Standard block production flow is exploited
- No economic disincentive prevents this attack

**Detection/Operational Constraints:**
- Difficult to detect as the validation incorrectly allows the behavior
- No automated monitoring would flag this as the contract accepts it as valid
- Could persist undetected until manual audit or unusual LIB behavior is noticed

**Probability:** High - Any compromised or malicious miner node can execute this. Given the critical nature of consensus, even a single malicious miner breaking invariants is unacceptable.

### Recommendation

**Immediate Fix:**

Store the original `baseRound.ImpliedIrreversibleBlockHeight` value BEFORE calling `RecoverFromUpdateValue`, then use this original value in the validation:

```csharp
// In AEDPoSContract_Validation.cs ValidateBeforeExecution method
if (!TryToGetCurrentRoundInformation(out var baseRound))
    return new ValidationResult { Success = false, Message = "Failed to get current round information." };

// Store original value before recovery
var originalBaseRound = baseRound.Clone(); // or create a separate field to store original implied heights

if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

var validationContext = new ConsensusValidationContext
{
    BaseRound = baseRound,
    OriginalBaseRound = originalBaseRound, // Pass original for validation
    ...
};
```

Then modify `LibInformationValidationProvider` to use the original value:

```csharp
// Use OriginalBaseRound instead of BaseRound for the comparison
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
    validationContext.OriginalBaseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
```

**Invariant Checks to Add:**
- Add explicit monotonicity check: `assert(newValue >= oldValue)` for `ImpliedIrreversibleBlockHeight`
- Add event logging when implied LIB values are updated for monitoring

**Test Cases:**
1. Test that validation FAILS when miner provides decreased `ImpliedIrreversibleBlockHeight`
2. Test that validation PASSES when miner provides increased or equal value
3. Test LIB calculation with manipulated values to ensure correct rejection

### Proof of Concept

**Initial State:**
- Miner A has `ImpliedIrreversibleBlockHeight = 1000` in state
- Current block height: 1050
- Miner A is scheduled to produce the next block

**Attack Steps:**

1. Malicious Miner A modifies their node's `ExtractInformationToUpdateConsensus` to output:
   ```
   ImpliedIrreversibleBlockHeight = 500  // Decreased from 1000
   ```

2. Miner A produces block with `UpdateValue` behavior containing the malicious value

3. During `ValidateBeforeExecution`:
   - `baseRound` loaded with `ImpliedIrreversibleBlockHeight = 1000` (from state)
   - `RecoverFromUpdateValue` called → overwrites to 500
   - `LibInformationValidationProvider` checks: `500 > 500?` → FALSE → validation PASSES
   
4. Block is accepted and `ProcessUpdateValue` executes: [8](#0-7) 

5. State is updated: `minerInRound.ImpliedIrreversibleBlockHeight = 500`

**Expected Result:** Validation should FAIL because 1000 > 500 (decrease not allowed)

**Actual Result:** Validation PASSES and state is updated to the decreased value (500)

**Success Condition:** The malicious miner successfully decreased their `ImpliedIrreversibleBlockHeight` from 1000 to 500, breaking the monotonicity invariant and potentially lowering the calculated LIB in subsequent rounds.

### Notes

The vulnerability fundamentally stems from the architectural decision to "recover" provided values into the baseRound object before validation. While this may be convenient for other validations, it destroys the original values needed for monotonicity checks. The fix requires preserving original state values separately for comparison during validation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L19-19)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L48-48)
```csharp
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```
