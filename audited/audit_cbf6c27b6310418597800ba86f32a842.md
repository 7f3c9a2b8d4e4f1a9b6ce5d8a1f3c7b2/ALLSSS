### Title
Premature Round Termination Allows Miner Exclusion and Consensus Liveness Violation

### Summary
Any miner whose time slot has passed can generate and execute a NextRound transaction before the designated extra block mining time, terminating the round prematurely and preventing subsequent miners from producing their blocks. This violates the consensus protocol's liveness guarantees and enables censorship attacks against specific miners.

### Finding Description

The vulnerability exists in the consensus command generation and validation flow:

**Root Cause - Command Generation:** [1](#0-0) 

When a miner has already produced their block (OutValue != null) and their time slot has passed (IsTimeSlotPassed returns true), the system returns NextRound/NextTerm behavior. The time slot check only verifies if the miner's own slot has ended: [2](#0-1) 

This means any miner whose slot ended can trigger round termination, regardless of whether later miners have had their opportunity to produce blocks.

**Missing Validation - No Extra Block Time Check:** [3](#0-2) 

When validating NextRound transactions (different RoundId), the validation only checks that the NEW round's time slots are properly arranged. It does not validate that the current block time has reached the extra block mining time.

**Extra Block Time Definition:** [4](#0-3) 

The extra block mining time is calculated as the last miner's expected time plus one mining interval. This represents when the round should normally terminate, but there's no enforcement of this timing.

**Validation Providers for NextRound:** [5](#0-4) 

Neither NextRoundMiningOrderValidationProvider nor RoundTerminateValidationProvider checks:
1. Whether current time >= extra block mining time
2. Whether all miners have had their time slots
3. Whether the sender is the designated extra block producer [6](#0-5) 

The validation only verifies round number increments correctly and that InValues are null in the next round.

### Impact Explanation

**Consensus Integrity Impact:**
- Miners scheduled for later time slots are excluded from block production
- Violates the fundamental liveness guarantee that all active miners get their turn
- Breaks the time-slot fairness mechanism of the AEDPoS protocol

**Censorship Attack Vector:**
- A malicious miner can systematically exclude specific miners by terminating rounds early
- Can target miners with later time slots repeatedly across multiple rounds
- Reduces effective validator set without formal removal

**Network Security Degradation:**
- Fewer blocks produced per round means less network security
- Reduces blockchain throughput and block finalization rate
- Concentrated block production increases centralization risk

**Reward Distribution Impact:**
- Excluded miners lose block rewards and transaction fees for skipped slots
- Unfair economic advantage to miners with earlier time slots
- Could drive honest miners to abandon the network

Severity: **HIGH** - Directly impacts consensus correctness and network liveness.

### Likelihood Explanation

**Attack Feasibility:**
- Any miner can exploit this - no special privileges required beyond being in the active miner set
- Attack complexity is LOW - simply submit NextRound transaction after your time slot ends
- No economic cost beyond standard transaction fees

**Preconditions:**
- Attacker must be in the current round's miner list (realistic - normal miner)
- Attacker must have already produced their block in the current round
- Attacker's time slot must have passed
- At least one miner with a later time slot must not have produced their block yet

**Detection Difficulty:**
- Attack is difficult to distinguish from legitimate NextRound transactions
- Network observers might attribute early termination to slow miners rather than malicious behavior
- No obvious on-chain evidence of malicious intent

**Operational Constraints:**
- Network conditions (latency, offline miners) naturally create opportunities
- Miners with middle-to-late time slots have multiple targets (all later miners)
- Can be executed repeatedly across many rounds

**Probability: HIGH** - The conditions for exploitation occur naturally during normal network operation whenever any miner is slow or offline.

### Recommendation

**Primary Fix - Add Extra Block Time Validation:**

Add a new validation provider that enforces the extra block mining time for NextRound and NextTerm transactions:

```csharp
public class ExtraBlockTimingValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        
        // Only apply to round termination behaviors
        if (extraData.Behaviour != AElfConsensusBehaviour.NextRound && 
            extraData.Behaviour != AElfConsensusBehaviour.NextTerm)
            return new ValidationResult { Success = true };
        
        var baseRound = validationContext.BaseRound;
        var extraBlockMiningTime = baseRound.GetExtraBlockMiningTime();
        
        // Current block time must have reached or exceeded extra block mining time
        if (validationContext.ExtraData.Round.GetRoundStartTime() < extraBlockMiningTime)
        {
            return new ValidationResult 
            { 
                Message = $"Cannot terminate round before extra block mining time. " +
                         $"Extra block time: {extraBlockMiningTime}, " +
                         $"Current time: {validationContext.ExtraData.Round.GetRoundStartTime()}"
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Register this provider in ValidateBeforeExecution: [7](#0-6) 

Add the new provider for NextRound and NextTerm cases.

**Secondary Fix - Restrict NextRound Command Generation:**

Modify ConsensusBehaviourProviderBase to only return NextRound/NextTerm when the current time has reached the extra block mining time: [8](#0-7) 

Add a check before line 82 that compares current time against GetExtraBlockMiningTime().

**Test Cases:**
1. Verify early NextRound transaction is rejected when current time < extra block time
2. Verify NextRound succeeds when current time >= extra block time
3. Verify all miners in a round get their time slots before round terminates
4. Verify behavior with offline/slow miners - round terminates only after extra block time

### Proof of Concept

**Initial State:**
- 5 miners in current round: A, B, C, D, E
- Mining interval: 4000ms
- Time slots:
  - Miner A: T0 (order 1)
  - Miner B: T0 + 4000ms (order 2)
  - Miner C: T0 + 8000ms (order 3)
  - Miner D: T0 + 12000ms (order 4)
  - Miner E: T0 + 16000ms (order 5)
- Extra block mining time: T0 + 20000ms

**Attack Steps:**

1. **T0**: Miner A produces their block (UpdateValue transaction)
   - A's OutValue is set
   - Round continues normally

2. **T0 + 4000ms**: Miner B produces their block (UpdateValue transaction)
   - B's OutValue is set
   - Round continues normally

3. **T0 + 8000ms**: Miner C is offline/slow, does not produce block

4. **T0 + 8001ms**: Miner B (malicious) calls GetConsensusCommand
   - B has OutValue (already mined) ✓
   - B's time slot passed: T0 + 8000ms > T0 + 4000ms + 4000ms ✓
   - System returns NextRound behavior
   - B generates NextRound transaction with next round information

5. **T0 + 8001ms**: Miner B submits NextRound transaction
   - Validation checks:
     - MiningPermissionValidationProvider: B is in miner list ✓
     - TimeSlotValidationProvider: New round's time slots are valid ✓
     - NextRoundMiningOrderValidationProvider: Mining order is valid ✓
     - RoundTerminateValidationProvider: Round number increments correctly ✓
     - **Missing check: Current time (T0 + 8001ms) < Extra block time (T0 + 20000ms) ✗**
   - Transaction executes successfully

6. **Result**: Round terminates at T0 + 8001ms
   - Miners C, D, and E never got their time slots
   - 3 out of 5 miners excluded from block production
   - Round terminated 11,999ms earlier than intended

**Expected vs Actual:**
- **Expected**: Round terminates at T0 + 20000ms after all miners have had their opportunity
- **Actual**: Round terminates at T0 + 8001ms, excluding 60% of miners

**Success Condition:** NextRound transaction is accepted and executed before the extra block mining time, with subsequent miners unable to produce blocks in the terminated round.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L88-90)
```csharp
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L117-122)
```csharp
    public Timestamp GetExtraBlockMiningTime()
    {
        return RealTimeMinersInformation.OrderBy(m => m.Value.Order).Last().Value
            .ExpectedMiningTime
            .AddMilliseconds(GetMiningInterval());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```
