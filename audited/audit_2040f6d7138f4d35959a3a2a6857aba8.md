### Title
Missing Validation in BlockchainMiningStatusEvaluator Allows Invalid LIB Round Number Leading to Incorrect Consensus Status Evaluation

### Summary
The `BlockchainMiningStatusEvaluator` constructor does not validate that `currentConfirmedIrreversibleBlockRoundNumber <= currentRoundNumber`, allowing a malicious miner to inject invalid round data where the Last Irreversible Block (LIB) round number exceeds the current round number. This causes the blockchain to incorrectly evaluate its mining status as Normal when it should be Abnormal or Severe, preventing proper throttling mechanisms from engaging during LIB lag conditions.

### Finding Description

The `BlockchainMiningStatusEvaluator` constructor accepts parameters without validating their logical relationship: [1](#0-0) 

The constructor should enforce that `currentConfirmedIrreversibleBlockRoundNumber <= currentRoundNumber` because by definition, the Last Irreversible Block cannot be in a future round. However, no such validation exists.

When a miner submits a `NextRound` transaction, the validation logic only checks that LIB values do not decrease from the base round, not the invariant within the provided round itself: [2](#0-1) 

The `RoundTerminateValidationProvider` only validates that the round number increments by exactly 1: [3](#0-2) 

No validator checks the relationship between `ConfirmedIrreversibleBlockRoundNumber` and `RoundNumber` within the submitted round data. When `ProcessNextRound` executes, it accepts the invalid round data without additional validation: [4](#0-3) 

Subsequently, when `GetMaximumBlocksCount` retrieves this corrupted round data and creates a `BlockchainMiningStatusEvaluator` with invalid parameters: [5](#0-4) 

The `Deconstruct` method evaluates status incorrectly. When `_libRoundNumber > _currentRoundNumber`, both conditions fail: [6](#0-5) 

This results in a `Normal` status even when the blockchain should be in `Abnormal` or `Severe` state, preventing proper block production throttling.

### Impact Explanation

**Consensus Integrity Compromise**: The blockchain's self-regulation mechanism for handling LIB lag is disabled. When the actual LIB is falling behind but the attacker inflates `ConfirmedIrreversibleBlockRoundNumber` to a value greater than `currentRoundNumber`:

1. The blockchain incorrectly evaluates its status as `Normal`
2. Miners continue producing maximum tiny blocks (`AEDPoSContractConstants.MaximumTinyBlocksCount`) instead of reducing production
3. The `Abnormal` state logic that reduces block count based on active miners is bypassed: [7](#0-6) 

4. The `Severe` state that limits production to 1 block and triggers `IrreversibleBlockHeightUnacceptable` event is bypassed: [8](#0-7) 

This prevents the blockchain from self-correcting during consensus stress, potentially worsening LIB lag and threatening chain finality. The corrupted state persists across subsequent rounds since new rounds copy these values: [9](#0-8) 

### Likelihood Explanation

**Likelihood: Medium**

**Attacker Prerequisites:**
- Must be a current miner with mining permission
- Must be in the extra block producer position to submit `NextRound` transactions
- These are privileged but regularly rotating positions

**Attack Complexity: Low**

The attack is straightforward:
1. Intercept the consensus transaction generation flow at: [10](#0-9) 

2. Modify the `NextRoundInput` to set `ConfirmedIrreversibleBlockRoundNumber` to a value greater than `RoundNumber`
3. Submit the modified transaction - it will pass all validation checks

**Detection Difficulty: High**

The invalid state is stored persistently and no alerts are triggered. The blockchain continues operating with incorrect status evaluation until external monitoring detects anomalous behavior.

**Economic Rationality:**
A malicious miner could use this to prevent the blockchain from throttling during actual consensus issues, potentially to exploit timing-dependent vulnerabilities or maintain higher block rewards while the chain is under stress.

### Recommendation

**1. Add validation in the `BlockchainMiningStatusEvaluator` constructor:**

```csharp
public BlockchainMiningStatusEvaluator(long currentConfirmedIrreversibleBlockRoundNumber,
    long currentRoundNumber, int maximumTinyBlocksCount)
{
    Assert(currentConfirmedIrreversibleBlockRoundNumber <= currentRoundNumber,
        "Confirmed irreversible block round number cannot exceed current round number.");
    _libRoundNumber = currentConfirmedIrreversibleBlockRoundNumber;
    _currentRoundNumber = currentRoundNumber;
    _maximumTinyBlocksCount = maximumTinyBlocksCount;
}
```

**2. Add validation in `LibInformationValidationProvider` to check the invariant within the provided round:**

After line 21, add:
```csharp
if (providedRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.RoundNumber)
{
    validationResult.Message = "Confirmed irreversible block round number cannot exceed current round number.";
    return validationResult;
}
```

**3. Add test cases:**
- Test that `NextRoundInput` with `ConfirmedIrreversibleBlockRoundNumber > RoundNumber` is rejected
- Test that `BlockchainMiningStatusEvaluator` constructor rejects invalid parameter ordering
- Test that corrupted round data cannot persist across round transitions

### Proof of Concept

**Initial State:**
- Current round: `RoundNumber = 10`, `ConfirmedIrreversibleBlockRoundNumber = 8`
- Blockchain is actually experiencing LIB lag (should be in Abnormal state)

**Attack Steps:**

1. Malicious miner (as extra block producer) generates `NextRound` consensus command
2. Modifies the `NextRoundInput` before submission:
   - `RoundNumber = 11` (valid increment)
   - `ConfirmedIrreversibleBlockRoundNumber = 15` (invalid - exceeds RoundNumber)

3. Submits the transaction via: [11](#0-10) 

4. Validation passes:
   - `RoundTerminateValidationProvider`: `10 + 1 == 11` ✓
   - `LibInformationValidationProvider`: `8 <= 15` ✓ (only checks non-decreasing)

5. Invalid round is stored in state

**Actual Result:**
- Next call to `GetMaximumBlocksCount()` creates evaluator with `libRoundNumber=15`, `currentRoundNumber=11`
- Conditions evaluate: `15+2 < 11` = False, `11 >= 15+8` = False
- Status = `Normal` (incorrect)
- Returns `AEDPoSContractConstants.MaximumTinyBlocksCount` instead of reduced count

**Expected Result:**
- Validation should reject the transaction with error: "Confirmed irreversible block round number cannot exceed current round number"
- Blockchain should correctly evaluate as `Abnormal` or `Severe` state
- Block production should be throttled appropriately

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L24-36)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L42-54)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L106-112)
```csharp
        public BlockchainMiningStatusEvaluator(long currentConfirmedIrreversibleBlockRoundNumber,
            long currentRoundNumber, int maximumTinyBlocksCount)
        {
            _libRoundNumber = currentConfirmedIrreversibleBlockRoundNumber;
            _currentRoundNumber = currentRoundNumber;
            _maximumTinyBlocksCount = maximumTinyBlocksCount;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L119-129)
```csharp
        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-30)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L164-171)
```csharp
            case AElfConsensusBehaviour.NextRound:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextRound), NextRoundInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
