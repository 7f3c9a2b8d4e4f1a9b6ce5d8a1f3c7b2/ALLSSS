### Title
Conflict Resolution Blind Spot in ApplyNormalConsensusData Allows Duplicate Mining Orders

### Summary
The conflict resolution loop in `ApplyNormalConsensusData` contains a mathematical flaw in its modulo-based position search that creates a blind spot for position `minersCount`. When all mining positions are occupied and a conflict occurs at this position, the algorithm fails to reassign the conflicted miner, resulting in two miners having identical `FinalOrderOfNextRound` values. This causes both miners to be assigned the same `Order` in the next consensus round, breaking the core invariant that each miner must have a unique time slot.

### Finding Description

The vulnerability exists in the conflict resolution logic at [1](#0-0) 

**Root Cause:**

When a miner produces a block, their `supposedOrderOfNextRound` is calculated at [2](#0-1)  which produces values in range [1, minersCount]. If this conflicts with an existing miner's `FinalOrderOfNextRound`, the conflict resolution loop attempts to find a new position for the conflicted miner.

The loop iterates `i` from `supposedOrderOfNextRound + 1` to `minersCount * 2 - 1`, computing `maybeNewOrder` at [3](#0-2) 

**Mathematical Blind Spot:**

For `i > minersCount`, the formula `i % minersCount` produces:
- When minersCount = 5 and i ∈ [6, 9]: `i % 5` yields {1, 2, 3, 4}
- The value `minersCount` (5 in this case) is never produced because:
  - To get 5 from `i % 5`, we'd need `i % 5 = 0` (impossible) or `i = 5` (before loop starts)
  - The next `i` that equals minersCount is `i = 10`, but loop condition `i < minersCount * 2` stops at `i = 9`

**Failure Scenario:**

When all positions [1, minersCount] are occupied and `supposedOrderOfNextRound = minersCount`:
1. Loop starts at `i = minersCount + 1`
2. For `i` in range [minersCount+1, 2*minersCount-1], `maybeNewOrder ∈ [1, minersCount-1]`
3. Position `minersCount` is never rechecked
4. If it's the only free position (or would become free after reassignment), the loop fails to find it
5. The conflicted miner retains `FinalOrderOfNextRound = minersCount`
6. At [4](#0-3)  the current miner is also assigned `FinalOrderOfNextRound = minersCount`

**Why Existing Protections Fail:**

The validation at [5](#0-4)  calls `Distinct()` on `MinerInRound` objects, not on their `FinalOrderOfNextRound` values. This counts distinct miner objects, not distinct order values, so duplicate orders pass validation.

The `UpdateValueValidationProvider` at [6](#0-5)  only validates OutValue/Signature filling and PreviousInValue correctness, not order uniqueness.

### Impact Explanation

**Consensus Integrity Breakdown:**

When `GenerateNextRoundInformation` processes miners at [7](#0-6)  both miners with duplicate `FinalOrderOfNextRound` values are assigned the same `Order` and identical `ExpectedMiningTime` in the next round.

**Concrete Harm:**
1. **Time Slot Collision:** Two miners attempt to produce blocks at exactly the same time
2. **Fork Risk:** Both miners believe they have authority to mine, potentially creating competing blocks
3. **Round Progression Failure:** Time slot validation will reject at least one block, potentially both
4. **Consensus Deadlock:** The round may fail to progress if neither miner's block is accepted
5. **Chain Liveness Impact:** Extended mining delays or complete consensus halt until manual intervention

**Affected Parties:**
- All network participants experience consensus delays or failures
- Miners lose block rewards due to invalid time slots
- dApps and users experience transaction confirmation delays
- Network reputation and reliability damaged

**Severity:** High - Violates critical invariant "miner schedule integrity" and causes "invalid round transitions"

### Likelihood Explanation

**Reachable Entry Point:**

The function is called from [8](#0-7)  during normal block production when a miner's node generates consensus extra data.

**Feasible Preconditions:**
1. All miners in the current round have produced blocks (common during healthy consensus)
2. All positions [1, minersCount] have assigned `FinalOrderOfNextRound` values
3. A miner's signature hash produces `supposedOrderOfNextRound = minersCount` (1/minersCount probability)
4. Another miner already occupies position `minersCount`

**Execution Practicality:**

The condition occurs naturally without attacker intervention:
- During active consensus rounds, all miners typically produce blocks
- Signature-derived order calculation is deterministic but unpredictable
- With minersCount typically 17-23 in AEDPoS, probability of hitting position `minersCount` is ~4-6% per block
- Over hundreds of blocks per day, occurrence is statistically inevitable

**Detection Constraints:**

The duplicate order values are embedded in consensus state and validated only superficially. The issue manifests as timing conflicts in the next round, making root cause diagnosis difficult.

**Probability Assessment:** Medium-High probability of occurrence during normal network operation over time. No attacker control needed; purely dependent on natural signature distribution and full miner participation.

### Recommendation

**Immediate Fix:**

Modify the conflict resolution loop at [9](#0-8)  to correctly handle all positions:

```csharp
for (var i = 1; i <= minersCount; i++)
{
    var candidateOrder = (supposedOrderOfNextRound + i - 1) % minersCount + 1;
    if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != candidateOrder))
    {
        RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound = candidateOrder;
        break;
    }
}
```

This formula ensures all positions [1, minersCount] are checked exactly once by wrapping correctly.

**Validation Enhancement:**

Add duplicate detection in `NextRoundMiningOrderValidationProvider` at [5](#0-4) :

```csharp
var orders = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
if (orders.Count != orders.Distinct().Count())
{
    validationResult.Message = "Duplicate FinalOrderOfNextRound values detected.";
    return validationResult;
}
```

**Test Cases:**

1. All miners mined, conflict at position minersCount
2. All miners mined, conflict at position 1
3. Partial miners mined, conflict requiring wrap-around
4. Verify no duplicates in generated next round

### Proof of Concept

**Initial State:**
- minersCount = 5
- All 5 miners have produced blocks
- Current FinalOrderOfNextRound assignments: {A:1, B:2, C:3, D:4, E:5}

**Attack Sequence:**

1. Miner F (one of A-E) produces a new block
2. Signature calculation at [10](#0-9)  produces signature with `ToInt64()` value that yields `GetAbsModulus(sigNum, 5) + 1 = 5`
3. Conflict detected: existing miner already has FinalOrderOfNextRound = 5
4. Conflict resolution loop executes:
   - i=6: maybeNewOrder = 6%5 = 1 (occupied)
   - i=7: maybeNewOrder = 7%5 = 2 (occupied)
   - i=8: maybeNewOrder = 8%5 = 3 (occupied)
   - i=9: maybeNewOrder = 9%5 = 4 (occupied)
   - Loop exits without reassignment
5. Both conflicted miner and new miner have FinalOrderOfNextRound = 5

**Expected Result:**
Conflicted miner should be reassigned to a free position; only one miner should have FinalOrderOfNextRound = 5

**Actual Result:**
Two miners have FinalOrderOfNextRound = 5; validation passes; next round generation at [7](#0-6)  assigns both miners Order = 5 with identical ExpectedMiningTime

**Success Condition:**
Observe duplicate Order values in next round's RealTimeMinersInformation, causing time slot collision when both miners attempt to produce blocks simultaneously.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L28-40)
```csharp
        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L44-44)
```csharp
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```
