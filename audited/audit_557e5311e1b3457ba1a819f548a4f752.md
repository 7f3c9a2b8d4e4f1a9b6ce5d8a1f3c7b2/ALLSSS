### Title
Ineffective ImpliedIrreversibleBlockHeight Validation Allows Miners to Manipulate Last Irreversible Block (LIB) Calculation

### Summary
The `LibInformationValidationProvider` validation for `ImpliedIrreversibleBlockHeight` is fundamentally broken because the `baseRound` is modified by `RecoverFromUpdateValue()` before validation runs, causing the validation to compare the miner-provided value against itself. This allows miners to report arbitrary `ImpliedIrreversibleBlockHeight` values (including values lower than their previous reports or artificially inflated values) without any validation failure, enabling potential manipulation of the LIB consensus mechanism when more than 1/3 of miners collude.

### Finding Description

The vulnerability exists in the validation flow for `UpdateValue` consensus behavior: [1](#0-0) 

The `baseRound` object fetched from state is modified in-place by calling `RecoverFromUpdateValue()`, which copies the miner's provided `ImpliedIrreversibleBlockHeight` into the `baseRound`: [2](#0-1) 

This modified `baseRound` is then used in the validation context: [3](#0-2) 

When `LibInformationValidationProvider` attempts to validate at line 23-26, it compares `baseRound.ImpliedIrreversibleBlockHeight` (which now contains the miner-provided value) against `providedRound.ImpliedIrreversibleBlockHeight` (the same miner-provided value): [4](#0-3) 

This check evaluates to `providedValue > providedValue`, which is always false, so validation never fails. The original value from state is lost after the recovery step, making it impossible to detect if a miner decreased their `ImpliedIrreversibleBlockHeight` or provided an inflated value.

The provided value is then directly stored in state without any correctness validation: [5](#0-4) 

### Impact Explanation

**Consensus Integrity Impact:**
The `ImpliedIrreversibleBlockHeight` values from all miners are used to calculate the Last Irreversible Block (LIB) height using Byzantine fault-tolerant consensus: [6](#0-5) 

The calculation takes the value at index `(count-1)/3` from sorted heights, which is designed to tolerate up to 1/3 Byzantine nodes. However, if more than 1/3 of miners collude:

1. **Inflated LIB Attack**: Miners report artificially high `ImpliedIrreversibleBlockHeight` values, causing premature finalization of blocks that haven't achieved true consensus. This breaks the fundamental safety guarantee of the blockchain, potentially enabling:
   - Chain reorganization attacks after blocks are marked irreversible
   - Double-spend attacks if blocks are finalized before sufficient confirmation
   - Cross-chain security violations if premature LIB is used for cross-chain indexing

2. **Deflated LIB Attack**: Miners report artificially low values, delaying finalization and reducing system throughput, though this has less severe security implications.

The system's Byzantine fault tolerance provides no protection against this attack because the validation that should enforce honest reporting is completely ineffective.

### Likelihood Explanation

**Attack Feasibility:**
- **Entry Point**: Any miner can call `UpdateValue()` with arbitrary `ImpliedIrreversibleBlockHeight` values - this is a standard consensus operation.
- **Preconditions**: Attacker must be a current miner (part of the active miner set).
- **Execution**: 100% success rate - ANY value passes validation due to the broken validation logic.
- **Detection**: Difficult to detect as individual miner reports vary legitimately based on their chain view.

**Grinding Not Required:**
Contrary to the prompt's "grinding attack" characterization, miners don't need to try multiple values - ANY value they provide will pass validation. This is actually worse than a grinding attack because there's no computational cost or detection possibility through multiple attempts.

**Impact Severity by Scenario:**
- **Single Miner**: Limited impact due to `(count-1)/3` selection in sorted list - one outlier value doesn't significantly affect LIB.
- **Collusion of >1/3 Miners**: High impact - can arbitrarily manipulate LIB calculation with coordinated false reports.
- **Economic Rationality**: For a consortium chain with known validators, compromising >1/3 may be feasible. For public chains, this requires significant stake or validator compromise.

### Recommendation

**Immediate Fix:**
Modify the validation flow to preserve the original `baseRound` value before recovery for comparison purposes:

```csharp
// In AEDPoSContract_Validation.cs ValidateBeforeExecution method:

// Store original value before recovery
var originalBaseRound = State.Rounds[roundNumber].Clone(); // Need to implement Clone or deep copy

if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

// Pass both original and recovered rounds to validation context
var validationContext = new ConsensusValidationContext
{
    BaseRound = baseRound, // Recovered version for other validations
    OriginalBaseRound = originalBaseRound, // Original version for LibInformationValidation
    // ... other fields
};
```

Update `LibInformationValidationProvider` to use `OriginalBaseRound`:

```csharp
// In LibInformationValidationProvider.ValidateHeaderInformation:
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
    validationContext.OriginalBaseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
{
    validationResult.Message = "Incorrect implied lib height - cannot decrease.";
    return validationResult;
}
```

**Additional Safeguards:**
1. Add upper bound validation: ensure `ImpliedIrreversibleBlockHeight` <= current block height
2. Add rate limit: prevent large jumps (e.g., > N blocks per round)
3. Add monitoring: alert when miners' reported values diverge significantly from chain state
4. Implement slashing for miners caught reporting provably false LIB heights

**Test Cases:**
1. Test that a miner cannot decrease their `ImpliedIrreversibleBlockHeight` from one round to the next
2. Test that a miner cannot report a value higher than the current block height
3. Test Byzantine fault tolerance with exactly 1/3 malicious miners reporting false values
4. Test that the validation correctly rejects invalid UpdateValue transactions

### Proof of Concept

**Initial State:**
- Blockchain at height 1000
- Current round number: 100
- Miner "Alice" has `ImpliedIrreversibleBlockHeight` = 900 in state for round 99

**Attack Sequence:**

1. Alice prepares `UpdateValueInput` with `ImpliedIrreversibleBlockHeight` = 500 (artificially LOW, 400 blocks below her previous report)

2. Transaction calls `UpdateValue()` → triggers `ValidateBeforeExecution()`:
   - `baseRound` fetched from state shows Alice's previous value: 900
   - `RecoverFromUpdateValue()` modifies `baseRound`: Alice's value now = 500
   - Validation compares: `500 > 500` → FALSE → validation PASSES ✓

3. `ProcessUpdateValue()` stores the manipulated value:
   - `minerInRound.ImpliedIrreversibleBlockHeight = 500` written to state

**Expected Result:** Validation should FAIL because 500 < 900 (decreasing)

**Actual Result:** Validation PASSES because comparison is `500 > 500` (false) after recovery overwrites the original value

**Success Condition:** Alice's `ImpliedIrreversibleBlockHeight` is now 500 in state, affecting subsequent LIB calculations. If >1/3 of miners collude to report low values, they can delay LIB finalization. If they report inflated values (e.g., 2000 when true LIB is 900), they can cause premature finalization.

### Notes

The validation comment at line 81 explicitly states its purpose is to prevent "confirmed lib height and lib round number went down", but the implementation fails to achieve this for `ImpliedIrreversibleBlockHeight` due to the ordering of recovery before validation. The first check (lines 14-21) correctly validates `ConfirmedIrreversibleBlockHeight` because those fields are NOT modified by `RecoverFromUpdateValue()`, but the second check (lines 23-30) is rendered ineffective by the recovery process.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-19)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```
