### Title
VoteId Collision Causing Permanent Token Lock Due to Insufficient Uniqueness in ID Generation

### Summary
The Vote contract generates VoteId using only the current voting result's VotesAmount, which can be identical across different voting items, especially when newly created (both start at 0). When a malicious contract calls Vote twice in one transaction on different voting items with the same VotesAmount, the identical VoteId causes the second VotingRecord to overwrite the first, while both Lock operations succeed and accumulate tokens in the same virtual address. This results in permanent loss of the first vote's locked tokens, as only the last VotingRecord's amount can be withdrawn.

### Finding Description

**Root Cause:**

The VoteId generation in the Vote contract uses an insufficient uniqueness formula that omits the VotingItemId: [1](#0-0) 

The formula generates: `Hash(OriginTransactionId + VoteContractAddress + votingResult.VotesAmount)`. Since VotesAmount is independent per voting item, two different voting items can have the same VotesAmount value (commonly 0 for newly created items). [2](#0-1) 

**Missing Protection:**

The Vote contract does not check for existing VotingRecords before overwriting: [3](#0-2) 

Unlike the Election contract which has explicit collision protection: [4](#0-3) 

**Lock Accumulation Behavior:**

When Lock is called multiple times with the same LockId, tokens accumulate in the same virtual address: [5](#0-4) 

The virtual address is deterministically computed from Context.Sender, input.Address, and input.LockId, so identical LockIds result in the same destination address where tokens accumulate.

**Unlock Uses Overwritten Record:**

During withdrawal, the Unlock operation uses the amount from the final (overwritten) VotingRecord: [6](#0-5) 

**Transaction Context Preservation:**

The OriginTransactionId remains constant across inline calls, enabling the collision: [7](#0-6) 

### Impact Explanation

**Direct Fund Loss:**
- Permanent lock of tokens from the first overwritten vote
- The virtual address holds more tokens than the VotingRecord indicates, making the excess permanently unrecoverable
- Example: Vote1 locks 100 tokens, Vote2 locks 200 tokens with colliding VoteId → Virtual address has 300 tokens but only 200 can be withdrawn → 100 tokens permanently lost

**Affected Parties:**
- Any contract that executes multiple votes in one transaction (e.g., voting aggregators, governance bots, batch voting services)
- Users who deposit tokens into such contracts
- The protocol's token supply integrity (tokens become permanently locked)

**Invariant Violation:**
- Breaks critical token locking invariant: `locked_amount == withdrawable_amount`
- Violates the fundamental assumption that every Lock has a corresponding Unlock with matching amounts

**Severity Justification:**
HIGH severity due to:
1. Permanent, irreversible loss of funds
2. No reliance on privileged roles or external conditions
3. Violation of core token locking mechanism
4. Affects any contract implementing batch voting functionality

### Likelihood Explanation

**Attacker Capabilities:**
- Must deploy a contract that makes inline calls to Vote.Vote()
- Must fund the contract with tokens to lock
- Requires basic understanding of VoteId generation mechanism

**Attack Complexity:**
MEDIUM - The attacker needs to:
1. Deploy a malicious contract with inline call capability
2. Identify or create two voting items with matching VotesAmount (trivial for newly registered items starting at 0)
3. Execute both votes in a single transaction via the contract

**Feasible Preconditions:**
- Vote contract must be a system contract (default configuration) to pass Lock whitelist checks: [8](#0-7) 

- Voting items must have `IsLockToken=true` (standard configuration): [9](#0-8) 

**Execution Practicality:**
- Standard AElf contract can make inline calls using Send: [10](#0-9) 

- Two newly registered voting items will both have VotesAmount=0, guaranteeing collision
- No special timing or race conditions required

**Detection:**
- The collision is not immediately visible in transaction logs
- Only detected when attempting to query locked amounts or during forensic analysis
- Appears as normal voting activity until withdrawal is attempted

### Recommendation

**1. Include VotingItemId in VoteId Generation:**

Modify line 397 in `VoteContract.cs` to include the VotingItemId:
```csharp
input.VoteId = Context.GenerateId(Context.Self, 
    ByteArrayHelper.ConcatArrays(
        input.VotingItemId.Value,
        votingResult.VotesAmount.ToBytes(false)
    ));
```

**2. Add Collision Detection:**

Add explicit check before line 117:
```csharp
Assert(State.VotingRecords[input.VoteId] == null || 
       State.VotingRecords[input.VoteId].IsWithdrawn, 
       "Vote ID already exists.");
```

**3. Invariant Validation:**

Add a view method to verify locked amount matches record:
```csharp
public override BoolValue ValidateVoteLock(Hash voteId)
{
    var record = State.VotingRecords[voteId];
    var lockedAmount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
    {
        Address = record.Voter,
        Symbol = GetVotingItem(record.VotingItemId).AcceptedCurrency,
        LockId = voteId
    }).Amount;
    return new BoolValue { Value = lockedAmount == record.Amount };
}
```

**4. Test Cases:**

Add regression tests:
- Test voting twice in same transaction on different items with same VotesAmount
- Verify VoteId uniqueness across different voting items
- Validate locked amounts match VotingRecord amounts after multiple votes

### Proof of Concept

**Initial State:**
1. Two voting items registered: VotingItem1 and VotingItem2
2. Both items have `IsLockToken=true` and `VotesAmount=0` initially
3. Malicious contract deployed and funded with 300 tokens

**Attack Steps:**

**Transaction 1 - Malicious Contract Execution:**
1. Malicious contract calls `Vote.Vote()` on VotingItem1:
   - Amount: 100 tokens
   - VoteId1 = Hash(OriginTxId + VoteContract + 0)
   - Creates VotingRecord1[VoteId1] = {Amount: 100}
   - Locks 100 tokens with LockId=VoteId1
   - VotingItem1.VotesAmount becomes 100

2. Malicious contract calls `Vote.Vote()` on VotingItem2 (inline, same transaction):
   - Amount: 200 tokens
   - VoteId2 = Hash(OriginTxId + VoteContract + 0) = VoteId1 ← **COLLISION**
   - Overwrites VotingRecord1[VoteId1] = {Amount: 200}
   - Locks 200 tokens with LockId=VoteId1
   - Virtual address now has 300 tokens total

**Transaction 2 - Withdrawal Attempt:**
3. Malicious contract calls `Withdraw(VoteId1)`:
   - Retrieves VotingRecord[VoteId1].Amount = 200
   - Unlocks 200 tokens from virtual address
   - Virtual address balance: 300 - 200 = 100 tokens

**Expected vs Actual Result:**
- **Expected:** All 300 locked tokens should be withdrawable
- **Actual:** Only 200 tokens withdrawn, 100 tokens permanently locked in virtual address with no corresponding VotingRecord

**Success Condition:**
- Virtual address for LockId=VoteId1 has non-zero balance after withdrawal
- No VotingRecord exists that references this remaining balance
- Tokens are permanently irrecoverable

### Notes

This vulnerability specifically affects the Vote contract's automatic VoteId generation for `IsLockToken=true` voting scenarios. Delegated voting (`IsLockToken=false`) where the caller provides the VoteId explicitly is not affected, as seen in the Election contract's usage pattern where it generates VoteIds including candidate information. The fix requires enhancing the uniqueness of auto-generated VoteIds to include the VotingItemId, ensuring each vote on different items generates distinct identifiers even when other parameters are identical.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L122-130)
```csharp
        if (votingItem.IsLockToken)
            // Lock voted token.
            State.TokenContract.Lock.Send(new LockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                LockId = input.VoteId,
                Amount = amount
            });
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L225-231)
```csharp
            State.TokenContract.Unlock.Send(new UnlockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                Amount = votingRecord.Amount,
                LockId = input.VoteId
            });
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L392-393)
```csharp
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L397-397)
```csharp
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L433-433)
```csharp
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-212)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L139-146)
```csharp
    public Hash GenerateId(Address contractAddress, IEnumerable<byte> bytes)
    {
        var contactedBytes = OriginTransactionId.Value.Concat(contractAddress.Value);
        var enumerable = bytes as byte[] ?? bytes?.ToArray();
        if (enumerable != null)
            contactedBytes = contactedBytes.Concat(enumerable);
        return HashHelper.ComputeFrom(contactedBytes.ToArray());
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L196-203)
```csharp
    private void AssertSystemContractOrLockWhiteListAddress(string symbol)
    {
        var symbolState = State.LockWhiteLists[symbol];
        var isInWhiteList = symbolState != null && symbolState[Context.Sender];
        var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Values;
        var isSystemContractAddress = systemContractAddresses.Contains(Context.Sender);
        Assert(isInWhiteList || isSystemContractAddress, "No Permission.");
    }
```
