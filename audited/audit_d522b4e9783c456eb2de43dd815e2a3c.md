### Title
Null Reference Exception in Organization Validation After Improper Migration of ProposerWhiteList

### Summary
During a contract upgrade, if existing Organization data is migrated but the `ProposerWhiteList` field is not properly initialized, it remains `null`. Multiple contract functions including `Validate()`, `ValidateProposerInWhiteList()`, and `AssertIsAuthorizedProposer()` access `organization.ProposerWhiteList` without null-safety checks, causing `NullReferenceException` that breaks critical governance operations.

### Finding Description

**Root Cause:**
In protobuf3 C# code generation, message-type fields default to `null` until explicitly assigned. The `Organization` message contains a `ProposerWhiteList` field (message type) that will be `null` if not initialized during migration. [1](#0-0) 

**Vulnerable Code Locations:**

1. **Validate() method** - Accesses `ProposerWhiteList.Empty()` without null check: [2](#0-1) 

2. **ValidateProposerInWhiteList()** - Accesses `ProposerWhiteList.Contains()` without null check on organization or ProposerWhiteList: [3](#0-2) 

3. **AssertIsAuthorizedProposer()** - Accesses `ProposerWhiteList.Contains()` after only checking organization != null: [4](#0-3) 

4. **Extension methods** - The `Count()` and `Empty()` methods assume `ProposerWhiteList` is never null: [5](#0-4) 

**Execution Paths:**

1. **ChangeOrganizationThreshold**: Retrieves organization from state, calls `Validate()` at line 129: [6](#0-5) 

2. **ChangeOrganizationProposerWhiteList**: Retrieves organization from state, calls `Validate()` at line 144: [7](#0-6) 

3. **CreateProposal**: Calls `AssertIsAuthorizedProposer()` which accesses ProposerWhiteList: [8](#0-7) 

**Why Existing Protections Fail:**
The state storage uses `MappedState<Address, Organization>`: [9](#0-8) 

When organizations are retrieved from state after an improper migration, the `Organization` object exists but its `ProposerWhiteList` field is `null`. None of the code paths check for null `ProposerWhiteList` before accessing its methods.

### Impact Explanation

**Operational DoS of Governance:**
- Organizations become completely unusable after contract upgrade with improper migration
- **ChangeOrganizationThreshold** fails with `NullReferenceException`, preventing threshold adjustments
- **ChangeOrganizationProposerWhiteList** fails with `NullReferenceException`, preventing whitelist updates  
- **CreateProposal** fails with `NullReferenceException`, preventing new proposal creation
- **ValidateProposerInWhiteList** fails with `NullReferenceException`, breaking proposal validation

**Affected Parties:**
- All existing Referendum organizations created before the upgrade
- Organization members unable to update configurations
- Proposers unable to create proposals
- Entire Referendum governance mechanism becomes non-functional

**Severity: Medium**
- No direct fund loss or theft
- Complete operational DoS of governance functionality
- Requires contract re-upgrade with proper migration to fix
- Affects critical governance invariant: "Organization thresholds, proposer whitelist checks"

### Likelihood Explanation

**Attack Complexity: N/A (Migration Bug)**
This is not an attack but a migration bug. The vulnerability is triggered by:

1. **Precondition**: Contract upgrade performed with incomplete migration logic that:
   - Migrates Organization objects from old state
   - Fails to initialize or copy the `ProposerWhiteList` field
   - Leaves `ProposerWhiteList` as `null` in migrated organizations

2. **Trigger Conditions** (No attacker privileges needed):
   - Any organization member calls `ChangeOrganizationThreshold`
   - Any organization member calls `ChangeOrganizationProposerWhiteList`  
   - Any whitelisted proposer calls `CreateProposal`
   - Anyone calls `ValidateProposerInWhiteList` view method

3. **Feasibility**: High
   - Migration bugs are common during contract upgrades
   - Easy to miss protobuf field initialization in migration code
   - No detection until first post-upgrade transaction attempts to use the organization
   - Referendum contract currently lacks an `Initialize()` method (unlike Parliament contract)

4. **Detection**: Post-deployment
   - Bug manifests immediately when governance functions are called
   - Produces `NullReferenceException` in transaction logs
   - Visible to all users attempting governance operations

**Probability: Medium**
Realistic scenario during upgrade development if migration code is not thoroughly tested with existing organization data.

### Recommendation

**1. Add Null-Safety Checks:**

In `Referendum_Helper.cs`, modify `Validate()` to check for null `ProposerWhiteList`:
```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || 
        organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || 
        organization.ProposerWhiteList == null ||  // ADD THIS CHECK
        organization.ProposerWhiteList.Empty())
        return false;
    // ... rest of validation
}
```

**2. Add Null Check in ValidateProposerInWhiteList:**

In `Referendum.cs`, add null checks:
```csharp
public override BoolValue ValidateProposerInWhiteList(ValidateProposerInWhiteListInput input)
{
    var organization = State.Organizations[input.OrganizationAddress];
    return new BoolValue
    {
        Value = organization != null && 
                organization.ProposerWhiteList != null && 
                organization.ProposerWhiteList.Contains(input.Proposer)
    };
}
```

**3. Add Migration Method:**

Add an `Initialize()` or migration method to properly handle existing organizations during upgrades, ensuring all `ProposerWhiteList` fields are initialized.

**4. Defensive Extension Methods:**

Modify `ProposerWhiteListExtensions.cs` to handle null:
```csharp
public static bool Empty(this ProposerWhiteList proposerWhiteList)
{
    return proposerWhiteList == null || proposerWhiteList.Count() == 0;
}
```

**5. Add Regression Tests:**

Test organization operations with null `ProposerWhiteList` to catch this pattern:
- Test `Validate()` with null `ProposerWhiteList`
- Test `ChangeOrganizationThreshold` after improper migration
- Test `CreateProposal` with migrated organizations

### Proof of Concept

**Initial State:**
1. Referendum contract deployed with organizations created normally (ProposerWhiteList properly initialized)
2. Contract upgrade performed with migration code that copies organizations but fails to initialize `ProposerWhiteList` field

**Exploitation Steps:**

Step 1: Contract upgraded, organization retrieved from state has `ProposerWhiteList = null`

Step 2: Organization attempts to change threshold:
```
Transaction: ChangeOrganizationThreshold(new ProposalReleaseThreshold { ... })
Caller: OrganizationAddress (organization calling itself via proposal)
```

**Expected Result:** Transaction succeeds, threshold updated

**Actual Result:** 
```
Transaction fails with NullReferenceException
Stack trace points to: organization.ProposerWhiteList.Empty()
Error occurs at Validate() line 93
```

Step 3: Any user attempts to validate proposer:
```
Transaction: ValidateProposerInWhiteList(organizationAddress, proposerAddress)
```

**Actual Result:**
```
Transaction fails with NullReferenceException  
Error occurs at: organization.ProposerWhiteList.Contains(input.Proposer)
Line 228 in Referendum.cs
```

**Success Condition:** All migrated organizations have non-functional governance operations, throwing `NullReferenceException` on any attempt to use `ProposerWhiteList`.

### Citations

**File:** protobuf/referendum_contract.proto (L57-70)
```text
message Organization {
    // The threshold for releasing the proposal.
    acs3.ProposalReleaseThreshold proposal_release_threshold = 1;
    // The token used during proposal operations.
    string token_symbol = 2;
    // The address of organization.
    aelf.Address organization_address = 3;
    // The organizations id.
    aelf.Hash organization_hash = 4;
    // The proposer whitelist.
    acs3.ProposerWhiteList proposer_white_list = 5;
    // The creation token is for organization address generation.
    aelf.Hash creation_token = 6;
}
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-59)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-137)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L223-230)
```csharp
    public override BoolValue ValidateProposerInWhiteList(ValidateProposerInWhiteListInput input)
    {
        var organization = State.Organizations[input.OrganizationAddress];
        return new BoolValue
        {
            Value = organization.ProposerWhiteList.Contains(input.Proposer)
        };
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L8-16)
```csharp
    public static int Count(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Proposers.Count;
    }

    public static bool Empty(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Count() == 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/ReferendumState.cs (L9-20)
```csharp
public class ReferendumState : ContractState
{
    internal TokenContractContainer.TokenContractReferenceState TokenContract { get; set; }
    internal ParliamentContractContainer.ParliamentContractReferenceState ParliamentContract { get; set; }

    public BoolState Initialized { get; set; }
    public MappedState<Address, Hash, Receipt> LockedTokenAmount { get; set; }
    public MappedState<Address, Organization> Organizations { get; set; }
    public MappedState<Hash, ProposalInfo> Proposals { get; set; }
    public MappedState<string, MethodFees> TransactionFees { get; set; }
    public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
}
```
