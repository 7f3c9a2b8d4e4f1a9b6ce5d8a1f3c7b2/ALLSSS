# Audit Report

## Title
ConnectorController Privilege Escalation Through Unvalidated Contract Address

## Summary
The `ChangeConnectorController` method in the TokenConverter contract fails to validate that the `ContractAddress` in the new `AuthorityInfo` corresponds to a legitimate governance contract (Parliament, Association, or Referendum). This allows an entity with temporary controller access to permanently bypass all governance by pointing to a malicious contract, gaining unrestricted control over connector management, fee settings, and token conversion operations.

## Finding Description
The vulnerability exists in the `ChangeConnectorController` method, which validates new authority using only `CheckOrganizationExist(input)`. [1](#0-0) 

The `CheckOrganizationExist` method performs a cross-contract call to `ValidateOrganizationExist` on whatever `ContractAddress` is provided in the `AuthorityInfo`, without verifying this address is a legitimate governance contract. [2](#0-1) 

Legitimate governance contracts (Parliament, Association, Referendum) implement `ValidateOrganizationExist` by checking if an organization exists in their state storage. [3](#0-2)  However, an attacker can deploy a malicious contract that always returns `true`, effectively bypassing this check.

After the malicious authority is set, all protected operations use `AssertPerformedByConnectorController()`, which only verifies that `Context.Sender` matches the `OwnerAddress` in the stored authority - it does NOT consult the governance contract for proposal approval. [4](#0-3) 

**Attack Sequence:**
1. Attacker obtains temporary control of current ConnectorController (via governance vote or compromise)
2. Attacker deploys a malicious contract implementing `ValidateOrganizationExist` to return `true` for any input
3. Attacker calls `ChangeConnectorController` with `AuthorityInfo { ContractAddress = malicious_contract, OwnerAddress = attacker_address }`
4. Validation passes because malicious contract returns `true`
5. Future operations only check if sender equals attacker_address, completely bypassing governance

This breaks the security guarantee that all critical authority changes must flow through legitimate governance organizations with proposals, voting, and thresholds.

## Impact Explanation
**Critical Severity** - The attacker gains permanent, unrestricted control over:

1. **Connector Management**: Can manipulate connector weights, virtual balances, and related symbols via `UpdateConnector` and `AddPairConnector`, directly affecting Bancor pricing calculations and liquidity
2. **Fee Control**: Can set arbitrary fee rates via `SetFeeRate`, enabling value extraction or DoS
3. **Connector Activation**: Can enable/disable connectors via `EnableConnector`, freezing token conversions
4. **Fund Risk**: Can drain reserves by manipulating connector parameters and pricing functions, or lock funds by disabling conversion paths

The impact extends beyond the TokenConverter to any protocol components relying on its pricing and conversion functionality. The governance bypass also sets a dangerous precedent that undermines the entire separation-of-powers model.

## Likelihood Explanation
**Medium-High Likelihood:**

- **Precondition**: Requires controlling the current ConnectorController, which by default is the Parliament default organization. This could be achieved through winning a governance vote, temporary compromise, or collusion within the organization.
- **Attack Complexity**: Low - requires only deploying a simple malicious contract and calling one method
- **Detection**: The attack would be visible on-chain but cannot be prevented by the contract itself
- **No Existing Protections**: There is no whitelist, no validation against known governance contract addresses (Parliament, Association, Referendum), and no additional checks in the authorization flow

The key insight is that this represents **privilege escalation** - even legitimate temporary governance control should not enable permanent bypass of all future governance. This violates the principle of least privilege and creates an asymmetric risk where a single compromised vote can have permanent consequences.

## Recommendation
Implement strict validation that the `ContractAddress` in `AuthorityInfo` must be one of the known governance contracts:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // First, validate the contract address is a legitimate governance contract
    Assert(
        authorityInfo.ContractAddress == State.ParliamentContract.Value ||
        authorityInfo.ContractAddress == State.AssociationContract.Value ||
        authorityInfo.ContractAddress == State.ReferendumContract.Value,
        "Controller contract must be a legitimate governance contract (Parliament, Association, or Referendum)."
    );
    
    // Then validate the organization exists in that contract
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

Add contract references to state if not already present:
```csharp
internal AssociationContractContainer.AssociationContractReferenceState AssociationContract { get; set; }
internal ReferendumContractContainer.ReferendumContractReferenceState ReferendumContract { get; set; }
```

Initialize these references by calling `Context.GetContractAddressByName()` with the appropriate system contract names when first accessed.

## Proof of Concept
```csharp
[Fact]
public async Task ConnectorController_Bypass_Through_Malicious_Contract()
{
    // Step 1: Deploy malicious "YesMan" contract that always approves
    var maliciousContractCode = DeployMaliciousYesManContract();
    var maliciousContractAddress = maliciousContractCode.ContractAddress;
    
    // Step 2: Attacker uses current controller authority to change controller
    var attackerAddress = Address.FromString("attacker");
    var maliciousAuthority = new AuthorityInfo
    {
        ContractAddress = maliciousContractAddress,
        OwnerAddress = attackerAddress
    };
    
    // Change controller through current governance (via proposal)
    await ExecuteProposalForParliamentTransaction(
        TokenConverterContractAddress,
        nameof(TokenConverterContractStub.ChangeConnectorController),
        maliciousAuthority);
    
    // Step 3: Verify controller was changed
    var newController = await DefaultStub.GetControllerForManageConnector.CallAsync(new Empty());
    newController.ContractAddress.ShouldBe(maliciousContractAddress);
    newController.OwnerAddress.ShouldBe(attackerAddress);
    
    // Step 4: Attacker can now directly call protected methods without governance
    var attackerStub = GetTokenConverterContractStub(attackerAddress);
    
    // Manipulate fee rate without any governance proposal
    var maliciousFeeRate = await attackerStub.SetFeeRate.SendAsync(new StringValue { Value = "0.99" }); // 99% fee
    maliciousFeeRate.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Attacker successfully bypassed governance!
}
```

## Notes
This vulnerability represents a **privilege escalation** issue rather than a simple authorization bypass. The design intention of AElf's governance model is that all authority should flow through legitimate governance contracts (Parliament, Association, Referendum) which enforce proposals, voting thresholds, and time locks. By allowing arbitrary contract addresses, the system enables conversion of temporary/governed control into permanent direct control.

The `AuthorityInfo` structure only contains two fields - `ContractAddress` and `OwnerAddress` [5](#0-4)  - with no inherent validation of the contract type. This pattern appears across multiple AElf contracts, suggesting a systemic issue that should be addressed protocol-wide.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L303-309)
```csharp
    public override Empty ChangeConnectorController(AuthorityInfo input)
    {
        AssertPerformedByConnectorController();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.ConnectorController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L397-403)
```csharp
    private void AssertPerformedByConnectorController()
    {
        if (State.ConnectorController.Value == null) State.ConnectorController.Value = GetDefaultConnectorController();

        Assert(Context.Sender == State.ConnectorController.Value.OwnerAddress,
            "Only manager can perform this action.");
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** protobuf/authority_info.proto (L5-10)
```text
message AuthorityInfo {
    // The contract address of the controller.
    aelf.Address contract_address = 1;
    // The address of the owner of the contract.
    aelf.Address owner_address = 2;
}
```
