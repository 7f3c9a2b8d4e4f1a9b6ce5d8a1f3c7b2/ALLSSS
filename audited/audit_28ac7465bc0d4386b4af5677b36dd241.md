# Audit Report

## Title
Premature Loop Exit in Transaction Fee Token Selection Causes Delegation Payment Failure

## Summary
The `GetAvailableSymbolToPayTxFee()` function incorrectly uses `break` instead of `continue` when a delegation check fails, causing the loop to exit prematurely without evaluating remaining tokens in the configured list. This results in legitimate transactions failing with "Transaction fee not enough" even when delegatees have sufficient delegation allowances for alternative tokens later in the list.

## Finding Description

The vulnerability exists in the token selection logic for transaction size fees when delegation is active. When the system is configured with multiple tokens that can be used to pay transaction fees (a standard production setup), the function iterates through the token list to find one with sufficient delegation allowance.

**Root Cause:**

The critical bug occurs when checking delegation sufficiency [1](#0-0) . When `delegations != null`, the function validates whether the current token has adequate delegation allowance. If the validation fails (`delegationEnough == false`), the code executes `break`, immediately terminating the entire foreach loop without evaluating subsequent tokens in the list.

**Execution Path:**

1. The public entry point `ChargeTransactionFees()` is automatically invoked by the ACS1 pre-plugin service for every transaction [2](#0-1) 

2. The charging flow attempts to deduct fees from delegatees when configured [3](#0-2) 

3. For each delegatee, the system calls `ChargeTransactionFeesToBill()` which includes size fee charging [4](#0-3) 

4. The `ChargeSizeFee()` function invokes `GetAvailableSymbolToPayTxFee()` with the list of configured alternative tokens [5](#0-4) 

5. When `GetAvailableSymbolToPayTxFee()` returns `null` due to the premature `break`, the size fee charging fails [6](#0-5) 

**Why Existing Protections Fail:**

The function initializes fallback variables (`availableSymbolWithEnoughBalance`, `availableSymbolWithEnoughBalancePlusAllowance`, etc.) intended to capture valid alternatives [7](#0-6) . However, these fallback mechanisms become useless because the premature `break` statement prevents the loop from ever reaching tokens that would pass the delegation check and populate these variables.

The fallback logic at the end cannot salvage the situation if the loop never evaluates viable tokens [8](#0-7) .

## Impact Explanation

**Denial of Service - Medium Severity:**

This vulnerability breaks the multi-token delegation feature's core functionality. Users relying on transaction fee delegation will experience systematic transaction failures for legitimate operations. The severity is medium rather than high because:

1. **No Direct Fund Loss:** The bug causes transaction rejections rather than fund theft or unauthorized transfers
2. **Feature-Specific Impact:** Only affects users utilizing the delegation feature with multi-token configurations
3. **Operational Disruption:** Blocks legitimate transactions and renders the multi-token fallback mechanism non-functional

**Affected Parties:**
- Users who depend on delegatees to pay transaction fees
- Delegatees who have properly allocated sufficient allowances for alternative tokens  
- DApps and smart contract operations requiring fee delegation functionality
- The AElf ecosystem's user experience and adoption of the delegation feature

**Realistic Scenario:**

Consider a production environment where:
- The system is configured with tokens [TOKEN_A, TOKEN_B, TOKEN_C] for size fees
- A user has a delegatee relationship
- The delegatee has: 0 TOKEN_A delegation, 1000 TOKEN_B delegation, 1000 TOKEN_C delegation
- Transaction requires 100 tokens worth of size fees

Expected behavior: The system should use TOKEN_B or TOKEN_C to pay the fee.
Actual behavior: Transaction fails at TOKEN_A check without evaluating TOKEN_B or TOKEN_C.

## Likelihood Explanation

**High Likelihood - Occurs During Normal Operations:**

This is not an attack but a systematic failure that triggers automatically under common production conditions. No malicious actor is required - it happens during normal protocol usage.

**Feasibility Conditions:**

1. **Directly Reachable:** The bug triggers through the public `ChargeTransactionFees()` method, which is automatically invoked by the ACS1 pre-plugin infrastructure for every transaction that requires fee payment [9](#0-8) 

2. **Standard Configuration:** Multi-token fee configuration is explicitly supported and commonly deployed in production environments. The system provides `SetSymbolsToPayTxSizeFee()` specifically for this purpose, indicating it's an intended feature rather than an edge case.

3. **Common Preconditions:**
   - Multiple tokens configured for transaction size fees (standard practice for flexibility)
   - Active delegation relationships (the delegation feature is in production use)
   - Token list ordering where a token with insufficient delegation appears before tokens with sufficient delegation (purely a configuration artifact, not user-controllable)

4. **High Probability:** The bug triggers whenever the token list ordering is unfavorable. Since users and applications cannot control the token list ordering in their individual transactions, this can easily occur in real deployments based solely on how the system administrator configures the token list.

**Detection Difficulty:**

The issue manifests as a generic "Transaction fee not enough" error message, making root cause diagnosis difficult without code inspection. Users and support teams would struggle to identify that the problem is a logic bug rather than actual insufficient delegation.

## Recommendation

**Fix:** Change line 480 from `break` to `continue` to allow the loop to evaluate all tokens in the list before determining no valid token exists.

**Current buggy code:**
```csharp
if (!delegationEnough) break;  // Line 480 - WRONG
```

**Corrected code:**
```csharp
if (!delegationEnough) continue;  // Should skip to next token
```

This simple one-word change ensures that when a token fails the delegation check, the loop continues evaluating remaining tokens rather than prematurely terminating. This restores the intended multi-token fallback mechanism and allows the function's fallback variables to be properly populated with valid alternatives.

**Additional Validation:**

Consider adding explicit test cases that verify multi-token delegation scenarios where the first token in the list has insufficient delegation but later tokens have sufficient delegation, ensuring the fallback mechanism works correctly.

## Proof of Concept

The following test demonstrates the vulnerability by configuring a scenario where TOKEN_A (first in list) has insufficient delegation but TOKEN_B (second in list) has sufficient delegation. The transaction should succeed by using TOKEN_B but will fail due to the premature `break` statement:

```csharp
[Fact]
public async Task ChargeTransactionFee_PrematureBreak_DelegationFailure_Test()
{
    // Setup: Create two tokens for size fees
    var tokenA = "TOKENA";
    var tokenB = "TOKENB";
    await SetPrimaryTokenSymbolAsync();
    await CreateTokenAsync(DefaultSender, tokenA);
    await CreateTokenAsync(DefaultSender, tokenB);

    // Issue tokens to delegatee
    await IssueTokenToUserAsync(tokenA, 1000_00000000, DelegateeAddress);
    await IssueTokenToUserAsync(tokenB, 1000_00000000, DelegateeAddress);

    // Setup delegation: TOKENA has insufficient (50), TOKENB has sufficient (500)
    var delegations = new Dictionary<string, long>
    {
        [tokenA] = 50_00000000,    // Insufficient for size fee
        [tokenB] = 500_00000000    // Sufficient for size fee
    };
    
    await TokenContractStub2.SetTransactionFeeDelegations.SendAsync(
        new SetTransactionFeeDelegationsInput
        {
            DelegatorAddress = DefaultSender,
            Delegations = { delegations }
        });

    // Configure token list: TOKENA first, TOKENB second
    var sizeFeeSymbolList = new SymbolListToPayTxSizeFee
    {
        SymbolsToPayTxSizeFee =
        {
            new SymbolToPayTxSizeFee
            {
                TokenSymbol = tokenA,
                AddedTokenWeight = 1,
                BaseTokenWeight = 1
            },
            new SymbolToPayTxSizeFee
            {
                TokenSymbol = tokenB,
                AddedTokenWeight = 1,
                BaseTokenWeight = 1
            }
        }
    };
    await TokenContractImplStub.SetSymbolsToPayTxSizeFee.SendAsync(sizeFeeSymbolList);

    // Attempt to charge transaction fee requiring 100 tokens
    var chargeInput = new ChargeTransactionFeesInput
    {
        MethodName = nameof(TokenContractContainer.TokenContractStub.Transfer),
        ContractAddress = TokenContractAddress,
        TransactionSizeFee = 100_00000000,
    };
    chargeInput.SymbolsToPayTxSizeFee.AddRange(sizeFeeSymbolList.SymbolsToPayTxSizeFee);

    // BUG: This will fail even though TOKENB has sufficient delegation
    // The function breaks at TOKENA (insufficient) without checking TOKENB
    var result = await TokenContractStub.ChargeTransactionFees.SendAsync(chargeInput);
    
    // Expected: Success = true (using TOKENB)
    // Actual: Success = false (premature break at TOKENA)
    result.Output.Success.ShouldBe(false);  // Demonstrates the bug
    result.Output.ChargingInformation.ShouldContain("Transaction fee not enough");

    // Verify TOKENB delegation was never checked/used despite being sufficient
    var delegationAfter = await TokenContractStub.GetTransactionFeeDelegationsOfADelegatee.CallAsync(
        new GetTransactionFeeDelegationsOfADelegateeInput
        {
            DelegatorAddress = DefaultSender,
            DelegateeAddress = DelegateeAddress
        });
    delegationAfter.Delegations[tokenB].ShouldBe(500_00000000);  // Unchanged - never evaluated
}
```

This test proves the vulnerability by showing that even when TOKEN_B has more than sufficient delegation (500 tokens when only 100 needed), the transaction fails because the loop exits prematurely at TOKEN_A without ever evaluating TOKEN_B. After the fix (changing `break` to `continue`), this test would pass with `Success = true` and TOKEN_B delegation would be properly deducted.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L18-27)
```csharp
    /// <summary>
    /// Related transactions will be generated by acs1 pre-plugin service,
    /// and will be executed before the origin transaction.
    /// </summary>
    /// <param name="input"></param>
    /// <returns></returns>
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L183-207)
```csharp
        foreach (var (delegatee, delegations) in delegationInfo)
        {
            // compare current block height with the block height when the delegatee added
            if (Context.Transaction.RefBlockNumber < delegations.BlockHeight) continue;

            var delegateeBill = new TransactionFeeBill();
            var delegateeAllowanceBill = new TransactionFreeFeeAllowanceBill();
            var delegateeAddress = Address.FromBase58(delegatee);
            var delegateeChargingResult = ChargeTransactionFeesToBill(input, delegateeAddress,
                ref delegateeBill, ref delegateeAllowanceBill, fee, isSizeFeeFree, delegations);

            if (!delegateeChargingResult) continue;

            bill = delegateeBill;
            allowanceBill = delegateeAllowanceBill;
            fromAddress = delegateeAddress;
            chargingResult = true;
            if (!delegations.IsUnlimitedDelegate)
            {
                ModifyDelegation(delegateeBill, delegateeAllowanceBill, fromAddress, input.ContractAddress,
                    input.MethodName, delegatorAddress);
            }

            break;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L285-299)
```csharp
        //For delegation, if the base fee fails to be charged, the size fee will not be charged
        if (delegations != null && !successToChargeBaseFee)
        {
            return false;
        }

        var successToChargeSizeFee = true;
        if (!isSizeFeeFree)
        {
            // If IsSizeFeeFree == true, do not charge size fee.
            successToChargeSizeFee =
                ChargeSizeFee(input, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }

        return successToChargeBaseFee && successToChargeSizeFee;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L393-398)
```csharp
        if (input.SymbolsToPayTxSizeFee.Any())
        {
            var allSymbolToTxFee = input.SymbolsToPayTxSizeFee.ToList();
            var availableSymbol = GetAvailableSymbolToPayTxFee(allSymbolToTxFee, fromAddress, txSizeFeeAmount,
                transactionFeeFreeAllowancesMap, symbolChargedForBaseFee, amountChargedForBaseFee,
                amountChargedForBaseAllowance, delegations);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L410-414)
```csharp
            //For delegation,if there is no available token,return false,no need to generate bill
            if (delegations != null && availableSymbol == null)
            {
                return false;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L467-470)
```csharp
        SymbolToPayTxSizeFee availableSymbol = null;
        SymbolToPayTxSizeFee availableSymbolWithAnything = null;
        SymbolToPayTxSizeFee availableSymbolWithEnoughBalance = null;
        SymbolToPayTxSizeFee availableSymbolWithEnoughBalancePlusAllowance = null;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L475-481)
```csharp
            if (delegations != null)
            {
                var delegationEnough = IsDelegationEnoughBaseOnPrimaryToken(symbolToPlayTxSizeFee,
                    symbolChargedForBaseFee, amountChargedForBaseFee.Add(amountChargedForBaseAllowance),
                    txSizeFeeAmount, delegations);
                if (!delegationEnough) break;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L513-516)
```csharp
        availableSymbol ??= availableSymbolWithEnoughBalancePlusAllowance ??
                            availableSymbolWithEnoughBalance ?? availableSymbolWithAnything;

        return availableSymbol;
```
