### Title
Unbounded Loop in GetAllProfitsMap Enables Denial of Service Through Gas Exhaustion

### Summary
The `GetAllProfitsMap` view method in the Profit contract contains an unbounded loop that iterates over all profit details without respecting the intended limit of 10 details per query. This allows attackers to cause excessive gas consumption and transaction failures when profit information is queried on-chain, particularly affecting contracts like TokenHolder that depend on these view methods.

### Finding Description

The vulnerability exists in the `GetAllProfitsMap` private method which is called by public view methods `GetAllProfitAmount` and `GetProfitsMap`. [1](#0-0) 

**Root Cause:**
While the code calculates `profitableDetailCount` limited to `ProfitContractConstants.ProfitReceivingLimitForEachTime` (10), the actual loop iterates over ALL `availableDetails.Count` without bounds. For each iteration, `ProfitAllPeriods` is called with `profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod)` as the period count parameter, which can be extremely large (potentially billions for permanent beneficiaries with `EndPeriod = long.MaxValue`). [2](#0-1) 

The `ProfitAllPeriods` method then performs nested loops over periods and token symbols with state reads for each period: [3](#0-2) 

**Why Protections Fail:**
The check `if(i >= profitableDetailCount) continue;` at line 132 only prevents the second `ProfitAllPeriods` call for calculating claimable profits, but does NOT prevent the first call at line 130 which calculates total profits for ALL details.

**Contrast with ClaimProfits:**
The state-changing `ClaimProfits` method correctly limits its loop to only `profitableDetailCount`: [4](#0-3) 

**How Details Accumulate:**
Each `AddBeneficiary` call adds a new `ProfitDetail` without hard limits on total count: [5](#0-4) 

The cleanup mechanism only removes fully claimed and expired details, allowing accumulation: [6](#0-5) 

### Impact Explanation

**Operational DoS Impact:**
- **Gas Exhaustion**: With 100 profit details and average 50 periods each, the method performs 5,000+ nested iterations with state reads, causing transactions to exceed gas limits or become prohibitively expensive
- **Service Disruption**: Users and contracts cannot query profit information on-chain, breaking critical functionality
- **Affected Parties**: 
  - TokenHolder contract which calls `GetProfitsMap` for profit queries
  - Any user or contract attempting to query profits via `GetAllProfitAmount` or `GetProfitsMap`
  - Beneficiaries in long-running schemes (Treasury, Election, etc.) who naturally accumulate many details over time

**Severity: HIGH** - Core profit querying functionality becomes unusable, blocking legitimate users from accessing their profit information and preventing dependent contracts from functioning correctly. [7](#0-6) 

### Likelihood Explanation

**Attacker Capabilities:**
1. **Direct Attack**: A malicious scheme manager can create a scheme and repeatedly call `AddBeneficiary` for a target beneficiary with different period ranges, artificially inflating their detail count
2. **Natural Accumulation**: In production schemes (Treasury, Election, TokenHolder), beneficiaries naturally accumulate many details through:
   - Repeated staking/unstaking operations
   - Multiple voting periods
   - Long-term participation spanning hundreds of periods

**Attack Complexity:** LOW
- Entry point is publicly accessible view method
- No special permissions required to trigger (any user can query their own profits)
- Scheme managers (controlled by contracts like TokenHolder) can add beneficiaries without restrictions

**Feasibility:** HIGH
- Attack requires only calling `AddBeneficiary` multiple times (for direct attack)
- Or simply waiting for natural accumulation in active schemes
- Subsequent queries trigger the DoS automatically

**Economic Rationality:**
- Attack cost: Gas for AddBeneficiary calls (~$1-10 depending on network fees)
- Impact: Complete DoS of profit querying for targeted beneficiaries
- Griefing potential: High, as it affects legitimate users

### Recommendation

**Immediate Fix:**
Apply the same limit used in `ClaimProfits` to the loop in `GetAllProfitsMap`:

```csharp
// Line 125: Change from
for (var i = 0; i < availableDetails.Count; i++)

// To
for (var i = 0; i < profitableDetailCount; i++)
```

This ensures the loop respects the `ProfitReceivingLimitForEachTime` constant (10) for calculating all profits, not just claimable profits.

**Additional Safeguards:**
1. Add a hard limit on `ProfitDetail` count per beneficiary in `AddBeneficiary`:
   ```csharp
   Assert(currentProfitDetails.Details.Count < MaxProfitDetailsPerBeneficiary, 
          "Too many profit details");
   ```

2. Cap the period range in `ProfitAllPeriods` calculation to prevent extremely large ranges:
   ```csharp
   var periodRange = Math.Min(
       profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod),
       MaximumPeriodRangeForViews);
   ```

3. Add comprehensive cleanup of old details during `AddBeneficiary` to prevent unbounded growth

**Test Cases:**
1. Add beneficiary 50+ times, verify view methods remain responsive
2. Test with permanent beneficiaries (EndPeriod = long.MaxValue)
3. Measure gas consumption for varying detail counts

### Proof of Concept

**Setup:**
1. Create a test profit scheme with manager = attacker address
2. Set scheme CurrentPeriod = 1000

**Attack Steps:**
```
1. For i = 1 to 100:
   - Call AddBeneficiary(schemeId, victim_address, shares=100, endPeriod=i*100)
   - This creates 100 ProfitDetail entries for the victim

2. For some periods, call DistributeProfits to create distributed profit data

3. Call GetAllProfitAmount(schemeId, victim_address, "ELF")
   OR
   Call GetProfitsMap(schemeId, victim_address) from TokenHolder contract
```

**Expected Result:** Query completes with reasonable gas cost (<1M gas)

**Actual Result:** 
- Loop executes 100 iterations at line 125
- Each iteration calls ProfitAllPeriods with potentially 100+ periods
- Total: 10,000+ nested iterations with state reads
- Gas consumption exceeds transaction limits (>10M gas)
- Transaction fails or becomes prohibitively expensive

**Success Condition:** Transaction fails with "out of gas" or gas cost exceeds reasonable limits (>5M gas), preventing legitimate users from querying their profits.

### Citations

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L119-135)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, availableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);

        var allProfitsDict = new Dictionary<string, long>();
        var claimableProfitsDict = new Dictionary<string, long>();
        for (var i = 0; i < availableDetails.Count; i++)
        {
            var profitDetail = availableDetails[i];
            if (profitDetail.LastProfitPeriod == 0) profitDetail.LastProfitPeriod = profitDetail.StartPeriod;
            
            var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod),true, symbol);
            AddProfitToDict(allProfitsDict, totalProfitsDictForEachProfitDetail);
            if(i >= profitableDetailCount) continue;
            var claimableProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount,true, symbol);
            AddProfitToDict(claimableProfitsDict, claimableProfitsDictForEachProfitDetail);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L5-5)
```csharp
    public const int ProfitReceivingLimitForEachTime = 10;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L203-207)
```csharp
        // Remove details too old.
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L772-785)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
        // Only can get profit from last profit period to actual last period (profit.CurrentPeriod - 1),
        // because current period not released yet.
        for (var i = 0; i < profitableDetailCount; i++)
        {
            var profitDetail = profitableDetails[i];
            if (profitDetail.LastProfitPeriod == 0)
                // This detail never performed profit before.
                profitDetail.LastProfitPeriod = profitDetail.StartPeriod;

            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L853-867)
```csharp
        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L264-271)
```csharp
    public override ReceivedProfitsMap GetProfitsMap(ClaimProfitsInput input)
    {
        var scheme = State.TokenHolderProfitSchemes[input.SchemeManager];
        var profitsMap = State.ProfitContract.GetProfitsMap.Call(new Profit.ClaimProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary ?? Context.Sender
        });
```
