### Title
Missing Symbol Length Validation in Cross-Chain Token Registration Allows Storage Bloat

### Summary
While the `SetMethodFee()` method indirectly enforces symbol length restrictions through token existence validation, tokens created via the cross-chain path (`CrossChainCreateToken`) bypass the symbol length checks enforced during normal token creation. This inconsistency allows tokens with symbols significantly longer than the intended limits (10 characters for regular tokens, 30 for NFTs) to be registered and used in method fees, potentially causing storage bloat.

### Finding Description

**Root Cause:**
The `RegisterTokenInfo()` method validates symbol format via regex but does not enforce symbol length limits. [1](#0-0) 

The regex validation only checks the pattern `^[a-zA-Z0-9]+(-[0-9]+)?$` without any length constraint: [2](#0-1) 

**Inconsistent Validation Paths:**

1. **Normal Token Creation Path (Enforces Length):**
   - `Create()` → `CreateToken()` → `AssertValidCreateInput()` → `CheckSymbolLength()`
   - Enforces `SymbolMaxLength = 10` for regular tokens and `NFTSymbolMaxLength = 30` for NFTs [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) [7](#0-6) 

2. **Cross-Chain Token Creation Path (Bypasses Length Check):**
   - `CrossChainCreateToken()` → `RegisterTokenInfo()` → Only regex validation, no length check [8](#0-7) 

**SetMethodFee Validation:**
`SetMethodFee()` requires tokens to exist (validated via `AssertValidFeeToken` → `GetTokenInfo`), but does not independently validate symbol length: [9](#0-8) [10](#0-9) 

### Impact Explanation

**Operational Impact:**
- **Storage Bloat**: Tokens with symbols hundreds or thousands of characters long (up to the 128KB state size limit) can be registered via cross-chain path and used in method fees, storing unnecessarily large strings in `State.TransactionFees`
- **Validation Inconsistency**: Cross-chain tokens bypass the defense-in-depth validation that locally-created tokens must pass
- **Increased State Costs**: Long symbols increase storage requirements and serialization/deserialization overhead
- **No Direct Fund Impact**: This is an efficiency/storage issue, not a direct financial vulnerability

**Affected Parties:**
- Chain operators bearing increased storage costs
- System efficiency and performance due to unnecessarily large state objects

**Severity Justification:**
Low severity because the impact is limited to storage inefficiency rather than critical system compromise, fund loss, or governance bypass.

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Access to a whitelisted cross-chain source (requires governance approval for whitelist registration)
2. The source chain must either have lax symbol validation or be compromised
3. `MethodFeeController` authority to call `SetMethodFee()` and actually use the long-symbol token in fees

**Attack Complexity:**
- **Medium-High**: Requires coordination with or compromise of a trusted cross-chain source
- Cross-chain whitelist is governance-controlled, limiting who can send tokens [11](#0-10) 

**Feasibility Conditions:**
- Assumes a whitelisted parent/side chain has inadequate symbol validation
- Relies on trust assumptions in cross-chain operations being violated
- Limited by transaction size (5MB) and state size (128KB) limits, but symbols of tens of thousands of characters still possible

**Probability Assessment:**
Low likelihood due to strong preconditions (governance-controlled whitelist, trusted chain compromise), but defense-in-depth principle suggests this gap should be closed.

### Recommendation

**Immediate Fix:**
Add symbol length validation to `RegisterTokenInfo()` to enforce consistent limits regardless of token registration path:

```csharp
private void RegisterTokenInfo(TokenInfo tokenInfo)
{
    Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
        "Invalid symbol.");
    
    // Add length validation
    var symbolType = GetSymbolType(tokenInfo.Symbol);
    CheckSymbolLength(tokenInfo.Symbol, symbolType);
    
    Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
    Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
    Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
    Assert(tokenInfo.Owner != null, "Invalid owner address.");
    State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
    State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
}
```

**Invariant to Add:**
All registered tokens must have symbol length ≤ `SymbolMaxLength` (10) for regular tokens or ≤ `NFTSymbolMaxLength` (30) for NFTs, regardless of registration path.

**Test Cases:**
1. Attempt to register token via `CrossChainCreateToken` with symbol length = 11 (should fail for regular token)
2. Attempt to register NFT via `CrossChainCreateToken` with symbol length = 31 (should fail)
3. Verify existing cross-chain token registration still works within limits

### Proof of Concept

**Initial State:**
- Chain A and Chain B are connected via cross-chain mechanism
- Chain B's token contract address is whitelisted in `State.CrossChainTransferWhiteList` on Chain A
- Attacker controls governance on Chain B or Chain B has no symbol length validation

**Attack Steps:**

1. **On Chain B**: Create token with symbol "VERYLONGSYMBOLNAMETHATEXCEEDSMAXIMUMLENGTHAAAAAAAAAAAAAAAAAAAAAA" (70 characters)
   - If Chain B lacks proper validation, token creation succeeds

2. **On Chain B**: Call `ValidateTokenInfoExists()` to generate proof

3. **On Chain A**: Call `CrossChainCreateToken()` with:
   - `FromChainId`: Chain B's ID
   - `TransactionBytes`: Transaction calling `ValidateTokenInfoExists`
   - `ParentChainHeight`: Valid height
   - `MerklePath`: Valid proof

4. **Result on Chain A**: 
   - `CrossChainCreateToken` verifies cross-chain proof (passes)
   - Calls `RegisterTokenInfo` which validates regex (passes - matches pattern)
   - Token registered with 70-character symbol (bypasses intended 10/30 limit)

5. **Use in SetMethodFee**: 
   - Authorized caller invokes `SetMethodFee()` specifying the 70-character symbol token
   - `AssertValidFeeToken` validates token exists (passes)
   - 70-character symbol stored in `State.TransactionFees[methodName]`

**Expected vs Actual:**
- **Expected**: Symbol length validation should prevent registration of 70-character symbol
- **Actual**: Symbol registered successfully via cross-chain path, bypassing length limits enforced on local creation

**Success Condition:**
Token with symbol length exceeding `SymbolMaxLength` or `NFTSymbolMaxLength` is successfully registered and usable in method fees, demonstrating the validation gap.

### Notes

While system-level protections exist (128KB state size limit per write, 5MB transaction size limit), these are orders of magnitude larger than the intended 10-30 character symbol limits. The vulnerability represents a failure of defense-in-depth rather than a critical system compromise. The primary concern is maintaining validation consistency across all token registration paths to prevent storage inefficiency and ensure the intended design invariants hold regardless of how tokens enter the system.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L18-21)
```csharp
    private static bool IsValidSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+(-[0-9]+)?$");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L305-311)
```csharp
    private void CheckSymbolLength(string symbol, SymbolType symbolType)
    {
        if (symbolType == SymbolType.Token)
            Assert(symbol.Length <= TokenContractConstants.SymbolMaxLength, "Invalid token symbol length");
        if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
            Assert(symbol.Length <= TokenContractConstants.NFTSymbolMaxLength, "Invalid NFT symbol length");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L48-50)
```csharp
    private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
    {
        AssertValidCreateInput(input, symbolType);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-508)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L7-7)
```csharp
    public const int SymbolMaxLength = 10;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L20-20)
```csharp
    public const int NFTSymbolMaxLength = 30;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L123-132)
```csharp
    private void AssertValidFeeToken(string symbol, long amount)
    {
        AssertValidSymbolAndAmount(symbol, amount);
        var tokenInfo = GetTokenInfo(symbol);
        if (tokenInfo == null)
        {
            throw new AssertionException("Token is not found");
        }
        Assert(tokenInfo.IsBurnable, $"Token {symbol} cannot set as method fee.");
    }
```
