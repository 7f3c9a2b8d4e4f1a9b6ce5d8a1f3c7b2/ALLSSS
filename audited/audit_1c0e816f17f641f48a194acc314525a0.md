### Title
Missing Miner List Validation in NextTerm Allows Consensus Takeover

### Summary
The `ProcessNextTerm` function accepts a `NextTermInput` that is converted to `Round` via `ToRound()` without validating that the miner list matches the legitimate election results from the Election contract. A malicious miner producing the NextTerm block can manipulate the miner list to exclude elected miners or keep themselves in power indefinitely, breaking the democratic election mechanism and compromising consensus integrity for the entire next term.

### Finding Description

**Root Cause:**
The `ToRound()` method simply copies all fields from the input without validation: [1](#0-0) 

When `ProcessNextTerm` processes a term transition, it extracts the miner list directly from the provided `nextRound` and stores it without verification: [2](#0-1) 

**Insufficient Validation:**
The pre-execution validation only checks that term and round numbers increment by 1, but never validates the miner list: [3](#0-2) 

The post-execution validation compares the header Round with the stored state Round, but since the malicious Round was already stored during execution, they match: [4](#0-3) 

**Contrast with Legitimate Flow:**
The legitimate flow calls `GenerateFirstRoundOfNextTerm` which retrieves the correct miner list from the Election contract: [5](#0-4) [6](#0-5) 

However, nothing prevents a malicious miner from generating the legitimate Round and then modifying `RealTimeMinersInformation` before including it in the `NextTermInput`.

### Impact Explanation

**Consensus Compromise:**
- The miner list for the entire next term (potentially days/weeks) is controlled by a single malicious actor
- Legitimate elected miners are excluded from consensus participation
- The attacker can maintain control indefinitely by repeating the attack each term

**Democratic Process Violation:**
- The Election contract's voting mechanism is completely bypassed
- Token holders' votes for candidates become meaningless
- The fundamental governance model is broken

**System-Wide Effects:**
- All consensus-dependent operations (block production, transaction ordering, finality) are controlled by unauthorized miners
- Revenue distribution via mining rewards goes to wrong parties
- Cross-chain operations and LIB calculations may be manipulated

**Severity Justification:** HIGH - This breaks a critical consensus invariant (miner list integrity) and allows complete takeover of the consensus mechanism by subverting the election process.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an authorized miner in the current term (realistic - 17-23 miners exist)
- Attacker must produce the NextTerm block (happens naturally when they're the extra block producer)
- No special privileges beyond being a current miner required

**Attack Complexity:**
1. Monitor for upcoming term transition
2. When producing the NextTerm block, call `GetConsensusExtraDataForNextTerm` to generate legitimate data
3. Parse the returned `AElfConsensusHeaderInformation` 
4. Modify `Round.RealTimeMinersInformation` to desired miner set
5. Create `NextTermInput` with modified Round and proper random number
6. Include in block and sign
7. All validations pass since only term/round number increments are checked

**Feasibility Conditions:**
- Occurs every term transition (regular occurrence)
- No cryptographic barriers since miner controls block production
- No multi-signature or threshold requirements for NextTerm
- Detection would require nodes to independently query Election contract and compare results (not currently implemented)

**Economic Rationality:**
- Cost: Must already be a miner (sunk cost)
- Benefit: Control consensus for entire term, capture all mining rewards, exclude competitors
- Risk: Low if other miners are also compromised or unaware

**Probability:** HIGH - The attack is straightforward for any malicious miner and occurs at predictable intervals (term boundaries).

### Recommendation

**Add Miner List Validation:**
In `RoundTerminateValidationProvider.ValidationForNextTerm`, add validation that compares the provided miner list against Election contract results:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Existing term number check
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // NEW: Validate miner list matches election results (for main chain)
    if (validationContext.IsMainChain)
    {
        var expectedMiners = GetVictoriesFromElection(); // Call Election.GetVictories
        var providedMiners = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        var expectedMinersList = expectedMiners.Pubkeys.Select(p => p.ToHex()).OrderBy(k => k).ToList();
        
        if (!providedMiners.SequenceEqual(expectedMinersList))
            return new ValidationResult { Message = "Miner list does not match election results." };
    }
    
    // Validate IsMinerListJustChanged is true for term transitions
    if (!extraData.Round.IsMinerListJustChanged)
        return new ValidationResult { Message = "IsMinerListJustChanged must be true for term transitions." };

    return new ValidationResult { Success = true };
}
```

**Additional Checks:**
1. Add validation in `ProcessNextTerm` as a defense-in-depth measure
2. Emit an event containing both the provided and expected miner lists for monitoring
3. Add consensus checkpoint that requires 2/3+ miners to agree on NextTerm block

**Test Cases:**
1. Attempt NextTerm with extra miner not in election results - should fail
2. Attempt NextTerm with missing elected miner - should fail  
3. Attempt NextTerm with correct miners but wrong order - should succeed (order doesn't matter)
4. Attempt NextTerm with IsMinerListJustChanged=false - should fail

### Proof of Concept

**Initial State:**
- Current term N with miners: [A, B, C, D, E]
- Election results for term N+1: [B, C, D, F, G] (A is voted out, F and G are new)
- Miner A is scheduled to produce the NextTerm block

**Attack Execution:**

1. **Miner A's malicious node generates NextTerm block:**
   - Calls `GetConsensusExtraDataForNextTerm` → returns Round with miners [B, C, D, F, G]
   - Modifies Round.RealTimeMinersInformation to: [A, B, C, D, E] (keeps old miner set)
   - Sets TermNumber = N+1, RoundNumber = currentRound+1 (passes validation)
   - Creates NextTermInput with modified Round
   - Signs and broadcasts block

2. **Validation passes:**
   - `RoundTerminateValidationProvider.ValidationForNextTerm`: ✓ (only checks term/round increment)
   - `ProcessNextTerm` executes: ✓ (extracts [A, B, C, D, E] from Round)
   - `SetMinerList(miners, termNumber=N+1)`: ✓ (stores [A, B, C, D, E] for term N+1)
   - `ValidateConsensusAfterExecution`: ✓ (header matches stored state)

3. **Result:**
   - Expected: Miners [B, C, D, F, G] authorized for term N+1
   - Actual: Miners [A, B, C, D, E] authorized for term N+1
   - Miners F and G (legitimately elected) cannot produce blocks
   - Miner A (voted out) retains control

**Success Condition:** 
Block is accepted by network, and `State.MinerListMap[N+1]` contains the attacker-chosen miner list instead of election results. Verify by calling `GetMinerList` with term number N+1.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```
