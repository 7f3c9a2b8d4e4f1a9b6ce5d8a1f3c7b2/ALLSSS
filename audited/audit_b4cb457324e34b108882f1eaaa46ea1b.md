### Title
Missing LockTimeMap Validation Allows Immediate Withdrawal of Legacy Votes

### Summary
The `TransferVotingRecordToElectionVotingRecord()` function and `Withdraw()` function read from `State.LockTimeMap[voteId]` without validating that the entry exists. For votes created before the LockTimeMap field was added to the contract, the map returns the default value (0), allowing users to bypass lock time requirements and withdraw tokens immediately, breaking the core voting economic guarantee.

### Finding Description

**Root Cause:**
`State.LockTimeMap` is defined as `MappedState<Hash, long>` [1](#0-0) , which returns the default value (0) for non-existent keys in C#. The code does not validate that a LockTimeMap entry exists before using it.

**Critical Code Paths:**

1. **View Method (Line 339)**: `TransferVotingRecordToElectionVotingRecord()` reads `var lockSeconds = State.LockTimeMap[voteId]` without validation [2](#0-1) . If the entry doesn't exist, it returns 0, causing incorrect calculations:
   - `LockTime = lockSeconds` shows 0
   - `UnlockTimestamp = votingRecord.VoteTimestamp.AddSeconds(lockSeconds)` shows immediate unlock
   - `Weight = GetVotesWeight(votingRecord.Amount, lockSeconds)` calculates weight with 0 lock time

2. **Withdraw Function (Line 634)**: The `Withdraw()` function reads `var claimedLockDays = State.LockTimeMap[input]` without validation [3](#0-2) . The subsequent assertion `Assert(actualLockedTime >= claimedLockDays, ...)` at line 635-636 always passes when `claimedLockDays = 0`, allowing immediate withdrawal.

**Why Existing Protections Fail:**

The `Vote()` function includes an assertion `Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.")` at line 433 [4](#0-3) , which prevents creating duplicate votes. However, this does NOT protect against legacy votes created before the LockTimeMap field was added to the contract. For such votes:
- The Vote contract contains the voting record
- The Election contract's tracking lists contain the voteId
- But `State.LockTimeMap[voteId]` has no entry (returns 0)

### Impact Explanation

**Direct Harm:**
- **Token Lock Bypass**: Users can withdraw tokens from legacy votes immediately without waiting for the lock period to expire, completely breaking the lock time mechanism
- **Voting Economics Broken**: The voting system's fundamental guarantee—that users must commit tokens for a specified duration to receive voting weight—is violated
- **Unfair Advantage**: Users with legacy votes gain voting weight based on long lock times but can retrieve their tokens immediately, while new voters must honor their lock commitments

**Quantified Impact:**
- For each legacy vote with original lock time of L seconds, the user gains L seconds of premature token access
- If a vote was intended to lock 1,000,000 tokens for 365 days, the user can withdraw immediately, gaining 365 days * token value in liquidity advantage
- Vote weight calculations show weight for L seconds of lock time, but tokens are freed in 0 seconds

**Affected Parties:**
- All users with legacy votes can exploit this (if such votes exist)
- The protocol loses its economic security guarantee
- Other voters are disadvantaged as their tokens remain locked while exploiters' tokens are free

**Severity Justification:**
HIGH severity because it completely bypasses a core protocol invariant (token lock/unlock correctness), allowing theft of economic value (premature token access) and breaking voting system integrity.

### Likelihood Explanation

**Preconditions:**
1. The Election contract was deployed initially without the `LockTimeMap` field
2. Users created votes during that period
3. The contract was upgraded to add `LockTimeMap`
4. No migration was performed to populate LockTimeMap entries for existing votes

**Attacker Capabilities:**
- Any user who owns a legacy vote (no special privileges required)
- Simply calls the public `Withdraw(voteId)` function [3](#0-2) 

**Execution Practicality:**
1. User identifies their legacy voteId from `ElectorVotes` tracking
2. Calls `Withdraw(voteId)`
3. Line 634 retrieves `claimedLockDays = 0`
4. Line 635-636 assertion passes immediately
5. Lines 662-664 unlock and return tokens

**Feasibility Conditions:**
- **Cannot determine from code**: The likelihood depends entirely on whether the LockTimeMap field was added in a contract upgrade (HIGH likelihood if true) or has existed since initial deployment (NO vulnerability if true)
- **No migration code found**: No code exists to backfill LockTimeMap for legacy votes [5](#0-4) 

**Detection Constraints:**
Low detectability - withdrawals appear normal in transaction logs; only analyzing state data would reveal premature withdrawals

### Recommendation

**Immediate Fix:**
Add explicit validation in both functions to ensure LockTimeMap entries exist before use:

1. In `TransferVotingRecordToElectionVotingRecord()` (line 339):
```csharp
var lockSeconds = State.LockTimeMap[voteId];
Assert(lockSeconds > 0, "Vote lock time not found. Legacy vote may require migration.");
```

2. In `Withdraw()` (line 634):
```csharp
var claimedLockDays = State.LockTimeMap[input];
Assert(claimedLockDays > 0, "Vote lock time not found. Cannot withdraw legacy vote without migration.");
```

**Migration Strategy:**
If legacy votes exist, implement a migration function that:
1. Enumerates all vote records from the Vote contract
2. For each voteId where `State.LockTimeMap[voteId] == 0`:
   - Calculate original lock time from vote metadata or set a reasonable default
   - Populate `State.LockTimeMap[voteId]` with the calculated value
3. Make this migration function callable only by contract admin/governance

**Test Cases:**
1. Attempt to withdraw a vote with missing LockTimeMap entry (should fail)
2. Attempt to call view methods on votes with missing LockTimeMap entries (should fail gracefully or return error)
3. Verify migration correctly populates LockTimeMap for all existing votes

### Proof of Concept

**Required Initial State:**
- Assume the Election contract was deployed initially without `State.LockTimeMap`
- User Alice created a vote at timestamp T0 with 365-day lock period (31,536,000 seconds)
- Contract was upgraded to add `State.LockTimeMap` field
- Alice's voteId exists in `State.ElectorVotes[Alice].ActiveVotingRecordIds`
- `State.LockTimeMap[voteId]` has no entry (would return 0)

**Exploitation Steps:**
1. At timestamp T0 + 1 day (86,400 seconds into lock period)
2. Alice calls `Withdraw(voteId)`
3. Line 631: `votingRecord` retrieved successfully
4. Line 633: `actualLockedTime = 86,400 seconds`
5. Line 634: `claimedLockDays = State.LockTimeMap[voteId] = 0` (missing entry)
6. Line 635-636: Assertion `86,400 >= 0` **PASSES** (should require 31,536,000 seconds)
7. Lines 662-664: Tokens unlocked and withdrawn successfully

**Expected Result:**
Withdrawal should fail with "Still need 364 days to unlock your token."

**Actual Result:**
Withdrawal succeeds immediately, bypassing 364 days of required lock time.

**Success Condition:**
Alice regains access to locked tokens 364 days early, breaking the 365-day lock commitment while retaining all voting weight benefits from that commitment period.

### Notes

The vulnerability's real-world impact depends on whether legacy votes exist in the deployed contract. This requires examining:
1. The contract's deployment history
2. Whether `LockTimeMap` was present in the initial version
3. Whether any votes were created before `LockTimeMap` was added

If `LockTimeMap` has existed since initial deployment, this is not a vulnerability. However, the lack of explicit validation remains a code quality issue that should be addressed to prevent future upgrade-related problems and to fail gracefully rather than silently using default values.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L38-38)
```csharp
    public MappedState<Hash, long> LockTimeMap { get; set; }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L337-355)
```csharp
    private ElectionVotingRecord TransferVotingRecordToElectionVotingRecord(VotingRecord votingRecord, Hash voteId)
    {
        var lockSeconds = State.LockTimeMap[voteId];
        return new ElectionVotingRecord
        {
            Voter = votingRecord.Voter,
            Candidate = GetNewestPubkey(votingRecord.Option),
            Amount = votingRecord.Amount,
            TermNumber = votingRecord.SnapshotNumber,
            VoteId = voteId,
            LockTime = lockSeconds,
            VoteTimestamp = votingRecord.VoteTimestamp,
            WithdrawTimestamp = votingRecord.WithdrawTimestamp,
            UnlockTimestamp = votingRecord.VoteTimestamp.AddSeconds(lockSeconds),
            IsWithdrawn = votingRecord.IsWithdrawn,
            Weight = GetVotesWeight(votingRecord.Amount, lockSeconds),
            IsChangeTarget = votingRecord.IsChangeTarget
        };
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L421-467)
```csharp
    public override Hash Vote(VoteMinerInput input)
    {
        // Check candidate information map instead of candidates. 
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);

        var electorPubkey = Context.RecoverPublicKey();

        var lockSeconds = (input.EndTimestamp - Context.CurrentBlockTime).Seconds;
        AssertValidLockSeconds(lockSeconds);

        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;

        UpdateElectorInformation(electorPubkey, input.Amount, voteId);

        var candidateVotesAmount = UpdateCandidateInformation(input.CandidatePubkey, input.Amount, voteId);

        LockTokensOfVoter(input.Amount, voteId);
        TransferTokensToVoter(input.Amount);
        CallVoteContractVote(input.Amount, input.CandidatePubkey, voteId);
        AddBeneficiaryToVoter(GetVotesWeight(input.Amount, lockSeconds), lockSeconds, voteId);

        var rankingList = State.DataCentersRankingList.Value;
        if (rankingList.DataCenters.ContainsKey(input.CandidatePubkey))
        {
            rankingList.DataCenters[input.CandidatePubkey] =
                rankingList.DataCenters[input.CandidatePubkey].Add(input.Amount);
            State.DataCentersRankingList.Value = rankingList;
        }
        else
        {
            if (rankingList.DataCenters.Count < GetValidationDataCenterCount())
            {
                State.DataCentersRankingList.Value.DataCenters.Add(input.CandidatePubkey,
                    candidateVotesAmount);
                AddBeneficiary(input.CandidatePubkey);
            }
            else
            {
                TryToBecomeAValidationDataCenter(input, candidateVotesAmount, rankingList);
            }
        }

        return voteId;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L629-679)
```csharp
    public override Empty Withdraw(Hash input)
    {
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input);

        var actualLockedTime = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockDays = State.LockTimeMap[input];
        Assert(actualLockedTime >= claimedLockDays,
            $"Still need {claimedLockDays.Sub(actualLockedTime).Div(86400)} days to unlock your token.");

        var voterPublicKey = Context.RecoverPublicKey();

        var voterVotes = GetElectorVote(voterPublicKey);

        Assert(voterVotes != null, $"Voter {Context.Sender.ToBase58()} never votes before");

        voterVotes.ActiveVotingRecordIds.Remove(input);
        voterVotes.WithdrawnVotingRecordIds.Add(input);
        voterVotes.ActiveVotedVotesAmount = voterVotes.ActiveVotedVotesAmount.Sub(votingRecord.Amount);

        State.ElectorVotes[Context.Sender.ToBase58()] = voterVotes;

        // Update Candidate's Votes information.
        var newestPubkey = GetNewestPubkey(votingRecord.Option);
        var candidateVotes = State.CandidateVotes[newestPubkey];

        Assert(candidateVotes != null, $"Newest pubkey {newestPubkey} is invalid. Old pubkey is {votingRecord.Option}");

        candidateVotes.ObtainedActiveVotingRecordIds.Remove(input);
        candidateVotes.ObtainedWithdrawnVotingRecordIds.Add(input);
        candidateVotes.ObtainedActiveVotedVotesAmount =
            candidateVotes.ObtainedActiveVotedVotesAmount.Sub(votingRecord.Amount);
        State.CandidateVotes[newestPubkey] = candidateVotes;

        UnlockTokensOfVoter(input, votingRecord.Amount);
        RetrieveTokensFromVoter(votingRecord.Amount);
        WithdrawTokensOfVoter(input);
        if (!State.WeightsAlreadyFixedMap[input])
        {
            RemoveBeneficiaryOfVoter();
            State.WeightsAlreadyFixedMap.Remove(input);
        }

        var rankingList = State.DataCentersRankingList.Value;
        if (!rankingList.DataCenters.ContainsKey(newestPubkey)) return new Empty();
        rankingList.DataCenters[newestPubkey] =
            rankingList.DataCenters[newestPubkey].Sub(votingRecord.Amount);
        UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, newestPubkey);
        State.DataCentersRankingList.Value = rankingList;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L22-52)
```csharp
    public override Empty InitialElectionContract(InitialElectionContractInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");

        State.Candidates.Value = new PubkeyList();

        State.MinimumLockTime.Value = input.MinimumLockTime;
        State.MaximumLockTime.Value = input.MaximumLockTime;

        State.TimeEachTerm.Value = input.TimeEachTerm;

        State.MinersCount.Value = input.MinerList.Count;
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
        foreach (var pubkey in input.MinerList)
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey
            };

        State.CurrentTermNumber.Value = 1;

        State.DataCentersRankingList.Value = new DataCenterRankingList();

        State.Initialized.Value = true;

        return new Empty();
    }
```
