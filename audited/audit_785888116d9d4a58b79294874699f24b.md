### Title
Built-in NFT Types Can Be Removed via RemoveNFTType, Breaking Cross-Chain Synchronization and Protocol Creation

### Summary
The `RemoveNFTType()` function lacks validation to prevent removal of the 10 built-in NFT types (XX/Any, AR/Art, MU/Music, DN/DomainNames, VW/VirtualWorlds, TC/TradingCards, CO/Collectables, SP/Sports, UT/Utility, BA/Badges) initialized in `InitialNFTTypeNameMap()`. [1](#0-0)  Removing a built-in type breaks cross-chain synchronization for all existing NFT protocols using that type and prevents creation of new protocols with that type, causing permanent operational failure.

### Finding Description

**Location**: `RemoveNFTType()` in NFTContract_Create.cs performs only basic validation before removing NFT type mappings. [2](#0-1) 

**Root Cause**: The function validates only that: (1) sender is Parliament default address, (2) short name is 2 characters, and (3) the short name exists. There is **no check** to distinguish between built-in types and custom-added types. [3](#0-2) 

**Why Protections Fail**: The 10 built-in types are initialized in `InitialNFTTypeNameMap()` and stored in the same state mappings (`NFTTypeFullNameMap`, `NFTTypeShortNameMap`, `NFTTypes`) as custom types. [4](#0-3)  Since `RemoveNFTType()` treats all types identically, built-in types can be removed just like custom types.

**Execution Path Leading to Failure**:

1. **CrossChainCreate failure**: When syncing an existing NFT protocol to a sidechain, `CrossChainCreate()` extracts the 2-character type prefix from the symbol and attempts to look up the full name. [5](#0-4)  If the type mapping was removed, the lookup returns null and the transaction fails with "Full name of {shortName} not found."

2. **Create failure**: When creating new protocols on mainchain, `Create()` calls `GetSymbol()` which looks up the short name from the full NFT type name. [6](#0-5)  If removed, it throws "Short name of NFT Type {nftType} not found."

### Impact Explanation

**Operational Impact - Cross-Chain Integrity Violation**:

If a built-in type like "VW" (VirtualWorlds) is removed:

1. **All existing NFT protocols** with symbols starting "VW" (e.g., "VW12345678") can no longer be synchronized to new sidechains via `CrossChainCreate()`. The cross-chain indexing mechanism depends on reconstructing the full NFT type from the symbol prefix. [7](#0-6) 

2. **No new NFT protocols** can be created with `NftType = "VirtualWorlds"` on mainchain, as the `Create()` method will fail during symbol generation. [8](#0-7) 

3. **Affected users**: All holders of NFTs from protocols using the removed type lose cross-chain interoperability. Protocol creators cannot expand to new sidechains.

4. **Irreversibility**: While the type can be re-added, existing protocols created before removal still have inconsistent state, and cross-chain synchronization may have been permanently missed for time-sensitive operations.

**Severity Justification**: HIGH - This breaks a critical invariant of the cross-chain NFT system. The 10 built-in types are defined in the protocol specification [9](#0-8)  and are intended to be permanent protocol constants, not mutable configuration.

### Likelihood Explanation

**Attacker Capabilities**: Requires Parliament default organization approval via governance proposal. This is not a direct attack by an untrusted party.

**Attack Complexity**: Low - a single `RemoveNFTType("VW")` call with Parliament authorization.

**Feasibility Conditions**: 
- **Governance Error Scenario**: Parliament approves a proposal to "clean up unused types" without realizing built-in types are in use by existing protocols. Given the lack of technical safeguard, governance mistakes are a realistic threat vector.
- **Compromised Governance**: If Parliament is compromised (though trusted), the lack of fail-safes means built-in types can be weaponized to DoS cross-chain operations.

**Detection/Constraints**: The removal would be visible on-chain via `NFTTypeRemoved` event [10](#0-9)  but damage occurs immediately for all dependent protocols.

**Probability**: MEDIUM - While requiring governance approval, the absence of any technical safeguard makes this a design vulnerability. Governance systems should have defense-in-depth; critical protocol constants should be immutable or protected by additional checks.

### Recommendation

**Code-Level Mitigation**: Add validation in `RemoveNFTType()` to prevent removal of built-in types:

```csharp
public override Empty RemoveNFTType(StringValue input)
{
    AssertSenderIsParliamentDefaultAddress();
    InitialNFTTypeNameMap();
    Assert(input.Value.Length == 2, "Incorrect short name.");
    Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
    
    // NEW: Prevent removal of built-in types
    var builtInTypes = new[] { "XX", "AR", "MU", "DN", "VW", "TC", "CO", "SP", "UT", "BA" };
    Assert(!builtInTypes.Contains(input.Value), 
        $"Cannot remove built-in NFT type {input.Value}. Built-in types are permanent protocol constants.");
    
    var fullName = State.NFTTypeFullNameMap[input.Value];
    State.NFTTypeFullNameMap.Remove(input.Value);
    State.NFTTypeShortNameMap.Remove(fullName);
    var nftTypes = State.NFTTypes.Value;
    nftTypes.Value.Remove(input.Value);
    State.NFTTypes.Value = nftTypes;
    Context.Fire(new NFTTypeRemoved { ShortName = input.Value });
    return new Empty();
}
```

**Invariant Check**: Add assertion that the 10 built-in type mappings always exist when accessed.

**Test Case**: Add regression test attempting to remove "VW" type and verifying it fails with appropriate error message, then confirming CrossChainCreate still works for VirtualWorlds protocols.

### Proof of Concept

**Initial State**: 
- NFT contract deployed with 10 built-in types initialized
- Existing NFT protocol "VW12345678" (VirtualWorlds type) created and operating on mainchain
- New sidechain being set up to sync existing protocols

**Attack Steps**:
1. Parliament creates and approves proposal to call `RemoveNFTType("VW")`
2. Proposal executes successfully - "VW" mapping removed from all state
3. Event `NFTTypeRemoved { ShortName = "VW" }` emitted

**Expected Result**: Transaction should fail with "Cannot remove built-in NFT type"

**Actual Result**: 
- Transaction succeeds
- Mapping removed: `State.NFTTypeFullNameMap["VW"]` now returns null
- Subsequent `CrossChainCreate({ Symbol: "VW12345678" })` on sidechain fails with "Full name of VW not found"
- Subsequent `Create({ NftType: "VirtualWorlds" })` on mainchain fails with "Short name of NFT Type VirtualWorlds not found"

**Success Condition**: All VirtualWorlds NFT protocols lose cross-chain synchronization capability and no new VirtualWorlds protocols can be created.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L28-34)
```csharp
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L39-63)
```csharp
    private NFTTypes InitialNFTTypeNameMap()
    {
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;

        var nftTypes = new NFTTypes();
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;

        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }

        return nftTypes;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-73)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);

        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;

        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
            ProtocolName = tokenCreateInput.TokenName,
            IsTokenIdReuse = input.IsTokenIdReuse,
            IssueChainId = tokenCreateInput.IssueChainId,
            IsBurnable = tokenCreateInput.IsBurnable,
            NftType = input.NftType
        };
        State.NftProtocolMap[symbol] = protocolInfo;

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = tokenCreateInput.Symbol,
            Creator = tokenCreateInput.Issuer,
            IsBurnable = tokenCreateInput.IsBurnable,
            IssueChainId = tokenCreateInput.IssueChainId,
            ProtocolName = tokenCreateInput.TokenName,
            TotalSupply = tokenCreateInput.TotalSupply,
            Metadata = protocolInfo.Metadata,
            BaseUri = protocolInfo.BaseUri,
            IsTokenIdReuse = protocolInfo.IsTokenIdReuse,
            NftType = protocolInfo.NftType
        });

        return new StringValue
        {
            Value = symbol
        };
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-129)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;

        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = input.Symbol,
            Creator = nftProtocolInfo.Creator,
            IsBurnable = nftProtocolInfo.IsBurnable,
            IssueChainId = nftProtocolInfo.IssueChainId,
            ProtocolName = nftProtocolInfo.ProtocolName,
            TotalSupply = nftProtocolInfo.TotalSupply,
            Metadata = nftProtocolInfo.Metadata,
            BaseUri = nftProtocolInfo.BaseUri,
            IsTokenIdReuse = isTokenIdReuse,
            NftType = nftProtocolInfo.NftType
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L152-169)
```csharp
    public override Empty RemoveNFTType(StringValue input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        Assert(input.Value.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
        var fullName = State.NFTTypeFullNameMap[input.Value];
        State.NFTTypeFullNameMap.Remove(input.Value);
        State.NFTTypeShortNameMap.Remove(fullName);
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Remove(input.Value);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeRemoved
        {
            ShortName = input.Value
        });
        return new Empty();
    }
```

**File:** protobuf/nft_contract.proto (L314-325)
```text
enum NFTType {
    ANY = 0;
    ART = 1;
    MUSIC = 2;
    DOMAIN_NAMES = 3;
    VIRTUAL_WORLDS = 4;
    TRADING_CARDS = 5;
    COLLECTABLES = 6;
    SPORTS = 7;
    UTILITY = 8;
    BADGES = 9;
}
```
