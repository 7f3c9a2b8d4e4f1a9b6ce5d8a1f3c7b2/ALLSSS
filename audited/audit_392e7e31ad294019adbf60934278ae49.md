### Title
Quadratic Voting Completely Bypassed - Users Pay Linear Cost Instead of Quadratic Cost

### Summary
The quadratic voting mechanism in VoteContract is fundamentally broken because each vote transaction generates a new VoteId based on the changing VotesAmount state variable. Since QuadraticVotesCountMap tracks vote counts per VoteId rather than per voter, each new vote starts with a counter of 0, allowing attackers to cast unlimited votes at a constant linear cost instead of the intended increasing quadratic cost.

### Finding Description

The vulnerability exists in the Vote() function's interaction with VoteId generation. When a voting item has `IsQuadratic=true` and `IsLockToken=true`, the system is supposed to charge users an increasing amount for each subsequent vote (quadratic voting). [1](#0-0) 

The quadratic cost calculation relies on `QuadraticVotesCountMap[input.VoteId]` to track how many times a specific VoteId has been used. However, the VoteId is generated in the `AssertValidVoteInput` function: [2](#0-1) 

The critical flaw is on line 397: the VoteId is generated using `votingResult.VotesAmount.ToBytes(false)` as input. Since VotesAmount is updated after each vote: [3](#0-2) 

Each vote transaction generates a **different VoteId** because VotesAmount changes. Since QuadraticVotesCountMap is indexed by VoteId: [4](#0-3) 

Every new VoteId starts with a vote count of 0, so the counter never accumulates across multiple votes from the same user.

**Execution Flow:**
1. First vote: VotesAmount=0 → VoteId1 generated → QuadraticVotesCountMap[VoteId1]=1 → cost = ticketCost × 1
2. Second vote: VotesAmount=100 → VoteId2 generated (different!) → QuadraticVotesCountMap[VoteId2]=1 → cost = ticketCost × 1 (should be × 2)
3. Third vote: VotesAmount=200 → VoteId3 generated (different!) → QuadraticVotesCountMap[VoteId3]=1 → cost = ticketCost × 1 (should be × 3)

### Impact Explanation

This vulnerability completely defeats the purpose of quadratic voting, which is designed to prevent vote concentration by making it increasingly expensive to cast additional votes.

**Quantified Impact:**
- For N votes, attacker pays: N × ticketCost
- Expected quadratic cost: (1+2+3+...+N) × ticketCost = N(N+1)/2 × ticketCost
- For 10 votes: attacker pays 10 units instead of 55 units (82% savings)
- For 100 votes: attacker pays 100 units instead of 5,050 units (98% savings)

**Protocol Damage:**
- Wealthy attackers can manipulate voting outcomes at linear cost instead of quadratic cost
- The Sybil resistance mechanism is completely broken
- All governance decisions using quadratic voting are compromised
- Token lock requirements become meaningless as the cost doesn't scale

**Affected Parties:**
- Any voting item with `IsQuadratic=true`
- All legitimate voters who expected fair quadratic cost scaling
- Protocol governance integrity

**Severity Justification:** Critical - This is a complete bypass of a core security mechanism with direct economic impact and governance manipulation potential.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Any user with sufficient tokens to cover initial TicketCost
- No special permissions or admin access needed
- Public Vote() method is the entry point

**Attack Complexity:**
- Extremely simple: just call Vote() multiple times in separate transactions
- No sophisticated timing, frontrunning, or state manipulation required
- Works reliably every time due to deterministic VoteId generation

**Feasibility Conditions:**
- Voting item must have `IsQuadratic=true` and `IsLockToken=true`
- Attacker needs enough tokens to cover N × ticketCost (linear cost)
- No rate limiting or per-user vote count checks exist in the code

**Detection/Operational Constraints:**
- The exploit leaves normal-looking transaction trails
- Each vote creates a valid VotingRecord and locks tokens properly
- Only statistical analysis of multiple VoteIds from same voter would reveal the attack
- No on-chain mechanism prevents or detects this behavior

**Probability:** Nearly certain for any determined attacker, as the vulnerability is inherent in the design and requires only repeated public method calls.

### Recommendation

**Immediate Fix:**
Change the quadratic vote counting to track votes per voter address, not per VoteId. Modify the code as follows:

1. Change QuadraticVotesCountMap state definition to map from a composite key of (VotingItemId, Voter Address):
```csharp
// In VoteContractState.cs
public MappedState<Hash, Address, long> QuadraticVotesCountMap { get; set; }
```

2. Update the Vote() function to use voter address and voting item ID:
```csharp
// In VoteContract.cs Vote() method
if (votingItem.IsQuadratic)
{
    var voterId = Context.Self; // or input.Voter for delegated voting
    var key = Hash.FromTwoHashes(input.VotingItemId, Hash.FromBytes(voterId.Value));
    var currentVotesCount = State.QuadraticVotesCountMap[key].Add(1);
    State.QuadraticVotesCountMap[key] = currentVotesCount;
    amount = votingItem.TicketCost.Mul(currentVotesCount);
}
```

3. Update Withdraw() function to properly decrement the counter when votes are withdrawn.

**Invariant Checks to Add:**
- Assert that quadratic vote count for a voter never decreases except during withdrawal
- Add view method to query total quadratic votes cast by a specific voter for a voting item
- Add maximum vote limit per voter to prevent integer overflow

**Test Cases to Prevent Regression:**
1. Test that same voter calling Vote() 3 times pays 1+2+3 = 6× ticketCost
2. Test that different voters each pay 1× ticketCost for their first vote
3. Test that withdrawing and re-voting properly maintains/resets the counter
4. Test boundary case with maximum votes to ensure no overflow

### Proof of Concept

**Required Initial State:**
- VotingItem registered with: IsQuadratic=true, IsLockToken=true, TicketCost=100, AcceptedCurrency="ELF"
- Attacker has balance of 10,000 ELF tokens
- Voting period is active

**Transaction Steps:**
1. Attacker calls `Vote(votingItemId, voter=attacker, amount=100, option="A", voteId=null, isChangeTarget=false)`
   - Expected: Cost 100 ELF (first vote), VoteId1 created
   - Actual: Cost 100 ELF ✓

2. Attacker calls `Vote(votingItemId, voter=attacker, amount=100, option="A", voteId=null, isChangeTarget=false)` again
   - Expected: Cost 200 ELF (second vote should be 2× ticketCost)
   - Actual: Cost 100 ELF ✗ (VoteId2 created with counter=1)

3. Attacker calls `Vote(votingItemId, voter=attacker, amount=100, option="A", voteId=null, isChangeTarget=false)` again
   - Expected: Cost 300 ELF (third vote should be 3× ticketCost)
   - Actual: Cost 100 ELF ✗ (VoteId3 created with counter=1)

**Expected vs Actual Result:**
- Expected total cost for 3 votes: 100 + 200 + 300 = 600 ELF
- Actual total cost for 3 votes: 100 + 100 + 100 = 300 ELF
- Attacker saves 50% and can continue indefinitely at linear cost

**Success Condition:**
Query `GetVotedItems(attacker)` and observe 3 different VoteIds all with amount=100. Query `QuadraticVotesCountMap[VoteId1]`, `[VoteId2]`, `[VoteId3]` and observe all return 1 instead of cumulative counts.

### Notes

The vulnerability stems from a fundamental design flaw where VoteId generation depends on mutable state (VotesAmount) rather than immutable voter identity. The Election contract has a similar pattern but it may be intentional there to allow separate independent votes. For the Vote contract's quadratic voting feature, this breaks the core Sybil resistance mechanism entirely.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L98-103)
```csharp
        else
        {
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L390-398)
```csharp
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L30-33)
```csharp
    /// <summary>
    ///     Vote Id -> Votes Count
    /// </summary>
    public MappedState<Hash, long> QuadraticVotesCountMap { get; set; }
```
