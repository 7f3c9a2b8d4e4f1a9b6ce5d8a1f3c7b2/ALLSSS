### Title
Colluding Miners Can Prevent Treasury Release by Blocking Term Transitions

### Summary
A coalition of 1/3+ miners can prevent term changes indefinitely by refusing to mine blocks. This blocks the execution of `Treasury.Release`, causing mining rewards to accumulate in the Treasury contract without distribution to voters, citizens, and other beneficiaries. The vulnerability stems from a mismatch between how the consensus threshold is calculated (total miners) versus how miners are counted for term change decisions (only miners who have mined).

### Finding Description

The vulnerability exists in the term change decision mechanism across multiple components:

**Decision Point**: The `GetConsensusBehaviourToTerminateCurrentRound()` method determines whether to trigger `NextRound` or `NextTerm` behavior. [1](#0-0) 

**Root Cause - Threshold Mismatch**: The `NeedToChangeTerm()` method filters miners to only those with `ActualMiningTimes.Any()` (miners who have actually mined blocks), then checks if enough of them show it's time to change term. [2](#0-1) 

However, `MinersCountOfConsent` is calculated based on the TOTAL miner count, not the count of miners who have mined. [3](#0-2) 

**Critical Impact Point**: `Treasury.Release` is ONLY called in `ProcessNextTerm()`, never in `ProcessNextRound()`. [4](#0-3) 

**Why Protections Fail**:

1. **Evil Miner Detection Insufficient**: Miners who don't mine accumulate missed time slots and are eventually marked as evil after exceeding `TolerableMissedTimeSlotsCount` (4,320 slots ≈ 3 days). [5](#0-4) 

However, evil miner detection in `ProcessNextRound` only marks miners, it doesn't force a term change. [6](#0-5) 

2. **Miner Replacement Doesn't Help**: While evil miners can be replaced mid-term, replacement happens during `GenerateNextRoundInformation`, and newly added miners start with no `ActualMiningTimes`, so they don't immediately contribute to the term change threshold. [7](#0-6) 

3. **Default Term Period**: With a default period of 7 days (604,800 seconds), malicious miners only need to sustain the attack for one term to prevent one treasury release. [8](#0-7) 

### Impact Explanation

**Direct Fund Impact**:
- Mining rewards continue to be donated to Treasury via `DonateMiningReward()` during `ProcessNextTerm` of PREVIOUS successful term changes. [9](#0-8) 

- However, without `Treasury.Release` being called, these funds never get distributed to profit schemes (Basic Reward, Backup Subsidy, Citizen Welfare, Welcome Reward, Flexible Reward).
- Funds accumulate indefinitely in the Treasury contract.

**Affected Parties**:
- **Voters/Token Holders**: Lose expected staking dividends from profit distribution
- **Citizens**: Lose welfare rewards
- **Backup Nodes**: Lose subsidy rewards  
- **Protocol Economics**: Incentive mechanisms break down, reducing participation

**Quantification**:
- With 7 miners and default mining reward of 12,500,000 tokens per block, each missed term prevents distribution of `blocks_in_term * 12,500,000` tokens
- Attack can be repeated across multiple terms for cumulative effect

### Likelihood Explanation

**Attacker Capabilities**:
- Requires control of ⌈(total_miners + 1) / 3⌉ miners (e.g., 3 out of 7 miners = 43%)
- This is a realistic threshold for a coordinated attack by a minority coalition

**Attack Complexity**: 
- **Low** - Attackers simply abstain from mining (passive attack)
- No special transactions or exploits needed
- Just requires coordination among colluding miners

**Feasibility Conditions**:
- No special permissions required beyond being elected as miners
- Works on mainchain (sidechain always uses NextRound behavior) [10](#0-9) 

**Detection Constraints**:
- Attack is visible (miners are missing blocks) but doesn't immediately trigger protections
- Evil miner detection takes 3 days, doesn't prevent the attack at term boundary (day 7)
- By the time miners are replaced, the term change opportunity is already missed

**Economic Rationality**:
- Colluding miners lose block rewards during attack period
- However, they may be motivated by:
  - Governance manipulation (preventing reward distribution changes voting power dynamics)
  - External incentives (paid by competing interests)
  - Desire to harm protocol economics
- Cost is bounded (7 days of lost mining rewards) vs. potentially large impact (all treasury distributions delayed)

### Recommendation

**Primary Fix - Adjust Threshold Calculation**:

Modify `NeedToChangeTerm()` in `Round.cs` to calculate the threshold based on active miners rather than total miners:

```csharp
public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
{
    var minersWithActualMiningTimes = RealTimeMinersInformation.Values
        .Where(m => m.ActualMiningTimes.Any())
        .ToList();
    
    // Use active miners count for threshold, or fall back to forcing term change
    var activeMinersConsent = Math.Max(minersWithActualMiningTimes.Count.Mul(2).Div(3).Add(1), 1);
    
    return minersWithActualMiningTimes
               .Select(m => m.ActualMiningTimes.Last())
               .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp, t, currentTermNumber, periodSeconds))
           >= activeMinersConsent;
}
```

**Alternative Fix - Force Term Change**:

Add a fallback in `GetConsensusBehaviourToTerminateCurrentRound()` to force `NextTerm` after the period definitively expires, regardless of miner participation:

```csharp
protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
{
    // Check if period has definitively expired (e.g., 150% of normal period)
    var currentBlockTime = Context.CurrentBlockTime;
    var timeSinceStart = (currentBlockTime - _blockchainStartTimestamp).Seconds;
    var periodsElapsed = timeSinceStart.Div(_periodSeconds);
    
    if (periodsElapsed > CurrentRound.TermNumber) {
        // Force term change if we're clearly past term boundary
        return AElfConsensusBehaviour.NextTerm;
    }
    
    // Original logic...
    return CurrentRound.RoundNumber == 1 || 
           !CurrentRound.NeedToChangeTerm(...) ||
           CurrentRound.RealTimeMinersInformation.Keys.Count == 1
        ? AElfConsensusBehaviour.NextRound
        : AElfConsensusBehaviour.NextTerm;
}
```

**Test Cases to Add**:
1. Test term change with 33% miners not mining
2. Test term change with 40% miners not mining  
3. Test term change with evil miners detected but not replaced before term boundary
4. Verify `Treasury.Release` is called even with partial miner participation

### Proof of Concept

**Initial State**:
- 7 active miners in current term
- Term period configured as 7 days (604,800 seconds)
- Treasury has funds from previous term's mining rewards

**Attack Sequence**:

1. **T=0 (Term Start)**: 3 miners coordinate to stop mining (43% of miners)
   - They simply don't call consensus methods or produce blocks
   - 4 honest miners continue mining normally

2. **T=0 to T=7 days**: Throughout the term
   - Only 4 miners have `ActualMiningTimes` entries
   - `MinersCountOfConsent` = (7 × 2 ÷ 3) + 1 = 5 (based on total count)
   - Missed time slots accumulate for non-mining miners

3. **T=3 days**: Evil miner detection triggers
   - 3 non-mining miners marked as evil in `ProcessNextRound`
   - Replacement initiated in `GenerateNextRoundInformation`
   - BUT: Replacement miners added with empty `ActualMiningTimes`

4. **T=7 days (Term Boundary)**: Miner produces block to terminate round
   - `GetConsensusCommand` called by miner
   - `GetConsensusBehaviourToTerminateCurrentRound` evaluates current round
   - `NeedToChangeTerm` checks: only 4 miners with `ActualMiningTimes` showing term elapsed
   - 4 < 5 (MinersCountOfConsent threshold)
   - Returns `false`
   
5. **Result**: `GetConsensusBehaviourToTerminateCurrentRound` returns `NextRound` instead of `NextTerm`

6. **Execution**: `ProcessConsensusInformation` routes to `ProcessNextRound` not `ProcessNextTerm` [11](#0-10) 

7. **Impact Verification**:
   - `Treasury.Release` never called (only called in `ProcessNextTerm`)
   - Mining rewards donated during previous successful term remain undistributed
   - Treasury contract balance increases without corresponding `Release` events
   - Round number increments but term number stays the same

**Expected Result**: At day 7, `NextTerm` triggers, `Treasury.Release` distributes accumulated funds

**Actual Result**: At day 7, `NextRound` triggers, funds remain locked in Treasury, no distribution occurs

**Success Condition**: Monitor for absence of `ReleaseInput` transactions to Treasury contract at expected term boundaries combined with continued `DonateInput` transactions from mining rewards.

### Notes

This vulnerability affects mainchain consensus only, as sidechains always return `NextRound` behavior and have no treasury release mechanism tied to term changes. The attack is particularly concerning because it requires only minority miner coordination (33-43% depending on total miner count) and can be sustained with minimal cost to attackers while significantly disrupting protocol economics.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L14-20)
```csharp
        public MainChainConsensusBehaviourProvider(Round currentRound, string pubkey, int maximumBlocksCount,
            Timestamp currentBlockTime, Timestamp blockchainStartTimestamp, long periodSeconds) : base(currentRound,
            pubkey, maximumBlocksCount, currentBlockTime)
        {
            _blockchainStartTimestamp = blockchainStartTimestamp;
            _periodSeconds = periodSeconds;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L37-43)
```csharp
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-342)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/ConsensusOptions.cs (L12-12)
```csharp
    public long PeriodSeconds { get; set; } = 604800;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```
