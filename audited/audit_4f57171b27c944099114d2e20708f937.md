### Title
Integer Overflow in Withdraw Function Causes Permanent Token Lock Denial of Service

### Summary
The `Withdraw` function in TokenHolderContract uses unchecked `MinimumLockMinutes` values in timestamp arithmetic that can cause overflow exceptions, permanently preventing users from withdrawing their locked tokens. When a scheme manager sets `MinimumLockMinutes` to extremely large values (e.g., `Int64.MaxValue`), the `AddMinutes` operation will throw an `OverflowException`, making all withdrawal attempts fail and locking users' funds indefinitely.

### Finding Description

The vulnerability exists in the TokenHolderContract's withdrawal mechanism across two locations:

**Location 1: CreateScheme - Missing Input Validation**

The `CreateScheme` function accepts `MinimumLockMinutes` without any validation and directly stores it in the scheme state. [1](#0-0) 

**Location 2: Withdraw - Vulnerable Overflow Point**

The `Withdraw` function performs a time comparison using `AddMinutes` without checking if the arithmetic will overflow. [2](#0-1) 

**Root Cause Analysis:**

The `AddMinutes` extension method multiplies the minutes parameter by 60 to convert to seconds using the `Mul` SafeMath function: [3](#0-2) 

The `Mul` function uses checked arithmetic that throws `OverflowException` on overflow: [4](#0-3) 

**Why Protections Fail:**

While AElf uses checked arithmetic to prevent silent overflows, this actually creates a DoS vulnerability in this context. When `MinimumLockMinutes > Int64.MaxValue / 60 (â‰ˆ153,722,867,280,912,930)`, the multiplication `minutes * 60` overflows and throws an exception, causing the entire `Withdraw` transaction to revert. Unlike the Election contract which validates lock times with both minimum and maximum bounds: [5](#0-4) 

The TokenHolderContract has no such validation, allowing arbitrarily large or even negative values.

### Impact Explanation

**Direct Fund Impact:**
- Users who register for profits under a malicious scheme will have their tokens permanently locked
- No withdrawal mechanism exists once the overflow condition is present
- Affects all users who have locked tokens in the compromised scheme

**Quantified Damage:**
- 100% loss of access to locked tokens for all scheme participants
- The locked amount per user is specified in `RegisterForProfits` and can be substantial [6](#0-5) 

**Affected Parties:**
- All users who have called `RegisterForProfits` for schemes with extreme `MinimumLockMinutes` values
- Legitimate schemes accidentally misconfigured with large values

**Severity Justification:**
This is a **HIGH severity** vulnerability because it results in permanent fund loss through denial of access. The protobuf definition allows `int64` values including `Int64.MaxValue`: [7](#0-6) 

### Likelihood Explanation

**Attacker Capabilities:**
- Any user can create a TokenHolder profit scheme by calling `CreateScheme`
- No privileged role required - scheme creation is permissionless
- Attacker can social engineer users to lock tokens in the malicious scheme

**Attack Complexity:**
- Trivial: Single transaction to `CreateScheme` with `MinimumLockMinutes = Int64.MaxValue`
- No special conditions or timing requirements needed

**Feasibility Conditions:**
- The vulnerability is always exploitable for any new scheme
- Existing test suite shows no validation of extreme values: [8](#0-7) 

**Probability Reasoning:**
- **Malicious scenario**: HIGH - Attacker creates honeypot scheme with attractive rewards
- **Accidental scenario**: MEDIUM - Developer mistakenly uses maximum value or miscalculates minutes

### Recommendation

**1. Add Input Validation in CreateScheme:**

Add bounds checking for `MinimumLockMinutes` similar to the Election contract pattern. Define reasonable maximum lock time (e.g., 1080 days = 1,555,200 minutes) and validate:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add validation
    Assert(input.MinimumLockMinutes >= 0, "Minimum lock minutes must be non-negative");
    Assert(input.MinimumLockMinutes <= MaximumLockMinutes, 
        $"Minimum lock minutes exceeds maximum allowed: {MaximumLockMinutes}");
    
    // Verify no overflow will occur
    Assert(input.MinimumLockMinutes <= long.MaxValue / 60, 
        "Minimum lock minutes would cause timestamp overflow");
    
    // ... rest of existing code
}
```

**2. Add State Variable for Maximum Lock Time:**

Define `MaximumLockMinutes` in the contract state, similar to how the Election contract stores `MaximumLockTime`.

**3. Test Cases to Add:**

- Test `CreateScheme` with `MinimumLockMinutes = Int64.MaxValue` - should reject
- Test `CreateScheme` with negative `MinimumLockMinutes` - should reject  
- Test `CreateScheme` with `MinimumLockMinutes = Int64.MaxValue / 60 + 1` - should reject
- Test successful `Withdraw` after maximum allowed lock period
- Test `Withdraw` failure before lock period expires with maximum lock time

### Proof of Concept

**Required Initial State:**
- TokenHolder contract deployed
- User has sufficient token balance for locking (e.g., 1000 ELF)
- User has approved TokenHolder contract to lock tokens

**Attack Sequence:**

1. **Attacker creates malicious scheme:**
   ```
   Call: CreateScheme({
       Symbol: "ELF",
       MinimumLockMinutes: 9223372036854775807  // Int64.MaxValue
   })
   ```
   Expected: Transaction succeeds, scheme created

2. **Victim registers for profits:**
   ```
   Call: RegisterForProfits({
       SchemeManager: AttackerAddress,
       Amount: 1000
   })
   ```
   Expected: Transaction succeeds, 1000 ELF locked

3. **Victim attempts withdrawal (at any future time):**
   ```
   Call: Withdraw(AttackerAddress)
   ```
   Expected: Transaction **FAILS** with `OverflowException`
   
   Actual: `AddMinutes(9223372036854775807)` attempts `9223372036854775807 * 60` which overflows, throwing exception

4. **Funds are permanently locked:**
   - No alternative withdrawal mechanism exists
   - Tokens remain locked indefinitely in the MultiToken contract
   - Victim has lost all access to their 1000 ELF tokens

**Success Condition for Attack:**
The attack succeeds when the victim can never successfully execute `Withdraw`, verified by repeated transaction failures with overflow exceptions regardless of time elapsed.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-165)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** src/AElf.CSharp.Core/Extension/TimestampExtensions.cs (L39-42)
```csharp
    public static Timestamp AddMinutes(this Timestamp timestamp, long minutes)
    {
        return timestamp + new Duration { Seconds = minutes.Mul(60) };
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L79-85)
```csharp
    public static long Mul(this long a, long b)
    {
        checked
        {
            return a * b;
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L320-326)
```csharp
    private void AssertValidLockSeconds(long lockSeconds)
    {
        Assert(lockSeconds >= State.MinimumLockTime.Value,
            $"Invalid lock time. At least {State.MinimumLockTime.Value.Div(60).Div(60).Div(24)} days");
        Assert(lockSeconds <= State.MaximumLockTime.Value,
            $"Invalid lock time. At most {State.MaximumLockTime.Value.Div(60).Div(60).Div(24)} days");
    }
```

**File:** protobuf/token_holder_contract.proto (L63-70)
```text
message CreateTokenHolderProfitSchemeInput {
    // The token symbol.
    string symbol = 1;
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 2;
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 3;
}
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L434-459)
```csharp
    public async Task Withdraw_Test()
    {
        var amount = 1000L;
        var nativeTokenSymbol = TokenHolderContractTestConstants.NativeTokenSymbol;
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = nativeTokenSymbol
        });
        await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
        {
            Amount = amount,
            SchemeManager = Starter
        });
        var beforeUnLockBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = nativeTokenSymbol,
            Owner = Starter
        })).Balance;
        await TokenHolderContractStub.Withdraw.SendAsync(Starter);
        var afterUnLockBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = nativeTokenSymbol,
            Owner = Starter
        })).Balance;
        afterUnLockBalance.ShouldBe(beforeUnLockBalance.Add(amount));
    }
```
