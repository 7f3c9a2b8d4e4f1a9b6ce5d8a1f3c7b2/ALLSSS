### Title
Missing Access Control in Parliament Contract Initialization Allows Unauthorized Default Organization Configuration

### Summary
The Parliament contract's `Initialize` method lacks sender authorization checks, only verifying that the contract hasn't been initialized previously. If the Parliament contract is deployed without immediate initialization (as seen in test environments), any attacker can call `Initialize` first and set themselves as the privileged proposer, gaining control over the default Parliament organization that governs critical consensus parameters.

### Finding Description

The `RequiredMaximumMinersCountControllerSet()` function in the AEDPoS contract lazy-initializes the maximum miners count controller to use the default Parliament organization: [1](#0-0) 

This default Parliament organization is created during Parliament contract initialization. However, the Parliament contract's `Initialize` method has a critical access control flaw: [2](#0-1) 

The method only checks `Assert(!State.Initialized.Value, "Already initialized.")` but does **not** verify the sender's authority. Compare this to the Genesis contract's Initialize method which properly restricts access: [3](#0-2) 

In production genesis flow, system contracts are deployed with inline initialization calls that execute atomically: [4](#0-3) 

However, test environments demonstrate that Parliament deployment and initialization can be **separate transactions**: [5](#0-4) 

The initialization parameters control critical governance aspects: [6](#0-5) 

If an attacker successfully initializes the contract first, they can set `PrivilegedProposer` to their own address and `ProposerAuthorityRequired` to true, becoming the sole entity capable of creating proposals to the default organization.

### Impact Explanation

**Governance Compromise**: An attacker who initializes the Parliament contract can:
1. Set themselves as the `PrivilegedProposer` (first address in the proposer whitelist)
2. Enable `ProposerAuthorityRequired`, restricting proposal creation to whitelist members only
3. Control the default Parliament organization that governs consensus parameters

**Affected Systems**: The compromised default organization is used by:
- `RequiredMaximumMinersCountControllerSet()` for controlling maximum miners count
- `SetMinerIncreaseInterval()` for miner increase timing
- Other critical consensus and governance parameters

**Severity Justification**: Medium severity because:
- Impact is HIGH: Complete control over default organization governance
- Likelihood is LOW-MEDIUM: Requires deployment misconfiguration or test environment exploitation
- Defense-in-depth violation that contradicts security best practices

### Likelihood Explanation

**Attack Preconditions**:
1. Parliament contract must be deployed without immediate initialization
2. Attacker must call `Initialize` before legitimate initialization occurs

**Feasibility Scenarios**:
- **Test/Development Networks**: As demonstrated in test code, deployment and initialization are separate steps
- **Deployment Bugs**: If `TransactionMethodCallList` is null/empty or fails
- **Side Chain Misconfiguration**: If initialization data provider is incorrectly configured
- **Race Condition**: If there's any delay between deployment and initialization

**Attack Complexity**: Low - single transaction calling `Initialize` with attacker-controlled parameters

**Detection Difficulty**: High - initialization appears valid to the system

**Probability Assessment**: 
- Production main chain with proper genesis flow: Very Low
- Test/development environments: Medium-High
- Improperly configured side chains: Medium
- Overall: Low-Medium (weighted by deployment scenarios)

### Recommendation

**Immediate Fix**: Add sender authorization to Parliament.Initialize:

```csharp
public override Empty Initialize(InitializeInput input)
{
    Assert(!State.Initialized.Value, "Already initialized.");
    
    // Add sender check - only Genesis contract or system contract can initialize
    var genesisContractAddress = Context.GetContractAddressByName(
        SmartContractConstants.GenesisContractSystemName);
    Assert(Context.Sender == genesisContractAddress || 
           Context.Sender == Context.Self,
           "No permission to initialize Parliament contract.");
    
    State.Initialized.Value = true;
    // ... rest of initialization
}
```

**Invariant Checks**:
1. Verify sender is authorized before allowing initialization
2. Ensure initialization parameters are validated
3. Add event logging for initialization to enable monitoring

**Test Cases**:
1. Test that unauthorized addresses cannot call Initialize
2. Test that only Genesis/system contracts can initialize during deployment
3. Test initialization failure causes deployment rollback
4. Add regression test preventing re-introduction of this vulnerability

**Additional Hardening**:
- Consider making Initialize callable only during system contract deployment phase
- Add initialization status query method for monitoring
- Document initialization security requirements in deployment procedures

### Proof of Concept

**Required Initial State**:
- Parliament contract deployed but not initialized
- Attacker has funded account to pay transaction fees

**Attack Transaction Sequence**:

1. **Deployment Phase** (by system, with bug/misconfiguration):
   - Parliament contract deployed to address `X`
   - Initialization call omitted or fails
   - Contract exists but `State.Initialized.Value == false`

2. **Attack Transaction** (by attacker):
   ```
   To: Parliament Contract (address X)
   Method: Initialize
   Parameters: {
     PrivilegedProposer: <attacker_address>,
     ProposerAuthorityRequired: true
   }
   ```

3. **Verification**:
   - Call `GetProposerWhiteList()` - returns attacker as privileged proposer
   - Call `GetDefaultOrganizationAddress()` - returns organization address
   - Call `GetOrganization(defaultOrgAddress)` - shows `ProposerAuthorityRequired = true`
   - Attempt to create proposal from non-attacker address - fails with "Unauthorized to propose"
   - Create proposal from attacker address - succeeds

**Expected vs Actual Result**:
- **Expected**: Initialize should fail with "No permission"
- **Actual**: Initialize succeeds, attacker controls default organization

**Success Condition**: Attacker becomes sole proposer to default Parliament organization, controlling consensus parameter governance

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L31-43)
```csharp
    private void RequiredMaximumMinersCountControllerSet()
    {
        if (State.MaximumMinersCountController.Value != null) return;
        EnsureParliamentContractAddressSet();

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MaximumMinersCountController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L11-37)
```csharp
    public override Empty Initialize(InitializeInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        var proposerWhiteList = new ProposerWhiteList();

        if (input.PrivilegedProposer != null)
            proposerWhiteList.Proposers.Add(input.PrivilegedProposer);

        State.ProposerWhiteList.Value = proposerWhiteList;
        var organizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = DefaultOrganizationMinimalApprovalThreshold,
                MinimalVoteThreshold = DefaultOrganizationMinimalVoteThresholdThreshold,
                MaximalAbstentionThreshold = DefaultOrganizationMaximalAbstentionThreshold,
                MaximalRejectionThreshold = DefaultOrganizationMaximalRejectionThreshold
            },
            ProposerAuthorityRequired = input.ProposerAuthorityRequired,
            ParliamentMemberProposingAllowed = true
        };
        var defaultOrganizationAddress = CreateNewOrganization(organizationInput);
        State.DefaultOrganizationAddress.Value = defaultOrganizationAddress;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L102-120)
```csharp
    public override Address DeploySystemSmartContract(SystemContractDeploymentInput input)
    {
        Assert(!State.Initialized.Value || !State.ContractDeploymentAuthorityRequired.Value,
            "System contract deployment failed.");
        RequireSenderAuthority();
        var name = input.Name;
        var category = input.Category;
        var code = input.Code.ToByteArray();
        var transactionMethodCallList = input.TransactionMethodCallList;

        // Context.Sender should be identical to Genesis contract address before initialization in production
        var address = DeploySmartContract(name, category, code, true, Context.Sender, false);

        if (transactionMethodCallList != null)
            foreach (var methodCall in transactionMethodCallList.Value)
                Context.SendInline(address, methodCall.MethodName, methodCall.Params);

        return address;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L339-346)
```csharp
    public override Empty Initialize(InitializeInput input)
    {
        Assert(!State.Initialized.Value, "Contract zero already initialized.");
        Assert(Context.Sender == Context.Self, "No permission.");
        State.ContractDeploymentAuthorityRequired.Value = input.ContractDeploymentAuthorityRequired;
        State.Initialized.Value = true;
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTestBase.cs (L65-77)
```csharp
        ParliamentContractAddress = AsyncHelper.RunSync(() =>
            DeploySystemSmartContract(
                KernelConstants.CodeCoverageRunnerCategory,
                ParliamentCode,
                ParliamentSmartContractAddressNameProvider.Name,
                DefaultSenderKeyPair
            ));
        ParliamentContractStub = GetParliamentContractTester(DefaultSenderKeyPair);
        AsyncHelper.RunSync(() => ParliamentContractStub.Initialize.SendAsync(new InitializeInput
        {
            ProposerAuthorityRequired = false,
            PrivilegedProposer = DefaultSender
        }));
```

**File:** protobuf/parliament_contract.proto (L145-150)
```text
message InitializeInput{
    // Privileged proposer would be the first address in parliament proposer whitelist.
    aelf.Address privileged_proposer = 1;
    // The setting indicates if proposals need authority to be created for first/default parliament organization.
    bool proposer_authority_required = 2;
}
```
