### Title
Non-Existent Token Distribution Causes Permanent Profit Loss in DistributeProfits

### Summary
The `DistributeProfits` function only validates that token symbols are non-empty but does not verify token existence, unlike `ContributeProfits` which calls `AssertTokenExists`. When distributing non-existent tokens with amount 0, the period is marked as released without including legitimately contributed tokens in the distribution, causing permanent profit loss as those tokens become unclaimable and further contributions are blocked.

### Finding Description

The root cause is insufficient token validation in `DistributeProfits`: [1](#0-0) 

This only checks symbols are not empty strings, while `ContributeProfits` properly validates token existence: [2](#0-1) [3](#0-2) 

When `GetBalance` is called on a non-existent token, it returns 0 instead of throwing: [4](#0-3) 

The execution path proceeds as follows:

1. Manager calls `DistributeProfits` with a non-existent token symbol (e.g., "FAKE") and amount=0
2. GetBalance returns 0 for the fake token from the general ledger: [5](#0-4) 

3. `UpdateDistributedProfits` marks the period as released and updates AmountsMap with only the fake token: [6](#0-5) 

4. The period is marked as released even though legitimate tokens (contributed via `ContributeProfits`) are not included in the distribution: [7](#0-6) 

5. Future contributions to this period are blocked: [8](#0-7) 

6. Beneficiaries cannot claim tokens not in AmountsMap: [9](#0-8) 

### Impact Explanation

**Direct Fund Impact - Profit Loss:**
- Users who contributed legitimate tokens (e.g., 1000 ELF) to a period via `ContributeProfits` lose access to those funds permanently
- The tokens remain locked in the period's virtual address but are excluded from the `AmountsMap` used by `ClaimProfits`
- No recovery mechanism exists to extract tokens from a released period's virtual address
- Beneficiaries receive zero profits for that period despite valid contributions existing

**Who is Affected:**
- All beneficiaries of the profit scheme for the affected period
- Users who contributed tokens expecting them to be distributed
- The scheme loses credibility and utility

**Severity Justification:**
Medium severity due to permanent fund loss, though requiring manager action (malicious or accidental) to trigger.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires scheme manager role to call `DistributeProfits`
- Manager could be compromised, malicious, or simply make a typo in token symbol

**Attack Complexity:**
Low - single function call with incorrect symbol parameter.

**Feasibility Conditions:**
- Users must have contributed tokens to the period before distribution
- Manager calls `DistributeProfits` with non-existent token symbol and amount=0
- No special setup or timing required

**Detection/Operational Constraints:**
- Difficult to detect before impact occurs
- Once period is released, damage is irreversible
- No monitoring exists for invalid token symbols in distribution

**Probability:**
High likelihood of accidental occurrence through:
- Copy-paste errors in token symbols
- Typos in symbol names
- Integration bugs passing wrong symbol values
- Malicious manager intentionally griefing beneficiaries

### Recommendation

**Code-Level Mitigation:**
Add token existence validation in `DistributeProfits` before processing, similar to `ContributeProfits`:

```csharp
public override Empty DistributeProfits(DistributeProfitsInput input)
{
    if (input.AmountsMap.Any())
    {
        Assert(input.AmountsMap.All(a => !string.IsNullOrEmpty(a.Key)), "Invalid token symbol.");
        // ADD THIS: Validate all tokens exist
        foreach (var amount in input.AmountsMap)
        {
            AssertTokenExists(amount.Key);
        }
    }
    // ... rest of function
}
```

**Invariant Checks to Add:**
1. All token symbols in `AmountsMap` must correspond to existing tokens before distribution
2. Verify `GetBalance` queries succeed for all symbols before marking period as released
3. Consider validating scheme's `ReceivedTokenSymbols` only contains valid tokens

**Test Cases:**
1. Test `DistributeProfits` with non-existent token symbol - should revert
2. Test `DistributeProfits` with typo in existing token symbol - should revert
3. Test that period can only be released if all tokens in AmountsMap exist
4. Test beneficiaries can claim all contributed tokens after valid distribution

### Proof of Concept

**Required Initial State:**
- Profit scheme X exists with beneficiaries
- Scheme manager is address M
- Period 1 has not been distributed yet

**Transaction Steps:**

1. User calls `ContributeProfits(schemeId=X, period=1, symbol="ELF", amount=1000)`
   - Expected: 1000 ELF transferred to period 1's virtual address
   - Result: SUCCESS

2. Manager M calls `DistributeProfits(schemeId=X, period=1, amountsMap={"NONEXISTENT": 0})`
   - Expected: Should fail with "Token NONEXISTENT not exists"
   - Actual: SUCCESS - period marked as released with empty distribution

3. User attempts `ContributeProfits(schemeId=X, period=1, symbol="ELF", amount=500)`
   - Expected: Should add 500 more ELF to period 1
   - Actual: FAILS with "Scheme of period 1 already released"

4. Beneficiary calls `ClaimProfits(schemeId=X)`
   - Expected: Should receive share of 1000 ELF from period 1
   - Actual: Receives 0 ELF (symbol "ELF" not in AmountsMap for period 1)

**Success Condition:**
The 1000 ELF contributed in step 1 is permanently locked in period 1's virtual address, unclaimable by beneficiaries, demonstrating concrete profit loss.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L419-420)
```csharp
        if (input.AmountsMap.Any())
            Assert(input.AmountsMap.All(a => !string.IsNullOrEmpty(a.Key)), "Invalid token symbol.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L437-444)
```csharp
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-496)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);

        State.SchemeInfos[input.SchemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L501-508)
```csharp
    private void AssertTokenExists(string symbol)
    {
        if (string.IsNullOrEmpty(State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput { Symbol = symbol })
                .TokenName))
        {
            throw new AssertionException($"Token {symbol} not exists.");
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-583)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L656-656)
```csharp
        AssertTokenExists(input.Symbol);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L697-699)
```csharp
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L867-871)
```csharp
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L166-172)
```csharp
    private long GetBalance(Address address, string symbol)
    {
        AssertValidInputAddress(address);
        var actualSymbol = GetActualTokenSymbol(symbol);
        Assert(!string.IsNullOrWhiteSpace(actualSymbol), "Invalid symbol.");
        return State.Balances[address][actualSymbol];
    }
```
