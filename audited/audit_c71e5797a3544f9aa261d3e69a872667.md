### Title
RemoveNFTType Breaks Cross-Chain Synchronization for Active NFT Protocols

### Summary
The `RemoveNFTType()` function only verifies that an NFT type exists before removal but fails to check if active NFT protocols currently use that type. When an NFT type is removed while protocols with symbols prefixed by that type's short name are active, subsequent `CrossChainCreate()` calls fail, permanently breaking cross-chain synchronization for those protocols.

### Finding Description

The vulnerability exists in the `RemoveNFTType()` function which lacks validation for active protocol usage: [1](#0-0) 

The function only checks if the short name exists (line 157) and then proceeds to remove it from both `NFTTypeFullNameMap` and `NFTTypeShortNameMap` state mappings. However, NFT protocol symbols are generated by concatenating the 2-character short name with a random number: [2](#0-1) 

When protocols are created, the NFT type information is used to generate the symbol, and protocols are stored in `State.NftProtocolMap` with this symbol as the key: [3](#0-2) 

The critical breakage occurs in `CrossChainCreate()`, which is used to synchronize NFT protocols across chains. This function extracts the 2-character short name from the protocol symbol and attempts to look it up in `NFTTypeFullNameMap`: [4](#0-3) 

If the NFT type has been removed via `RemoveNFTType()`, the lookup at line 90 returns null, causing the assertion at lines 91-93 to fail with the error: "Full name of {shortName} not found. Use AddNFTType to add this new pair."

**Root Cause:** No validation exists in `RemoveNFTType()` to iterate through `State.NftProtocolMap` and check if any protocols have symbols starting with the short name being removed.

**Why Existing Protections Fail:** The authorization check (Parliament default address) only ensures proper governance but provides no awareness of protocol dependencies. The existence check at line 157 only validates the type exists in the mapping, not whether it's actively used.

### Impact Explanation

**Operational DoS of Cross-Chain Functionality:**
- All NFT protocols created with the removed type become permanently unable to synchronize to side chains
- Cross-chain NFT transfer and indexing operations fail for affected protocols
- Affects AElf's core multi-chain architecture promise

**Who Is Affected:**
- Protocol creators who issued NFTs with the removed type on the main chain
- Users attempting to use cross-chain NFT functionality
- Side chains unable to receive legitimate NFT protocol synchronization

**Severity Justification:** CRITICAL - This breaks a fundamental cross-chain integrity invariant. Once an NFT type is removed while active protocols exist, there is no straightforward recovery path. Even re-adding the type may not restore the mapping correctly if Parliament is unaware of the specific protocols affected. The impact is permanent operational failure of cross-chain NFT synchronization.

### Likelihood Explanation

**Attacker Capabilities:** This requires Parliament default organization authority, which is a legitimate governance role, not a compromised attacker.

**Attack Complexity:** LOW - Single transaction execution of `RemoveNFTType()` with a valid short name.

**Feasibility Conditions:**
- Parliament governance decides to remove what appears to be an unused or deprecated NFT type
- No visibility provided to Parliament about which protocols depend on specific types
- Legitimate "cleanup" governance action performed without awareness of active protocol dependency

**Probability Reasoning:** HIGH - This is a realistic governance scenario. As the protocol evolves, Parliament may wish to deprecate old NFT type categories or consolidate naming schemes. Without tooling to check protocol usage, this removal appears safe but causes hidden breakage in cross-chain flows that may not be immediately detected until synchronization is attempted.

### Recommendation

**Code-Level Mitigation:**

Add validation in `RemoveNFTType()` to check for active protocols before removal. Since `State.NftProtocolMap` is a mapped state without enumeration support in AElf, implement a counter tracking mechanism:

1. Add a new state variable: `MappedState<string, int64> NFTTypeProtocolCountMap`

2. Increment the counter when protocols are created in `Create()` and `CrossChainCreate()`:
```
State.NFTTypeProtocolCountMap[shortName] = 
    State.NFTTypeProtocolCountMap[shortName].Add(1);
```

3. Add validation in `RemoveNFTType()` before line 157:
```
var protocolCount = State.NFTTypeProtocolCountMap[input.Value];
Assert(protocolCount == 0, 
    $"Cannot remove NFT type {input.Value}: {protocolCount} protocols still use this type.");
```

4. Optionally, decrement counter when protocols are fully burned/destroyed (if such functionality exists)

**Invariant Check:** Before any NFT type removal, verify zero active protocols reference that type's short name.

**Test Cases:**
1. Test removal of unused NFT type succeeds
2. Test removal of NFT type with active protocols fails with descriptive error
3. Test cross-chain synchronization continues working after legitimate type removal
4. Test counter accuracy across multiple protocol creations

### Proof of Concept

**Required Initial State:**
- AElf mainchain with NFT contract deployed
- Parliament governance initialized
- At least one NFT type registered (e.g., "VW" -> "VirtualWorlds")

**Transaction Sequence:**

1. **Create NFT Protocol with VirtualWorlds Type:**
   - Call `NFTContract.Create()` with `NftType = "VirtualWorlds"`
   - Protocol created with symbol "VW123456789" (example)
   - Protocol stored in `State.NftProtocolMap["VW123456789"]`
   - Users mint NFTs, protocol is actively used

2. **Parliament Removes VirtualWorlds Type:**
   - Parliament calls `NFTContract.RemoveNFTType("VW")`
   - Transaction succeeds (only checks existence, line 157)
   - `State.NFTTypeFullNameMap["VW"]` removed
   - `State.NFTTypeShortNameMap["VirtualWorlds"]` removed

3. **Attempt Cross-Chain Synchronization:**
   - Call `NFTContract.CrossChainCreate({ symbol: "VW123456789" })`
   - Line 89: `nftTypeShortName = "VW"`
   - Line 90: `nftTypeFullName = State.NFTTypeFullNameMap["VW"]` returns `null`
   - Line 92-93: Transaction fails with AssertionException

**Expected Result:** Cross-chain synchronization succeeds, protocol is created on side chain

**Actual Result:** Transaction reverts with error: "Full name of VW not found. Use AddNFTType to add this new pair."

**Success Condition:** The vulnerability is confirmed when active protocol "VW123456789" cannot be synchronized cross-chain after its type "VW" is removed, demonstrating permanent breakage of cross-chain functionality for legitimate, active NFT protocols.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-73)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);

        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;

        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
            ProtocolName = tokenCreateInput.TokenName,
            IsTokenIdReuse = input.IsTokenIdReuse,
            IssueChainId = tokenCreateInput.IssueChainId,
            IsBurnable = tokenCreateInput.IsBurnable,
            NftType = input.NftType
        };
        State.NftProtocolMap[symbol] = protocolInfo;

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = tokenCreateInput.Symbol,
            Creator = tokenCreateInput.Issuer,
            IsBurnable = tokenCreateInput.IsBurnable,
            IssueChainId = tokenCreateInput.IssueChainId,
            ProtocolName = tokenCreateInput.TokenName,
            TotalSupply = tokenCreateInput.TotalSupply,
            Metadata = protocolInfo.Metadata,
            BaseUri = protocolInfo.BaseUri,
            IsTokenIdReuse = protocolInfo.IsTokenIdReuse,
            NftType = protocolInfo.NftType
        });

        return new StringValue
        {
            Value = symbol
        };
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L87-93)
```csharp
        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L152-169)
```csharp
    public override Empty RemoveNFTType(StringValue input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        Assert(input.Value.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
        var fullName = State.NFTTypeFullNameMap[input.Value];
        State.NFTTypeFullNameMap.Remove(input.Value);
        State.NFTTypeShortNameMap.Remove(fullName);
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Remove(input.Value);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeRemoved
        {
            ShortName = input.Value
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```
