### Title
Governance Bypass via Malicious Contract Validation in Method Fee Controller

### Summary
The `ChangeMethodFeeController` function accepts arbitrary contract addresses in `AuthorityInfo.ContractAddress` without validating they are legitimate governance contracts. An attacker can deploy a malicious contract that always returns `true` for `ValidateOrganizationExist`, then use a single approved governance proposal to permanently take over the method fee controller, bypassing all future governance requirements.

### Finding Description

The vulnerability exists in the `CheckOrganizationExist` function that validates new controller authority: [1](#0-0) 

This function makes a cross-contract call to `ValidateOrganizationExist` on the address provided in `authorityInfo.ContractAddress` without verifying this address is a trusted governance contract (Parliament, Association, or Referendum).

The `ChangeMethodFeeController` function uses this validation: [2](#0-1) 

While line 25 requires the sender to be the current controller's owner address, this protection is insufficient when the controller is changed via a governance proposal. During proposal execution, `Context.Sender` becomes the organization's virtual address, passing the authorization check. The malicious contract validation then accepts any fake organization address.

Legitimate governance contracts implement `ValidateOrganizationExist` by checking state storage: [3](#0-2) 

However, there is no mechanism to ensure the `ContractAddress` actually points to Parliament, Association, or Referendum contracts obtained via system contract resolution: [4](#0-3) 

### Impact Explanation

**Critical Governance Bypass:**
- Complete circumvention of governance controls for method fee management across the TokenHolder contract
- Once the initial malicious proposal is approved, the attacker gains permanent, irreversible control
- Attacker can arbitrarily set method fees to zero (breaking fee economics) or excessively high values (DoS attack)
- Attacker can change the controller to any address they control, permanently locking out legitimate governance

**Systemic Risk:**
This same vulnerability pattern exists in ALL ACS1 implementations across the codebase, including:
- MultiToken contract (fee controller for all token operations)
- Parliament, Association, Referendum contracts (self-governance)
- Consensus, Election, Treasury, Profit contracts (core protocol governance)

The impact extends to the entire protocol's governance infrastructure, not just TokenHolder.

**Affected Parties:**
- All users paying transaction fees
- Protocol economics and sustainability
- Governance participants who lose control
- Chain operators unable to adjust fees

### Likelihood Explanation

**Attack Complexity: Medium**
The attacker must:
1. Deploy a malicious contract implementing the `ValidateOrganizationExist` interface to always return `true`
2. Craft a governance proposal to change the controller with the malicious ContractAddress
3. Get the proposal approved through legitimate governance (requires miner/organization votes)

**Feasibility: High**
- The proposal can be crafted to appear legitimate by using a real-looking organization address as `OwnerAddress`
- Governance reviewers may focus on the `OwnerAddress` and not scrutinize the `ContractAddress`
- No on-chain validation prevents this attack
- Once approved once, the attack is permanent without emergency intervention

**Detection: Low**
- The malicious ContractAddress may not be immediately obvious during proposal review
- Standard governance processes don't include ContractAddress validation
- The attack is only detectable by manual code review of the proposed ContractAddress

**Economic Rationality: Very High**
- Cost: One governance proposal approval (standard governance process)
- Benefit: Permanent control over method fee controller worth significant value
- No ongoing costs after initial compromise

### Recommendation

**Immediate Fix:**
Add validation in `CheckOrganizationExist` to verify the `ContractAddress` is a legitimate system governance contract:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate ContractAddress is a trusted governance contract
    var systemContracts = Context.GetSystemContractNameToAddressMapping();
    var isValidGovernanceContract = 
        authorityInfo.ContractAddress == systemContracts[SmartContractConstants.ParliamentContractSystemName] ||
        authorityInfo.ContractAddress == systemContracts[SmartContractConstants.AssociationContractSystemName] ||
        authorityInfo.ContractAddress == systemContracts[SmartContractConstants.ReferendumContractSystemName];
    
    Assert(isValidGovernanceContract, "ContractAddress must be a valid governance contract.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Invariant to Enforce:**
`AuthorityInfo.ContractAddress` MUST be one of the three system governance contracts obtained through `Context.GetContractAddressByName()`.

**Test Cases:**
1. Test that `ChangeMethodFeeController` rejects AuthorityInfo with arbitrary contract addresses
2. Test that only Parliament, Association, and Referendum addresses are accepted
3. Test that malicious contracts cannot bypass organization validation
4. Regression test across all ACS1 implementations

**Apply Fix System-Wide:**
This same pattern must be fixed in all contracts implementing ACS1, including MultiToken, Parliament, Association, Referendum, Consensus, Election, Treasury, Profit, Vote, Configuration, and Genesis contracts.

### Proof of Concept

**Initial State:**
- MethodFeeController = { OwnerAddress: Parliament_Default_Org, ContractAddress: Parliament_Contract }

**Attack Steps:**

1. **Attacker deploys malicious contract:**
```csharp
public class MaliciousValidator : ContractBase {
    public override BoolValue ValidateOrganizationExist(Address input) {
        return new BoolValue { Value = true }; // Always return true
    }
}
```

2. **Attacker creates proposal via Parliament:**
    - Target: TokenHolderContract.ChangeMethodFeeController
    - Params: AuthorityInfo { 
    OwnerAddress: Attacker_Address, 
    ContractAddress: MaliciousValidator_Address 
  }

3. **Proposal gets approved by miners and released:**
    - Execution context: Context.Sender = Parliament_Default_Org (virtual address)
    - Line 25 passes: Parliament_Default_Org == current controller owner
    - Line 26-27: Calls MaliciousValidator.ValidateOrganizationExist(Attacker_Address)
    - MaliciousValidator returns true
    - Controller changed to attacker

4. **Attacker now has permanent control:**
    - Attacker directly calls ChangeMethodFeeController (no proposal needed)
    - Line 25 passes: Attacker_Address == current controller owner
    - Line 26-27: Calls MaliciousValidator which returns true for ANY address
    - Attacker can set any controller, set any fees, lock out governance

**Expected Result:** Transaction should fail with "Invalid governance contract"

**Actual Result:** Transaction succeeds, attacker gains permanent control

**Success Condition:** After step 4, attacker can call `SetMethodFee` and `ChangeMethodFeeController` without governance approval, completely bypassing the intended governance model.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L50-64)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```
