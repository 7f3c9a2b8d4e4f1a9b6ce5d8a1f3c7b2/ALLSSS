# Audit Report

## Title
Continuous Blocks Limit Bypass via RoundNumber Manipulation in UpdateValue/TinyBlock Behaviors

## Summary
A malicious miner can bypass the continuous blocks production limit by manipulating the `RoundNumber` field in consensus extra data for UpdateValue and TinyBlock behaviors. By setting `RoundNumber` to ≤2, the miner skips the `ContinuousBlocksValidationProvider` check, allowing unlimited consecutive block production beyond the intended limit of 8 tiny blocks.

## Finding Description

The AEDPoS consensus mechanism implements a protection to prevent any single miner from producing too many consecutive blocks, tracked via `LatestPubkeyToTinyBlocksCount`. When a miner's `BlocksCount` becomes negative, they should be forced to trigger NextRound behavior.

However, this protection can be bypassed due to missing RoundNumber validation for UpdateValue and TinyBlock behaviors:

**Root Cause:**

The `GetUpdateValueRound` and `GetTinyBlockRound` methods copy `RoundNumber` directly from the current round state: [1](#0-0) [2](#0-1) 

While NextRound and NextTerm behaviors have `RoundTerminateValidationProvider` that validates the RoundNumber: [3](#0-2) 

UpdateValue and TinyBlock behaviors do NOT receive this validation provider.

**Exploitation Mechanism:**

The validation context sets `ProvidedRound` directly from the consensus extra data in the block header: [4](#0-3) 

During `ValidateBeforeExecution`, the recovery methods only merge miner information without touching or validating RoundNumber: [5](#0-4) [6](#0-5) 

The `ContinuousBlocksValidationProvider` is applied to ALL behaviors and uses the unvalidated `ProvidedRound.RoundNumber`: [7](#0-6) 

A miner can exploit this by:
1. Receiving advisory to use NextRound behavior from `GetConsensusCommand`: [8](#0-7) 
2. Ignoring this advisory and manually constructing UpdateValue/TinyBlock consensus extra data
3. Setting `RoundNumber` to 1 or 2 in the consensus extra data
4. The check `ProvidedRound.RoundNumber > 2` evaluates to false, skipping the continuous blocks validation entirely
5. After execution, the recovery corrects RoundNumber before hash validation, so the manipulation isn't detected: [9](#0-8) 

## Impact Explanation

**Concrete Harm:**
A malicious miner who has exhausted their continuous blocks limit can monopolize block production by bypassing the protection mechanism. The intended limit is defined by `MaximumTinyBlocksCount`: [10](#0-9) 

The continuous blocks tracking mechanism is implemented in `ResetLatestProviderToTinyBlocksCount`: [11](#0-10) 

**Impact Severity:**
- **Consensus Disruption**: Single miner produces unlimited consecutive blocks beyond the 8-block limit
- **Operational DoS**: Other miners are starved of block production opportunities, unable to participate in consensus
- **Reward Misallocation**: Unfair distribution of mining rewards to the exploiting miner
- **Fairness Violation**: Breaks the intended round-robin block production schedule designed to ensure distributed consensus

## Likelihood Explanation

**Attacker Capabilities:**
Any miner participating in consensus can exploit this vulnerability. The attack requires:
1. Being an active miner in the current round (normal prerequisite)
2. Modifying node software to ignore the advisory `GetConsensusCommand` result
3. Manually constructing UpdateValue/TinyBlock consensus extra data with manipulated `RoundNumber` field
4. Including the modified consensus extra data in produced block headers

**Attack Complexity:** 
Low - requires only a simple modification of the `RoundNumber` field in consensus extra data before including it in the block header. No cryptographic operations, complex state manipulation, or race conditions are involved.

**Feasibility:** 
High - miners control the consensus extra data they include in their block headers. The manipulation occurs locally during block generation, and no special permissions or economic resources are required beyond being an active miner.

**Detection:** 
Difficult - the manipulated `RoundNumber` is corrected during the recovery phase before hash validation, making post-execution detection challenging without inspecting raw block headers before validation occurs.

## Recommendation

Add `RoundTerminateValidationProvider` validation for UpdateValue and TinyBlock behaviors to ensure RoundNumber consistency:

```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider()); // Add this
        break;
    case AElfConsensusBehaviour.TinyBlock:
        validationProviders.Add(new RoundTerminateValidationProvider()); // Add this
        break;
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new RoundTerminateValidationProvider());
        break;
}
```

Alternatively, validate RoundNumber consistency in `ContinuousBlocksValidationProvider` directly:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    
    // Validate RoundNumber matches state for UpdateValue/TinyBlock
    if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.UpdateValue ||
        validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
    {
        if (validationContext.ProvidedRound.RoundNumber != validationContext.BaseRound.RoundNumber)
        {
            validationResult.Message = "RoundNumber mismatch in consensus extra data.";
            return validationResult;
        }
    }

    if (validationContext.ProvidedRound.RoundNumber > 2 && 
        validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
    {
        // ... existing continuous blocks check
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

## Proof of Concept

To demonstrate this vulnerability, a test would need to:

1. Set up a consensus round with an active miner
2. Have the miner produce blocks until `BlocksCount < 0` (continuous blocks limit exhausted)
3. Construct an UpdateValue consensus extra data with `RoundNumber = 2` (manipulated)
4. Call `ValidateConsensusBeforeExecution` with this manipulated extra data
5. Verify that validation passes (continuous blocks check is skipped)
6. Execute the UpdateValue transaction
7. Verify the block is accepted despite the miner having exceeded the continuous blocks limit

The test would confirm that by manipulating `RoundNumber` to ≤2, a miner bypasses the protection mechanism and can continue producing blocks indefinitely.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L14-16)
```csharp
        var round = new Round
        {
            RoundNumber = RoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L61-63)
```csharp
        var round = new Round
        {
            RoundNumber = RoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-92)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L8-28)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Is sender produce too many continuous blocks?
        var validationResult = new ValidationResult();

        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-97)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```
