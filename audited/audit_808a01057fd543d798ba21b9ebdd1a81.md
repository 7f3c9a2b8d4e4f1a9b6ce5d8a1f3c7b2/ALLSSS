### Title
Unhandled KeyNotFoundException in IsCurrentMiner During Term Transitions Causes DoS of Critical Authorization Checks

### Summary
The `ConvertAddressToPubkey` function combines miners from current and previous rounds, allowing it to return pubkeys that don't exist in the current round. When `IsCurrentMiner(string pubkey)` is called during term transitions with `IsMinerListJustChanged = true`, it skips the existence check but then directly accesses the dictionary, causing a KeyNotFoundException that crashes transactions requiring miner authorization (fee claims, cross-chain indexing, governance operations).

### Finding Description

The vulnerability exists in the interaction between two functions in `AEDPoSContract_ViewMethods.cs`: [1](#0-0) 

The `ConvertAddressToPubkey` function combines pubkeys from both current and previous rounds, which means it can return a pubkey that exists only in the previous round's miner list. [2](#0-1) 

The `IsCurrentMiner(string pubkey)` function has a critical flaw at lines 142-144: when `IsMinerListJustChanged = true` (which occurs during term transitions), it skips the `ContainsKey` check. However, at line 158, it directly accesses `currentRound.RealTimeMinersInformation[pubkey]` without any guard, causing a `KeyNotFoundException` if the pubkey doesn't exist in the current round.

During term transitions, `GenerateFirstRoundOfNewTerm` sets `IsMinerListJustChanged = true`: [3](#0-2) 

**Root Cause**: The code assumes that when `IsMinerListJustChanged = true`, all accessed miners will be valid, but `ConvertAddressToPubkey` can return pubkeys from the previous round that are no longer in the current miner list.

**Why Protection Fails**: The check at lines 150-155 only handles the special case of `ExtraBlockProducerOfPreviousRound`, but doesn't protect against other previous-round miners who are not in the current round.

### Impact Explanation

This vulnerability causes **Denial of Service** during term transitions affecting multiple critical contract operations:

1. **Token Fee Claims** - Miners attempting to claim transaction fees via `ClaimTransactionFees`: [4](#0-3) 

2. **Cross-Chain Indexing** - Cross-chain operations requiring miner authorization: [5](#0-4) 

3. **Any contract** checking `IsCurrentMiner` for authorization during the term transition window.

**Quantified Impact**: All authorization checks using `IsCurrentMiner` fail with unhandled exceptions during term transitions when queried with addresses of miners who were removed from the miner list. This blocks legitimate operations and creates operational disruption during each term change.

**Severity**: Medium - While not causing fund loss, it disrupts critical protocol operations (fee distribution, cross-chain communication) during term transitions, which occur periodically in the AElf consensus cycle.

### Likelihood Explanation

**Attacker Capabilities**: Any user can trigger this by:
- Calling `IsCurrentMiner` with an old miner's address during a term transition, OR
- Having transactions fail when they legitimately try to use functions that check miner status

**Attack Complexity**: Low
- Requires only knowing an address from the previous miner list
- No special permissions needed
- Automatically occurs during normal term transitions when old miners try to claim fees

**Feasibility Conditions**:
- Term transition must have occurred (happens periodically per AElf consensus design)
- `IsMinerListJustChanged` must be true (first round of new term)
- Address must belong to a miner from previous term who is not in current term and not the extra block producer

**Probability**: Moderate to High - Term transitions with miner list changes happen regularly, and the vulnerable state persists for the first round of each new term.

### Recommendation

Add an existence check before accessing the dictionary, even when `IsMinerListJustChanged` is true:

```csharp
private bool IsCurrentMiner(string pubkey)
{
    if (pubkey == null) return false;
    
    if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;
    
    // Always check if pubkey exists in current round before accessing
    if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
    {
        // Special case: allow extra block producer from previous round
        if (currentRound.IsMinerListJustChanged && 
            Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            return true;
        }
        return false;
    }
    
    // ... rest of the existing logic
}
```

**Invariant to Enforce**: Before accessing `currentRound.RealTimeMinersInformation[pubkey]`, always verify the key exists, regardless of `IsMinerListJustChanged` state.

**Test Cases**:
1. Test `IsCurrentMiner` with previous-term miner address during first round of new term
2. Test authorization functions during term transitions with old miner addresses
3. Verify graceful failure (returns false) instead of exception

### Proof of Concept

**Initial State**:
- Term N has miners: [Alice, Bob, Carol]
- Term N+1 starts with miners: [Bob, Carol, Dave]
- Alice was removed from miner list
- First round of Term N+1 has `IsMinerListJustChanged = true`

**Exploitation Steps**:
1. Term transition occurs, new term begins
2. Attacker (or Alice herself) calls `IsCurrentMiner(Alice_Address)`
3. `ConvertAddressToPubkey` returns Alice's pubkey (found in previous round at lines 128-130)
4. `IsCurrentMiner(Alice_Pubkey)` executes:
   - Line 142-144: Skipped because `IsMinerListJustChanged = true`
   - Line 150-155: Alice is not the extra block producer, check fails
   - Line 158: Attempts `currentRound.RealTimeMinersInformation[Alice_Pubkey]`
5. **KeyNotFoundException** thrown - Alice's pubkey doesn't exist in current round
6. Transaction reverts with unhandled exception

**Expected Result**: Should return `false` gracefully
**Actual Result**: Transaction crashes with `KeyNotFoundException`
**Success Condition**: Any transaction checking authorization with old miner address fails during term transition window

### Notes

The original question's premise was incorrectâ€”a single pubkey cannot derive to different addresses (cryptographic impossibility). However, the question correctly identified a vulnerability in the code flow: `ConvertAddressToPubkey` returns pubkeys from previous rounds that may not exist in the current round, and `IsCurrentMiner` fails to handle this case when `IsMinerListJustChanged = true`, causing unhandled exceptions instead of graceful authorization denial.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L125-134)
```csharp
    private string ConvertAddressToPubkey(Address address)
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return null;
        var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
        if (TryToGetPreviousRoundInformation(out var previousRound))
            possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys);

        return possibleKeys.FirstOrDefault(k =>
            Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)) == address);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L136-158)
```csharp
    private bool IsCurrentMiner(string pubkey)
    {
        if (pubkey == null) return false;

        if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;

        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;

        Context.LogDebug(() =>
            $"Extra block producer of previous round: {currentRound.ExtraBlockProducerOfPreviousRound}");

        // Check confirmed extra block producer of previous round.
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }

        var miningInterval = currentRound.GetMiningInterval();
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L42-42)
```csharp
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L897-906)
```csharp
    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```
