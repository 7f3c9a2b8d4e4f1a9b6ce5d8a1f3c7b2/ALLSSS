### Title
Systematic Token Loss Due to Precision Loss in SafeCalculateProfits Function

### Summary
The `SafeCalculateProfits` function uses decimal arithmetic but casts to `long`, causing systematic floor division rounding errors. When profits are distributed to beneficiaries across multiple periods, the sum of individual allocations is consistently less than the total amount, resulting in dust tokens permanently locked in period virtual addresses with no recovery mechanism.

### Finding Description

**Root Cause:**
The `SafeCalculateProfits` function performs an implicit floor operation when casting decimal results to long: [1](#0-0) 

This function is called in two critical distribution paths:

1. **Sub-scheme distribution:** When distributing to sub-schemes, each allocation uses floor division, and the remainder is tracked: [2](#0-1) 

2. **Individual beneficiary claims:** When beneficiaries claim from period virtual addresses, the same floor division applies: [3](#0-2) 

**Why Protections Fail:**
While the code handles remainders from sub-scheme distribution by sending them to period virtual addresses: [4](#0-3) 

There is NO mechanism to recover dust that remains after all beneficiaries claim their floor-divided shares from these period virtual addresses. The only operations on period virtual addresses are receiving funds (distribution) and sending to beneficiaries (claims): [5](#0-4) 

No admin function exists to withdraw leftover balances from period-specific virtual addresses.

### Impact Explanation

**Concrete Impact:**
- **Token Leakage:** For every profit distribution period, dust tokens (typically 1-N tokens depending on totalShares) remain permanently locked in period virtual addresses
- **Systematic Accumulation:** This occurs in EVERY distribution period across ALL profit schemes
- **Irreversible Loss:** Period virtual addresses are computed deterministically from schemeId and period number, with no recovery function [6](#0-5) 

**Quantified Impact:**
For a distribution of `totalAmount` tokens among `n` beneficiaries with equal shares:
- Each beneficiary receives: `floor(totalAmount / n)` tokens
- Dust remaining: `totalAmount - n * floor(totalAmount / n)` tokens
- Maximum dust per period: `n - 1` tokens (when `totalAmount % n == n - 1`)

**Example:**
- Total: 1000 tokens, 3 equal beneficiaries
- Each receives: `floor(1000 / 3) = 333` tokens  
- Total claimed: 999 tokens
- **Dust locked: 1 token per period**

Over thousands of distribution periods across multiple schemes, this accumulates to significant token loss.

**Affected Parties:**
- Profit scheme participants lose fractional shares
- Token holders experience gradual supply locked in inaccessible addresses
- Protocol suffers from inefficient token utilization

### Likelihood Explanation

**Execution Practicality:**
- **Entry Point:** Normal `DistributeProfits` and `ClaimProfits` operations trigger this automatically
- **No Attack Required:** This is a natural consequence of the rounding logic, not requiring malicious intent
- **Guaranteed Occurrence:** Happens whenever `totalAmount` is not perfectly divisible by `totalShares`

**Feasibility:**
- **Preconditions:** Standard profit distribution with multiple beneficiaries (common scenario)
- **Frequency:** Every distribution period in every profit scheme
- **Detection Difficulty:** Dust amounts are small per period, making the issue non-obvious until accumulated

**Probability:** HIGH - This occurs with normal protocol operations in virtually every profit distribution where beneficiary counts don't perfectly divide token amounts.

### Recommendation

**Code-Level Mitigation:**

1. **Track and redistribute dust:** Modify the distribution logic to track cumulative rounding errors and allocate dust to the last beneficiary or implement a rounding adjustment mechanism:

```csharp
private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares, ref long totalDistributed, bool isLast)
{
    if (isLast)
    {
        // Last beneficiary gets remaining to ensure no dust
        return totalAmount - totalDistributed;
    }
    
    var amount = (long)((decimal)totalAmount * shares / totalShares);
    totalDistributed += amount;
    return amount;
}
```

2. **Add dust recovery function:** Implement a scheme manager function to recover leftover tokens from period virtual addresses after claims are complete:

```csharp
public override Empty RecoverPeriodDust(RecoverPeriodDustInput input)
{
    var scheme = State.SchemeInfos[input.SchemeId];
    Assert(Context.Sender == scheme.Manager, "Only manager can recover dust");
    Assert(input.Period < scheme.CurrentPeriod, "Period must be completed");
    
    var periodVirtualAddress = GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);
    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
    {
        Owner = periodVirtualAddress,
        Symbol = input.Symbol
    }).Balance;
    
    if (balance > 0)
    {
        Context.SendVirtualInline(
            GeneratePeriodVirtualAddressFromHash(input.SchemeId, input.Period),
            State.TokenContract.Value,
            nameof(State.TokenContract.Transfer), 
            new TransferInput
            {
                To = scheme.Manager,
                Symbol = input.Symbol,
                Amount = balance
            }.ToByteString());
    }
    return new Empty();
}
```

3. **Invariant Check:** Add assertion to verify no significant dust accumulation exceeds expected rounding errors (e.g., < totalShares tokens).

### Proof of Concept

**Initial State:**
- Profit scheme created with SchemeId = `SCHEME_A`
- 3 beneficiaries each with 1 share (totalShares = 3)
- Period 1 is active

**Transaction Steps:**

1. **Distribute 1000 tokens:**
   ```
   DistributeProfits(
       SchemeId: SCHEME_A,
       Amount: 1000,
       Symbol: "ELF",
       Period: 1
   )
   ```

2. **Beneficiary 1 claims:**
   ```
   ClaimProfits(SchemeId: SCHEME_A, Beneficiary: ADDR_1)
   // Receives: floor(1000 * 1 / 3) = 333 tokens
   ```

3. **Beneficiary 2 claims:**
   ```
   ClaimProfits(SchemeId: SCHEME_A, Beneficiary: ADDR_2)
   // Receives: floor(1000 * 1 / 3) = 333 tokens
   ```

4. **Beneficiary 3 claims:**
   ```
   ClaimProfits(SchemeId: SCHEME_A, Beneficiary: ADDR_3)
   // Receives: floor(1000 * 1 / 3) = 333 tokens
   ```

**Expected Result:**
All 1000 tokens distributed to beneficiaries.

**Actual Result:**
- Total claimed: 333 + 333 + 333 = 999 tokens
- Dust remaining in period virtual address: 1 token
- This 1 token is permanently locked with no recovery mechanism

**Success Condition:**
Query balance of period virtual address `GetDistributedPeriodProfitsVirtualAddress(SCHEME_A, 1)` shows non-zero balance after all claims are complete, confirming permanent token lock.

### Notes

This vulnerability affects the "Economics & Treasury" critical invariant regarding "dividend distribution and settlement accuracy." The systematic loss, while small per period, accumulates significantly over time across all profit schemes in the protocol, representing a gradual token supply leakage into inaccessible virtual addresses.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L592-602)
```csharp
            var remainAmount = DistributeProfitsForSubSchemes(symbol, amount, scheme, totalShares);
            Context.LogDebug(() => $"Distributing {remainAmount} {symbol} tokens.");
            // Transfer remain amount to individuals' receiving profits address.
            if (remainAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L621-631)
```csharp
            var distributeAmount = SafeCalculateProfits(subSchemeShares.Shares, totalAmount, totalShares);
            if (distributeAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = subItemVirtualAddress,
                        Amount = distributeAmount,
                        Symbol = symbol
                    }.ToByteString());

            remainAmount = remainAmount.Sub(distributeAmount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L887-895)
```csharp
                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L51-60)
```csharp
    private Address GetDistributedPeriodProfitsVirtualAddress(Hash schemeId, long period)
    {
        return Context.ConvertVirtualAddressToContractAddress(
            GeneratePeriodVirtualAddressFromHash(schemeId, period));
    }

    private Hash GeneratePeriodVirtualAddressFromHash(Hash schemeId, long period)
    {
        return HashHelper.XorAndCompute(schemeId, HashHelper.ComputeFrom(period));
    }
```
