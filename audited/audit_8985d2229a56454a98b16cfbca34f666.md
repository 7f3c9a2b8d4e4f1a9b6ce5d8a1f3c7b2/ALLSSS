### Title
Missing Validation of ExtraBlockProducerOfPreviousRound in NextTermInput Allows Reward Manipulation

### Summary
The `NextTermInput.Create()` method accepts a Round object without validating that the `ExtraBlockProducerOfPreviousRound` field matches the actual block producer. This field is also not validated by any validation providers during block processing. A malicious miner producing a NextTerm block can manipulate this field to grant extra mining privileges and rewards to arbitrary miners or deny them to the rightful producer.

### Finding Description

The vulnerability exists across multiple components:

**1. No validation in NextTermInput.Create():** [1](#0-0) 

The `Create()` method simply copies `ExtraBlockProducerOfPreviousRound` from the input Round without any validation.

**2. Missing validation in RoundTerminateValidationProvider:** [2](#0-1) 

The validation for NextTerm only checks round number, term number, and InValues - it does NOT validate `ExtraBlockProducerOfPreviousRound`.

**3. ExtraBlockProducerOfPreviousRound excluded from hash calculation:** [3](#0-2) 

The `GetCheckableRound()` method used for hashing does not include `ExtraBlockProducerOfPreviousRound`, so even hash-based validation would not detect manipulation of this field.

**4. The field grants special mining privileges:** [4](#0-3) 

A miner whose pubkey matches `ExtraBlockProducerOfPreviousRound` can produce tiny blocks before the round starts, increasing their `ProducedBlocks` count.

**5. ProducedBlocks directly affects rewards:** [5](#0-4) 

Each tiny block increments the miner's `ProducedBlocks` counter, which is used to calculate their share of mining rewards.

**Root Cause:** The system assumes that the Round object in consensus extra data is generated honestly by `GenerateFirstRoundOfNextTerm()` where the field is correctly set: [6](#0-5) 

However, a malicious miner can modify the consensus extra data before signing the block, changing `ExtraBlockProducerOfPreviousRound` to any value, and this manipulation is not caught by any validation layer.

### Impact Explanation

**Direct Fund Impact - Reward Misallocation:**

The vulnerability enables reward manipulation in the following ways:

1. **Extra Mining Privileges:** The miner whose pubkey matches `ExtraBlockProducerOfPreviousRound` can produce additional tiny blocks before the round officially starts, which normal miners cannot do.

2. **Increased Block Production Count:** Each tiny block produced increments the miner's `ProducedBlocks` counter, as shown in the ProcessTinyBlock method.

3. **Higher Reward Share:** Mining rewards are calculated based on the total mined blocks: [7](#0-6) 

The reward amount is `minedBlocks * miningRewardPerBlock`, and miners with higher `ProducedBlocks` receive proportionally more rewards.

**Attack Scenarios:**
- **Collusion:** Malicious NextTerm producer sets `ExtraBlockProducerOfPreviousRound` to a colluding miner's pubkey, granting them extra rewards
- **Self-enrichment:** If the malicious producer is also in the new term, they can set it to their own pubkey if different from the NextTerm sender
- **Denial of Service:** Setting it to a non-existent pubkey prevents anyone from utilizing these privileges, potentially causing consensus delays

**Affected Parties:**
- The legitimate extra block producer loses rightful mining privileges and associated rewards
- Other miners receive proportionally reduced rewards when a colluding miner gains extra blocks
- Protocol integrity is compromised as rewards no longer accurately reflect work performed

### Likelihood Explanation

**Reachable Entry Point:**
The attack starts from the NextTerm transaction flow, which is a standard consensus operation triggered when term transitions are needed.

**Attacker Capabilities:**
The attacker must be a miner selected to produce the NextTerm block. This is a privileged position but realistically achievable in the normal course of consensus operation.

**Execution Practicality:**
1. Attacker produces a NextTerm block during their designated time slot
2. Before signing the block, they modify the `ExtraBlockProducerOfPreviousRound` field in the consensus extra data Round object
3. The modified block passes all validation checks:
   - `MiningPermissionValidationProvider` checks if sender is in the miner list (passes)
   - `RoundTerminateValidationProvider` validates round/term numbers and InValues (passes)
   - No validator checks `ExtraBlockProducerOfPreviousRound`
4. The transaction executes via ProcessNextTerm, storing the manipulated Round
5. In the next round, the beneficiary miner gains extra mining privileges

**Detection Constraints:**
The manipulation is difficult to detect because:
- There's no baseline to compare against (validation doesn't regenerate the expected Round)
- The field is not included in hash-based validation
- The block appears valid to all validation layers

**Economic Rationality:**
The attack has minimal cost (just modifying one field before signing) and provides direct economic benefit through increased reward allocation. For a rational attacker, the reward gain outweighs any reputational risk.

### Recommendation

**1. Add validation to verify ExtraBlockProducerOfPreviousRound matches sender:**

In `RoundTerminateValidationProvider.ValidationForNextTerm()`, add:
```csharp
// Validate ExtraBlockProducerOfPreviousRound matches sender
if (extraData.Round.ExtraBlockProducerOfPreviousRound != validationContext.SenderPubkey)
    return new ValidationResult { 
        Message = "ExtraBlockProducerOfPreviousRound must match the NextTerm block producer." 
    };
```

**2. Include ExtraBlockProducerOfPreviousRound in Round hash calculation:**

Modify `GetCheckableRound()` to include this field:
```csharp
var checkableRound = new Round
{
    RoundNumber = RoundNumber,
    TermNumber = TermNumber,
    RealTimeMinersInformation = { minersInformation },
    BlockchainAge = BlockchainAge,
    ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound  // Add this
};
```

**3. Add validation in NextTermInput.Create():**

Add defensive validation:
```csharp
public static NextTermInput Create(Round round, ByteString randomNumber, string expectedProducer)
{
    Assert(round.ExtraBlockProducerOfPreviousRound == expectedProducer,
        "ExtraBlockProducerOfPreviousRound validation failed");
    // ... rest of method
}
```

**4. Add test cases:**
- Test that NextTerm blocks with manipulated ExtraBlockProducerOfPreviousRound are rejected
- Test that legitimate ExtraBlockProducerOfPreviousRound values are accepted
- Test that reward distribution remains correct when validation is enforced

### Proof of Concept

**Initial State:**
- Blockchain at term N, round R, with miners [A, B, C, D, E]
- New term N+1 will have miners [B, C, D, E, F]
- Miner A is selected to produce the NextTerm block

**Attack Steps:**

1. **Miner A generates NextTerm consensus extra data:**
   - Calls `GetConsensusExtraDataForNextTerm()`
   - System generates Round with `ExtraBlockProducerOfPreviousRound = "A"` (Miner A's pubkey)

2. **Miner A manipulates the data:**
   - Before signing the block, modifies the Round in consensus extra data
   - Changes `ExtraBlockProducerOfPreviousRound = "B"` (Miner B's pubkey)

3. **Block validation passes:**
   - `ValidateBeforeExecution` is called
   - `RoundTerminateValidationProvider` validates round number, term number, InValues
   - NO validation checks that `ExtraBlockProducerOfPreviousRound == "A"`
   - Validation succeeds ✓

4. **Transaction execution:**
   - `GenerateConsensusTransactions` creates NextTermInput from the manipulated Round
   - `NextTerm()` calls `ProcessNextTerm()` with the NextTermInput
   - Round is stored with `ExtraBlockProducerOfPreviousRound = "B"`

5. **Exploitation in term N+1, round 1:**
   - Miner B calls `GetConsensusCommand()`
   - `ConsensusBehaviourProviderBase` checks: `CurrentRound.ExtraBlockProducerOfPreviousRound == "B"` → TRUE
   - Miner B is allowed to produce tiny blocks before round start
   - Each tiny block increments Miner B's `ProducedBlocks` counter
   - Miner B receives extra rewards

**Expected Result:** 
Miner A should receive extra mining privileges as the NextTerm block producer

**Actual Result:** 
Miner B receives the privileges instead, gaining unfair reward advantage while Miner A is denied rightful compensation

**Success Condition:**
Mining reward distribution shows Miner B with artificially inflated `ProducedBlocks` count and proportionally higher rewards compared to what they should have received.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L249-256)
```csharp
        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```
