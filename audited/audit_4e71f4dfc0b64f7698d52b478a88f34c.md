# Audit Report

## Title
Uncaught KeyNotFoundException in UpdateValueValidationProvider Causes Block Processing DoS

## Summary
The `UpdateValueValidationProvider` performs dictionary lookups without `ContainsKey` checks on miner-controlled `ProvidedRound` data. A malicious miner can exclude their own public key from the `RealTimeMinersInformation` dictionary, causing `KeyNotFoundException` to propagate as an uncaught `ContractCallException`, disrupting block validation on all nodes attempting to process the block.

## Finding Description

The consensus validation pipeline calls the ACS4 view method `ValidateConsensusBeforeExecution` to validate block header consensus data before execution. This invocation occurs through the `Call<T>` bridge method, which throws `ContractCallException` when transaction execution fails. [1](#0-0) 

The `NewConsensusInformationFilled` method directly accesses `validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey]` without checking if the key exists. Similarly, `ValidatePreviousInValue` contains two unchecked accesses: [2](#0-1) [3](#0-2) 

Note that the code checks `PreviousRound` at line 40, but NOT `ProvidedRound` (which aliases `extraData.Round`): [4](#0-3) 

The `ProvidedRound` is miner-supplied consensus extra data, while `BaseRound` is fetched from trusted StateDb: [5](#0-4) 

The earlier `MiningPermissionValidationProvider` only validates the miner's presence in `BaseRound`, not `ProvidedRound`: [6](#0-5) 

**Exception Propagation Path:**

When a `KeyNotFoundException` occurs during contract execution, `Executive.Execute()` catches it and sets `ExecutionStatus.SystemError`: [7](#0-6) 

The `Call<T>` method checks trace success and throws `ContractCallException` if execution failed: [8](#0-7) 

This exception is NOT caught by:
- `ConsensusService.ValidateConsensusBeforeExecutionAsync` [9](#0-8) 
- `ConsensusValidationProvider.ValidateBlockBeforeExecuteAsync` [10](#0-9) 
- `BlockValidationService.ValidateBlockBeforeExecuteAsync` [11](#0-10) 

`ExecuteBlocksAsync` only catches `BlockValidationException`, not `ContractCallException`: [12](#0-11) 

The exception classes are in separate hierarchies - `ContractCallException` inherits from `SmartContractBridgeException`: [13](#0-12) 

While `BlockValidationException` inherits directly from `Exception`: [14](#0-13) 

## Impact Explanation

A malicious miner can craft a block with consensus extra data where the `Round` object excludes their own public key from `RealTimeMinersInformation`. When other nodes receive and attempt to validate this block:

1. The block passes `MiningPermissionValidationProvider` (checks `BaseRound` which contains the miner)
2. `UpdateValueValidationProvider` throws `KeyNotFoundException` accessing `ProvidedRound`
3. The uncaught `ContractCallException` propagates through the validation pipeline
4. Block processing fails, disrupting synchronization and consensus

This breaks the availability guarantee of the consensus system. While the attacker loses their mining opportunity (self-harm), they can disrupt network consensus if this causes widespread block processing failures. The severity is Medium - requires miner privileges but has network-wide impact.

## Likelihood Explanation

**Prerequisites:**
- Attacker must be a scheduled miner (obtainable through normal election process)
- Attack execution is trivial (simply omit own key in `Round` object)

**Feasibility:**
The attack is straightforward to execute once miner status is obtained. The `ProvidedRound` is miner-constructed data that earlier validation providers do not fully validate. The dictionary structure allows arbitrary key omission.

**Probability:** Moderate. While miner privileges are required, the attack is detectable through exception logs but not preventable at the validation layer. The attacker's self-harm (lost mining slot) provides some deterrence but may not prevent determined adversaries or those seeking to disrupt consensus.

## Recommendation

Add `ContainsKey` checks before all dictionary accesses in `UpdateValueValidationProvider`:

```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    if (!validationContext.ProvidedRound.RealTimeMinersInformation.ContainsKey(validationContext.SenderPubkey))
        return false;
        
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    return minerInRound.OutValue != null && minerInRound.Signature != null &&
           minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
}

private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;

    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
        return true;
    
    // Add check for ProvidedRound
    if (!extraData.Round.RealTimeMinersInformation.ContainsKey(publicKey))
        return false;

    if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) 
        return true;

    var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
    var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
    if (previousInValue == Hash.Empty) return true;

    return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
}
```

Additionally, consider catching `ContractCallException` in `ConsensusValidationProvider` or `ExecuteBlocksAsync` to handle contract execution failures gracefully during validation.

## Proof of Concept

Due to the complexity of setting up a full AElf consensus environment with multiple nodes and miner rotation, a complete end-to-end test would require extensive infrastructure. However, the vulnerability can be demonstrated through a unit test that shows the exception propagation:

```csharp
[Fact]
public void UpdateValueValidationProvider_MissingMinerKey_ThrowsKeyNotFoundException()
{
    // Arrange
    var validationContext = new ConsensusValidationContext
    {
        SenderPubkey = "malicious_miner_pubkey",
        ProvidedRound = new Round
        {
            RealTimeMinersInformation = 
            {
                // Intentionally exclude SenderPubkey
                ["other_miner_1"] = new MinerInRound(),
                ["other_miner_2"] = new MinerInRound()
            }
        },
        PreviousRound = new Round(),
        ExtraData = new AElfConsensusHeaderInformation 
        { 
            Round = new Round 
            {
                RealTimeMinersInformation = 
                {
                    ["other_miner_1"] = new MinerInRound(),
                    ["other_miner_2"] = new MinerInRound()
                }
            }
        }
    };
    
    var provider = new UpdateValueValidationProvider();
    
    // Act & Assert
    Assert.Throws<KeyNotFoundException>(() => 
        provider.ValidateHeaderInformation(validationContext));
}
```

This test demonstrates that when `ProvidedRound` lacks the sender's public key, the validation provider throws `KeyNotFoundException`, which would propagate uncaught through the validation pipeline in production.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L29-30)
```csharp
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L40-40)
```csharp
        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L42-42)
```csharp
        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L45-45)
```csharp
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L19-27)
```csharp
    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-17)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
```

**File:** src/AElf.Runtime.CSharp/Executive.cs (L148-152)
```csharp
        catch (Exception ex)
        {
            CurrentTransactionContext.Trace.ExecutionStatus = ExecutionStatus.SystemError;
            CurrentTransactionContext.Trace.Error += ex + "\n";
        }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L221-221)
```csharp
        if (!trace.IsSuccessful()) throw new ContractCallException(trace.Error);
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L119-149)
```csharp
    public async Task<bool> ValidateConsensusBeforeExecutionAsync(ChainContext chainContext,
        byte[] consensusExtraData)
    {
        var now = TimestampHelper.GetUtcNow();
        _blockTimeProvider.SetBlockTime(now, chainContext.BlockHash);

        var contractReaderContext =
            await _consensusReaderContextService.GetContractReaderContextAsync(chainContext);
        var validationResult = await _contractReaderFactory
            .Create(contractReaderContext)
            .ValidateConsensusBeforeExecution
            .CallAsync(new BytesValue { Value = ByteString.CopyFrom(consensusExtraData) });

        if (validationResult == null)
        {
            Logger.LogDebug("Validation of consensus failed before execution.");
            return false;
        }

        if (!validationResult.Success)
        {
            Logger.LogDebug($"Consensus validating before execution failed: {validationResult.Message}");
            await LocalEventBus.PublishAsync(new ConsensusValidationFailedEventData
            {
                ValidationResultMessage = validationResult.Message,
                IsReTrigger = validationResult.IsReTrigger
            });
        }

        return validationResult.Success;
    }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusValidationProvider.cs (L58-78)
```csharp
    public async Task<bool> ValidateBlockBeforeExecuteAsync(IBlock block)
    {
        if (block.Header.Height == AElfConstants.GenesisBlockHeight)
            return true;

        var consensusExtraData = _consensusExtraDataExtractor.ExtractConsensusExtraData(block.Header);
        if (consensusExtraData == null || consensusExtraData.IsEmpty)
        {
            Logger.LogDebug($"Invalid consensus extra data {block}");
            return false;
        }

        var isValid = await _consensusService.ValidateConsensusBeforeExecutionAsync(new ChainContext
        {
            BlockHash = block.Header.PreviousBlockHash,
            BlockHeight = block.Header.Height - 1
        }, consensusExtraData.ToByteArray());
        if (!isValid) return false;

        return ValidateTransactionCount(block);
    }
```

**File:** src/AElf.Kernel.Core/Blockchain/Application/IBlockValidationService.cs (L35-45)
```csharp
    public async Task<bool> ValidateBlockBeforeExecuteAsync(IBlock block)
    {
        foreach (var provider in _blockValidationProviders)
            if (!await provider.ValidateBlockBeforeExecuteAsync(block))
            {
                Logger.LogDebug("Validate block before execution failed: {ProviderTypeName}", provider.GetType().Name);
                return false;
            }

        return true;
    }
```

**File:** src/AElf.Kernel.SmartContractExecution/Application/BlockchainExecutingService.cs (L61-63)
```csharp
        catch (BlockValidationException ex)
        {
            if (!(ex.InnerException is ValidateNextTimeBlockValidationException)) throw;
```

**File:** src/AElf.Kernel.SmartContract.Shared/ISmartContractBridgeContext.cs (L159-159)
```csharp
public class ContractCallException : SmartContractBridgeException
```

**File:** src/AElf.Kernel.Core/Blockchain/Application/IBlockValidationProvider.cs (L15-15)
```csharp
public class BlockValidationException : Exception
```
