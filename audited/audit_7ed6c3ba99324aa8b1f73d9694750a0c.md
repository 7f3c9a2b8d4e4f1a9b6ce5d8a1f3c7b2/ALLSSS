### Title
Quadratic Complexity DoS in Association Proposal Threshold Checks for Large Organizations

### Summary
The `IsProposalAbstained()`, `IsProposalRejected()`, and `CheckEnoughVoteAndApprovals()` functions use inefficient O(n*m) algorithms that iterate through all votes and check membership against the organization member list. An attacker can create an organization with thousands of members and have them all vote, causing the `Release()` function to perform hundreds of millions of address comparisons, leading to transaction timeout or excessive execution time.

### Finding Description

The vulnerability exists in three related functions in `Association_Helper.cs` that check voting thresholds: [1](#0-0) [2](#0-1) [3](#0-2) 

Each function uses the pattern `proposal.XYZ.Count(organization.OrganizationMemberList.Contains)` which has O(n*m) complexity where n = number of votes and m = number of organization members. The `Contains()` method on `OrganizationMemberList` iterates through the repeated field: [4](#0-3) 

These threshold checks are invoked by `IsReleaseThresholdReached()`: [5](#0-4) 

Which is called in the critical `Release()` function and the `GetProposal()` view function: [6](#0-5) [7](#0-6) 

**Root Cause:** The code stores organization members in a `repeated aelf.Address` protobuf field, resulting in a list-like data structure. When checking if a voter is a valid member, it performs linear search through all members for each vote, creating quadratic complexity.

**Why Existing Protections Fail:** While the voting functions enforce that only organization members can vote and each member can vote only once: [8](#0-7) [9](#0-8) 

These protections only limit votes to organization size but don't prevent the creation of large organizations. The validation logic has no upper bound on organization member count: [10](#0-9) 

### Impact Explanation

**Operational DoS Impact:**
- For an organization with N members where all vote, the threshold checks perform approximately 3*N² address comparisons (checking approvals, rejections, and abstentions against the member list)
- With 1,000 members: ~3,000,000 comparisons
- With 10,000 members: ~300,000,000 comparisons
- This can cause the `Release()` transaction to timeout or consume excessive execution time, effectively preventing proposal execution

**Affected Functions:**
- `Release()` - Critical governance action becomes unusable
- `GetProposal()` - View function becomes slow or times out, preventing UI/monitoring

**Who is Affected:**
- Large legitimate organizations (e.g., DAOs with 1000+ members) become unusable
- Intentionally created attack organizations cause self-DoS but demonstrate the systemic issue

**Severity Justification:** Medium severity because:
- It causes operational DoS of critical governance functionality
- No direct fund theft occurs
- Affects scalability and usability of legitimate large organizations
- The contract becomes unusable for its intended purpose at scale

### Likelihood Explanation

**Attacker Capabilities Required:**
- Create and control multiple addresses (relatively cheap on AElf)
- Create an organization with large member list
- Submit votes from all member addresses (requires paying transaction fees for each vote)

**Attack Complexity:**
- Low-Medium: Straightforward to execute once addresses are created
- Attacker needs to pay N transaction fees for N votes

**Feasibility Conditions:**
- No technical barriers prevent large organizations
- Each vote costs transaction fees, making very large attacks (10,000+ members) expensive
- Attack primarily affects the attacker's own organization

**Natural Occurrence Probability:**
- Medium: Legitimate large DAOs could naturally encounter this issue
- As ecosystem grows, organizations with 1000+ members become more likely
- Performance degradation occurs even without malicious intent

**Overall Likelihood:** Medium - While expensive to execute deliberately, the vulnerability naturally manifests in legitimate large organizations and represents a fundamental scalability limitation.

### Recommendation

**Code-Level Mitigation:**

1. **Add Maximum Organization Size Limit:** Modify the `Validate()` function in `Association_Helper.cs` to enforce an upper bound on organization members (e.g., 100-500 members):

```csharp
const int MaxOrganizationMembers = 500;
return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
       organizationMemberCount <= MaxOrganizationMembers &&
       // ... existing validations
```

2. **Use HashSet for Member Lookup:** Convert `OrganizationMemberList` to maintain a HashSet internally for O(1) lookups instead of O(m) linear search. Add a private HashSet field and populate it when members are added/removed.

3. **Alternative - Cache Valid Votes:** Instead of recalculating on every Release(), cache the count of valid member votes during the voting phase:

```csharp
// In Approve/Reject/Abstain functions, increment a counter
proposal.ValidAbstentionCount++;
// Use this counter in IsProposalAbstained instead of recomputing
```

**Invariant Checks to Add:**
- Assert organization member count ≤ MaxOrganizationMembers during creation and member addition
- Add integration test with 500+ member organization to verify performance

**Test Cases:**
- Test organization creation failure when member count exceeds limit
- Test proposal release with maximum allowed organization size
- Performance benchmark test measuring execution time for threshold checks with varying organization sizes

### Proof of Concept

**Required Initial State:**
- Association contract deployed
- Attacker controls 5,000 addresses (Address1 through Address5000)

**Transaction Steps:**

1. **Create Large Organization:**
```csharp
CreateOrganizationInput input = {
    OrganizationMemberList: { Address1, Address2, ..., Address5000 },
    ProposalReleaseThreshold: {
        MinimalApprovalThreshold: 1,
        MinimalVoteThreshold: 5000,
        MaximalAbstentionThreshold: 0,
        MaximalRejectionThreshold: 0
    },
    ProposerWhiteList: { Address1 }
}
// Result: Organization created with 5000 members
```

2. **Create Proposal:**
```csharp
CreateProposal(organizationAddress, ...)
// Result: proposalId returned
```

3. **All Members Abstain (5000 transactions):**
```csharp
For i = 1 to 5000:
    Abstain(proposalId) from Address[i]
// Result: proposal.Abstentions contains 5000 addresses
```

4. **Attempt to Release Proposal:**
```csharp
Release(proposalId) from Address1
// Expected: Transaction completes normally
// Actual: Transaction times out or takes excessive time due to
//         5000 * 5000 = 25,000,000 address comparisons in threshold checks
```

**Success Condition:** The `Release()` transaction either times out, exceeds the block execution time limit, or takes significantly longer than normal (e.g., >1 second vs <100ms for small organizations), demonstrating the quadratic complexity DoS.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L132-138)
```csharp
    private void AssertProposalNotYetVotedBySender(ProposalInfo proposal, Address sender)
    {
        var isAlreadyVoted = proposal.Approvals.Contains(sender) || proposal.Rejections.Contains(sender) ||
                             proposal.Abstentions.Contains(sender);

        Assert(!isAlreadyVoted, "Sender already voted.");
    }
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L18-42)
```csharp
    public override ProposalOutput GetProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        if (proposal == null) return new ProposalOutput();

        var organization = State.Organizations[proposal.OrganizationAddress];
        var readyToRelease = IsReleaseThresholdReached(proposal, organization);

        return new ProposalOutput
        {
            ProposalId = proposalId,
            ContractMethodName = proposal.ContractMethodName,
            ExpiredTime = proposal.ExpiredTime,
            OrganizationAddress = proposal.OrganizationAddress,
            Params = proposal.Params,
            Proposer = proposal.Proposer,
            ToAddress = proposal.ToAddress,
            ToBeReleased = readyToRelease,
            ApprovalCount = proposal.Approvals.Count,
            RejectionCount = proposal.Rejections.Count,
            AbstentionCount = proposal.Abstentions.Count,
            Title = proposal.Title,
            Description = proposal.Description
        };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L163-181)
```csharp
    public override Empty Abstain(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Abstentions.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Abstain),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```
