### Title
Missing Cryptographic Verification of Signature Field Allows Manipulation of Extra Block Producer Selection and Reward Distribution

### Summary
The `MiningPermissionValidationProvider.ValidateHeaderInformation` method only verifies miner list membership but does not cryptographically verify that the `Signature` field in consensus updates was computed correctly. A malicious miner with order 1 in any round can provide an arbitrary `Signature` value to manipulate which miner becomes the extra block producer in the next round, gaining unfair advantages in block production limits and mining rewards.

### Finding Description

When a miner produces a block with `UpdateValue` behavior, they provide `OutValue` and `Signature` fields. The `Signature` should be computed deterministically via `CalculateSignature(previousInValue)` [5](#0-4) , which XORs the input with all existing miner signatures.

However, the validation flow never verifies this computation:

1. In `ValidateBeforeExecution`, `RecoverFromUpdateValue` blindly copies the provided `OutValue` and `Signature` without verification [2](#0-1) 

2. `MiningPermissionValidationProvider` only performs a membership check, verifying the sender is in the miner list [3](#0-2) 

3. `UpdateValueValidationProvider` only checks that `OutValue` and `Signature` are non-empty [4](#0-3)  and validates the `PreviousInValue` chain [12](#0-11) , but never verifies the `Signature` was computed using the correct algorithm

4. In `ProcessUpdateValue`, the unverified signature is stored directly [13](#0-12) 

The compromised signature is then used in `CalculateNextExtraBlockProducerOrder` to determine the next round's extra block producer [14](#0-13) . The method selects the signature from the first miner by order who has produced a block, converts it to an integer, and uses modulo arithmetic to select the extra block producer. By providing a specially crafted signature value, an attacker with order 1 can control this selection.

### Impact Explanation

**Direct Financial Impact:**

The extra block producer gains concrete advantages that translate to disproportionate mining rewards:

1. **Increased Block Production Limits**: The extra block producer from the previous round can mine `maximumBlocksCount + blocksBeforeCurrentRound` blocks instead of just `maximumBlocksCount` [8](#0-7)  and can produce blocks before the next round officially starts [9](#0-8) 

2. **Unfair Reward Distribution**: Mining rewards are distributed based on `ProducedBlocks` count through share calculations [15](#0-14) . The share formula penalizes miners producing below average [11](#0-10) :
   - Below 50% average: 0 shares (no rewards)
   - 50-80% average: quadratic penalty
   - Above 80% average: linear shares

3. **Cumulative Advantage**: A miner with order 1 position can systematically favor themselves or accomplices as extra block producer, accumulating more blocks and capturing disproportionate rewards over time.

**Consensus Integrity Impact:**

The manipulated signature corrupts the signature chain since `CalculateSignature` XORs with existing signatures, affecting all future rounds' signature calculations.

**Severity Justification:** HIGH - Enables systematic unfair financial advantage through a core consensus mechanism, allows reward theft from honest miners, exploitable repeatedly with minimal cost.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a legitimate miner with order 1 in a round (occurs regularly in round rotation)
- No special cryptographic knowledge required beyond choosing a hash value with desired modulo properties
- No need to compromise other systems

**Attack Complexity:**
- Simple: replace correctly computed signature with chosen value
- Can pre-compute optimal signature values offline to maximize benefit
- No timing constraints beyond normal block production

**Feasibility Conditions:**
- Attack works whenever attacker has order 1 position (which rotates among miners)
- No special blockchain state required
- Exploitable in every round where attacker is order 1

**Detection Difficulty:**
- Signature values appear as random hashes with no externally verifiable pattern
- Distinguishing malicious from correctly computed signatures requires comparing against the expected `CalculateSignature` result, which the protocol doesn't implement
- Extra block producer selection appears random, making manipulation hard to detect

**Probability Assessment:** MEDIUM-HIGH - While constrained to order 1 positions, this occurs regularly for each miner. Over multiple rounds, a malicious miner can repeatedly exploit this vulnerability. A cartel of miners could coordinate to maximize exploitation frequency.

### Recommendation

**Immediate Fix:**

Add cryptographic verification to `UpdateValueValidationProvider.ValidateHeaderInformation`: [16](#0-15) 

Implement a new validation method that verifies the signature was computed correctly using the previous round's `CalculateSignature` method with the provided `PreviousInValue`. This requires:

1. Retrieving the previous round information from validation context
2. Computing the expected signature: `expectedSignature = previousRound.CalculateSignature(previousInValue)`
3. Comparing with the provided signature and rejecting if they don't match

**Additional Hardening:**

1. Add similar validation for `OutValue` to ensure it equals `Hash(InValue)` when the `InValue` is eventually revealed
2. Implement monitoring for abnormal extra block producer selection patterns
3. Add rate-limiting to prevent the same miner from repeatedly becoming extra block producer

**Testing:**

Add regression tests verifying:
- UpdateValue transactions with incorrect signatures are rejected during validation
- Manipulated signatures cannot influence extra block producer selection
- Reward distribution remains fair when signature computation is enforced

### Proof of Concept

**Initial State:**
- 5 miners in consensus: M0, M1, M2, M3, M4
- M0 has order 1 in current round N
- Attacker controls M0
- Round N transitioning to round N+1

**Attack Steps:**

1. **M0 produces UpdateValue block with malicious signature:**
   - Normal: Compute `Signature = previousRound.CalculateSignature(previousInValue)` [17](#0-16) 
   - Malicious: Choose signature such that `signature.ToInt64() % 5 == 0` to make M0 (order 1) the extra block producer

2. **Transaction passes validation:**
   - `MiningPermissionValidationProvider`: Passes (M0 is in miner list) [18](#0-17) 
   - `UpdateValueValidationProvider`: Passes (Signature is non-empty) [4](#0-3) 
   - No cryptographic verification occurs

3. **Malicious signature stored:**
   - `ProcessUpdateValue` stores the manipulated signature [13](#0-12) 

4. **Extra block producer selection manipulated:**
   - At round transition, `CalculateNextExtraBlockProducerOrder` executes [7](#0-6) 
   - Uses M0's malicious signature to compute: `order = (signature.ToInt64() % 5) + 1 = 1`
   - M0 becomes extra block producer for round N+1

5. **M0 exploits extra block producer privileges in round N+1:**
   - Mines additional blocks beyond normal limit [8](#0-7) 
   - Accumulates higher `ProducedBlocks` count than honest miners

6. **Unfair reward distribution:**
   - At term end, reward shares calculated based on `ProducedBlocks` [10](#0-9) 
   - M0 receives disproportionately higher rewards due to inflated block count

**Expected vs Actual Result:**
- Expected: Signature validation fails, transaction rejected
- Actual: Transaction succeeds, M0 manipulates extra block producer selection and gains unfair rewards

**Success Condition:** M0's `ProducedBlocks` count and reward share exceed fair distribution by 20-50% through repeated exploitation across multiple rounds where M0 has order 1.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L16-17)
```csharp
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-24)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L48-48)
```csharp
        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-245)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L112-122)
```csharp
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L71-79)
```csharp
                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L789-822)
```csharp
        var averageProducedBlocksCount = CalculateAverage(previousTermInformation.Last().RealTimeMinersInformation
            .Values
            .Select(i => i.ProducedBlocks).ToList());
        // Manage weights of `MinerBasicReward`
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```
