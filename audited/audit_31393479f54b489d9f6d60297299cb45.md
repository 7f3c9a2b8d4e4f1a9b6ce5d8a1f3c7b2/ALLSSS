### Title
Signature Forgery Enables Mining Order Manipulation in AEDPoS Consensus

### Summary
The `RecoverFromUpdateValue()` function and `ProcessUpdateValue()` method accept miner-provided signatures without cryptographic verification, allowing malicious miners to forge arbitrary signature values. Since `SupposedOrderOfNextRound` is calculated directly from the signature value, attackers can manipulate their mining position in subsequent rounds, breaking consensus randomness and fairness guarantees.

### Finding Description

**Root Cause:**
The consensus validation flow fails to verify that provided signatures are correctly calculated using the `CalculateSignature()` method. The signature should be computed as `XOR(inValue, XOR of all previous miner signatures)`, [1](#0-0)  but this verification is never performed.

**Vulnerable Code Locations:**

1. In `RecoverFromUpdateValue()`, the signature is copied directly from provided data without validation: [2](#0-1) 

2. The function also copies `SupposedOrderOfNextRound` for all miners from the provided round: [3](#0-2) 

3. In `ProcessUpdateValue()`, both signature and order values are directly accepted from user input: [4](#0-3) 

**Insufficient Validation:**
The `UpdateValueValidationProvider` only verifies that signature and outvalue are non-empty, not that they are cryptographically correct: [5](#0-4) 

**Order Calculation Dependency:**
The mining order for the next round is calculated directly from the signature value using: [6](#0-5) 

Where `GetAbsModulus` is defined as: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Breach:**
- A malicious miner can choose their mining position in the next round by crafting a signature value that produces their desired `SupposedOrderOfNextRound`
- For example, to mine first (order = 1), they need `GetAbsModulus(signature.ToInt64(), minersCount) == 0`
- This completely breaks the randomness guarantee of the AEDPoS consensus mechanism

**Unfair Mining Advantages:**
- Consistently mining first provides maximum MEV (Miner Extractable Value) opportunities
- First miner can reorder/censor transactions within their block production window
- Higher visibility and influence over block content
- Potential for unfair reward accumulation across multiple rounds

**Protocol-Wide Impact:**
- Violates the core security assumption that mining order is unpredictably randomized
- Any of the authorized miners can exploit this independently
- Can be exploited repeatedly without detection through on-chain validation
- Undermines trust in consensus fairness

**Severity: CRITICAL** - Directly compromises consensus mechanism integrity, a foundational security property of the blockchain.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an authorized miner (verified by `MiningPermissionValidationProvider`) [8](#0-7) 
- This is a realistic precondition as the attack is BY a miner, not against miner authorization

**Attack Complexity: LOW**
1. Calculate desired order position (e.g., order = 1 for first position)
2. Work backwards to find signature value: `signature.ToInt64() % minersCount == (desiredOrder - 1)`
3. Construct `UpdateValueInput` with forged signature and calculated `SupposedOrderOfNextRound`
4. Submit the block with this consensus data
5. Validation accepts it since no signature correctness check exists

**Execution Practicality:**
- Entry point is the block production flow via `UpdateValue()` transaction [9](#0-8) 
- Executed during normal mining operations through `ProcessConsensusInformation()` [10](#0-9) 
- No additional state changes or complex preconditions required

**Detection Difficulty:**
- The forged values pass all existing validation checks
- Hash comparison in `ValidateConsensusAfterExecution` succeeds because `RecoverFromUpdateValue` has already modified the current round to match the provided data [11](#0-10) 
- No on-chain mechanism can detect the forgery without re-computing expected signature

**Likelihood: HIGH** - Any authorized miner can exploit this with minimal effort and no risk of detection through the validation system.

### Recommendation

**Immediate Fix:**
Add signature verification in the validation flow. Modify `UpdateValueValidationProvider` or add a new provider:

```csharp
// Add to UpdateValueValidationProvider.ValidateHeaderInformation()
if (!ValidateSignature(validationContext))
    return new ValidationResult { Message = "Invalid signature - does not match calculated value." };

private bool ValidateSignature(ConsensusValidationContext validationContext)
{
    var providedMinerInfo = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    var providedSignature = providedMinerInfo.Signature;
    var inValue = providedMinerInfo.PreviousInValue; // or current InValue depending on logic
    
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(inValue);
    
    return providedSignature == expectedSignature;
}
```

**Additional Validations:**
1. Verify `SupposedOrderOfNextRound` matches the signature-based calculation:
   ```csharp
   var expectedOrder = GetAbsModulus(providedSignature.ToInt64(), minersCount) + 1;
   if (providedMinerInfo.SupposedOrderOfNextRound != expectedOrder)
       return new ValidationResult { Message = "SupposedOrderOfNextRound does not match signature." };
   ```

2. Add invariant checks in `ProcessUpdateValue()` before accepting the values

3. Consider storing signature calculation logs for auditing

**Test Cases:**
1. Test that forged signatures are rejected during validation
2. Test that correctly calculated signatures are accepted
3. Test that manipulated `SupposedOrderOfNextRound` values are detected
4. Regression test for legitimate UpdateValue transactions

### Proof of Concept

**Initial State:**
- Current round has 21 authorized miners
- Attacker is one of the authorized miners with pubkey `ATTACKER_PUBKEY`
- Current round number is N

**Attack Steps:**

1. **Calculate Target Signature:**
   - Attacker wants to mine first in round N+1 (order = 1)
   - Required: `GetAbsModulus(signature.ToInt64(), 21) + 1 == 1`
   - Therefore: `signature.ToInt64() % 21 == 0`
   - Choose signature: Create Hash with `ToInt64() == 0` or `21` or `42`, etc.

2. **Construct Malicious UpdateValueInput:**
   ```
   UpdateValueInput {
       Signature: <forged_signature_with_toInt64_equals_0>,
       SupposedOrderOfNextRound: 1,
       OutValue: <legitimate_outvalue>,
       PreviousInValue: <legitimate_previousInValue>,
       // ... other fields
   }
   ```

3. **Submit Block:**
   - Produce block with UpdateValue behavior
   - Include the malicious UpdateValueInput in consensus extra data

4. **Validation Flow:**
   - `ValidateConsensusBeforeExecution` calls `RecoverFromUpdateValue()` which copies the forged signature
   - `UpdateValueValidationProvider` only checks signature is non-empty ✓
   - No validation compares signature with `CalculateSignature()` result
   - Validation passes ✓

5. **State Update:**
   - `ProcessUpdateValue()` accepts the forged values and updates state
   - Round information now contains: `minerInRound.Signature = <forged_signature>` and `minerInRound.SupposedOrderOfNextRound = 1`

**Expected Result:** Attacker should be rejected for providing invalid signature

**Actual Result:** Attacker successfully manipulates their mining order to position 1 in round N+1

**Success Verification:** Query round N+1 information and observe attacker at `Order = 1`, demonstrating successful manipulation of consensus mining schedule.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L245-248)
```csharp
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L17-17)
```csharp
        minerInRound.Signature = providedInformation.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L21-53)
```csharp
    private void ProcessConsensusInformation(dynamic input, [CallerMemberName] string callerMethodName = null)
    {
        EnsureTransactionOnlyExecutedOnceInOneBlock();

        Context.LogDebug(() => $"Processing {callerMethodName}");

        /* Privilege check. */
        if (!PreCheck()) Assert(false, "No permission.");

        State.RoundBeforeLatestExecution.Value = GetCurrentRoundInformation(new Empty());

        ByteString randomNumber = null;

        // The only difference.
        switch (input)
        {
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
                break;
            case UpdateValueInput updateValueInput:
                randomNumber = updateValueInput.RandomNumber;
                ProcessUpdateValue(updateValueInput);
                break;
            case TinyBlockInput tinyBlockInput:
                randomNumber = tinyBlockInput.RandomNumber;
                ProcessTinyBlock(tinyBlockInput);
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-247)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-101)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```
