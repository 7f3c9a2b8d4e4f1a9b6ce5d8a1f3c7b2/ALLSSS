### Title
Empty Miner List Acceptance Causes Permanent Side Chain Consensus DoS via Division by Zero

### Summary
The `UpdateInformationFromCrossChain()` function does not validate that `consensusInformation.Round.RealTimeMinersInformation` is non-empty before extracting keys and committing the miner list to state. This allows an empty miner list to be stored, which causes a division-by-zero exception in subsequent calls during resource token distribution, permanently breaking side chain consensus updates.

### Finding Description

**Root Cause:**
The function extracts miner keys without validation [1](#0-0)  and commits them to state [2](#0-1) . The only validation checks are for null/empty input and round number comparison [3](#0-2) , but there is no check ensuring `RealTimeMinersInformation` contains at least one miner.

**Execution Path:**

1. First malicious call: Empty `RealTimeMinersInformation` bypasses all checks and gets committed to `State.MainChainCurrentMinerList.Value`

2. Subsequent calls: `DistributeResourceTokensToPreviousMiners()` is invoked before miner list update [4](#0-3) 

3. Function retrieves the empty miner list [5](#0-4) 

4. Division by zero occurs when calculating distribution amount [6](#0-5) 

5. The `Div` method throws `DivideByZeroException` [7](#0-6) , causing transaction failure

**Why Protections Fail:**

The cross-chain contract passes consensus data without validation [8](#0-7) . The check for empty miner list in `IsMainChainMinerListChanged` [9](#0-8)  only prevents usage but doesn't prevent storage of empty lists. The guard at line 83 checking `amount <= 0` comes AFTER the division [10](#0-9) .

### Impact Explanation

**Consensus Integrity Violation:**
- Side chain permanently loses ability to update its miner list from parent chain
- All subsequent `UpdateInformationFromCrossChain` calls fail with unrecoverable exception
- Consensus system breaks if empty miner list is used in round generation [11](#0-10) 
- No miners available means no blocks can be produced [12](#0-11) 

**Operational Impact:**
- Complete side chain halt requiring hard fork or chain restart
- All transactions, smart contracts, and cross-chain operations stopped
- Economic damage from chain downtime and loss of user confidence
- Affects entire side chain ecosystem, not just consensus

**Severity:** Critical - permanent DoS of core consensus functionality with no recovery path.

### Likelihood Explanation

**Reachable Entry Point:**
The function is callable by the cross-chain contract, which is a system contract [13](#0-12) .

**Attack Vectors:**
1. **Compromised parent chain:** Malicious parent chain sends consensus information with empty miner list
2. **Cross-chain indexing exploit:** Attacker manipulates parent chain block data through compromised proposal system [14](#0-13) 
3. **Data corruption:** Bug in parent chain consensus contract generates invalid round with no miners

**Execution Practicality:**
- Single malicious cross-chain consensus update triggers the vulnerability
- No complex preconditions required beyond getting malicious data indexed
- Attack persists permanently after single successful execution
- No economic cost barrier if parent chain is compromised

**Feasibility:** High - requires either compromised parent chain or cross-chain proposal system, but single successful attack causes permanent damage.

### Recommendation

**Immediate Fix:**
Add validation before extracting miner keys in `UpdateInformationFromCrossChain`:

```csharp
// After line 46, before line 57:
Assert(
    consensusInformation.Round.RealTimeMinersInformation.Count > 0,
    "Miner list cannot be empty.");
```

**Additional Safeguards:**
1. Add empty check in `DistributeResourceTokensToPreviousMiners` before division:
```csharp
// After line 72:
if (minerList.Count == 0) return;
```

2. Add validation in cross-chain contract before calling consensus update [15](#0-14) 

3. Add invariant check: `State.MainChainCurrentMinerList.Value.Pubkeys.Count > 0` after any miner list update

**Test Cases:**
1. Test `UpdateInformationFromCrossChain` with empty `RealTimeMinersInformation` - should revert
2. Test two consecutive calls where first has empty list - should revert on first call
3. Test `DistributeResourceTokensToPreviousMiners` with empty miner list - should handle gracefully
4. Integration test validating cross-chain data with empty consensus info is rejected

### Proof of Concept

**Initial State:**
- Side chain running with valid miner list from initialization
- Cross-chain contract has indexing permissions

**Attack Sequence:**

**Step 1:** Prepare malicious consensus data
```
headerInformation = new AElfConsensusHeaderInformation {
    Round = new Round {
        RoundNumber = CurrentRoundNumber + 1,
        RealTimeMinersInformation = {} // Empty!
    }
}
```

**Step 2:** First call via cross-chain contract
```
CrossChainContract.IndexParentChainBlockData(
    parentChainBlockData with ExtraData["Consensus"] = headerInformation.ToByteString()
)
→ Calls UpdateInformationFromCrossChain
→ DistributeResourceTokensToPreviousMiners() succeeds (uses old miner list)
→ Empty miner list committed to State.MainChainCurrentMinerList.Value
→ Returns successfully
```

**Step 3:** Second call (any subsequent update)
```
CrossChainContract.IndexParentChainBlockData(any parent chain data)
→ Calls UpdateInformationFromCrossChain
→ Line 53: DistributeResourceTokensToPreviousMiners() called
→ Line 72: minerList.Count = 0
→ Line 81: balance.Div(0) → DivideByZeroException
→ Transaction fails
→ Side chain consensus update permanently broken
```

**Success Condition:**
All future `UpdateInformationFromCrossChain` calls fail with division by zero, preventing miner list synchronization and potentially halting block production when empty list is used in consensus logic.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L34-36)
```csharp
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L41-47)
```csharp
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L53-53)
```csharp
        DistributeResourceTokensToPreviousMiners();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L57-57)
```csharp
        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L58-61)
```csharp
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L72-72)
```csharp
        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L81-81)
```csharp
            var amount = balance.Div(minerList.Count);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L83-83)
```csharp
            if (amount <= 0) continue;
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L227-234)
```csharp
    private void UpdateConsensusInformation(ByteString bytes)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        Context.SendInline(State.CrossChainInteractionContract.Value,
            nameof(State.CrossChainInteractionContract.UpdateInformationFromCrossChain),
            new BytesValue { Value = bytes });
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L761-807)
```csharp
    private IndexedParentChainBlockData IndexParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData)
    {
        var parentChainId = State.ParentChainId.Value;
        var currentHeight = State.CurrentParentChainHeight.Value;
        var indexedParentChainBlockData = new IndexedParentChainBlockData
        {
            LocalChainHeight = Context.CurrentHeight
        };
        for (var i = 0; i < parentChainBlockData.Count; i++)
        {
            var blockInfo = parentChainBlockData[i];
            AssertParentChainBlock(parentChainId, currentHeight, blockInfo);
            var parentChainHeight = blockInfo.Height;
            State.ParentChainTransactionStatusMerkleTreeRoot[parentChainHeight] =
                blockInfo.TransactionStatusMerkleTreeRoot;
            foreach (var indexedBlockInfo in blockInfo.IndexedMerklePath)
            {
                BindParentChainHeight(indexedBlockInfo.Key, parentChainHeight);
                AddIndexedTxRootMerklePathInParentChain(indexedBlockInfo.Key, indexedBlockInfo.Value);
            }

            // send consensus data shared from main chain  
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }

            if (blockInfo.CrossChainExtraData != null)
                State.TransactionMerkleTreeRootRecordedInParentChain[parentChainHeight] =
                    blockInfo.CrossChainExtraData.TransactionStatusMerkleTreeRoot;

            indexedParentChainBlockData.ParentChainBlockDataList.Add(blockInfo);
            currentHeight += 1;
        }

        State.CurrentParentChainHeight.Value = currentHeight;
        
        Context.Fire(new ParentChainIndexed
        {
            ChainId = parentChainId,
            IndexedHeight = currentHeight
        });

        return indexedParentChainBlockData;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L290-291)
```csharp
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L351-353)
```csharp
        return State.MainChainCurrentMinerList.Value.Pubkeys.Any() &&
               GetMinerListHash(currentRound.RealTimeMinersInformation.Keys) !=
               GetMinerListHash(State.MainChainCurrentMinerList.Value.Pubkeys.Select(p => p.ToHex()));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L23-38)
```csharp
        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }
```
