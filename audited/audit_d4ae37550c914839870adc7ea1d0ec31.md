### Title
Insufficient Validation of PreviousInValue for Non-Sender Miners Allows Consensus State Corruption

### Summary
The `GetUpdateValueRound()` function copies `PreviousInValue` for all miners into the block header, but during validation, only the sender's `PreviousInValue` is verified against their previous round's `OutValue`. A malicious miner can inject arbitrary `PreviousInValue` values for other miners through the `revealed_in_values` field in trigger information, which are then propagated without validation, corrupting consensus state for miners who haven't produced blocks yet.

### Finding Description

The vulnerability exists across multiple consensus data flow components:

**1. Unvalidated PreviousInValue Propagation in Block Header:**

In `GetUpdateValueRound()`, the `PreviousInValue` is copied for all miners without validation: [1](#0-0) [2](#0-1) 

**2. Injection Point via Revealed InValues:**

In `UpdateLatestSecretPieces()`, a miner can set arbitrary `PreviousInValue` for other miners (whose `PreviousInValue` is currently empty) via the `revealed_in_values` field in trigger information: [3](#0-2) 

**3. Recovery Without Validation:**

During block validation, `RecoverFromUpdateValue()` copies ALL miners' `PreviousInValue` from the provided round to the base round: [4](#0-3) 

**4. Validation Gap:**

The `UpdateValueValidationProvider` only validates the sender's `PreviousInValue`, not other miners': [5](#0-4) 

The validation explicitly checks only `publicKey = validationContext.SenderPubkey`, leaving other miners' values unverified.

**5. Usage of Corrupted Values:**

The corrupted `PreviousInValue` is later used in `SupplyCurrentRoundInformation()` to calculate signatures for miners who didn't produce blocks: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Violation:**
- A malicious miner can inject `PreviousInValue` values that do NOT hash to the corresponding miner's `OutValue` from the previous round
- This violates the fundamental invariant that `Hash(PreviousInValue) == OutValue_previous_round`

**Concrete Harm:**
1. **Signature Corruption**: For miners who miss their time slots, the incorrect `PreviousInValue` is used to calculate their signature, corrupting the signature chain used for random number generation
2. **Secret Sharing Compromise**: The incorrect values propagate through the secret sharing mechanism via `MinersPreviousInValues` [7](#0-6) 

3. **State Persistence**: Once stored via round updates, the corrupted values become part of the persistent consensus state [8](#0-7) 

**Who is Affected:**
- All network participants relying on consensus integrity
- Miners whose `PreviousInValue` is corrupted
- Random number generation and block production schedules

### Likelihood Explanation

**Attacker Capabilities:**
- Any active miner in the current round can exploit this
- No special privileges required beyond normal block production rights
- Attack can be launched from the miner's consensus node

**Attack Complexity:**
- LOW: Attacker simply provides malicious `revealed_in_values` map in their `AElfConsensusTriggerInformation` [9](#0-8) 

**Feasibility Conditions:**
- Target miner must have `PreviousInValue == Hash.Empty || PreviousInValue == null` (miners who haven't produced blocks yet in current round)
- Secret sharing must be enabled (checked via configuration) [10](#0-9) 

**Detection Constraints:**
- No validation prevents this attack
- Corrupted values appear legitimate in block headers
- Only detectable through post-hoc forensic analysis comparing `PreviousInValue` hashes with previous round's `OutValue`

**Probability: HIGH** - The attack is straightforward for any malicious miner, requires no sophisticated techniques, and bypasses all existing validations.

### Recommendation

**1. Add Validation for All Miners' PreviousInValue:**

Extend `UpdateValueValidationProvider.ValidatePreviousInValue()` to validate ALL miners' `PreviousInValue` values copied in the round, not just the sender's:

```csharp
// In UpdateValueValidationProvider.cs
private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;

    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
        return true;

    // Validate sender's PreviousInValue (existing check)
    if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue != null &&
        extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue != Hash.Empty)
    {
        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (HashHelper.ComputeFrom(previousInValue) != previousOutValue)
            return false;
    }

    // NEW: Validate ALL other miners' PreviousInValue
    foreach (var minerInfo in extraData.Round.RealTimeMinersInformation)
    {
        if (minerInfo.Key == publicKey) continue; // Already checked
        
        var otherMinerPrevInValue = minerInfo.Value.PreviousInValue;
        if (otherMinerPrevInValue == null || otherMinerPrevInValue == Hash.Empty)
            continue;
            
        // Check if this miner existed in previous round
        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(minerInfo.Key))
            continue;
            
        var expectedOutValue = validationContext.PreviousRound.RealTimeMinersInformation[minerInfo.Key].OutValue;
        if (expectedOutValue == null || expectedOutValue == Hash.Empty)
            continue;
            
        // Validate: Hash(PreviousInValue) must equal OutValue from previous round
        if (HashHelper.ComputeFrom(otherMinerPrevInValue) != expectedOutValue)
            return false;
    }

    return true;
}
```

**2. Add Validation in UpdateLatestSecretPieces:**

Before setting `PreviousInValue` from `revealed_in_values`, verify it hashes to the miner's previous `OutValue`: [3](#0-2) 

**3. Add Test Cases:**

- Test that blocks with invalid `PreviousInValue` for non-sender miners are rejected
- Test that correct `revealed_in_values` are accepted
- Test edge cases: new miners, miners with no previous round data

### Proof of Concept

**Initial State:**
- 5 miners in current round: Alice (malicious), Bob, Carol, Dave, Eve
- Bob has not produced blocks yet in current round, so `Bob.PreviousInValue == Hash.Empty`
- Bob's `OutValue` in previous round was `Hash("Bob_Previous_InValue")`

**Attack Steps:**

1. **Alice produces a block with UpdateValue behavior:**
   - Alice crafts her `AElfConsensusTriggerInformation` with:
     ```
     revealed_in_values = {
       "Bob": Hash("MALICIOUS_VALUE")  // Does NOT hash to Bob's previous OutValue
     }
     ```

2. **Block generation flow:**
   - `UpdateLatestSecretPieces()` sets `Bob.PreviousInValue = Hash("MALICIOUS_VALUE")`
   - `GetUpdateValueRound()` copies this malicious value into the simplified round
   - Block header contains corrupted `Bob.PreviousInValue`

3. **Block validation (should fail but doesn't):**
   - `RecoverFromUpdateValue()` copies malicious value to base round
   - `UpdateValueValidationProvider` only validates Alice's `PreviousInValue` ✓
   - Bob's malicious `PreviousInValue` is NOT validated ✗
   - Block is accepted

4. **State corruption:**
   - `ProcessUpdateValue()` persists the round with corrupted Bob's `PreviousInValue`
   - If Bob continues to not produce blocks, `SupplyCurrentRoundInformation()` uses the corrupted value to calculate Bob's signature

**Expected Result:**
Block validation should REJECT the block because `Hash("MALICIOUS_VALUE") != Hash("Bob_Previous_InValue")`

**Actual Result:**
Block is ACCEPTED, and Bob's `PreviousInValue` is corrupted in consensus state

**Success Condition:**
Query the round information after block execution and verify `Bob.PreviousInValue == Hash("MALICIOUS_VALUE")` instead of the correct value, and that `Hash(Bob.PreviousInValue) != Bob.PreviousRound.OutValue`

### Notes

This vulnerability specifically affects the secret sharing mechanism when enabled. The root cause is the asymmetric validation: while a miner's own `PreviousInValue` must prove they know the preimage of their previous `OutValue` (commit-reveal scheme), they can arbitrarily set other miners' revealed values without cryptographic proof. The validation provider should enforce the invariant `Hash(PreviousInValue) == OutValue_previous_round` for ALL miners whose `PreviousInValue` is included in the block header, not just the sender.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L27-27)
```csharp
                    PreviousInValue = minerInRound.PreviousInValue,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L51-51)
```csharp
                    PreviousInValue = information.Value.PreviousInValue
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L122-125)
```csharp
        if (IsSecretSharingEnabled())
        {
            UpdateLatestSecretPieces(updatedRound, pubkey, triggerInformation);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L28-29)
```csharp
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L38-48)
```csharp
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** protobuf/aedpos_contract.proto (L343-343)
```text
    map<string, aelf.Hash> revealed_in_values = 7;
```
