### Title
Missing Range Validation on SupposedOrderOfNextRound Allows Consensus Order Manipulation

### Summary
The `GetMinedMiners()` function only validates that `SupposedOrderOfNextRound != 0` but does not enforce the valid range of `[1, minersCount]`. A malicious miner can submit an `UpdateValue` transaction with an out-of-range `SupposedOrderOfNextRound` value, which bypasses validation and corrupts next round order assignments, disrupts the continuous mining prevention mechanism, and manipulates extra block producer selection.

### Finding Description

The vulnerability exists across multiple components of the consensus mechanism:

**Root Cause Location 1 - Insufficient Filter Check:** [1](#0-0) 

The `GetMinedMiners()` function only checks if `SupposedOrderOfNextRound != 0`, allowing any non-zero value (including negative numbers or values exceeding `minersCount`) to pass.

**Root Cause Location 2 - Direct Assignment Without Validation:** [2](#0-1) 

The `ProcessUpdateValue` method directly assigns user-supplied `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` values from `UpdateValueInput` without any range validation.

**Root Cause Location 3 - Incomplete Validation Provider:** [3](#0-2) 

The `UpdateValueValidationProvider` only validates that `OutValue` and `Signature` are filled, and that `PreviousInValue` is correct. It performs no validation on the `SupposedOrderOfNextRound` field.

**Root Cause Location 4 - Insufficient NextRound Validation:** [4](#0-3) 

The `NextRoundMiningOrderValidationProvider` only checks that distinct count of `FinalOrderOfNextRound > 0` matches miners with `OutValue`, but doesn't validate the range is within `[1, minersCount]`.

**Expected Calculation:** [5](#0-4) 

The correct calculation using `GetAbsModulus(sigNum, minersCount) + 1` ensures the value is always in range `[1, minersCount]`. However, this is bypassed when values are directly submitted via `UpdateValueInput`.

**Impact on Round Generation:** [6](#0-5) 

When `GenerateNextRoundInformation` processes miners with out-of-range orders, it assigns invalid order values to the next round, leaving some valid orders unassigned and creating miners with orders outside the valid range.

### Impact Explanation

**Consensus Integrity Compromise:**
1. **Invalid Order Assignment**: A miner with `SupposedOrderOfNextRound = 100` (when `minersCount = 5`) receives order 100 in the next round, while valid order slots remain unassigned or are incorrectly distributed.

2. **BreakContinuousMining Bypass:** [7](#0-6) 

The safety mechanism preventing a miner from producing both the extra block and first block of next round can be bypassed. When the intended last miner (order = `minersCount`) has an out-of-range order instead, line 94's `FirstOrDefault(i => i.Order == minersCount)` returns null, causing the check to return early without preventing continuous mining.

3. **Extra Block Producer Manipulation:** [8](#0-7) 

The calculated `extraBlockProducerOrder` (always in `[1, minersCount]`) may not find the intended miner if they have an out-of-range order, causing the fallback to assign the first miner as extra block producer instead.

4. **Mining Schedule Disruption**: Miners with out-of-range orders receive `ExpectedMiningTime` calculated as `currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order))`, creating slots far beyond the normal round duration.

**Affected Parties:**
- All network participants relying on consensus ordering
- Legitimate miners whose time slots are disrupted
- Block production schedule integrity

### Likelihood Explanation

**Attack Prerequisites:**
- Attacker must be a legitimate miner in the current round (publicly verifiable state)
- No special privileges beyond normal miner capabilities required

**Attack Execution:**
1. Attacker waits for their mining turn
2. Generates consensus information normally via client
3. Intercepts and modifies `UpdateValueInput.SupposedOrderOfNextRound` to out-of-range value (e.g., 0, -1, or 1000)
4. Submits modified `UpdateValue` transaction during block production
5. Transaction passes all validation checks due to missing range validation
6. Out-of-range value is stored in round state
7. Impact manifests when `NextRound` is triggered and `GenerateNextRoundInformation` processes the corrupted data

**Attack Complexity:** Low
- Single transaction modification
- No complex timing requirements
- No need to compromise other components
- Deterministic outcome

**Detection Difficulty:** Medium
- Out-of-range values are stored on-chain but may not trigger immediate errors
- Impact becomes visible during next round generation
- Round information is queryable, but unusual order values might be overlooked without specific monitoring

**Economic Rationality:** High
- No direct cost beyond transaction fee
- Potential to manipulate mining order in attacker's favor
- Can disrupt competitor miners' schedules
- Low risk of attribution if executed carefully

### Recommendation

**Immediate Fix - Add Range Validation in UpdateValueValidationProvider:**

Add validation in `UpdateValueValidationProvider.ValidateHeaderInformation`:
```csharp
// After existing checks, add:
var minersCount = validationContext.PreviousRound.RealTimeMinersInformation.Count;
foreach (var miner in validationContext.ProvidedRound.RealTimeMinersInformation.Values)
{
    if (miner.SupposedOrderOfNextRound != 0 && 
        (miner.SupposedOrderOfNextRound < 1 || miner.SupposedOrderOfNextRound > minersCount))
    {
        return new ValidationResult { Message = "SupposedOrderOfNextRound out of valid range." };
    }
}
```

**Secondary Fix - Add Assertion in ProcessUpdateValue:**

In `AEDPoSContract_ProcessConsensusInformation.cs`, add validation before assignment:
```csharp
var minersCount = currentRound.RealTimeMinersInformation.Count;
Assert(updateValueInput.SupposedOrderOfNextRound > 0 && 
       updateValueInput.SupposedOrderOfNextRound <= minersCount,
       "Invalid SupposedOrderOfNextRound value.");
```

**Defense in Depth - Enhance GetMinedMiners:**

Modify the filter to include range check:
```csharp
public List<MinerInRound> GetMinedMiners()
{
    var minersCount = RealTimeMinersInformation.Count;
    return RealTimeMinersInformation.Values
        .Where(m => m.SupposedOrderOfNextRound > 0 && 
                    m.SupposedOrderOfNextRound <= minersCount)
        .ToList();
}
```

**Test Cases:**
1. Submit `UpdateValue` with `SupposedOrderOfNextRound = 0` → should fail validation
2. Submit `UpdateValue` with `SupposedOrderOfNextRound = -1` → should fail validation
3. Submit `UpdateValue` with `SupposedOrderOfNextRound = minersCount + 1` → should fail validation
4. Submit `UpdateValue` with valid `SupposedOrderOfNextRound = 3` (when `minersCount = 5`) → should succeed
5. Verify `GenerateNextRoundInformation` with corrupted data cannot proceed

### Proof of Concept

**Initial State:**
- Blockchain with 5 active miners
- Current round number: 100
- Attacker is miner with pubkey "AttackerPubkey" at order 3
- Normal `SupposedOrderOfNextRound` calculation would yield 3

**Attack Steps:**

1. **Attacker produces block at their time slot**
   - Expected behavior: Calculate `SupposedOrderOfNextRound = 3` via signature hash

2. **Attacker modifies UpdateValueInput before submission:**
   ```
   UpdateValueInput {
     out_value: [valid hash],
     signature: [valid signature],
     supposed_order_of_next_round: 100,  // MANIPULATED: should be 3
     ...other valid fields
   }
   ```

3. **Transaction validation occurs:**
   - `UpdateValueValidationProvider` checks OutValue, Signature, PreviousInValue → ✓ Pass
   - NO check on `supposed_order_of_next_round` range → ✓ Pass (vulnerability)

4. **ProcessUpdateValue executes:**
   - Line 246: `minerInRound.SupposedOrderOfNextRound = 100` (no validation)
   - Line 247: `minerInRound.FinalOrderOfNextRound = 100` (no validation)
   - Corrupted value stored in round state

5. **NextRound triggered by subsequent miner:**

6. **GenerateNextRoundInformation processes corrupted data:**
   - `GetMinedMiners()` returns attacker because `100 != 0` ✓
   - Attacker assigned order 100 in next round (invalid!)
   - Valid order 3 assigned to non-mining miner instead
   - `BreakContinuousMining`: line 94 seeks order 5, may find wrong miner or null
   - Extra block producer selection: seeks valid order, may not find attacker with order 100

**Expected Result:** Transaction should fail validation with "SupposedOrderOfNextRound out of valid range"

**Actual Result:** Transaction succeeds, next round has miner with order 100 (invalid), consensus ordering corrupted

**Success Condition:** Query next round information shows attacker has order 100 instead of valid order 3, and another miner incorrectly occupies order 3.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-108)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }

        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-22)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

```
