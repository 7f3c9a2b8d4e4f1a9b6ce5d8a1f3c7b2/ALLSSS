### Title
Unprotected Controller Migration Allows Malicious Fee Setting During Transition

### Summary
The controller migration process in ACS1 implementations lacks atomicity protections, allowing the outgoing controller to set arbitrarily high method fees immediately before transferring control. The new controller inherits these malicious fees with no ability to prevent or immediately override them, potentially causing contract DoS and user fund extraction.

### Finding Description

The vulnerability exists in the `EconomicContract_ACS1_TransactionFeeProvider.cs` implementation and affects all ACS1-compliant contracts in the codebase.

**Root Cause:**

The `SetMethodFee` method only checks authorization at execution time without any transition safeguards: [1](#0-0) 

Similarly, `ChangeMethodFeeController` performs an immediate state update with no delay mechanism: [2](#0-1) 

**Why Protections Fail:**

Both methods verify `Context.Sender == State.MethodFeeController.Value.OwnerAddress` at the moment of execution, but there is:
- No timelock or delay period for controller changes
- No freeze on fee modifications during controller transitions
- No two-phase commit mechanism
- No emergency override capability for the new controller

**Exploitation Path:**

Through the Parliament governance system, proposals are executed via the `Release` method which triggers immediate execution: [3](#0-2) 

An attacker controlling the outgoing organization can:
1. Create and approve Proposal A: `SetMethodFee` with extremely high fees (e.g., 1,000,000 tokens per call)
2. Create and approve Proposal B: `ChangeMethodFeeController` to new organization
3. Release Proposal A first (malicious fees activated)
4. Release Proposal B second (controller transferred)
5. New controller now has authority but malicious fees are already in effect

The same pattern exists across all ACS1 implementations: [4](#0-3) [5](#0-4) 

### Impact Explanation

**Direct Operational Impact:**
- Method fees can be set to arbitrarily high values (e.g., millions of tokens), effectively creating a Denial-of-Service condition
- Users cannot afford to call contract methods, halting all economic activity
- Critical operations like token transfers, staking, and governance become economically infeasible

**Economic Harm:**
- Users who manage to pay malicious fees lose substantial funds
- The contract becomes unusable until the new controller goes through another full governance cycle to reset fees
- During the fix period (proposal creation + approval + release), the contract remains in a DoS state

**Affected Parties:**
- All users attempting to interact with the contract
- The new controller organization who inherits a compromised fee structure
- The broader protocol ecosystem relying on these contracts

**Severity Justification:**
This is a **Medium severity** issue because while the impact is severe (contract DoS + fund extraction), it requires the outgoing controller to be malicious or compromised, which is not the default scenario but is realistic in contentious governance transitions or key compromise situations.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Control over the outgoing controller organization (e.g., compromised Parliament keys)
- Ability to create and approve governance proposals
- Timing control to sequence proposal releases

**Attack Complexity:**
- **Low**: The attack is straightforward - create two proposals, approve both, release in sequence
- No complex transaction ordering or race conditions required
- The Parliament proposal system enables atomic execution of both actions

**Feasibility Conditions:**
- Most realistic in scenarios where:
  - The old controller is being forcefully replaced due to compromise
  - Contentious governance disputes where the outgoing party acts maliciously
  - Key management failures leading to unauthorized access
  - Inside attacks by minority stakeholders losing control

**Detection Constraints:**
- The attack occurs through legitimate governance channels
- Both proposals would be visible on-chain, but if approved simultaneously, defenders have limited reaction time
- No technical mechanism prevents the sequence of events

**Probability Assessment:**
While this requires the old controller to act maliciously (not the typical case), the technical ease of execution and realistic scenarios (key compromise, hostile transitions) make this a **medium likelihood** concern that warrants mitigation.

### Recommendation

**Implement Controller Migration Safeguards:**

1. **Add Timelock to Controller Changes:**
```
Implement a delay period (e.g., 7 days) between ChangeMethodFeeController 
approval and execution, with a pending state tracked in 
State.PendingMethodFeeController
```

2. **Freeze Fee Modifications During Transition:**
```
In SetMethodFee, add check:
Assert(State.PendingMethodFeeController.Value == null, 
  "Cannot modify fees during controller migration.");
```

3. **Two-Phase Commit Pattern:**
```
Phase 1: ChangeMethodFeeController sets pending controller
Phase 2: New controller must call AcceptControllerRole to complete transfer
During pending phase, both SetMethodFee and further controller changes are blocked
```

4. **Emergency Fee Reset:**
```
Add ResetFeesToDefault method callable only by new controller within X days 
of controller change to immediately restore safe fee values
```

**Invariant Checks:**
- `State.MethodFeeController.Value != State.PendingMethodFeeController.Value` (no simultaneous states)
- Fee modifications blocked when `PendingMethodFeeController != null`
- Timelock expiration verified before controller transfer completes

**Test Cases:**
- Test that SetMethodFee fails during pending controller migration
- Test that controller change requires timelock expiration
- Test that new controller can emergency-reset fees
- Test that multiple sequential controller changes are properly queued

### Proof of Concept

**Initial State:**
- Current controller: Parliament Default Organization (address 0xAAA)
- Token contract method fees: Transfer = 0.01 ELF (normal)
- New organization created: Association MultiSig (address 0xBBB)

**Attack Sequence:**

**Step 1:** Old controller creates malicious fee proposal
```
CreateProposal(
  ToAddress: EconomicContract,
  MethodName: "SetMethodFee",
  Params: { MethodName: "DonateAll", Fees: [{ Symbol: "ELF", BasicFee: 1000000 }] }
)
→ ProposalId: 0xFEE123
```

**Step 2:** Old controller creates migration proposal
```
CreateProposal(
  ToAddress: EconomicContract,
  MethodName: "ChangeMethodFeeController",
  Params: { OwnerAddress: 0xBBB, ContractAddress: AssociationContract }
)
→ ProposalId: 0xCTRL456
```

**Step 3:** Both proposals get miner approval (controlled by old controller)
```
ApproveProposal(0xFEE123) by 67% of miners → Approved
ApproveProposal(0xCTRL456) by 67% of miners → Approved
```

**Step 4:** Release malicious fees first
```
Release(0xFEE123)
→ SetMethodFee executes
→ DonateAll fee now: 1,000,000 ELF (was ~0.01 ELF)
```

**Step 5:** Release controller migration
```
Release(0xCTRL456)
→ ChangeMethodFeeController executes
→ Controller is now 0xBBB (Association)
```

**Expected vs Actual Result:**

**Expected (with proper safeguards):**
- Controller change should either:
  - Block fee modifications during transition, OR
  - Include timelock allowing new controller to review/prevent, OR
  - Reset fees to safe defaults upon controller change

**Actual Result:**
- Association (0xBBB) now controls fees
- But DonateAll method costs 1,000,000 ELF per call
- Users cannot call the method (DoS condition)
- New controller must create new proposal, get approval, and release to fix
- Contract remains in DoS state for entire governance cycle (days/weeks)

**Success Condition for Attack:**
The attack succeeds if after both releases execute, the new controller has authority but inherits malicious fee values set by the old controller.

### Citations

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L16-17)
```csharp
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;
```

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L22-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L18-21)
```csharp
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-32)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
```
