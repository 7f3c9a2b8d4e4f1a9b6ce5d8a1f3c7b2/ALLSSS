# Audit Report

## Title
Banned Candidates Persist in Election Snapshots Due to Incomplete Removal Logic

## Summary
The `GetPreviousTermSnapshotWithNewestPubkey()` function contains a logic flaw where banned candidates are not removed from election snapshots when their replacement pubkey already exists in the snapshot. This allows banned validators to be re-selected as consensus miners, bypassing the network's security ban mechanism.

## Finding Description

The vulnerability exists in the snapshot processing logic that handles banned candidates. [1](#0-0) 

When processing banned candidates, the code checks if the newest replacement pubkey already exists in the snapshot. If it does, the code executes `continue`, which skips both the addition of the new pubkey AND the removal of the banned candidate. This creates a scenario where:

1. A banned candidate's pubkey remains in the election snapshot with full vote weight
2. The snapshot is consumed by the consensus contract to select alternative miners
3. No filtering for banned pubkeys occurs in the selection logic [2](#0-1) 

The exploitation path leverages legitimate contract operations:
- A candidate (B) quits election via `QuitElection()` [3](#0-2) 
- Another candidate (A) is marked as evil/banned [4](#0-3) 
- A's admin replaces A's pubkey with B's pubkey via `ReplaceCandidatePubkey()` - this succeeds because B is no longer a candidate [5](#0-4) 
- Historical snapshots containing both A and B result in A remaining in the processed snapshot
- The consensus contract calls `GetMinerReplacementInformation()` which can return A as an alternative candidate [6](#0-5) 

This breaks the security invariant that banned validators cannot participate in consensus.

## Impact Explanation

**Critical Consensus Security Violation:**
The vulnerability directly undermines the network's ability to permanently exclude malicious or compromised validators. When a node is marked as evil through `UpdateCandidateInformation()` with `IsEvilNode = true`, the intention is permanent exclusion from consensus participation.

However, this bug allows banned candidates to:
- Retain their historical vote weight in election snapshots
- Be selected as replacement miners by the consensus contract's `GenerateNextRoundInformation()` method
- Resume block production and consensus participation
- Potentially collect mining rewards

**Quantified Impact:**
- A banned candidate with high vote count from previous terms has priority in selection
- The consensus contract transfers the evil miner's time slot and order directly to the "alternative" candidate
- No additional validation checks occur once the alternative is selected

**Affected Parties:**
- Network integrity: compromised nodes regain validator privileges
- Honest validators: must operate alongside previously-banned malicious nodes
- Token holders: network security degraded, staked value at risk

The severity is **High** because it directly compromises the consensus security model, even though it requires specific preconditions to trigger.

## Likelihood Explanation

**Realistic Attack Scenario:**
The vulnerability is exploitable through a sequence of legitimate contract operations:

1. **Setup (Historical):** Multiple candidates participate in elections across several terms, building vote history
2. **Trigger Event:** One candidate quits election (normal operation)
3. **Ban Event:** Another candidate is detected as malicious and banned (security response)
4. **Exploitation:** The banned candidate's admin replaces the banned pubkey with the quit candidate's pubkey
5. **Execution:** During next term transitions, the consensus contract queries historical snapshots for miner replacements

**Feasibility Analysis:**
- All operations are accessible to candidate admins (unprivileged actors)
- No special permissions or timing windows required beyond normal admin control
- The bug triggers automatically during consensus contract's routine snapshot processing
- Detection is difficult because pubkey replacement appears legitimate

**Probability Assessment:**
Medium likelihood because:
- Requires coordination of specific events (quit + ban + replacement)
- All events are normal operations that could occur naturally
- A sophisticated attacker controlling multiple candidate identities could orchestrate this
- Once conditions are met, the vulnerability triggers automatically

The combination of High impact and Medium likelihood makes this a significant security concern.

## Recommendation

Modify the `GetPreviousTermSnapshotWithNewestPubkey()` function to always remove banned candidates from the snapshot, regardless of whether their newest pubkey already exists:

```csharp
foreach (var bannedCandidate in bannedCandidates)
{
    var newestPubkey = GetNewestPubkey(bannedCandidate);
    
    // Always remove the banned candidate first
    if (snapshot.ElectionResult.ContainsKey(bannedCandidate))
        snapshot.ElectionResult.Remove(bannedCandidate);
    
    // Only add newest pubkey if it's valid and not already present
    if (newestPubkey != null && newestPubkey != bannedCandidate &&
        !snapshot.ElectionResult.ContainsKey(newestPubkey))
    {
        snapshot.ElectionResult.Add(newestPubkey, electionResult);
    }
}
```

Alternatively, add an additional filter in `GetMinerReplacementInformation()` to explicitly exclude banned pubkeys:

```csharp
var maybeNextCandidates = latestSnapshot.ElectionResult
    .Where(cs => !State.InitialMiners.Value.Value.Contains(
        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
    .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
    .Where(cs => !State.BannedPubkeyMap[cs.Key])  // Add this filter
    .OrderByDescending(s => s.Value).ToList();
```

The first approach is preferred as it ensures data consistency at the source.

## Proof of Concept

Due to the complexity of the AElf consensus and election system, a complete PoC would require:

1. Setting up a multi-term election scenario with candidates A and B
2. Having B quit election
3. Marking A as evil/banned
4. Replacing A's pubkey with B's pubkey
5. Triggering consensus round generation to invoke `GetMinerReplacementInformation()`
6. Verifying that A's banned pubkey appears in the alternative candidates list

The vulnerability is confirmed through code analysis showing:
- The `continue` statement at line 154 prevents execution of the removal logic at line 157
- No banned pubkey filtering exists in `GetMinerReplacementInformation()` lines 368-375
- The consensus contract directly uses the flawed snapshot data at line 301

**Notes:**
This vulnerability demonstrates a subtle interaction between the election snapshot processing and consensus miner selection mechanisms. The root cause is an incomplete conditional flow where the duplicate key check unintentionally prevents banned candidate removal. The fix requires either moving the removal logic outside the conditional block or adding explicit banned pubkey filtering in the consumer method.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L149-158)
```csharp
        foreach (var bannedCandidate in bannedCandidates)
        {
            var newestPubkey = GetNewestPubkey(bannedCandidate);
            // If newest pubkey not exists or same as old pubkey (which is banned), skip.
            if (newestPubkey == null || newestPubkey == bannedCandidate ||
                snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
            if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L368-375)
```csharp
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-280)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });

        // Update candidate information.
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;

        // Remove candidate public key from the Voting Item options.
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
        var dataCenterList = State.DataCentersRankingList.Value;
        if (dataCenterList.DataCenters.ContainsKey(pubkey))
        {
            dataCenterList.DataCenters[pubkey] = 0;
            UpdateDataCenterAfterMemberVoteAmountChanged(dataCenterList, pubkey, true);
            State.DataCentersRankingList.Value = dataCenterList;
        }

        var managedCandidatePubkey = State.ManagedCandidatePubkeysMap[Context.Sender];
        managedCandidatePubkey.Value.Remove(ByteString.CopyFrom(pubkeyBytes));
        if (managedCandidatePubkey.Value.Any())
            State.ManagedCandidatePubkeysMap[Context.Sender] = managedCandidatePubkey;
        else
            State.ManagedCandidatePubkeysMap.Remove(Context.Sender);

        State.CandidateSponsorMap.Remove(pubkey);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L191-246)
```csharp
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }

        var rankingList = State.DataCentersRankingList.Value;
        //the profit receiver is not exist but candidate in the data center ranking list
        if (rankingList.DataCenters.ContainsKey(input.OldPubkey))
        {
            rankingList.DataCenters.Add(input.NewPubkey, rankingList.DataCenters[input.OldPubkey]);
            rankingList.DataCenters.Remove(input.OldPubkey);
            State.DataCentersRankingList.Value = rankingList;

            // Notify Profit Contract to update backup subsidy profiting item.
            if (State.ProfitContract.Value == null)
                State.ProfitContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            
            var oldProfitReceiver = GetProfitsReceiverOrDefault(input.OldPubkey);
            var profitReceiver = oldProfitReceiver.Value.Any()
                ? oldProfitReceiver
                : null;
            RemoveBeneficiary(input.OldPubkey);
            AddBeneficiary(input.NewPubkey, profitReceiver);
        }

        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }

        //     For CandidateVotes and CandidateInformation, just replace value of origin pubkey.
        var candidateVotes = State.CandidateVotes[input.OldPubkey];
        if (candidateVotes != null)
        {
            candidateVotes.Pubkey = newPubkeyBytes;
            State.CandidateVotes[input.NewPubkey] = candidateVotes;
            State.CandidateVotes.Remove(input.OldPubkey);
        }

        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
        }

        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-342)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```
