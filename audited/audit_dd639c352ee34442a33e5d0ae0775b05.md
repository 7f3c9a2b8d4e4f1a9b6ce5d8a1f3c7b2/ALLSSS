### Title
Governance Bypass via Malicious MethodFeeController Substitution

### Summary
The `ChangeMethodFeeController` method validates organization existence but does not verify that the new controller's `ContractAddress` is a trusted governance contract or that the `OwnerAddress` is a virtual address. An attacker with temporary governance control can pass a single proposal to replace the legitimate governance-controlled MethodFeeController with a malicious contract pointing to their own regular address, permanently bypassing all future proposal requirements for fee changes.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController` method implementation: [1](#0-0) 

The method performs only two checks:
1. **Sender authorization**: Verifies `Context.Sender` equals the current controller's `OwnerAddress` (line 27)
2. **Organization existence**: Calls `CheckOrganizationExist` which invokes `ValidateOrganizationExist` on the provided contract (line 28) [2](#0-1) 

**Root Cause**: The validation trusts any contract that implements `ValidateOrganizationExist` without verifying:
- The `ContractAddress` is a whitelisted governance contract (Parliament/Association/Referendum)
- The `OwnerAddress` is a virtual address (not directly controllable by a private key)
- Future calls will require proposal approval

In legitimate governance contracts, `ValidateOrganizationExist` checks organization state: [3](#0-2) 

However, an attacker can deploy a malicious contract returning `true` for any address.

**Why Legitimate Governance Works**: When Parliament releases an approved proposal, it uses `SendVirtualInlineBySystemContract` with the organization's virtual hash: [4](#0-3) 

The virtual address is deterministically computed and cannot be impersonated by external transactions: [5](#0-4) 

**Why Protection Fails**: There is no validation preventing the controller from pointing to a non-governance contract with a regular address as owner. The system assumes but does not enforce that `OwnerAddress` must be a virtual address only usable through proposal mechanisms.

### Impact Explanation

**Critical Governance Bypass**: Once the MethodFeeController is changed to point to an attacker-controlled address, the attacker gains permanent, unrestricted control over:

1. **Method fee manipulation**: Direct calls to `SetMethodFee` to set arbitrary transaction fees for any contract method [6](#0-5) 

2. **Controller re-assignment**: Ability to transfer control to other addresses or back to legitimate governance without proposals

3. **Economic disruption**: Can set prohibitively high fees to DoS critical operations or zero fees to eliminate revenue

**Affected Parties**:
- All token contract users (fees manipulated arbitrarily)
- Governance participants (authority permanently undermined)
- Protocol treasury (revenue stream compromised)

**Severity Justification**: This permanently breaks the governance invariant that critical configuration changes require multi-party approval. Unlike normal governance control (which is temporary and subject to community oversight), this exploit grants indefinite unilateral control after a single malicious proposal.

### Likelihood Explanation

**Attacker Capabilities Required**:
1. Deploy a malicious contract with `ValidateOrganizationExist` returning `true` (requires passing one contract deployment proposal)
2. Pass one proposal to change MethodFeeController to the malicious setup (requires temporary governance majority)

**Attack Complexity**: Medium
- Must gain temporary control (e.g., coordinate validators, bribe voters for one proposal cycle)
- Two sequential proposals needed (deployment + controller change)
- Both are standard governance operations that don't appear obviously malicious

**Feasibility Conditions**:
- Contract deployment is governance-controlled but follows standard patterns: [7](#0-6) 

- No code review prevents malicious `ValidateOrganizationExist` implementations
- Tests show the authorization pattern but don't validate against malicious controllers: [8](#0-7) 

**Economic Rationality**: High incentive for attackers seeking to:
- Extract value through fee manipulation
- Gain persistent protocol influence
- Create backdoor access after brief governance control

**Detection Difficulty**: The malicious proposal appears as a legitimate governance transition (e.g., "migrating to a new governance structure") and would only be caught by careful code review of the new contract.

### Recommendation

**Immediate Fix**: Add system contract validation in `ChangeMethodFeeController`:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    
    // NEW: Validate ContractAddress is a trusted governance contract
    var systemContracts = Context.GetSystemContractNameToAddressMapping();
    var isValidGovernanceContract = 
        input.ContractAddress == systemContracts[SmartContractConstants.ParliamentContractSystemName] ||
        input.ContractAddress == systemContracts[SmartContractConstants.AssociationContractSystemName] ||
        input.ContractAddress == systemContracts[SmartContractConstants.ReferendumContractSystemName];
    Assert(isValidGovernanceContract, "Controller must be a governance system contract.");
    
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    State.MethodFeeController.Value = input;
    return new Empty();
}
```

**Additional Safeguards**:
1. Add virtual address verification to ensure `OwnerAddress` was created by `ContractAddress`
2. Implement the same fix for all similar controller change methods: `ChangeContractDeploymentController`, `ChangeCodeCheckController`, etc. [9](#0-8) 

3. Add regression test attempting to set a non-system-contract controller

### Proof of Concept

**Step 1**: Deploy malicious "governance" contract:
```csharp
public class MaliciousGovernance : AElf.Sdk.CSharp.CSharpSmartContract<State>
{
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = true }; // Always approve
    }
}
```

**Step 2**: Create proposal through legitimate Parliament governance:
- Target: TokenContract.ChangeMethodFeeController
- Params: `{ ContractAddress: MaliciousGovernance, OwnerAddress: AttackerAddress }`

**Step 3**: Get proposal approved and released by miners (standard governance flow)

**Step 4**: Verify controller changed:
- Call `GetMethodFeeController()` returns attacker's AuthorityInfo

**Step 5**: Execute bypass:
- Attacker directly calls `TokenContract.ChangeMethodFeeController` as `AttackerAddress`
- Attacker directly calls `TokenContract.SetMethodFee` to set arbitrary fees
- Both succeed without any proposal or voting

**Expected Result**: Method calls fail with "Unauthorized behavior"
**Actual Result**: Calls succeed, fees changed without governance approval

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L293-312)
```csharp
    private OrganizationHashAddressPair CalculateOrganizationHashAddressPair(
        CreateOrganizationInput createOrganizationInput)
    {
        var organizationHash = HashHelper.ComputeFrom(createOrganizationInput);
        var organizationAddress =
            Context.ConvertVirtualAddressToContractAddressWithContractHashName(
                CalculateVirtualHash(organizationHash, createOrganizationInput.CreationToken));
        return new OrganizationHashAddressPair
        {
            OrganizationAddress = organizationAddress,
            OrganizationHash = organizationHash
        };
    }

    private Hash CalculateVirtualHash(Hash organizationHash, Hash creationToken)
    {
        return creationToken == null
            ? organizationHash
            : HashHelper.ConcatAndCompute(organizationHash, creationToken);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L122-173)
```csharp
    public override Hash ProposeNewContract(ContractDeploymentInput input)
    {
        // AssertDeploymentProposerAuthority(Context.Sender);
        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        AssertContractNotExists(codeHash);
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();

        if (input.ContractOperation != null)
        {
            ValidateContractOperation(input.ContractOperation, 0, codeHash);
            
            // Remove one time signer if exists. Signer is only needed for validating signature.
            RemoveOneTimeSigner(input.ContractOperation.Deployer);
            
            AssertContractAddressAvailable(input.ContractOperation.Deployer, input.ContractOperation.Salt);
        }

        // Create proposal for deployment
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName =
                    nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.ProposeContractCodeCheck),
                Params = new ContractCodeCheckInput
                {
                    ContractInput = input.ToByteString(),
                    CodeCheckReleaseMethod = nameof(DeploySmartContract),
                    ProposedContractInputHash = proposedContractInputHash,
                    Category = input.Category,
                    IsSystemContract = false
                }.ToByteString(),
                OrganizationAddress = State.ContractDeploymentController.Value.OwnerAddress,
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
            },
            OriginProposer = Context.Sender
        };
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput.ToByteString());

        Context.Fire(new ContractProposed
        {
            ProposedContractInputHash = proposedContractInputHash
        });

        return proposedContractInputHash;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L366-382)
```csharp
    public override Empty ChangeContractDeploymentController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.ContractDeploymentController.Value = input;
        return new Empty();
    }

    public override Empty ChangeCodeCheckController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.CodeCheckController.Value.OwnerAddress);
        Assert(CheckOrganizationExist(input),
            "Invalid authority input.");
        State.CodeCheckController.Value = input;
        return new Empty();
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/ACS1_ImplementTest.cs (L56-78)
```csharp
    public async Task ChangeMethodFeeController_WithoutAuth_Test()
    {
        var createOrganizationResult =
            await ParliamentContractStub.CreateOrganization.SendAsync(
                new CreateOrganizationInput
                {
                    ProposalReleaseThreshold = new ProposalReleaseThreshold
                    {
                        MinimalApprovalThreshold = 1000,
                        MinimalVoteThreshold = 1000
                    }
                });
        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.TransactionResult.ReturnValue);
        var result = await TokenContractStub.ChangeMethodFeeController.SendWithExceptionAsync(
            new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = ParliamentContractAddress
            });

        result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        result.TransactionResult.Error.Contains("Unauthorized behavior.").ShouldBeTrue();
    }
```
