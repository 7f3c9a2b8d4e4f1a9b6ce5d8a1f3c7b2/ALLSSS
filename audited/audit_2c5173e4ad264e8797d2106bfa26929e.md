### Title
NextRoundMiningOrderValidationProvider Fails to Detect Duplicate Mining Orders Due to Multiple Logic Errors

### Summary
The `NextRoundMiningOrderValidationProvider` contains critical logic errors that completely undermine round transition validation. The validator checks the wrong data (`FinalOrderOfNextRound` in the next round instead of `Order` values), and uses `Distinct()` on `MinerInRound` objects rather than on order values themselves. This allows a malicious block producer to create next rounds with duplicate mining orders, breaking consensus integrity and enabling targeted denial-of-service against specific miners.

### Finding Description

The validation occurs in `ValidateHeaderInformation()` where it attempts to verify mining order uniqueness: [1](#0-0) 

**Root Cause #1 - Wrong Field Checked**: The validation checks `FinalOrderOfNextRound` in the provided round. For `NextRound` behaviour, `providedRound` represents round N+1. The `FinalOrderOfNextRound` field in round N+1 would indicate mining order for round N+2, which hasn't been calculated yet (defaults to 0). Meanwhile, the actual mining order for round N+1 is stored in the `Order` field, which is never validated.

**Root Cause #2 - Object-Level Distinct Instead of Value-Level**: Line 16 calls `Distinct()` on `MinerInRound` objects. Since `MinerInRound` is a protobuf message with multiple fields (pubkey, signature, OutValue, etc.): [2](#0-1) 

Two different miners with the same `FinalOrderOfNextRound` value are still considered distinct objects because they differ in other fields. The validation should call `Distinct()` on the order values themselves, not on the miner objects.

**Why Protection Fails**: When a malicious block producer generates a next round via `GetConsensusExtraDataForNextRound`, they can craft round data where multiple miners have the same `Order` value: [3](#0-2) 

The validation registers in the NextRound case: [4](#0-3) 

However, since the validation checks `FinalOrderOfNextRound` (all zeros in a newly generated round) against `OutValue != null` (also zero as miners haven't mined yet in the new round), the comparison becomes `0 == 0` and always passes, regardless of whether `Order` values have collisions.

### Impact Explanation

**Consensus Integrity Violation**: A malicious block producer can create a next round where two or more miners share the same `Order` value (e.g., both assigned Order = 5). This directly violates the fundamental consensus invariant that each miner must have a unique time slot.

**Concrete Harm**:
1. **Scheduling Conflicts**: Multiple miners scheduled for the same time slot cannot both produce blocks, causing one to miss their slot
2. **Targeted Miner Exclusion**: An attacker can strategically assign duplicate orders to exclude specific miners from participation
3. **Round Generation Corruption**: Subsequent round generation uses these corrupted Order values: [5](#0-4) 

Leading to cascading failures as occupied orders are incorrectly tracked: [6](#0-5) 

4. **Consensus Stall Risk**: If critical miners (e.g., extra block producer) are assigned duplicate orders, consensus could stall entirely

**Who Is Affected**: All network participants. Miners lose their rightful mining slots, validators cannot maintain proper block production schedule, and the network's consensus integrity is compromised.

**Severity Justification**: CRITICAL - This breaks a core consensus invariant (unique mining orders) and is trivially exploitable by any miner producing a NextRound block.

### Likelihood Explanation

**Attacker Capabilities**: Any miner selected to produce the NextRound block can exploit this. No special permissions beyond being a current miner are required.

**Attack Complexity**: LOW
1. Wait for your turn to produce the NextRound block
2. Instead of calling the standard `GenerateNextRoundInformation`, manually craft a `Round` object with duplicate `Order` values
3. Submit this as consensus header data via `NextRound` method: [7](#0-6) 

4. The validation passes due to the bugs described above
5. The corrupted round is stored in state

**Feasibility Conditions**: 
- Attacker must be an active miner (realistic - miners rotate)
- Attacker's turn to produce NextRound block (occurs regularly at round boundaries)
- No additional preconditions required

**Detection Constraints**: The attack would be visible in block data (duplicate orders in round information), but there's no on-chain detection mechanism. Off-chain monitoring could detect it, but by then consensus is already corrupted.

**Economic Rationality**: Attack cost is minimal (just producing one block). Potential gains include denying competitors' mining rewards or disrupting consensus for strategic advantage.

**Probability Assessment**: HIGH - Any malicious miner will eventually get the opportunity, the attack is straightforward, and the validation provides zero protection.

### Recommendation

**Immediate Fix**: Replace the validation logic to check `Order` uniqueness in the provided round:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var providedRound = validationContext.ProvidedRound;
    
    // Get all mining orders from the provided next round
    var orders = providedRound.RealTimeMinersInformation.Values
        .Select(m => m.Order)
        .ToList();
    
    // Check that all orders are unique
    var distinctOrderCount = orders.Distinct().Count();
    if (distinctOrderCount != orders.Count)
    {
        validationResult.Message = "Duplicate mining orders detected in next round.";
        return validationResult;
    }
    
    // Check that orders form a valid sequence (1 to N)
    var minersCount = providedRound.RealTimeMinersInformation.Count;
    if (orders.Min() != 1 || orders.Max() != minersCount)
    {
        validationResult.Message = "Mining orders do not form valid sequence.";
        return validationResult;
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

**Additional Invariant Checks**:
1. Validate that Order values are in range [1, minersCount]
2. Validate that all Order positions are filled (no gaps)
3. Cross-check with expected orders derived from current round's `FinalOrderOfNextRound`

**Test Cases to Add**:
1. Test NextRound validation rejects round with duplicate Order values
2. Test NextRound validation rejects round with out-of-range Order values
3. Test NextRound validation rejects round with gaps in Order sequence
4. Test legitimate NextRound passes validation with unique sequential orders

### Proof of Concept

**Initial State**:
- Current round N with 5 active miners
- Each miner has correctly calculated `FinalOrderOfNextRound` (1, 2, 3, 4, 5)
- Attacker (MinerA) is designated to produce the NextRound block

**Attack Steps**:

1. **Craft Malicious Round**: Instead of generating round N+1 via `GenerateNextRoundInformation`, MinerA manually creates a Round object where:
   - MinerB has `Order = 3`  
   - MinerC has `Order = 3` (collision!)
   - Other miners have unique orders (1, 2, 4, 5)
   - All `FinalOrderOfNextRound` = 0 (default)
   - All `OutValue` = null (miners haven't mined yet)

2. **Submit NextRound**: MinerA calls `NextRound` method with this crafted round data

3. **Validation Executes**:
   ```
   distinctCount = providedRound.RealTimeMinersInformation.Values
       .Where(m => m.FinalOrderOfNextRound > 0)  // All 0, so empty set
       .Distinct().Count();  // Count = 0
   
   minersWithOutValue = providedRound.RealTimeMinersInformation.Values
       .Count(m => m.OutValue != null);  // All null, so Count = 0
   
   if (0 != 0) // FALSE - validation passes!
   ```

4. **Round Accepted**: The validation passes, `ProcessNextRound` stores the corrupted round in state

**Expected Result**: Validation should reject the round due to duplicate Order values (both MinerB and MinerC have Order = 3)

**Actual Result**: Validation passes because it checks `FinalOrderOfNextRound` (all 0) instead of `Order`, and the comparison `0 == 0` succeeds

**Success Condition**: Round N+1 is stored with MinerB.Order = 3 and MinerC.Order = 3, confirmed by querying round state. Both miners are now scheduled for the same time slot, breaking consensus.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L14-21)
```csharp
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```
