# Audit Report

## Title
Inconsistent Profit Detail Matching Logic Enables Vote Extension Manipulation

## Summary
The Election and Profit contracts use different fallback strategies when matching profit details by shares for legacy votes, causing `ChangeVotingOption` to extend the wrong vote's profit period when multiple votes have identical weights.

## Finding Description

The vulnerability stems from inconsistent LINQ selection logic between two contracts when handling old-system votes (where `ProfitDetail.Id` is null):

**Election Contract Validation:** [1](#0-0) 

The `GetProfitDetailByElectionVotingRecord` method uses `LastOrDefault` to find profit details when matching by shares (line 181), which returns the **last** element in the collection.

**Profit Contract Modification:** [2](#0-1) 

The `FixProfitDetail` method uses `OrderBy(d => d.StartPeriod).FirstOrDefault` to find profit details when matching by shares (lines 287-288), which returns the element with the **earliest StartPeriod**.

**Root Cause:**
When a user has multiple old votes with identical weights (same amount and lock time), the validation check and the actual modification target different profit details:
- Validation: selects the last detail in collection order
- Modification: selects the detail with earliest StartPeriod

**Vote Weight Determinism:** [3](#0-2) 

The weight calculation is purely deterministic based on `votesAmount` and `lockTime`, making identical weights inevitable for votes with identical parameters.

**Execution Path:** [4](#0-3) 

When `ChangeVotingOption` is called with `IsResetVotingTime=true` (line 33), it invokes `ExtendVoterWelfareProfits` (line 37). [5](#0-4) 

`ExtendVoterWelfareProfits` retrieves the profit detail using `GetProfitDetailByElectionVotingRecord` (line 140) for validation, then calls `State.ProfitContract.FixProfitDetail.Send` (line 144) which re-searches using different logic.

**Realistic Scenario Evidence:** [6](#0-5) 

The test suite demonstrates creating three votes with identical parameters (lines 22-26: same voter, same candidate, same lock time of 20 days, same amount of 10 tokens), confirming this scenario is expected behavior.

## Impact Explanation

**HIGH Severity** due to:

1. **Direct Financial Manipulation**: Users can extend Vote A's profit period by calling `ChangeVotingOption` on Vote B when both have identical weights. Vote A receives extended profit distributions beyond its intended period, while Vote B's period remains unmodified.

2. **Protocol Integrity Breach**: The profit distribution scheme's correctness guarantee is violated - votes receive incorrect profit periods, causing misallocation of welfare rewards.

3. **Diluted Distributions**: Other beneficiaries in the welfare scheme receive reduced distributions due to the incorrect share periods of manipulated votes.

4. **Silent State Corruption**: No error is thrown; the wrong profit detail is modified without any indication, making detection extremely difficult.

5. **No Authorization Required**: Exploitation uses the standard public `ChangeVotingOption` method with legitimate parameters.

## Likelihood Explanation

**MEDIUM-HIGH Likelihood** because:

1. **No Special Permissions**: Any user with old-system votes can exploit this through the public `ChangeVotingOption` method.

2. **Realistic Preconditions**: 
   - Old-system votes (Id=null) exist in production systems that were deployed before profit detail IDs were introduced
   - Users commonly vote with standardized amounts (e.g., 1000 tokens for 365 days), naturally creating duplicate weights
   - The test suite itself demonstrates this scenario as normal behavior

3. **Low Complexity**: The exploit requires only calling `ChangeVotingOption` with `IsResetVotingTime=true` on a vote that has a sibling vote with identical weight.

4. **Detection Difficulty**: Both contracts execute successfully with no errors, and the state change appears as a legitimate vote extension in logs.

## Recommendation

Align the fallback logic between both contracts to use consistent selection criteria. The recommended fix is to make both contracts use the same sorting and selection method:

**Option 1 (Recommended)**: Use `OrderBy(StartPeriod).FirstOrDefault` in both places to always select the oldest profit detail by StartPeriod.

**Option 2**: Pass an additional unique identifier (e.g., the VoteId itself) that can be stored in a custom field for old votes during a migration, eliminating reliance on Shares matching.

**Option 3**: Add validation in `FixProfitDetail` to ensure the found detail matches the one that would be found by `GetProfitDetailByElectionVotingRecord`, throwing an error if they differ.

## Proof of Concept

```csharp
[Fact]
public async Task InconsistentProfitDetailMatching_WrongVoteExtended()
{
    // Setup: Announce candidate
    await AnnounceElectionAsync(CoreDataCenterKeyPairs[0]);
    
    // Create 2 votes with IDENTICAL parameters (same amount, same lock time)
    // This creates 2 profit details with identical Shares but different StartPeriods
    var voteId1 = await VoteToCandidateAsync(VoterKeyPairs[0], 
        CoreDataCenterKeyPairs[0].PublicKey.ToHex(), 20 * 86400, 10);
    
    await ProduceBlocks(BootMinerKeyPair, 5);
    
    var voteId2 = await VoteToCandidateAsync(VoterKeyPairs[0], 
        CoreDataCenterKeyPairs[0].PublicKey.ToHex(), 20 * 86400, 10);
    
    await NextTerm(BootMinerKeyPair);
    
    // Get profit details before change
    var profitDetailsBefore = await GetCitizenWelfareProfitDetails(
        Address.FromPublicKey(VoterKeyPairs[0].PublicKey));
    var detail1Before = profitDetailsBefore.Details[0];
    var detail2Before = profitDetailsBefore.Details[1];
    
    // Change voting option for SECOND vote with IsResetVotingTime=true
    await ChangeVotingOption(VoterKeyPairs[0], 
        CoreDataCenterKeyPairs[0].PublicKey.ToHex(), voteId2, true);
    
    // Get profit details after change
    var profitDetailsAfter = await GetCitizenWelfareProfitDetails(
        Address.FromPublicKey(VoterKeyPairs[0].PublicKey));
    var detail1After = profitDetailsAfter.Details[0];
    var detail2After = profitDetailsAfter.Details[1];
    
    // BUG: detail1 (FIRST vote) EndPeriod was extended instead of detail2
    detail1After.EndPeriod.ShouldBeGreaterThan(detail1Before.EndPeriod); 
    detail2After.EndPeriod.ShouldBe(detail2Before.EndPeriod); // Second vote unchanged!
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L23-44)
```csharp
    public override Empty ChangeVotingOption(ChangeVotingOptionInput input)
    {
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input.VoteId);
        Assert(Context.Sender == votingRecord.Voter, "No permission to change current vote's option.");
        var actualLockedSeconds = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockingSeconds = State.LockTimeMap[input.VoteId];
        Assert(actualLockedSeconds < claimedLockingSeconds, "This vote already expired.");

        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
        }
        else
        {
            // false, no change for EndPeroid
            State.LockTimeMap[input.VoteId] = State.LockTimeMap[input.VoteId].Sub(actualLockedSeconds);
        }

```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L126-160)
```csharp
    private void ExtendVoterWelfareProfits(Hash voteId)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);

        // Extend endPeriod from now no, so the lockTime will *NOT* be changed.
        var lockTime = State.LockTimeMap[voteId];
        var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
        if (lockPeriod == 0)
        {
            return;
        }

        var endPeriod = lockPeriod.Add(treasury.CurrentPeriod);
        var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
        if (extendingDetail != null)
        {
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
        }
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L168-185)
```csharp
    private ProfitDetail GetProfitDetailByElectionVotingRecord(ElectionVotingRecord electionVotingRecord)
    {
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
        // However, in the old world, profitDetail.Id is null, so use Shares.
        if (profitDetail == null)
        {
            profitDetail = profitDetails.Details.LastOrDefault(d => d.Shares == electionVotingRecord.Weight);
        }

        return profitDetail;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-306)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }

        // Try to get profitDetails by Id
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
        ProfitDetail fixingDetail = null;
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }

        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Election.Tests/Full/ChangeVotingOptionTests.cs (L12-89)
```csharp
    [Fact]
    public async Task ChangeVotingOptionTest()
    {
        foreach (var keyPair in CoreDataCenterKeyPairs)
        {
            await AnnounceElectionAsync(keyPair);
        }

        // Term 1
        // Voter 1 votes 3 times.
        for (var i = 0; i < 3; i++)
        {
            await VoteToCandidateAsync(VoterKeyPairs[0], CoreDataCenterKeyPairs[0].PublicKey.ToHex(), 20 * 86400,
                10);
        }

        await ProduceBlocks(BootMinerKeyPair, 10);
        await NextTerm(BootMinerKeyPair);

        // Term 2
        // Change voting option for first vote.
        {
            var electorVotes = await ElectionContractStub.GetElectorVote.CallAsync(new StringValue
            {
                Value = VoterKeyPairs[0].PublicKey.ToHex()
            });
            await ChangeVotingOption(VoterKeyPairs[0], CoreDataCenterKeyPairs[0].PublicKey.ToHex(),
                electorVotes.ActiveVotingRecordIds.First(), true);
        }
        await ProduceBlocks(BootMinerKeyPair, 10);
        await NextTerm(BootMinerKeyPair);

        await ProduceBlocks(BootMinerKeyPair, 10);
        await NextTerm(BootMinerKeyPair);

        // Term 4
        // Change voting option for second vote.
        {
            var electorVotes = await ElectionContractStub.GetElectorVote.CallAsync(new StringValue
            {
                Value = VoterKeyPairs[0].PublicKey.ToHex()
            });
            await ChangeVotingOption(VoterKeyPairs[0], CoreDataCenterKeyPairs[0].PublicKey.ToHex(),
                electorVotes.ActiveVotingRecordIds.Skip(1).First(), true);
        }
        await ProduceBlocks(BootMinerKeyPair, 10);
        await NextTerm(BootMinerKeyPair);

        await ProduceBlocks(BootMinerKeyPair, 10);
        await NextTerm(BootMinerKeyPair);

        // Term 6
        // Change voting option for last vote.
        {
            var electorVotes = await ElectionContractStub.GetElectorVote.CallAsync(new StringValue
            {
                Value = VoterKeyPairs[0].PublicKey.ToHex()
            });
            await ChangeVotingOption(VoterKeyPairs[0], CoreDataCenterKeyPairs[0].PublicKey.ToHex(),
                electorVotes.ActiveVotingRecordIds.Last(), true);
        }
        await ProduceBlocks(BootMinerKeyPair, 10);
        await NextTerm(BootMinerKeyPair);

        {
            var profitDetails =
                await GetCitizenWelfareProfitDetails(Address.FromPublicKey(VoterKeyPairs[0].PublicKey));
            profitDetails.Details.Count.ShouldBe(3);
        }

        // Term 7
        for (var i = 0; i < 5; i++)
        {
            await ClaimProfitsAsync(VoterKeyPairs[0]);
            await ProduceBlocks(BootMinerKeyPair, 10);
            await NextTerm(BootMinerKeyPair);
        }
    }
```
