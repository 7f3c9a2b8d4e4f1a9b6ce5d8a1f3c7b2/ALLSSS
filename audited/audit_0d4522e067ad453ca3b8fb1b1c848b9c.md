### Title
Decimal Overflow in BancorHelper.Pow() Causes DoS When Extreme Connector Weight Ratios Are Configured

### Summary
The `Pow()` function in `BancorHelper.cs` can overflow when computing decimal exponentiation with large base values, causing `OverflowException` and transaction revert. This occurs when connector weight ratios exceed approximately 40:1, which can result from governance configuring extreme but technically valid weight values (e.g., 0.9/0.01 = 90). Buy and sell operations become permanently unusable for affected connector pairs until weights are reconfigured.

### Finding Description

The vulnerability exists in the binary exponentiation algorithm at [1](#0-0) . The `Pow()` function repeatedly squares the accumulator `A` at line 115, which can exceed the decimal maximum value of ~7.9 × 10^28.

The execution path is:
1. `Buy()` or `Sell()` calls [2](#0-1)  or [3](#0-2) 
2. These compute `Exp(y * Ln(x))` where `y = connectorWeight1 / connectorWeight2`
3. `Exp()` at [4](#0-3)  calls `Pow(y, iteration)` for iterations 1-20
4. When weight ratio causes `y` to exceed ~28, computing `y^20` overflows

**Root Cause**: Connector weights are validated only to be between 0 and 1 at [5](#0-4) , with no upper bound on weight ratios. The validation at [6](#0-5)  permits values like 0.99 and 0.01, yielding a ratio of 99.

**Calculation**: For weight ratio of 99 and `Ln(x) ≈ 0.5`, we get `y ≈ 49.5`. Computing `49.5^17` in the Exp series yields ~3.4 × 10^29, exceeding decimal's maximum and throwing `OverflowException`.

### Impact Explanation

**Harm**: Complete denial of service for buy/sell operations on affected connector pairs. All user transactions attempting to trade those tokens will revert with `OverflowException`.

**Affected Parties**: 
- Users attempting to buy or sell tokens through affected connector pairs
- Protocols depending on token conversion functionality
- Liquidity providers unable to adjust positions

**Severity**: Medium-High. While no funds are at risk of theft, the contract becomes permanently unusable for affected pairs until governance intervenes to reconfigure weights via [7](#0-6) . This represents operational failure of a critical DeFi component.

The default configuration in [8](#0-7)  uses safe ratios (0.005/0.005 = 1), but governance can update weights post-deployment.

### Likelihood Explanation

**Preconditions**: Requires ConnectorController (governance) to configure extreme weight ratios through `UpdateConnector()` or `AddPairConnector()`. 

**Feasibility**: 
- Governance might set weights like 0.95/0.02 (ratio 47.5) without realizing overflow implications
- No validation warnings exist to prevent this configuration
- The mathematical consequences of extreme ratios are non-obvious
- Governance acts through proposals, so multiple parties could miss the issue

**Complexity**: Low - once extreme weights are configured, any user calling `Buy()` or `Sell()` triggers the overflow with normal transaction parameters.

**Probability**: Medium - requires governance misconfiguration rather than malicious end-user input, but the lack of validation makes honest mistakes likely when adjusting tokenomics parameters.

### Recommendation

**Code-level mitigation**:
1. Add explicit weight ratio validation in [5](#0-4) :

```csharp
private void AssertValidConnectorWeight(Connector connector)
{
    var weight = AssertedDecimal(connector.Weight);
    Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
    
    // Add ratio validation
    if (!string.IsNullOrEmpty(connector.RelatedSymbol))
    {
        var relatedConnector = State.Connectors[connector.RelatedSymbol];
        if (relatedConnector != null)
        {
            var relatedWeight = decimal.Parse(relatedConnector.Weight);
            var ratio = Math.Max(weight / relatedWeight, relatedWeight / weight);
            Assert(ratio <= 20m, "Connector weight ratio cannot exceed 20 to prevent overflow.");
        }
    }
    
    connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
}
```

2. Add try-catch in `Pow()` to provide better error messages instead of raw overflow exception.

**Test cases**:
- Test `Pow()` with values that would overflow (e.g., `Pow(50, 20)`)
- Test `Buy()`/`Sell()` with extreme but valid weight ratios
- Test weight update rejection when ratio exceeds safe bounds

### Proof of Concept

**Initial State**:
- TokenConverter initialized with connector pair
- Connector A: weight = 0.9, balance = 1,000,000
- Connector B: weight = 0.01, balance = 1,000,000
- Weight ratio: 0.9 / 0.01 = 90

**Transaction Steps**:
1. User calls `Buy(amount = 100,000)` to purchase tokens from Connector A
2. `GetAmountToPayFromReturn()` calculates: `y = (0.01 / 0.9) * Ln(x)` where `x ≈ 1.1`
3. With `Ln(1.1) ≈ 0.095`, inverse formula gives `y = (0.9 / 0.01) * Ln(y_temp) ≈ 90 * 0.5 = 45` in reverse calculation path
4. `Exp(45)` calls `Pow(45, 17)` → computes `45^17 ≈ 9.5 × 10^28` 
5. Next iteration `Pow(45, 18)` → `A *= A` at line 115 attempts `(9.5 × 10^28)^2`
6. Result exceeds `decimal.MaxValue`, throwing `System.OverflowException`
7. Transaction reverts

**Expected**: Transaction succeeds with calculated token amounts
**Actual**: Transaction fails with overflow exception, DoS condition established

**Notes**

While the default Economic contract configuration uses safe weight values [9](#0-8) , the lack of ratio validation in the update functions means governance can inadvertently create DoS conditions through parameter adjustments. The vulnerability lies in missing input validation rather than malicious user exploitation, representing a systemic risk in protocol governance operations.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L67-94)
```csharp
    public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = amountToReceive;
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }

        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L104-120)
```csharp
    public static decimal Pow(decimal x, uint y)
    {
        if (y == 1)
            return x;

        var A = 1m;
        var e = new BitArray(y.ToBytes(false));
        var t = e.Count;

        for (var i = t - 1; i >= 0; --i)
        {
            A *= A;
            if (e[i]) A *= x;
        }

        return A;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L354-357)
```csharp
    private static bool IsBetweenZeroAndOne(decimal number)
    {
        return number > decimal.Zero && number < decimal.One;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L211-260)
```csharp
    private void InitializeTokenConverterContract()
    {
        State.TokenConverterContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName);
        var connectors = new List<Connector>
        {
            new()
            {
                Symbol = Context.Variables.NativeSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.5",
                VirtualBalance = EconomicContractConstants.NativeTokenConnectorInitialVirtualBalance
            }
        };
        foreach (var resourceTokenSymbol in Context.Variables
                     .GetStringArray(EconomicContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(EconomicContractConstants.PayRentalSymbolListName)))
        {
            var resourceTokenConnector = new Connector
            {
                Symbol = resourceTokenSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.ResourceTokenInitialVirtualBalance,
                RelatedSymbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsDepositAccount = false
            };
            var nativeTokenConnector = new Connector
            {
                Symbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
                RelatedSymbol = resourceTokenSymbol,
                IsDepositAccount = true
            };
            connectors.Add(resourceTokenConnector);
            connectors.Add(nativeTokenConnector);
        }

        State.TokenConverterContract.Initialize.Send(new InitializeInput
        {
            FeeRate = EconomicContractConstants.TokenConverterFeeRate,
            Connectors = { connectors },
            BaseTokenSymbol = Context.Variables.NativeSymbol
        });
    }
```
