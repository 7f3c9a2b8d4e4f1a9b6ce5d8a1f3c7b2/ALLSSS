### Title
Insufficient Loop Iterations in Conflict Resolution Causes Duplicate Mining Orders and Consensus Failure

### Summary
The conflict resolution algorithm in `ApplyNormalConsensusData()` contains an insufficient loop bound that fails to resolve all conflicts when multiple miners have the same `FinalOrderOfNextRound`. The comment at line 29 dismisses "multiple conflicts" as "unlikely" without justification, but such conflicts can occur through race conditions during concurrent block preparation. When the algorithm fails to reassign conflicting miners, duplicate `FinalOrderOfNextRound` values persist, leading to multiple miners claiming the same order in the next round and causing consensus breakdown. [1](#0-0) 

### Finding Description

**Root Cause**: The conflict resolution loop iterates from `supposedOrderOfNextRound + 1` to `minersCount * 2`, checking only `minersCount - 1` positions (after wrapping via modulus). When there are multiple conflicts and most positions are occupied, later conflicts cannot find available positions and remain unresolved. [2](#0-1) 

**How Multiple Conflicts Occur**: During block preparation, multiple miners read the same round state and calculate their consensus data via `GetConsensusExtraDataToPublishOutValue()`. If their signatures produce the same `supposedOrderOfNextRound`, they each prepare `UpdateValueInput` with empty `TuneOrderInformation` (no conflicts detected at preparation time). When these transactions execute sequentially, each sets `FinalOrderOfNextRound` to the same value without conflict resolution. [3](#0-2) [4](#0-3) 

**Why Protection Fails**: The validation in `NextRoundMiningOrderValidationProvider` is incorrectly implemented. It calls `.Distinct()` on `MinerInRound` objects rather than on `FinalOrderOfNextRound` values, so it counts distinct miner objects instead of checking for duplicate order values. This validation only runs during `NextRound` behavior, not `UpdateValue`, allowing duplicates to accumulate undetected. [5](#0-4) 

**Consensus Breakdown**: When `GenerateNextRoundInformation()` processes duplicate `FinalOrderOfNextRound` values, multiple miners receive the same `Order` in the next round. The `BreakContinuousMining()` function expects unique orders and calls `.First(i => i.Order == 2)`, which throws an exception if no miner has order 2 (because two miners claimed order 1). Additionally, miners with the same order receive identical `ExpectedMiningTime`, creating ambiguous mining schedules. [6](#0-5) [7](#0-6) 

### Impact Explanation

**Consensus Integrity Violation**: Duplicate mining orders break the fundamental consensus invariant that each miner must have a unique position in the round. This creates:
- **Non-deterministic ordering**: `OrderBy(m => m.FinalOrderOfNextRound)` produces unpredictable results when duplicates exist
- **Runtime exceptions**: Attempts to find specific orders (e.g., order 2) fail when that position is unclaimed
- **Schedule ambiguity**: Multiple miners claim the same time slot, creating conflicts over block production rights
- **Chain halt risk**: The next round cannot be properly generated, potentially halting block production

**Severity**: High/Critical - This directly violates the "Consensus & Cross-Chain" critical invariant requiring "correct round transitions and time-slot validation, miner schedule integrity". A consensus failure can halt the entire blockchain or fork it into incompatible states. All network participants are affected as the chain cannot progress reliably.

### Likelihood Explanation

**Attacker Capabilities**: No special privileges required. Any miner producing blocks during normal consensus operations can trigger this vulnerability through timing alone.

**Attack Complexity**: LOW - This occurs naturally through race conditions:
1. Two miners prepare blocks concurrently (both reading the same round state)
2. Their signatures happen to produce the same `supposedOrderOfNextRound` (probability â‰ˆ 1/minersCount per pair)
3. Both transactions execute sequentially, creating duplicates

**Feasibility**: HIGH - With even moderate network latency, multiple miners routinely prepare blocks before seeing others' updates. The probability increases with:
- Larger miner sets (more concurrent block producers)
- Higher block production rates (less time between preparations)
- Network delays between preparation and execution

**Detection**: Duplicates accumulate silently until round transition, when consensus fails catastrophically rather than gracefully degrading.

**Probability Assessment**: In a 5-miner network with uniform signature distribution, the expected collision rate is ~1 per round. With concurrent preparation (realistic), multiple collisions can occur, triggering the insufficient loop bound issue.

### Recommendation

**Fix 1 - Increase Loop Iterations**: Change the loop bound to ensure all positions are checked multiple times:
```csharp
for (var i = supposedOrderOfNextRound + 1; i < supposedOrderOfNextRound + minersCount * 3; i++)
```
This guarantees checking all positions at least twice, sufficient to resolve even `minersCount - 1` conflicts.

**Fix 2 - Proper Validation**: Correct the `NextRoundMiningOrderValidationProvider` to check for duplicate values:
```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct().Count();
```

**Fix 3 - Add UpdateValue Validation**: Implement duplicate checking during `ProcessUpdateValue()` to detect and reject transactions that would create duplicates:
```csharp
// After line 260 in ProcessUpdateValue
var finalOrders = currentRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
Assert(finalOrders.Distinct().Count() == finalOrders.Count, 
    "Duplicate FinalOrderOfNextRound detected");
```

**Test Cases**:
1. Simulate 3+ miners with identical signatures targeting the same order
2. Verify all conflicts are resolved with unique final orders
3. Test with fully occupied positions (all orders 1-N taken)
4. Validate rejection of transactions creating duplicates

### Proof of Concept

**Initial State** (3 miners):
- Miner A: `FinalOrderOfNextRound = 2, SupposedOrderOfNextRound = 2`
- Miner B: `FinalOrderOfNextRound = 3, SupposedOrderOfNextRound = 3`
- Miner C: `FinalOrderOfNextRound = 3, SupposedOrderOfNextRound = 3` (duplicate with B via race condition)

**Attack Steps**:
1. Miner A produces block with signature resulting in `supposedOrderOfNextRound = 3`
2. `ApplyNormalConsensusData()` detects conflicts: `[B, C]` (both have `FinalOrderOfNextRound == 3`)
3. Loop processes B: tries positions [1, 2], finds position 1 available, assigns `B.FinalOrderOfNextRound = 1`
4. Loop processes C: tries positions [1, 2], both occupied (1 by B, 2 by A), loop exits without reassignment
5. Transaction sets `A.FinalOrderOfNextRound = 3`

**Expected Result**: All three miners have unique `FinalOrderOfNextRound` values

**Actual Result**: 
- Miner A: `FinalOrderOfNextRound = 3`
- Miner B: `FinalOrderOfNextRound = 1`
- Miner C: `FinalOrderOfNextRound = 3` (DUPLICATE with A)

**Success Condition**: Query `RealTimeMinersInformation.Values.Select(m => m.FinalOrderOfNextRound)` shows `[3, 1, 3]` containing duplicates. Next round generation fails with exception or produces invalid mining schedule.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L28-40)
```csharp
        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-89)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
```
