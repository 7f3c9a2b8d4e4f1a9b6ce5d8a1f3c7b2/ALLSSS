### Title
Incorrect Threshold Check in Secret Sharing Reconstruction Defeats Byzantine Fault Tolerance

### Summary
The secret sharing reconstruction logic requires 100% of miners to provide decrypted pieces before attempting reconstruction, instead of the intended 2/3 threshold defined by Shamir's Secret Sharing algorithm. This allows a single malicious miner to prevent forced revelation of their InValue by providing incomplete encrypted pieces, breaking the commit-reveal scheme's security guarantees and enabling manipulation of consensus randomness and mining order.

### Finding Description

The vulnerability exists in two critical validation points where secret reconstruction is performed: [1](#0-0) [2](#0-1) 

Both checks validate `DecryptedPieces.Count < minersCount` (100% of miners) before attempting secret reconstruction, despite the system calculating and using a threshold of 2/3: [3](#0-2) [4](#0-3) 

The secret reconstruction itself correctly uses `minimumCount` as the threshold parameter: [5](#0-4) [6](#0-5) 

**Root Cause:** The validation incorrectly requires ALL miners' participation instead of the mathematically sufficient threshold defined by Shamir's Secret Sharing.

**Why Protections Fail:**

1. No validation exists for `EncryptedPieces` completeness in the UpdateValue validation provider: [7](#0-6) 

2. PreviousInValue is explicitly allowed to be `Hash.Empty`, bypassing forced revelation: [8](#0-7) 

3. When EncryptedPieces are processed, they are stored without completeness validation: [9](#0-8) 

4. DecryptedPieces accumulate only from miners who successfully decrypt: [10](#0-9) 

**Execution Path:**
- Round N: Malicious miner provides incomplete EncryptedPieces (e.g., omitting 1/3 of miners)
- Round N+1: Only miners with encrypted pieces can decrypt and submit DecryptedPieces
- Round N+1: The malicious miner's DecryptedPieces count remains below `minersCount`
- Round N+2: Secret reconstruction is skipped due to incorrect threshold check
- The malicious miner can withhold their PreviousInValue without forced revelation

### Impact Explanation

**Consensus Integrity Breach:** The vulnerability breaks the forced-reveal property of the secret sharing scheme, which is fundamental to ensuring fair and unpredictable consensus randomness.

**Concrete Harm:**
1. **Mining Order Manipulation:** The signature value (computed from InValue) determines mining order for the next round. Without forced revelation, a malicious miner can avoid verification of their signature: [11](#0-10) 

2. **Randomness Manipulation:** The miner can selectively choose whether to reveal their InValue based on whether it benefits them, breaking the commit-reveal scheme's unpredictability guarantee.

3. **Byzantine Fault Tolerance Defeated:** Shamir's Secret Sharing is designed to tolerate up to 1/3 Byzantine miners, but the incorrect threshold check requires 100% honest participation, reducing tolerance to 0%.

**Affected Parties:** All network participants suffer from compromised consensus fairness. The malicious miner gains unfair advantages in block production scheduling and rewards.

**Severity Justification:** HIGH - This breaks a critical security invariant (correct round transitions and miner schedule integrity) and affects the core consensus mechanism without requiring collusion.

### Likelihood Explanation

**Attacker Capabilities:** Any miner in the active validator set can execute this attack. No special privileges beyond being a validator are required.

**Attack Complexity:** LOW
- The attacker simply provides incomplete EncryptedPieces in their UpdateValue transaction
- No complex cryptographic manipulation or timing requirements
- The attack is undetectable at validation time since EncryptedPieces completeness is not checked

**Feasibility Conditions:**
1. Attacker is an active miner (realistic precondition)
2. Secret sharing is enabled (standard operational mode): [12](#0-11) 

**Detection Constraints:** The attack is difficult to detect because:
- Off-chain nodes cannot distinguish between network-delayed pieces and deliberately withheld pieces
- No on-chain slashing mechanism exists for incomplete secret sharing participation
- Evil miner detection only tracks missed time slots (OutValue == null), not secret sharing non-participation: [13](#0-12) [14](#0-13) 

**Probability:** HIGH - The attack is straightforward to execute and provides concrete benefits to the attacker with minimal risk.

### Recommendation

**Code-Level Mitigation:**

1. Change the threshold check to use `minimumCount` instead of `minersCount`:

```csharp
// In AEDPoSContract_SecretSharing.cs line 36 and SecretSharingService.cs line 162:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

2. Add validation for EncryptedPieces completeness in UpdateValueValidationProvider to ensure miners publish pieces for all active validators.

3. Implement on-chain slashing or reputation penalty for miners who consistently fail to provide complete EncryptedPieces.

**Invariant Checks:**
- Assert that secret reconstruction attempts when `DecryptedPieces.Count >= minimumCount`
- Verify that all miners publish EncryptedPieces containing entries for all other miners in the active set

**Test Cases:**
1. Test secret reconstruction with exactly `minimumCount` decrypted pieces (should succeed)
2. Test that a miner providing incomplete EncryptedPieces still allows reconstruction with sufficient pieces from other miners
3. Test detection and slashing of miners consistently omitting encrypted pieces

### Proof of Concept

**Initial State:**
- 17 active miners in the current round (standard mainnet configuration)
- `minimumCount = 17 * 2 / 3 = 11` (threshold for reconstruction)
- Secret sharing is enabled

**Attack Sequence:**

1. **Round N - Malicious Action:**
   - Miner A (attacker) produces their block with UpdateValue
   - Miner A provides EncryptedPieces containing only 10 entries (instead of 16 for all other miners)
   - No validation error occurs since EncryptedPieces completeness is not checked

2. **Round N+1 - Incomplete Decryption:**
   - Only 10 miners can decrypt pieces from Miner A
   - These 10 miners submit their DecryptedPieces in their UpdateValue transactions
   - Miner A's DecryptedPieces map accumulates only 10 entries

3. **Round N+2 - Reconstruction Failure:**
   - RevealSharedInValues executes
   - Check: `Miner A's DecryptedPieces.Count (10) < minersCount (17)` â†’ FAILS
   - Secret reconstruction is skipped despite having sufficient pieces (`10 >= minimumCount` would be false, but `10 < 11` is still true in this case)
   - If attacker omits 6 miners: 11 pieces collected, reconstruction should succeed but check requires all 17

4. **Round N+2 - Withheld Revelation:**
   - Miner A submits UpdateValue with `PreviousInValue = Hash.Empty`
   - Validation passes since `Hash.Empty` is explicitly allowed
   - Miner A's InValue from Round N is never revealed
   - Miner A's signature cannot be verified for correctness

**Expected vs Actual Result:**
- **Expected:** With 11+ decrypted pieces, secret sharing should successfully reconstruct Miner A's InValue, forcing revelation
- **Actual:** Reconstruction is skipped, allowing Miner A to permanently withhold their InValue and avoid verification

**Success Condition:** Miner A successfully avoids forced revelation while still participating in consensus, breaking the Byzantine fault tolerance guarantee.

### Notes

The vulnerability fundamentally undermines Shamir's Secret Sharing properties by requiring 100% participation instead of the designed threshold. This transforms the Byzantine fault-tolerant mechanism into one that cannot tolerate any non-cooperation, defeating its core purpose. The issue affects the consensus layer's randomness generation and mining order fairness, which are critical for decentralized network security.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L50-50)
```csharp
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L127-137)
```csharp
            var encryptedShares =
                secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].EncryptedPieces;
            if (!encryptedShares.Any() || !encryptedShares.ContainsKey(selfPubkey)) continue;
            var interestingMessage = encryptedShares[selfPubkey];
            var senderPublicKey = ByteArrayHelper.HexStringToByteArray(pubkey);

            var decryptedPiece =
                await _accountService.DecryptMessageAsync(senderPublicKey, interestingMessage.ToByteArray());
            decryptedPieces[pubkey] = decryptedPiece;
            secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].DecryptedPieces[selfPubkey]
                = ByteString.CopyFrom(decryptedPiece);
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L147-149)
```csharp
        var minersCount = round.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L162-162)
```csharp
            if (minerInRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-44)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L91-93)
```csharp
        foreach (var minerInRound in currentRound.RealTimeMinersInformation)
            if (minerInRound.Value.OutValue == null)
                minerInRound.Value.MissedTimeSlots = minerInRound.Value.MissedTimeSlots.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```
