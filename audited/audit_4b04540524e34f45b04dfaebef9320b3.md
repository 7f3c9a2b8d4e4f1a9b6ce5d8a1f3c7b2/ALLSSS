### Title
State Inconsistency in AddSubScheme: TotalShares Update Lost Due to Stale State Overwrite

### Summary
The `AddSubScheme` function contains a critical state inconsistency bug where the `TotalShares` increase performed by the internal `AddBeneficiary` call gets overwritten when `AddSubScheme` saves its stale copy of the scheme state. This results in sub-schemes being registered without their shares being properly accounted for in `TotalShares`, causing incorrect profit distribution where sub-schemes receive disproportionately large shares at the expense of other beneficiaries.

### Finding Description
The vulnerability exists in the `AddSubScheme` function's state management pattern: [1](#0-0) 

The function loads the scheme state into a local variable at the beginning. It then calls `AddBeneficiary`: [2](#0-1) 

The `AddBeneficiary` function loads its own fresh copy of the scheme, updates `TotalShares`, and saves it back to state: [3](#0-2) 

However, after `AddBeneficiary` returns successfully, `AddSubScheme` continues using its original stale scheme variable loaded at line 96, adds the sub-scheme entry, and then saves this stale version back to state: [4](#0-3) 

This final save operation **overwrites** the `TotalShares` update made by `AddBeneficiary`, leaving the contract in an inconsistent state where:
- `scheme.SubSchemes` contains the new sub-scheme entry
- `State.ProfitDetailsMap[schemeId][subSchemeVirtualAddress]` contains the beneficiary details
- BUT `scheme.TotalShares` does NOT include the sub-scheme's shares

### Impact Explanation
This vulnerability causes **direct fund misallocation** during profit distribution. The impact is severe and affects all profit distributions:

When `DistributeProfits` is called, it uses the incorrect (understated) `TotalShares` value: [5](#0-4) 

This incorrect `totalShares` is then used in `DistributeProfitsForSubSchemes` to calculate each sub-scheme's share: [6](#0-5) 

**Concrete Impact:**
- **Sub-schemes receive MORE than their fair share**: The calculation is `(subSchemeShares / totalShares) * totalAmount`, but `totalShares` is missing the sub-scheme's own shares in the denominator
- **Regular beneficiaries receive LESS than their fair share**: The remaining amount distributed to individuals is reduced by the excess given to sub-schemes
- **Cumulative effect**: Each `AddSubScheme` call compounds the problem, with `TotalShares` falling further behind the actual sum of all beneficiary shares
- **Permanent state corruption**: There is no mechanism to recover from this inconsistent state once it occurs

**Example:** If a scheme has 100 initial shares and a sub-scheme with 50 shares is added:
- Correct TotalShares should be: 150
- Actual TotalShares after bug: 100
- Sub-scheme receives: (50/100) * 1000 = 500 tokens instead of (50/150) * 1000 = 333 tokens
- Sub-scheme steals ~167 tokens from other beneficiaries per distribution

### Likelihood Explanation
**Exploitability: HIGH - Requires only normal manager operations**

**Attacker Capabilities:**
- Must be the scheme manager (authorized role for calling `AddSubScheme`)
- No additional privileges needed beyond normal scheme management

**Attack Complexity: TRIVIAL**
- Simply call `AddSubScheme` through normal contract interaction
- The bug triggers automatically on every successful call
- No special sequencing or timing required

**Feasibility:**
- The vulnerable code path executes on EVERY `AddSubScheme` call
- This is a legitimate, frequently-used operation in the Profit contract system
- Sub-schemes are a core feature for hierarchical profit distribution (e.g., Treasury -> TokenHolder -> Individual stakers)

**Detection Constraints:**
- The bug is silent - no failed assertions or error conditions
- State appears valid on surface inspection (sub-scheme is registered, beneficiary exists)
- Only mathematical analysis of profit distribution reveals the discrepancy
- Victims (other beneficiaries) likely won't notice small percentage losses

**Probability: CERTAIN**
- Every legitimate use of `AddSubScheme` triggers the vulnerability
- The bug will manifest in ALL production deployments using sub-schemes
- This is not a race condition or timing issue - it's a deterministic logic error

### Recommendation
**Fix: Reload scheme state after AddBeneficiary call**

Modify `AddSubScheme` to reload the fresh scheme state after `AddBeneficiary` completes:

```csharp
public override Empty AddSubScheme(AddSubSchemeInput input)
{
    Assert(input.SchemeId != input.SubSchemeId, "Two schemes cannot be same.");
    Assert(input.SubSchemeShares > 0, "Shares of sub scheme should greater than 0.");

    var scheme = State.SchemeInfos[input.SchemeId];
    Assert(scheme != null, "Scheme not found.");
    Assert(Context.Sender == scheme.Manager, "Only manager can add sub-scheme.");
    Assert(scheme.SubSchemes.All(s => s.SchemeId != input.SubSchemeId),
        $"Sub scheme {input.SubSchemeId} already exist.");

    var subSchemeId = input.SubSchemeId;
    var subScheme = State.SchemeInfos[subSchemeId];
    Assert(subScheme != null, "Sub scheme not found.");

    var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
    
    AddBeneficiary(new AddBeneficiaryInput
    {
        SchemeId = input.SchemeId,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = subSchemeVirtualAddress,
            Shares = input.SubSchemeShares
        },
        EndPeriod = long.MaxValue
    });

    // CRITICAL FIX: Reload scheme after AddBeneficiary updates TotalShares
    scheme = State.SchemeInfos[input.SchemeId];
    
    scheme.SubSchemes.Add(new SchemeBeneficiaryShare
    {
        SchemeId = input.SubSchemeId,
        Shares = input.SubSchemeShares
    });
    State.SchemeInfos[input.SchemeId] = scheme;

    return new Empty();
}
```

**Additional Safeguards:**
1. Add an invariant check: Assert that the sum of all beneficiary shares in `ProfitDetailsMap` equals `TotalShares`
2. Add a state verification function that scheme managers can call to detect inconsistencies
3. Add comprehensive integration tests that verify profit distribution percentages match expected share ratios

### Proof of Concept
**Initial State:**
- Scheme A exists with TotalShares = 100 (e.g., two regular beneficiaries with 50 shares each)
- Scheme B exists (to be added as sub-scheme)

**Exploit Steps:**
1. Scheme A manager calls `AddSubScheme(SchemeId: A, SubSchemeId: B, SubSchemeShares: 50)`
2. Execution flow:
   - Line 96: `scheme` loaded with TotalShares = 100
   - Lines 109-118: `AddBeneficiary` called
     - AddBeneficiary loads fresh scheme, updates TotalShares to 150, saves to state
   - Lines 121-125: Original `scheme` variable (TotalShares = 100) has SubSchemes updated
   - Line 126: Stale scheme saved, overwriting TotalShares back to 100

**Expected Result:**
- TotalShares should be 150 (100 + 50)
- During profit distribution of 1500 tokens:
  - Sub-scheme B should receive: (50/150) * 1500 = 500 tokens
  - Other beneficiaries combined: 1000 tokens

**Actual Result:**
- TotalShares is 100 (BUG)
- During profit distribution of 1500 tokens:
  - Sub-scheme B receives: (50/100) * 1500 = 750 tokens (250 excess)
  - Other beneficiaries combined: 750 tokens (250 shortfall)
  - **250 tokens stolen from legitimate beneficiaries**

**Verification:**
Query `State.SchemeInfos[A].TotalShares` → returns 100 (should be 150)
Query `State.SchemeInfos[A].SubSchemes.Count` → returns 1 (correct)
Query `State.ProfitDetailsMap[A][B_VirtualAddress]` → exists with 50 shares (correct)

The state is internally inconsistent, causing permanent fund misallocation.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L96-96)
```csharp
        var scheme = State.SchemeInfos[input.SchemeId];
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L109-118)
```csharp
        AddBeneficiary(new AddBeneficiaryInput
        {
            SchemeId = input.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = subSchemeVirtualAddress,
                Shares = input.SubSchemeShares
            },
            EndPeriod = long.MaxValue
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L121-126)
```csharp
        scheme.SubSchemes.Add(new SchemeBeneficiaryShare
        {
            SchemeId = input.SubSchemeId,
            Shares = input.SubSchemeShares
        });
        State.SchemeInfos[input.SchemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L166-184)
```csharp
        var scheme = State.SchemeInfos[schemeId];

        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");

        Context.LogDebug(() =>
            $"{input.SchemeId}.\n End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);

        State.SchemeInfos[schemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L462-462)
```csharp
        var totalShares = scheme.TotalShares;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L621-621)
```csharp
            var distributeAmount = SafeCalculateProfits(subSchemeShares.Shares, totalAmount, totalShares);
```
