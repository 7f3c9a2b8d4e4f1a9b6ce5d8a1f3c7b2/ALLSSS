### Title
MethodFeeController Governance Bypass via Unvalidated Organization Threshold

### Summary
The `ChangeMethodFeeController` method in the Economic contract fails to validate the security properties of the new controller organization, allowing a 1-of-N Association organization to be set as the method fee controller. This enables permanent bypass of intended multi-sig governance, as an attacker controlling a single key in such an organization can unilaterally approve all future method fee changes without requiring the originally intended 2/3 block producer consensus.

### Finding Description

**Root Cause:** The `ChangeMethodFeeController` method only validates organization existence, not threshold security. [1](#0-0) 

The method calls `CheckOrganizationExist` which only verifies the organization exists: [2](#0-1) 

This calls `ValidateOrganizationExist` in the Association contract, which merely checks if `State.Organizations[input] != null`: [3](#0-2) 

**Why Weak Organizations Are Valid:** The Association contract's validation logic allows organizations with `MinimalApprovalThreshold = 1`: [4](#0-3) 

The validation only requires `MinimalApprovalThreshold > 0`, meaning a 1-of-1 organization passes all checks.

**Exploitation Path:**
1. Attacker creates a 1-of-1 Association organization where they control the single member and proposer
2. Through a Parliament proposal (requiring initial 2/3 BP approval, potentially obtained through social engineering or inadequate parameter review), the `MethodFeeController` is changed to this weak organization
3. The `SetMethodFee` method now only requires the attacker's single signature: [5](#0-4) 

4. All future method fee changes bypass multi-sig governance permanently

### Impact Explanation

**Governance Impact:** Once a weak organization is set as `MethodFeeController`, the attacker gains permanent unilateral control over method fees for the Economic contract. The default controller requires 2/3 block producer approval: [6](#0-5) 

This bypass is permanent because the attacker can also prevent future controller changes through their control.

**Operational Impact:** The attacker can:
- Set method fees to zero, breaking fee economics and enabling spam
- Set fees arbitrarily high, causing DoS of contract functions
- Change fees discriminatorily across methods to manipulate protocol behavior

**Affected Scope:** This vulnerability pattern affects ALL contracts implementing ACS1 (Economic, Token, Consensus, Election, Treasury, Profit, etc.), not just Economic contract.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to create Association organizations (public function)
- Obtaining Parliament proposal approval (2/3 BPs) for controller change

**Feasibility:** The critical aspect is obtaining initial BP approval. Realistic scenarios include:
- **Social engineering:** Proposal framed as "governance improvement" without BPs carefully reviewing organization parameters
- **Parameter obfuscation:** Organization address provided without threshold details visible
- **Legitimate but careless governance:** BPs approve without security audit

**Execution Practicality:** Once controller is changed:
1. Attacker creates proposal in their 1-of-1 organization
2. Attacker approves their own proposal (single signature)
3. Attacker releases proposal to execute `SetMethodFee`

**Detection:** The vulnerability is exploitable before detection because organization parameters are not easily auditable from the `AuthorityInfo` structure: [7](#0-6) 

Only `owner_address` and `contract_address` are visible, not the underlying threshold configuration.

### Recommendation

**Immediate Fix:** Add threshold validation in `ChangeMethodFeeController`:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    var exists = Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
    
    if (!exists) return false;
    
    // Add threshold validation for Association organizations
    if (authorityInfo.ContractAddress == State.AssociationContract.Value)
    {
        var org = Context.Call<Organization>(authorityInfo.ContractAddress,
            "GetOrganization", authorityInfo.OwnerAddress);
        
        // Require minimum security: at least 2 members and 2 approvals
        Assert(org.OrganizationMemberList.OrganizationMembers.Count >= 2,
            "Organization must have at least 2 members");
        Assert(org.ProposalReleaseThreshold.MinimalApprovalThreshold >= 2,
            "Organization must require at least 2 approvals");
    }
    
    return true;
}
```

**Invariant to Enforce:** Method fee controllers must maintain multi-sig properties with minimum threshold requirements.

**Test Cases:**
1. Test rejecting `ChangeMethodFeeController` with 1-of-1 organization
2. Test rejecting `ChangeMethodFeeController` with 1-of-N organization where N > 1
3. Test accepting `ChangeMethodFeeController` with proper multi-sig (e.g., 2-of-3)

### Proof of Concept

**Initial State:**
- Economic contract deployed with default Parliament controller (2/3 BP threshold)

**Attack Sequence:**

1. **Attacker creates weak organization:**
```
CreateOrganizationInput {
    OrganizationMemberList: { attacker_address },
    ProposerWhiteList: { attacker_address },
    ProposalReleaseThreshold: {
        MinimalApprovalThreshold: 1,
        MinimalVoteThreshold: 1,
        MaximalAbstentionThreshold: 0,
        MaximalRejectionThreshold: 0
    }
}
```
Returns: `weak_org_address`

2. **Create Parliament proposal to change controller:**
```
CreateProposal {
    ContractMethodName: "ChangeMethodFeeController",
    ToAddress: economic_contract_address,
    Params: AuthorityInfo {
        OwnerAddress: weak_org_address,
        ContractAddress: association_contract_address
    }
}
```

3. **Get 2/3 BP approval and release** (through social engineering or compromised governance)

4. **Attacker now controls method fees:**
```
// Create proposal in weak organization
CreateProposal { 
    ContractMethodName: "SetMethodFee",
    Params: MethodFees { fees: [...] }
}
// Approve with single signature
Approve(proposal_id)
// Release immediately
Release(proposal_id)
```

**Expected Result:** `SetMethodFee` should require multi-sig approval (2/3 BPs)

**Actual Result:** `SetMethodFee` executed with single attacker signature, permanently bypassing governance

### Citations

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L50-64)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** protobuf/authority_info.proto (L1-10)
```text
syntax = "proto3";

import "aelf/core.proto";

message AuthorityInfo {
    // The contract address of the controller.
    aelf.Address contract_address = 1;
    // The address of the owner of the contract.
    aelf.Address owner_address = 2;
}
```
