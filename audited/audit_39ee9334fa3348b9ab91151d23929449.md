### Title
Irreversible Miner Increase Interval Reduction Enables Uncontrolled Consensus Growth

### Summary
The `SetMinerIncreaseInterval()` function contains a one-way assertion that only allows the miner increase interval to decrease, never increase. Combined with the auto-increase formula and the default `MaximumMinersCount` of `int.MaxValue`, this creates an irreversible path to rapid, uncontrolled miner count growth that cannot be corrected once triggered, potentially destabilizing consensus operations.

### Finding Description

The vulnerability exists in the `SetMinerIncreaseInterval()` method: [1](#0-0) 

The assertion on line 61 enforces that `input.Value <= State.MinerIncreaseInterval.Value`, meaning the interval can only be decreased or remain the same—it can never be increased. This is confirmed by the test suite: [2](#0-1) 

The test explicitly verifies that attempting to increase the interval (by adding 1) results in an "Invalid interval" error, while decreasing works successfully.

The miner increase interval directly controls the auto-increase formula used to calculate the number of miners: [3](#0-2) 

The formula is: `SupposedMinersCount + ((CurrentTime - StartTime) / MinerIncreaseInterval) × 2`

A smaller interval causes faster miner count growth. The critical issue is that `MaximumMinersCount` defaults to effectively unlimited: [4](#0-3) 

**Root Cause**: The one-way constraint lacks a recovery mechanism. Once governance sets a low interval value (whether accidentally or due to parameter miscalculation), there is no way to slow down the miner growth rate by increasing the interval back to a reasonable value.

**Why Existing Protections Fail**:
1. No minimum interval validation exists in `SetMinerIncreaseInterval()`
2. No bidirectional range check (only one-way ≤ check)
3. `MaximumMinersCount` defaults to `int.MaxValue` unless explicitly set through governance
4. The authorization check only validates permission, not parameter reasonableness

### Impact Explanation

**Consensus Performance Degradation**: If the interval is set to a small value (e.g., 86,400 seconds = 1 day instead of 31,536,000 seconds = 1 year), miners would increase by 2 every day. After 1 year, this would result in approximately 730 additional miners beyond the initial 17, leading to:
- Longer consensus rounds due to increased time slot allocations
- Higher communication overhead between miners
- Increased block validation complexity
- Degraded network performance and throughput

**Resource Exhaustion**: More miners require:
- More storage for maintaining miner state
- More computation for round generation and LIB calculation
- More network bandwidth for consensus message propagation

**Economic Impact**: Mining rewards and profit distributions are split among all miners, diluting rewards for legitimate participants and potentially making mining economically unviable.

**Irreversibility**: The most severe aspect is that once the interval is decreased, it cannot be increased back, making the damage permanent. Even if governance recognizes the error, they have no mechanism to correct it other than setting `MaximumMinersCount` to cap the damage—but the interval itself remains permanently low.

**Affected Parties**: All network participants suffer from consensus degradation, but miners are particularly affected by diluted rewards and increased operational complexity.

### Likelihood Explanation

**Attacker Capabilities**: This requires governance approval through the `MaximumMinersCountController` (typically Parliament), which requires legitimate proposer and miner approval. However, the vulnerability does not require malicious intent—human error in parameter selection is sufficient.

**Attack Complexity**: LOW. The attack requires only a single governance proposal to set an incorrect interval value. Complex technical setup is not required—just a parameter value mistake.

**Feasibility Conditions**:
1. Governance proposes and approves a low `MinerIncreaseInterval` value (could be due to unit confusion: seconds vs. days, decimal point errors, or misunderstanding the growth formula)
2. `MaximumMinersCount` is not set to a reasonable cap (defaults to `int.MaxValue`)
3. Once executed, the interval cannot be corrected upward

**Realistic Scenario**: Consider a governance proposal intending to set the interval to 1 year (31,536,000 seconds) but accidentally specifying 31,536 seconds (approximately 8.76 hours) due to a missing digit or unit conversion error. This would cause miners to increase by 2 approximately every 8.76 hours—over 1,000 times faster than intended.

**Detection and Operational Constraints**: The error would only become apparent after observing rapid miner count growth over time. By then, the damage is already done and irreversible. Monitoring systems may not immediately flag this as anomalous since the parameter change itself is legitimate governance action.

**Probability**: MEDIUM-HIGH. Parameter configuration errors in governance systems are well-documented across blockchain projects. The lack of validation bounds and the irreversible nature significantly increase the probability of this vulnerability being exploited through genuine mistakes.

### Recommendation

**1. Remove One-Way Constraint**: Modify the assertion to allow bidirectional changes:

```solidity
// In SetMinerIncreaseInterval()
Assert(input.Value > 0, "Interval must be positive");
Assert(input.Value <= MaximumAllowedInterval, "Interval exceeds maximum");
Assert(input.Value >= MinimumAllowedInterval, "Interval below minimum");
State.MinerIncreaseInterval.Value = input.Value;
```

Define reasonable constants:
- `MinimumAllowedInterval`: e.g., 86,400 seconds (1 day) to prevent excessive growth
- `MaximumAllowedInterval`: e.g., 126,144,000 seconds (4 years) to ensure growth occurs

**2. Add Parameter Validation**: Implement range checks based on expected blockchain operation parameters.

**3. Set Reasonable Default for MaximumMinersCount**: During initialization, set a reasonable maximum (e.g., 101 miners) instead of `int.MaxValue`: [4](#0-3) 

**4. Add Change Impact Warning**: Emit an event when `MinerIncreaseInterval` is changed, logging the old and new values and the projected miner count impact over the next term.

**5. Test Cases**: Add regression tests verifying:
- Interval can be both increased and decreased within valid bounds
- Attempting to set values outside bounds fails appropriately
- Projected miner growth rate matches expected parameters

### Proof of Concept

**Initial State**:
- `MinerIncreaseInterval`: 31,536,000 (1 year, default)
- `MaximumMinersCount`: 2,147,483,647 (int.MaxValue)
- `SupposedMinersCount`: 17
- `BlockchainStartTimestamp`: T₀

**Attack Sequence**:

1. **Governance Proposal**: Parliament creates proposal to set `MinerIncreaseInterval` to 86,400 (1 day) due to parameter confusion
   - Proposer believes they are setting "reasonable growth"
   - Value passes the assertion check: 86,400 < 31,536,000 ✓

2. **Proposal Execution**: 
   ```
   SetMinerIncreaseInterval(86,400)
   Assert(86,400 <= 31,536,000) // Passes
   State.MinerIncreaseInterval.Value = 86,400
   ```

3. **Miner Count Growth** (at various timestamps):
   - T₀ + 1 day: 17 + (86,400 / 86,400) × 2 = 19 miners
   - T₀ + 30 days: 17 + (2,592,000 / 86,400) × 2 = 77 miners
   - T₀ + 365 days: 17 + (31,536,000 / 86,400) × 2 = 747 miners

4. **Recovery Attempt Fails**:
   ```
   SetMinerIncreaseInterval(31,536,000) // Try to restore original
   Assert(31,536,000 <= 86,400) // FAILS - "Invalid interval"
   ```

**Expected vs Actual Result**:
- **Expected**: Governance can correct the parameter error by increasing the interval back to 31,536,000
- **Actual**: The one-way assertion prevents correction, permanently locking the network into rapid miner growth

**Success Condition**: The vulnerability is confirmed when:
1. An interval decrease is accepted
2. An interval increase (back to original value) is rejected
3. Miner count grows according to the reduced interval
4. No governance mechanism exists to reverse the change

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L121-132)
```csharp
        var transactionResult = await ParliamentReachAnAgreementWithExceptionAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = minerIncreaseInterval.Value + 1
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        transactionResult.Error.ShouldContain("Invalid interval");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L52-52)
```csharp
        State.MaximumMinersCount.Value = int.MaxValue;
```
