### Title
Governance Proposals Can Be Created With Far-Future Expiry Times Causing Permanent State Bloat

### Summary
The Association, Parliament, and Referendum governance contracts allow authorized proposers to create proposals with ExpiredTime set to year 9999 or any far-future date. Such proposals cannot be cleared until their expiry time is reached, effectively making them permanent if they never reach approval threshold. This enables state storage bloat that persists indefinitely.

### Finding Description

The vulnerability exists in the proposal validation logic across all three governance contracts (Association, Parliament, and Referendum). 

In the Association contract, the `Validate(ProposalInfo)` method only verifies that ExpiredTime is not null and is in the future relative to the current block time: [1](#0-0) 

The validation lacks an upper bound check on ExpiredTime. Google Protobuf Timestamp supports dates up to year 9999 with a seconds value of 253402300799L: [2](#0-1) 

Proposals can only be removed from state through two mechanisms:
1. **Release**: When a proposal is approved and executed, it's deleted from state [3](#0-2) 

2. **ClearProposal**: Anyone can clear a proposal, but ONLY if it has expired [4](#0-3) 

The ClearProposal method explicitly requires `Context.CurrentBlockTime >= proposal.ExpiredTime`, meaning proposals with year 9999 expiry cannot be cleared for approximately 8000 years.

If a proposal with far-future expiry never reaches the approval threshold (due to rejection, abstention, or simply being ignored), it remains in state storage permanently with no removal mechanism.

The same vulnerability exists in Parliament and Referendum contracts with identical validation patterns: [5](#0-4) [6](#0-5) 

### Impact Explanation

**State Storage Bloat**: Each proposal with a far-future expiry occupies permanent state storage. A malicious or careless proposer can create numerous proposals (limited only by transaction fees if configured) that will never be removable through normal cleanup mechanisms.

**Node Operator Costs**: All full nodes must store these proposals indefinitely, increasing storage requirements and operational costs for the network.

**Performance Degradation**: Large numbers of perpetual proposals could degrade query performance and state management operations.

**Who Is Affected**: 
- All node operators bear increased storage costs
- Organizations with compromised or malicious proposers
- The overall network efficiency

**Severity Justification (Medium)**: While this doesn't enable direct fund theft or immediate system failure, it allows permanent resource consumption. The impact is gradual but irreversible. The medium severity reflects that:
- Attacker must be an authorized proposer (not fully permissionless)
- Organizations can remove malicious proposers from whitelist (though existing proposals remain)
- Method fees can provide some economic deterrent if configured
- Impact accumulates over time rather than causing immediate catastrophic failure

### Likelihood Explanation

**Attacker Capabilities**: The attacker must be in the proposer whitelist of a governance organization. For Association contracts, this is any member of the multi-sig organization. For Parliament, this includes block producers or whitelisted addresses. For Referendum, this includes whitelisted proposers.

**Attack Complexity**: Very low - simply create proposals with ExpiredTime set to year 9999:
```
ExpiredTime = new Timestamp { Seconds = 253402300799L }
```

**Feasibility Conditions**:
- Attacker is an authorized proposer (common for organization members)
- Method fees may not be configured (default is zero)
- Even if fees exist, a well-funded attacker pays once for permanent bloat

**Detection Constraints**: The attack may go unnoticed initially as proposals with far-future expiry are technically valid. Only when attempting to clean up state would operators discover the problem.

**Probability**: High for accidental occurrence (proposers setting very long expiry times for legitimate reasons), Medium for malicious exploitation (requires proposer access but is trivial to execute).

### Recommendation

**1. Add Maximum Expiry Time Validation**

Add a constant defining maximum proposal lifetime (e.g., 1 year or 30 days) and validate ExpiredTime against it:

In `AssociationConstants.cs` (and similar for Parliament/Referendum):
```csharp
public const long MaxProposalLifetimeSeconds = 31536000; // 1 year
```

Modify the `Validate(ProposalInfo)` method in `Association_Helper.cs`:
```csharp
private bool Validate(ProposalInfo proposal)
{
    if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
        !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
        return false;

    if (proposal.ExpiredTime == null || Context.CurrentBlockTime >= proposal.ExpiredTime)
        return false;
    
    // Add maximum expiry validation
    var maxExpiredTime = Context.CurrentBlockTime.AddSeconds(AssociationConstants.MaxProposalLifetimeSeconds);
    return proposal.ExpiredTime <= maxExpiredTime;
}
```

Apply the same fix to Parliament_Helper.cs and Referendum_Helper.cs.

**2. Add Governance-Controlled Maximum**

Alternatively, make the maximum proposal lifetime configurable per organization or globally through governance, with a reasonable default.

**3. Test Cases**

Add test cases to verify:
- Proposals with ExpiredTime > MaxProposalLifetime are rejected
- Proposals with ExpiredTime at the maximum are accepted
- Existing cleanup mechanisms (ClearProposal) work correctly with the new limit

### Proof of Concept

**Initial State**:
- Association organization exists with proposer whitelist containing attacker address
- No method fees configured (or attacker has sufficient funds)

**Attack Steps**:

1. **Create proposal with year 9999 expiry**:
```csharp
var farFutureTime = new Timestamp { Seconds = 253402300799L }; // Year 9999
var createProposalInput = new CreateProposalInput
{
    ToAddress = targetContractAddress,
    ContractMethodName = "SomeMethod",
    Params = ByteString.Empty,
    ExpiredTime = farFutureTime,
    OrganizationAddress = organizationAddress,
    Title = "Test Proposal",
    Description = "This will never expire"
};
await associationContractStub.CreateProposal.SendAsync(createProposalInput);
```

2. **Proposal passes validation**: The Validate method accepts it because `Context.CurrentBlockTime < farFutureTime` is true.

3. **Proposal stored in state**: The proposal is stored in `State.Proposals[proposalId]`.

4. **Proposal never reaches approval**: Design the proposal to be controversial or simply ignore voting, so it never reaches the release threshold.

5. **Attempt to clear proposal**: Call `ClearProposal(proposalId)` - it fails because `Context.CurrentBlockTime >= proposal.ExpiredTime` is false and will remain false for ~8000 years.

**Expected Result**: Proposal should be rejected during creation due to unreasonable expiry time.

**Actual Result**: Proposal is accepted and remains in state storage permanently until year 9999, with no mechanism for early removal.

**Success Condition**: After attack, query `State.Proposals[proposalId]` shows the proposal exists and will exist indefinitely. The ClearProposal method remains unusable for this proposal for millennia.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Election/TimestampHelper.cs (L12-15)
```csharp
    /// <summary>
    ///     9999-12-31T23:59:59.999999999Z
    /// </summary>
    public static Timestamp MaxValue => new() { Nanos = 999999999, Seconds = 253402300799L };
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L177-180)
```csharp
    private bool CheckProposalNotExpired(ProposalInfo proposal)
    {
        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```
