# Audit Report

## Title
State Inconsistency in RemoveBeneficiary Allows Orphaned Lock State and Profit Loss

## Summary
The `RemoveBeneficiary` function in the TokenHolder contract removes or reduces a user's profit shares without unlocking their tokens or cleaning up associated lock state mappings. This creates an inconsistent state where users who registered via `RegisterForProfits` have locked tokens but no corresponding profit beneficiary status, causing them to lose expected dividends while their funds remain inaccessible for the `MinimumLockMinutes` period.

## Finding Description

When a user calls `RegisterForProfits`, the TokenHolder contract performs three critical state changes: (1) locks tokens in the MultiToken contract, (2) creates a `LockIds` mapping entry tracking the lock, and (3) adds the user as a beneficiary in the Profit contract with shares equal to the locked amount. [1](#0-0) 

The `LockIds` mapping maintains the relationship between scheme managers, users, and their lock identifiers. [2](#0-1) 

However, the `RemoveBeneficiary` function only interacts with the Profit contract to remove or reduce beneficiary shares. It does NOT unlock the tokens in the MultiToken contract, does NOT remove the `LockIds` mapping entry, and does NOT update any lock-related state. [3](#0-2) 

This creates an inconsistent state where `State.LockIds[schemeManager][user]` still exists, the user's tokens remain locked in the MultiToken contract, but the user is removed or has reduced shares in the Profit contract and receives no or reduced profit distributions.

The `Withdraw` function is designed to clean up this state, but it requires `MinimumLockMinutes` to elapse before tokens can be unlocked. During this entire period, users with orphaned lock state receive no profits despite having locked tokens. [4](#0-3) 

Additionally, the Profit contract's `RemoveBeneficiary` function silently succeeds even if the beneficiary is already removed or doesn't exist, which masks the inconsistency from the TokenHolder contract. [5](#0-4) 

## Impact Explanation

**Financial Impact:**
Users lose all expected profit distributions for the entire duration their tokens remain locked (up to `MinimumLockMinutes`). If a scheme distributes profits multiple times during the lock period (e.g., weekly distributions over a 90-day lock), users receive none of these profits despite having committed their tokens. This represents direct financial loss with no compensation mechanism.

**State Consistency Impact:**
The vulnerability violates the core invariant that locked tokens should earn profit shares. It creates orphaned `LockIds` entries that reference locked tokens with no corresponding profit beneficiary status, causing token lock amounts and profit shares to become permanently desynchronized until the lock period expires.

**Affected Parties:**
Any user who called `RegisterForProfits` and subsequently had the scheme manager call `RemoveBeneficiary` on them. In schemes with long `MinimumLockMinutes` values (e.g., 90 days as mentioned in the protobuf definition), users could lose months of profit distributions while their capital remains inaccessible. [6](#0-5) 

## Likelihood Explanation

**Attacker Capabilities:**
The scheme manager, who is set at scheme creation time to `Context.Sender`, can call `RemoveBeneficiary` on any registered user at any time. [7](#0-6) 

**Feasibility:**
While the scheme manager is a privileged role, it is NOT listed as a trusted role in the AElf security model (which only trusts genesis method-fee providers, organization controllers, and consensus system contracts). The scheme manager could be a malicious actor from the start, a compromised account, or an automated contract with flawed logic. Users who lock tokens trust they will receive profits, but have no protection against this scenario.

**Detection:**
No checks prevent `RemoveBeneficiary` from being called on users with locked tokens. The test suite contains no coverage for the `RegisterForProfits` + `RemoveBeneficiary` scenario, indicating this edge case was not considered during development. [8](#0-7) 

## Recommendation

The `RemoveBeneficiary` function should be modified to handle users who registered via `RegisterForProfits` by also unlocking their tokens and cleaning up the associated lock state:

```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);
    
    // Check if this beneficiary has locked tokens
    var lockId = State.LockIds[Context.Sender][input.Beneficiary];
    
    if (lockId != null)
    {
        // Get locked amount
        var lockedAmount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = input.Beneficiary,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
        
        // Unlock tokens
        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address: input.Beneficiary,
            LockId: lockId,
            Amount: lockedAmount,
            Symbol: scheme.Symbol
        });
        
        // Clean up lock state
        State.LockIds[Context.Sender].Remove(input.Beneficiary);
        State.LockTimestamp.Remove(lockId);
    }
    
    // Continue with existing beneficiary removal logic
    var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
    {
        Beneficiary = input.Beneficiary,
        SchemeId = scheme.SchemeId
    }).Details.SingleOrDefault();
    
    if (detail != null)
    {
        var shares = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        
        if (shares > input.Amount && input.Amount != 0)
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = shares.Sub(input.Amount)
                }
            });
    }
    
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task RemoveBeneficiary_After_RegisterForProfits_Causes_Locked_State_Without_Profits()
{
    // Setup: Create scheme with 90 day lock period
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 129600 // 90 days
    });
    
    // User registers for profits with 1000 tokens
    var lockAmount = 1000L;
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = lockAmount,
        SchemeManager = Starter
    });
    
    // Verify user has locked tokens and profit shares
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
    {
        Manager = Starter
    });
    var schemeId = schemeIds.SchemeIds.First();
    
    var profitDetailsBefore = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId,
        Beneficiary = Starter
    });
    profitDetailsBefore.Details.Count.ShouldBe(1);
    profitDetailsBefore.Details[0].Shares.ShouldBe(lockAmount);
    
    // Scheme manager removes beneficiary
    await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
    {
        Beneficiary = Starter,
        Amount = 0 // Complete removal
    });
    
    // VULNERABILITY: User has NO profit shares anymore
    var profitDetailsAfter = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId,
        Beneficiary = Starter
    });
    profitDetailsAfter.ShouldBeNull(); // No profit shares
    
    // BUT tokens are still locked - user cannot access them
    var balanceBefore = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = "ELF",
        Owner = Starter
    })).Balance;
    
    // Attempting to withdraw fails because MinimumLockMinutes hasn't elapsed
    var withdrawResult = await TokenHolderContractStub.Withdraw.SendWithExceptionAsync(Starter);
    withdrawResult.TransactionResult.Error.ShouldContain("Cannot withdraw");
    
    // User loses profit distributions during entire lock period
    // while having no access to their locked tokens
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-177)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-245)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L12-15)
```csharp
    /// <summary>
    ///     Contract address (Manager address) -> Beneficiary address -> Lock id.
    /// </summary>
    public MappedState<Address, Address, Hash> LockIds { get; set; }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-235)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();
```

**File:** protobuf/token_holder_contract.proto (L63-70)
```text
message CreateTokenHolderProfitSchemeInput {
    // The token symbol.
    string symbol = 1;
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 2;
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 3;
}
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L138-196)
```csharp
    public async Task RemoveBeneficiaryTest()
    {
        await AddBeneficiaryTest();

        var tokenHolderProfitScheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);

        await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
        {
            Beneficiary = UserAddresses.First()
        });

        {
            var originScheme = await ProfitContractStub.GetScheme.CallAsync(tokenHolderProfitScheme.SchemeId);
            originScheme.TotalShares.ShouldBe(0);
        }
    }

    [Fact]
    public async Task RemoveBeneficiary_With_Amount_Test()
    {
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "ELF"
        });
        await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeManager = Starter,
            Symbol = "ELF",
            Amount = 9999
        });
        await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
        {
            Beneficiary = Starter,
            Shares = 1000
        });
        var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
        {
            Manager = Starter
        });
        var schemeId = schemeIds.SchemeIds[0];
        var beforeRemoveScheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
        var amount = 10;
        await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
        {
            Beneficiary = Starter,
            Amount = amount
        });
        var afterRemoveScheme = await ProfitContractStub.GetScheme.CallAsync(schemeIds.SchemeIds[0]);
        afterRemoveScheme.TotalShares.ShouldBe(beforeRemoveScheme.TotalShares - amount);
        var profitAmount = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
        {
            Beneficiary = Starter,
            SchemeId = schemeId
        });
        profitAmount.Details.Count.ShouldBe(2);
        profitAmount.Details[0].Shares.ShouldBe(beforeRemoveScheme.TotalShares);
        profitAmount.Details[0].EndPeriod.ShouldBe(0);
        profitAmount.Details[1].Shares.ShouldBe(beforeRemoveScheme.TotalShares - amount);
    }
```
