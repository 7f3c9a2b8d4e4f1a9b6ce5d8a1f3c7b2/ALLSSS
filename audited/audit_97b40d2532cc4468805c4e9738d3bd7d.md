### Title
Empty Whitelist DOS: User Contract Deployment Blocked on Non-Public Side Chains

### Summary
The `AssertUserDeployContract()` function fails to check if users are parliament members when `ParliamentMemberProposingAllowed` is enabled, only verifying whitelist membership. When the Parliament proposer whitelist is legitimately empty (allowed when parliament members can propose), all user contract deployments on non-public side chains are permanently blocked, including for authorized parliament members.

### Finding Description

The vulnerability exists in the `AssertUserDeployContract()` function which is called during user contract deployment. [1](#0-0) 

This function only checks if `Context.Sender` is in the Parliament's proposer whitelist, but fails to check if the sender is a parliament member when `ParliamentMemberProposingAllowed` is enabled. On non-public side chains (where `NativeSymbol != PrimaryTokenSymbol`), the function retrieves the global Parliament whitelist and performs a `Contains` check. When the whitelist is empty, this check always returns false, causing the assertion to fail.

The Parliament contract explicitly allows empty whitelists when `ParliamentMemberProposingAllowed` is true. [2](#0-1) 

The default Parliament organization is always created with `ParliamentMemberProposingAllowed = true`. [3](#0-2) 

The correct authorization logic is implemented in `AssertIsAuthorizedProposer()` which checks three conditions: authority not required OR proposer in whitelist OR (parliament member AND member proposing allowed). [4](#0-3) 

The function is called from the public `DeployUserSmartContract()` method, which is the only entry point for user contract deployment. [5](#0-4) 

### Impact Explanation

**Operational Impact - Complete DOS:**
- All user contract deployments are permanently blocked on affected side chains
- Even authorized parliament members (miners) who should be able to deploy contracts when `ParliamentMemberProposingAllowed = true` cannot deploy
- No workaround exists as this is the sole path for user contract deployment
- Affects the entire side chain ecosystem's ability to add new contracts

**Affected Chains:**
- Non-public side chains where `NativeSymbol != PrimaryTokenSymbol`
- Any side chain with an empty Parliament proposer whitelist (a legitimate configuration)

**Severity Justification:**
This is a HIGH severity issue causing complete protocol functionality failure for a critical operation (contract deployment) with no bypass mechanism available.

### Likelihood Explanation

**Preconditions (All Legitimate):**
1. Side chain is non-public (`NativeSymbol != PrimaryTokenSymbol`) - common for most side chains
2. Parliament proposer whitelist is empty - this is explicitly allowed and valid when `ParliamentMemberProposingAllowed = true`

**No Attacker Required:**
The vulnerability manifests from a valid configuration state. The whitelist can become empty through:
- Normal governance operations via `ChangeOrganizationProposerWhiteList`
- Initial deployment if `PrivilegedProposer` is null during Parliament initialization [6](#0-5) 

**Evidence from Tests:**
Test code explicitly works around this issue by adding addresses to the whitelist before deployment, confirming the known limitation. [7](#0-6) 

**Probability:** High - occurs whenever a non-public side chain has an empty whitelist, which is a valid operational state.

### Recommendation

Modify `AssertUserDeployContract()` to match the correct authorization logic in `AssertIsAuthorizedProposer()`:

```csharp
private void AssertUserDeployContract()
{
    RequireTokenContractContractAddressSet();
    var primaryTokenSymbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;
    if (Context.Variables.NativeSymbol == primaryTokenSymbol)
    {
        return;
    }

    RequireParliamentContractAddressSet();
    var whitelist = State.ParliamentContract.GetProposerWhiteList.Call(new Empty());
    
    // Check if sender is in whitelist
    if (whitelist.Proposers.Contains(Context.Sender))
        return;
    
    // If not in whitelist, check if parliament member proposing is allowed
    var defaultOrg = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
    var organization = State.ParliamentContract.GetOrganization.Call(defaultOrg);
    
    if (organization.ParliamentMemberProposingAllowed)
    {
        // Verify sender is a parliament member
        var isParliamentMember = State.ParliamentContract.ValidateAddressIsParliamentMember.Call(Context.Sender).Value;
        Assert(isParliamentMember, "No permission.");
    }
    else
    {
        Assert(false, "No permission.");
    }
}
```

Add regression test cases for:
1. User contract deployment with empty whitelist but sender is parliament member
2. User contract deployment with empty whitelist but sender is not parliament member
3. Non-public side chain deployment scenarios

### Proof of Concept

**Initial State:**
1. Non-public side chain where `NativeSymbol != PrimaryTokenSymbol`
2. Parliament contract initialized with empty proposer whitelist
3. Default organization has `ParliamentMemberProposingAllowed = true` (default)
4. User is a valid parliament member (miner)

**Exploitation Steps:**
1. Parliament member calls `DeployUserSmartContract()` with valid contract code
2. Function executes `AssertUserDeployContract()` at line 412
3. Check passes for main chain test (line 348-352) but fails for non-public side chain
4. Function retrieves empty whitelist from Parliament contract (line 355)
5. Performs `whitelist.Proposers.Contains(Context.Sender)` check (line 356)
6. Since whitelist is empty, `Contains()` returns false for ANY address
7. Assertion fails with "No permission." message

**Expected vs Actual:**
- **Expected:** Parliament member should be authorized to deploy when `ParliamentMemberProposingAllowed = true`, even with empty whitelist
- **Actual:** All users (including parliament members) are blocked from deploying contracts

**Success Condition:**
Transaction reverts with "No permission." error, completely blocking user contract deployment functionality on the side chain.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L344-357)
```csharp
    private void AssertUserDeployContract()
    {
        // Only the symbol of main chain or public side chain is native symbol.
        RequireTokenContractContractAddressSet();
        var primaryTokenSymbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;
        if (Context.Variables.NativeSymbol == primaryTokenSymbol)
        {
            return;
        }

        RequireParliamentContractAddressSet();
        var whitelist = State.ParliamentContract.GetProposerWhiteList.Call(new Empty());
        Assert(whitelist.Proposers.Contains(Context.Sender), "No permission.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L11-36)
```csharp
    public override Empty Initialize(InitializeInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        var proposerWhiteList = new ProposerWhiteList();

        if (input.PrivilegedProposer != null)
            proposerWhiteList.Proposers.Add(input.PrivilegedProposer);

        State.ProposerWhiteList.Value = proposerWhiteList;
        var organizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = DefaultOrganizationMinimalApprovalThreshold,
                MinimalVoteThreshold = DefaultOrganizationMinimalVoteThresholdThreshold,
                MaximalAbstentionThreshold = DefaultOrganizationMaximalAbstentionThreshold,
                MaximalRejectionThreshold = DefaultOrganizationMaximalRejectionThreshold
            },
            ProposerAuthorityRequired = input.ProposerAuthorityRequired,
            ParliamentMemberProposingAllowed = true
        };
        var defaultOrganizationAddress = CreateNewOrganization(organizationInput);
        State.DefaultOrganizationAddress.Value = defaultOrganizationAddress;
        return new Empty();
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L162-177)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var defaultOrganizationAddress = State.DefaultOrganizationAddress.Value;
        Assert(defaultOrganizationAddress == Context.Sender, "No permission.");
        var organization = State.Organizations[defaultOrganizationAddress];
        Assert(
            input.Proposers.Count > 0 || !organization.ProposerAuthorityRequired ||
            organization.ParliamentMemberProposingAllowed, "White list can't be empty.");
        State.ProposerWhiteList.Value = input;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L22-34)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        // It is a valid proposer if
        // authority check is disable,
        // or sender is in proposer white list,
        // or sender is one of miners when member proposing allowed.
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L409-443)
```csharp
    public override DeployUserSmartContractOutput DeployUserSmartContract(UserContractDeploymentInput input)
    {
        AssertInlineDeployOrUpdateUserContract();
        AssertUserDeployContract();

        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        Context.LogDebug(() => "BasicContractZero - Deployment user contract hash: " + codeHash.ToHex());

        AssertContractNotExists(codeHash);

        if (input.Salt != null)
        {
            AssertContractAddressAvailable(Context.Sender, input.Salt);
        }

        var proposedContractInputHash = CalculateHashFromInput(input);
        SendUserContractProposal(proposedContractInputHash,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.PerformDeployUserSmartContract),
            input.ToByteString());

        // Fire event to trigger BPs checking contract code
        Context.Fire(new CodeCheckRequired
        {
            Code = input.Code,
            ProposedContractInputHash = proposedContractInputHash,
            Category = input.Category,
            IsSystemContract = false,
            IsUserContract = true
        });

        return new DeployUserSmartContractOutput
        {
            CodeHash = codeHash
        };
    }
```

**File:** src/AElf.Blockchains.SideChain/ParliamentContractInitializationDataProvider.cs (L17-27)
```csharp
    public ParliamentContractInitializationData GetContractInitializationData()
    {
        var sideChainInitializationData =
            AsyncHelper.RunSync(_sideChainInitializationDataProvider.GetChainInitializationDataAsync);

        return new ParliamentContractInitializationData
        {
            PrivilegedProposer = sideChainInitializationData.Creator,
            ProposerAuthorityRequired = sideChainInitializationData.ChainCreatorPrivilegePreserved
        };
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L1680-1695)
```csharp
    [Fact(Skip = "The current miner cannot be accurately obtained.")]
    public async Task DeployAndUpdateUserSmartContracts_Success_Test()
    {
        StartSideChain("ELF");
        await AddZeroContractToProposerWhiteListAsync();
        
        // deploy contract
        var userContractDeploymentInput = new UserContractDeploymentInput
        {
            Category = KernelConstants.DefaultRunnerCategory, 
            Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value)
        };

        var deployResult = await SideChainTester.ExecuteContractWithMiningAsync(SideBasicContractZeroAddress,
            nameof(ACS0Container.ACS0Stub.DeployUserSmartContract), userContractDeploymentInput);
        deployResult.Status.ShouldBe(TransactionResultStatus.Mined);
```
