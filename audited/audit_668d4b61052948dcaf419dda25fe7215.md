### Title
Replacement Chain Corruption Enables Pubkey Ownership Hijacking via InitialMiner Collision

### Summary
The `PerformReplacement()` function unconditionally overwrites `State.CandidateReplacementMap[newPubkey]` and `State.InitialPubkeyMap[newPubkey]` without verifying if `newPubkey` already exists in the replacement chain. An attacker controlling initial miner D can replace D with an already-replaced pubkey B (from A→B), stealing admin control from the original owner and corrupting the replacement history.

### Finding Description

The vulnerability exists in the `ReplaceCandidatePubkey` method which validates the replacement but fails to prevent reusing a pubkey that was already a replacement target for a different initial miner. [1](#0-0) 

At line 282, `State.CandidateReplacementMap[newPubkey] = oldPubkey` unconditionally overwrites any existing mapping. At line 289, `State.InitialPubkeyMap[newPubkey] = initialPubkey` also overwrites the previous initial pubkey association.

The only validation that checks if `newPubkey` is already used occurs at line 191, but this only checks the `Candidates` list, not the `InitialMiners` list: [2](#0-1) 

When an initial miner A is replaced with B, B is added to `InitialMiners` but NOT to `Candidates` (since initial miners are separate from announced candidates): [3](#0-2) 

The ban check at line 177-178 also fails to prevent this, as the target pubkey B is not banned (only the original pubkey A was banned): [4](#0-3) 

### Impact Explanation

**Admin Privilege Escalation:** The `GetCandidateAdmin` function resolves admin ownership using `InitialPubkeyMap`: [5](#0-4) 

After the attack (D→B overwrites A→B), `InitialPubkeyMap[B]` changes from A to D, causing `GetCandidateAdmin(B)` to return D's admin instead of A's admin. The attacker gains full administrative control including:

1. **Admin Control Theft**: Attacker can call `SetCandidateAdmin` to permanently change B's admin, or call `ReplaceCandidatePubkey` again to further replace B
2. **Voting/Profit Theft**: If B has accumulated votes, ranking position, or profit shares, the attacker gains control over these assets
3. **State Corruption**: Replacement history is permanently lost as `CandidateReplacementMap[B]` now incorrectly points to D instead of A
4. **Duplicate Entries**: The code at line 224 adds B to `InitialMiners` without checking if B already exists, creating duplicate entries

The `PubkeyList` structure uses protobuf repeated fields, allowing duplicates: [6](#0-5) 

### Likelihood Explanation

**High Likelihood:**

1. **Reachable Entry Point**: `ReplaceCandidatePubkey` is a public method callable by any candidate admin: [7](#0-6) 

2. **Minimal Prerequisites**: Only requires:
   - Two independent initial miners (A and D, common in production)
   - Alice performs legitimate A→B replacement
   - Bob controls initial miner D with standard admin rights

3. **No Special Privileges**: Attacker only needs admin rights to their own initial miner D, which they legitimately possess

4. **Low Cost**: No economic cost beyond normal transaction fees

5. **Practical Feasibility**: The `IsCurrentCandidateOrInitialMiner` check confirms both candidates and initial miners are valid targets: [8](#0-7) 

### Recommendation

**Immediate Fix**: Add validation in `ReplaceCandidatePubkey` before calling `PerformReplacement` to check if `newPubkey` already exists in either `Candidates` or `InitialMiners`:

```csharp
// After line 191, add:
Assert(!State.InitialMiners.Value.Value.Contains(newPubkeyBytes), 
    "New pubkey is already an initial miner.");

// Or check if newPubkey has any replacement history:
Assert(State.CandidateReplacementMap[input.NewPubkey] == null, 
    "New pubkey already exists in replacement chain.");
Assert(State.InitialPubkeyMap[input.NewPubkey] == null, 
    "New pubkey already has initial pubkey mapping.");
```

**Additional Safeguards**:
1. Add duplicate check before adding to `InitialMiners.Value` at line 224
2. Add event emission when replacement history overwrites occur for monitoring
3. Add integration test: attempt D→B after A→B and verify it reverts

### Proof of Concept

**Initial State:**
- Alice controls initial miner A with admin address Alice_Admin
- Bob controls initial miner D with admin address Bob_Admin
- `State.CandidateAdmins[A] = Alice_Admin`
- `State.CandidateAdmins[D] = Bob_Admin`

**Transaction 1 (Legitimate):** Alice calls `ReplaceCandidatePubkey(A, B)`
- Result: `InitialPubkeyMap[B] = A`, `CandidateReplacementMap[B] = A`
- `GetCandidateAdmin(B)` returns `Alice_Admin` ✓

**Transaction 2 (Attack):** Bob calls `ReplaceCandidatePubkey(D, B)`
- Line 175 check: D is initial miner ✓
- Line 177-178 check: D not banned, B not banned ✓
- Line 181 check: Bob is admin of D ✓
- Line 191 check: B NOT in Candidates (only in InitialMiners) ✓
- PerformReplacement executes: Overwrites `InitialPubkeyMap[B] = D`, `CandidateReplacementMap[B] = D`

**Result (Success Condition):**
- `GetCandidateAdmin(B)` now returns `Bob_Admin` (was `Alice_Admin`)
- Bob has stolen administrative control of pubkey B
- Alice can no longer manage pubkey B
- Replacement history A→B is lost, now shows D→B

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L191-191)
```csharp
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L280-292)
```csharp
    private void PerformReplacement(string oldPubkey, string newPubkey)
    {
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;

```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L411-414)
```csharp
    public override Address GetCandidateAdmin(StringValue input)
    {
        return State.CandidateAdmins[State.InitialPubkeyMap[input.Value] ?? input.Value];
    }
```

**File:** protobuf/election_contract.proto (L423-426)
```text
message PubkeyList {
    // Candidates’ public keys
    repeated bytes value = 1;
}
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L75-82)
```csharp
    private bool IsCurrentCandidateOrInitialMiner(string pubkey)
    {
        var isCurrentCandidate = State.CandidateInformationMap[pubkey] != null &&
                                 State.CandidateInformationMap[pubkey].IsCurrentCandidate;
        var isInitialMiner = State.InitialMiners.Value.Value.Contains(
            ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey)));
        return isCurrentCandidate || isInitialMiner;
    }
```
