### Title
Incomplete State Path Declaration for Token Transfer Callbacks Breaks Parallel Execution Safety

### Summary
The `GetResourceInfo` method for `Transfer` operations does not declare state paths for callback contract modifications when tokens have transfer callbacks configured via `ExternalInfo`. This causes the parallel execution engine to incorrectly group conflicting transactions as parallelizable, leading to race conditions and state corruption in callback contracts when multiple transfers execute concurrently.

### Finding Description

**Location**: [1](#0-0) 

**Root Cause**: The AElf token contract supports ERC777-style transfer callbacks through the `ExternalInfo` mechanism. When a token has the `"aelf_transfer_callback"` key configured in its `ExternalInfo`, transfers automatically trigger cross-contract calls via `Context.SendInline` to the specified callback contract: [2](#0-1) 

This callback is invoked during the `Transfer` method execution: [3](#0-2) 

However, the `GetResourceInfo` implementation only declares state paths for:
- Token balances of sender and receiver
- Transaction fees and delegatees
- Token metadata reads

It does **not** include any `WritePaths` or `ReadPaths` for the callback contract's state modifications. The callback contract address is defined in the `CallbackInfo` structure: [4](#0-3) 

**Why Protections Fail**: The ACS2 parallel execution system relies on complete state path declarations to determine transaction conflicts. The `ResourceExtractionService` only calls `GetResourceInfo` on the transaction's target contract (the token contract), not on inline transaction targets: [5](#0-4) 

The ACS2 documentation explicitly states that transactions will be canceled if state paths mismatch: [6](#0-5) 

However, this protection is bypassed because the paths are incomplete from declaration, not from execution mismatch.

**Execution Path**:
1. Token creator sets `TransferCallbackExternalInfoKey` in token's `ExternalInfo`: [7](#0-6) 

2. Two transfers of the same token to different recipients occur in the same block
3. `GetResourceInfo` declares non-overlapping paths (different recipient balances)
4. Parallel execution engine groups them as parallelizable
5. Both transfers execute concurrently, both invoke the same callback contract method
6. Callback contract state reads/writes race, causing lost updates or corruption

### Impact Explanation

**Harm**: State corruption and race conditions in callback contracts. If a callback contract maintains state (e.g., transfer counters, recipient tracking, access control lists), concurrent transfers will cause:
- Lost updates: Both transactions read the same state value, modify it, and write back, with one update overwriting the other
- Inconsistent state: Callback logic that depends on consistent ordering will break
- Logic bypass: Security checks in callbacks may be circumvented

**Affected Parties**: 
- Token contracts with transfer callbacks (legitimate feature per reserved keys list: [8](#0-7) )
- Callback contracts expecting sequential execution
- Users relying on callback contract state integrity

**Severity**: **Critical** - This violates the fundamental safety guarantee of AElf's parallel execution model, causing state inconsistencies without any indication of failure.

### Likelihood Explanation

**Attacker Capabilities**: Any token creator can configure transfer callbacks through `ExternalInfo` - this is a documented feature, not a privilege escalation.

**Attack Complexity**: Low. Steps:
1. Create token with transfer callback pointing to a contract that modifies state
2. Wait for multiple users to transfer the token in the same block
3. Parallel execution automatically triggers the race condition

**Feasibility**: High. Multiple transfers in a single block are common in active token systems. The parallel execution engine will automatically attempt to parallelize them.

**Detection**: Difficult. The transactions appear to succeed; only careful state inspection reveals lost updates. No transaction failure or conflict detection occurs because paths were declared as non-conflicting.

**Probability**: Medium-to-High for tokens that use callbacks, which is a legitimate and documented feature of the token system.

### Recommendation

**Code-Level Mitigation**:

1. **Option A - Mark as non-parallelizable**: In `GetResourceInfo`, detect if a token has callback configuration and return `NonParallelizable = true`:

```csharp
case nameof(Transfer):
{
    var args = TransferInput.Parser.ParseFrom(txn.Params);
    var tokenInfo = GetTokenInfo(args.Symbol);
    
    // Check if token has transfer callback
    if (tokenInfo.ExternalInfo != null && 
        tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
    {
        return new ResourceInfo { NonParallelizable = true };
    }
    
    // ... rest of existing logic
}
```

2. **Option B - Declare callback contract paths** (requires knowing callback contract's state paths, which is impractical):
   Not recommended as it requires the token contract to know implementation details of arbitrary callback contracts.

3. **Option C - Extend ACS2 protocol**: Add support for declaring "inline transaction targets" in `ResourceInfo`, allowing the parallel execution engine to recursively extract paths from inline transaction targets. This is the most complete solution but requires protocol changes.

**Invariant Checks**:
- Add assertion in `DealWithExternalInfoDuringTransfer` that current transaction is marked non-parallelizable if callback exists
- Add test cases verifying that transfers with callbacks cannot be parallelized

**Test Cases**:
1. Create two transactions transferring tokens with callbacks to different recipients
2. Verify they are not grouped as parallelizable
3. Create callback contract that increments a counter on each transfer
4. Execute multiple transfers and verify counter is correct (not missing updates)

### Proof of Concept

**Initial State**:
1. Deploy a callback contract `CallbackCounter` with state variable `uint64 transferCount` and method `OnTransferReceived(TransferFromInput input)` that increments `transferCount`
2. Create token `TEST` with `ExternalInfo[TransferCallbackExternalInfoKey] = {"contract_address": CallbackCounter, "method_name": "OnTransferReceived"}`
3. Mint 1000 TEST to Alice and 1000 TEST to Bob

**Transaction Steps**:
1. Alice sends `Transfer(to: Charlie, symbol: TEST, amount: 100)`
2. Bob sends `Transfer(to: David, symbol: TEST, amount: 100)`
3. Both transactions included in same block

**Expected Result**:
- Transactions should be serialized (not parallelized) due to shared callback contract state
- `CallbackCounter.transferCount` should be exactly 2

**Actual Result**:
- `GetResourceInfo` returns non-overlapping paths (Charlie's balance vs David's balance)
- Transactions grouped as parallelizable
- Both read `transferCount = 0`, both write `transferCount = 1`
- Final `CallbackCounter.transferCount = 1` (lost update)

**Success Condition**: Demonstrating that `transferCount = 1` instead of expected `2` proves the race condition and state corruption.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L15-38)
```csharp
            case nameof(Transfer):
            {
                var args = TransferInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), txn.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol)
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };

                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** protobuf/token_contract.proto (L530-533)
```text
message CallbackInfo {
    aelf.Address contract_address = 1;
    string method_name = 2;
}
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/ResourceExtractionService.cs (L160-163)
```csharp
            var txContext = GetTransactionContext(chainContext, transaction.To, transaction.ToByteString());
            var resourceInfo = await executive.GetTransactionResourceInfoAsync(txContext, transaction.GetHash());
            // Try storing in cache here
            return resourceInfo;
```

**File:** docs-sphinx/reference/acs/acs2.rst (L453-454)
```text
Attention: The transaction will be canceled and labeled to “can not be
groupped” when the StatePath mismatchs the method.
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-13)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L244-247)
```csharp
                TokenContractConstants.LockCallbackExternalInfoKey,
                TokenContractConstants.LogEventExternalInfoKey,
                TokenContractConstants.TransferCallbackExternalInfoKey,
                TokenContractConstants.UnlockCallbackExternalInfoKey
```
