### Title
Commit-Reveal Scheme Bypass Through Selective PreviousInValue Omission Allows Mining Order Manipulation

### Summary
Miners can intentionally omit their `PreviousInValue` during the reveal phase of the AEDPoS commit-reveal scheme without facing validation failure or penalties. This breaks the cryptographic guarantee of the commit-reveal protocol and allows miners to strategically choose between two different signature values after observing other miners' revelations, thereby biasing their mining order in the next round.

### Finding Description

The vulnerability exists in the `ValidatePreviousInValue()` function which unconditionally returns `true` when `PreviousInValue` is null: [1](#0-0) 

The root cause is a deliberate design choice that permits miners to not publish their in values, as evidenced by the comment and conditional check in `ProcessUpdateValue`: [2](#0-1) 

When a miner omits `PreviousInValue` from their off-chain trigger information (controlled via `AEDPoSTriggerInformationProvider`), the system falls back to generating a fake or appointed value: [3](#0-2) 

This fallback value is then used to calculate the miner's signature through XOR operations with other miners' signatures: [4](#0-3) 

The signature directly determines the miner's position in the next round: [5](#0-4) 

The `PreviousInValue` originates from off-chain node software where miners have full control: [6](#0-5) 

**Why Existing Protections Fail:**

1. The validation explicitly allows null values without requiring secret sharing to be enabled
2. The evil miner detection system only penalizes miners who miss time slots entirely (no `OutValue`), not those who produce blocks but omit `PreviousInValue`: [7](#0-6) 

3. Secret sharing, which could force revelation through reconstruction, is optional rather than mandatory: [8](#0-7) 

4. The validation occurs in `UpdateValueValidationProvider` which is the only validator checking `PreviousInValue` for UpdateValue behavior: [9](#0-8) 

### Impact Explanation

**Consensus Integrity Violation:**
- The commit-reveal scheme's fundamental security property is broken: miners can observe other participants' revealed values before deciding whether to reveal their own committed value
- This violates the unpredictability guarantee that random number generation depends upon

**Mining Order Manipulation:**
- A malicious miner M can compute both possible signatures: `signature_real = CalculateSignature(actualInValue)` and `signature_fake = CalculateSignature(fakeValue)`
- Since `supposedOrderOfNextRound = GetAbsModulus(signature.ToInt64(), minersCount) + 1`, M can determine which revelation strategy yields a more favorable position
- Favorable positions may include: earlier slots (higher block rewards due to fee accumulation), specific timing for transaction ordering benefits, or avoiding unfavorable network conditions

**Affected Parties:**
- Honest miners suffer from unfair competition as malicious miners gain systematic positioning advantages
- The network's decentralization guarantee is undermined as strategic miners can accumulate disproportionate rewards
- Users experience degraded fairness in transaction ordering and block production timing

**Severity Justification:**
This is **HIGH** severity because it breaks a core consensus security mechanism (commit-reveal cryptographic protocol) without requiring any special privileges beyond being an active miner, and provides concrete economic advantages through mining order manipulation.

### Likelihood Explanation

**Attacker Capabilities:**
- Any active miner in the consensus set can execute this attack
- No special permissions or compromised keys beyond normal miner credentials required
- Complete control over off-chain node software (specifically `IInValueCache` and trigger information generation)

**Attack Complexity:**
- **Low**: Miner simply clears `IInValueCache` or modifies trigger provider to return null for `PreviousInValue`
- The calculation of which strategy (reveal vs. omit) is favorable requires only basic arithmetic operations on public round data
- No timing attacks, race conditions, or complex state manipulation needed

**Feasibility Conditions:**
- Secret sharing must not be enabled (checked via configuration contract)
- Since secret sharing is optional and the system functions without it, this precondition is realistic in many deployment scenarios
- The miner must be in the active consensus set, which is the normal operational state for miners

**Detection/Operational Constraints:**
- The attack is **undetectable** from on-chain data alone since null `PreviousInValue` is treated as valid
- No events or logs distinguish legitimate non-revelation from strategic omission
- Network monitoring cannot differentiate between cache failures and intentional manipulation
- The attack leaves no penalizable trace (no missed time slots, valid blocks produced)

**Probability Reasoning:**
Given the low technical barrier, undetectability, absence of penalties, and direct economic incentives, rational miners are **highly likely** to exploit this when secret sharing is disabled. The probability increases in competitive mining environments where marginal advantages compound over time.

### Recommendation

**Immediate Mitigations:**

1. **Make Secret Sharing Mandatory:**
   Modify `IsSecretSharingEnabled()` to return `true` unconditionally or fail initialization if the configuration is not set. This forces miners to share encrypted pieces that other miners can reconstruct.

2. **Enforce PreviousInValue Revelation:**
   Modify the validation to reject null `PreviousInValue` when the miner was present in the previous round:

   ```csharp
   private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
   {
       var extraData = validationContext.ExtraData;
       var publicKey = validationContext.SenderPubkey;
       
       if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
           return true;
       
       var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
       
       // REJECT null PreviousInValue if miner was in previous round
       if (previousInValue == null || previousInValue == Hash.Empty)
           return false;
       
       var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
       return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
   }
   ```

3. **Add Penalty Mechanism:**
   Track non-revelation in a separate counter (similar to `MissedTimeSlots`) and penalize miners who repeatedly produce blocks without revealing `PreviousInValue`.

**Invariant to Enforce:**
- **IF** miner M produced a block with `OutValue` in round N **AND** M is producing a block in round N+1 **THEN** M must provide `PreviousInValue` such that `Hash(PreviousInValue) == OutValue_from_round_N` **OR** secret sharing must successfully reconstruct M's InValue.

**Test Cases:**

1. Test that `ValidatePreviousInValue` rejects null `PreviousInValue` when miner was in previous round
2. Test that miners who repeatedly omit `PreviousInValue` accumulate penalties
3. Test that secret sharing successfully prevents mining when InValue reconstruction is possible but miner omits revelation
4. Test that the penalty threshold triggers evil miner detection for non-revelation
5. Regression test: verify first-time miners (not in previous round) can still produce blocks without `PreviousInValue`

### Proof of Concept

**Required Initial State:**
- Active consensus network with at least 3 miners (M1, M2, M3)
- Secret sharing is **disabled** via configuration (`SecretSharingEnabledConfigurationKey = false`)
- Round N has completed with all miners producing blocks and `OutValue` set

**Attack Execution:**

**Step 1 (Round N - Commit Phase):**
- Malicious miner M1 produces block at height H with:
  - `InValue_M1 = Hash("secret_random_value")`
  - `OutValue_M1 = Hash(InValue_M1)` = `0xABC...DEF`
- M1's `OutValue_M1` is recorded in Round N state

**Step 2 (Round N+1 - Reveal Phase Begins):**
- Honest miner M2 produces block and reveals: `PreviousInValue_M2 = InValue_M2`
- Honest miner M3 produces block and reveals: `PreviousInValue_M3 = InValue_M3`
- M1 observes the current round state including M2 and M3's revealed values

**Step 3 (M1's Strategic Decision):**
- M1 calculates off-chain:
  - `signature_if_reveal = CalculateSignature(InValue_M1)` using actual InValue
  - `signature_if_omit = CalculateSignature(Hash(pubkey_M1 + currentHeight))` using fake value
  - `order_if_reveal = GetAbsModulus(signature_if_reveal.ToInt64(), 3) + 1`
  - `order_if_omit = GetAbsModulus(signature_if_omit.ToInt64(), 3) + 1`
- M1 determines `order_if_omit` yields position 1 (earliest slot), while `order_if_reveal` yields position 3
- M1 chooses to omit `PreviousInValue`

**Step 4 (M1's Block Production):**
- M1 modifies off-chain trigger provider to return null for `PreviousInValue`:
  ```csharp
  // In attacker's modified AEDPoSTriggerInformationProvider
  PreviousInValue = null  // or simply don't cache the value
  ```
- M1 produces block with `UpdateValueInput` where `PreviousInValue = Hash.Empty`

**Step 5 (Validation Passes):**
- `ValidatePreviousInValue()` is called
- Line 42 executes: `if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;`
- Validation succeeds despite broken commit-reveal

**Step 6 (Fake Value Used):**
- `GetConsensusExtraDataToPublishOutValue()` generates `fakePreviousInValue = Hash(pubkey_M1 + currentHeight)`
- Signature is calculated using fake value instead of committed `InValue_M1`
- M1's next round order is set to 1 (favorable position)

**Expected vs Actual Result:**
- **Expected (Secure)**: M1 must reveal `InValue_M1` matching `Hash(InValue_M1) == OutValue_M1`, or face validation failure
- **Actual (Vulnerable)**: M1 successfully produces block without revealing, uses fake value for signature, gains favorable mining position

**Success Condition:**
- M1's block is accepted into the blockchain
- M1's `PreviousInValue` remains null or `Hash.Empty` in the round state
- M1's next round order (position 1) differs from what would result if they had revealed the actual `InValue_M1`
- No penalty or evil miner marking occurs for M1

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L42-42)
```csharp
        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L94-108)
```csharp
            else
            {
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L92-102)
```csharp
        if (hint.Behaviour == AElfConsensusBehaviour.UpdateValue)
        {
            var inValue = _inValueCache.GetInValue(hint.RoundId);
            var trigger = new AElfConsensusTriggerInformation
            {
                Pubkey = Pubkey,
                InValue = inValue,
                PreviousInValue = _inValueCache.GetInValue(hint.PreviousRoundId),
                Behaviour = hint.Behaviour,
                RandomNumber = ByteString.CopyFrom(randomProof)
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L175-176)
```csharp
        var notMinedMiners = currentRound.RealTimeMinersInformation.Values.Where(m => m.OutValue == null).ToList();
        if (!notMinedMiners.Any()) return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```
