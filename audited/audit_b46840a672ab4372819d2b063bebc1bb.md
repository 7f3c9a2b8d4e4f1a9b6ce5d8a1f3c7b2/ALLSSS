### Title
Critical Off-By-One Error in Bancor Exponential Calculation Causes Incorrect Token Conversion Pricing

### Summary
The `Fact` array in `BancorHelper.cs` is initialized with factorials 0! through 19! but is accessed as if it contains 1! through 20!, causing all exponential calculations (except the first term) to use incorrect factorial values. [1](#0-0)  This results in systematically wrong token conversion prices for all swaps where connector weights differ.

### Finding Description

The `DynFact` function itself correctly computes factorials. [2](#0-1)  For `number = 1`, the ternary operator returns 1, and the loop doesn't execute, correctly producing 1! = 1.

However, the critical bug is in the static constructor initialization: [1](#0-0) 

This creates:
- Fact[0] = DynFact(0) = 0! = 1
- Fact[1] = DynFact(1) = 1! = 1  
- Fact[2] = DynFact(2) = 2! = 2
- ...
- Fact[19] = DynFact(19) = 19! = 121645100408832000

But the `Exp` function accesses it as: [3](#0-2) 

The exponential series requires: exp(y) = 1 + y^1/1! + y^2/2! + y^3/3! + ... + y^20/20!

When `iteration = n`, it computes y^n / Fact[n-1], expecting Fact[n-1] = n!. But actually Fact[n-1] = (n-1)!

This causes:
- iteration 1: uses Fact[0] = 0! = 1 (needs 1! = 1) ✓ correct by luck
- iteration 2: uses Fact[1] = 1! = 1 (needs 2! = 2) ✗ wrong by factor of 2
- iteration 3: uses Fact[2] = 2! = 2 (needs 3! = 6) ✗ wrong by factor of 3
- iteration 20: uses Fact[19] = 19! (needs 20! = 2,432,902,008,176,640,000) ✗ wrong by factor of 20

The test version correctly hardcodes Fact[i] = (i+1)!: [4](#0-3) 

### Impact Explanation

This bug affects all token conversions when connector weights differ, causing drastically incorrect pricing: [5](#0-4) [6](#0-5) 

For example, computing exp(0.1):
- Contract version: 1 + 0.1 + 0.01 + 0.001/2 + 0.0001/6 + ... ≈ 1.1105
- Correct value: 1 + 0.1 + 0.01/2 + 0.001/6 + 0.0001/24 + ... ≈ 1.10517

The error compounds for larger exponent values, causing:
- Users receive incorrect token amounts (over/under-payment depending on direction)
- Arbitrageurs can exploit the mispricing for profit extraction
- Reserve ratios become imbalanced over time
- Protocol loses credibility and funds

**Severity: CRITICAL** - All token conversions with non-equal weights produce wrong results, affecting core protocol functionality.

### Likelihood Explanation

**Likelihood: CERTAIN** - This bug triggers on every token conversion where `fromConnectorWeight != toConnectorWeight`.

Entry points are public methods:
- `Buy` and `Sell` operations call `GetAmountToPayFromReturn` and `GetReturnFromPaid`
- No special permissions required
- Affects all users performing conversions
- No external conditions needed

The bug is deterministic and always active since the static constructor runs once at contract deployment.

### Recommendation

**Fix:** Change line 13 to initialize with factorials 1! through 20!:
```csharp
Fact = Array.AsReadOnly(Enumerable.Range(1, 20).Select(x => DynFact(x)).ToArray());
```

**Add validation:** Include compile-time or deployment-time verification that:
- Fact[0] equals 1 (which is 1!)
- Fact[1] equals 2 (which is 2!)  
- Fact[19] equals 2432902008176640000 (which is 20!)

**Add regression tests:** Create unit tests comparing DynFact-based results with hardcoded expected factorial values and validate `Exp` function output against known exponential values.

### Proof of Concept

**Initial State:** Deploy TokenConverter contract with two connectors having different weights (e.g., 0.5 and 0.6).

**Transaction Steps:**
1. User calls `Buy` or `Sell` with any amount where weights differ
2. Contract invokes `GetReturnFromPaid` or `GetAmountToPayFromReturn`
3. These call `Exp(y * Ln(x))` with y = weight ratio
4. `Exp` function uses wrong factorials from Fact array

**Expected Result:** exp(y) computed using 1!, 2!, 3!, ..., 20!

**Actual Result:** exp(y) computed using 0!, 1!, 2!, ..., 19!, causing all terms (except first) to be wrong

**Success Condition:** Compare actual conversion amount with mathematically correct Bancor formula - they differ significantly for any conversion where connector weights are unequal.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L13-13)
```csharp
        Fact = Array.AsReadOnly(Enumerable.Range(0, 20).Select(x => DynFact(x)).ToArray());
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L16-21)
```csharp
    private static long DynFact(long number)
    {
        var fact = number == 0 ? 1 : number;
        for (var i = number - 1; i >= 1; i--) fact *= i;
        return fact;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L47-53)
```csharp
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L159-159)
```csharp
            var fatorial = Fact[iteration - 1];
```

**File:** test/AElf.Contracts.TokenConverter.Tests/BancorHelper.cs (L78-102)
```csharp
    private static readonly long[] Fact =
    {
        1L,
        1L * 2,
        1L * 2 * 3,
        1L * 2 * 3 * 4,
        1L * 2 * 3 * 4 * 5,
        1L * 2 * 3 * 4 * 5 * 6,
        1L * 2 * 3 * 4 * 5 * 6 * 7,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19,
        1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20
        //14197454024290336768L, //1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20 * 21,        // NOTE: Overflow during compilation
        //17196083355034583040L, //1L * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17 * 18 * 19 * 20 * 21 * 22    // NOTE: Overflow during compilation
    };
```
