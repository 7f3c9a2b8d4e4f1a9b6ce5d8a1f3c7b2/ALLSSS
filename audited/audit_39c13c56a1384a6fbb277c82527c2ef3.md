### Title
Code Check Proposals Can Be Executed Instantly Without Mandatory Review Period

### Summary
The contract deployment governance system lacks a minimum time delay between code check proposal creation and execution. Despite firing a `CodeCheckRequired` event to trigger code review, proposals can be approved and released immediately after creation if the approval threshold is met, completely bypassing the intended code review process. This allows potentially malicious contracts to be deployed within seconds without any enforced review period.

### Finding Description

**Root Cause Location:**

The Parliament contract's `Release` method only validates that the approval threshold is reached and the proposal has not expired, with no minimum time requirement between proposal creation and release: [1](#0-0) 

The expiration check only ensures the proposal hasn't exceeded its maximum validity window, not that sufficient time has passed for review: [2](#0-1) 

**Vulnerable Flow:**

When `BasicContractZero` interacts with Parliament through the `ParliamentContract` reference for code check proposals: [3](#0-2) 

The code check proposal process begins when `ProposeContractCodeCheck` is called (after deployment proposal approval): [4](#0-3) 

The system fires a `CodeCheckRequired` event expecting code review (line 266-272), and sets an expiration time with a default of only 15 minutes: [5](#0-4) [6](#0-5) 

However, the automatic approval system can immediately generate approval transactions: [7](#0-6) 

Once the threshold is reached, `ReleaseCodeCheckedContract` can be called immediately by the proposer: [8](#0-7) 

This triggers the Parliament `Release` which executes the contract deployment without any enforced delay: [9](#0-8) 

**Why Existing Protections Fail:**

1. The expiration time is a maximum validity window, not a minimum review period
2. No time-based validation exists between proposal creation and release
3. The approval threshold can be met instantly if miners control majority
4. System transaction automation enables same-block or immediate-block approvals

### Impact Explanation

**Direct Governance Impact:**
A compromised or colluding miner majority can deploy malicious contracts without any enforced code review period, completely bypassing the two-stage governance security model.

**Concrete Harm:**
- Malicious contracts could steal funds from users or the Treasury
- Compromised contracts could manipulate consensus, token economics, or cross-chain verification
- Backdoors or vulnerabilities could be deployed that affect all users
- The entire security assumption of "code review before deployment" is violated

**Affected Parties:**
- All chain users whose funds could be stolen by malicious contracts
- Ecosystem integrity compromised by backdoored system contracts
- Governance process credibility undermined

**Severity Justification:**
HIGH - The system explicitly expects code review (fires `CodeCheckRequired` event) but provides no technical enforcement. This is a critical gap between design intent and implementation that could enable catastrophic attacks.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Control or compromise of miner majority (>66.67% for default threshold)
- Ability to submit contract deployment proposals
- Coordination to execute approval and release in rapid succession

**Attack Complexity:**
Once miner majority control is achieved, the attack is trivial:
1. Submit contract deployment proposal (standard governance path)
2. Wait for first-stage approval
3. Create code check proposal (automatic via `ReleaseApprovedContract`)
4. System automatically generates approval transactions
5. Immediately call `ReleaseCodeCheckedContract`
6. Malicious contract deployed in seconds

**Feasibility Assessment:**
- **Entry Point:** Reachable via standard `ProposeNewContract` / `ProposeUpdateContract` methods
- **Preconditions:** Miner majority control is a significant barrier but not impossible (compromise, collusion, or insider threat)
- **Execution:** Trivially executable once preconditions met - no technical barriers
- **Detection:** Attack could complete before detection, especially during off-peak monitoring

**Probability Reasoning:**
MEDIUM-HIGH likelihood because:
- The automatic approval system (`ProposalApprovalTransactionGenerator`) makes instant approvals practical
- No monitoring can stop an attack that completes within one block
- The short 15-minute window suggests the system expects quick turnaround, making rapid approval seem normal
- Historical blockchain incidents show miner collusion is a realistic threat model

### Recommendation

**Implement Minimum Proposal Duration:**

Add a minimum time delay requirement in the Parliament contract's `Release` method:

```
Minimum Changes Required:
1. Add ProposalCreatedTime field to ProposalInfo in ParliamentState.cs
2. Store creation time in CreateNewProposal in Parliament_Helper.cs
3. Add MinimumProposalDuration constant to Parliament_Constants.cs
4. Validate minimum duration in Release method before allowing execution
```

**Specific Code Changes:**

In `Parliament_Helper.cs`, modify the `Validate` method to check minimum duration:

```csharp
private bool Validate(ProposalInfo proposal)
{
    var validDestinationAddress = proposal.ToAddress != null;
    var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
    var validExpiredTime = CheckProposalNotExpired(proposal);
    var hasOrganizationAddress = proposal.OrganizationAddress != null;
    var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
    var validMinimumDuration = CheckMinimumDurationPassed(proposal); // ADD THIS
    return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
           hasOrganizationAddress && validDescriptionUrl && validMinimumDuration; // ADD validMinimumDuration
}

private bool CheckMinimumDurationPassed(ProposalInfo proposal)
{
    var minimumDuration = TimeSpan.FromHours(24); // Or configurable per organization
    return Context.CurrentBlockTime >= proposal.CreatedTime.AddSeconds((long)minimumDuration.TotalSeconds);
}
```

**For Code Check Proposals Specifically:**

Increase the default expiration time and add minimum duration:
- Change `DefaultCodeCheckProposalExpirationTimePeriod` from 900 seconds (15 minutes) to at least 86400 seconds (24 hours)
- Add `MinimumCodeCheckReviewPeriod` constant of at least 21600 seconds (6 hours)

**Additional Invariant Checks:**
- Assert minimum review period has passed before allowing `ReleaseCodeCheckedContract`
- Emit events when proposals become eligible for release (after minimum duration)
- Add emergency pause mechanism for suspicious rapid approvals

**Test Cases to Add:**
1. Test that proposals cannot be released before minimum duration
2. Test that proposals can be released after minimum duration + threshold met
3. Test that expired proposals cannot be released even if duration passed
4. Test rapid approval detection and prevention

### Proof of Concept

**Initial State:**
- Parliament governance system initialized with default organization
- Miners control majority (66.67%+ of voting power)
- Attacker has proposer privileges

**Attack Sequence:**

**Block N:**
1. Attacker calls `ProposeNewContract` with malicious contract code
2. Creates deployment proposal with 72-hour expiration
3. Proposal ID returned: `proposal_1`

**Block N+1 to N+k (until threshold reached):**
4. Miners approve `proposal_1` via `ApproveMultiProposals` (automatic system transactions)
5. Approval threshold reached

**Block N+k+1:**
6. Attacker calls `ReleaseApprovedContract(proposal_1, contractInputHash)`
7. This creates code check proposal automatically with 15-minute expiration
8. `CodeCheckRequired` event fired
9. Code check proposal ID returned: `proposal_2`

**Block N+k+2 (potentially same block as step 6):**
10. `ProposalApprovalTransactionGenerator` automatically generates approvals for `proposal_2`
11. Miners approve `proposal_2` - threshold reached **immediately**

**Block N+k+3 (potentially within seconds):**
12. Attacker calls `ReleaseCodeCheckedContract(proposal_2, contractInputHash)`
13. Parliament `Release` executes immediately (no minimum duration check)
14. Malicious contract deployed via `DeploySmartContract`

**Expected Result (Current Vulnerable Behavior):**
Malicious contract deployed in 3-4 blocks (~12-16 seconds) with zero meaningful code review time.

**Expected Result (After Fix):**
`Release` call in step 12 fails with "Minimum review period not passed" assertion, requiring at least 6-24 hours between proposal creation and execution.

**Success Condition:**
Attack succeeds if malicious contract address appears in `State.ContractInfos` within 30 seconds of code check proposal creation, proving no enforced review period exists.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L177-180)
```csharp
    private bool CheckProposalNotExpired(ProposalInfo proposal)
    {
        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroReferenceState.cs (L9-9)
```csharp
    internal ParliamentContractContainer.ParliamentContractReferenceState ParliamentContract { get; set; }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L234-275)
```csharp
    public override Hash ProposeContractCodeCheck(ContractCodeCheckInput input)
    {
        RequireSenderAuthority(State.ContractDeploymentController.Value.OwnerAddress);
        AssertCodeCheckProposingInput(input);
        var proposedContractInputHash = input.ProposedContractInputHash;
        var proposedInfo = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(proposedInfo != null && proposedInfo.Status == ContractProposingInputStatus.Approved,
            "Invalid contract proposing status.");
        proposedInfo.Status = ContractProposingInputStatus.CodeCheckProposed;
        State.ContractProposingInputMap[proposedContractInputHash] = proposedInfo;

        var codeCheckController = State.CodeCheckController.Value;
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName = input.CodeCheckReleaseMethod,
                Params = input.ContractInput,
                OrganizationAddress = codeCheckController.OwnerAddress,
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod())
            },
            OriginProposer = proposedInfo.Proposer
        };

        proposedInfo.ExpiredTime = proposalCreationInput.ProposalInput.ExpiredTime;
        State.ContractProposingInputMap[proposedContractInputHash] = proposedInfo;
        Context.SendInline(codeCheckController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput);

        // Fire event to trigger BPs checking contract code
        Context.Fire(new CodeCheckRequired
        {
            Code = ExtractCodeFromContractCodeCheckInput(input),
            ProposedContractInputHash = proposedContractInputHash,
            Category = input.Category,
            IsSystemContract = input.IsSystemContract
        });

        return proposedContractInputHash;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L292-306)
```csharp
    public override Empty ReleaseCodeCheckedContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];

        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.CodeCheckProposed &&
            contractProposingInput.Proposer == Context.Sender, "Invalid contract proposing status.");
        contractProposingInput.Status = ContractProposingInputStatus.CodeChecked;
        State.ContractProposingInputMap[input.ProposedContractInputHash] = contractProposingInput;
        var codeCheckController = State.CodeCheckController.Value;
        Context.SendInline(codeCheckController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release), input.ProposalId);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L309-322)
```csharp
    public override Address DeploySmartContract(ContractDeploymentInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        // AssertDeploymentProposerAuthority(Context.Origin);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address =
            DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
                DecideNonSystemContractAuthor(contractProposingInput?.Proposer, Context.Sender), false,
                input.ContractOperation?.Deployer, input.ContractOperation?.Salt);
        return address;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L6-6)
```csharp
    public const int DefaultCodeCheckProposalExpirationTimePeriod = 900; // 60 * 15
```

**File:** src/AElf.Kernel.Proposal/Application/ProposalApprovalTransactionGenerator.cs (L14-71)
```csharp
public class ProposalApprovalTransactionGenerator : ISystemTransactionGenerator
{
    private readonly IProposalService _proposalService;
    private readonly ISmartContractAddressService _smartContractAddressService;
    private readonly ITransactionPackingOptionProvider _transactionPackingOptionProvider;

    public ProposalApprovalTransactionGenerator(IProposalService proposalService,
        ISmartContractAddressService smartContractAddressService,
        ITransactionPackingOptionProvider transactionPackingOptionProvider)
    {
        _proposalService = proposalService;
        _smartContractAddressService = smartContractAddressService;
        _transactionPackingOptionProvider = transactionPackingOptionProvider;

        Logger = NullLogger<ProposalApprovalTransactionGenerator>.Instance;
    }

    public ILogger<ProposalApprovalTransactionGenerator> Logger { get; set; }

    public async Task<List<Transaction>> GenerateTransactionsAsync(Address from, long preBlockHeight,
        Hash preBlockHash)
    {
        var generatedTransactions = new List<Transaction>();
        var chainContext = new ChainContext
        {
            BlockHash = preBlockHash, BlockHeight = preBlockHeight
        };
        if (!_transactionPackingOptionProvider.IsTransactionPackable(chainContext))
            return generatedTransactions;

        var parliamentContractAddress = await _smartContractAddressService.GetAddressByContractNameAsync(
            chainContext, ParliamentSmartContractAddressNameProvider.StringName);

        if (parliamentContractAddress == null) return generatedTransactions;

        var proposalIdList =
            await _proposalService.GetNotApprovedProposalIdListAsync(from, preBlockHash, preBlockHeight);
        if (proposalIdList == null || proposalIdList.Count == 0)
            return generatedTransactions;

        var generatedTransaction = new Transaction
        {
            From = from,
            MethodName = nameof(ParliamentContractContainer.ParliamentContractStub.ApproveMultiProposals),
            To = parliamentContractAddress,
            RefBlockNumber = preBlockHeight,
            RefBlockPrefix = BlockHelper.GetRefBlockPrefix(preBlockHash),
            Params = new ProposalIdList
            {
                ProposalIds = { proposalIdList }
            }.ToByteString()
        };
        generatedTransactions.Add(generatedTransaction);

        Logger.LogTrace("Proposal approval transaction generated.");

        return generatedTransactions;
    }
```
