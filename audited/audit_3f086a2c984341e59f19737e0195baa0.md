# Audit Report

## Title
Association Contract Threshold Validation Allows Governance Deadlock

## Summary
The `Validate(Organization)` function in the Association contract contains insufficient threshold validation that allows creation of organizations where proposals can enter permanent deadlock states. The validation checks two separate sum constraints but fails to verify that `MaximalRejectionThreshold + MaximalAbstentionThreshold + MinimalApprovalThreshold` does not exceed the organization member count plus one, enabling proposals that can neither be approved, rejected, nor abstained even after all members vote.

## Finding Description

The root cause lies in the threshold validation logic which performs two independent checks without ensuring the combined constraint is satisfied: [1](#0-0) 

These constraints check:
1. `MaximalAbstentionThreshold + MinimalApprovalThreshold <= organizationMemberCount`
2. `MaximalRejectionThreshold + MinimalApprovalThreshold <= organizationMemberCount`

However, the proposal release logic uses asymmetric inequality operators that create a deadlock vulnerability: [2](#0-1) 

The release determination uses:
- **Rejected** if rejections > MaximalRejectionThreshold (strict inequality)
- **Abstained** if abstentions > MaximalAbstentionThreshold (strict inequality)  
- **Approved** if approvals >= MinimalApprovalThreshold (non-strict inequality)

Due to the strict inequalities for rejection/abstention versus non-strict for approval, a deadlock occurs when all N members vote with the distribution:
- Approvals = MinimalApprovalThreshold - 1
- Rejections = MaximalRejectionThreshold
- Abstentions = MaximalAbstentionThreshold
- Sum = N (all members voted)

This satisfies the current validation when `MaximalRejectionThreshold + MaximalAbstentionThreshold + MinimalApprovalThreshold = N + 1`.

**Concrete Example:**
- N = 10 members
- MinimalApprovalThreshold = 6
- MaximalRejectionThreshold = 2  
- MaximalAbstentionThreshold = 3

Validation passes (3+6=9≤10, 2+6=8≤10), but sum is 11 = N+1.

When all 10 members vote (5 approvals, 2 rejections, 3 abstentions):
- Not rejected: 2 > 2? NO
- Not abstained: 3 > 3? NO
- Not approved: 5 >= 6? NO
- **Result: DEADLOCK**

## Impact Explanation

**HIGH Severity - Governance DoS**

Organizations with deadlock-prone threshold configurations experience critical governance failure:

1. **Governance Paralysis**: Proposals requiring urgent action cannot be executed or rejected, leaving the organization unable to respond to time-sensitive situations.

2. **Resource Lock**: Proposals remain permanently stuck as the `Release` method will fail the threshold check: [3](#0-2) 

3. **No Recovery Path**: The `ChangeOrganizationThreshold` method requires execution through a proposal: [4](#0-3) 
   
   If a threshold-change proposal deadlocks, the organization cannot fix its own broken configuration.

4. **Limited Mitigation**: Only recovery is waiting for proposal expiration via `ClearProposal`: [5](#0-4) 

This violates the governance invariant that organization thresholds must ensure deterministic proposal outcomes when members vote.

## Likelihood Explanation

**HIGH Likelihood - Easily Exploitable**

The vulnerability has high exploitability:

1. **Public Entry Point**: Any user can create an Association organization through the unrestricted `CreateOrganization` method: [6](#0-5) 

2. **No Economic Barrier**: Organization creation requires no staking, approval, or special privileges.

3. **Simple Attack Vector**: Calculate threshold values satisfying `MaximalRejectionThreshold + MaximalAbstentionThreshold + MinimalApprovalThreshold = organizationMemberCount + 1` that pass the current validation.

4. **Accidental Creation**: Legitimate organizations attempting balanced thresholds (e.g., 60% approval requirement, 20% rejection tolerance, 30% abstention tolerance) can inadvertently create deadlock configurations.

5. **Delayed Detection**: Validation passes during creation; deadlock only manifests during voting, making it difficult to detect beforehand.

## Recommendation

Add a combined threshold validation constraint to prevent deadlock configurations. The fix should ensure that it's always possible to reach a deterministic outcome:

```csharp
private bool Validate(Organization organization)
{
    // ... existing checks ...
    
    return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
           proposalReleaseThreshold.MaximalRejectionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
           // Add this constraint to prevent deadlock:
           proposalReleaseThreshold.MaximalRejectionThreshold +
           proposalReleaseThreshold.MaximalAbstentionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
}
```

This ensures that when all members vote, at least one of the three outcomes (approved/rejected/abstained) must be satisfied.

## Proof of Concept

```csharp
[Fact]
public async Task Governance_Deadlock_Vulnerability_Test()
{
    // Create organization with deadlock-prone thresholds
    // N=3 members, thresholds sum to 4 (N+1)
    var minimalApprovalThreshold = 2;      // Need >= 2 approvals
    var maximalRejectionThreshold = 1;      // Rejected if > 1 rejections
    var maximalAbstentionThreshold = 1;     // Abstained if > 1 abstentions
    var minimalVoteThreshold = 3;
    
    // These thresholds pass current validation:
    // 1 + 2 = 3 <= 3 ✓
    // 1 + 2 = 3 <= 3 ✓
    // But sum = 1 + 1 + 2 = 4 = N + 1 (deadlock condition)
    
    var organizationAddress = await CreateOrganizationAsync(
        minimalApprovalThreshold, 
        minimalVoteThreshold,
        maximalAbstentionThreshold, 
        maximalRejectionThreshold, 
        Reviewer1);
    
    // Create a proposal
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // All 3 members vote with deadlock distribution:
    // 1 approval (< 2 needed), 1 rejection (= 1 max), 1 abstention (= 1 max)
    await ApproveAsync(Reviewer1KeyPair, proposalId);
    await RejectAsync(Reviewer2KeyPair, proposalId);
    await AbstainAsync(Reviewer3KeyPair, proposalId);
    
    // Verify proposal cannot be released (deadlock state)
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBe(false); // Stuck in deadlock
    
    // Attempt to release should fail
    var reviewer1Stub = GetAssociationContractTester(Reviewer1KeyPair);
    var releaseResult = await reviewer1Stub.Release.SendWithExceptionAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
    
    // Proposal is stuck: not approved, not rejected, not abstained
    // Only recovery is waiting for expiration
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-51)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }

    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L77-80)
```csharp
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-83)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-188)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-209)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```
