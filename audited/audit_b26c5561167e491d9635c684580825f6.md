### Title
Arithmetic Overflow in Bancor Formula Exp/Pow Integration Causes DoS of Token Swap Operations

### Summary
The `Exp` function in BancorHelper.cs calls `Pow(y, iteration)` with iteration values up to 20, but fails to validate that the exponential result will fit within C# decimal bounds. When connector weight ratios are high (e.g., 100:1 as configured in production), the calculation of `y^20` overflows, throwing an `OverflowException` and causing denial of service for Buy and Sell token swap operations.

### Finding Description

The root cause is in the `Exp` function [1](#0-0)  which implements the exponential series `exp(y) = 1 + y + y^2/2! + y^3/3! + ... + y^20/20!`. At line 160, it calls `Pow(y, (uint)iteration)` where iteration ranges from 1 to 20.

The `Pow` function [2](#0-1)  uses binary exponentiation with repeated squaring operations (`A *= A` at line 115). When the base value `y` is large, computing `y^20` exceeds the C# decimal maximum value of approximately 7.92 × 10^28.

The value passed to `Exp` comes from the Bancor formula calculations:
- In `GetReturnFromPaid` (Sell operation) [3](#0-2) : `y * Ln(x)` where `y = wf / wt` (weight ratio)
- In `GetAmountToPayFromReturn` (Buy operation) [4](#0-3) : `y * Ln(x)` where `y = wt / wf` (inverted weight ratio)

While connector weights are validated to be between 0 and 1 [5](#0-4) , their **ratio** can be arbitrarily large. For example, production configurations use weight 0.5 for native tokens and 0.005 for resource tokens [6](#0-5) , creating a weight ratio of 100:1.

**Mathematical Analysis:**
- Decimal overflow threshold for `y^20`: y ≤ (7.92 × 10^28)^(1/20) ≈ 26.53
- With weight ratio 100 and Ln(x) ≈ -0.693 (when x = 0.5): product = 100 × (-0.693) = -69.3
- Computing Pow(-69.3, 20) requires 69.3^20 ≈ 1.3 × 10^37, which exceeds decimal.MaxValue
- Even more extreme valid weights (0.99:0.01 or 0.999:0.001) produce ratios of 99 or 999, making overflow trivial

The `Ln` function validates only that its input is between 0 and 2 [7](#0-6) , but provides no bounds on the **output** magnitude when multiplied by weight ratios.

### Impact Explanation

**Operational Impact - Critical DoS:**
When users attempt to swap tokens via `Buy` [8](#0-7)  or `Sell` [9](#0-8)  operations with configurations that produce high weight ratios, the contract will throw an `OverflowException` during the Bancor formula calculation, reverting the entire transaction.

This affects:
1. **All token swaps** between connector pairs with high weight ratios (e.g., native-to-resource swaps in production)
2. **User funds**: Swaps fail, preventing legitimate trading and liquidity provision
3. **Protocol functionality**: TokenConverter becomes unusable for affected pairs until connector weights are reconfigured
4. **Economic operations**: Treasury and other system contracts that rely on token conversion will also fail

The impact is especially severe because:
- Production weights (0.5 and 0.005) already create a vulnerable 100:1 ratio
- Any swap where the balance ratio drives Ln(x) to sufficiently negative values will trigger overflow
- The overflow occurs in core pricing logic, affecting the entire connector pair

**Severity: HIGH** - Complete denial of service for token conversion operations, which are critical to the protocol's economic functionality.

### Likelihood Explanation

**Likelihood: HIGH** - The vulnerability is triggered during normal protocol operation without requiring attacker-specific actions.

**Reachable Entry Points:**
- Public `Buy` and `Sell` methods are accessible to any user
- No special permissions required beyond standard token swap requirements

**Feasible Preconditions:**
1. Connector weights configured with ratios ≥ 100:1 (already true in production with 0.5 and 0.005 weights)
2. User attempts a swap with amounts that produce balance ratios where Ln(x) magnitude, when multiplied by weight ratio, exceeds ~26.53
3. For the production 100:1 ratio: any swap where `x = bf/(bf+a)` is approximately 0.5 or less will trigger overflow (Ln(0.5) ≈ -0.693, product = -69.3)

**Execution Practicality:**
- No special exploit needed - normal swap operations trigger the bug
- The more tokens a user tries to swap at once, the more likely overflow occurs (as it drives x toward 0)
- Happens automatically when balance ratios and swap amounts create the vulnerable mathematical conditions

**Economic Rationality:**
- No cost to trigger beyond normal swap transaction fees
- Users attempting large swaps will consistently hit this issue
- Affects legitimate use cases, not just attack scenarios

**Detection:** The overflow will be immediately visible as transaction reverts with `OverflowException`, making it trivial to reproduce.

### Recommendation

**Immediate Mitigation:**
Add bounds checking before calling `Exp` to ensure the input value will not cause overflow:

```csharp
private static decimal Exp(decimal y)
{
    // Prevent overflow: y^20 must fit in decimal range
    // Maximum safe value: (decimal.MaxValue)^(1/20) ≈ 26.53
    const decimal MAX_SAFE_EXP_INPUT = 26m;
    const decimal MIN_SAFE_EXP_INPUT = -26m;
    
    if (y > MAX_SAFE_EXP_INPUT || y < MIN_SAFE_EXP_INPUT)
        throw new InvalidValueException($"Exponential input {y} exceeds safe calculation bounds");
    
    // ... existing implementation
}
```

**Long-term Solutions:**
1. **Weight Ratio Limits**: Add validation in `AssertValidConnectorWeight` to ensure weight ratios between any pair remain below safe thresholds (e.g., max 20:1 ratio)
2. **Alternative Algorithm**: Consider using a more numerically stable exponential approximation that doesn't require computing such high powers
3. **Checked Arithmetic**: Wrap critical arithmetic operations in try-catch blocks to provide better error messages instead of raw overflow exceptions

**Test Cases:**
1. Test connector pairs with weights 0.5 and 0.005 (production configuration)
2. Test swaps with amounts that drive balance ratios to 0.5 or lower
3. Test extreme valid weights (0.99 and 0.01) to verify bounds
4. Add integration tests that specifically check for overflow conditions in Bancor calculations

### Proof of Concept

**Initial State:**
- Configure connector pair with production weights: fromWeight = 0.5, toWeight = 0.005 (ratio 100:1)
- Set connector balances: fromBalance = 1,000,000, toBalance = 1,000,000

**Exploitation Steps:**

1. User calls `Sell` operation with `input.Amount = 500,000`

2. Contract executes `GetReturnFromPaid`:
   - fromConnectorBalance = 1,000,000
   - fromConnectorWeight = 0.5
   - toConnectorBalance = 1,000,000
   - toConnectorWeight = 0.005
   - paidAmount = 500,000

3. Calculation at line 51: `x = bf / (bf + a) = 1,000,000 / 1,500,000 = 0.6667`

4. Calculation at line 52: `y = wf / wt = 0.5 / 0.005 = 100`

5. `Ln(0.6667)` computes approximately -0.405

6. Line 53 calls `Exp(100 × -0.405) = Exp(-40.5)`

7. In `Exp(-40.5)`, at iteration 20: calls `Pow(-40.5, 20)`

8. `Pow` computes (-40.5)^20 = 40.5^20 ≈ 1.8 × 10^32

**Expected Result:** Transaction completes and returns calculated token amount

**Actual Result:** `OverflowException` thrown because 1.8 × 10^32 exceeds decimal.MaxValue (7.92 × 10^28), transaction reverts, swap fails

**Success Condition:** Transaction reverts with arithmetic overflow error, proving DoS vulnerability

**Notes:**
- Even larger paidAmount values (e.g., 700,000) drive x closer to 0.5, producing Ln(x) ≈ -0.693 and Exp(-69.3), making overflow more severe
- The vulnerability exists in current production configuration without any malicious setup required
- Any connector pair with weight ratio > 26.53 is vulnerable to this overflow under normal usage conditions

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L51-53)
```csharp
        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L104-120)
```csharp
    public static decimal Pow(decimal x, uint y)
    {
        if (y == 1)
            return x;

        var A = 1m;
        var e = new BitArray(y.ToBytes(false));
        var t = e.Count;

        for (var i = t - 1; i >= 0; --i)
        {
            A *= A;
            if (e[i]) A *= x;
        }

        return A;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L131-132)
```csharp
        if (Math.Abs(x) >= 1)
            throw new InvalidValueException("must be 0 < a < 2");
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-123)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-172)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L354-357)
```csharp
    private static bool IsBetweenZeroAndOne(decimal number)
    {
        return number > decimal.Zero && number < decimal.One;
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L222-235)
```csharp
                Weight = "0.5",
                VirtualBalance = EconomicContractConstants.NativeTokenConnectorInitialVirtualBalance
            }
        };
        foreach (var resourceTokenSymbol in Context.Variables
                     .GetStringArray(EconomicContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(EconomicContractConstants.PayRentalSymbolListName)))
        {
            var resourceTokenConnector = new Connector
            {
                Symbol = resourceTokenSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
```
