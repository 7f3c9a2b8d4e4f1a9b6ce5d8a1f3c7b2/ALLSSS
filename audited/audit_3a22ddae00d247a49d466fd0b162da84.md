### Title
Missing Delegation State Paths in ACS2 Resource Declaration Allows Parallel Execution Race Condition

### Summary
The `AddPathForDelegatees` function fails to declare `TransactionFeeDelegateInfoMap` and `TransactionFeeDelegateesMap` state paths in WritePaths, despite these being modified during delegated transaction fee charging. This allows parallel execution of transactions that should be serialized, enabling delegation allowance over-spending and incorrect state tracking.

### Finding Description
The vulnerability exists in the ACS2 state path provider implementation for the MultiToken contract. [1](#0-0) 

When `AddPathForDelegatees` is called during `GetResourceInfo`, it only adds:
1. Fee token balance paths via `AddPathForTransactionFee`
2. Fee-free allowance paths via `AddPathForTransactionFeeFreeAllowance`

However, during actual transaction execution, when a delegatee pays fees on behalf of a delegator, the `ModifyDelegation` function modifies the delegation allowance state: [2](#0-1) 

This modifies `State.TransactionFeeDelegateInfoMap[delegatorAddress][contractAddress][methodName].Delegatees[delegateeAddress].Delegations[symbol]` or `State.TransactionFeeDelegateesMap[delegatorAddress].Delegatees[delegateeAddress].Delegations[symbol]`, but these state paths are never declared in WritePaths.

The `ModifyDelegation` function is invoked from `ChargeFromDelegations` when delegation is not unlimited: [3](#0-2) 

Additionally, `GetDelegateeList` reads these delegation maps during `GetResourceInfo` execution but doesn't declare them as ReadPaths: [4](#0-3) 

### Impact Explanation
This vulnerability allows multiple transactions from the same delegator (using the same delegatee with limited delegation allowance) to execute in parallel, causing:

1. **Delegation Allowance Over-spending**: If a delegatee has 100 ELF delegation allowance, two parallel transactions each requiring 60 ELF could both succeed (total 120 ELF), exceeding the limit.

2. **Incorrect State Tracking**: Concurrent decrements to the same delegation allowance field result in race conditions, potentially leaving the allowance in an incorrect state (could be negative or not properly decremented).

3. **Fee Payment Bypass**: Users could exploit this to get more transaction fees paid by delegatees than authorized, effectively stealing fee coverage.

The severity is Medium because:
- Requires specific setup (limited delegation allowance)
- Requires timing (parallel transaction submission)
- Impact is limited to delegation allowance tracking, not direct token theft
- Affects delegators who set limited delegation allowances

### Likelihood Explanation
**Exploitability: Medium to High**

**Attacker Capabilities Required:**
- Control over transaction submission timing
- Ability to submit multiple transactions rapidly
- Access to a delegatee with limited (non-unlimited) delegation allowance

**Attack Complexity: Low**
1. Set up delegation with limited allowance (e.g., 100 ELF for transaction fees)
2. Prepare multiple transactions that would each consume significant portions of the allowance
3. Submit transactions simultaneously or in rapid succession
4. Parallel execution engine processes them concurrently due to missing WritePaths
5. Both transactions successfully charge from the same delegation allowance

**Feasibility Conditions:**
- The blockchain must have parallel execution enabled (which is the purpose of ACS2)
- The delegator must use limited delegation (not `IsUnlimitedDelegate`)
- Multiple transactions must be submitted within the same block or close timing window

**Detection:** Difficult - appears as normal transaction execution; only detailed delegation allowance auditing would reveal over-spending.

### Recommendation

**Immediate Fix:**
Modify `AddPathForDelegatees` to include delegation state paths in WritePaths:

```csharp
private void AddPathForDelegatees(ResourceInfo resourceInfo, Address from, Address to, string methodName)
{
    var delegateeList = new List<string>();
    delegateeList.AddRange(GetDelegateeList(from, to, methodName));
    if (delegateeList.Count <= 0) return;
    
    // Add delegation map paths to WritePaths
    resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.TransactionFeeDelegateInfoMap), 
        from.ToString(), to.ToString(), methodName));
    resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.TransactionFeeDelegateesMap), 
        from.ToString()));
    
    var secondDelegateeList = new List<string>();
    foreach (var delegateeAddress in delegateeList.Select(a => Address.FromBase58(a)))
    {
        secondDelegateeList.AddRange(GetDelegateeList(delegateeAddress, to, methodName));
        // Add second-level delegation paths
        resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.TransactionFeeDelegateInfoMap), 
            delegateeAddress.ToString(), to.ToString(), methodName));
        resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.TransactionFeeDelegateesMap), 
            delegateeAddress.ToString()));
    }
    delegateeList.AddRange(secondDelegateeList);
    
    foreach (var delegatee in delegateeList.Distinct())
    {
        AddPathForTransactionFee(resourceInfo, delegatee, methodName);
        AddPathForTransactionFeeFreeAllowance(resourceInfo, Address.FromBase58(delegatee));
    }
}
```

**Test Cases:**
1. Verify parallel execution is blocked for transactions sharing the same delegator-delegatee pair
2. Test that delegation allowance is correctly decremented for sequential transactions
3. Confirm that attempting to over-spend delegation allowance via parallel transactions fails appropriately

### Proof of Concept

**Initial State:**
- Alice (delegator) has 1000 ELF
- Bob (delegatee) has 500 ELF  
- Alice delegates 100 ELF to Bob for paying transaction fees (limited delegation)

**Attack Sequence:**
1. Alice prepares Transaction T1: Transfer 100 TOKEN_A to Carol (requires 60 ELF fee)
2. Alice prepares Transaction T2: Transfer 100 TOKEN_B to Dave (requires 60 ELF fee)
3. Alice submits both T1 and T2 in the same block

**Expected Result (Correct Behavior):**
- T1 executes: Bob pays 60 ELF, delegation allowance becomes 40 ELF
- T2 fails: Insufficient delegation allowance (needs 60 ELF, only 40 ELF available)

**Actual Result (Vulnerable Behavior):**
- GetResourceInfo for T1 declares WritePaths without delegation state paths
- GetResourceInfo for T2 declares WritePaths without delegation state paths
- Parallel execution engine sees no WritePath conflicts
- T1 and T2 execute in parallel
- Both attempt to decrement Bob's delegation allowance from 100 ELF
- Race condition: Both transactions succeed, total fees = 120 ELF (exceeding 100 ELF limit)
- Final delegation allowance state is incorrect (could be 40, 80, or negative depending on race outcome)

**Success Condition:** Both transactions succeed and Bob pays total fees exceeding the original 100 ELF delegation limit.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L113-132)
```csharp
    private void AddPathForDelegatees(ResourceInfo resourceInfo, Address from, Address to, string methodName)
    {
        var delegateeList = new List<string>();
        //get and add first-level delegatee list
        delegateeList.AddRange(GetDelegateeList(from, to, methodName));
        if (delegateeList.Count <= 0) return;
        var secondDelegateeList = new List<string>();
        //get and add second-level delegatee list
        foreach (var delegateeAddress in delegateeList.Select(a => Address.FromBase58(a)))
        {
            //delegatee of the first-level delegate is delegator of the second-level delegate
            secondDelegateeList.AddRange(GetDelegateeList(delegateeAddress, to, methodName));
        }
        delegateeList.AddRange(secondDelegateeList);
        foreach (var delegatee in delegateeList.Distinct())
        {
            AddPathForTransactionFee(resourceInfo, delegatee, methodName);
            AddPathForTransactionFeeFreeAllowance(resourceInfo, Address.FromBase58(delegatee));
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L134-146)
```csharp
    private List<string> GetDelegateeList(Address delegator, Address to, string methodName)
    {
        var delegateeList = new List<string>();
        var allDelegatees = State.TransactionFeeDelegateInfoMap[delegator][to][methodName] 
                            ?? State.TransactionFeeDelegateesMap[delegator];
            
        if (allDelegatees != null)
        {
            delegateeList.AddRange(allDelegatees.Delegatees.Keys.ToList());
        } 

        return delegateeList;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L167-210)
```csharp
    private bool ChargeFromDelegations(ChargeTransactionFeesInput input, ref Address fromAddress,
        ref TransactionFeeBill bill, ref TransactionFreeFeeAllowanceBill allowanceBill,
        Dictionary<string, long> fee, bool isSizeFeeFree, Address delegatorAddress)
    {
        var chargingResult = false;
        // Try to charge delegatees
        // Get delegatee list according to the delegator
        var delegationInfo =
            State.TransactionFeeDelegateInfoMap[delegatorAddress][input.ContractAddress][input.MethodName]?.Delegatees ?? 
            State.TransactionFeeDelegateesMap[delegatorAddress]?.Delegatees;

        if (delegationInfo == null)
        {
            return false;
        }

        foreach (var (delegatee, delegations) in delegationInfo)
        {
            // compare current block height with the block height when the delegatee added
            if (Context.Transaction.RefBlockNumber < delegations.BlockHeight) continue;

            var delegateeBill = new TransactionFeeBill();
            var delegateeAllowanceBill = new TransactionFreeFeeAllowanceBill();
            var delegateeAddress = Address.FromBase58(delegatee);
            var delegateeChargingResult = ChargeTransactionFeesToBill(input, delegateeAddress,
                ref delegateeBill, ref delegateeAllowanceBill, fee, isSizeFeeFree, delegations);

            if (!delegateeChargingResult) continue;

            bill = delegateeBill;
            allowanceBill = delegateeAllowanceBill;
            fromAddress = delegateeAddress;
            chargingResult = true;
            if (!delegations.IsUnlimitedDelegate)
            {
                ModifyDelegation(delegateeBill, delegateeAllowanceBill, fromAddress, input.ContractAddress,
                    input.MethodName, delegatorAddress);
            }

            break;
        }

        return chargingResult;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L212-235)
```csharp
    private void ModifyDelegation(TransactionFeeBill bill, TransactionFreeFeeAllowanceBill allowanceBill,
        Address delegateeAddress, Address contractAddress, string methodName, Address delegatorAddress)
    {
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            var delegateInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][contractAddress][methodName] ??
                State.TransactionFeeDelegateesMap[delegatorAddress];
            delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol] =
                delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol].Sub(amount);
        }

        foreach (var (symbol, amount) in allowanceBill.FreeFeeAllowancesMap)
        {
            if (amount <= 0) continue;

            var delegateInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][contractAddress][methodName] ??
                State.TransactionFeeDelegateesMap[delegatorAddress];
            delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol] =
                delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol].Sub(amount);
        }
    }
```
