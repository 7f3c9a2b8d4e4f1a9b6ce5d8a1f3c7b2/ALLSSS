# Audit Report

## Title
PreviousInValue State Inconsistency Through Unconditional Overwrites in UpdateValue Processing

## Summary
The `PerformSecretSharing` function in the AEDPoS consensus contract allows any miner to unconditionally overwrite `PreviousInValue` fields for other miners without validation. This enables manipulation of signature calculations used during round transitions, compromising consensus integrity and random number generation.

## Finding Description

The vulnerability exists in the consensus update flow when secret sharing is enabled. When miners call the public `UpdateValue` method, the transaction is processed through `PerformSecretSharing`, which unconditionally overwrites `PreviousInValue` for any miners specified in the `MinersPreviousInValues` dictionary without any validation. [1](#0-0) [2](#0-1) 

The vulnerability manifests in the unconditional write operations where no validation ensures that the provided `MinersPreviousInValues` are legitimate reconstructed values from the secret sharing protocol. A malicious miner can construct an `UpdateValueInput` with arbitrary values for other miners' `PreviousInValue` fields.

The validation logic only checks the sender's own `PreviousInValue`, not the values provided for other miners: [3](#0-2) 

In contrast, a similar function `UpdateLatestSecretPieces` implements proper protection by only updating `PreviousInValue` when it's currently null or Hash.Empty: [4](#0-3) 

The corrupted `PreviousInValue` is subsequently used during round transitions when `SupplyCurrentRoundInformation` fills in consensus data for miners who didn't produce blocks: [5](#0-4) 

Specifically, at line 191, the potentially corrupted `PreviousInValue` is retrieved and used to calculate the signature at line 199, which directly affects consensus operations and random number generation.

## Impact Explanation

**Consensus Integrity Violation:** The corrupted `PreviousInValue` is used to calculate signatures for non-mining miners during round transitions. These signatures are critical components of the AEDPoS consensus mechanism and are used in random number generation. By manipulating these values, a malicious miner can influence consensus calculations.

**State Inconsistency:** Different miners can have inconsistent views of the consensus state within a round, as multiple miners producing blocks in the same round can repeatedly overwrite the same `PreviousInValue` fields, with the last writer winning. This violates the fundamental consensus invariant that all nodes should agree on the same state.

**Affected Parties:** All miners in the consensus set are potentially affected, particularly those who fail to produce blocks in a given round, as their signature calculations will be based on potentially corrupted data that wasn't cryptographically verified.

The severity is Medium-to-High as it undermines core consensus integrity, though exploitation requires miner-level privileges and primarily affects scenarios where miners don't produce blocks.

## Likelihood Explanation

**Reachable Entry Point:** The `UpdateValue` method is a public contract method callable by any miner during their designated block production time.

**Attacker Capabilities:** Any miner in the consensus set can construct a malicious `UpdateValueInput` with arbitrary `MinersPreviousInValues`. The protobuf structure allows a map of miner public keys to hash values. [6](#0-5) 

**Execution Practicality:** The attack requires:
1. Attacker must be a valid miner (verified by `PreCheck`)
2. Attacker produces a block in the target round
3. Attacker constructs `UpdateValueInput` with fabricated `MinersPreviousInValues`
4. No validation prevents this during transaction processing

**One Transaction Per Block Protection:** While `EnsureTransactionOnlyExecutedOnceInOneBlock` prevents multiple consensus transactions in a single block, it doesn't prevent the attack since different miners produce different blocks within the same round. [7](#0-6) 

**Feasibility:** High - requires only being a valid miner (a semi-trusted role within the consensus set) to corrupt another miner's `PreviousInValue`. Detection is difficult as the overwrite happens during normal consensus operations.

## Recommendation

Add validation in `PerformSecretSharing` to protect against unconditional overwrites, similar to the protection already present in `UpdateLatestSecretPieces`:

```csharp
foreach (var previousInValue in input.MinersPreviousInValues)
{
    if (round.RealTimeMinersInformation.ContainsKey(previousInValue.Key) &&
        (round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue == Hash.Empty ||
         round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue == null))
    {
        round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
}
```

Additionally, consider implementing cryptographic verification to ensure that provided `MinersPreviousInValues` are actually the correct reconstructed values from the secret sharing protocol, rather than arbitrary attacker-chosen values.

## Proof of Concept

The vulnerability can be demonstrated by having a malicious miner construct an `UpdateValueInput` with fake `MinersPreviousInValues` entries. When this transaction is processed through `ProcessUpdateValue`, the `PerformSecretSharing` function will unconditionally overwrite the `PreviousInValue` fields for the specified miners without any validation that these are legitimate secret-sharing reconstructed values. A subsequent call to `SupplyCurrentRoundInformation` during round transition will use these corrupted values to calculate signatures for non-mining miners, affecting consensus integrity.

**Notes**

The vulnerability exploits a gap between two code paths: `UpdateLatestSecretPieces` (used in off-chain block generation) has proper overwrite protection, while `PerformSecretSharing` (used in on-chain transaction processing) lacks this protection. This inconsistency suggests the missing protection in `PerformSecretSharing` is unintentional. The attack vector requires miner-level privileges but is otherwise straightforward to execute, and the impact on consensus integrity makes this a valid security concern requiring remediation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L171-221)
```csharp
    private void SupplyCurrentRoundInformation()
    {
        var currentRound = GetCurrentRoundInformation(new Empty());
        Context.LogDebug(() => $"Before supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
        var notMinedMiners = currentRound.RealTimeMinersInformation.Values.Where(m => m.OutValue == null).ToList();
        if (!notMinedMiners.Any()) return;
        TryToGetPreviousRoundInformation(out var previousRound);
        foreach (var miner in notMinedMiners)
        {
            Context.LogDebug(() => $"Miner pubkey {miner.Pubkey}");

            Hash previousInValue = null;
            Hash signature = null;

            // Normal situation: previous round information exists and contains this miner.
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
            }

            if (previousInValue == null)
            {
                // Handle abnormal situation.

                // The fake in value shall only use once during one term.
                previousInValue = HashHelper.ComputeFrom(miner);
                signature = previousInValue;
            }

            // Fill this two fields at last.
            miner.InValue = previousInValue;
            miner.Signature = signature;

            currentRound.RealTimeMinersInformation[miner.Pubkey] = miner;
        }

        TryToUpdateRoundInformation(currentRound);
        Context.LogDebug(() => $"After supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** protobuf/aedpos_contract.proto (L215-216)
```text
    // The InValue in the previous round, miner public key -> InValue.
    map<string, aelf.Hash> miners_previous_in_values = 11;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```
