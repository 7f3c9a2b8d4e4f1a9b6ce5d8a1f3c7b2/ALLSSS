### Title
Historical Election Snapshot Manipulation via Post-Election Pubkey Replacement

### Summary
The `GetPreviousTermSnapshotWithNewestPubkey()` function uses current ban status to retroactively modify historical election snapshots, allowing candidates who replace their pubkey after an election to transfer their votes to the new pubkey. This violates the principle that snapshots should represent the state at the time they were taken, enabling vote count manipulation in alternative candidate selection for miner replacements.

### Finding Description

The vulnerability exists in `GetPreviousTermSnapshotWithNewestPubkey()` where the ban status check uses current state rather than snapshot-time state. [1](#0-0) 

The `IsPubkeyBanned()` function checks the current ban status: [2](#0-1) 

Pubkeys are banned in two scenarios: (1) evil node detection, and (2) voluntary pubkey replacement. When a candidate replaces their pubkey, the old pubkey is banned: [3](#0-2) 

The problematic flow occurs when:
1. A snapshot is created at the end of Term N with election results
2. During Term N+1, a candidate voluntarily replaces their pubkey (old → new)
3. The old pubkey is marked as banned in current state
4. When `GetPreviousTermSnapshotWithNewestPubkey()` is called, it retrieves the Term N snapshot but checks CURRENT ban status
5. It finds the old pubkey is banned, gets the newest pubkey, and replaces the old pubkey with the new pubkey in the historical snapshot: [4](#0-3) 

The modified snapshot is then used to select alternative candidates for miner replacement: [5](#0-4) 

The root cause is a TIME-OF-CHECK-TIME-OF-USE issue: the snapshot represents state at Term N, but the ban check uses state from Term N+1 or later. The `TermSnapshot` structure does not store ban status at snapshot time: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Violation**: The function is called by the consensus contract during miner replacement operations: [7](#0-6) 

**Concrete Harm**:
1. A candidate who received 900 votes in Term N under pubkey C can replace their key to C' in Term N+1
2. The historical snapshot is retroactively modified to show C' with 900 votes instead of C
3. Alternative candidates are selected based on this modified data
4. Voters who voted for C in Term N never voted for C', yet C' receives those votes
5. This allows manipulation of miner selection by transferring vote counts to new pubkeys after elections complete

**Who is Affected**: 
- The blockchain's consensus integrity (wrong miners may be selected)
- Voters whose votes are transferred to pubkeys they never voted for
- Legitimate candidates who may be displaced in the alternative candidate ranking

**Severity Justification**: HIGH - This directly affects consensus by allowing manipulation of which miners are selected as replacements, violating the fundamental principle that election results should be immutable once recorded.

### Likelihood Explanation

**Reachable Entry Point**: The function is called from the consensus contract's view method, which is invoked during normal consensus operations when evil miners need replacement.

**Attacker Capabilities**: A candidate admin can voluntarily replace their pubkey at any time: [8](#0-7) 

**Attack Complexity**: LOW
1. Participate in election for Term N, receive votes
2. After Term N snapshot is taken, call `ReplaceCandidatePubkey` to replace old pubkey with new pubkey
3. When miner replacement occurs, the historical snapshot is automatically modified to show the new pubkey
4. No special permissions beyond candidate admin rights are required

**Feasibility**: The attack occurs during normal system operation and requires no special timing or coordination beyond choosing when to replace the pubkey.

**Detection**: The modification happens silently within the view function, making it difficult to detect without comparing raw snapshot storage against the returned modified snapshot.

**Probability**: MEDIUM-HIGH - Occurs whenever a candidate replaces their pubkey after being included in a term snapshot, which is a legitimate operation that candidates may perform for key rotation or security reasons.

### Recommendation

**Code-Level Mitigation**:
Store the ban status as part of each snapshot at the time the snapshot is created. Modify `SavePreviousTermInformation()` to include banned pubkeys: [9](#0-8) 

Add a `banned_pubkeys` field to `TermSnapshot`:
```protobuf
message TermSnapshot {
    int64 end_round_number = 1;
    int64 mined_blocks = 2;
    map<string, int64> election_result = 3;
    repeated string banned_pubkeys = 4; // NEW: pubkeys banned at snapshot time
}
```

**Invariant Check**: In `GetPreviousTermSnapshotWithNewestPubkey()`, only apply pubkey replacement if the pubkey was already banned at snapshot creation time, not if it was banned afterward.

**Test Cases**:
1. Verify snapshot remains unchanged when pubkey is replaced AFTER snapshot creation
2. Verify snapshot is correctly updated when pubkey was replaced BEFORE snapshot creation
3. Verify alternative candidate selection uses original election results, not post-modified results

### Proof of Concept

**Initial State**:
- Term N election completes with Candidate C receiving 900 votes
- Snapshot saved: `{..., C: 900, ...}`
- Current term advanced to N+1

**Attack Steps**:
1. Candidate C's admin calls `ReplaceCandidatePubkey(oldPubkey: C, newPubkey: C')`
2. System sets `State.BannedPubkeyMap[C] = true` and `State.InitialToNewestPubkeyMap[C] = C'`
3. An evil miner is detected in Term N+1
4. Consensus contract calls `GetMinerReplacementInformation()`
5. This internally calls `GetPreviousTermSnapshotWithNewestPubkey()`

**Expected Result**: 
Snapshot should return: `{..., C: 900, ...}` (unchanged, reflecting Term N election results)

**Actual Result**: 
Snapshot returns: `{..., C': 900, ...}` (modified, showing C' received votes that were cast for C)

**Success Condition**: 
C' appears in the alternative candidates list with 900 votes despite never participating in the Term N election, allowing C' to potentially be selected as a miner replacement based on votes cast for a different pubkey.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L145-145)
```csharp
        var bannedCandidates = snapshot.ElectionResult.Keys.Where(IsPubkeyBanned).ToList();
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L149-158)
```csharp
        foreach (var bannedCandidate in bannedCandidates)
        {
            var newestPubkey = GetNewestPubkey(bannedCandidate);
            // If newest pubkey not exists or same as old pubkey (which is banned), skip.
            if (newestPubkey == null || newestPubkey == bannedCandidate ||
                snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
            if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L363-377)
```csharp
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L61-64)
```csharp
    private bool IsPubkeyBanned(string pubkey)
    {
        return State.BannedPubkeyMap[pubkey];
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L246-246)
```csharp
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L459-479)
```csharp
    private void SavePreviousTermInformation(TakeElectionSnapshotInput input)
    {
        var snapshot = new TermSnapshot
        {
            MinedBlocks = input.MinedBlocks,
            EndRoundNumber = input.RoundNumber
        };

        if (State.Candidates.Value == null) return;

        foreach (var pubkey in State.Candidates.Value.Value)
        {
            var votes = State.CandidateVotes[pubkey.ToHex()];
            var validObtainedVotesAmount = 0L;
            if (votes != null) validObtainedVotesAmount = votes.ObtainedActiveVotedVotesAmount;

            snapshot.ElectionResult.Add(pubkey.ToHex(), validObtainedVotesAmount);
        }

        State.Snapshots[input.TermNumber] = snapshot;
    }
```

**File:** protobuf/election_contract.proto (L428-435)
```text
message TermSnapshot {
    // The end round number of this term.
    int64 end_round_number = 1;
    // The number of blocks mined in this term. 
    int64 mined_blocks = 2;
    // The election result, candidates’ public key -> number of votes.
    map<string, int64> election_result = 3;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-305)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```
