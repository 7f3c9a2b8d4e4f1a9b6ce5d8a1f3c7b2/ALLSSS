### Title
Unhandled ArgumentOutOfRangeException in CrossChainCreate Due to Missing Symbol Length Validation

### Summary
The `CrossChainCreate` function performs `input.Symbol.Substring(0, 2)` without validating that the symbol is at least 2 characters long. Since the MultiToken contract allows creation of 1-character symbols, cross-chain synced tokens with such symbols will cause an unhandled exception when attempting NFT protocol creation on destination chains, resulting in permanent DoS for those specific symbols.

### Finding Description
The vulnerability exists in the `CrossChainCreate` method where the NFT type short name is extracted from the symbol: [1](#0-0) 

The code assumes all symbols are at least 2 characters long to extract the NFT type prefix. However, the MultiToken contract's validation only requires symbol length to be greater than 0: [2](#0-1) 

The validation at line 275 checks `input.Symbol.Length > 0`, allowing single-character symbols like "A" or "X". The regex pattern used for validation also permits this: [3](#0-2) 

The regex `^[a-zA-Z0-9]+(-[0-9]+)?$` requires one or more alphanumeric characters, not a minimum of two.

**Exploitation Path:**
1. A token with a 1-character symbol is created on Chain A (mainchain or sidechain) by a whitelisted address or on a sidechain where seed restrictions may not apply
2. The token is synced to Chain B via `CrossChainCreateToken` with no additional length validation: [4](#0-3) 

3. When `CrossChainCreate` is called with this symbol, the token info retrieval succeeds: [5](#0-4) 

4. The subsequent Substring operation throws an unhandled `ArgumentOutOfRangeException` in C#

### Impact Explanation
**Operational Impact - DoS of Cross-Chain NFT Protocol Creation:**

- Any token with a 1-character symbol synced cross-chain cannot have its NFT protocol created on the destination chain
- The `CrossChainCreate` function becomes permanently unusable for that specific symbol
- This breaks the cross-chain NFT protocol establishment flow, preventing legitimate NFT operations
- While the underlying token remains functional in the MultiToken contract, NFT-specific features (minting, metadata management, etc.) cannot be initialized
- This affects protocol interoperability and cross-chain NFT functionality

**Severity Justification:** High - While not causing direct fund loss, this creates a permanent operational failure for affected tokens, disrupting critical cross-chain NFT infrastructure.

### Likelihood Explanation
**Attacker Capabilities:** An attacker needs ability to create tokens with 1-character symbols. While mainchain creation requires Seed NFTs for non-whitelisted addresses: [6](#0-5) 

Several bypass vectors exist:
- Whitelisted addresses can create any valid symbol without Seed NFT restrictions
- Sidechain token creation may have different or relaxed rules
- The Seed NFT system itself may allow registration of 1-character symbols

**Attack Complexity:** Low - Once a 1-character token exists, the cross-chain sync and subsequent DoS are automatic.

**Feasibility Conditions:** 
- No special permissions needed beyond token creation capability
- Cross-chain infrastructure functions normally
- No detection mechanisms exist for this edge case

**Probability:** Medium - While unusual, 1-character symbols are technically valid throughout the system, making this a realistic edge case that could occur accidentally or maliciously.

### Recommendation
**Code-Level Mitigation:**

Add symbol length validation before the Substring operation in `CrossChainCreate`:

```csharp
// In CrossChainCreate method, before line 89
Assert(input.Symbol.Length >= 2, 
    $"Symbol {input.Symbol} must be at least 2 characters for NFT type extraction.");

var nftTypeShortName = input.Symbol.Substring(0, 2);
```

**Alternative: Enforce minimum length in MultiToken contract:**

Add a constant for minimum symbol length and enforce it during token creation:

```csharp
// In TokenContractConstants.cs
public const int SymbolMinLength = 2;

// In AssertValidCreateInput method
Assert(input.Symbol.Length >= TokenContractConstants.SymbolMinLength,
    "Symbol must be at least 2 characters.");
```

**Test Cases:**
1. Attempt to call `CrossChainCreate` with a 1-character symbol - should fail with clear error
2. Verify MultiToken creation rejects 1-character symbols if minimum length enforcement is added
3. Test cross-chain sync with edge case symbols (2 chars, special characters, etc.)

### Proof of Concept

**Initial State:**
- Chain A (source chain) operational with MultiToken contract
- Chain B (destination chain) operational with NFT and MultiToken contracts
- Cross-chain infrastructure configured between chains

**Exploitation Steps:**

1. **On Chain A:** Create token with 1-character symbol:
   - Whitelisted address calls `Create` with `input.Symbol = "A"`
   - Token passes validation (length > 0, matches regex)
   - Token "A" successfully created

2. **Cross-Chain Sync:**
   - Call `ValidateTokenInfoExists` on Chain A for symbol "A"
   - Index cross-chain transaction
   - Call `CrossChainCreateToken` on Chain B with merkle proof
   - Token "A" successfully registered on Chain B

3. **Trigger DoS:**
   - Call `CrossChainCreate` on Chain B with `input.Symbol = "A"`
   - Line 80-85: Token info retrieval succeeds
   - Line 89: Execute `"A".Substring(0, 2)`
   - **Result:** `ArgumentOutOfRangeException` thrown
   - Transaction reverts with unhandled exception

**Expected vs Actual:**
- **Expected:** Either validation prevents 1-char symbols, or Substring handles gracefully
- **Actual:** Unhandled exception crashes the transaction, permanently blocking NFT protocol creation

**Success Condition:** Transaction revert with exception proves the DoS vulnerability.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L80-85)
```csharp
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L89-89)
```csharp
        var nftTypeShortName = input.Symbol.Substring(0, 2);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L18-21)
```csharp
    private static bool IsValidSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+(-[0-9]+)?$");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-508)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```
