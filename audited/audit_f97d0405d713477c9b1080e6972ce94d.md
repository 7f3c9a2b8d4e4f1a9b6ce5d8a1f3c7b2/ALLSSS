### Title
Vote Contract Registration Bypasses Option Limits Through Governance Proposals

### Summary
The VoteContract.Register method fails to validate the options count and option length constraints defined in VoteContractConstants (MaximumOptionsCount=64, OptionLengthLimit=1024). Parliament, Referendum, and Association governance contracts can create proposals that call VoteContract.Register with arbitrary options, completely bypassing these limits since validation only occurs in AddOption/AddOptions methods after registration.

### Finding Description

The vulnerability exists in the VoteContract.Register method which creates voting items without validating the options array: [1](#0-0) [2](#0-1) 

At line 49, the Register method directly copies all options from the input without any validation of count or length: `Options = { input.Options }`. The AssertValidNewVotingItem helper method only validates timestamps and item uniqueness, not options. [3](#0-2) 

The limits are only enforced in the AddOption and AddOptions methods: [4](#0-3) [5](#0-4) [6](#0-5) 

Governance contracts (Parliament, Referendum, Association) can execute arbitrary contract calls through their Release methods using CreateProposalInput: [7](#0-6) [8](#0-7) [9](#0-8) [10](#0-9) 

The protobuf definition shows VotingRegisterInput accepts a repeated string options field with no size constraints: [11](#0-10) 

### Impact Explanation

**Governance Integrity Violation**: Voting items can be created with unlimited options (>64) or excessively long option strings (>1024 characters), violating documented constraints and potentially causing:

1. **Storage bloat**: Unbounded options stored in voting items
2. **Gas/computation issues**: Iterations over large option sets could exceed transaction limits
3. **User interface failures**: Systems expecting â‰¤64 options may break
4. **Inconsistent state**: Some voting items respect limits (via AddOption) while others bypass them (via Register)

**Who is affected**: Any voting activity registered through governance proposals, which includes critical protocol governance decisions. The Election contract already uses VoteContract.Register but fortunately doesn't include options in its registration: [12](#0-11) 

However, governance contracts could create voting items for any purpose with malicious option sets.

### Likelihood Explanation

**Reachable Entry Point**: Any authorized proposer in Parliament/Referendum/Association organizations can create proposals. This doesn't require special privileges beyond normal proposer authorization (whitelist membership or organization membership). [13](#0-12) [14](#0-13) [15](#0-14) 

**Attack Complexity**: Low. The attacker simply:
1. Creates a CreateProposalInput with contract_method_name="Register", to_address=VoteContract, params=serialized VotingRegisterInput with >64 options
2. Gets proposal approved through normal governance process
3. Releases the proposal, which executes Register with malicious input

**Feasibility**: The existing tests show Register is called with options, and validation only occurs in AddOption/AddOptions: [16](#0-15) [17](#0-16) 

The test at line 342 successfully registers with exactly 64 options, and the test at line 340-352 shows adding the 65th option fails. No test validates rejecting >64 options during Register itself, confirming the missing validation.

### Recommendation

**Immediate Fix**: Add option validation in the Register method before line 49:

```csharp
// In VoteContract.cs Register method, before line 49
Assert(input.Options.Count <= VoteContractConstants.MaximumOptionsCount, 
    $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
foreach (var option in input.Options)
{
    Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
}
```

**Add to AssertValidNewVotingItem**: Move the validation logic into the AssertValidNewVotingItem helper method: [3](#0-2) 

Add after line 361:
```csharp
Assert(input.Options.Count <= VoteContractConstants.MaximumOptionsCount,
    $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
foreach (var option in input.Options)
{
    Assert(option.Length <= VoteContractConstants.OptionLengthLimit, 
        $"Option length exceeds limit of {VoteContractConstants.OptionLengthLimit}");
}
```

**Test Case**: Add a test in BasicTests.cs:
```csharp
[Fact]
public async Task Register_With_Too_Many_Options_Should_Fail()
{
    var input = new VotingRegisterInput
    {
        StartTimestamp = TimestampHelper.GetUtcNow(),
        EndTimestamp = TimestampHelper.GetUtcNow().AddDays(10),
        Options = { GenerateOptions(VoteContractConstants.MaximumOptionsCount + 1) },
        AcceptedCurrency = TestTokenSymbol,
        IsLockToken = true
    };
    var result = await VoteContractStub.Register.SendWithExceptionAsync(input);
    result.TransactionResult.Error.ShouldContain("can't greater than 64");
}
```

### Proof of Concept

**Initial State**: 
- Parliament/Referendum/Association organization exists with authorized proposer
- VoteContract is deployed and accessible

**Attack Steps**:

1. **Create malicious VotingRegisterInput** with 100 options (exceeding limit of 64):
```csharp
var maliciousInput = new VotingRegisterInput
{
    StartTimestamp = TimestampHelper.GetUtcNow(),
    EndTimestamp = TimestampHelper.GetUtcNow().AddDays(365),
    Options = { GenerateOptions(100) }, // 100 options > 64 limit
    AcceptedCurrency = "ELF",
    IsLockToken = true,
    TotalSnapshotNumber = 1
};
```

2. **Create governance proposal**:
```csharp
var proposalInput = new CreateProposalInput
{
    ContractMethodName = "Register",
    ToAddress = voteContractAddress,
    Params = maliciousInput.ToByteString(),
    ExpiredTime = TimestampHelper.GetUtcNow().AddDays(30),
    OrganizationAddress = parliamentOrgAddress
};
var proposalId = await ParliamentContractStub.CreateProposal.SendAsync(proposalInput);
```

3. **Get proposal approved and release**:
```csharp
await ParliamentContractStub.Approve.SendAsync(proposalId);
// ... get enough approvals ...
await ParliamentContractStub.Release.SendAsync(proposalId);
```

**Expected Result**: Register should reject input with >64 options with assertion error.

**Actual Result**: Register succeeds, creating a voting item with 100 options, bypassing the MaximumOptionsCount=64 limit defined in VoteContractConstants.

**Success Condition**: Query the created voting item and verify it contains 100 options despite the documented 64-option limit.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-6)
```csharp
    public const int MaximumOptionsCount = 64;
    public const int OptionLengthLimit = 1024;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-82)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);

        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Accepted currency is in white list means this token symbol supports voting.
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");

        // Initialize voting event.
        var votingItem = new VotingItem
        {
            Sponsor = Context.Sender,
            VotingItemId = votingItemId,
            AcceptedCurrency = input.AcceptedCurrency,
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
        };

        State.VotingItems[votingItemId] = votingItem;

        // Initialize first voting going information of registered voting event.
        var votingResultHash = GetVotingResultHash(votingItemId, 1);
        State.VotingResults[votingResultHash] = new VotingResult
        {
            VotingItemId = votingItemId,
            SnapshotNumber = 1,
            SnapshotStartTimestamp = input.StartTimestamp
        };

        Context.Fire(new VotingItemRegistered
        {
            Sponsor = votingItem.Sponsor,
            VotingItemId = votingItemId,
            AcceptedCurrency = votingItem.AcceptedCurrency,
            IsLockToken = votingItem.IsLockToken,
            TotalSnapshotNumber = votingItem.TotalSnapshotNumber,
            CurrentSnapshotNumber = votingItem.CurrentSnapshotNumber,
            CurrentSnapshotStartTimestamp = votingItem.StartTimestamp,
            StartTimestamp = votingItem.StartTimestamp,
            EndTimestamp = votingItem.EndTimestamp,
            RegisterTimestamp = votingItem.RegisterTimestamp,
            IsQuadratic = votingItem.IsQuadratic,
            TicketCost = votingItem.TicketCost
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L280-290)
```csharp
    public override Empty AddOption(AddOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        AssertOption(votingItem, input.Option);
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        votingItem.Options.Add(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L292-296)
```csharp
    private void AssertOption(VotingItem votingItem, string option)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(!votingItem.Options.Contains(option), "Option already exists.");
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L314-324)
```csharp
    public override Empty AddOptions(AddOptionsInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        foreach (var option in input.Options) AssertOption(votingItem, option);
        votingItem.Options.AddRange(input.Options);
        Assert(votingItem.Options.Count <= VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** protobuf/acs3.proto (L78-97)
```text
message CreateProposalInput {
    // The name of the method to call after release.
    string contract_method_name = 1;
    // The address of the contract to call after release.
    aelf.Address to_address = 2;
    // The parameter of the method to be called after the release.
    bytes params = 3;
    // The timestamp at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 4;
    // The address of the organization.
    aelf.Address organization_address = 5;
    // Url is used for proposal describing.
    string proposal_description_url = 6;
    // The token is for proposal id generation and with this token, proposal id can be calculated before proposing.
    aelf.Hash token = 7;
    // Title of this proposal.
    string title = 8;
    // Description of this proposal.
    string description = 9;
}
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-66)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-59)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** protobuf/vote_contract.proto (L87-104)
```text
message VotingRegisterInput {
    // The start time of the voting.
    google.protobuf.Timestamp start_timestamp = 1;
    // The end time of the voting.
    google.protobuf.Timestamp end_timestamp = 2;
    // The token symbol which will be accepted.
    string accepted_currency = 3;
    // Whether the vote will lock token.
    bool is_lock_token = 4;
    // The total number of snapshots of the vote.
    int64 total_snapshot_number = 5;
    // The list of options.
    repeated string options = 6;
    // Is quadratic voting.
    bool is_quadratic = 7;
    // Quadratic voting item ticket cost.
    int64 ticket_cost = 8;
}
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L54-76)
```csharp
    public override Empty RegisterElectionVotingEvent(Empty input)
    {
        Assert(!State.VotingEventRegistered.Value, "Already registered.");

        State.VoteContract.Value = Context.GetContractAddressByName(SmartContractConstants.VoteContractSystemName);

        var votingRegisterInput = new VotingRegisterInput
        {
            IsLockToken = false,
            AcceptedCurrency = Context.Variables.NativeSymbol,
            TotalSnapshotNumber = long.MaxValue,
            StartTimestamp = TimestampHelper.MinValue,
            EndTimestamp = TimestampHelper.MaxValue
        };
        State.VoteContract.Register.Send(votingRegisterInput);

        State.MinerElectionVotingItemId.Value = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(votingRegisterInput),
            HashHelper.ComputeFrom(Context.Self));

        State.VotingEventRegistered.Value = true;
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Vote.Tests/VoteContractTestHelper.cs (L28-50)
```csharp
    private async Task<VotingItem> RegisterVotingItemAsync(int lastingDays, int optionsCount, bool isLockToken,
        Address sender,
        int totalSnapshotNumber = int.MaxValue)
    {
        var startTime = TimestampHelper.GetUtcNow();
        var input = new VotingRegisterInput
        {
            TotalSnapshotNumber = totalSnapshotNumber,
            EndTimestamp = startTime.AddDays(lastingDays),
            StartTimestamp = startTime,
            Options = { GenerateOptions(optionsCount) },
            AcceptedCurrency = TestTokenSymbol,
            IsLockToken = isLockToken
        };
        var transactionResult = (await VoteContractStub.Register.SendAsync(input)).TransactionResult;
        transactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        input.Options.Clear();
        var votingItemId = HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(input), HashHelper.ComputeFrom(sender));
        return await VoteContractStub.GetVotingItem.CallAsync(new GetVotingItemInput
        {
            VotingItemId = votingItemId
        });
    }
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L340-352)
```csharp
        // option count exceed 64
        {
            var registerItem = await RegisterVotingItemAsync(100, VoteContractConstant.MaximumOptionsCount, true,
                DefaultSender, 1);
            var newOption = Accounts[VoteContractConstant.MaximumOptionsCount].Address.ToBase58();
            var transactionResult = (await VoteContractStub.AddOption.SendWithExceptionAsync(new AddOptionInput
            {
                Option = newOption,
                VotingItemId = registerItem.VotingItemId
            })).TransactionResult;
            transactionResult.Error.ShouldContain(
                $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        }
```
