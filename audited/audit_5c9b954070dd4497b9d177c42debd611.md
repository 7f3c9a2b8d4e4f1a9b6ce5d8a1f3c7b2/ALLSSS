### Title
Election Contract Miners Count Desynchronization After MinerIncreaseInterval Change

### Summary
When `SetMinerIncreaseInterval()` modifies the miner increase interval, it fails to notify the Election contract of the resulting change in effective miners count. This causes the Election contract to use stale miners count data during the next term transition, resulting in an incorrect number of block producers being elected for that term.

### Finding Description

The `SetMinerIncreaseInterval()` function updates `State.MinerIncreaseInterval.Value` without notifying the Election contract: [1](#0-0) 

The `MinerIncreaseInterval` value is used in the `GetMinersCount(Round input)` calculation to determine the auto-increased miners count based on blockchain age: [2](#0-1) 

The formula on line 389-390 shows that miners count increases as `(BlockchainAge / MinerIncreaseInterval) * 2`. When `MinerIncreaseInterval` decreases, the effective miners count increases, and vice versa.

In contrast, `SetMaximumMinersCount()` immediately notifies the Election contract via `UpdateMinersCount.Send()`: [3](#0-2) 

During term transitions, the Election contract's `GetVictories()` function uses its stored `State.MinersCount.Value` to determine how many candidates to select: [4](#0-3) 

The critical lines are 58, 60, and 81 where `State.MinersCount.Value` is used to limit candidate selection.

When a new term begins, `GenerateFirstRoundOfNextTerm()` calls `TryToGetVictories()` which fetches candidates from the Election contract: [5](#0-4) [6](#0-5) 

This occurs during block generation via `GetConsensusExtraDataForNextTerm()`: [7](#0-6) 

Only after the block is executed does `ProcessNextTerm()` update the Election contract's miners count: [8](#0-7) 

However, by this point the round has already been generated with the wrong number of miners based on the stale Election contract data.

### Impact Explanation

**Concrete Harm**:
- **Incorrect Miner Selection**: When `MinerIncreaseInterval` is decreased (to accelerate miner growth), the auto-calculated count increases, but the Election contract still uses the old lower count. This causes fewer candidates to be elected as block producers than the system intends.
  
- **Example Scenario**: 
  - Blockchain age: 2 years (63,072,000 seconds)
  - Initial `MinerIncreaseInterval`: 31,536,000 (1 year)
  - Auto-increased count: 17 + (63,072,000 / 31,536,000) * 2 = 21
  - Election contract `MinersCount`: 21
  - After governance reduces interval to 15,768,000 (6 months)
  - New auto-increased count: 17 + (63,072,000 / 15,768,000) * 2 = 25
  - Election contract still has `MinersCount`: 21
  - At next term: `GetVictories()` returns only 21 candidates instead of 25

- **Affected Parties**:
  - Candidates ranked 22-25 who should be elected but are excluded
  - Voters who voted for these candidates expecting returns
  - Network decentralization objectives are compromised

- **Duration**: From `SetMinerIncreaseInterval()` call until the next term transition (typically 1 day in AElf), though the wrong miner count persists for the entire subsequent term.

### Likelihood Explanation

**Attacker Capabilities**: This is not a traditional attack but rather an operational vulnerability triggered by legitimate governance actions. The Parliament organization (requiring 2/3 miner consensus) can call `SetMinerIncreaseInterval()`. [9](#0-8) 

**Feasibility**: The vulnerability is highly feasible as:
- `SetMinerIncreaseInterval()` is a legitimate administrative function
- No malicious intent required - the desync is an unintentional side effect
- The constraint on line 61 only prevents increasing the interval, not decreasing it
- Term transitions happen regularly (daily)

**Execution Practicality**: The vulnerability manifests automatically during normal protocol operation whenever `MinerIncreaseInterval` is changed between term transitions.

**Probability**: Medium - While `MinerIncreaseInterval` changes are infrequent governance decisions, they are legitimate protocol adjustments that could occur during network growth phases or governance policy changes.

### Recommendation

**Immediate Fix**: Modify `SetMinerIncreaseInterval()` to notify the Election contract immediately, similar to `SetMaximumMinersCount()`:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    
    // Add synchronization with Election contract
    TryToGetCurrentRoundInformation(out var round);
    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
    {
        MinersCount = GetMinersCount(round)
    });
    
    return new Empty();
}
```

**Invariant Check**: Add integration tests to verify that after any change to parameters affecting miners count calculation (`MinerIncreaseInterval` or `MaximumMinersCount`), the Election contract's `State.MinersCount.Value` matches the Consensus contract's calculated `GetMinersCount()` result.

**Regression Prevention**: Add test cases that:
1. Call `SetMinerIncreaseInterval()` with a decreased value
2. Immediately query Election contract's `GetMinersCount()`
3. Verify it matches the expected auto-increased count
4. Trigger a term transition
5. Verify the correct number of miners are elected

### Proof of Concept

**Initial State**:
- Blockchain running for 2 years (63,072,000 seconds)
- `State.MinerIncreaseInterval.Value` = 31,536,000 (1 year)
- Calculated miners count: 17 + (63,072,000 / 31,536,000) * 2 = 21
- `Election.State.MinersCount.Value` = 21
- 30 active candidates with votes

**Transaction Sequence**:

1. **Parliament proposal and execution**: Call `SetMinerIncreaseInterval(15768000)` (6 months)
   - `State.MinerIncreaseInterval.Value` updated to 15,768,000
   - New calculated count: 17 + (63,072,000 / 15,768,000) * 2 = 25
   - Election contract NOT notified

2. **Query Election contract**: Call `Election.GetMinersCount()`
   - Returns: 21 (stale value)
   - Expected: 25 (should reflect new calculation)

3. **Term transition occurs**: Miner produces NextTerm block
   - `GenerateFirstRoundOfNextTerm()` calls `GetVictories()`
   - `GetVictories()` uses `State.MinersCount.Value = 21`
   - Returns top 21 candidates only
   - New term round generated with 21 miners

4. **Block execution**: `ProcessNextTerm()` runs
   - `UpdateMinersCountToElectionContract()` calculates based on actual round
   - Updates Election to `MinersCount = 21` (matching actual round, not intended 25)

**Expected vs Actual Result**:
- **Expected**: 25 block producers elected for the new term
- **Actual**: Only 21 block producers elected
- **Consequence**: 4 eligible candidates (ranked 22-25) excluded from block production and rewards

**Success Condition**: Candidates ranked 22-25 by vote weight are not included in the new term's miner list despite the updated interval parameter indicating they should be.

### Notes

The vulnerability represents a cross-contract state synchronization issue rather than a direct exploit. The impact severity is Medium because:
- The desync is temporary but affects miner selection for an entire term
- The direction matters: decreasing interval (common during network growth) causes under-selection of miners
- Increasing interval could cause over-selection, but line 61's assertion prevents interval increases
- The issue self-corrects at subsequent term transitions but with wrong miners for one term

The root cause is the inconsistent synchronization pattern between `SetMaximumMinersCount()` (which immediately notifies Election) and `SetMinerIncreaseInterval()` (which does not), despite both affecting the same effective miners count calculation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L31-43)
```csharp
    private void RequiredMaximumMinersCountControllerSet()
    {
        if (State.MaximumMinersCountController.Value != null) return;
        EnsureParliamentContractAddressSet();

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MaximumMinersCountController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-177)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

```
