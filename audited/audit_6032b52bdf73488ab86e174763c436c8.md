### Title
Duplicate Mining Order Injection via Unvalidated TuneOrderInformation Breaks Consensus Schedule Integrity

### Summary
A malicious miner can inject duplicate `FinalOrderOfNextRound` values through unvalidated `TuneOrderInformation` in `UpdateValueInput`, causing multiple miners to receive identical `Order` values in the next round. This violates the critical invariant that each miner must have a unique time slot, allowing invalid time slot configurations to bypass validation and disrupting consensus schedule integrity.

### Finding Description

**Root Cause:** The `ProcessUpdateValue` method applies miner-provided `TuneOrderInformation` directly to other miners' `FinalOrderOfNextRound` values without any validation to prevent duplicates. [1](#0-0) 

The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`, completely ignoring `TuneOrderInformation` content. [2](#0-1) 

When the next round is generated, `GenerateNextRoundInformation` directly assigns `FinalOrderOfNextRound` to the `Order` field without checking for duplicates. [3](#0-2) 

The `ExpectedMiningTime` is calculated based on `Order`, so duplicate orders result in identical mining times for multiple miners. [4](#0-3) 

**Why Protections Fail:** The `NextRoundMiningOrderValidationProvider` attempts distinctness checking but calls `Distinct()` on `MinerInRound` objects rather than on their `FinalOrderOfNextRound` values, making it ineffective. [5](#0-4) 

The `CheckRoundTimeSlots` function uses `OrderBy(m => m.Order)` which, with duplicate Order values, produces non-deterministic or overlapping miner sequences. The validation allows intervals within a tolerance range, enabling invalid configurations with skipped orders to pass. [6](#0-5) 

### Impact Explanation

**Consensus Integrity Violation:** Multiple miners are assigned identical `Order` values and thus identical `ExpectedMiningTime` values, creating direct time slot conflicts. This violates the fundamental consensus invariant that each miner must have a unique, non-overlapping time slot.

**Schedule Disruption:** By creating duplicate orders (e.g., two miners with Order=3), the attack causes some order positions to be skipped (e.g., no miner with Order=4), creating uneven time slot distributions. The validation's tolerance mechanism allows gaps up to 2x the base interval to pass, enabling invalid configurations.

**Operational Impact:** Miners with duplicate time slots will attempt to produce blocks simultaneously, causing synchronization conflicts, potential block production failures, and consensus round disruption. This degrades network stability and block production reliability.

**Affected Parties:** All network participants are affected through consensus degradation. Honest miners may miss their legitimate time slots due to schedule conflicts, while the attacker gains unfair block production opportunities.

### Likelihood Explanation

**Attacker Capabilities:** The attacker must be an active miner in the current round, which is a semi-privileged but publicly accessible role through the election mechanism. Once a miner, they can submit `UpdateValue` transactions with arbitrary `TuneOrderInformation`.

**Attack Complexity:** Low. The attacker simply needs to construct an `UpdateValueInput` with malicious `TuneOrderInformation` mapping other miners' public keys to duplicate order values. No complex timing, state manipulation, or cryptographic bypass is required. [7](#0-6) 

**Feasibility Conditions:** The attack is executable in any round where the attacker is an active miner. The `PreCheck` only verifies the sender is in the miner list, not that their input data is honest. [8](#0-7) 

**Detection:** The malicious `TuneOrderInformation` persists in state after `ProcessUpdateValue` execution and propagates to the next round, making detection possible but requiring active monitoring of round state transitions.

**Probability:** High likelihood given the low attack complexity and absence of preventive validation.

### Recommendation

**Immediate Fix:** Add validation in `UpdateValueValidationProvider` or `ProcessUpdateValue` to ensure `TuneOrderInformation` does not create duplicate `FinalOrderOfNextRound` values:

1. Before applying `TuneOrderInformation`, collect all resulting `FinalOrderOfNextRound` values (including the sender's own `SupposedOrderOfNextRound`)
2. Verify all values are unique using a HashSet or similar distinctness check
3. Verify all values are within valid range [1, minersCount]
4. Reject the transaction if duplicates or out-of-range values are detected

**Validation Enhancement:** Fix `NextRoundMiningOrderValidationProvider` to check distinctness of `FinalOrderOfNextRound` values, not `MinerInRound` objects:
```csharp
var finalOrders = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound);
if (finalOrders.Count() != finalOrders.Distinct().Count())
    return new ValidationResult { Message = "Duplicate FinalOrderOfNextRound values detected." };
```

**Invariant Check:** Add assertion in `GenerateNextRoundInformation` to detect and prevent duplicate Order assignment before it occurs.

**Test Cases:**
1. Test that `UpdateValue` with duplicate `TuneOrderInformation` values is rejected
2. Test that round generation fails if duplicate `FinalOrderOfNextRound` values exist
3. Test that `NextRound` validation catches duplicate Order values before execution

### Proof of Concept

**Initial State:**
- 5 miners in current round (A, B, C, D, E)
- Miner A is malicious, others are honest
- All miners have produced blocks and set their `SupposedOrderOfNextRound` values normally

**Attack Steps:**

1. Malicious Miner A constructs `UpdateValueInput` with:
   - `SupposedOrderOfNextRound` = 1 (their own order)
   - `TuneOrderInformation` = { "MinerC_Pubkey": 3, "MinerD_Pubkey": 3 } (duplicate!)

2. Miner A calls `UpdateValue` with this input

3. `ProcessUpdateValue` applies the malicious tuning:
   - Sets `currentRound.RealTimeMinersInformation["MinerC"].FinalOrderOfNextRound = 3`
   - Sets `currentRound.RealTimeMinersInformation["MinerD"].FinalOrderOfNextRound = 3`
   - No validation occurs; state is corrupted

4. Later, when `NextRound` is triggered, `GenerateNextRoundInformation` executes:
   - Miner C gets `Order = 3, ExpectedMiningTime = T + 3000ms`
   - Miner D gets `Order = 3, ExpectedMiningTime = T + 3000ms`
   - Order 4 is missing from the sequence

5. `NextRound` validation calls `CheckRoundTimeSlots`:
   - `OrderBy(m => m.Order)` produces list with duplicate Order=3 entries
   - Validation calculates intervals between consecutive entries
   - Due to tolerance (`baseMiningInterval` threshold), the invalid configuration passes

**Expected Result:** `UpdateValue` transaction should be rejected with "Duplicate order values detected"

**Actual Result:** Transaction succeeds, consensus schedule is corrupted with duplicate mining orders, next round has invalid time slot configuration

**Success Condition:** Two miners (C and D) have identical Order and ExpectedMiningTime values in the next round, violating consensus invariants

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-330)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L35-57)
```csharp
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```
