# Audit Report

## Title
NFT Protocol Creation Always Fails Due to Symbol Length Validation Mismatch

## Summary
The NFT contract generates protocol symbols that are always at least 11 characters long, but the TokenContract validates them as regular tokens with a 10-character maximum limit. This architectural mismatch causes 100% of NFT protocol creation attempts to fail, rendering the entire NFT contract non-functional.

## Finding Description

The vulnerability stems from a fundamental design mismatch between symbol generation in the NFT contract and symbol type classification in the TokenContract.

**Symbol Generation Flow:**

The NFT contract's `GetSymbol()` method generates protocol symbols by concatenating a 2-character NFT type short name with a random number. [1](#0-0) 

The minimum number length is defined as 9 digits. [2](#0-1) 

This produces symbols like "AR123456789" (2 + 9 = 11 characters minimum) without any separator character. Short names are enforced to be exactly 2 characters. [3](#0-2) 

**Symbol Type Misclassification:**

When the NFT contract calls TokenContract.Create with the generated symbol, the TokenContract's `GetSymbolType()` method splits the symbol by the '-' separator. Since NFT protocol symbols have no '-' separator, they return `SymbolType.Token` instead of an NFT type. [4](#0-3) 

**Validation Failure:**

The TokenContract enforces different length limits based on symbol type: 10 characters for `SymbolType.Token` and 30 characters for NFT types. [5](#0-4) [6](#0-5) 

The `CheckSymbolLength()` validation enforces the 10-character limit for Token types. [7](#0-6) 

Since NFT protocol symbols are 11+ characters but classified as Token type, the validation always fails with "Invalid token symbol length".

**Execution Path:**

The NFT contract's `Create()` method generates the symbol and calls `TokenContract.Create.Send()`. [8](#0-7) 

TokenContract.Create determines symbol type and routes to `CreateToken()`. [9](#0-8) 

CreateToken calls `AssertValidCreateInput()` which invokes the failing validation. [10](#0-9) [11](#0-10) 

## Impact Explanation

**Severity: CRITICAL**

This vulnerability completely breaks the NFT contract's core functionality:

1. **Complete Denial of Service**: Every call to `NFTContract.Create()` fails deterministically. No NFT protocols can be created through the intended public interface.

2. **Protocol-Wide Impact**: All NFT types (Art, Music, DomainNames, VirtualWorlds, TradingCards, Collectables, Sports, Utility, Badges) are affected equally, as they all use 2-character short names.

3. **No Workaround**: Users cannot bypass this issue without code changes. The validation happens before any NFT-specific logic executes.

4. **Ecosystem Breakdown**: Any dApps, marketplaces, or services built expecting to create NFT protocols through this contract are non-functional.

The impact goes beyond a simple bug - it represents a fundamental architectural incompatibility that prevents the NFT contract from serving its intended purpose.

## Likelihood Explanation

**Probability: 100%**

This vulnerability has maximum likelihood:

1. **Reachability**: The `Create()` method is public and callable by any user with valid input parameters.

2. **No Preconditions**: No special permissions, state setup, or timing requirements are needed. Any valid `CreateInput` triggers the failure.

3. **Deterministic Failure**: The symbol generation always produces 11+ character symbols, and the validation always checks against the 10-character limit. There is no randomness or conditional logic that could allow success.

4. **Universal Scope**: Affects all NFT types and all users equally. The test suite even expects 11-character symbols, revealing the design intent conflicts with the validation logic. [12](#0-11) 

## Recommendation

**Option 1: Add Separator to NFT Protocol Symbols**

Modify `GetSymbol()` to include the '-' separator so symbols are classified as NFT types:

```csharp
return $"{shortName}-{randomNumber}";
```

This would produce symbols like "AR-123456789" which would be classified as `SymbolType.NftCollection` and validated against the 30-character limit.

**Option 2: Use NFT-Specific Creation Method**

Have the NFT contract call TokenContract's NFT-specific creation methods that already handle NFT type validation correctly, rather than the generic Create method.

**Option 3: Adjust Validation Logic**

Modify TokenContract's symbol type detection to recognize NFT protocol symbols by checking if the symbol starts with a known NFT type short name, even without a separator.

**Recommended Approach**: Option 1 is the cleanest fix, as it aligns with the existing TokenContract design where NFT-related symbols use the '-' separator format. This would require minimal changes and maintains consistency with the rest of the NFT ecosystem.

## Proof of Concept

```csharp
[Fact]
public async Task NFTProtocolCreationFails_SymbolLengthMismatch()
{
    // Attempt to create NFT protocol with any valid input
    var createInput = new CreateInput
    {
        BaseUri = "ipfs://test/",
        Creator = DefaultAddress,
        IsBurnable = true,
        NftType = NFTType.Art.ToString(), // Will generate "AR" + 9-digit number
        ProtocolName = "TEST_PROTOCOL",
        TotalSupply = 1000000
    };
    
    // This call will fail with "Invalid token symbol length" error
    // because generated symbol "AR123456789" (11 chars) exceeds 
    // SymbolType.Token limit of 10 characters
    var exception = await Assert.ThrowsAsync<Exception>(
        async () => await NFTContractStub.Create.SendAsync(createInput)
    );
    
    Assert.Contains("Invalid token symbol length", exception.Message);
}
```

This test demonstrates that any attempt to create an NFT protocol through the standard `Create()` method will fail due to the symbol length validation mismatch. The generated symbol will always be at least 11 characters (2-char short name + 9-digit minimum number), but will be validated against the 10-character limit for Token type symbols.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L20-34)
```csharp
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L136-136)
```csharp
        Assert(input.ShortName.Length == 2, "Incorrect short name.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L7-7)
```csharp
    public const int SymbolMaxLength = 10;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L20-20)
```csharp
    public const int NFTSymbolMaxLength = 30;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-279)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L305-311)
```csharp
    private void CheckSymbolLength(string symbol, SymbolType symbolType)
    {
        if (symbolType == SymbolType.Token)
            Assert(symbol.Length <= TokenContractConstants.SymbolMaxLength, "Invalid token symbol length");
        if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
            Assert(symbol.Length <= TokenContractConstants.NFTSymbolMaxLength, "Invalid NFT symbol length");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L48-50)
```csharp
    private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
    {
        AssertValidCreateInput(input, symbolType);
```

**File:** test/AElf.Contracts.NFT.Tests/NFTContractTests.cs (L48-48)
```csharp
        symbol.Length.ShouldBe(11);
```
