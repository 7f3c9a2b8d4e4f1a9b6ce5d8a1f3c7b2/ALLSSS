### Title
Evil Miners Can Produce Blocks Despite Exceeding Missed Time Slots Threshold

### Summary
The `MiningPermissionValidationProvider` only verifies that a miner's public key exists in the `RealTimeMinersInformation` dictionary without checking their `MissedTimeSlots` count. Miners who have exceeded the `TolerableMissedTimeSlotsCount` threshold (4320 slots = 3 days) can still produce blocks and earn rewards until they are detected and marked as evil during `ProcessNextRound`, which occurs after block execution and validation.

### Finding Description

**Note:** The fields `IsForked` and `IsMined` mentioned in the security question do not exist in the `MinerInRound` protobuf definition. [1](#0-0) 

However, there is a legitimate disqualifying state that is not being validated: the `MissedTimeSlots` field.

**Root Cause:**

The `MiningPermissionValidationProvider.ValidateHeaderInformation()` performs only a dictionary key existence check: [2](#0-1) 

The validation comment explicitly states "Simply check keys of RealTimeMinersInformation should be enough," but this is insufficient because miners with `MissedTimeSlots >= TolerableMissedTimeSlotsCount` (defined as 4320) remain in the dictionary until the next round generation. [3](#0-2) 

**Execution Flow:**

1. During `ValidateBeforeExecution()`, the `MiningPermissionValidationProvider` is added to the validation chain: [4](#0-3) 

2. Validation occurs BEFORE block execution via `ValidateConsensusBeforeExecution()`: [5](#0-4) 

3. Evil miner detection happens AFTER block execution in `ProcessNextRound()`: [6](#0-5) 

4. The detection method checks the `MissedTimeSlots` field: [7](#0-6) 

5. Evil miners are only removed from `RealTimeMinersInformation` during the NEXT round generation: [8](#0-7) 

This creates a window where miners with `MissedTimeSlots >= 4320` can still pass validation and produce blocks.

### Impact Explanation

**Direct Fund Impact - Reward Misallocation:**

Miners who have exceeded the tolerable missed time slots threshold (3 days of inactivity) can still:
- Produce blocks during the current round
- Earn block rewards (configured as `InitialMiningRewardPerBlock = 12500000` tokens initially) [9](#0-8) 
- Potentially produce critical consensus blocks like `NextRound` or `NextTerm`

This violates the consensus protocol's economic incentive model, which should immediately prevent unreliable miners from earning additional rewards once they demonstrate sustained poor performance.

**Affected Parties:**
- Honest miners: lose potential rewards to evil miners who should be excluded
- Token holders: inflationary rewards distributed to undeserving miners
- Network: reduced consensus quality by allowing unreliable miners to participate

### Likelihood Explanation

**Attack Complexity:** Low to Medium

**Preconditions:**
1. Attacker must be a current miner in `RealTimeMinersInformation`
2. Attacker accumulates `MissedTimeSlots >= 4320` through intentional absence or poor performance
3. Attacker must have an assigned time slot in the current round before `NextRound` transition occurs

**Execution Steps:**
1. Miner deliberately misses time slots over multiple rounds (or suffers legitimate downtime)
2. Miner accumulates >= 4320 missed slots
3. Miner remains in current round's `RealTimeMinersInformation` dictionary
4. When miner's time slot arrives, miner comes back online
5. Miner produces block(s) - validation passes because key exists in dictionary
6. Miner earns block rewards
7. Only during subsequent `ProcessNextRound` is miner detected and marked as evil

**Feasibility:** High - This is the current behavior of the system, not an edge case. Any miner crossing the threshold can exploit this window.

**Economic Rationality:** Profitable - The cost is simply being offline/malicious for 3 days, but the miner can still earn rewards for blocks produced in that final window before detection.

### Recommendation

**Code-Level Mitigation:**

Modify `MiningPermissionValidationProvider.ValidateHeaderInformation()` to check the miner's `MissedTimeSlots` count:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    
    if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
    {
        validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
        return validationResult;
    }
    
    // Check if miner has exceeded tolerable missed time slots
    var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    if (minerInRound.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
    {
        validationResult.Message = $"Sender {validationContext.SenderPubkey} has exceeded tolerable missed time slots ({minerInRound.MissedTimeSlots} >= {AEDPoSContractConstants.TolerableMissedTimeSlotsCount}).";
        return validationResult;
    }

    validationResult.Success = true;
    return validationResult;
}
```

**Invariant to Enforce:**
Only miners with `MissedTimeSlots < TolerableMissedTimeSlotsCount` should pass mining permission validation.

**Test Cases:**
1. Verify that a miner with `MissedTimeSlots = 4319` can still produce blocks
2. Verify that a miner with `MissedTimeSlots = 4320` is rejected during validation
3. Verify that a miner with `MissedTimeSlots > 4320` cannot produce any consensus transaction
4. Ensure this check works across all consensus behaviors (UpdateValue, NextRound, NextTerm, TinyBlock)

### Proof of Concept

**Initial State:**
- Round N with miners A, B, C in `RealTimeMinersInformation`
- Miner A has `MissedTimeSlots = 4320` (or higher) due to prior absence
- Miner A is still in the current round's dictionary (not yet replaced)
- Current time approaches Miner A's assigned time slot

**Exploitation Steps:**

1. **Miner A produces block:** Despite having `MissedTimeSlots >= 4320`, Miner A produces a block with `UpdateValue` or `NextRound` behavior

2. **Validation passes:** 
   - `ValidateConsensusBeforeExecution()` is called
   - `MiningPermissionValidationProvider` checks: `RealTimeMinersInformation.Keys.Contains(MinerA.Pubkey)` â†’ TRUE
   - Validation succeeds without checking `MissedTimeSlots`

3. **Block executes:**
   - If `UpdateValue`: Miner A's state is updated, ProducedBlocks incremented, rewards earned [10](#0-9) 
   - If `NextRound`: Round transitions and evil miners are detected [6](#0-5) 

4. **Post-execution:**
   - Miner A is marked as evil in Election contract
   - Miner A will be replaced in next round generation
   - But Miner A has already earned rewards for the block(s) produced

**Expected Result:** Miner A should be rejected during validation before producing any blocks.

**Actual Result:** Miner A passes validation and earns block rewards despite being an evil miner.

**Success Condition:** The exploit is successful when a miner with `MissedTimeSlots >= TolerableMissedTimeSlotsCount` successfully produces a block and earns rewards.

### Citations

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L7-7)
```csharp
    public const long InitialMiningRewardPerBlock = 12500000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-75)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-252)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L337-338)
```csharp
                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
```
