# Audit Report

## Title
State Bloat DoS Through Unlimited TokenHolder Scheme Creation

## Summary
The `CreateScheme()` function in TokenHolderContract allows unlimited profit scheme creation without validation, causing permanent state bloat in the Profit contract. Each call creates a new scheme with a unique ID, but TokenHolder only tracks one scheme per address, orphaning all subsequent schemes. With no deletion mechanism and a 10 ELF cost per scheme, a well-funded attacker can create thousands of schemes, imposing permanent storage burden on all validators.

## Finding Description

The vulnerability exists in TokenHolder's `CreateScheme()` method, which lacks validation to prevent repeated calls. [1](#0-0) 

When called, it creates a new scheme in the Profit contract by sending a CreateSchemeInput with the sender as manager. [2](#0-1) 

TokenHolder then stores the scheme configuration locally using `Context.Sender` as the key, meaning it only maintains ONE scheme reference per address. [3](#0-2) 

In the Profit contract, each call to `CreateScheme()` generates a unique scheme ID based on the manager's current scheme count. [4](#0-3) 

The scheme ID increments with each call because it uses the count of existing schemes for that manager. [5](#0-4) 

Each scheme is permanently stored in `State.SchemeInfos[schemeId]`, and the scheme ID is added to the manager's list in `State.ManagingSchemeIds[scheme.Manager]`. [6](#0-5) 

Critically, the Profit contract's interface contains no method to delete schemes - only `RemoveSubScheme` exists for removing sub-schemes from parent schemes, not for deleting top-level schemes. [7](#0-6) 

When TokenHolder needs to retrieve a scheme, it queries the Profit contract for the first scheme ID in the manager's list. [8](#0-7) 

**Attack Sequence:**
1. Attacker calls `CreateScheme()` first time → Creates scheme1 in Profit, stores locally in TokenHolder
2. Attacker calls `CreateScheme()` second time → Creates scheme2 in Profit, overwrites local TokenHolder state
3. Attacker repeats N times → Creates schemeN in Profit each time
4. Result: Only scheme1 is functionally used (via `.FirstOrDefault()`), but all N schemes exist permanently in Profit contract state

## Impact Explanation

**Permanent State Bloat:**
Each orphaned scheme consumes permanent storage in the Profit contract's state, including the full `Scheme` object with virtual address, manager, total shares, current period, sub-schemes list, settings, and received token symbols. All validators must store and sync this data indefinitely.

**Quantified Impact:**
- Each scheme stores substantial data across multiple state mappings
- 1,000 orphaned schemes could consume megabytes of state storage
- 10,000 schemes would cost attacker 100,000 ELF but causes permanent validator storage burden
- No cleanup mechanism exists to remove orphaned schemes
- Affects query performance for all Profit contract interactions

**Severity Assessment - Medium:**
The attack requires significant capital (10 ELF per scheme as confirmed in the method fee configuration), providing economic deterrent. [9](#0-8) 

However, the impact is cumulative and permanent, degrading network performance over time if exploited at scale. While it doesn't directly steal funds or break consensus, the irreversible nature and network-wide impact justify Medium severity.

## Likelihood Explanation

**Reachability:** The `CreateScheme()` method is public and callable by any address without special permissions or checks.

**Attacker Capabilities:**
- Requires only an account with sufficient ELF balance
- No special privileges needed
- Simple repeated transaction submission

**Attack Complexity:**
- Trivial to execute: repeatedly call `CreateScheme()` with identical or varied parameters
- Fully automatable with a simple script
- No timing requirements or complex state manipulation

**Economic Feasibility:**
- Cost: 10 ELF per scheme creation
- Creating 1,000 schemes = 10,000 ELF
- Creating 10,000 schemes = 100,000 ELF
- While expensive, this is within reach of well-funded attackers
- The permanent network-wide burden may exceed attacker's costs

**Detection:** Repeated `CreateScheme` calls from the same address are visible on-chain but may not trigger immediate response if executed gradually over time.

## Recommendation

Add validation in `TokenHolderContract.CreateScheme()` to prevent multiple scheme creation:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add check for existing scheme
    var existingScheme = State.TokenHolderProfitSchemes[Context.Sender];
    Assert(existingScheme == null || existingScheme.Symbol == null, 
           "Scheme already exists for this address.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
    
    // Rest of implementation...
}
```

Alternatively, query Profit contract to check if schemes already exist for the sender before creating a new one.

## Proof of Concept

```csharp
[Fact]
public async Task StateBloa_MultipleSchemeCreation_Test()
{
    // Create first scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "TEST1",
        MinimumLockMinutes = 100
    });
    
    // Query Profit contract for schemes managed by Starter
    var schemeIds1 = await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = Starter });
    schemeIds1.SchemeIds.Count.ShouldBe(1);
    
    // Create second scheme - should create NEW scheme in Profit
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "TEST2",
        MinimumLockMinutes = 200
    });
    
    // Query again - count should increase to 2
    var schemeIds2 = await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = Starter });
    schemeIds2.SchemeIds.Count.ShouldBe(2); // VULNERABILITY: State bloat
    
    // Create third scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "TEST3",
        MinimumLockMinutes = 300
    });
    
    // Verify state bloat - 3 schemes now exist
    var schemeIds3 = await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = Starter });
    schemeIds3.SchemeIds.Count.ShouldBe(3); // CONFIRMED: Unlimited scheme creation
    
    // All schemes are stored permanently with no deletion mechanism
    foreach (var schemeId in schemeIds3.SchemeIds)
    {
        var scheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
        scheme.ShouldNotBeNull(); // Each scheme permanently consumes state
    }
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L290-293)
```csharp
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L60-71)
```csharp
        State.SchemeInfos[schemeId] = scheme;

        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```

**File:** protobuf/profit_contract.proto (L59-61)
```text
    // Remove sub scheme from a scheme.
    rpc RemoveSubScheme (RemoveSubSchemeInput) returns (google.protobuf.Empty) {
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L42-49)
```csharp
            case nameof(CreateScheme):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
```
