### Title
Missing Miner List Validation in NextTerm Allows Consensus Breakdown via Empty RealTimeMinersInformation

### Summary
The `NextTerm` method accepts deserialized `NextTermInput` from transactions without validating that `RealTimeMinersInformation` contains any miners. A malicious miner can craft a transaction with an empty miner map, passing all existing validation checks (term/round number increments and VRF proof), resulting in zero miners being registered for the next term and complete blockchain halt.

### Finding Description

The vulnerability exists in the term transition flow where `NextTermInput` is deserialized from transaction data and processed without adequate field validation.

**Entry Point**: The public `NextTerm(NextTermInput input)` method accepts the input parameter which is deserialized from transaction protobuf data. [1](#0-0) 

**Root Cause**: In `ProcessNextTerm`, the miner list is directly constructed from `nextRound.RealTimeMinersInformation.Keys` without any validation that this map is non-empty. [2](#0-1) 

The protobuf definition allows `real_time_miners_information` to be an empty map: [3](#0-2) 

**Insufficient Validation**: The validation layer only checks sequential term/round numbers but not miner list content. The `RoundTerminateValidationProvider` validates term/round number increments but has no check for empty miner lists. [4](#0-3) 

Term number validation: [5](#0-4) 

**Execution Path**: 
1. Attacker (current miner) passes `PreCheck` which only validates miner membership, not input integrity. [6](#0-5) 

2. Random number verification passes if attacker provides valid VRF proof. [7](#0-6) 

3. `SetMinerList` stores the empty list without validation, only checking if the term was already set. [8](#0-7) 

### Impact Explanation

**Consensus Breakdown**: Storing an empty miner list for the next term means zero miners are authorized to produce blocks, causing complete blockchain halt. No blocks can be produced, no transactions can be processed, and the chain becomes permanently stalled at the term boundary.

**Affected Parties**: All blockchain participants - validators lose rewards, users cannot transact, dApps become unavailable, and cross-chain operations fail.

**Severity**: CRITICAL - This breaks the fundamental consensus invariant that there must always be active miners. The damage is catastrophic and permanent without hard fork intervention, as no valid blocks can advance the chain past the corrupted term.

### Likelihood Explanation

**Attacker Capabilities**: 
- Must be a current miner (passes `PreCheck` authorization)
- Must generate valid VRF proof for `random_number` field (miners have this capability by design)
- Can submit transaction at any time before legitimate term transition

**Attack Complexity**: LOW
- Construct `NextTermInput` with correct `term_number` (current + 1) and `round_number` (current + 1)
- Set `real_time_miners_information` to empty map `{}`
- Generate valid VRF-based `random_number`
- Submit as regular transaction

**Feasibility**: HIGH - No special conditions required beyond being an active miner. The attacker can submit this malicious transaction during any block before the natural term transition, and if included before the legitimate NextTerm transaction, it will execute first and corrupt the miner list.

**Detection**: None - The transaction appears valid to all validation providers and passes all checks. Other nodes will accept and execute it.

**Economic Rationality**: A malicious or compromised miner could execute this to halt the chain. The attack cost is just transaction fees, making it economically feasible for griefing or ransom scenarios.

### Recommendation

**Immediate Fix**: Add miner list validation in `ProcessNextTerm` before storing:

```csharp
// After line 163 in ProcessNextTerm
Assert(nextRound.RealTimeMinersInformation.Count > 0, 
    "Miner list cannot be empty for new term.");

// Additional validation: ensure miners match Election Contract for main chain
if (State.IsMainChain.Value && State.ElectionContract.Value != null)
{
    var expectedVictories = State.ElectionContract.GetVictories.Call(new Empty());
    var expectedMinerSet = new HashSet<string>(
        expectedVictories.Value.Select(pk => pk.ToHex()));
    var providedMinerSet = new HashSet<string>(
        nextRound.RealTimeMinersInformation.Keys);
    
    Assert(expectedMinerSet.SetEquals(providedMinerSet),
        "Provided miner list does not match election results.");
}
```

**Validation Layer**: Enhance `RoundTerminateValidationProvider.ValidationForNextTerm` to validate miner list integrity:

```csharp
// Add to ValidationForNextTerm
if (extraData.Round.RealTimeMinersInformation.Count == 0)
    return new ValidationResult { Message = "Miner list cannot be empty." };
```

**Test Cases**: Add unit tests covering:
- NextTerm with empty RealTimeMinersInformation (should reject)
- NextTerm with miner list not matching Election Contract (should reject)  
- NextTerm with correct miner list (should succeed)

### Proof of Concept

**Initial State**:
- Current term: 100, round: 500
- Active miners: [M1, M2, M3]
- Attacker: M1 (valid miner)

**Attack Steps**:

1. M1 constructs malicious `NextTermInput`:
```
{
  term_number: 101,
  round_number: 501,
  real_time_miners_information: {},  // EMPTY
  confirmed_irreversible_block_height: <current_value>,
  confirmed_irreversible_block_round_number: <current_value>,
  blockchain_age: <current_value>,
  is_miner_list_just_changed: true,
  round_id_for_validation: <calculated>,
  random_number: <valid_VRF_proof_from_M1>
}
```

2. M1 submits transaction calling `NextTerm(input)`

3. Transaction execution:
   - `PreCheck()`: ✓ Passes (M1 is valid miner)
   - `TryToUpdateTermNumber(101)`: ✓ Passes (100 + 1 = 101)
   - `TryToUpdateRoundNumber(501)`: ✓ Passes (500 + 1 = 501)
   - `ECVrfVerify(random_number)`: ✓ Passes (M1's valid proof)
   - Line 189: `miners.Pubkeys` becomes empty list
   - `SetMinerList(empty_miners, 101)`: ✓ Succeeds, stores empty list
   - State updated: `State.MinerListMap[101]` = []

**Expected**: Transaction rejected due to empty miner list
**Actual**: Transaction succeeds, empty miner list stored

**Success Condition**: Query `GetCurrentMinerList` after term 101 begins returns empty list, no blocks can be produced in term 101+, blockchain halted.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L98-105)
```csharp
    private bool TryToUpdateTermNumber(long termNumber)
    {
        var oldTermNumber = State.CurrentTermNumber.Value;
        if (termNumber != 1 && oldTermNumber + 1 != termNumber) return false;

        State.CurrentTermNumber.Value = termNumber;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** protobuf/aedpos_contract.proto (L484-507)
```text
message NextTermInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producers’ expecting time (second).
    int64 round_id_for_validation = 10;
    // The random number.
    bytes random_number = 11;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```
