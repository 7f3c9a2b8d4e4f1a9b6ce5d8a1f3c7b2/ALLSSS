# Audit Report

## Title
Hex Encoding Case Sensitivity Causes Miner DoS Through Candidate Replacement

## Summary
The consensus contract's `RecordCandidateReplacement` method accepts pubkey strings without case normalization, while all block production and validation operations use lowercase hex strings from `.ToHex()`. A candidate admin can replace a miner's pubkey with an uppercase variant, causing the miner to be permanently unable to produce blocks due to dictionary key mismatches, resulting in consensus disruption.

## Finding Description

The vulnerability stems from inconsistent handling of pubkey string case across the Election and Consensus contracts. The AElf codebase consistently generates lowercase hex strings through the `ToHex()` method implementation [1](#0-0) , which uses arithmetic (`b + 0x37 + 0x20`) that produces lowercase 'a'-'f' characters.

However, the consensus contract's `RecordCandidateReplacement` method directly uses input pubkey strings as dictionary keys without any case normalization [2](#0-1) . When this method receives an uppercase pubkey string from the Election contract, it removes the old (lowercase) key and adds the new (uppercase) key to `RealTimeMinersInformation`.

During block production, the miner's pubkey is converted to lowercase via `ToHex()` [3](#0-2) , then directly accessed in the dictionary [4](#0-3) . This causes a `KeyNotFoundException` because the dictionary contains the uppercase key but the code looks for the lowercase key.

The validation system exhibits the same issue. The `SenderPubkey` property always returns lowercase hex [5](#0-4) , and the mining permission validator checks if this lowercase key exists in the dictionary [6](#0-5) .

The attack entry point is the Election contract's `ReplaceCandidatePubkey` method, which accepts arbitrary string pubkeys without any format validation or case normalization [7](#0-6) . The protobuf definition confirms pubkeys are simple strings with no constraints [8](#0-7) .

**Attack Sequence:**
1. Attacker (candidate admin) calls `ReplaceCandidatePubkey(oldPubkey="abc123...", newPubkey="ABC123...")`
2. Election contract calls consensus contract's `RecordCandidateReplacement`
3. Consensus contract removes "abc123..." and adds "ABC123..." to `RealTimeMinersInformation`
4. When miner attempts block production, `ToHex()` produces "abc123..." (lowercase)
5. Dictionary access fails with `KeyNotFoundException`
6. Block production and validation both fail, miner is DoS'd

## Impact Explanation

This vulnerability directly disrupts consensus operations with **HIGH** severity:

**Immediate Operational Impact:**
- Affected miner becomes permanently unable to produce blocks until the issue is manually corrected
- Unhandled `KeyNotFoundException` prevents block production entirely
- Mining permission validation fails, preventing consensus participation

**Consensus-Level Impact:**
- Miner misses all assigned time slots, causing block production delays
- Reduces effective miner count, concentrating consensus power among remaining miners
- If multiple miners are targeted, could significantly degrade network performance
- Creates consensus instability and reduces network liveness guarantees

**Affected Parties:**
- Any candidate/miner whose admin performs pubkey replacement with non-lowercase hex
- Can be triggered maliciously by a compromised or malicious admin
- Can occur accidentally if developers use uppercase hex strings from external tools

The severity is HIGH because it directly breaks the core protocol operation (block production) and cannot be recovered without manual intervention or another replacement transaction.

## Likelihood Explanation

This vulnerability has **MEDIUM-HIGH** likelihood of exploitation:

**Attacker Profile:**
- Requires candidate admin role, which is a legitimate, non-privileged position
- Any candidate can set their own admin address
- No special permissions or trusted role required

**Attack Complexity:**
- Extremely simple: single transaction to `ReplaceCandidatePubkey`
- Only requirement: provide uppercase hex string as new pubkey
- No timing constraints, race conditions, or complex state manipulation needed
- No economic barriers (only transaction fees)

**Feasibility:**
- Candidate being a current miner is a common operational scenario
- Admin permissions are granted by design for legitimate key rotation
- No special blockchain state or conditions required
- Attack can be executed at any time

**Accidental Trigger Risk:**
- Developers using external tools might copy uppercase hex strings
- No input validation prevents accidental misuse
- Error is not immediately apparent until next block production attempt

The combination of simple execution, legitimate attacker role, and potential for accidental triggering makes this a realistic threat to network stability.

## Recommendation

Implement case normalization in the consensus contract's `RecordCandidateReplacement` method:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");

    // Normalize case to lowercase
    var oldPubkey = input.OldPubkey?.ToLower();
    var newPubkey = input.NewPubkey?.ToLower();

    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(oldPubkey)) return new Empty();

    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[oldPubkey];
    realTimeMinerInformation.Pubkey = newPubkey;
    currentRound.RealTimeMinersInformation.Remove(oldPubkey);
    currentRound.RealTimeMinersInformation.Add(newPubkey, realTimeMinerInformation);
    if (currentRound.ExtraBlockProducerOfPreviousRound == oldPubkey)
        currentRound.ExtraBlockProducerOfPreviousRound = newPubkey;
    State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

    State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
    {
        OldPubkey = oldPubkey,
        NewPubkey = newPubkey,
        CurrentTermNumber = State.CurrentTermNumber.Value
    });

    return new Empty();
}
```

Additionally, add validation in the Election contract's `ReplaceCandidatePubkey` method to ensure pubkeys are lowercase hex strings before propagating them to the consensus contract. This provides defense-in-depth against similar issues.

## Proof of Concept

A test demonstrating the vulnerability would:

1. Set up a candidate as a current miner with lowercase pubkey "abc123..."
2. Call `ReplaceCandidatePubkey(oldPubkey="abc123...", newPubkey="ABC123...")`
3. Verify the consensus contract's `RealTimeMinersInformation` contains "ABC123..." (uppercase)
4. Attempt block production using the miner's key
5. Observe `KeyNotFoundException` when the code tries to access `RealTimeMinersInformation["abc123..."]` (lowercase from `ToHex()`)
6. Verify mining permission validation also fails with the same key mismatch

The test would confirm that a simple case mismatch in the replacement pubkey renders the miner unable to participate in consensus.

### Citations

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L38-41)
```csharp
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L140-143)
```csharp
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L23-23)
```csharp
        var pubkey = publicKeyBytes.ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L58-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L17-17)
```csharp
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-20)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** protobuf/election_contract.proto (L504-507)
```text
message ReplaceCandidatePubkeyInput {
    string old_pubkey = 1;
    string new_pubkey = 2;
}
```
