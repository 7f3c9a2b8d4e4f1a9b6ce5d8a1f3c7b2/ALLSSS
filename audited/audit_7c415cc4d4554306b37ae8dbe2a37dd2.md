### Title
Inconsistent Vote Counting Allows Governance Manipulation Through Member Removal

### Summary
The Association contract's `CheckEnoughVoteAndApprovals()` function contains a critical inconsistency: it filters approval, rejection, and abstention counts by current membership, but counts total votes without filtering. This allows an organization to retroactively change rejected proposals to releasable status by removing dissenting members, undermining governance integrity.

### Finding Description

The vulnerability exists in the threshold validation logic within `CheckEnoughVoteAndApprovals()`: [1](#0-0) 

The root cause is an inconsistency in how votes are counted:

1. **Filtered counts** (current members only):
   - Approvals: [2](#0-1) 
   - Rejections: [3](#0-2) 
   - Abstentions: [4](#0-3) 

2. **Unfiltered count** (all historical votes):
   - Total votes: [5](#0-4) 

This inconsistency is exploitable through the member removal mechanism: [6](#0-5) 

When `IsReleaseThresholdReached()` is called during proposal release, it applies these inconsistent filters: [7](#0-6) [8](#0-7) 

### Impact Explanation

**Governance Integrity Violation:** An organization can manipulate proposal outcomes by strategically removing members who voted against proposals. A proposal that was legitimately rejected can be retroactively made releasable.

**Concrete Attack Scenario:**
- Organization: 10 members (A-J), thresholds: `minimal_approval=4`, `maximal_rejection=3`, `minimal_vote=7`
- Proposal P1: 4 approve (A,B,C,D), 4 reject (E,F,G,H) → 4 rejections > 3 threshold → **REJECTED**
- Organization releases P2 to remove members E and F
- After removal, P1 validation: approvals=4 (≥4 ✓), rejections=2 (≤3 ✓), total_votes=8 (≥7 ✓) → **RELEASABLE**

**Severity:** Critical - undermines the fundamental governance mechanism, allowing proposals that failed democratic consensus to be executed through membership manipulation.

### Likelihood Explanation

**Attack Complexity:** Medium - requires coordinating two proposals:
1. The target proposal that gets rejected
2. A member removal proposal to eliminate dissenters

**Feasibility:** High - the attack uses standard contract methods:
- `RemoveMember()` is a legitimate governance function
- No special privileges required beyond normal proposal approval
- All steps executable within standard AElf contract semantics

**Realistic Scenario:** Organizations naturally evolve and remove inactive/malicious members. The vulnerability creates unintended side effects where historical proposals suddenly become valid. While intentional manipulation requires majority support, the inconsistency enables both accidental and deliberate governance subversion.

**Detection:** Difficult - the behavior appears as normal governance operations, with no explicit indicators of exploitation.

### Recommendation

**Fix the inconsistency** by making vote counting uniform. Apply current membership filtering to total vote count:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough = 
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter total votes by current membership
    var currentMemberVotes = proposal.Abstentions
        .Concat(proposal.Approvals)
        .Concat(proposal.Rejections)
        .Count(organization.OrganizationMemberList.Contains);
    
    var isVoteThresholdReached = 
        currentMemberVotes >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

**Alternative approach:** Clear/invalidate all pending proposals when membership changes occur, ensuring proposals are evaluated only with the membership that voted on them.

**Test cases:**
1. Verify rejected proposal remains rejected after removing dissenting members
2. Verify total vote threshold accounts for membership changes
3. Test edge cases with multiple sequential member removals

### Proof of Concept

**Initial State:**
- Create organization with 10 members: A,B,C,D,E,F,G,H,I,J
- Set thresholds: `minimal_approval_threshold=4`, `maximal_rejection_threshold=3`, `minimal_vote_threshold=7`

**Step 1 - Create and Reject Proposal P1:**
```
CreateProposal(P1, params...)
A.Approve(P1)
B.Approve(P1) 
C.Approve(P1)
D.Approve(P1)
E.Reject(P1)
F.Reject(P1)
G.Reject(P1)
H.Reject(P1)
```
- Total votes: 8
- Approvals: 4, Rejections: 4
- Status: 4 rejections > 3 threshold → **REJECTED**
- `A.Release(P1)` → **FAILS** with "Not approved"

**Step 2 - Remove Dissenting Members:**
```
CreateProposal(P2, target: RemoveMember, params: {E})
[Get P2 approved and released by majority]
CreateProposal(P3, target: RemoveMember, params: {F})  
[Get P3 approved and released by majority]
```
- Organization now has 8 members: A,B,C,D,G,H,I,J

**Step 3 - Release Previously Rejected P1:**
```
GetProposal(P1) → Shows ToBeReleased=true
A.Release(P1) → **SUCCESS**
```

**Expected:** P1 should remain rejected after member removals
**Actual:** P1 becomes releasable (approvals=4≥4, rejections=2≤3, total=8≥7)
**Success Condition:** P1 executes despite being rejected with 4 rejections in Step 1

### Notes

The original question asked whether "approved count can drop below threshold" - the answer is YES, and this correctly prevents release. However, the investigation revealed a more critical vulnerability: the REVERSE scenario where rejection count drops, allowing previously rejected proposals to become releasable due to inconsistent vote filtering logic.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-37)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-200)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-279)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
```
