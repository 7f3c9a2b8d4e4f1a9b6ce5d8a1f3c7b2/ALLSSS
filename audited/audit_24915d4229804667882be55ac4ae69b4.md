### Title
Missing Order Uniqueness Validation Allows Consensus Timing Disruption via Duplicate Miner Orders

### Summary
The `GetExtraBlockMiningTime()` method relies on `OrderBy().Last()` to identify the last miner by Order value, but no validation ensures Order uniqueness when Round information is stored. A malicious miner can submit a NextRoundInput with duplicate Order values (e.g., all miners with Order = 1), causing incorrect extra block timing calculations and disrupting consensus progression.

### Finding Description

The vulnerability exists in the Round validation and storage logic: [1](#0-0) 

The `GetExtraBlockMiningTime()` method uses `OrderBy(m => m.Value.Order).Last()` to determine when the extra block should be produced. When multiple miners share the same Order value, `.Last()` returns an arbitrary miner based on dictionary enumeration order rather than the intended last miner in the mining sequence. [2](#0-1) 

Similarly, `GetMiningInterval()` assumes at least one miner has Order = 2, but with duplicate orders (all Order = 1), it would select two arbitrary miners from the dictionary, calculating an incorrect mining interval.

**Root Cause:**

When round information is stored via `ProcessNextRound`, no validation ensures Order uniqueness: [3](#0-2) 

The only validation performed is `CheckRoundTimeSlots()`: [4](#0-3) 

This validation checks time slot intervals but does NOT verify Order uniqueness. A malicious round with all miners having Order = 1 would pass validation if ExpectedMiningTime values are properly distributed. [5](#0-4) 

**Execution Path:**

1. Authorized miner calls NextRound with crafted NextRoundInput
2. `ProcessNextRound` converts input to Round via `ToRound()`: [6](#0-5) 
3. TimeSlotValidationProvider validates but doesn't check Order uniqueness
4. Round stored without Order validation: [7](#0-6) 

### Impact Explanation

**Consensus Timing Disruption:**
- Extra block time calculated incorrectly, potentially scheduling it too early (overlapping with regular mining slots) or at an arbitrary incorrect time
- Mining interval calculated from two arbitrary miners instead of intended first and second miners
- BreakContinuousMining logic fails: [8](#0-7) 
  
  This expects a miner with `Order == minersCount`, returning null when all miners have Order = 1, skipping critical continuous mining prevention

**Protocol Impact:**
- Consensus round progression disrupted
- Extra block producer unable to produce at correct time
- Potential chain stalls or validation failures
- Temporary denial of service of consensus mechanism

**Affected Parties:**
- All network participants affected by consensus disruption
- Validators unable to produce blocks at correct times
- Users experiencing transaction delays

**Severity:** Medium - Requires miner authority but causes operational consensus disruption without direct fund theft.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an authorized miner (verified in PreCheck): [9](#0-8) 

**Attack Complexity:**
- Low - Miner crafts NextRoundInput with duplicate Order values and properly distributed ExpectedMiningTime to pass CheckRoundTimeSlots
- Submits via NextRound transaction during their designated turn

**Feasibility:**
- Miners rotate as extra block producers, giving each authorized miner opportunities to submit malicious rounds
- No economic detection mechanisms prevent this attack
- Round structure not validated against expected generation

**Detection Constraints:**
- Malicious round would pass all existing validations
- Impact only visible when extra block timing becomes incorrect
- No automated detection or rollback mechanism

**Probability:** Medium - Limited to miners but straightforward execution with operational impact.

### Recommendation

**Add Order Uniqueness Validation:**

1. Add validation method to Round class:
```csharp
public ValidationResult ValidateOrderUniqueness()
{
    var orders = RealTimeMinersInformation.Values.Select(m => m.Order).ToList();
    var distinctOrders = orders.Distinct().Count();
    
    if (distinctOrders != orders.Count)
        return new ValidationResult { 
            Message = "Duplicate Order values detected in round information" 
        };
    
    // Validate orders are sequential from 1 to minersCount
    var expectedOrders = Enumerable.Range(1, RealTimeMinersInformation.Count).ToHashSet();
    var actualOrders = orders.ToHashSet();
    
    if (!expectedOrders.SetEquals(actualOrders))
        return new ValidationResult { 
            Message = "Order values must be unique and range from 1 to miner count" 
        };
    
    return new ValidationResult { Success = true };
}
```

2. Call validation in ProcessNextRound before storing:
```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    // Add validation
    var orderValidation = nextRound.ValidateOrderUniqueness();
    Assert(orderValidation.Success, orderValidation.Message);
    
    // ... rest of method
}
```

3. Add similar validation in ProcessNextTerm

4. Add test cases verifying rejection of duplicate orders

### Proof of Concept

**Required Initial State:**
- Blockchain with active AEDPoS consensus
- Attacker is an authorized miner in current miner list
- Current round nearing completion, attacker designated as extra block producer

**Attack Steps:**

1. Attacker monitors consensus and waits for their turn to produce extra block and submit NextRound

2. Instead of calling legitimate round generation, attacker crafts malicious NextRoundInput:
   - Sets all miners' Order = 1
   - Sets ExpectedMiningTime values properly distributed (e.g., at intervals of 4000ms) to pass CheckRoundTimeSlots
   - Maintains other required fields

3. Attacker submits NextRound transaction with malicious input

4. Transaction passes PreCheck (attacker is authorized miner)

5. ProcessNextRound converts input to Round and stores without Order validation

6. CheckRoundTimeSlots passes (time intervals are correct)

**Expected Result:**
- Transaction should be rejected due to duplicate Order values

**Actual Result:**
- Transaction accepted and malicious round stored
- GetExtraBlockMiningTime() returns arbitrary time based on dictionary enumeration
- GetMiningInterval() calculates interval between arbitrary miners
- BreakContinuousMining logic skipped (no miner with Order == minersCount)
- Consensus timing disrupted, extra block scheduled incorrectly
- Subsequent round generation may fail or produce invalid results

**Success Condition:**
- Malicious round stored in State.Rounds
- GetExtraBlockMiningTime() returns time that doesn't match intended last miner's time + interval
- Consensus progression disrupted

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L117-122)
```csharp
    public Timestamp GetExtraBlockMiningTime()
    {
        return RealTimeMinersInformation.OrderBy(m => m.Value.Order).Last().Value
            .ExpectedMiningTime
            .AddMilliseconds(GetMiningInterval());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L93-107)
```csharp
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
```
