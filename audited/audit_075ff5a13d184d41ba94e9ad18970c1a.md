# Audit Report

## Title
Null Reference Exception in GetMaximumBlocksCount() Causes Consensus DoS During Abnormal Blockchain Status

## Summary
The `GetMaximumBlocksCount()` function accesses `MinedMinerListMap` entries without null checks, causing `NullReferenceException` when historical round data is missing. This crashes all consensus operations during abnormal blockchain status, creating a deadlock where the chain cannot recover from Last Irreversible Block (LIB) lag.

## Finding Description

The vulnerable code directly accesses `.Pubkeys` on `MinedMinerListMap` entries without null validation: [1](#0-0) 

**Root Cause Chain:**

When a key doesn't exist in `MappedState`, the indexer loads null bytes from state: [2](#0-1) 

These null bytes are deserialized, returning `default(T)` which is null for reference types like `MinerList`: [3](#0-2) 

**Evidence of Known Risk:**

The codebase contains defensive null checking for `MinedMinerListMap` in the same file: [4](#0-3) 

This proves developers are aware entries can be null, yet the protection is missing at the vulnerable lines.

**Trigger Conditions:**

The vulnerable path executes when abnormal blockchain status is detected: [5](#0-4) 

Abnormal status occurs when LIB round lags by 2+ rounds: [6](#0-5) 

**Execution Path:**

This function is invoked during all consensus operations: [7](#0-6) 

Affecting UpdateValue, NextRound, NextTerm, and TinyBlock transactions: [8](#0-7) 

**Recording Logic:**

`MinedMinerListMap` is only populated during round transitions: [9](#0-8) 

Called exclusively from NextRound and NextTerm: [10](#0-9) [11](#0-10) 

**State Definition:**

The state variable is defined as: [12](#0-11) 

**Initial Deployment:**

FirstRound initialization does NOT populate MinedMinerListMap: [13](#0-12) 

## Impact Explanation

**Critical Consensus DoS:**
- All consensus operations (`UpdateValue`, `NextRound`, `NextTerm`, `UpdateTinyBlockInformation`) throw unhandled exceptions and fail
- Block production completely halts during abnormal status
- The chain cannot recover from LIB lag, creating a permanent deadlock
- No graceful fallback or error handling exists

**Network-Wide Impact:**
- All miners cannot produce blocks
- All users cannot submit transactions  
- The entire blockchain halts during the most critical recovery period
- The vulnerability creates a catch-22: abnormal status requires recovery actions, but those actions crash

**Severity: High** because:
1. Causes complete consensus failure during stress conditions
2. No recovery mechanism - the exception prevents any progress
3. Affects core protocol functionality, not peripheral features
4. Breaks fundamental availability guarantees

## Likelihood Explanation

**Realistic Trigger Scenarios:**

1. **Contract Upgrade/Migration (Primary Scenario):**
   - Contract upgraded from version without `MinedMinerListMap` at round N
   - New contract state is empty (no historical data migration)
   - Blockchain continues from round N
   - Network stress causes LIB lag (common under load)
   - `MinedMinerListMap[N-1]` and `MinedMinerListMap[N-2]` return null
   - NullReferenceException thrown

2. **State Inconsistency:**
   - After chain rollbacks or consensus failures
   - Gaps appear in `MinedMinerListMap` recording
   - Abnormal status triggered during recovery
   - Crash prevents recovery

3. **Early Deployment Edge Cases:**
   - Initial rounds where historical data incomplete
   - Immediate abnormal status (e.g., imported LIB state)

**Attack Complexity:** None - this is a latent bug triggered by:
- System operations (contract upgrades)
- Natural stress conditions (LIB lag)
- No attacker interaction required

**Probability: Medium-High** because:
- Contract upgrades are common operational procedures
- Network stress causing LIB lag is realistic
- The combination of these conditions is foreseeable
- No defensive initialization or migration logic exists

## Recommendation

Add null checks before accessing `MinedMinerListMap` entries:

```csharp
if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
{
    var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)];
    var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)];
    
    // Add null checks
    if (previousRoundMinedMinerList == null || previousPreviousRoundMinedMinerList == null)
    {
        Context.LogDebug(() => "Missing historical MinedMinerListMap data, using default maximum blocks count");
        return AEDPoSContractConstants.MaximumTinyBlocksCount;
    }
    
    var minersOfLastTwoRounds = previousRoundMinedMinerList.Pubkeys
        .Intersect(previousPreviousRoundMinedMinerList.Pubkeys).Count();
    // ... rest of logic
}
```

Additionally, consider:
- Initializing `MinedMinerListMap` with dummy data during contract upgrades
- Adding migration logic to populate historical entries
- Implementing graceful degradation for missing state

## Proof of Concept

The vulnerability is proven through code analysis:

1. **State Returns Null:** `MappedState` indexer returns `SerializationHelper.Deserialize<MinerList>(null)` = `null` for non-existent keys (verified in MappedState.cs lines 95-99 and SerializationHelper.cs lines 88-91)

2. **No Null Check:** Lines 44-45 of GetMaximumBlocksCount.cs directly access `.Pubkeys` without validation

3. **Defensive Check Exists Elsewhere:** Line 234 of ProcessConsensusInformation.cs checks for null before removal, proving developers know it can be null

4. **Execution Path Confirmed:** Line 68 of ProcessConsensusInformation.cs calls `GetMaximumBlocksCount()` for ALL consensus operations

5. **Realistic Trigger:** Abnormal status (LIB lag by 2+ rounds) combined with contract upgrade leaving `MinedMinerListMap` empty

The complete execution path is traced and verified in the codebase. This vulnerability will deterministically crash consensus operations when:
- Contract is upgraded (no historical `MinedMinerListMap` data)
- Network experiences LIB lag (realistic under stress)
- Any consensus operation is attempted

No additional proof-of-concept test is required as the vulnerability is directly evident from the code structure and execution flow.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L42-42)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L44-45)
```csharp
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L123-125)
```csharp
            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L95-99)
```csharp
    private ValuePair LoadKey(TKey key)
    {
        var path = GetSubStatePath(key.ToString());
        var bytes = Provider.Get(path);
        var value = SerializationHelper.Deserialize<TEntity>(bytes);
```

**File:** src/AElf.Types/Helper/SerializationHelper.cs (L88-91)
```csharp
        public static T Deserialize<T>(byte[] bytes)
        {
            if (bytes == null)
                return default;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L68-68)
```csharp
        var minersCountInTheory = GetMaximumBlocksCount();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L112-112)
```csharp
        RecordMinedMinerListOfCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L165-165)
```csharp
        RecordMinedMinerListOfCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L223-230)
```csharp
    private void RecordMinedMinerListOfCurrentRound()
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        State.MinedMinerListMap.Set(currentRound.RoundNumber, new MinerList
        {
            Pubkeys = { currentRound.GetMinedMiners().Select(m => ByteStringHelper.FromHexString(m.Pubkey)) }
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L234-235)
```csharp
        if (removeTargetRoundNumber > 0 && State.MinedMinerListMap[removeTargetRoundNumber] != null)
            State.MinedMinerListMap.Remove(removeTargetRoundNumber);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L74-92)
```csharp
    public override Empty FirstRound(Round input)
    {
        /* Basic checks. */
        Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");

        /* Initial settings. */
        State.CurrentTermNumber.Value = 1;
        State.CurrentRoundNumber.Value = 1;
        State.FirstRoundNumberOfEachTerm[1] = 1;
        State.MiningInterval.Value = input.GetMiningInterval();
        SetMinerList(input.GetMinerList(), 1);

        AddRoundInformation(input);

        Context.LogDebug(() =>
            $"Initial Miners: {input.RealTimeMinersInformation.Keys.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-112)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }

    #endregion

    #region UpdateTinyBlockInformation

    public override Empty UpdateTinyBlockInformation(TinyBlockInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L46-46)
```csharp
    public MappedState<long, MinerList> MinedMinerListMap { get; set; }
```
