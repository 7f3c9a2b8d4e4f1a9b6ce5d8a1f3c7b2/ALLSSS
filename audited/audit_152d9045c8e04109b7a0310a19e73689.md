### Title
Removed Evil Miners Can Continue Validating as Current Miners via previousRound Inclusion

### Summary
The `ConvertAddressToPubkey()` function includes miners from both current and previous rounds in its search for pubkey-address mappings. When combined with insufficient validation in `IsCurrentMiner()` when `IsMinerListJustChanged` is true, removed evil miners can be validated as current miners, allowing them to perform privileged cross-chain operations despite being removed from the active miner list.

### Finding Description

The vulnerability exists in the interaction between two functions in `AEDPoSContract_ViewMethods.cs`:

**Root Cause 1 - Overly Permissive Address Conversion:**
The `ConvertAddressToPubkey()` function unconditionally adds miners from the previous round to its search space. [1](#0-0) 

It retrieves both `currentRound.RealTimeMinersInformation.Keys` and `previousRound.RealTimeMinersInformation.Keys`, then searches for a matching address. When an evil miner is removed from the current round during miner replacement, they are eliminated from `currentRound` but remain in the stored `previousRound` (State.Rounds[N]).

**Root Cause 2 - Conditional Validation Gap:**
The `IsCurrentMiner(string pubkey)` function only validates pubkey existence in the current round when `IsMinerListJustChanged` is false. [2](#0-1) 

When `IsMinerListJustChanged` is true (which occurs when evil miners are replaced), this critical check is completely skipped, and execution proceeds to line 150.

**Authorization Bypass Path:**
If the removed evil miner was the `ExtraBlockProducerOfPreviousRound` and the check at lines 150-155 passes (when `Context.CurrentBlockTime <= currentRound.GetRoundStartTime()`), the function returns `true`, validating the removed miner as current. [3](#0-2) 

**Miner Replacement Process:**
During round transitions, evil miners are identified and removed from the current round's miner list before generating the next round. [4](#0-3) 

However, the previous round data stored in State.Rounds remains unchanged and still contains the removed miner. [5](#0-4) 

**Exploitation Entry Point:**
The vulnerability is exploitable through the `CheckCrossChainIndexingPermission()` function, which directly calls `IsCurrentMiner()` to validate cross-chain operations. [6](#0-5) 

This is used by critical CrossChain contract operations that require current miner authorization. [7](#0-6) [8](#0-7) 

The CrossChain contract enforces this check via `AssertAddressIsCurrentMiner()`. [9](#0-8) 

### Impact Explanation

**Consensus Integrity Violation:**
Removed evil miners can bypass miner validation and continue performing privileged consensus-related operations. This directly violates the critical invariant that "miner schedule integrity" must be maintained at all times.

**Cross-Chain Security Compromise:**
The removed miner can call `ProposeCrossChainIndexing()` and `ReleaseCrossChainIndexingProposal()` functions, allowing them to:
- Propose malicious cross-chain block data
- Release cross-chain indexing proposals
- Potentially manipulate cross-chain verification and parent/side-chain information

**Authorization Bypass Window:**
The vulnerability is exploitable during the time window when:
1. A new round has just started (`IsMinerListJustChanged` is true)
2. Current block time is at or before the round start time
3. The removed miner was the extra block producer of the previous round

This window exists at every round transition where miner replacement occurs, making it a recurring vulnerability.

**Severity Justification:**
This is a **Critical** severity issue because:
- It allows removed malicious actors to maintain privileged access
- It compromises cross-chain security, which is fundamental to multi-chain integrity
- It defeats the purpose of the evil miner removal mechanism
- The attacker is already identified as "evil" but can continue operations

### Likelihood Explanation

**Attacker Capabilities:**
- The attacker is a miner who has been identified as evil by the election contract
- They still control their original address and can sign transactions
- They monitor round transitions to identify exploitation windows

**Preconditions (All Realistic):**
1. Evil miner M is identified and removed during round transition (happens by design when evil behavior is detected)
2. M was the extra block producer who terminated the previous round (1 in N miners chance, where N is miner count)
3. M attempts cross-chain operations immediately after the new round starts (before `currentBlockTime > roundStartTime`)

**Execution Practicality:**
The exploit is straightforward:
1. Evil miner M monitors their removal from the miner list
2. At the start of the next round (when `IsMinerListJustChanged` is true and they were the previous extra block producer)
3. M calls `ProposeCrossChainIndexing()` or `ReleaseCrossChainIndexingProposal()` from their address
4. `CheckCrossChainIndexingPermission()` validates them as a current miner despite removal
5. M successfully executes privileged cross-chain operations

**Detection Constraints:**
The attack is difficult to detect because:
- The validation function returns normally (no error/exception)
- The removed miner appears to be legitimately authorized
- The window is brief but recurring at every round transition with miner replacement

**Probability Assessment:**
- High likelihood: Evil miner removal is a routine occurrence in the consensus mechanism
- Medium opportunity window: Only when removed miner was the previous extra block producer
- Low complexity: Simple transaction execution, no complex setup required
- Overall: **Medium-High likelihood** with recurring opportunities

### Recommendation

**Immediate Fix:**
Modify `IsCurrentMiner(string pubkey)` to always validate pubkey existence in current round, regardless of `IsMinerListJustChanged` status:

```csharp
private bool IsCurrentMiner(string pubkey)
{
    if (pubkey == null) return false;
    
    if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;
    
    // CRITICAL FIX: Always check if pubkey is in current round
    if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
        return false;
    
    // ... rest of the function
}
```

**Alternative Fix:**
Modify `ConvertAddressToPubkey()` to only include previous round miners if they are also in the current round:

```csharp
private string ConvertAddressToPubkey(Address address)
{
    if (!TryToGetCurrentRoundInformation(out var currentRound)) return null;
    var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
    if (TryToGetPreviousRoundInformation(out var previousRound))
    {
        // Only add previous round miners who are still in current round
        possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys
            .Where(k => currentRound.RealTimeMinersInformation.ContainsKey(k)));
    }
    return possibleKeys.FirstOrDefault(k =>
        Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)) == address);
}
```

**Invariant to Add:**
Assert that any miner performing privileged operations must exist in the current round's active miner list, with no exceptions based on miner list change status.

**Test Cases:**
1. Test removed evil miner attempting cross-chain operations when they were previous extra block producer
2. Test removed evil miner attempting operations when they were not previous extra block producer (should throw exception currently)
3. Test legitimate previous round miner who is still in current round (should work)
4. Test all cross-chain permission checks with miner list changes

### Proof of Concept

**Initial State:**
- Round N active with miners [A, B, C, D, E]
- Miner E produces malicious blocks and is flagged as evil
- E produces the extra block that transitions Round N to Round N+1

**Exploitation Steps:**

1. **Round N → N+1 Transition:**
   - Election contract identifies E as evil via `GetMinerReplacementInformation()`
   - E is removed from current round: `currentRound.RealTimeMinersInformation.Remove(E)`
   - Alternative miner F replaces E
   - `GenerateNextRoundInformation()` creates Round N+1 with miners [A, B, C, D, F]
   - Round N+1 has `IsMinerListJustChanged = true`
   - E set as `ExtraBlockProducerOfPreviousRound` (because E terminated Round N)
   - State.Rounds[N] still contains E in its miner list

2. **Exploitation (at start of Round N+1, when `CurrentBlockTime <= RoundStartTime`):**
   - Evil miner E calls `ProposeCrossChainIndexing(maliciousData)` with their address
   - CrossChain contract calls `AssertAddressIsCurrentMiner(E's address)`
   - Consensus contract's `CheckCrossChainIndexingPermission(E's address)` is invoked
   - `IsCurrentMiner(E's address)` is called
   - `ConvertAddressToPubkey(E's address)` retrieves:
     - currentRound (N+1) keys: [A, B, C, D, F] ← E not present
     - previousRound (N) keys: [A, B, C, D, E] ← E present
     - Returns E's pubkey (found in previous round)
   - `IsCurrentMiner(E's pubkey)` executes:
     - Line 142-144 check SKIPPED (IsMinerListJustChanged = true)
     - Line 150-155 check: E == ExtraBlockProducerOfPreviousRound ✓ AND CurrentBlockTime <= RoundStartTime ✓
     - Returns TRUE
   - Assertion passes, E's cross-chain operation succeeds

**Expected Result:**
E's cross-chain operation should be rejected (E is not a current miner)

**Actual Result:**
E's cross-chain operation succeeds (E is validated as current miner)

**Success Condition:**
Transaction executes successfully and emits cross-chain indexing proposal event with E as the proposer, despite E being a removed evil miner.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L125-134)
```csharp
    private string ConvertAddressToPubkey(Address address)
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return null;
        var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
        if (TryToGetPreviousRoundInformation(out var previousRound))
            possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys);

        return possibleKeys.FirstOrDefault(k =>
            Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)) == address);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L142-144)
```csharp
        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L150-155)
```csharp
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-342)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L56-64)
```csharp
    private bool TryToGetPreviousRoundInformation(out Round previousRound)
    {
        previousRound = new Round();
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        if (roundNumber < 2) return false;
        var targetRoundNumber = roundNumber.Sub(1);
        previousRound = State.Rounds[targetRoundNumber];
        return !previousRound.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-291)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```
