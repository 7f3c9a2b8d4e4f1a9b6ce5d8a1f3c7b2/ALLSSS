### Title
Missing Validation Allows Division by Zero in Election Contract Initialization Leading to Complete DOS of Voting System

### Summary
The `InitialElectionContract` method lacks validation to ensure `TimeEachTerm` is non-zero before storing it in contract state. If a genesis deployer configures `PeriodSeconds = 0` in consensus options, the Election contract initializes with `TimeEachTerm = 0`, causing all subsequent voting operations to crash with `DivideByZeroException`, permanently disabling the election and consensus system.

### Finding Description
The vulnerability exists in the contract initialization flow: [1](#0-0) 

The `InitialElectionContract` method directly assigns `input.TimeEachTerm` to `State.TimeEachTerm.Value` without validating that the value is positive. This value originates from `ConsensusOptions.PeriodSeconds`: [2](#0-1) 

While `PeriodSeconds` has a default value of 604800 seconds (7 days): [3](#0-2) 

This default can be overridden via configuration with no validation. If set to zero, division operations fail at two critical locations:

**Location 1 - GetEndPeriod:** [4](#0-3) 

**Location 2 - ExtendVoterWelfareProfits:** [5](#0-4) 

The `.Div()` extension method throws `DivideByZeroException` when the divisor is zero, as confirmed by the test suite: [6](#0-5) 

### Impact Explanation
This vulnerability causes **complete operational failure** of the election and voting system:

1. **Vote() Method DOS**: When users attempt to vote via the `Vote` method, it calls `AddBeneficiaryToVoter` at line 443: [7](#0-6) 
   
   Which calls `GetEndPeriod` at line 379: [8](#0-7) 
   
   This crashes with `DivideByZeroException`, preventing ALL voting operations.

2. **ChangeVotingOption() Method DOS**: Voters cannot change their voting targets because `ExtendVoterWelfareProfits` crashes at line 133.

3. **Consensus System Failure**: Without functioning elections, the blockchain cannot elect validators or maintain the consensus mechanism, rendering the entire network non-operational.

4. **Irreversible**: The initialization can only occur once due to the check at line 24, so this misconfiguration is permanent and requires chain redeployment to fix.

### Likelihood Explanation
**Preconditions Required:**
- Genesis deployer must configure `Consensus:PeriodSeconds = 0` in appsettings.json or provide zero value during initialization
- This configuration gets passed through the initialization pipeline without validation

**Attack Complexity:** LOW
- Simple configuration change in deployment settings
- No cryptographic or complex exploitation required
- Affects any deployment (mainchain, sidechain, test networks)

**Realistic Scenarios:**
1. **Misconfiguration**: Operator error during deployment (sets 0 instead of 604800)
2. **Malicious Sidechain Deployer**: Intentional sabotage of a sidechain election system
3. **Test Environment Mistake**: Test configuration accidentally deployed to production

**Probability:** MEDIUM-HIGH for sidechains and private deployments where configuration control is less rigorous than public mainnets.

### Recommendation
Add explicit validation in `InitialElectionContract` to ensure `TimeEachTerm` is positive:

```csharp
public override Empty InitialElectionContract(InitialElectionContractInput input)
{
    Assert(!State.Initialized.Value, "Already initialized.");
    
    // ADD THIS VALIDATION
    Assert(input.TimeEachTerm > 0, "TimeEachTerm must be greater than zero.");
    Assert(input.MinimumLockTime > 0, "MinimumLockTime must be greater than zero.");
    Assert(input.MaximumLockTime >= input.MinimumLockTime, 
        "MaximumLockTime must be greater than or equal to MinimumLockTime.");
    
    State.Candidates.Value = new PubkeyList();
    State.MinimumLockTime.Value = input.MinimumLockTime;
    State.MaximumLockTime.Value = input.MaximumLockTime;
    State.TimeEachTerm.Value = input.TimeEachTerm;
    // ... rest of initialization
}
```

Additionally, add validation in `ConsensusOptions` configuration binding or use `IValidateOptions<ConsensusOptions>` to enforce positive values at the configuration layer.

**Test Cases to Add:**
1. Test that `InitialElectionContract` rejects `TimeEachTerm = 0`
2. Test that `InitialElectionContract` rejects negative values
3. Integration test verifying Vote() succeeds after proper initialization

### Proof of Concept

**Required Initial State:**
- Fresh blockchain deployment with uninitialized Election contract

**Attack Steps:**

1. **Configure genesis with malicious/misconfigured value:**
   - Set `Consensus:PeriodSeconds = 0` in appsettings.json
   - Deploy blockchain with this configuration

2. **Genesis initialization executes:**
   - `ElectionContractInitializationProvider` reads `PeriodSeconds = 0`
   - Calls `InitialElectionContract` with `TimeEachTerm = 0`
   - No validation occurs, `State.TimeEachTerm.Value` set to 0

3. **Attempt normal voting operation:**
   - User calls `Vote(candidatePubkey, amount, lockTime)`
   - Transaction proceeds through vote logic
   - Reaches `AddBeneficiaryToVoter` → `GetEndPeriod`
   - Executes `lockTime.Div(State.TimeEachTerm.Value)` → `lockTime.Div(0)`
   - **Result**: `DivideByZeroException` thrown, transaction fails

4. **Verify complete DOS:**
   - ALL vote attempts fail
   - ChangeVotingOption attempts fail
   - Election system permanently disabled

**Expected vs Actual Result:**
- **Expected**: Initialization should reject `TimeEachTerm = 0` with clear error message
- **Actual**: Initialization succeeds, all voting operations crash permanently

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L22-31)
```csharp
    public override Empty InitialElectionContract(InitialElectionContractInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");

        State.Candidates.Value = new PubkeyList();

        State.MinimumLockTime.Value = input.MinimumLockTime;
        State.MaximumLockTime.Value = input.MaximumLockTime;

        State.TimeEachTerm.Value = input.TimeEachTerm;
```

**File:** src/AElf.GovernmentSystem/ElectionContractInitializationProvider.cs (L36-41)
```csharp
                Params = new InitialElectionContractInput
                {
                    MaximumLockTime = _economicOptions.MaximumLockTime,
                    MinimumLockTime = _economicOptions.MinimumLockTime,
                    TimeEachTerm = _consensusOptions.PeriodSeconds,
                    MinerList = { _consensusOptions.InitialMinerList },
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/ConsensusOptions.cs (L12-12)
```csharp
    public long PeriodSeconds { get; set; } = 604800;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L126-137)
```csharp
    private void ExtendVoterWelfareProfits(Hash voteId)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);

        // Extend endPeriod from now no, so the lockTime will *NOT* be changed.
        var lockTime = State.LockTimeMap[voteId];
        var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
        if (lockPeriod == 0)
        {
            return;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-382)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L443-443)
```csharp
        AddBeneficiaryToVoter(GetVotesWeight(input.Amount, lockSeconds), lockSeconds, voteId);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L612-616)
```csharp
    private long GetEndPeriod(long lockTime)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        return lockTime.Div(State.TimeEachTerm.Value).Add(treasury.CurrentPeriod);
    }
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L50-51)
```csharp
        Should.Throw<DivideByZeroException>(() => { number1.Div(0); });
        Should.Throw<DivideByZeroException>(() => { number2.Div(0); });
```
