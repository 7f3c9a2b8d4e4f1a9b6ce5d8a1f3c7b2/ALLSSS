### Title
Missing Signature-to-Order Validation Allows Miners to Manipulate Next Round Mining Order

### Summary
The AEDPoS consensus mechanism fails to validate that miners' `SupposedOrderOfNextRound` values match their cryptographic signatures when processing `UpdateValue` transactions. A malicious miner can arbitrarily set their mining order to 1 (first position) in every round and manipulate other miners' positions via `TuneOrderInformation`, breaking consensus fairness and enabling MEV extraction advantages.

### Finding Description

The vulnerability exists in the `UpdateValue` transaction processing flow:

**Root Cause**: The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue` fields but does NOT verify that `SupposedOrderOfNextRound` matches the cryptographic calculation `GetAbsModulus(signature.ToInt64(), minersCount) + 1`. [1](#0-0) 

**Normal Flow**: When consensus data is honestly generated, `ApplyNormalConsensusData` correctly calculates the order from the signature using modulus operation: [2](#0-1) 

**Exploitation Point**: However, in `ProcessUpdateValue`, the order values from `UpdateValueInput` are directly stored to state WITHOUT any validation that they match the signature: [3](#0-2) 

Additionally, miners can manipulate OTHER miners' `FinalOrderOfNextRound` via unvalidated `TuneOrderInformation` dictionary.

**Order Usage in Next Round**: The manipulated `FinalOrderOfNextRound` values directly determine mining order in the next round: [4](#0-3) 

**Why Existing Protections Fail**:
- `RecoverFromUpdateValue` is only used during validation to reconstruct round state for comparison, but doesn't validate order correctness [5](#0-4) 

- `NextRoundMiningOrderValidationProvider` validates order uniqueness but only for `NextRound` behavior, not `UpdateValue` [6](#0-5) 

### Impact Explanation

**Consensus Integrity Breach**: The vulnerability breaks a critical consensus invariant - that mining order must be deterministically derived from signatures to ensure randomness and fairness. This undermines the entire security model of AEDPoS.

**MEV Extraction**: Mining first in every round provides:
- First access to profitable transactions in the mempool
- Transaction ordering control within blocks for front-running/back-running
- Priority in including high-fee transactions
- Ability to observe other miners' consensus data before producing own block

**Reward Misallocation**: While individual block rewards are equal, consistently mining first provides subtle advantages:
- Transaction fee collection from high-value transactions before others [7](#0-6) 

- Increased `ProducedBlocks` count over time if combined with other timing advantages
- Extra block producer selection benefits (calculated from first miner's signature) [8](#0-7) 

**Multi-Miner Collusion**: Multiple malicious miners can coordinate to claim sequential orders (1, 2, 3...) and manipulate legitimate miners to later positions via `TuneOrderInformation`, creating mining cartels that dominate block production timing.

### Likelihood Explanation

**Attacker Capabilities**: Any active miner in the current consensus round can exploit this - no special privileges beyond existing miner status required.

**Attack Complexity**: Low
1. Craft `UpdateValueInput` with `SupposedOrderOfNextRound = 1`
2. Submit via standard `UpdateValue` transaction during mining turn
3. No cryptographic breaking or complex manipulation needed

**Feasibility Conditions**:
- Attacker must be an elected miner (realistic - election is public)
- Must wait for their time slot in current round (guaranteed if miner)
- No special network conditions or timing attacks required

**Detection Difficulty**: Without validators checking the signature-to-order mathematical relationship, this manipulation appears as legitimate consensus data. The `BreakContinuousMining` function provides minor mitigation by preventing consecutive extra block production, but doesn't stop the core order manipulation: [9](#0-8) 

**Economic Rationality**: The exploit cost is minimal (only gas for the `UpdateValue` transaction), while benefits accumulate over many rounds through MEV and fee advantages.

### Recommendation

**Immediate Fix**: Add signature-to-order validation in `UpdateValueValidationProvider`:

```csharp
private bool ValidateSupposedOrderOfNextRound(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    var signature = minerInRound.Signature;
    var minersCount = validationContext.BaseRound.RealTimeMinersInformation.Count;
    
    var expectedOrder = GetAbsModulus(signature.ToInt64(), minersCount) + 1;
    
    if (minerInRound.SupposedOrderOfNextRound != expectedOrder)
        return false;
        
    // Also validate that initially FinalOrderOfNextRound equals SupposedOrderOfNextRound
    if (minerInRound.FinalOrderOfNextRound != minerInRound.SupposedOrderOfNextRound)
        return false;
        
    return true;
}
```

Call this method in `UpdateValueValidationProvider.ValidateHeaderInformation()` before returning success.

**TuneOrderInformation Validation**: Validate that `TuneOrderInformation` only contains legitimate conflict resolutions:
- Only include miners whose `SupposedOrderOfNextRound` conflicts with already-assigned orders
- Verify conflict resolution follows the deterministic algorithm from `ApplyNormalConsensusData`
- Ensure no miner's order is tuned to a value that creates new conflicts

**Invariant Enforcement**: Add assertion in `ProcessUpdateValue` after line 260:
```csharp
// Verify no duplicate FinalOrderOfNextRound values
var distinctOrders = currentRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
Assert(distinctOrders == currentRound.RealTimeMinersInformation.Values.Count(m => m.SupposedOrderOfNextRound > 0),
    "Duplicate mining orders detected");
```

**Test Cases**:
1. Test that `UpdateValue` with incorrect `SupposedOrderOfNextRound` is rejected
2. Test that malicious `TuneOrderInformation` creating duplicates is rejected
3. Test legitimate conflict resolution still works
4. Fuzz test with various signature values to ensure order calculation cannot be bypassed

### Proof of Concept

**Initial State**:
- Blockchain with 7 active miners (M1-M7)
- Current round N with attacker as miner M3
- M3's legitimate order calculation from signature would be 5

**Attack Sequence**:

**Transaction 1** - M3's normal mining turn:
```
UpdateValue({
    Signature: <M3's valid signature>,
    OutValue: <M3's valid outvalue>,
    SupposedOrderOfNextRound: 1,  // MALICIOUS: should be 5
    FinalOrderOfNextRound: 1,      // Claimed first position
    TuneOrderInformation: {
        "M1_pubkey": 7,  // Push legitimate first miner to last
        "M7_pubkey": 5   // Shuffle others down
    },
    // ... other legitimate fields
})
```

**Expected Result (Secure System)**:
- Validation should reject: "SupposedOrderOfNextRound does not match signature calculation"
- State remains unchanged

**Actual Result (Vulnerable System)**:
- Validation passes (only checks OutValue/Signature fields) [10](#0-9) 

- State updated with malicious orders
- M3's `SupposedOrderOfNextRound` set to 1 instead of 5
- M1's `FinalOrderOfNextRound` changed to 7
- M7's `FinalOrderOfNextRound` changed to 5

**Transaction 2** - Next round generation (any miner):
```
NextRound(<automatically generated round>)
```

**Result**:
- `GenerateNextRoundInformation` sorts miners by `FinalOrderOfNextRound`
- M3 assigned `Order = 1` in round N+1
- M3 mines first in next round despite signature indicating they should mine 5th

**Success Condition**: M3 consistently appears as first miner in multiple consecutive rounds by repeating this attack, accumulating MEV advantages while legitimate random ordering is subverted.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-260)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L25-36)
```csharp
        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-90)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L867-895)
```csharp
    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
        var claimTransactionExecuteHeight = State.ClaimTransactionFeeExecuteHeight.Value;

        Assert(claimTransactionExecuteHeight < Context.CurrentHeight,
            $"This method already executed in height {State.ClaimTransactionFeeExecuteHeight.Value}");
        State.ClaimTransactionFeeExecuteHeight.Value = Context.CurrentHeight;
        Context.LogDebug(() => $"Claim transaction fee. {input}");
        State.LatestTotalTransactionFeesMapHash.Value = HashHelper.ComputeFrom(input);
        foreach (var bill in input.Value)
        {
            var symbol = bill.Key;
            var amount = bill.Value;
            ModifyBalance(Context.Self, symbol, amount);
            Context.Fire(new TransactionFeeClaimed
            {
                Symbol = symbol,
                Amount = amount,
                Receiver = Context.Self
            });
            
            TransferTransactionFeesToFeeReceiver(symbol, amount);
        }

        Context.LogDebug(() => "Finish claim transaction fee.");

        return new Empty();
    }
```
