### Title
Critical State Initialization Vulnerability in AEDPoS Contract Upgrade Path

### Summary
The AEDPoS consensus contract contains a critical flaw where `State.MinerIncreaseInterval` cannot be properly initialized after a contract upgrade due to incorrect validation logic in `SetMinerIncreaseInterval`. Additionally, `State.MaximumMinersCount` is never initialized for side chains, remaining at the default value of 0, which causes incorrect behavior in miner count calculations.

### Finding Description

**Root Cause 1: Flawed Validation Prevents MinerIncreaseInterval Recovery**

The `SetMinerIncreaseInterval` method contains validation logic that only allows DECREASING the interval value: [1](#0-0) 

If `State.MinerIncreaseInterval.Value` is uninitialized (defaults to 0) after a contract upgrade that adds this state variable, the assertion `Assert(input.Value <= 0)` means only zero or negative values are accepted. The proper value (e.g., 31,536,000 seconds = 1 year) cannot be set.

When `GetAutoIncreasedMinersCount` is subsequently called, it performs division by the uninitialized interval: [2](#0-1) 

This causes a `DivideByZeroException`, breaking all functionality that depends on miner count calculations including `GetMaximumMinersCount`, `GetMinersCount`, and `SetMaximumMinersCount`.

**Root Cause 2: Re-initialization Prevented**

The `InitialAElfConsensusContract` method is the only place where these state variables are properly initialized: [3](#0-2) 

However, re-initialization is blocked by the guard: [4](#0-3) 

Once `State.Initialized.Value` is true, the method cannot be called again, leaving no path to initialize new state variables added in an upgrade.

**Root Cause 3: Side Chain MaximumMinersCount Never Initialized**

For side chains, `InitialAElfConsensusContract` returns early before initializing `MaximumMinersCount`: [5](#0-4) 

The initialization of `State.MaximumMinersCount.Value` only occurs for main chains: [6](#0-5) 

This leaves `State.MaximumMinersCount.Value` at 0 for all side chains. When used in `GetMinersCount`: [7](#0-6) 

The `Math.Min(..., 0)` always returns 0, producing incorrect results.

### Impact Explanation

**Operational Impact - Complete Consensus Failure:**
1. If `MinerIncreaseInterval` is uninitialized (0), any call to `GetMaximumMinersCount` triggers division by zero
2. This breaks `SetMaximumMinersCount` which calls `GetMinersCount` at line 25: [8](#0-7) 
3. Consensus operations in `ProcessNextRound` fail when calling `GetMinersCount`: [9](#0-8) 
4. The Election Contract receives incorrect miner counts, corrupting the entire miner list

**Consensus Integrity Impact:**
- Miner count calculations return 0 instead of actual values
- Election contract receives corrupted miner count updates
- Consensus round progression may fail

**Affected Parties:**
- Main chains upgrading from versions without these state variables
- All side chains (MaximumMinersCount permanently 0)
- Network validators unable to participate in consensus

### Likelihood Explanation

**Attacker Capabilities:** Not required - this is a design flaw affecting legitimate upgrade scenarios.

**Attack Complexity:** N/A - automatically triggered during:
1. Contract upgrade that adds these state variables
2. Any call to `SetMaximumMinersCount` or `GetMaximumMinersCount` post-upgrade

**Feasibility Conditions:**
- Contract deployed with older version lacking these state variables
- Contract upgraded to current version
- No migration script provided to initialize new states
- For side chains: occurs immediately upon deployment (MaximumMinersCount never initialized)

**Probability:** HIGH
- Side chain issue is 100% reproducible in current codebase
- Upgrade scenario highly likely as blockchain evolves
- No mitigation mechanism exists in current code

### Recommendation

**1. Fix SetMinerIncreaseInterval Validation:**
Change the validation logic to allow proper initialization:
```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Invalid interval - must be positive");
    // Remove or fix: Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    // If preventing increases is intentional, allow override when current value is 0:
    Assert(State.MinerIncreaseInterval.Value == 0 || input.Value <= State.MinerIncreaseInterval.Value, 
        "Can only decrease interval unless uninitialized");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

**2. Add Migration Method:**
Implement a one-time migration method callable by governance:
```csharp
public override Empty MigrateUninitializedStates(MigrationInput input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress, "No permission");
    
    if (State.MinerIncreaseInterval.Value == 0)
        State.MinerIncreaseInterval.Value = input.MinerIncreaseInterval;
    
    if (State.MaximumMinersCount.Value == 0)
        State.MaximumMinersCount.Value = input.MaximumMinersCount;
    
    return new Empty();
}
```

**3. Fix Side Chain Initialization:**
Initialize `MaximumMinersCount` for side chains before the early return: [5](#0-4) 

Add before line 40:
```csharp
State.MaximumMinersCount.Value = int.MaxValue; // Unlimited miners for side chains
```

**4. Add Division by Zero Protection:**
Add validation before division operations: [10](#0-9) 

Add assertion:
```csharp
Assert(State.MinerIncreaseInterval.Value > 0, "MinerIncreaseInterval not initialized");
```

### Proof of Concept

**Scenario 1: Side Chain Uninitialized MaximumMinersCount**

Initial State:
- Deploy side chain with current codebase
- `InitialAElfConsensusContract` called with `IsSideChain = true`
- `State.MaximumMinersCount.Value` remains 0

Transaction Steps:
1. Call `GetMaximumMinersCount()` on side chain
2. Observe: Returns 0 instead of expected unlimited value

Expected Result: Should return `int.MaxValue` or calculated auto-increased count  
Actual Result: Returns 0 due to `Math.Min(calculated_value, 0)`

**Scenario 2: Post-Upgrade MinerIncreaseInterval Cannot Be Set**

Initial State:
- Contract Version 1 deployed (without MinerIncreaseInterval state)
- Contract upgraded to Version 2 (with MinerIncreaseInterval)
- `State.MinerIncreaseInterval.Value` = 0 (uninitialized)

Transaction Steps:
1. Parliament attempts to call `SetMinerIncreaseInterval(31536000)` to initialize
2. Line 61 validation: `Assert(31536000 <= 0, "Invalid interval")` fails
3. Transaction reverts

Expected Result: Should allow setting proper value for uninitialized state  
Actual Result: Cannot set any positive value, state remains corrupted at 0

**Scenario 3: Division by Zero on GetMaximumMinersCount**

Initial State:
- `State.MinerIncreaseInterval.Value` = 0 (from Scenario 2)

Transaction Steps:
1. Call `GetMaximumMinersCount()`
2. Executes `GetAutoIncreasedMinersCount()`
3. Line 94: `.Div(0)` triggers `DivideByZeroException`
4. Transaction fails, contract becomes unusable

Success Condition for Exploit: Contract upgrade introduces uninitialized states, and setter validation prevents proper initialization, permanently breaking consensus functionality.

### Notes

Side chains deployed with the current codebase exhibit the uninitialized `MaximumMinersCount` issue immediately, making this a present vulnerability rather than hypothetical. The upgrade scenario for `MinerIncreaseInterval` represents a critical upgrade path vulnerability that would permanently break the contract if these states were added in a new version without proper migration logic.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L25-25)
```csharp
            MinersCount = GetMinersCount(round)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L61-61)
```csharp
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L22-31)
```csharp
    public override Empty InitialAElfConsensusContract(InitialAElfConsensusContractInput input)
    {
        Assert(State.CurrentRoundNumber.Value == 0 && !State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        State.PeriodSeconds.Value = input.IsTermStayOne
            ? int.MaxValue
            : input.PeriodSeconds;

        State.MinerIncreaseInterval.Value = input.MinerIncreaseInterval;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L37-40)
```csharp
        if (input.IsTermStayOne || input.IsSideChain)
        {
            State.IsMainChain.Value = false;
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L52-52)
```csharp
        State.MaximumMinersCount.Value = int.MaxValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L128-128)
```csharp
                var minersCount = GetMinersCount(nextRound);
```
