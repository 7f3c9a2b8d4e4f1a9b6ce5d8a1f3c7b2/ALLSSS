### Title
Zero ResourceAmount Allows Side Chains to Bypass Rental Fees Completely

### Summary
The `UpdateRentedResources` function validates that ResourceAmount values are non-negative (>= 0) but does not enforce a minimum positive value. When ResourceAmount is set to zero, the `PayRental` function calculates zero rental charges regardless of the rental unit price or duration, allowing side chains to use resources (CPU, RAM, DISK, NET) completely free of charge. This breaks the economic model for side chain resource pricing and causes direct loss of rental revenue to the main chain.

### Finding Description
The vulnerability exists in the rental calculation logic and the parameter validation for resource amounts.

In the `PayRental` function, rental charges are calculated using the formula at [1](#0-0) . This multiplication results in zero rental whenever `State.ResourceAmount[symbol]` is zero, regardless of the duration or rental unit price.

The root cause is in the `UpdateRentedResources` function's validation logic at [2](#0-1) , which explicitly allows zero values by checking `>= 0` instead of `> 0`. This validation weakness enables authorized parties to set ResourceAmount to zero.

The ResourceAmount state variable is defined at [3](#0-2)  and represents the amount of resources consumed per minute. When initialized through [4](#0-3) , it can be set to any non-negative value, and subsequently updated via the vulnerable validation path.

No additional checks exist in the PayRental execution flow at [5](#0-4)  to prevent zero resource amounts from resulting in zero rental charges.

### Impact Explanation
**Direct Financial Impact:**
- Side chains can completely avoid rental fees for resource usage (CPU, RAM, DISK, NET tokens)
- Main chain loses all rental revenue from affected side chains
- The rental calculation becomes: `duration × 0 × Rental[symbol] = 0`

**Economic Model Breakdown:**
- Violates the intended resource pricing mechanism where side chains pay based on consumption
- Creates unfair advantage for side chains that exploit this vs. legitimate paying side chains
- Undermines the sustainability of the side chain resource allocation system

**Affected Parties:**
- Main chain treasury loses rental income
- Legitimate side chains face unfair competition
- The overall AElf economic model for side chain resources is compromised

**Severity Justification:**
HIGH - Direct, quantifiable financial loss with clear exploitation path. While authorization is required, the validation explicitly permits the vulnerable state, suggesting this is an oversight rather than intentional design.

### Likelihood Explanation
**Attacker Capabilities Required:**
The exploitation requires approval from the Side Chain Rental Controller, which is an Association organization requiring signatures from both the Parliament default organization and the side chain creator, as defined at [6](#0-5) . The authorization check is enforced at [7](#0-6) .

**Attack Complexity:**
LOW to MEDIUM - Once governance approval is obtained, the attack is a simple parameter update:
1. Create governance proposal to call `UpdateRentedResources` with zero values
2. Obtain required approvals (Parliament + side chain creator)
3. Execute proposal to set `ResourceAmount[symbol] = 0`
4. All subsequent `PayRental` calls charge zero fees

**Feasibility Conditions:**
- Requires collusion between side chain creator and Parliament, OR
- Parliament compromise/malicious governance, OR  
- Side chain creator convincing Parliament that zero resource usage is legitimate

**Economic Rationality:**
STRONG - Side chains have clear financial incentive to reduce operating costs to zero. The cost of obtaining governance approval is minimal compared to ongoing rental savings.

**Detection Constraints:**
The change is visible on-chain through `GetResourceUsage` queries, but may not trigger immediate alerts since the validation explicitly allows it.

### Recommendation
**Code-Level Mitigation:**
Modify the validation in `UpdateRentedResources` to enforce positive resource amounts:

```csharp
Assert(pair.Value > 0, "Resource amount must be positive.");
```

Update the validation at [8](#0-7)  from `>= 0` to `> 0`.

**Invariant Checks:**
Add assertion in `PayRental` as defense-in-depth:
```csharp
Assert(State.ResourceAmount[symbol] > 0, "Invalid resource amount configuration.");
```

**Initialization Validation:**
Add validation in `InitializeFromParentChain` at [4](#0-3)  to ensure initial ResourceAmount values are positive.

**Test Cases:**
1. Test that `UpdateRentedResources` rejects zero values
2. Test that `UpdateRentedResources` rejects negative values  
3. Test rental calculation with minimum valid ResourceAmount (1)
4. Add regression test ensuring PayRental cannot result in zero charges when resources are consumed

### Proof of Concept
**Initial State:**
- Side chain is created and initialized with positive ResourceAmount values (e.g., CPU: 4, RAM: 8, DISK: 512, NET: 1000)
- Side chain creator has sufficient resource token balance
- PayRental is being called periodically during DonateResourceToken execution

**Attack Steps:**
1. Side chain creator and Parliament collaborate to create an Association proposal
2. Proposal calls `UpdateRentedResources` with input: `ResourceAmount = {{"CPU", 0}, {"RAM", 0}, {"DISK", 0}, {"NET", 0}}`
3. Both Parliament and side chain creator approve the proposal
4. Proposal is executed, setting all ResourceAmount values to 0
5. On next block production cycle, `DonateResourceToken` is called
6. `PayRental` executes at [1](#0-0) 

**Expected Result:**
Rental should be calculated based on resource consumption and unit price.

**Actual Result:**
```
rental = duration × 0 × Rental[symbol] = 0
```
No rental is charged despite resource usage. Side chain creator's balance remains unchanged. Consensus contract receives zero tokens.

**Success Condition:**
After multiple minutes of operation, side chain creator's resource token balances remain constant at their pre-attack levels, while they continue using side chain resources. The `RentalCharged` event at [9](#0-8)  shows Amount = 0 for all resource symbols.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1019-1097)
```csharp
    private void PayRental()
    {
        var creator = State.SideChainCreator.Value;
        if (creator == null) return;
        if (State.LastPayRentTime.Value == null)
        {
            // Initial LastPayRentTime first calling DonateResourceToken.
            State.LastPayRentTime.Value = Context.CurrentBlockTime;
            return;
        }

        // We need minutes.
        var duration = (Context.CurrentBlockTime - State.LastPayRentTime.Value).Seconds.Div(60);
        if (duration == 0)
        {
            return;
        }

        // Update LastPayRentTime if it is ready to charge rental.
        State.LastPayRentTime.Value += new Duration { Seconds = duration.Mul(60) };

        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName))
        {
            var donates = 0L;

            var availableBalance = GetBalance(creator, symbol);

            // Try to update owning rental.
            var owningRental = State.OwningRental[symbol];
            if (owningRental > 0)
            {
                // If Creator own this symbol and current balance can cover the debt, pay the debt at first.
                if (availableBalance > owningRental)
                {
                    donates = owningRental;
                    // Need to update available balance,
                    // cause existing balance not necessary equals to available balance.
                    availableBalance = availableBalance.Sub(owningRental);
                    State.OwningRental[symbol] = 0;
                }
            }

            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
            if (availableBalance >= rental) // Success
            {
                donates = donates.Add(rental);
                ModifyBalance(creator, symbol, -donates);
            }
            else // Fail
            {
                // Donate all existing balance. Directly reset the donates.
                donates = GetBalance(creator, symbol);
                State.Balances[creator][symbol] = 0;

                // Update owning rental to record a new debt.
                var own = rental.Sub(availableBalance);
                State.OwningRental[symbol] = State.OwningRental[symbol].Add(own);

                Context.Fire(new RentalAccountBalanceInsufficient
                {
                    Symbol = symbol,
                    Amount = own
                });
            }

            // Side Chain donates.
            var consensusContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
            ModifyBalance(consensusContractAddress, symbol, donates);

            Context.Fire(new RentalCharged()
            {
                Symbol = symbol,
                Amount = donates,
                Payer = creator,
                Receiver = consensusContractAddress
            });
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1122-1123)
```csharp
            Assert(pair.Value >= 0, "Invalid amount.");
            State.ResourceAmount[pair.Key] = pair.Value;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState_ChargeFee.cs (L26-26)
```csharp
    public MappedState<string, int> ResourceAmount { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L19-19)
```csharp
        foreach (var pair in input.ResourceAmount) State.ResourceAmount[pair.Key] = pair.Value;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L244-268)
```csharp
    private Association.CreateOrganizationBySystemContractInput GetControllerCreateInputForSideChainRental(
        Address sideChainCreator, Address parliamentAddress)
    {
        var proposers = new List<Address> { parliamentAddress, sideChainCreator };
        return new Association.CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new Association.CreateOrganizationInput
            {
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { proposers }
                },
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = proposers.Count,
                    MinimalVoteThreshold = proposers.Count,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { proposers }
                }
            }
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L407-413)
```csharp
    private void AssertControllerForSideChainRental()
    {
        Assert(State.SideChainRentalController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");
        // ReSharper disable once PossibleNullReferenceException
        Assert(State.SideChainRentalController.Value.OwnerAddress == Context.Sender, "no permission");
    }
```
