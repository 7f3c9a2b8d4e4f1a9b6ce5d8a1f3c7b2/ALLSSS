### Title
Election Deposit Misrouted to Wrong Address After Pubkey Replacement in Self-Announce Scenario

### Summary
When a candidate self-announces election, no sponsor is recorded in `CandidateSponsorMap`. If the candidate's pubkey is later replaced via `ReplaceCandidatePubkey`, the locked deposit (100,000 tokens) is incorrectly sent to the new pubkey's address instead of the original payer's address upon quitting election. This results in permanent fund loss for the original depositor.

### Finding Description

**Root Cause**: The `QuitElection` method uses a fallback mechanism to determine the refund recipient when no sponsor is recorded. [1](#0-0) 

When `CandidateSponsorMap[input.Value]` is `null` (self-announce case), tokens are sent to `Address.FromPublicKey(pubkeyBytes)` where `pubkeyBytes` is the **current** pubkey. After a pubkey replacement, this points to the new pubkey's address, not the original depositor's address.

**Execution Path**:

1. **Self-Announce**: Candidate calls `AnnounceElection` with pubkey_A, locking 100,000 tokens from `Address.FromPublicKey(pubkey_A)`. No sponsor is recorded: [2](#0-1) 

2. **Pubkey Replacement**: Admin calls `ReplaceCandidatePubkey` to change pubkey_A to pubkey_B. The sponsor mapping is transferred (remains `null`): [3](#0-2) 

3. **Quit Election**: Admin quits with pubkey_B. Since `CandidateSponsorMap[pubkey_B]` is `null`, tokens are sent to `Address.FromPublicKey(pubkey_B)` instead of the original payer `Address.FromPublicKey(pubkey_A)`.

**Contrast with Sponsored Case**: When using `AnnounceElectionFor`, the sponsor is explicitly recorded and correctly preserved through pubkey replacements: [4](#0-3) 

### Impact Explanation

**Direct Fund Loss**: The locked election deposit of 100,000 tokens (defined in `ElectionContractConstants.LockTokenForElection`) is sent to an unintended recipient. 

**Affected Parties**:
- Original depositor (pubkey_A owner) permanently loses their 100,000 token deposit
- New pubkey owner (pubkey_B) receives tokens they didn't pay for

**Severity Justification**: This is a **High** severity issue because:
1. Results in direct, irreversible fund loss
2. Violates the fundamental principle that deposits should be refundable to the payer
3. Can occur through admin compromise OR legitimate key rotation scenarios
4. The sponsored case (AnnounceElectionFor) correctly tracks the payer, demonstrating the contract's intent to preserve deposit ownership

### Likelihood Explanation

**Attack Scenario**:
1. Alice announces election with pubkey_A, setting Bob as admin for operational convenience
2. Bob's account is compromised by an attacker
3. Attacker replaces pubkey_A with attacker-controlled pubkey_Attack
4. Attacker quits election, receiving Alice's 100,000 token deposit

**Feasibility**:
- **Entry Points**: All methods (`AnnounceElection`, `ReplaceCandidatePubkey`, `QuitElection`) are standard public operations
- **Preconditions**: Requires self-announce scenario (no sponsor) followed by pubkey replacement
- **Attack Complexity**: Low - three straightforward contract calls
- **Admin Compromise**: While requiring admin compromise, the contract should still protect user funds. The sponsor case demonstrates this is achievable.

**Legitimate Scenario**: Even without malice, legitimate key rotation scenarios result in fund loss:
- Candidate loses private key for pubkey_A
- Admin rotates to pubkey_B owned by candidate
- Upon quitting, deposit goes to new address, but old address owner may expect refund

**Probability**: Medium - Pubkey replacement is a supported feature, and candidates may use separate admin addresses for operational security.

### Recommendation

**Fix**: In `PerformReplacement` method, preserve the original payer's address before transferring the sponsor mapping:

```csharp
// Before line 320 in ElectionContract_Maintainence.cs
if (State.CandidateSponsorMap[oldPubkey] == null)
{
    // Record original payer for self-announced candidates
    State.CandidateSponsorMap[oldPubkey] = Address.FromPublicKey(
        ByteArrayHelper.HexStringToByteArray(oldPubkey));
}

State.CandidateSponsorMap[newPubkey] = State.CandidateSponsorMap[oldPubkey];
State.CandidateSponsorMap.Remove(oldPubkey);
```

**Invariant to Enforce**: When a pubkey is replaced, the refund recipient mapping must point to the original depositor, regardless of whether they self-announced or were sponsored.

**Test Case**: Add a test that:
1. Self-announces election with keypair_A
2. Records initial balance of keypair_A
3. Replaces pubkey to keypair_B
4. Quits election
5. Asserts that keypair_A's balance increased by lock amount (not keypair_B)

### Proof of Concept

**Initial State**:
- Alice has balance: 1,000,000 tokens
- Bob (admin) has control privileges
- Attacker has pubkey_Attack

**Transaction Sequence**:

1. Alice calls `AnnounceElection(admin: Bob's address)` with signature from pubkey_A
   - Alice's balance: 900,000 tokens (locked 100,000)
   - `CandidateSponsorMap[pubkey_A] = null`

2. Attacker compromises Bob's account, calls `ReplaceCandidatePubkey(oldPubkey: pubkey_A, newPubkey: pubkey_Attack)`
   - `CandidateSponsorMap[pubkey_Attack] = null` (transferred)

3. Attacker (as Bob) calls `QuitElection(pubkey: pubkey_Attack)`
   - Refund calculation: `CandidateSponsorMap[pubkey_Attack] ?? Address.FromPublicKey(pubkey_Attack)`
   - Result: `Address.FromPublicKey(pubkey_Attack)`

**Expected Result**: Alice's balance returns to 1,000,000 tokens

**Actual Result**: 
- Alice's balance: 900,000 tokens (lost 100,000)
- Attacker's balance: +100,000 tokens

**Success Condition**: Attacker successfully steals Alice's election deposit through pubkey replacement exploitation.

### Notes

The vulnerability exists because the `QuitElection` fallback mechanism assumes the current pubkey owner is the original depositor. This assumption breaks after pubkey replacement. The sponsored case (`AnnounceElectionFor`) correctly handles this by explicitly tracking the sponsor through replacements, demonstrating that the contract recognizes the importance of deposit ownership tracking.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L140-140)
```csharp
        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L242-249)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L320-321)
```csharp
        State.CandidateSponsorMap[newPubkey] = State.CandidateSponsorMap[oldPubkey];
        State.CandidateSponsorMap.Remove(oldPubkey);
```
