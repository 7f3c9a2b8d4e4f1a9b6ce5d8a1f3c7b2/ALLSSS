### Title
Broken ValidateConsensusAfterExecution Allows State Inconsistency Due to In-Place Round Modification

### Summary
The `ValidateConsensusAfterExecution` method fails to properly validate consensus state after execution due to a critical bug in the recovery logic. The `RecoverFromUpdateValue` and `RecoverFromTinyBlock` methods modify the `currentRound` object in-place and return `this`, causing both `headerInformation.Round` and `currentRound` to reference the same object. This makes the subsequent hash comparison meaningless, always succeeding even when there are genuine state mismatches between what was proposed in the block header and what was actually executed.

### Finding Description

**Root Cause:**

In `ValidateConsensusAfterExecution`, the code attempts to recover the expected round state and compare it with the actual state: [1](#0-0) 

The recovery methods modify the round in-place: [2](#0-1) 

When `currentRound.RecoverFromUpdateValue(headerInformation.Round, pubkey)` is called, it modifies `currentRound` and returns `this`. The returned reference is assigned to `headerInformation.Round`, meaning both variables now point to the same modified object. The subsequent comparison `headerInformation.Round.GetHash() != currentRound.GetHash()` compares the same object's hash to itself, which always returns false (hashes match), making the validation always pass.

**Why State Inconsistency Occurs:**

The consensus flow involves several stages where state can diverge:

1. **Header Generation**: When `GetConsensusBlockExtraData` is called, it reads the current round and increments fields like `ProducedBlocks`: [3](#0-2) 

2. **Transaction Execution**: When `ProcessUpdateValue` executes, it explicitly ignores the provided value and recalculates based on current state: [4](#0-3) 

Note line 250-252: "Just add 1 based on previous data, do not use provided values."

3. **Timing Window**: If another block is finalized between header generation and validation (due to concurrent block production, network delays, or out-of-order block arrival), the state used in step 2 differs from the state used in step 1. The header contains `ProducedBlocks = X+1` (based on old state X), but execution sets `ProducedBlocks = Y+1` where Y is the current state value (potentially X+1 if another block was already processed), resulting in `ProducedBlocks = X+2`.

The `UpdateValueInput` is extracted from the header round: [5](#0-4) 

Even though it includes `ProducedBlocks` from the header (line 41), `ProcessUpdateValue` ignores this value and recalculates it.

### Impact Explanation

**Consensus Integrity Violation:**
- Different nodes processing blocks in different orders will compute different `ProducedBlocks`, `ProducedTinyBlocks`, and potentially other round fields
- This breaks the fundamental consensus invariant that all nodes must arrive at identical state given the same block sequence
- Nodes could diverge on miner statistics, affecting reward calculations and miner reputation

**Concrete Harm:**
- **Miner Reward Misallocation**: The `ProducedBlocks` field directly influences mining rewards and dividend distribution. State divergence means different nodes calculate different reward amounts, causing payment inconsistencies
- **Consensus Failure**: When nodes have different round information, they cannot reach agreement on future blocks, potentially halting the chain or causing forks
- **LIB Calculation Errors**: The round state includes `ConfirmedIrreversibleBlockHeight` which is updated during validation. Divergent states could lead to different LIB heights across nodes

**Affected Parties:**
- All network participants: validators cannot maintain consensus
- Miners: incorrect block production statistics and reward calculations  
- Token holders: potential chain halt or fork requiring manual intervention

**Severity Justification:**
HIGH severity because:
1. Breaks core consensus guarantees
2. Occurs during normal network operation (concurrent blocks)
3. No special attacker privileges required
4. Leads to measurable financial impact (reward misallocation)
5. Can cause operational failure (chain halt)

### Likelihood Explanation

**Attack Complexity**: LOW - No attack required, occurs naturally

**Feasible Conditions:**
1. **Concurrent Block Production**: Two miners produce blocks within the same time window (expected behavior in AEDPoS)
2. **Network Propagation Delays**: Blocks arrive at different nodes in different orders (normal network conditions)
3. **Validator Processing**: Node processes Block A, then receives Block B that was generated before Block A was finalized

**Scenario Sequence:**
- T0: State has Round N, Miner A's ProducedBlocks = 5
- T1: Miner A generates Block A (header: ProducedBlocks = 6)
- T2: Miner B generates Block B (header: ProducedBlocks = 6)  
- T3: Node X receives Block A, executes (ProducedBlocks → 7)
- T4: Node X receives Block B (header says 6, but current state is 7)
- T5: ProcessUpdateValue calculates: 7 + 1 = 8
- T6: ValidateConsensusAfterExecution should fail (header: 6, state: 8) but passes due to bug
- Result: Different nodes have different ProducedBlocks values

**Attacker Capabilities**: None required - occurs during normal operations

**Detection Constraints**: The bug makes the validation always pass, so there's no detection mechanism. State divergence would only be noticed when nodes attempt to validate each other's blocks and encounter unexpected mismatches.

**Probability**: HIGH - Occurs whenever blocks are processed out of generation order, which is common in distributed blockchain networks with concurrent miners.

### Recommendation

**Immediate Fix:**

Modify `ValidateConsensusAfterExecution` to create a copy of `currentRound` before recovery:

```csharp
public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
{
    var headerInformation = new AElfConsensusHeaderInformation();
    headerInformation.MergeFrom(input.Value);
    if (TryToGetCurrentRoundInformation(out var currentRound))
    {
        // Create a deep copy to avoid in-place modification
        var expectedRound = CloneRound(currentRound);
        
        if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
            expectedRound.RecoverFromUpdateValue(headerInformation.Round,
                headerInformation.SenderPubkey.ToHex());

        if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
            expectedRound.RecoverFromTinyBlock(headerInformation.Round,
                headerInformation.SenderPubkey.ToHex());

        var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
        if (expectedRound.GetHash(isContainPreviousInValue) !=
            currentRound.GetHash(isContainPreviousInValue))
        {
            // ... existing replacement check logic
        }
    }
    return new ValidationResult { Success = true };
}
```

Implement `CloneRound` using existing pattern: [6](#0-5) 

**Additional Invariant Checks:**

1. Add explicit round number validation for UpdateValue/TinyBlock behaviors (currently only done for NextRound/NextTerm): [7](#0-6) 

2. Add validation in `UpdateValueValidationProvider` to check header round number matches current round number

**Test Cases:**

1. Test concurrent block production with out-of-order arrival
2. Test ProducedBlocks consistency across multiple validators
3. Test recovery methods preserve original round object
4. Test hash comparison with intentionally mismatched rounds

### Proof of Concept

**Initial State:**
- Round 10 active
- Miner A: ProducedBlocks = 5
- Miner B: ProducedBlocks = 5

**Execution Steps:**

1. Miner A calls `GetConsensusCommand` for Round 10 → Gets valid permission
2. Miner A generates block header via `GetConsensusBlockExtraData`:
   - Reads current round (ProducedBlocks = 5)
   - Increments to 6 in header
   - Header contains: Round 10, ProducedBlocks = 6

3. Before Miner A's block propagates, Miner B produces and finalizes a block:
   - Miner B's block executes
   - Miner A's ProducedBlocks: 5 → 6 (Miner B's execution affects shared round state)

4. Miner A's block arrives at validators:
   - `ValidateConsensusBeforeExecution`: Checks against current state (ProducedBlocks = 6)
   - `ProcessUpdateValue` executes: ProducedBlocks = 6 + 1 = 7 (ignores header value)
   - `ValidateConsensusAfterExecution`: Should detect mismatch (header: 6, state: 7)

**Expected Result:**
ValidationResult with `Success = false` and message indicating round information mismatch

**Actual Result:**
ValidationResult with `Success = true` because:
- `currentRound.RecoverFromUpdateValue()` modifies currentRound to have values from header
- Both `headerInformation.Round` and `currentRound` reference same object
- Hash comparison: same object hash == same object hash → always true
- Validation incorrectly passes despite state inconsistency

**Success Condition:**
Different validator nodes end up with divergent `ProducedBlocks` values (Node 1: 6, Node 2: 7, Node 3: 8) depending on block arrival order, causing consensus failure when validating subsequent blocks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-47)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }

    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L55-134)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataToPublishOutValue(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        Assert(triggerInformation.InValue != null, "In value should not be null.");

        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
        var previousInValue = Hash.Empty; // Just initial previous in value.

        if (TryToGetPreviousRoundInformation(out var previousRound) && !IsFirstRoundOfCurrentTerm(out _))
        {
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
            else
            {
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
            }
        }

        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);

        Context.LogDebug(
            () => "Previous in value after ApplyNormalConsensusData: " +
                  $"{updatedRound.RealTimeMinersInformation[pubkey].PreviousInValue}");

        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;

        // Update secret pieces of latest in value.
        
        if (IsSecretSharingEnabled())
        {
            UpdateLatestSecretPieces(updatedRound, pubkey, triggerInformation);
        }

        // To publish Out Value.
        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = updatedRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L35-51)
```csharp
        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```
