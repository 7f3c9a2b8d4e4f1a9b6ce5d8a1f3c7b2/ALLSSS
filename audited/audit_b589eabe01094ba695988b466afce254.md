### Title
Initial Registration Bypass of MaximumOptionsCount Limit Allows Unlimited Options in Voting Items

### Summary
The `Register` function in the Vote contract does not validate the initial options count against the `MaximumOptionsCount` constant (64), while `AddOption` and `AddOptions` strictly enforce this limit post-registration. This allows a malicious sponsor to register voting items with unlimited options during initial registration, bypassing the protocol's intended constraint and causing storage bloat, potential DoS, and breaking protocol invariants.

### Finding Description

The vulnerability exists in the `Register` function which directly copies all input options without validation: [1](#0-0) 

The `AssertValidNewVotingItem` validation function is called during registration but does not check the options count: [2](#0-1) 

In contrast, `AddOption` enforces the limit BEFORE adding a new option: [3](#0-2) 

And `AddOptions` enforces the limit AFTER adding options: [4](#0-3) 

The `MaximumOptionsCount` constant is defined as 64: [5](#0-4) 

The protobuf definition shows options are accepted as a repeated field with no built-in size restriction: [6](#0-5) 

### Impact Explanation

**Operational Impact - DoS and Storage Bloat:**
- A sponsor can register a voting item with thousands or unlimited options (e.g., 1000+ options)
- Operations that query or iterate over voting item options may hit gas limits or timeout
- Excessive storage consumption on-chain for a single voting item
- The `GetVotingItem` view function and vote validation logic (`AssertValidVoteInput`) must process all options, potentially causing DoS

**Protocol Invariant Violation:**
- The protocol defines `MaximumOptionsCount = 64` as a constant limit, clearly intended as a protocol-wide constraint
- This invariant is enforced for `AddOption` and `AddOptions` but completely bypassed during `Register`
- Creates inconsistent behavior: post-registration modifications are strictly limited, but initial registration is unlimited

**Affected Users:**
- Voters attempting to query or vote on items with excessive options may experience transaction failures
- Other sponsors and voting operations on the same chain face increased gas costs due to state bloat
- System integrity compromised as the fundamental constraint is bypassable

### Likelihood Explanation

**Reachable Entry Point:**
The `Register` function is a public entry point callable by any user who holds the accepted token: [7](#0-6) 

**Feasible Preconditions:**
- Attacker must have access to call `Register` (no special privileges required beyond token whitelist check)
- Can construct `VotingRegisterInput` with arbitrary number of options in the `options` field
- No economic barrier - registration cost is the same regardless of options count

**Execution Practicality:**
- Straightforward exploit: Simply include >64 options in the `VotingRegisterInput.options` array
- No complex transaction sequences or timing requirements
- Test evidence confirms registration with 64 options succeeds without validation: [8](#0-7) 

**Detection/Operational Constraints:**
- Exploit leaves clear evidence (voting item with >64 options)
- However, no mechanism exists to reject or remediate such items post-registration
- Damage is permanent once registered

### Recommendation

**Immediate Fix:**
Add validation in the `Register` function or `AssertValidNewVotingItem` helper to enforce the maximum options count:

```csharp
// In AssertValidNewVotingItem function, add before return:
Assert(input.Options.Count <= VoteContractConstants.MaximumOptionsCount, 
    $"The count of options can't be greater than {VoteContractConstants.MaximumOptionsCount}");
```

**Specific Code Location:**
Insert validation in `AssertValidNewVotingItem` after line 361 (after timestamp validation): [9](#0-8) 

**Test Cases to Add:**
1. Test registration with exactly 64 options (should succeed)
2. Test registration with 65 options (should fail with appropriate error)
3. Test registration with 100+ options (should fail)
4. Ensure error message matches the one used in `AddOption` and `AddOptions` for consistency

### Proof of Concept

**Initial State:**
- Vote contract deployed and initialized
- Token contract has whitelisted the accepted currency
- Attacker has sufficient balance of accepted currency

**Exploitation Steps:**

1. Construct `VotingRegisterInput` with 100 options (exceeding MaximumOptionsCount of 64):
```csharp
var input = new VotingRegisterInput
{
    StartTimestamp = Timestamp.FromDateTime(DateTime.UtcNow),
    EndTimestamp = Timestamp.FromDateTime(DateTime.UtcNow.AddDays(10)),
    AcceptedCurrency = "ELF",
    IsLockToken = true,
    TotalSnapshotNumber = 1,
    Options = { GenerateOptions(100) } // 100 options
};
```

2. Call `Register` function with this input

**Expected Result:**
- Transaction should fail with error message about exceeding maximum options count

**Actual Result:**
- Transaction succeeds and voting item is created with 100 options
- Subsequent calls to `AddOption` will correctly reject adding more options (since count already exceeds 64)
- But the initial 100 options remain permanently, violating the protocol invariant

**Success Condition:**
- Query the created voting item using `GetVotingItem`
- Observe `votingItem.Options.Count > 64` (e.g., 100)
- Attempt to call `AddOption` - it will fail, proving the inconsistency between registration and post-registration validation

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-20)
```csharp
    public override Empty Register(VotingRegisterInput input)
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L49-49)
```csharp
            Options = { input.Options },
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L285-286)
```csharp
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L320-321)
```csharp
        Assert(votingItem.Options.Count <= VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-5)
```csharp
    public const int MaximumOptionsCount = 64;
```

**File:** protobuf/vote_contract.proto (L99-99)
```text
    repeated string options = 6;
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L342-343)
```csharp
            var registerItem = await RegisterVotingItemAsync(100, VoteContractConstant.MaximumOptionsCount, true,
                DefaultSender, 1);
```
