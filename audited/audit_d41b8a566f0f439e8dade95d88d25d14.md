### Title
Secret Sharing Threshold Mismatch Causes Incorrect InValue Revelation During Miner Set Changes

### Summary
The RevealSharedInValues function uses the current round's miner count to calculate the decoding threshold, but InValues were encoded using a different round's miner count. When the miner count changes between rounds, this threshold mismatch causes Shamir's Secret Sharing to reconstruct incorrect InValues, leading to consensus validation failures and potential consensus stall.

### Finding Description

**Encoding Flow:**
When Round N is added, InValues are encoded using Round N-1's miner count: [1](#0-0) 

The threshold is calculated as `minimumCount = (Round N-1's miner count * 2) / 3`, and secrets are encoded with this threshold.

**Decoding Flow:**
During transition to Round N+1, the contract attempts to decode Round N-1's InValues: [2](#0-1) 

The decoding threshold is calculated using the **current** round's (Round N's) miner count, not the round where encoding occurred (Round N-2).

**Root Cause:**
InValue for Round N-1 was encoded when Round N-1 was added, using Round N-2's miner count as the threshold basis. However, decoding happens during the transition to Round N+1, using Round N's miner count: [3](#0-2) 

When Round N-2 and Round N have different miner counts, the Shamir's Secret Sharing reconstruction produces incorrect results. For example:
- Round N-2: 5 miners → encoding threshold = 3
- Round N: 3 miners → decoding threshold = 2
- Using threshold=2 to decode a secret encoded with threshold=3 produces mathematically incorrect results

**Why Existing Protections Fail:**
While secret sharing is skipped when `IsMinerListJustChanged=true`: [4](#0-3) 

This only prevents encoding in the round where the miner list changed. It does NOT prevent decoding of InValues encoded BEFORE the change using a POST-change miner count in subsequent rounds. The check at line 36 requiring all decrypted pieces doesn't prevent incorrect reconstruction when miner count decreases, as it only checks quantity, not the threshold match.

### Impact Explanation

**Consensus Integrity Violation:**
Incorrectly revealed InValues are stored in the round state: [5](#0-4) 

When miners produce blocks using these incorrect PreviousInValues, validation fails: [6](#0-5) 

The check `HashHelper.ComputeFrom(previousInValue) == previousOutValue` fails because the incorrectly reconstructed InValue does not hash to the expected OutValue.

**Concrete Damage:**
- Consensus can stall when miner count decreases after stable periods
- All continuing miners from the previous round cannot produce valid blocks
- Network liveness is compromised until the miner set stabilizes again
- No automatic recovery mechanism exists

**Affected Parties:**
- All network nodes experience consensus disruption
- Block production halts for affected miners
- Transaction finality is severely delayed

**Severity: HIGH** - Breaks the critical consensus invariant of correct InValue/OutValue chain verification, causing DoS of the consensus mechanism.

### Likelihood Explanation

**Attacker Capabilities:**
No malicious attacker required - this is a logic bug triggered by normal miner set changes through the election process.

**Attack Complexity:**
Very low - occurs automatically when:
1. Miner set remains stable for 2+ rounds (IsMinerListJustChanged=false during encoding)
2. Miner count then decreases through normal election process
3. Next stable round attempts secret reconstruction

**Feasibility Conditions:**
Miner elections naturally cause count changes. Concrete scenario:
- Round N-2: 5 miners, each encodes InValues with threshold=3
- Round N-1: 5 miners (stable), IsMinerListJustChanged=false, encoding continues
- Round N: 3 miners (election result), IsMinerListJustChanged=true
- Round N+1: 3 miners, attempts to decode Round N-1's InValues with threshold=2 instead of threshold=3

**Detection:**
Manifests as repeated block validation failures with "Incorrect previous in value" messages immediately after miner set contractions.

**Probability: HIGH** - Occurs whenever miner count decreases after stable periods, which happens regularly during validator elections in PoS systems.

### Recommendation

**Immediate Fix:**
Use the previous round's miner count (where encoding occurred) instead of the current round's count for decoding:

In `AEDPoSContract_SecretSharing.cs` line 21-22, change:
```
var minersCount = currentRound.RealTimeMinersInformation.Count;
```
To:
```
var minersCount = previousRound.RealTimeMinersInformation.Count;
```

This ensures the decoding threshold matches the encoding threshold used when the InValues were originally created.

**Invariant Check:**
Add validation before decoding:
```
Assert(encodingThreshold == decodingThreshold, "Secret sharing threshold mismatch");
```

**Test Cases:**
1. Test secret sharing with miner count decrease: 5→5→3 miners across three rounds
2. Test secret sharing with miner count increase: 3→3→5 miners across three rounds
3. Verify InValue revelation produces correct values that pass validation
4. Test interaction between IsMinerListJustChanged and threshold calculations

### Proof of Concept

**Initial State:**
- Round N-2: 5 miners {A, B, C, D, E}
- Round N-1: 5 miners {A, B, C, D, E}, IsMinerListJustChanged=false
- Miner A generates and encodes InValue_A for Round N-1

**Exploitation Steps:**

1. **Round N-2 to N-1 Transition:**
   - SecretSharingInformation event fired for Round N-1
   - Miner A encodes InValue_A using threshold = (5*2)/3 = 3
   - Distributes 5 encrypted shares (one to each miner)
   - All 5 miners successfully decrypt their shares

2. **Round N-1 to N Transition:**
   - Election reduces miner set to 3 miners {A, B, C}
   - Round N has IsMinerListJustChanged=true
   - Secret sharing is skipped for Round N (per line 107-108 check)

3. **Round N to N+1 Transition:**
   - `RevealSharedInValues(Round N)` is called
   - Gets previousRound = Round N-1 (which has 5 miners)
   - **BUG**: Calculates minimumCount = (3*2)/3 = 2 using Round N's count
   - Decodes Miner A's InValue from Round N-1 using threshold=2
   - Original encoding used threshold=3 → produces **INCORRECT** InValue_A_corrupted
   - Sets `Round N+1.RealTimeMinersInformation[A].PreviousInValue = InValue_A_corrupted`

4. **Block Production Attempt in Round N+1:**
   - Miner A produces block with PreviousInValue=InValue_A_corrupted
   - `UpdateValueValidationProvider.ValidatePreviousInValue()` executes
   - Checks: `Hash(InValue_A_corrupted) == A's OutValue from Round N`
   - **Validation FAILS** - OutValue was computed from correct InValue_A, not the corrupted version
   - Block is rejected with "Incorrect previous in value" error

**Expected vs Actual Result:**
- **Expected**: InValue revelation succeeds with correct value, miners produce valid blocks
- **Actual**: InValue incorrectly reconstructed due to threshold mismatch (2 vs 3), all blocks from continuing miners rejected

**Success Condition:**
Consensus degrades when miner count decreases from 5 to 3 after stable rounds. All miners continuing from the previous round fail block validation and cannot contribute to consensus until conditions change.

### Citations

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L101-104)
```csharp
        var minersCount = secretSharingInformation.PreviousRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        var secretShares =
            SecretSharingHelper.EncodeSecret(newInValue.ToByteArray(), minimumCount, minersCount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L50-50)
```csharp
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L52-52)
```csharp
            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L107-115)
```csharp
        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L48-48)
```csharp
        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```
