### Title
Insufficient Validation Allows Bypassing Maximum Miners Count Restriction in NextTerm Transition

### Summary
The `NextTerm` method in the AEDPoS consensus contract accepts a `NextTermInput` parameter containing a Round with an arbitrary number of miners, but fails to validate that the count of `RealTimeMinersInformation` entries does not exceed `State.MaximumMinersCount.Value`. A malicious miner can craft consensus extra data during a term transition to install more miners than the configured maximum, bypassing the miner count restriction and potentially compromising consensus integrity.

### Finding Description

**Root Cause:**

The `NextTermInput.Create()` method directly copies all `RealTimeMinersInformation` entries from the input Round without any count validation: [1](#0-0) 

**Missing Validation in Entry Point:**

The public `NextTerm` method accepts the input and passes it to `ProcessConsensusInformation` without validating the miner count: [2](#0-1) 

**Insufficient Before-Execution Validation:**

The `RoundTerminateValidationProvider` for NextTerm behavior only validates round number, term number, and that InValues are null. It does NOT validate the miner count against the maximum: [3](#0-2) 

The validation provider is added for NextTerm but performs no miner count checks: [4](#0-3) 

**Unvalidated Processing:**

In `ProcessNextTerm`, the method converts the input to a Round and directly uses ALL miners from `nextRound.RealTimeMinersInformation` without checking if the count exceeds `State.MaximumMinersCount.Value`: [5](#0-4) 

The method creates a `MinerList` from all keys in `nextRound.RealTimeMinersInformation` and calls `SetMinerList` to install them without any count validation.

**No After-Execution Protection:**

The `ValidateConsensusAfterExecution` method compares round hashes but does not explicitly validate that the installed miner count respects the maximum: [6](#0-5) 

**Configuration Context:**

The maximum miners count is configurable via governance and defaults to `int.MaxValue`: [7](#0-6) 

When properly set via governance, it should limit the miner count: [8](#0-7) 

### Impact Explanation

**Consensus Integrity Compromise:**
- An attacker can install more miners than the governance-approved maximum, diluting voting power and potentially enabling Sybil attacks on consensus decisions
- If `MaximumMinersCount` is set to 21 but an attacker installs 50 miners they control, they can dominate consensus with 29+ malicious nodes

**Governance Bypass:**
- The `MaximumMinersCount` is a critical governance parameter controlled by Parliament
- Bypassing this restriction undermines the governance mechanism and the intended security model

**Election System Corruption:**
- The excess miners would be recorded in the miner list state, affecting election snapshots, reward distributions, and subsequent term transitions
- The Election contract's miner count would be updated to reflect the inflated count, propagating the corruption: [9](#0-8) 

**Reward Misallocation:**
- Mining rewards would be distributed among the excess miners, diluting legitimate miners' rewards
- Treasury donations and profit distributions would be calculated based on the corrupted miner count

**Severity:** Medium to High depending on the configured `MaximumMinersCount`. If set to a security-critical value significantly below the actual candidate count, the impact is severe.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be a current miner (to pass `PreCheck()` authorization)
- Must wait for a term transition window when NextTerm behavior is appropriate
- Must have capability to craft custom consensus extra data

**Attack Complexity:**
- Moderate: Requires understanding of the consensus extra data format and term transition timing
- The attacker must create a valid `NextTermInput` with proper round/term numbers but inflated miner count
- Must produce a block during the appropriate time window

**Feasibility Conditions:**
- The network must have `MaximumMinersCount` set to a value lower than the number of candidates
- A malicious miner must have their turn during a term transition
- Term transitions occur regularly (based on `PeriodSeconds`), providing periodic opportunities

**Detection Constraints:**
- The excess miners would be visible in the miner list state after the attack
- However, by the time it's detected, the state corruption has occurred and the malicious term has begun
- Rollback would require hard fork or emergency governance action

**Economic Rationality:**
- Cost: Requires being an existing miner (significant stake/reputation)
- Benefit: Control over consensus, increased mining rewards for attacker's nodes, governance manipulation
- The attack may be rational for sophisticated adversaries seeking long-term control

**Probability:** Medium - Requires miner status and precise timing, but the attack is deterministic and has no additional barriers once conditions are met.

### Recommendation

**Immediate Fix - Add Miner Count Validation:**

Add validation in `ProcessNextTerm` before accepting the Round:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // CRITICAL: Validate miner count does not exceed maximum
    var actualMinersCount = nextRound.RealTimeMinersInformation.Count;
    var maximumMinersCount = State.MaximumMinersCount.Value;
    Assert(actualMinersCount <= maximumMinersCount, 
        $"Miners count {actualMinersCount} exceeds maximum allowed {maximumMinersCount}.");
    
    RecordMinedMinerListOfCurrentRound();
    // ... rest of method
}
```

**Add Validation Provider:**

Create a new `MinerCountValidationProvider` and add it to the NextTerm validation pipeline:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new MinerCountValidationProvider()); // NEW
    break;
```

The provider should validate:
```csharp
public class MinerCountValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var minerCount = extraData.Round.RealTimeMinersInformation.Count;
        var maxCount = validationContext.MaximumMinersCount; // Add to context
        
        if (minerCount > maxCount)
            return new ValidationResult { 
                Message = $"Miner count {minerCount} exceeds maximum {maxCount}" 
            };
            
        return new ValidationResult { Success = true };
    }
}
```

**Additional Checks:**

Add similar validation in `ProcessNextRound` for miner replacement scenarios where the miner list changes within a term.

**Test Cases:**

1. Test NextTerm with miner count equal to MaximumMinersCount - should pass
2. Test NextTerm with miner count exceeding MaximumMinersCount by 1 - should fail
3. Test NextTerm with miner count significantly exceeding MaximumMinersCount - should fail
4. Test that validation occurs before state changes (test rollback on failure)

### Proof of Concept

**Initial State:**
- Network has 20 active candidates
- `State.MaximumMinersCount.Value` is set to 15 via governance
- Current term has 15 miners
- Alice is a current miner

**Attack Sequence:**

1. **Wait for Term Transition Window:**
   - Monitor blockchain timestamp relative to term start + PeriodSeconds
   - When term transition is imminent, prepare attack

2. **Craft Malicious NextTermInput:**
   ```csharp
   var maliciousRound = new Round
   {
       RoundNumber = currentRound.RoundNumber + 1,
       TermNumber = currentRound.TermNumber + 1,
       RealTimeMinersInformation = { /* 20 miners instead of max 15 */ }
   };
   
   var maliciousInput = NextTermInput.Create(maliciousRound, randomNumber);
   ```

3. **Submit Block with Malicious Consensus Data:**
   - Alice produces a block during her time slot in the transition window
   - Includes malicious consensus extra data in the block header
   - The generated NextTerm transaction uses this malicious data

4. **Validation Passes:**
   - `ValidateConsensusBeforeExecution`: ✓ (round/term numbers are correct)
   - `PreCheck()`: ✓ (Alice is a current miner)
   - `ProcessNextTerm`: ✓ (no miner count validation)
   - `ValidateConsensusAfterExecution`: ✓ (state matches header)

5. **State Corruption:**
   - `State.MinerListMap[newTermNumber]` contains 20 miners instead of 15
   - `State.Rounds[newRoundNumber].RealTimeMinersInformation` has 20 entries
   - Election contract's `State.MinersCount` is updated to 20

**Expected Result:** NextTerm transaction fails with "Miners count exceeds maximum"

**Actual Result:** NextTerm transaction succeeds, 20 miners installed despite 15 maximum

**Success Condition:** Query `GetCurrentMinerList()` returns 20 miners when maximum is configured as 15

### Notes

The vulnerability exists because the validation logic assumes consensus extra data is always properly generated by the contract's internal methods (`GetConsensusExtraDataForNextTerm`), which naturally respects the maximum by getting victories from the Election contract. However, there is no enforcement that prevents a miner from crafting malicious consensus data that bypasses this flow. Defense in depth requires explicit validation at the entry point regardless of the expected data source.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-190)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L84-128)
```csharp
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L52-52)
```csharp
        State.MaximumMinersCount.Value = int.MaxValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```
