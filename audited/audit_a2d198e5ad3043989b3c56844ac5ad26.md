### Title
Banned Pubkey Can Be Included in Election Snapshot via Replacement Chain, Allowing Banned Miners to Re-Enter Consensus

### Summary
The `GetPreviousTermSnapshotWithNewestPubkey()` function fails to verify whether the newest pubkey in a replacement chain is itself banned before including it in the election snapshot. This allows a banned miner to re-enter the active consensus miner set through the miner replacement mechanism, completely bypassing the ban enforcement system.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:** The replacement logic retrieves the newest pubkey for a banned candidate but only checks if the newest pubkey is null, identical to the banned candidate, or already in the snapshot. It does **not** verify whether the newest pubkey itself is banned using `IsPubkeyBanned()`. [2](#0-1) 

The `GetNewestPubkey()` function traces through the replacement chain to find the most recent pubkey: [3](#0-2) 

When candidates perform replacements, the old pubkey is banned but the mapping is updated to point to the new pubkey: [4](#0-3) [5](#0-4) 

If the newest pubkey in the chain is subsequently marked as evil, it gets banned: [6](#0-5) 

The function `IsPubkeyBanned()` exists and is used elsewhere but not at the critical check point: [7](#0-6) 

**Execution Path:**

1. The corrupted snapshot from `GetPreviousTermSnapshotWithNewestPubkey()` is used by `GetMinerReplacementInformation()`: [8](#0-7) 

2. Alternative candidates are selected from the snapshot **without banned pubkey filtering**: [9](#0-8) 

3. The consensus contract receives these alternatives and directly adds them to the active miner set: [10](#0-9) 

### Impact Explanation

**Consensus Integrity Compromise:** Banned miners can bypass the ban mechanism and remain in or re-enter the active consensus miner set, directly violating the critical invariant of miner schedule integrity.

**Reward Misallocation:** Banned miners continue earning mining rewards (block rewards, subsidy distributions) they are not entitled to receive, resulting in direct fund impact through improper reward allocation.

**Security Degradation:** Miners are typically banned for malicious behavior (detected evil nodes) or severe underperformance. Allowing them back into consensus enables continued attacks or degraded network performance.

**Governance Bypass:** The ban enforcement mechanism—a critical governance control callable by the consensus contract or emergency response organization—becomes ineffective when miners can remain via replacement chains.

### Likelihood Explanation

**Reachable Entry Point:** The vulnerability is triggered automatically during normal consensus operations when `GetMinerReplacementInformation()` is called from the consensus contract's round generation logic.

**Feasible Preconditions:** 
- Replacement chains (A→B→C) are a standard feature where miners legitimately replace their pubkeys
- Any miner in the chain can later be marked as evil/banned through normal consensus detection
- No special permissions or attack complexity required

**Execution Practicality:** The exploit occurs passively once the conditions exist—no active attack needed. When the consensus contract detects evil miners and queries for replacements, banned pubkeys are automatically included.

**Economic Rationality:** An attacker controlling multiple pubkeys can establish a replacement chain at minimal cost (standard replacement fees), then have intermediate pubkeys operate normally while the final pubkey engages in malicious behavior. After being banned, the chain allows re-entry.

**Detection Constraints:** The vulnerability is not easily detected as the banned pubkey appears in election snapshots with legitimate voting power inherited from the original pubkey.

### Recommendation

**Code-Level Mitigation:**

Add a banned pubkey check in `GetPreviousTermSnapshotWithNewestPubkey()` at line 153:

```csharp
var newestPubkey = GetNewestPubkey(bannedCandidate);
// If newest pubkey not exists or same as old pubkey (which is banned), skip.
if (newestPubkey == null || newestPubkey == bannedCandidate ||
    IsPubkeyBanned(newestPubkey) ||  // ADD THIS CHECK
    snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
```

**Defense in Depth:**

Additionally filter banned pubkeys in `GetMinerReplacementInformation()` at line 374:

```csharp
.Where(cs => !input.CurrentMinerList.Contains(cs.Key))
.Where(cs => !IsPubkeyBanned(cs.Key))  // ADD THIS CHECK
.OrderByDescending(s => s.Value).ToList();
```

**Test Cases:**

1. Create replacement chain A→B→C where A and C are banned
2. Verify snapshot does not include C when processing A
3. Verify `GetMinerReplacementInformation()` excludes C from alternatives
4. Ensure consensus contract cannot add C as a replacement miner

### Proof of Concept

**Initial State:**
1. Miner A is an initial miner participating in election with 10,000 votes
2. A has voting power recorded in previous term snapshot

**Transaction Sequence:**

1. **T1:** A calls `ReplaceCandidatePubkey(oldPubkey: A, newPubkey: B)`
   - A is banned, `InitialToNewestPubkeyMap[A] = B`
   
2. **T2:** B calls `ReplaceCandidatePubkey(oldPubkey: B, newPubkey: C)`
   - B is banned, `InitialToNewestPubkeyMap[A] = C`
   - C is now the newest pubkey in chain A→B→C

3. **T3:** Consensus contract detects C as evil miner
   - Calls `UpdateCandidateInformation(pubkey: C, isEvilNode: true)`
   - C is banned: `BannedPubkeyMap[C] = true`

4. **T4:** Next round generation in consensus contract
   - Calls `GetMinerReplacementInformation()`
   - Which calls `GetPreviousTermSnapshotWithNewestPubkey()`
   - Finds A in snapshot (A is banned)
   - Calls `GetNewestPubkey(A)` → returns C
   - Checks: `C != null` ✓, `C != A` ✓, `snapshot[C] not exists` ✓
   - **MISSING:** `IsPubkeyBanned(C)` check
   - Adds C to snapshot with A's 10,000 votes

5. **T5:** Consensus contract processes alternatives
   - C appears in `maybeNextCandidates` with 10,000 votes
   - C is selected as alternative candidate
   - C is added to `currentRound.RealTimeMinersInformation`

**Expected vs Actual Result:**
- **Expected:** C (banned) should be excluded from election snapshot and alternatives
- **Actual:** C is included in snapshot, selected as alternative, and added to active miner set

**Success Condition:** 
A banned miner C is present in `currentRound.RealTimeMinersInformation` and can produce blocks despite being banned.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L151-158)
```csharp
            var newestPubkey = GetNewestPubkey(bannedCandidate);
            // If newest pubkey not exists or same as old pubkey (which is banned), skip.
            if (newestPubkey == null || newestPubkey == bannedCandidate ||
                snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
            if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L363-363)
```csharp
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L368-377)
```csharp
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L96-96)
```csharp
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L246-246)
```csharp
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L288-291)
```csharp
        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L61-63)
```csharp
    private bool IsPubkeyBanned(string pubkey)
    {
        return State.BannedPubkeyMap[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-338)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
```
