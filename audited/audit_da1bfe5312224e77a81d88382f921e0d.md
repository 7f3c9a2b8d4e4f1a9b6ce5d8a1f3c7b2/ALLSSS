### Title
Missing Per-Round Block Production Limit Validation in MiningPermissionValidationProvider

### Summary
The consensus validation system fails to enforce per-round block production limits for miners. While `MiningPermissionValidationProvider` only verifies miner list membership, no validator checks if a miner (especially an extra block producer) has exceeded their allowed block production count for the current round based on `ActualMiningTimes.Count` in `BaseRound`. This allows miners to produce more blocks than the intended maximum, particularly extra block producers who have multiple time slots in a round. [1](#0-0) 

### Finding Description

The root cause is in the validation architecture. When `ValidateBeforeExecution` processes a consensus block:

1. `BaseRound` is fetched from StateDb and recovered with new `ActualMiningTimes` from the provided round: [2](#0-1) 

2. The recovery functions add new mining times to `BaseRound`: [3](#0-2) 

3. Multiple validators are instantiated, but none check block production count: [4](#0-3) 

4. `MiningPermissionValidationProvider` only checks miner list membership: [1](#0-0) 

5. `ContinuousBlocksValidationProvider` tracks consecutive blocks across miners but doesn't validate per-miner round limits: [5](#0-4) 

6. During command generation, the intended limit is checked: [6](#0-5) 

However, this check only happens during honest command generation, not during validation. A malicious miner can bypass the command generation and directly submit blocks exceeding their limit. For extra block producers, the allowed total is `_maximumBlocksCount + blocksBeforeCurrentRound`, but validation never verifies this constraint against `BaseRound.RealTimeMinersInformation[pubkey].ActualMiningTimes.Count`.

### Impact Explanation

**Consensus Integrity Violation**: Miners can exceed intended block production limits per round, undermining the fairness of the AEDPoS consensus mechanism where each miner should have bounded production capacity.

**Mining Reward Misallocation**: Extra blocks produced beyond the limit generate additional mining rewards. With the default limit of 8 blocks per time slot and extra block producers having two slots, a malicious extra block producer could potentially produce significantly more than the intended ~16 blocks maximum per round. [7](#0-6) 

**Block Production Monopolization**: By exceeding limits, a malicious miner can monopolize block production within the round, reducing other miners' opportunities and centralizing control.

### Likelihood Explanation

**Reachable Entry Point**: Any active miner can invoke `UpdateValue` or `TinyBlock` consensus methods to submit blocks. [8](#0-7) 

**Low Complexity**: The attacker only needs to submit additional consensus transactions beyond their limit. No sophisticated attack vector is required.

**Feasible Preconditions**: The attacker must be an active miner in the current round, which is a realistic capability for consensus participants.

**Limited Detection**: Since blocks are processed individually and validation doesn't check cumulative counts, detection requires external monitoring of `ActualMiningTimes.Count` per miner per round, which may not be immediately apparent.

### Recommendation

Add a new validation provider `BlockProductionLimitValidationProvider` that checks per-round production limits:

```csharp
public class BlockProductionLimitValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var pubkey = validationContext.SenderPubkey;
        var baseRound = validationContext.BaseRound;
        var minerInRound = baseRound.RealTimeMinersInformation[pubkey];
        
        var maximumBlocksCount = GetMaximumBlocksCount(); // Should be passed as context
        var allowedBlocksCount = maximumBlocksCount;
        
        // Extra block producers get additional allowance
        if (baseRound.ExtraBlockProducerOfPreviousRound == pubkey && 
            !baseRound.IsMinerListJustChanged)
        {
            var blocksBeforeCurrentRound = minerInRound.ActualMiningTimes
                .Count(t => t <= baseRound.GetRoundStartTime());
            allowedBlocksCount = maximumBlocksCount + blocksBeforeCurrentRound;
        }
        
        if (minerInRound.ActualMiningTimes.Count > allowedBlocksCount)
        {
            return new ValidationResult 
            { 
                Message = $"Miner exceeded block production limit: {minerInRound.ActualMiningTimes.Count} > {allowedBlocksCount}" 
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Add this validator to the validation providers list in `ValidateBeforeExecution`: [9](#0-8) 

Add test cases verifying rejection of blocks when:
1. Normal miners exceed `MaximumTinyBlocksCount`
2. Extra block producers exceed `MaximumTinyBlocksCount + blocksBeforeCurrentRound`
3. Limits adjust correctly during Abnormal/Severe blockchain status

### Proof of Concept

**Initial State**:
- Current round has miner M as extra block producer from previous round
- `MaximumTinyBlocksCount` = 8
- Miner M has 2 blocks before current round started (`blocksBeforeCurrentRound` = 2)
- Allowed total: 8 + 2 = 10 blocks

**Attack Sequence**:
1. Miner M submits 10 legitimate TinyBlock transactions during their time slots
2. All pass validation (continuous blocks check allows up to 8 consecutive)
3. Miner M then submits 11th and 12th TinyBlock transactions
4. `MiningPermissionValidationProvider` passes (M is in miner list)
5. `TimeSlotValidationProvider` passes (still within time slot bounds)
6. `ContinuousBlocksValidationProvider` may pass if interspersed with other miners' blocks
7. Blocks are accepted even though M exceeded the intended 10-block limit

**Expected Result**: Validation should reject blocks 11 and 12 due to exceeding per-round production limit.

**Actual Result**: Blocks are accepted because no validator checks `ActualMiningTimes.Count` against the allowed limit.

**Success Condition**: After execution, `BaseRound.RealTimeMinersInformation[M].ActualMiningTimes.Count > 10`, confirming the limit was exceeded.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-92)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L8-28)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Is sender produce too many continuous blocks?
        var validationResult = new ValidationResult();

        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-79)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L4-7)
```csharp
public static class AEDPoSContractConstants
{
    public const int MaximumTinyBlocksCount = 8;
    public const long InitialMiningRewardPerBlock = 12500000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L35-52)
```csharp
        switch (input)
        {
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
                break;
            case UpdateValueInput updateValueInput:
                randomNumber = updateValueInput.RandomNumber;
                ProcessUpdateValue(updateValueInput);
                break;
            case TinyBlockInput tinyBlockInput:
                randomNumber = tinyBlockInput.RandomNumber;
                ProcessTinyBlock(tinyBlockInput);
                break;
```
