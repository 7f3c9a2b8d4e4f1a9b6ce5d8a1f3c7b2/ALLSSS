### Title
Symbol Alias Resolution Inconsistency Enables Token Supply Inflation Beyond TotalSupply Limit

### Summary
The `ModifyBalance()` function reads balances using resolved symbols but writes using unresolved input symbols. When `Issue()` or `Burn()` operations use token aliases, this creates a critical mismatch that allows attackers to manipulate token supply counters without affecting actual balances, enabling unlimited token minting beyond `TotalSupply` limits and breaking the fundamental invariant that supply equals the sum of all balances.

### Finding Description

The root cause lies in the interaction between alias resolution and balance modification logic across multiple functions:

**Alias Resolution Logic:** [1](#0-0) 

The `GetActualTokenSymbol()` method correctly resolves aliases by checking if a TokenInfo exists for the input string, and if not, looking up the SymbolAliasMap to find the actual symbol.

**Balance Reading:** [2](#0-1) 

The private `GetBalance()` helper calls `GetActualTokenSymbol()` at line 169 to resolve the symbol before reading from `State.Balances[address][actualSymbol]` at line 171, correctly using the resolved symbol.

**Balance Modification Inconsistency:** [3](#0-2) 

The `ModifyBalance()` function at line 118 calls `GetBalance()` which returns the balance of the **resolved** symbol, but at line 124 it writes to `State.Balances[address][symbol]` using the **unresolved input parameter**. This creates phantom balances under alias keys while leaving actual balances unchanged.

**Vulnerable Issue Operation:** [4](#0-3) 

The `Issue()` function validates the token at line 158 (which resolves aliases via `GetTokenInfo()`), updates supply counters at lines 163-164, but then calls `ModifyBalance(input.To, input.Symbol, input.Amount)` at line 168 with the unresolved `input.Symbol`, not `tokenInfo.Symbol`.

**Vulnerable Burn Operation:** [5](#0-4) 

The private `Burn()` method has the same issue: it validates at line 325, decreases supply at line 328, but calls `ModifyBalance(address, symbol, -amount)` at line 327 with the unresolved `symbol` parameter.

**Contrast with Correct Implementation:** [6](#0-5) 

The `Transfer()` function demonstrates correct behavior by resolving the alias at line 182 and passing `tokenInfo.Symbol` (the resolved symbol) to `DoTransfer()` at line 183.

**Alias Setting Controls:** [7](#0-6) 

Aliases can be set by NFT collection owners/issuers through `SetSymbolAlias()`, with validation at lines 750, 752, and 760-761. While access is restricted, any legitimate NFT collection owner can exploit this vulnerability.

### Impact Explanation

**Direct Fund Impact - Token Supply Inflation:**
An attacker who owns or issues an NFT collection can inflate their token holdings beyond the `TotalSupply` limit through the following mechanism:

1. **Initial State**: Attacker creates NFT collection "EXPLOIT-0" with items like "EXPLOIT-1" (totalSupply = 1,000,000)
2. **Set Alias**: Attacker sets alias "EXPLOIT" → "EXPLOIT-1" (line 768)
3. **Legitimate Issue**: Issue 1,000,000 tokens: `balance["EXPLOIT-1"] = 1,000,000`, `supply = 1,000,000`
4. **Phantom Burn**: Burn 1,000,000 using alias "EXPLOIT":
   - GetBalance reads `State.Balances[attacker]["EXPLOIT-1"] = 1,000,000` (passes check)
   - ModifyBalance writes `State.Balances[attacker]["EXPLOIT"] = 0` (phantom key, never read)
   - Actual balance `State.Balances[attacker]["EXPLOIT-1"]` remains 1,000,000 (unchanged!)
   - Supply decreases to 0
5. **Re-Issue**: Issue another 1,000,000 tokens (supply check passes since supply = 0)
6. **Result**: Attacker holds 2,000,000 tokens while supply shows 1,000,000, bypassing totalSupply limit

**Critical Invariant Broken:**
The fundamental invariant that `tokenInfo.Supply == sum(all balances)` is violated. This breaks:
- Economic models relying on supply limits
- Tokenomics and scarcity guarantees
- Cross-chain supply synchronization
- Trust in token issuance limits

**Affected Parties:**
- All token holders (value dilution from unlimited inflation)
- Protocol governance (economic security assumptions broken)
- Cross-chain bridges (supply mismatches)
- DeFi protocols integrating these tokens

### Likelihood Explanation

**Reachable Entry Point:**
The exploit uses standard public methods: `Issue()` and `Burn()` are accessible to token issuers, and `SetSymbolAlias()` is accessible to NFT collection owners/issuers. No privileged access beyond being a legitimate token issuer is required.

**Feasible Preconditions:**
1. Attacker creates an NFT collection (anyone can do this via `Create()`)
2. Attacker sets an alias for their NFT (restricted to owner/issuer, but attacker controls their own NFT)
3. Attacker issues tokens to themselves (as the issuer, this is expected behavior)

**Execution Practicality:**
The attack requires only standard smart contract calls:
1. `Create()` to create NFT collection
2. `SetSymbolAlias()` to establish alias mapping  
3. Alternating `Issue()` and `Burn()` calls using alias vs real symbol
4. All operations are gas-efficient single transactions
5. No complex timing or race conditions required

**Economic Rationality:**
- Cost: Minimal gas fees for NFT creation and alias setup, plus standard issue/burn costs
- Benefit: Unlimited token multiplication, effectively minting value from nothing
- The exploit is undetectable from external view functions (GetBalance returns resolved symbol)
- Highly profitable for any token with monetary value

**Detection Constraints:**
The vulnerability is subtle - balances query correctly via GetBalance (which resolves aliases), so external monitoring won't detect the phantom balances. Only internal state auditing would reveal the inconsistency between supply counters and actual balance totals.

### Recommendation

**Immediate Fix - Resolve Symbols Before ModifyBalance:**

Modify `Issue()` to use resolved symbol:
```csharp
// Line 168 in TokenContract_Actions.cs
ModifyBalance(input.To, tokenInfo.Symbol, input.Amount);  // Use tokenInfo.Symbol not input.Symbol
```

Modify `Burn()` to use resolved symbol:
```csharp
// Line 327 in TokenContract_Actions.cs  
ModifyBalance(address, tokenInfo.Symbol, -amount);  // Use tokenInfo.Symbol not symbol parameter
```

**Alternative Fix - Resolve Inside ModifyBalance:**

Add alias resolution at the beginning of `ModifyBalance()`:
```csharp
private void ModifyBalance(Address address, string symbol, long addAmount)
{
    var actualSymbol = GetActualTokenSymbol(symbol);  // Add this line
    var before = GetBalance(address, actualSymbol);
    // ... rest of logic using actualSymbol everywhere
    State.Balances[address][actualSymbol] = target;
}
```

**Invariant Checks:**
Add validation in token operations to verify supply equals sum of balances periodically, or add assertions in Issue/Burn that the balance was actually modified:
```csharp
// After ModifyBalance in Issue
var newBalance = GetBalance(input.To, tokenInfo.Symbol);
Assert(newBalance >= input.Amount, "Balance update verification failed");
```

**Regression Tests:**
1. Test issuing tokens with alias, verify actual balance increases
2. Test burning tokens with alias, verify actual balance decreases  
3. Test that supply limits cannot be bypassed via alias manipulation
4. Test that phantom balances under alias keys don't accumulate

### Proof of Concept

**Initial State:**
- Attacker creates NFT collection "SCAM-0" with totalSupply = 1,000,000
- Attacker mints NFT item "SCAM-1"
- Attacker sets alias: "SCAM" → "SCAM-1"

**Transaction Sequence:**

**Step 1 - Legitimate Issue:**
```
Call: Issue({Symbol: "SCAM-1", Amount: 1000000, To: attacker})
Result: 
- State.Balances[attacker]["SCAM-1"] = 1,000,000
- tokenInfo.Supply = 1,000,000
- tokenInfo.Issued = 1,000,000
```

**Step 2 - Phantom Burn Using Alias:**
```
Call: Burn({Symbol: "SCAM", Amount: 1000000})
Execution:
- AssertValidToken("SCAM") resolves to "SCAM-1", passes validation
- ModifyBalance(attacker, "SCAM", -1000000):
  * GetBalance(attacker, "SCAM") resolves to "SCAM-1" → reads 1,000,000
  * Validation passes: 1,000,000 >= 1,000,000
  * Writes: State.Balances[attacker]["SCAM"] = 0 (phantom, never read)
- tokenInfo.Supply -= 1,000,000 → supply now 0

Result:
- State.Balances[attacker]["SCAM-1"] = 1,000,000 (UNCHANGED!)
- State.Balances[attacker]["SCAM"] = 0 (phantom key)
- tokenInfo.Supply = 0
```

**Step 3 - Re-Issue:**
```
Call: Issue({Symbol: "SCAM-1", Amount: 1000000, To: attacker})
- Supply check passes: 0 + 1,000,000 <= 1,000,000
- ModifyBalance(attacker, "SCAM-1", 1000000):
  * GetBalance reads State.Balances[attacker]["SCAM-1"] = 1,000,000
  * Writes: State.Balances[attacker]["SCAM-1"] = 2,000,000

Result:
- State.Balances[attacker]["SCAM-1"] = 2,000,000 (DOUBLED!)
- tokenInfo.Supply = 1,000,000 (within limit)
```

**Expected vs Actual:**
- **Expected**: Cannot issue more than totalSupply (1,000,000 tokens maximum)
- **Actual**: Attacker holds 2,000,000 tokens while supply shows 1,000,000
- **Success Condition**: `GetBalance(attacker, "SCAM-1") = 2,000,000` AND `tokenInfo.Supply = 1,000,000`

**Repeatability:**
Steps 2-3 can be repeated indefinitely to multiply tokens without bound, completely bypassing totalSupply restrictions.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L286-294)
```csharp
    private string GetActualTokenSymbol(string aliasOrSymbol)
    {
        if (State.TokenInfos[aliasOrSymbol] == null)
        {
            return State.SymbolAliasMap[aliasOrSymbol] ?? aliasOrSymbol;
        }

        return aliasOrSymbol;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L116-125)
```csharp
    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L166-172)
```csharp
    private long GetBalance(Address address, string symbol)
    {
        AssertValidInputAddress(address);
        var actualSymbol = GetActualTokenSymbol(symbol);
        Assert(!string.IsNullOrWhiteSpace(actualSymbol), "Invalid symbol.");
        return State.Balances[address][actualSymbol];
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L154-178)
```csharp
    public override Empty Issue(IssueInput input)
    {
        Assert(input.To != null, "To address not filled.");
        AssertValidMemo(input.Memo);
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");

        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(input.To, input.Symbol, input.Amount);

        Context.Fire(new Issued
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = input.To,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L323-337)
```csharp
    private Empty Burn(Address address, string symbol, long amount)
    {
        var tokenInfo = AssertValidToken(symbol, amount);
        Assert(tokenInfo.IsBurnable, "The token is not burnable.");
        ModifyBalance(address, symbol, -amount);
        tokenInfo.Supply = tokenInfo.Supply.Sub(amount);

        Context.Fire(new Burned
        {
            Burner = address,
            Symbol = symbol,
            Amount = amount
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L738-779)
```csharp
    public override Empty SetSymbolAlias(SetSymbolAliasInput input)
    {
        // Alias setting can only work for NFT Item for now.
        // And the setting exists on the TokenInfo of the NFT Collection.

        // Can only happen on Main Chain.
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "Symbol alias setting only works on MainChain.");

        var collectionSymbol = GetNftCollectionSymbol(input.Symbol, true);

        // For now, token alias can only be set once.
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");

        CheckTokenAlias(input.Alias, collectionSymbol);

        var collectionTokenInfo = GetTokenInfo(collectionSymbol);
        if (collectionTokenInfo == null)
        {
            throw new AssertionException($"NFT Collection {collectionSymbol} not found.");
        }

        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");

        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);

        State.SymbolAliasMap[input.Alias] = input.Symbol;

        Context.LogDebug(() => $"Token alias added: {input.Symbol} -> {input.Alias}");

        Context.Fire(new SymbolAliasAdded
        {
            Symbol = input.Symbol,
            Alias = input.Alias
        });

        return new Empty();
    }
```
