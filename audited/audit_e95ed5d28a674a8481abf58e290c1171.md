### Title
Missing Dictionary Key Validation in RecoverFromUpdateValue Causes DOS Through Block Rejection During Miner Replacements

### Summary
The `RecoverFromUpdateValue` method accesses `baseRound.RealTimeMinersInformation` dictionary entries without validating key existence, causing `KeyNotFoundException` when miner lists change mid-round. While the question focuses on line 25 of `LibInformationValidationProvider`, the actual vulnerability lies in `Round_Recover.cs` lines 24-29. Exceptions are caught by the execution framework but result in block rejection, potentially causing consensus stalls during legitimate miner replacements.

### Finding Description

The vulnerability exists in the consensus validation flow where round information recovery fails due to missing dictionary key checks: [1](#0-0) 

In `RecoverFromUpdateValue`, the foreach loop at lines 22-30 iterates through `providedRound.RealTimeMinersInformation` and accesses `baseRound.RealTimeMinersInformation[information.Key]` without checking if the key exists. While lines 10-12 validate that the sender's pubkey exists in both rounds, no such check exists for OTHER miners in the round.

This method is invoked during validation: [2](#0-1) 

The execution flow is:
1. Block validation calls `ValidateBeforeExecution` 
2. `RecoverFromUpdateValue` is called to reconstruct round state
3. Exception thrown if providedRound contains miners not in baseRound
4. Executive catches exception and sets trace status to `SystemError`: [3](#0-2) 

5. Validation returns null/false, causing block rejection

Regarding the question's specific concern about line 25 of `LibInformationValidationProvider`: [4](#0-3) 

This line is protected by prior validation. `MiningPermissionValidationProvider` runs first and ensures the sender's pubkey exists in baseRound: [5](#0-4) 

Therefore, line 25 of `LibInformationValidationProvider` should not throw under normal flow, making it a defensive programming issue rather than the primary vulnerability.

The root cause is that miner lists can change mid-round via `RecordCandidateReplacement`: [6](#0-5) 

This method removes old miners and adds new ones to `RealTimeMinersInformation`, creating a window where blocks created with the old miner list fail validation against the updated state.

### Impact Explanation

**Operational Impact - Consensus DOS:**
When `RecordCandidateReplacement` executes (legitimately called by Election Contract to replace misbehaving miners), a timing window opens where:

1. Honest miners who created blocks before the replacement have those blocks rejected during validation
2. Blocks contain `providedRound` with the old miner list (e.g., miners [A,B,C])
3. Validation reads `baseRound` with the updated miner list (e.g., miners [A,B,D] after C replaced by D)
4. `RecoverFromUpdateValue` throws `KeyNotFoundException` trying to access the removed miner's data
5. Block is rejected as if it were invalid

**Severity: Medium-High**
- Affects honest miners during legitimate miner replacements
- Can cause temporary consensus stalls if multiple miners' blocks are rejected
- Does not result in permanent DOS as miners will eventually create new blocks with updated state
- No fund loss, but chain availability/liveness is impacted

### Likelihood Explanation

**Likelihood: Medium**

**Attacker Capabilities:**
- No attacker required - vulnerability triggered by legitimate miner replacement operations
- Election Contract authorization required to call `RecordCandidateReplacement` (intended functionality)

**Preconditions:**
1. Miner replacement occurs via `RecordCandidateReplacement` 
2. Honest miner creates UpdateValue block before replacement
3. Block propagates and validates after replacement executes
4. Timing window between block creation and validation

**Execution Practicality:**
- Miner replacements are legitimate protocol operations
- The timing window exists during every miner replacement
- Multiple miners may be affected simultaneously if they created blocks before the replacement
- More likely during periods of high miner turnover or when addressing misbehaving miners

**Operational Constraints:**
- Temporary impact - miners recover by creating new blocks
- Detection is straightforward via `SystemError` in trace logs
- Network conditions (latency, propagation delays) affect probability

### Recommendation

**Fix RecoverFromUpdateValue:**
Add defensive key existence checks before accessing dictionary entries:

```csharp
foreach (var information in providedRound.RealTimeMinersInformation)
{
    // Add defensive check
    if (!RealTimeMinersInformation.ContainsKey(information.Key))
        continue; // or return graceful validation failure
        
    RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
        information.Value.SupposedOrderOfNextRound;
    RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
        information.Value.FinalOrderOfNextRound;
    RealTimeMinersInformation[information.Key].PreviousInValue =
        information.Value.PreviousInValue;
}
```

**Add Defensive Check in LibInformationValidationProvider:**
Even though protected by prior validation, add defensive programming:

```csharp
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
    baseRound.RealTimeMinersInformation.ContainsKey(pubkey) && // Add this check
    baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
```

**Test Cases:**
1. Test miner replacement during UpdateValue block validation
2. Verify blocks with stale miner lists are gracefully rejected with proper error messages
3. Test concurrent blocks from multiple miners during replacement window
4. Verify RecoverFromTinyBlock has similar protections

### Proof of Concept

**Initial State:**
- Current round has miners [AlicePubkey, BobPubkey, CharliePubkey]
- Round number: 100
- All miners are active and producing blocks

**Exploit Steps:**

1. **Alice creates UpdateValue block N:**
   - Calls `GetConsensusCommand` and `GetConsensusExtraData` at height N-1
   - Block header contains `providedRound` with miners [AlicePubkey, BobPubkey, CharliePubkey]
   - Uses `GetUpdateValueRound` which copies all current miners

2. **Charlie replacement transaction executes in competing block:**
   - Election Contract calls `RecordCandidateReplacement(CharliePubkey, DavidPubkey)`
   - State now has miners [AlicePubkey, BobPubkey, DavidPubkey]
   - Charlie removed, David added

3. **Alice's block N propagates to nodes for validation:**
   - `ValidateBeforeExecution` called with Alice's block
   - `TryToGetCurrentRoundInformation` returns baseRound with [AlicePubkey, BobPubkey, DavidPubkey]
   - `RecoverFromUpdateValue(providedRound, "AlicePubkey")` called
   - Lines 10-12: AlicePubkey exists in both → continue
   - Lines 22-30: foreach through providedRound miners:
     - Process AlicePubkey → OK
     - Process BobPubkey → OK  
     - Process CharliePubkey → **KeyNotFoundException**: CharliePubkey not in baseRound

4. **Result:**
   - Exception caught by Executive
   - Trace.ExecutionStatus = SystemError
   - Trace.Error = "System.Collections.Generic.KeyNotFoundException: ..."
   - `CallAsync` returns null
   - Validation fails, block rejected

**Expected:** Alice's block validated successfully (created before replacement)
**Actual:** Alice's block rejected with SystemError
**Success Condition:** Block rejection observable via failed validation, debug logs show KeyNotFoundException

### Notes

The question specifically asks about line 25 of `LibInformationValidationProvider`, but investigation reveals this line is protected by prior `MiningPermissionValidationProvider` checks. The actual vulnerability exists in `RecoverFromUpdateValue` at lines 24-29 of `Round_Recover.cs`, where missing key checks cause exceptions during legitimate miner replacement operations. This represents a timing-dependent DOS that affects honest miners but resolves as they create new blocks with updated state.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** src/AElf.Runtime.CSharp/Executive.cs (L148-152)
```csharp
        catch (Exception ex)
        {
            CurrentTransactionContext.Trace.ExecutionStatus = ExecutionStatus.SystemError;
            CurrentTransactionContext.Trace.Error += ex + "\n";
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-26)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-146)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```
