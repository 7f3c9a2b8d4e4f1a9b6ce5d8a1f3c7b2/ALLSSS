### Title
Unauthorized Round Termination by Non-Extra-Block-Producer Miners

### Summary
Any miner in the current round's miner list can produce NextRound or NextTerm blocks to terminate the round, even when they are not the designated extra block producer. The ConsensusCommand structure lacks pubkey-based authorization, and the validation pipeline fails to verify that the block producer is the intended extra block producer. This violates the fundamental consensus mechanism design where only a specific miner should terminate each round.

### Finding Description

The vulnerability exists in the consensus command generation and validation flow for round termination:

**Root Cause - Missing Authorization Field:**
The `ConsensusCommand` structure contains only timing information (`arranged_mining_time`, `mining_due_time`, `hint`, `limit_milliseconds_of_mining_block`) but no pubkey field to identify which miner should use it. [1](#0-0) 

**Command Generation Without Binding:**
When `TerminateRoundCommandStrategy.GetAEDPoSConsensusCommand()` generates a command for NextRound/NextTerm behavior, it accepts a `pubkey` parameter but doesn't embed it in the returned `ConsensusCommand`. [2](#0-1) 

**Insufficient Validation - MiningPermissionValidationProvider:**
Only checks if the sender is **any** miner in the round's miner list, not whether they are the designated extra block producer. [3](#0-2) 

**Insufficient Validation - TimeSlotValidationProvider:**
When validating a new round (`ProvidedRound.RoundId != BaseRound.RoundId`), only checks time slot consistency via `CheckRoundTimeSlots()`, not sender authorization. [4](#0-3) 

**Insufficient Validation - NextRoundMiningOrderValidationProvider:**
Only validates that miners with `FinalOrderOfNextRound > 0` equals miners with `OutValue != null`, not sender identity. [5](#0-4) 

**Insufficient Validation - RoundTerminateValidationProvider:**
Only validates round/term number increments and that InValues are null, not sender authorization. [6](#0-5) 

**No Method-Level Authorization:**
The `NextRound()` and `NextTerm()` methods lack any authorization checks to verify the caller is the extra block producer. [7](#0-6) [8](#0-7) 

**Validation Context Availability:**
The `ConsensusValidationContext` provides both `SenderPubkey` and `BaseRound` (which contains extra block producer information), but no validator uses them to check authorization. [9](#0-8) 

**Extra Block Producer Information Available But Unused:**
The `GetExtraBlockProducerInformation()` method correctly identifies the designated extra block producer in each round, but this information is never validated against the sender during NextRound/NextTerm block production. [10](#0-9) 

**IsCurrentMiner Check Not Applied:**
While `IsCurrentMiner()` contains logic to validate extra block time slots (lines 169-178), this check is never invoked during the NextRound/NextTerm validation pipeline. [11](#0-10) 

### Impact Explanation

**Consensus Mechanism Violation:**
The AEDPoS consensus design designates one specific extra block producer per round who is responsible for terminating the round and confirming the mining order for the next round. Allowing any miner to perform this role breaks this fundamental invariant.

**Incorrect State Recording:**
When an unauthorized miner produces a NextRound block, `GetConsensusExtraDataForNextRound()` incorrectly records that unauthorized miner's pubkey as `ExtraBlockProducerOfPreviousRound` in the next round. [12](#0-11) 

**Potential Reward Misallocation:**
If the extra block producer receives special rewards or privileges for round termination, unauthorized miners can claim these benefits.

**Mining Schedule Manipulation:**
The extra block producer influences the next round's mining order calculation. Unauthorized control of round termination could enable manipulation of block production schedules.

**Severity: Critical** - Violates core consensus safety properties and enables unauthorized control over round transitions, a fundamental blockchain operation.

### Likelihood Explanation

**Attacker Profile:**
Any miner currently in the miner list who is not the designated extra block producer.

**Attack Preconditions:**
1. Attacker must be in the current round's miner list (realistic for consensus participants)
2. Timing must be appropriate for round termination (natural occurrence in consensus flow)

**Attack Complexity: Low**
1. Call `GetConsensusCommand()` with attacker's own pubkey
2. Receive a valid `ConsensusCommand` with behavior NextRound/NextTerm
3. Produce a block at the appropriate time
4. Call `GetConsensusExtraData()` to generate consensus header information
5. Submit the block - all validation passes

**No Special Capabilities Required:**
- No private key compromise needed
- No state manipulation required
- Uses standard block production flow
- All steps are normal consensus operations

**Detection Difficulty: High**
The system records the unauthorized miner as a legitimate extra block producer in `ExtraBlockProducerOfPreviousRound`, making the attack appear valid in historical data.

**Economic Feasibility:**
Cost is equivalent to normal block production (gas fees, computational resources). Benefit includes potential rewards and consensus manipulation capabilities.

**Probability: High** - Any non-extra-block-producer miner can execute this during their time window, and the attack is undetectable by current validation logic.

### Recommendation

**Add Extra Block Producer Validation:**
Create a new validation provider `ExtraBlockProducerValidationProvider` that validates the sender is the designated extra block producer for NextRound/NextTerm behaviors:

```csharp
public class ExtraBlockProducerValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var behaviour = validationContext.ExtraData.Behaviour;
        
        // Only apply to round termination behaviors
        if (behaviour != AElfConsensusBehaviour.NextRound && 
            behaviour != AElfConsensusBehaviour.NextTerm)
        {
            validationResult.Success = true;
            return validationResult;
        }
        
        // Get the designated extra block producer
        var extraBlockProducer = validationContext.BaseRound.GetExtraBlockProducerInformation();
        
        // Verify sender matches the designated extra block producer
        if (extraBlockProducer.Pubkey != validationContext.SenderPubkey)
        {
            validationResult.Message = 
                $"Sender {validationContext.SenderPubkey} is not the designated extra block producer. " +
                $"Expected: {extraBlockProducer.Pubkey}";
            return validationResult;
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

**Register the New Validator:**
Add this provider to the validation pipeline in `ValidateBeforeExecution()`: [13](#0-12) 

Insert after line 75 (before behavior-specific validators):
```csharp
validationProviders.Add(new ExtraBlockProducerValidationProvider());
```

**Add Test Cases:**
1. Test that non-extra-block-producer miners cannot produce NextRound blocks
2. Test that only the designated extra block producer can terminate rounds
3. Test that ExtraBlockProducerOfPreviousRound is correctly validated

### Proof of Concept

**Initial State:**
- Round with 5 miners: A, B, C, D, E
- Miner A is designated as extra block producer (`IsExtraBlockProducer = true`)
- Miner B (attacker) is in the miner list but NOT the extra block producer
- All regular miners have produced their blocks
- Current time is in the extra block time slot

**Attack Sequence:**

**Step 1:** Attacker (Miner B) calls `GetConsensusCommand(MinerB_Pubkey)`
- System determines behavior should be `NextRound` based on state
- Returns `ConsensusCommand` with `ArrangedMiningTime`, no pubkey restriction

**Step 2:** Attacker produces a block and signs it with their key

**Step 3:** Attacker calls `GetConsensusExtraData()` with `AElfConsensusTriggerInformation` containing:
- `Pubkey = MinerB_Pubkey`
- `Behaviour = NextRound`

**Step 4:** `GetConsensusExtraDataForNextRound()` executes:
- Generates next round information
- **Sets `nextRound.ExtraBlockProducerOfPreviousRound = MinerB_Pubkey`** (WRONG - should be Miner A)
- Returns consensus header information with `SenderPubkey = MinerB_Pubkey`

**Step 5:** Block validation executes:
- `AEDPoSExtraDataExtractor`: Validates `SenderPubkey == SignerPubkey` ✓ (Passes - both are Miner B)
- `MiningPermissionValidationProvider`: Validates Miner B is in miner list ✓ (Passes)
- `TimeSlotValidationProvider`: New round detected, only calls `CheckRoundTimeSlots()` ✓ (Passes)
- `ContinuousBlocksValidationProvider`: Checks continuous blocks ✓ (Passes)
- `NextRoundMiningOrderValidationProvider`: Validates `FinalOrderOfNextRound` structure ✓ (Passes)
- `RoundTerminateValidationProvider`: Validates round number increment ✓ (Passes)
- **NO validator checks if Miner B is the extra block producer** ✗ (Missing)

**Step 6:** Block accepted, `NextRound()` transaction executes successfully

**Expected Result:**
Block rejected with error: "Sender MinerB_Pubkey is not the designated extra block producer"

**Actual Result:**
Block accepted, round terminates with Miner B recorded as the terminator instead of the rightful extra block producer (Miner A)

**Success Condition:**
The round advances with an unauthorized miner having terminated it, violating consensus invariants.

### Citations

**File:** protobuf/acs4.proto (L47-56)
```text
message ConsensusCommand {
    // Time limit of mining next block.
    int32 limit_milliseconds_of_mining_block = 1;
    // Context of Hint is diverse according to the consensus protocol we choose, so we use bytes.
    bytes hint = 2;
    // The time of arrange mining.
    google.protobuf.Timestamp arranged_mining_time = 3;
    // The expiration time of mining.
    google.protobuf.Timestamp mining_due_time = 4;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-39)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L10-47)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) return ValidationForNextRound(validationContext);

        if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) return ValidationForNextTerm(validationContext);

        validationResult.Success = true;
        return validationResult;
    }

    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L8-41)
```csharp
public class ConsensusValidationContext
{
    public long CurrentTermNumber { get; set; }
    public long CurrentRoundNumber { get; set; }

    /// <summary>
    ///     We can trust this because we already validated the pubkey
    ///     during `AEDPoSExtraDataExtractor.ExtractConsensusExtraData`
    /// </summary>
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();

    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;

    /// <summary>
    ///     Previous round information fetch from StateDb.
    /// </summary>
    public Round PreviousRound { get; set; }

    /// <summary>
    ///     This filed is to prevent one miner produces too many continues blocks
    ///     (which may cause problems to other parts).
    /// </summary>
    public LatestPubkeyToTinyBlocksCount LatestPubkeyToTinyBlocksCount { get; set; }

    public AElfConsensusHeaderInformation ExtraData { get; set; }
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L136-178)
```csharp
    private bool IsCurrentMiner(string pubkey)
    {
        if (pubkey == null) return false;

        if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;

        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;

        Context.LogDebug(() =>
            $"Extra block producer of previous round: {currentRound.ExtraBlockProducerOfPreviousRound}");

        // Check confirmed extra block producer of previous round.
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }

        var miningInterval = currentRound.GetMiningInterval();
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
        var timeSlotStartTime = minerInRound.ExpectedMiningTime;

        // Check normal time slot.
        if (timeSlotStartTime <= Context.CurrentBlockTime && Context.CurrentBlockTime <=
            timeSlotStartTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]NORMAL");
            return true;
        }

        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-203)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```
