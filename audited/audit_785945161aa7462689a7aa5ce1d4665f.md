# Audit Report

## Title
Insufficient Order Validation Allows Duplicate Mining Orders to Break Secret Sharing Reconstruction

## Summary
The AEDPoS consensus mechanism contains three interconnected validation failures that allow a malicious miner to create duplicate `FinalOrderOfNextRound` values through crafted `TuneOrderInformation`. These duplicate orders propagate to subsequent rounds and cause the Shamir's Secret Sharing reconstruction in `DecodeSecret` to produce incorrect results due to division by zero in Lagrange interpolation, compromising the consensus secret sharing verification mechanism.

## Finding Description

The vulnerability exists due to three interconnected validation failures:

**Root Cause #1 - Flawed Duplicate Detection:**

The `NextRoundMiningOrderValidationProvider` attempts to validate mining order uniqueness but the implementation is incorrect. [1](#0-0) 

The `Distinct()` method operates on `MinerInRound` objects rather than extracting and checking the `FinalOrderOfNextRound` property values themselves. Since each miner has a unique `MinerInRound` instance, the distinctness check always passes regardless of whether the actual `FinalOrderOfNextRound` values are duplicates.

**Root Cause #2 - Unvalidated TuneOrderInformation:**

When processing `UpdateValue`, the contract blindly applies whatever `TuneOrderInformation` is provided without validating uniqueness or range. [2](#0-1) 

A malicious miner can craft an `UpdateValueInput` with duplicate `FinalOrderOfNextRound` values in `TuneOrderInformation`, and these will be directly applied to the round state. The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`. [3](#0-2) 

Additionally, the validation framework only applies `NextRoundMiningOrderValidationProvider` for `NextRound` behavior, not for `UpdateValue` behavior. [4](#0-3) 

**Root Cause #3 - Missing Duplicate Order Validation in DecodeSecret:**

When a new round is generated, the `FinalOrderOfNextRound` values from the current round become the `Order` values in the next round. [5](#0-4) 

Subsequently, `RevealSharedInValues` extracts order values from the previous round's miner information and passes them to `DecodeSecret`. [6](#0-5) 

The `DecodeSecret` function performs Shamir's Secret Sharing reconstruction using Lagrange interpolation but does not validate that the `orders` parameter contains unique values. [7](#0-6) 

When duplicate orders exist (e.g., `orders[j] == orders[i]` for `j != i`), the denominator calculation `orders[j] - orders[i]` becomes zero. [8](#0-7) 

This zero denominator flows through `MultiplyRational` [9](#0-8) , then `RationalToWhole` calls `Inverse(0)` [10](#0-9) . The `Inverse` function with input 0 returns 0 through the Extended Euclidean Algorithm [11](#0-10) , causing the Lagrange basis polynomial term to evaluate incorrectly, resulting in incorrect secret reconstruction.

**Attack Sequence:**

1. Round N: Malicious miner (who must be in the active miner set) submits `UpdateValue` with duplicate `FinalOrderOfNextRound` values in `TuneOrderInformation`
2. `ProcessUpdateValue` applies these duplicate values without validation
3. Round N+1: When `NextRound` is called, `GenerateNextRoundInformation` sets the `Order` values in the new round based on `FinalOrderOfNextRound` from Round N, creating duplicate `Order` values
4. Round N+1: Miners perform secret sharing with `DecryptedPieces`
5. Round N+2: When `RevealSharedInValues` is called, it extracts the duplicate `Order` values and passes them to `DecodeSecret`
6. `DecodeSecret` produces incorrect results due to division by zero, setting wrong `PreviousInValue` hashes

## Impact Explanation

**Consensus Integrity Compromise:**

The secret sharing mechanism is a critical component of AEDPoS consensus designed to reconstruct and verify miners' `PreviousInValue` through Lagrange interpolation. This ensures miners cannot cheat on their random value commitments, which are fundamental to consensus security and random number generation.

When `DecodeSecret` produces incorrect results due to duplicate orders:
- Miners' `PreviousInValue` fields are set to wrong hash values in the current round
- The cryptographic integrity of the random number generation chain is broken
- The consensus validation mechanism for miner behavior becomes unreliable
- Subsequent rounds may fail validation or accept invalid consensus states
- The network may experience consensus disruption requiring manual intervention

**Affected Parties:**
- All consensus participants are affected as the secret sharing verification becomes unreliable
- The entire network's consensus security is degraded when this mechanism fails
- Honest miners may be falsely flagged or malicious behavior may go undetected

**Severity Assessment: Medium**
- Does not directly result in fund theft or unauthorized token minting
- Compromises consensus integrity and random number generation security  
- Could enable secondary attacks by breaking miner behavior verification
- May cause consensus disruption but does not permanently halt the chain

## Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an active miner in the consensus set (requires winning election through governance)
- No special privileges beyond normal miner capabilities required
- Can craft malicious `UpdateValueInput` with duplicate `TuneOrderInformation` values

**Attack Complexity:**
- Low technical complexity: Simply requires modifying the `TuneOrderInformation` field when calling `UpdateValue`
- No sophisticated cryptographic attacks or precise timing manipulation needed
- Can be executed in a single transaction during the attacker's designated mining slot
- The flawed validation allows the attack to succeed on-chain

**Feasibility Conditions:**
- Requires the attacker to be selected as a miner through the election process
- Secret sharing must be enabled (checked via configuration contract) [12](#0-11) 
- The malicious round must successfully transition through `NextRound` to propagate duplicate orders
- Effects manifest two rounds later when `RevealSharedInValues` is called

**Detection Constraints:**
- The incorrect `PreviousInValue` values would be detectable through off-chain monitoring
- However, the flawed validation allows the attack to succeed on-chain before detection
- May cause observable consensus anomalies that alert network operators

**Likelihood Assessment: Medium**
- Requires compromised miner position, but miners are elected through governance mechanisms
- Easy to execute once in position with low technical barriers
- Detectable through monitoring but may cause temporary disruption before remediation

## Recommendation

**Fix Root Cause #1 - Correct Duplicate Detection:**

In `NextRoundMiningOrderValidationProvider.cs`, extract the `FinalOrderOfNextRound` values before checking distinctness:

```csharp
var finalOrders = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
var distinctCount = finalOrders.Distinct().Count();
if (distinctCount != finalOrders.Count || distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
{
    validationResult.Message = "Invalid FinalOrderOfNextRound - duplicates detected.";
    return validationResult;
}
```

**Fix Root Cause #2 - Validate TuneOrderInformation:**

In `ProcessUpdateValue`, add validation before applying `TuneOrderInformation`:

```csharp
// Validate TuneOrderInformation for duplicates
var tunedOrders = updateValueInput.TuneOrderInformation.Values.ToList();
if (tunedOrders.Distinct().Count() != tunedOrders.Count)
{
    Assert(false, "Duplicate orders detected in TuneOrderInformation.");
}

foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**Fix Root Cause #3 - Add Input Validation in DecodeSecret:**

In `SecretSharingHelper.DecodeSecret`, validate that orders are unique:

```csharp
public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
{
    // Validate no duplicate orders
    if (orders.Distinct().Count() != orders.Count)
    {
        throw new InvalidOperationException("Orders must be unique for secret reconstruction.");
    }
    
    var result = BigInteger.Zero;
    // ... rest of implementation
}
```

## Proof of Concept

```csharp
using System.Collections.Generic;
using System.Linq;
using System.Text;
using AElf.Cryptography.SecretSharing;
using Xunit;

namespace AElf.Cryptography.Tests
{
    public class DuplicateOrderVulnerabilityTest
    {
        [Fact]
        public void DecodeSecret_WithDuplicateOrders_ProducesIncorrectResult()
        {
            // Setup: Create a valid secret and encode it
            var secretMessage = Encoding.UTF8.GetBytes("test_secret");
            int threshold = 3;
            int totalParts = 5;
            
            var encodedParts = SecretSharingHelper.EncodeSecret(secretMessage, threshold, totalParts);
            
            // Normal case: Decode with unique orders (should work correctly)
            var normalOrders = new List<int> { 1, 2, 3 };
            var normalResult = SecretSharingHelper.DecodeSecret(
                encodedParts.Take(threshold).ToList(), 
                normalOrders, 
                threshold
            );
            Assert.Equal(secretMessage, normalResult);
            
            // Attack case: Decode with duplicate orders (causes incorrect reconstruction)
            var duplicateOrders = new List<int> { 1, 2, 2 }; // Duplicate order value
            var maliciousResult = SecretSharingHelper.DecodeSecret(
                encodedParts.Take(threshold).ToList(),
                duplicateOrders,
                threshold
            );
            
            // The result will be incorrect due to division by zero in Lagrange interpolation
            Assert.NotEqual(secretMessage, maliciousResult);
        }
    }
}
```

This proof of concept demonstrates that `DecodeSecret` produces incorrect results when provided with duplicate order values, confirming the vulnerability in the secret sharing reconstruction mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-88)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-50)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L67-70)
```csharp
        private static BigInteger RationalToWhole(BigInteger numerator, BigInteger denominator)
        {
            return numerator * Inverse(denominator) % SecretSharingConsts.FieldPrime;
        }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L83-96)
```csharp
        private static (BigInteger gcd, BigInteger invA, BigInteger invB) GetGreatestCommonDivisor2(BigInteger integer1,
            BigInteger integer2)
        {
            if (integer2 == 0) return (integer1, 1, 0);

            var div = BigInteger.DivRem(integer1, integer2, out var rem);
            var (g, iA, iB) = GetGreatestCommonDivisor2(integer2, rem);
            return (g, iB, iA - iB * div);
        }

        private static BigInteger Inverse(BigInteger integer)
        {
            return GetGreatestCommonDivisor2(SecretSharingConsts.FieldPrime, integer).invB.Abs();
        }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L98-106)
```csharp
        private static (BigInteger numerator, BigInteger denominator) MultiplyRational(
            BigInteger numeratorLhs, BigInteger denominatorLhs,
            BigInteger numeratorRhs, BigInteger denominatorRhs)
        {
            var numerator = numeratorLhs * numeratorRhs % SecretSharingConsts.FieldPrime;
            var denominator = denominatorLhs * denominatorRhs % SecretSharingConsts.FieldPrime;
            var gcd = GetGreatestCommonDivisor(numerator, denominator);
            return (numerator / gcd, denominator / gcd);
        }
```
