### Title
Treasury Donation DoS Due to Unchecked TokenConverter Liquidity

### Summary
The `ConvertToNativeToken()` function in TreasuryContract calls TokenConverter's `Sell` method with the full donation amount without verifying sufficient liquidity reserves. When the TokenConverter's deposit balance is insufficient, the sell operation reverts due to arithmetic underflow, causing the entire donation transaction to fail. This creates a denial-of-service condition where donations of convertible tokens become impossible until TokenConverter liquidity is manually restored.

### Finding Description

The vulnerability exists in the Treasury contract's donation flow for non-native tokens that are convertible to the native token: [1](#0-0) 

When a user donates a token that can be exchanged with the native symbol, the `Donate` function determines conversion is needed and calls `ConvertToNativeToken`: [2](#0-1) 

The only validation performed is checking if the symbol is "able to sell" via `IsSymbolAbleToSell`: [3](#0-2) 

However, this check only verifies that the connector's `IsPurchaseEnabled` flag is true, not the actual liquidity: [4](#0-3) 

When `ConvertToNativeToken` calls the TokenConverter's `Sell` method, it performs a deposit balance subtraction that will throw an underflow exception if insufficient reserves exist: [5](#0-4) 

The project has overflow/underflow checking enabled: [6](#0-5) 

**Root Cause**: The Treasury contract does not query `GetDepositConnectorBalance` before attempting conversion, and provides no fallback mechanism to donate unconverted tokens when the TokenConverter lacks liquidity.

**Why Existing Protections Fail**: The `IsSymbolAbleToSell` check validates connector configuration but ignores actual available reserves. The Bancor formula calculates an `amountToReceive` based on connector balances, but if the actual deposit balance has been depleted (e.g., due to concurrent transactions or natural market activity), the subtraction operation fails.

### Impact Explanation

**Harm**: Donations of specific tokens to the Treasury become completely blocked when the TokenConverter has insufficient deposit balance for the corresponding token pair. This represents a denial-of-service on Treasury revenue streams.

**Affected Parties**: 
- Users attempting to donate convertible tokens cannot complete transactions
- The Treasury contract cannot receive donations of affected tokens
- The protocol's economic system loses a revenue source

**Severity Justification**: Medium severity because:
1. No funds are lost (transactions revert cleanly)
2. Causes operational disruption to Treasury functionality
3. Requires external intervention (adding liquidity to TokenConverter) to restore functionality
4. Affects only specific tokens, not all donations
5. Does not compromise core consensus, governance, or token supply invariants

The blocking persists indefinitely until someone manually adds sufficient liquidity to the TokenConverter, as there is no automatic recovery mechanism.

### Likelihood Explanation

**Attacker Capabilities**: No special privileges required. Any user can trigger this by attempting to donate when conditions exist.

**Attack Complexity**: Low. Simply call the public `Donate` function with a convertible token symbol when TokenConverter liquidity is depleted.

**Feasibility Conditions**:
1. A token must be registered in TokenConverter with `IsPurchaseEnabled = true`
2. The TokenConverter's deposit balance for that token pair must be insufficient
3. This can occur naturally during heavy selling pressure or if initial liquidity is low

**Detection/Operational Constraints**: The vulnerability is easy to detect once triggered (donation transactions revert), but there's no proactive monitoring to prevent it. The Treasury contract has no mechanism to detect low liquidity states before attempting conversions.

**Probability Reasoning**: Medium probability because TokenConverter liquidity can naturally deplete during normal market operations, especially for less-traded token pairs. No attacker action is required beyond attempting a donation at the right time.

### Recommendation

**Code-Level Mitigation**:

1. Add liquidity validation before attempting conversion in `ConvertToNativeToken`:
```csharp
private void ConvertToNativeToken(string symbol, long amount)
{
    // Query available liquidity
    var depositBalance = State.TokenConverterContract.GetDepositConnectorBalance.Call(
        new StringValue { Value = symbol }).Value;
    
    // Calculate expected return
    var pairConnector = State.TokenConverterContract.GetPairConnector.Call(
        new TokenSymbol { Symbol = symbol });
    // Use Bancor calculation to estimate amountToReceive
    
    Assert(depositBalance >= estimatedReturn, 
        "Insufficient TokenConverter liquidity for conversion");
    
    // Proceed with existing logic...
}
```

2. Add a fallback mechanism to donate tokens directly without conversion when liquidity is insufficient:
```csharp
if (needToConvert)
{
    if (HasSufficientConverterLiquidity(input.Symbol, input.Amount))
    {
        ConvertToNativeToken(input.Symbol, input.Amount);
    }
    else
    {
        // Donate directly without conversion
        DonateDirectly(input.Symbol, input.Amount);
    }
}
```

3. Consider adding the token to the SymbolList to allow direct donations alongside conversion attempts.

**Invariant Checks**: Before calling TokenConverter.Sell, verify: `depositBalance >= calculatedAmountToReceive`

**Test Cases**: 
- Test donation of convertible token when TokenConverter deposit balance is zero
- Test donation when deposit balance is less than calculated return amount
- Test that donations succeed via fallback path when conversion fails
- Test that proper error messages are returned to users

### Proof of Concept

**Required Initial State**:
1. Token X is registered in TokenConverter with `IsPurchaseEnabled = true`
2. TokenConverter has very low or zero deposit balance for token X's pair
3. User has balance of token X and has approved Treasury contract

**Transaction Steps**:
1. User calls `Treasury.Donate(symbol: "X", amount: 1000)`
2. Treasury validates `IsTokenAvailableForMethodFee` - passes
3. Treasury calls `IsSymbolAbleToSell("X")` - returns true (only checks flag)
4. Treasury determines `needToConvert = true`
5. Treasury calls `ConvertToNativeToken("X", 1000)`
6. ConvertToNativeToken approves TokenConverter and calls `Sell("X", 1000)`
7. TokenConverter.Sell calculates `amountToReceive` using Bancor formula
8. TokenConverter attempts: `State.DepositBalance[ntSymbol].Sub(amountToReceive)`
9. Underflow exception thrown because `DepositBalance < amountToReceive`
10. Entire transaction reverts

**Expected Result**: Donation should either succeed with fallback mechanism or provide clear error about insufficient liquidity

**Actual Result**: Transaction reverts with generic underflow exception, donation fails completely

**Success Condition**: Any subsequent attempt to donate token X will fail identically until TokenConverter liquidity is restored through external means.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L189-192)
```csharp
        var canExchangeWithNativeSymbol =
            isNativeSymbol ||
            State.TokenConverterContract.IsSymbolAbleToSell
                .Call(new StringValue { Value = input.Symbol }).Value;
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L204-208)
```csharp
        var needToConvert = !isNativeSymbol && canExchangeWithNativeSymbol;
        if (needToConvert)
        {
            ConvertToNativeToken(input.Symbol, input.Amount);
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L667-686)
```csharp
    private void ConvertToNativeToken(string symbol, long amount)
    {
        State.TokenContract.Approve.Send(new ApproveInput
        {
            Spender = State.TokenConverterContract.Value,
            Symbol = symbol,
            Amount = amount
        });

        State.TokenConverterContract.Sell.Send(new SellInput
        {
            Symbol = symbol,
            Amount = amount
        });

        Context.SendInline(Context.Self, nameof(DonateAll), new DonateAllInput
        {
            Symbol = Context.Variables.NativeSymbol
        });
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L104-108)
```csharp
    public override BoolValue IsSymbolAbleToSell(StringValue input)
    {
        var depositConnector = GetPairConnector(new TokenSymbol { Symbol = input.Value }).DepositConnector;
        return new BoolValue { Value = depositConnector != null && depositConnector.IsPurchaseEnabled };
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/AElf.Contracts.TokenConverter.csproj (L11-16)
```text
    <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
    <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
```
