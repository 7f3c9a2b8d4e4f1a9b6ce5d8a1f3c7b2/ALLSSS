# Audit Report

## Title
Missing Miner List Validation During Term Transitions Allows Consensus Takeover

## Summary
The `NextTerm` function accepts arbitrary miner lists from block producers without validating them against the Election Contract's authoritative `GetVictories` result. Any current miner can craft a term transition block containing only themselves and accomplices as the new miner set, completely taking over network consensus and invalidating the DPoS election mechanism.

## Finding Description

The AElf consensus system has a critical validation gap during term transitions. When an honest miner produces a NextTerm block, they call `GenerateFirstRoundOfNextTerm` which queries the Election Contract via `TryToGetVictories` to obtain the legitimately elected miners. [1](#0-0) 

However, malicious miners can bypass this legitimate flow entirely by crafting custom consensus data with arbitrary miners in the `RealTimeMinersInformation` field of their `NextTermInput`.

The validation system fails to detect this attack at multiple critical checkpoints:

**1. Pre-Execution Validation:**
The `ValidateConsensusBeforeExecution` method only adds `RoundTerminateValidationProvider` for NextTerm behavior. [2](#0-1) 

This validator only checks that term and round numbers increment correctlyâ€”it never validates the miner list composition. [3](#0-2) 

**2. Transaction Execution:**
The `NextTerm` public method calls `ProcessConsensusInformation` [4](#0-3)  which only performs a `PreCheck` authorization that verifies the sender is in the current or previous miner list. [5](#0-4) 

Then `ProcessNextTerm` directly extracts the miner list from the malicious input and sets it as the official miner list via `SetMinerList` without any validation against the Election Contract. [6](#0-5) 

**3. Type Conversion:**
The `NextTermInput.ToRound()` conversion performs no integrity checks, blindly copying the attacker-provided miner information. [7](#0-6) 

**Attack Execution:**
1. Malicious miner M waits for their designated time slot during a term transition period
2. M crafts a `NextTermInput` containing only their own public key and accomplices in `RealTimeMinersInformation`
3. M produces a block with this malicious consensus data and correct term/round number increments
4. Network validates via `ValidateConsensusBeforeExecution` - passes (no miner list check)
5. `ProcessNextTerm` executes, extracting the malicious miner list and calling `SetMinerList`
6. The malicious miner list becomes the official consensus miner list
7. Only attackers can produce subsequent blocks, maintaining perpetual control

## Impact Explanation

**Critical Severity - Complete Network Compromise:**

**Consensus Takeover:** The attacker gains total control over block production by setting themselves as the exclusive miner(s). All legitimately elected miners are permanently excluded from the network. The attacker maintains control indefinitely by continuing to exclude others in subsequent term transitions.

**Governance Capture:** Control over block production grants complete control over all governance mechanisms. The attacker can unilaterally pass any Parliament/Association/Referendum proposal, modify any system parameter, control the Treasury, and manipulate the token supply without any checks.

**Election System Invalidation:** This breaks the fundamental security guarantee of the DPoS (Delegated Proof of Stake) election mechanism. Token holders' votes become meaningless as the election results from `GetVictories` are completely ignored. All staking and voting activities lose their purpose.

**Economic Impact:** 
- Legitimate miners lose all block production rewards
- Attacker collects all future mining rewards
- Attacker controls Treasury fund distributions
- Network trust collapses, destroying token value

**Irreversibility:** Once executed, the attack cannot be reversed without manual intervention or hard fork, as the attacker controls all block production and can reject any recovery attempts.

## Likelihood Explanation

**High Likelihood - Low Barrier to Entry:**

**Attacker Prerequisites:**
- Must be a current miner (any one of the existing miners can execute this attack)
- Must control their miner node software to produce custom consensus data
- Must wait for a term transition period (occurs regularly and predictably)

**Attack Complexity: LOW**
- Requires only a single compromised miner (no coordination needed)
- No special cryptographic attacks required
- Uses standard block production mechanisms
- No economic cost beyond normal block production operations

**Feasibility:**
- Attack window opens at every term transition (predictable, recurring opportunity)
- Time slot validation is the only timing constraint, which any legitimate miner can satisfy
- No financial barriers or stake requirements beyond being an existing miner
- Detection only occurs after execution when the damage is irreversible

**Realistic Scenario:**
Given that mining nodes are operated by various entities with different security postures, the probability that at least one miner becomes compromised (through malware, insider threat, or intentional malice) is substantial. Once compromised, executing this attack is straightforward and highly rewarding for the attacker.

## Recommendation

Implement miner list validation against the Election Contract's authoritative source:

**1. Add Miner List Validation Provider:**
Create a new `MinerListValidationProvider` that verifies the miner list in `NextTermInput` matches the Election Contract's `GetVictories` result for main chain term transitions.

**2. Register the Validator:**
Add the new validation provider to the validation chain in `ValidateBeforeExecution` for `AElfConsensusBehaviour.NextTerm` behavior.

**3. Implementation Example:**
```csharp
public class MinerListValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        
        // Only validate on main chain for NextTerm behavior
        if (extraData.Behaviour != AElfConsensusBehaviour.NextTerm)
        {
            validationResult.Success = true;
            return validationResult;
        }
        
        // Get official victories from Election Contract
        var officialVictories = GetOfficialVictories();
        if (officialVictories == null || !officialVictories.Any())
        {
            // Side chains or initial setup - allow current miners
            validationResult.Success = true;
            return validationResult;
        }
        
        // Extract provided miners from header
        var providedMiners = extraData.Round.RealTimeMinersInformation.Keys.ToHashSet();
        var officialMiners = officialVictories.Select(pk => pk.ToHex()).ToHashSet();
        
        // Verify exact match
        if (!providedMiners.SetEquals(officialMiners))
        {
            validationResult.Message = 
                $"Miner list mismatch. Provided: {string.Join(",", providedMiners)}. " +
                $"Official: {string.Join(",", officialMiners)}";
            return validationResult;
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

**4. Update Validation Registration:**
In `AEDPoSContract_Validation.cs`, add the miner list validator:
```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new MinerListValidationProvider()); // Add this line
    break;
```

This ensures that only blocks with legitimately elected miner lists can successfully execute term transitions, preserving the integrity of the DPoS election mechanism.

## Proof of Concept

A proof of concept would require setting up a full AElf test network with the following test:

```csharp
[Fact]
public async Task MaliciousMiner_CanTakeoverConsensus_ViaArbitraryMinerList()
{
    // Setup: Initialize chain with legitimate miners from election
    var legitimateMiners = await ElectionContract.GetVictories();
    var maliciousMiner = legitimateMiners.First();
    
    // Get current term and round info
    var currentRound = await ConsensusContract.GetCurrentRoundInformation();
    
    // Attack: Craft NextTermInput with only attacker as miner
    var maliciousNextTermInput = new NextTermInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber + 1,
        RealTimeMinersInformation = 
        {
            // Only include attacker, exclude all other legitimate miners
            { maliciousMiner.ToHex(), new MinerInRound { Pubkey = maliciousMiner.ToHex() } }
        }
    };
    
    // Execute: Malicious miner produces NextTerm block
    var result = await ConsensusContract.NextTerm(maliciousNextTermInput);
    result.Should().BeSuccess(); // Attack succeeds
    
    // Verify: Attacker is now the only official miner
    var newMinerList = await ConsensusContract.GetCurrentMinerList();
    newMinerList.Pubkeys.Count.Should().Be(1);
    newMinerList.Pubkeys.First().Should().Be(maliciousMiner);
    
    // Impact: Legitimate miners cannot produce blocks
    foreach (var legitimateMiner in legitimateMiners.Skip(1))
    {
        var blockResult = await TryProduceBlock(legitimateMiner);
        blockResult.Should().Fail(); // Excluded miners rejected
    }
}
```

This test demonstrates that a malicious miner can successfully set themselves as the sole miner, excluding all legitimately elected miners and taking complete control of the consensus mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-17)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```
