### Title
Inconsistent Vote Accounting After Member Removal Allows Governance Manipulation

### Summary
The `RemoveMember` function does not invalidate existing votes from removed members on active proposals, creating an inconsistent vote accounting system. While approval/rejection/abstention counts filter out non-members, the total vote threshold count includes all historical votes. This allows a majority coalition to manipulate proposal outcomes by removing dissenting members after they vote, effectively bypassing rejection thresholds and quorum requirements.

### Finding Description

The vulnerability exists in the interaction between three components:

**1. Member Removal (No Vote Cleanup)** [1](#0-0) 

The `RemoveMember` function removes an address from the organization's member list but does not clean up that member's existing votes in any active proposals. The member's address remains in the `Approvals`, `Rejections`, or `Abstentions` lists of proposals they voted on.

**2. Inconsistent Vote Counting Logic** [2](#0-1) 

The threshold checking logic has a critical inconsistency:
- Rejection count (line 36-37): Filters by current membership using `.Count(organization.OrganizationMemberList.Contains)`
- Abstention count (line 43): Filters by current membership
- Approval count (line 49): Filters by current membership
- **Total vote count** (line 55-56): Does NOT filter - counts ALL historical votes with `.Concat().Count()`

**3. Release Validation** [3](#0-2) 

When releasing a proposal, the validation uses the CURRENT organization state (line 187-188), meaning any members removed between voting and release will have their votes handled inconsistently.

**Root Cause**: The filtering predicate `organization.OrganizationMemberList.Contains` is applied to individual vote type counts but not to the aggregate total vote count used for `MinimalVoteThreshold` validation.

### Impact Explanation

**Concrete Harm**:
1. **Threshold Bypass**: A majority coalition can remove members who voted against a proposal, causing:
   - Their rejections to no longer count toward `MaximalRejectionThreshold`
   - Their abstentions to no longer count toward `MaximalAbstentionThreshold`
   - But their votes still count toward `MinimalVoteThreshold`

2. **Governance Manipulation**: Proposals that should be rejected can be artificially approved by removing dissenting members.

3. **Quorum Gaming**: The `MinimalVoteThreshold` can be met with votes from removed members, while actual participation from current members is lower than intended.

**Example Impact**:
- Organization: 10 members
- Thresholds: MinimalVoteThreshold=7, MinimalApprovalThreshold=4, MaximalRejectionThreshold=2
- Initial votes: 4 approve, 3 reject (7 total votes)
- **Without manipulation**: 3 rejections > MaximalRejectionThreshold(2) → Proposal REJECTED
- **After removing 3 dissenters**: 4 approvals from current members (meets min), 0 rejections from current members (under max), 7 total votes (meets quorum) → Proposal APPROVED

**Severity**: HIGH - Undermines fundamental governance integrity and allows majority coalitions to silence minority opposition through member removal.

### Likelihood Explanation

**Attacker Capabilities**: 
- Requires control of organizational majority to pass a member removal proposal
- This is realistic for any governance token or multi-sig organization where coalitions form

**Attack Complexity**: LOW
1. Create Proposal A (contentious action)
2. Members vote on Proposal A
3. Create Proposal B to remove members who voted against Proposal A
4. Majority approves Proposal B
5. Release Proposal B (removes dissenting members)
6. Release Proposal A (now passes due to inconsistent vote counting)

**Feasibility**: HIGH
- All steps use standard public methods
- No special permissions required beyond organizational majority
- Attack is undetectable until execution
- Economically rational for high-value proposals

**Operational Constraints**: Member removal is a legitimate organizational function, making this attack indistinguishable from normal operations until the pattern emerges.

### Recommendation

**Immediate Fix**: When removing a member, clean up their votes from all active (non-released, non-expired) proposals:

```csharp
public override Empty RemoveMember(Address input)
{
    var organization = State.Organizations[Context.Sender];
    Assert(organization != null, "Organization not found.");
    var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
    Assert(removeResult, "Remove member failed.");
    Assert(Validate(organization), "Invalid organization.");
    
    // NEW: Clean up votes from removed member in all active proposals
    foreach (var proposalId in GetActiveProposalIds(Context.Sender))
    {
        var proposal = State.Proposals[proposalId];
        proposal.Approvals.Remove(input);
        proposal.Rejections.Remove(input);
        proposal.Abstentions.Remove(input);
        State.Proposals[proposalId] = proposal;
    }
    
    State.Organizations[Context.Sender] = organization;
    Context.Fire(new MemberRemoved
    {
        OrganizationAddress = Context.Sender,
        Member = input
    });
    return new Empty();
}
```

**Alternative Fix**: Make total vote counting consistent by filtering by current membership:
```csharp
var isVoteThresholdReached =
    proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
    proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
    proposal.Rejections.Count(organization.OrganizationMemberList.Contains) >=
    organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**Test Cases**:
1. Verify removing a member removes their votes from active proposals
2. Verify vote counts (approval/rejection/abstention/total) all use consistent membership filtering
3. Verify proposals cannot be released with votes from non-members counting toward thresholds

### Proof of Concept

**Initial State**:
- Organization: 10 members (M1-M10)
- Thresholds: MinimalVoteThreshold=7, MinimalApprovalThreshold=4, MaximalRejectionThreshold=2
- All members in good standing

**Attack Sequence**:

1. **Create Proposal A** (e.g., "Transfer 1000 tokens to address X")
   - Proposer: M1
   - Voting: M1,M2,M3,M4 approve | M5,M6,M7 reject
   - Result: 4 approvals, 3 rejections, 7 total votes

2. **Validate Proposal A status BEFORE removal**:
   - Approvals from current members: 4 (meets MinimalApprovalThreshold ✓)
   - Rejections from current members: 3 (EXCEEDS MaximalRejectionThreshold of 2 ✗)
   - Total votes: 7 (meets MinimalVoteThreshold ✓)
   - **Release Status**: CANNOT RELEASE (too many rejections)

3. **Create Proposal B**: "Remove members M5, M6, M7"
   - M1,M2,M3,M4 (and potentially 3 others) approve
   - Proposal B passes and is released

4. **Execute Proposal B**: M5, M6, M7 are removed from organization

5. **Validate Proposal A status AFTER removal**:
   - Approvals from current members: 4 (meets MinimalApprovalThreshold ✓)
   - Rejections from current members: 0 (M5,M6,M7 no longer members - under MaximalRejectionThreshold ✓)
   - Total votes: 7 (still counts M5,M6,M7's votes - meets MinimalVoteThreshold ✓)
   - **Release Status**: CAN NOW RELEASE ✓

6. **Release Proposal A**: Successfully executes despite original rejection

**Expected Result**: Proposal A should remain rejected when members are removed (either their votes are cleaned up, or rejection count should still fail threshold).

**Actual Result**: Proposal A becomes releasable because rejected members' votes are excluded from rejection count but included in total vote count.

**Success Condition**: Proposal that was initially blocked by rejections can be released after removing dissenting members, demonstrating governance manipulation via inconsistent vote accounting.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-59)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }

    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```
