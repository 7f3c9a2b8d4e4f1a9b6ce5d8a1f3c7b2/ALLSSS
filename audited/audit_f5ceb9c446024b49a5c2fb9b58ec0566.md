# Audit Report

## Title
Incomplete Auto-Distribution Logic Causes Profit Misallocation Across Multiple Token Types

## Summary
The `RegisterForProfits()` method in the TokenHolder contract contains a logic error where the auto-distribution loop prematurely exits after processing only the first token that meets its threshold. This causes tokens contributed in the same timeframe to be distributed to different periods with different beneficiary sets, resulting in unfair profit allocation where early registrants receive disproportionately higher rewards.

## Finding Description

The vulnerability exists in the auto-distribution logic within `RegisterForProfits()`. When a user registers for profits, the method first adds them as a beneficiary to the current period, then checks if any tokens in the general ledger meet their auto-distribution thresholds. [1](#0-0) 

However, the auto-distribution check contains a critical flaw. The loop iterates through all `AutoDistributeThreshold` entries, but after finding the first token whose balance meets its threshold, it adds that token to the distribution map and then executes a `break` statement, immediately exiting the loop. [2](#0-1) 

This means that even when multiple tokens simultaneously meet their respective thresholds, only the first one encountered in the iteration is distributed. The remaining tokens stay in the general ledger until a subsequent registration triggers their distribution.

After distribution, the scheme period is incremented. [3](#0-2) 

When beneficiaries are added via `AddBeneficiary()`, their `StartPeriod` is set to the scheme's current period plus any delay. [4](#0-3) 

This creates an unfair scenario where tokens contributed together are distributed separately with different beneficiary sets.

## Impact Explanation

**Direct Fund Misallocation:**

Consider a scheme with `AutoDistributeThreshold = {ELF: 1000, JUN: 1000}`. Both tokens are contributed to the general ledger (1000 each) during the same period.

- **User A registers with 100 shares:**
  - Added as beneficiary with StartPeriod = 1
  - Auto-distribution triggers: only ELF is added to AmountsMap and distributed to Period 1
  - Period increments to 2
  - JUN (1000) remains undistributed in general ledger

- **User B registers with 100 shares:**
  - Added as beneficiary with StartPeriod = 2
  - Auto-distribution triggers: JUN is distributed to Period 2
  - Period increments to 3

**Financial Impact:**
- User A can claim: 100% of ELF from Period 1 (100/100 shares) + 50% of JUN from Period 2 (100/200 total shares)
- User B can claim: 0% of ELF (not eligible for Period 1) + 50% of JUN from Period 2

Despite both users contributing equal 100-share stakes, User A receives significantly more value. This violates the fundamental fairness guarantee that equal contributions should receive proportional rewards from tokens contributed during the same timeframe.

The existing test case `RegisterForProfits_With_Auto_Distribute_Test` demonstrates the expected behavior - it sets up two tokens with thresholds and expects both to be claimable after a single registration. [5](#0-4) 

Specifically, the test expects a profit map count of 2 (both tokens claimable), confirming that the intended behavior is to distribute all qualifying tokens together, not sequentially. [6](#0-5) 

## Likelihood Explanation

**Attack Complexity: TRIVIAL**
- Any user can trigger the vulnerability by calling `RegisterForProfits()` when multiple token thresholds are met
- No special permissions or complex setup required
- Attacker simply needs to monitor scheme balances and race to register first

**Preconditions:**
- Scheme must be configured with multiple `AutoDistributeThreshold` entries (common for multi-token dividend schemes)
- Multiple tokens must simultaneously meet their thresholds (realistic when contributions arrive together or accumulate over time)
- Public method accessible to all users

**Probability: HIGH**
- Occurs deterministically whenever multiple thresholds are met and users register sequentially
- Multi-token schemes are a primary use case for TokenHolder contracts
- The vulnerability is triggered by normal contract usage, making it difficult for victims to detect until they claim profits and discover discrepancies

## Recommendation

Remove the `break` statement from the auto-distribution loop to allow all qualifying tokens to be processed:

```csharp
foreach (var threshold in scheme.AutoDistributeThreshold)
{
    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
    {
        Owner = virtualAddress,
        Symbol = threshold.Key
    }).Balance;
    if (balance < threshold.Value) continue;
    if (distributedInput == null)
        distributedInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
    distributedInput.AmountsMap[threshold.Key] = 0;
    // Remove the break statement here
}
```

This ensures all tokens that meet their thresholds are distributed together in the same period, maintaining fairness for all beneficiaries.

## Proof of Concept

The test `RegisterForProfits_With_Auto_Distribute_Test` serves as proof of concept. It demonstrates that when a scheme is created with multiple auto-distribution thresholds and both tokens meet their thresholds, the expected behavior is for both tokens to be distributed and claimable by the registrant. With the current buggy implementation containing the `break` statement, only one token would be distributed, causing the test expectation at line 412 to fail and confirming the profit misallocation vulnerability.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L168-176)
```csharp
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L184-200)
```csharp
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L203-205)
```csharp
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L359-419)
```csharp
    public async Task RegisterForProfits_With_Auto_Distribute_Test()
    {
        var amount = 1000L;
        var nativeTokenSymbol = TokenHolderContractTestConstants.NativeTokenSymbol;
        var tokenA = "JUN";
        await StarterCreateIssueAndApproveTokenAsync(tokenA, 1000000L, 100000L);
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = nativeTokenSymbol,
            AutoDistributeThreshold =
            {
                { nativeTokenSymbol, amount },
                { tokenA, amount }
            }
        });
        await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeManager = Starter,
            Amount = amount,
            Symbol = nativeTokenSymbol
        });
        await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeManager = Starter,
            Amount = amount,
            Symbol = tokenA
        });
        var beforeLockBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = nativeTokenSymbol,
            Owner = Starter
        })).Balance;
        await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
        {
            Amount = amount,
            SchemeManager = Starter
        });
        var afterLockBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = nativeTokenSymbol,
            Owner = Starter
        })).Balance;
        beforeLockBalance.ShouldBe(afterLockBalance.Add(amount));
        var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
        {
            Manager = Starter
        });
        var schemeId = schemeIds.SchemeIds.First();
        var profitMap = await ProfitContractStub.GetProfitsMap.CallAsync(new Profit.ClaimProfitsInput
        {
            Beneficiary = Starter,
            SchemeId = schemeId
        });
        profitMap.Value.Count.ShouldBe(2);
        profitMap.Value.ContainsKey(nativeTokenSymbol).ShouldBeTrue();
        profitMap.Value[nativeTokenSymbol].ShouldBe(amount);
        var schemeInfoInProfit = await ProfitContractStub.GetScheme.CallAsync(schemeId);
        var schemeInfoInTokenHolder = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
        schemeInfoInProfit.CurrentPeriod.ShouldBe(2);
        schemeInfoInTokenHolder.Period.ShouldBe(2);
    }
```
