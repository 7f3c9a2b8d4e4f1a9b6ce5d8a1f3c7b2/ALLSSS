### Title
Integer Overflow and Division by Zero in Miner Count Calculation Due to Unchecked Cast and Missing Validation

### Summary
The `GetAutoIncreasedMinersCount()` and `GetMinersCount()` functions perform an unchecked cast from `long` to `int` when calculating the time-based miner increase, which can cause integer overflow after sufficient blockchain runtime or if `MinerIncreaseInterval` is set to a small value. Additionally, `SetMinerIncreaseInterval()` lacks validation to prevent zero or negative values, enabling division by zero attacks that cause DoS on critical consensus operations.

### Finding Description

The vulnerability exists in two locations with identical root causes:

**Location 1:** `GetAutoIncreasedMinersCount()` performs a calculation that casts a `long` result to `int` without checked context: [1](#0-0) 

**Location 2:** `GetMinersCount()` contains the same vulnerable pattern: [2](#0-1) 

The calculation flow is:
1. `(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds` returns a `long`
2. `.Div(State.MinerIncreaseInterval.Value)` divides by `long`, returns `long`
3. `.Mul(2)` multiplies in checked context (SafeMath), returns `long`
4. `(int)` performs an **unchecked cast** from `long` to `int`
5. `.Add(SupposedMinersCount)` adds in checked context

While the SafeMath extension methods use checked arithmetic, the explicit cast from `long` to `int` is NOT in a checked context and will wrap around if the value exceeds `Int32.MaxValue` (2,147,483,647). [3](#0-2) 

**Critical Validation Gap:** The `SetMinerIncreaseInterval()` function only validates that the new value is less than or equal to the current value, with NO check for positive values: [4](#0-3) 

This allows the `MaximumMinersCountController` to set `MinerIncreaseInterval` to:
- **Zero**: Causes immediate division by zero exception
- **Small positive values (e.g., 1 second)**: Causes integer overflow after ~34 years of blockchain operation

### Impact Explanation

**Scenario A - Division by Zero (Immediate DoS):**
If `MinerIncreaseInterval` is set to 0, any call to `GetMaximumMinersCount()` or `GetMinersCount()` will throw a `DivideByZeroException`. Since `GetMinersCount()` is called during critical consensus operations: [5](#0-4) 

This causes complete DoS of:
- Round transitions
- Miner list updates
- Election contract synchronization
- All consensus operations

**Scenario B - Integer Overflow (Consensus Integrity Breach):**
If `MinerIncreaseInterval` is set to 1 second and the blockchain runs for ~34 years:
- Calculation: `(1,073,741,824 seconds / 1) * 2 = 2,147,483,648` (exceeds Int32.MaxValue)
- Cast result: wraps to `-2,147,483,648` (Int32.MinValue)
- Final result: `17 + (-2,147,483,648) = -2,147,483,631`
- `Math.Min(-2,147,483,631, MaximumMinersCount)` returns the negative/incorrect value

This breaks the fundamental consensus mechanism by:
- Allowing incorrect number of miners
- Potentially enabling consensus centralization
- Breaking miner election and rotation logic
- Violating the consensus invariant of correct miner count

The default interval is 31,536,000 seconds (1 year), which would require ~1 billion years for natural overflow, making it impractical. However, the lack of validation allows malicious reduction. [6](#0-5) 

### Likelihood Explanation

**Attack Prerequisites:**
- Attacker must control the `MaximumMinersCountController` (default: Parliament organization) [7](#0-6) 

**Attack Vectors:**

1. **Malicious Governance Proposal:** A compromised or malicious Parliament could pass a proposal to set `MinerIncreaseInterval` to 0 or 1
2. **Social Engineering:** Misleading proposal that appears benign but sets dangerous interval
3. **Configuration Error:** Accidental misconfiguration during governance operations

**Execution Complexity:** Low - single transaction call to `SetMinerIncreaseInterval`

**Detection:** The change is logged but may not trigger immediate alerts; DoS would be noticed immediately, but overflow would manifest gradually

**Likelihood Assessment:** Medium
- Requires governance-level compromise (elevated but not impossible)
- No technical barriers once authority obtained
- Historical precedent of governance attacks in blockchain systems
- The "decrease only" check in line 61 suggests defensive intent but is insufficient

### Recommendation

**Immediate Fix:**

1. **Add validation in `SetMinerIncreaseInterval()`:**
```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Miner increase interval must be positive.");
    Assert(input.Value >= MIN_MINER_INCREASE_INTERVAL, "Interval too small."); // e.g., 86400 (1 day)
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

2. **Use checked cast in `GetAutoIncreasedMinersCount()` and `GetMinersCount()`:**
```csharp
return AEDPoSContractConstants.SupposedMinersCount.Add(
    checked((int)((Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
    .Div(State.MinerIncreaseInterval.Value).Mul(2))));
```

3. **Add validation on initialization in `InitialAElfConsensusContract()`:**
```csharp
Assert(input.MinerIncreaseInterval > 0, "Invalid miner increase interval.");
Assert(input.MinerIncreaseInterval >= MIN_MINER_INCREASE_INTERVAL, "Interval too small.");
State.MinerIncreaseInterval.Value = input.MinerIncreaseInterval;
```

**Additional Recommendations:**
- Add monitoring/alerts for `MinerIncreaseInterval` changes
- Consider making the minimum interval a governance parameter
- Add integration tests covering edge cases (zero interval, overflow scenarios)

### Proof of Concept

**Step 1 - Setup:**
- Blockchain initialized with default `MinerIncreaseInterval = 31536000`
- Parliament controls `MaximumMinersCountController`

**Step 2 - Attack (Division by Zero):**
1. Parliament passes proposal to call `SetMinerIncreaseInterval(0)`
2. Transaction succeeds (no validation prevents zero)
3. Any subsequent call to `GetMaximumMinersCount()` or consensus operations calling `GetMinersCount()` throws `DivideByZeroException`
4. **Result:** Complete consensus DoS

**Step 3 - Attack (Integer Overflow):**
1. Parliament passes proposal to call `SetMinerIncreaseInterval(1)`
2. Transaction succeeds (assertion only checks `<= current`)
3. Wait ~34 years (or simulate via test framework)
4. Calculation: `(~1,073,741,824 / 1) * 2 = 2,147,483,648`
5. Cast to int wraps to `-2,147,483,648`
6. `GetMaximumMinersCount()` returns `Math.Min(-2,147,483,631, MaximumMinersCount)` = negative value
7. **Result:** Consensus integrity compromised with incorrect miner count

**Expected vs Actual:**
- **Expected:** Miner count gradually increases by 2 per interval, capped by `MaximumMinersCount`
- **Actual (zero):** Division by zero exception, DoS
- **Actual (overflow):** Negative or incorrect miner count returned

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L92-94)
```csharp
        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L388-390)
```csharp
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L79-90)
```csharp
    public static long Mul(this long a, long b)
    {
        checked
        {
            return a * b;
        }
    }

    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L128-130)
```csharp
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```
