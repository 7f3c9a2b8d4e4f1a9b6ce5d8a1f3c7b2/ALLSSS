# Audit Report

## Title
Side Chain Validators Can Prevent Validator Set Updates by Omitting Consensus Data from Cross-Chain Indexing

## Summary
Side chain validators can permanently freeze the validator set by proposing parent chain blocks without consensus information in the `extra_data` field. The cross-chain contract's validation logic does not enforce the presence of consensus data, allowing malicious validators to prevent validator rotation while maintaining normal cross-chain operations. This creates an irreversible centralization risk where initial validators retain permanent control of the side chain.

## Finding Description

Side chains rely exclusively on cross-chain indexing for validator set updates and never use the `NextTerm` mechanism. [1](#0-0) 

The validator update mechanism depends on consensus information being passed through the `extra_data` field of `ParentChainBlockData`. When this data is present, it updates the side chain's `MainChainCurrentMinerList`. [2](#0-1) 

During round generation, if the main chain miner list has changed, the side chain generates a new first round with updated validators. [3](#0-2) 

**Root Cause**: The `ValidateParentChainBlockData` function validates chain ID, sequential height, and merkle tree root, but does NOT validate the presence or requirement of consensus data in the `extra_data` field. [4](#0-3) 

When parent chain blocks are indexed, consensus data extraction is conditional - if the `extra_data` map does not contain the consensus key, the update is simply skipped without any error. [5](#0-4) 

The `extra_data` field in `ParentChainBlockData` is defined as an optional map in the protobuf specification. [6](#0-5) 

Only current miners can propose cross-chain indexing data. [7](#0-6) 

**Attack Vector**: A malicious validator receives proper parent chain block data (including consensus information) from the off-chain service, but when calling `ProposeCrossChainIndexing`, they construct their own `ParentChainBlockData` message with all required fields (height, chain_id, transaction_status_merkle_tree_root, indexed_merkle_path) but omit the `extra_data` field or provide it empty. The validation passes, the data gets indexed, but `UpdateConsensusInformation` is never called, preventing validator set updates indefinitely.

## Impact Explanation

**Critical Consensus Integrity Break**: This vulnerability fundamentally breaks the security model where side chains inherit validator rotation from the main chain. The initial validator set gains permanent, irrevocable control with no on-chain recovery mechanism.

**Permanent Validator Control**: Colluding validators can:
- Censor any transactions arbitrarily
- Extract unlimited MEV without competition from new validators
- Reorganize blocks for double-spending attacks
- Selectively refuse cross-chain transactions
- Hold the entire side chain hostage for ransom

**System-Wide Security Failure**: All side chain users, dApps, and assets become subject to the permanent control of a potentially malicious validator set. The expected security guarantee from main chain validator rotation is completely nullified.

**No Recovery Path**: Once validators stop including consensus data, there is no contract-level mechanism to force them to include it or to update the validator set through alternative means. The side chain becomes permanently compromised.

## Likelihood Explanation

**Feasibility: HIGH**
- Validators have legitimate authority to propose cross-chain indexing data
- Attack execution is trivial - simply omit a field from the data structure
- No sophisticated techniques or timing requirements needed
- Zero cost to execute the attack

**Detection: LOW**
- The side chain continues operating normally for other functions
- Cross-chain transactions still work (merkle paths are validated)
- No obvious indicators that validator synchronization has stopped
- Users cannot easily verify if the validator set matches the main chain

**Economic Incentive: HIGH**
- Permanent control of economically significant side chain
- Can extract long-term value through transaction censorship and MEV
- Expected value increases with side chain economic activity
- Rational choice for compromised or malicious validator sets

**Prerequisites**: Requires collusion among initial side chain validators, but once they decide to maintain control, execution is immediate and irreversible.

**Overall Likelihood: MEDIUM to HIGH** - While requires validator collusion, the zero-cost execution, high economic incentive, and low detection risk make this an attractive attack for malicious validator sets on valuable side chains.

## Recommendation

Add validation in the `ValidateParentChainBlockData` function to enforce the presence of consensus data in the `extra_data` field for the last parent chain block being indexed (since that's what triggers the update):

```csharp
private bool ValidateParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData,
    out Dictionary<int, List<ParentChainBlockData>> validatedParentChainBlockData)
{
    var parentChainId = State.ParentChainId.Value;
    var currentHeight = State.CurrentParentChainHeight.Value;
    validatedParentChainBlockData = new Dictionary<int, List<ParentChainBlockData>>();
    
    for (int i = 0; i < parentChainBlockData.Count; i++)
    {
        var blockData = parentChainBlockData[i];
        if (parentChainId != blockData.ChainId || currentHeight + 1 != blockData.Height ||
            blockData.TransactionStatusMerkleTreeRoot == null)
            return false;
            
        if (blockData.IndexedMerklePath.Any(indexedBlockInfo =>
                State.ChildHeightToParentChainHeight[indexedBlockInfo.Key] != 0 ||
                State.TxRootMerklePathInParentChain[indexedBlockInfo.Key] != null))
            return false;
        
        // NEW: Enforce consensus data presence in the last block
        if (i == parentChainBlockData.Count - 1)
        {
            if (!blockData.ExtraData.ContainsKey(ConsensusExtraDataName) || 
                blockData.ExtraData[ConsensusExtraDataName].IsEmpty)
                return false;
        }
        
        currentHeight += 1;
    }

    if (parentChainBlockData.Count > 0)
        validatedParentChainBlockData[parentChainId] = parentChainBlockData.ToList();

    return true;
}
```

This ensures that consensus data cannot be omitted from cross-chain indexing proposals, maintaining the security guarantee that side chains synchronize their validator sets with the main chain.

## Proof of Concept

```csharp
// Test demonstrates that parent chain blocks can be indexed without consensus data
[Fact]
public async Task SideChain_ValidatorSet_CanBeFrozen_ByOmittingConsensusData()
{
    // Setup: Create side chain with initial validators
    var sideChainId = await CreateSideChainAsync();
    var initialValidators = await GetCurrentSideChainValidatorsAsync(sideChainId);
    
    // Main chain updates its validator set through election
    await MainChainElectionAsync(); // New validators elected on main chain
    var newMainChainValidators = await GetMainChainValidatorsAsync();
    Assert.NotEqual(initialValidators, newMainChainValidators);
    
    // Malicious side chain validator proposes parent chain block WITHOUT consensus data
    var parentChainBlockData = new ParentChainBlockData
    {
        Height = parentChainHeight,
        ChainId = parentChainId,
        TransactionStatusMerkleTreeRoot = merkleRoot,
        IndexedMerklePath = { validMerklePaths }
        // NOTE: extra_data is intentionally omitted - no consensus information
    };
    
    // Validation passes even without consensus data
    var result = await SideChainCrossChainContract.ProposeCrossChainIndexing
        .SendAsync(new CrossChainBlockData 
        { 
            ParentChainBlockDataList = { parentChainBlockData } 
        });
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Release and index the data
    await ReleaseCrossChainIndexingProposalAsync();
    
    // Verify: Side chain validator set is NOT updated despite main chain change
    var sideChainValidatorsAfter = await GetCurrentSideChainValidatorsAsync(sideChainId);
    Assert.Equal(initialValidators, sideChainValidatorsAfter); // Validators unchanged
    
    // Main chain validators changed but side chain validators frozen
    Assert.NotEqual(newMainChainValidators, sideChainValidatorsAfter);
    
    // Side chain is now permanently controlled by initial validators
}
```

## Notes

The vulnerability exists because the contract assumes honest validators will always include consensus data (as provided by the off-chain `CrossChainResponseService`), but does not enforce this assumption at the contract level. The validation logic is insufficient - it checks data integrity but not completeness of critical security-relevant fields.

This is particularly severe because:
1. There is no fallback mechanism for validator updates if consensus data is never provided
2. The side chain appears to function normally (blocks produced, transactions processed)
3. Only sophisticated monitoring could detect that validator synchronization has stopped
4. Once frozen, the validator set cannot be updated through any on-chain mechanism

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L20-23)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-64)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-295)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L720-743)
```csharp
    private bool ValidateParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData,
        out Dictionary<int, List<ParentChainBlockData>> validatedParentChainBlockData)
    {
        var parentChainId = State.ParentChainId.Value;
        var currentHeight = State.CurrentParentChainHeight.Value;
        validatedParentChainBlockData = new Dictionary<int, List<ParentChainBlockData>>();
        foreach (var blockData in parentChainBlockData)
        {
            if (parentChainId != blockData.ChainId || currentHeight + 1 != blockData.Height ||
                blockData.TransactionStatusMerkleTreeRoot == null)
                return false;
            if (blockData.IndexedMerklePath.Any(indexedBlockInfo =>
                    State.ChildHeightToParentChainHeight[indexedBlockInfo.Key] != 0 ||
                    State.TxRootMerklePathInParentChain[indexedBlockInfo.Key] != null))
                return false;

            currentHeight += 1;
        }

        if (parentChainBlockData.Count > 0)
            validatedParentChainBlockData[parentChainId] = parentChainBlockData.ToList();

        return true;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L783-788)
```csharp
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }
```

**File:** protobuf/acs7.proto (L109-122)
```text
message ParentChainBlockData {
    // The height of parent chain.
    int64 height = 1;
    // The merkle tree root computing from side chain roots.
    CrossChainExtraData cross_chain_extra_data = 2;
    // The parent chain id.
    int32 chain_id = 3;
    // The merkle tree root computing from transactions status in parent chain block.
    aelf.Hash transaction_status_merkle_tree_root = 4;
    // Indexed block height from side chain and merkle path for this side chain block
    map<int64, aelf.MerklePath> indexed_merkle_path = 5;
    // Extra data map.
    map<string, bytes> extra_data = 6;
}
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-291)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }
```
