# Audit Report

## Title
Non-Evil Miner Replacements Incorrectly Bypass Reward Penalty Calculations

## Summary
The `RecordMinerReplacement()` function unconditionally marks ALL replacement miners as evil miner replacements, causing legitimate (non-evil) replacement miners to bypass performance-based penalty calculations during Basic Miner Reward distribution. This enables miners to gain unfair rewards by replacing their public key before terms where they anticipate poor performance.

## Finding Description

The vulnerability exists in the Treasury contract's `RecordMinerReplacement()` method. While the function correctly branches based on the `IsOldPubkeyEvil` flag to update different state variables (lines 583-594), it unconditionally sets `State.IsReplacedEvilMiner[input.NewPubkey] = true` at line 596, executing for ALL replacement cases regardless of whether the old miner was evil or not. [1](#0-0) 

The execution flow begins when any candidate admin voluntarily replaces their public key through the Election contract: [2](#0-1) 

This triggers a cross-contract notification chain where the AEDPoS consensus contract calls the Treasury contract's `RecordMinerReplacement` method. Critically, the AEDPoS contract does NOT set the `IsOldPubkeyEvil` field in the input message, causing it to default to `false` for voluntary replacements: [3](#0-2) 

The protobuf message definition confirms that `is_old_pubkey_evil` is indeed a field that should distinguish evil from non-evil replacements: [4](#0-3) 

During reward distribution, the `UpdateBasicMinerRewardWeights` function checks the `IsReplacedEvilMiner` flag. When true, miners receive shares equal to their produced blocks directly, completely bypassing the penalty calculation: [5](#0-4) 

The `CalculateShares()` function enforces strict performance penalties that replacement miners incorrectly avoid: [6](#0-5) 

## Impact Explanation

This vulnerability breaks the Treasury contract's fundamental invariant of fair, performance-based reward distribution. Replacement miners gain a systematic unfair advantage in Basic Miner Reward allocation:

**Concrete Scenario (Average blocks = 100):**
- A regular miner producing 40 blocks (40% of average) receives 0 shares due to the < 50% penalty threshold
- A replacement miner producing 40 blocks receives 40 shares with no penalty
- **Result**: 100% excess rewards for severe underperformance

**Medium Performance Scenario:**
- A regular miner producing 60 blocks receives 36 shares (60² ÷ 100) due to quadratic penalty
- A replacement miner producing 60 blocks receives 60 shares
- **Result**: 67% excess rewards (24 additional shares)

Over multiple terms, this systematically misallocates Basic Miner Rewards from high-performing miners to strategically-timed underperforming replacement miners. The economic impact scales with the number of replacements and the degree of underperformance.

## Likelihood Explanation

**Attacker Capability**: Any candidate admin can trigger this vulnerability. The Election contract only requires the sender to be the candidate's admin, which is a standard operational role for key rotation or security updates.

**Attack Complexity**: Low. The exploitation requires a single transaction:
1. Candidate admin calls `ReplaceCandidatePubkey(oldPubkey, newPubkey)`
2. Treasury automatically marks the new key with bypass flag
3. Next reward distribution exempts the miner from penalties

**Feasibility**: High. Public key replacement is a legitimate operational feature designed for key rotation. There are no rate limits, governance approvals, or additional restrictions beyond being a candidate admin.

**Economic Rationality**: Clear financial incentive. A miner anticipating poor performance (hardware issues, network problems, scheduled downtime) can strategically replace their key to receive full rewards instead of 0-60% reduced rewards. The cost is minimal (one transaction), while the benefit can be 40-100% additional reward shares.

**Preconditions**: Requires being a current candidate with admin control, which is achievable through normal election participation.

## Recommendation

Move line 596 inside the `if (input.IsOldPubkeyEvil)` branch so that only actual evil miner replacements receive the penalty exemption:

```csharp
public override Empty RecordMinerReplacement(RecordMinerReplacementInput input)
{
    Assert(
        Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
        "Only AEDPoS Contract can record miner replacement.");

    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    if (!input.IsOldPubkeyEvil)
    {
        var latestMinedTerm = State.LatestMinedTerm[input.OldPubkey];
        State.LatestMinedTerm[input.NewPubkey] = latestMinedTerm;
        State.LatestMinedTerm.Remove(input.OldPubkey);
    }
    else
    {
        var replaceCandidates = State.ReplaceCandidateMap[input.CurrentTermNumber] ?? new StringList();
        replaceCandidates.Value.Add(input.NewPubkey);
        State.ReplaceCandidateMap[input.CurrentTermNumber] = replaceCandidates;
        
        // Only mark as replaced evil miner if actually replacing an evil miner
        State.IsReplacedEvilMiner[input.NewPubkey] = true;
    }

    return new Empty();
}
```

Additionally, ensure the AEDPoS contract properly sets `IsOldPubkeyEvil = true` when replacing detected evil miners during consensus operations.

## Proof of Concept

```csharp
[Fact]
public async Task ReplacementMiner_BypassesPenalties_ForLowPerformance()
{
    // Setup: Two miners with same low performance (40% of average)
    const int producedBlocks = 40;
    const int averageBlocks = 100;
    
    // Regular miner without replacement
    var regularMinerShares = CalculateShares(producedBlocks, averageBlocks);
    // Expected: 0 shares (below 50% threshold)
    Assert.Equal(0, regularMinerShares);
    
    // Miner who replaced their pubkey
    var electionStub = GetElectionContractStub(candidateKeyPair);
    await electionStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = oldPubkey,
        NewPubkey = newPubkey
    });
    
    // Advance to next term and distribute rewards
    await NextTerm(BlockchainStartTimestamp, initialMiners);
    
    // Verify replacement miner received full shares despite low performance
    var beneficiaries = await GetBasicMinerRewardBeneficiaries();
    var replacementMinerShares = beneficiaries
        .First(b => b.Beneficiary == GetProfitsReceiver(newPubkey))
        .Shares;
    
    // Bug: Receives 40 shares instead of 0
    Assert.Equal(producedBlocks, replacementMinerShares);
    Assert.True(replacementMinerShares > regularMinerShares); // Unfair advantage
}
```

## Notes

The design intent appears to be providing a penalty exemption ONLY for miners who replace detected evil miners (to incentivize network cleanup). However, the implementation error causes ALL replacement miners to receive this exemption, including voluntary key rotations for legitimate operational reasons. The flag is cleared after first use, so the bypass only affects one term, but this is still sufficient for strategic exploitation.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L573-599)
```csharp
    public override Empty RecordMinerReplacement(RecordMinerReplacementInput input)
    {
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only AEDPoS Contract can record miner replacement.");

        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        if (!input.IsOldPubkeyEvil)
        {
            var latestMinedTerm = State.LatestMinedTerm[input.OldPubkey];
            State.LatestMinedTerm[input.NewPubkey] = latestMinedTerm;
            State.LatestMinedTerm.Remove(input.OldPubkey);
        }
        else
        {
            var replaceCandidates = State.ReplaceCandidateMap[input.CurrentTermNumber] ?? new StringList();
            replaceCandidates.Value.Add(input.NewPubkey);
            State.ReplaceCandidateMap[input.CurrentTermNumber] = replaceCandidates;
        }

        State.IsReplacedEvilMiner[input.NewPubkey] = true;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L799-822)
```csharp
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L148-154)
```csharp
        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });
```

**File:** protobuf/treasury_contract.proto (L154-159)
```text
message RecordMinerReplacementInput {
    string old_pubkey = 1;
    string new_pubkey = 2;
    int64 current_term_number = 3;
    bool is_old_pubkey_evil = 4;
}
```
