### Title
Case Sensitivity in ReplaceCandidatePubkey Causes Vote Data Loss and Incorrect Miner Selection in GetVictories()

### Summary
The `ReplaceCandidatePubkey` function lacks case normalization for pubkey string inputs, causing it to fail migrating vote data when uppercase pubkeys are provided. This creates inconsistent state where `State.CandidateVotes` retains orphaned lowercase entries while `State.Candidates` is updated with new pubkey bytes. Subsequently, `GetVictories()` cannot find the vote data for replaced candidates and incorrectly excludes them from victory calculation, potentially corrupting miner selection for consensus.

### Finding Description

The vulnerability exists in the interaction between case-sensitive dictionary lookups and the lack of input normalization in `ReplaceCandidatePubkey`.

**Root Cause:**

The `ToHex()` extension method deterministically produces lowercase hex strings from byte sequences. [1](#0-0)  During normal election registration via `AnnounceElection`, pubkeys are normalized to lowercase when creating dictionary keys. [2](#0-1) 

When candidates receive votes, the `Vote` function validates against `State.CandidateInformationMap` which contains only lowercase keys, ensuring all vote data is stored with lowercase pubkey keys. [3](#0-2) 

However, `ReplaceCandidatePubkey` uses input strings directly without normalization: [4](#0-3) 

When an admin provides uppercase `input.OldPubkey` and `input.NewPubkey`:
1. Line 229 attempts to retrieve `State.CandidateVotes[input.OldPubkey]` using the uppercase key
2. This returns `null` because the actual entry exists at the lowercase key
3. The if block doesn't execute, so vote data is not migrated
4. Line 234 attempts to remove the uppercase key, which has no effect
5. The old lowercase entry remains orphaned in `State.CandidateVotes`
6. Meanwhile, `State.Candidates` is updated to remove old bytes and add new bytes (lines 192-196) [5](#0-4) 

**Why Existing Protections Fail:**

The validation at line 175 checks `IsCurrentCandidateOrInitialMiner`, which for initial miners succeeds even with case mismatch because it checks byte equality (case-insensitive). [6](#0-5) 

The check uses `ByteArrayHelper.HexStringToByteArray` which is case-insensitive, so uppercase and lowercase pubkey strings convert to identical bytes, allowing initial miner validation to pass. [7](#0-6) 

**Impact on GetVictories():**

When `GetVictories()` executes, `GetValidCandidates()` iterates through `State.Candidates` and converts pubkeys to lowercase using `ToHex()` to lookup vote counts. [8](#0-7) 

For a candidate whose pubkey was replaced with incorrect case:
- `State.Candidates` contains the new pubkey bytes
- `GetValidCandidates()` converts to lowercase and checks `State.CandidateVotes["newpubkeylowercase"]`
- This entry doesn't exist (migration failed)
- The candidate is excluded from `validCandidates` list despite having votes
- The orphaned `State.CandidateVotes["oldpubkeylowercase"]` entry remains but is unreachable

### Impact Explanation

**Consensus Integrity Compromise:**
- Candidates with legitimate votes are incorrectly excluded from `GetVictories()` results
- The miner selection for consensus rounds becomes corrupted, potentially selecting less qualified candidates
- The AEDPoS consensus mechanism depends on accurate victory calculation from `GetVictories()` [9](#0-8) 

**Vote Data Loss:**
- Vote tokens locked by electors become associated with orphaned pubkey entries
- The voting power accumulated for a candidate is effectively nullified
- This violates the invariant that vote weight must accurately reflect in candidate selection

**Operational Impact:**
- Disrupts the election mechanism's core function of determining block producers
- Could lead to governance disputes if legitimate high-vote candidates are excluded
- Recovery requires complex state migration by admins

**Severity Justification:**
This is a **Medium** severity issue because while it compromises consensus integrity and causes data inconsistency, it requires:
1. Admin-level access to call `ReplaceCandidatePubkey`
2. Either mistake (providing wrong case) or malicious intent
3. Only affects candidates who undergo pubkey replacement

However, the impact on consensus and irreversible vote data loss justifies medium severity.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires admin/candidate admin role to call `ReplaceCandidatePubkey` [10](#0-9) 
- No special cryptographic or economic requirements beyond legitimate admin access

**Attack Complexity:**
- Simple execution: call `ReplaceCandidatePubkey` with uppercase pubkey strings
- No complex transaction sequences or timing requirements
- Can occur unintentionally if admin uses uppercase format

**Feasibility Conditions:**
- Target must be an initial miner (validation passes for initial miners with case mismatch)
- Or admin must have been set with matching case for regular candidates (possible via `AnnounceElectionFor`)
- Candidate must have existing vote data to cause impact

**Detection/Operational Constraints:**
- The inconsistency may not be immediately apparent
- `GetVictories()` would return incorrect results without obvious error
- Tests use `ToHex()` which produces lowercase, missing this edge case [11](#0-10) 

**Probability Reasoning:**
Medium probability - while requiring admin access, the lack of input validation or documentation about case sensitivity makes this a realistic mistake. Initial miners are high-value targets for pubkey replacement, increasing likelihood.

### Recommendation

**1. Add Case Normalization in ReplaceCandidatePubkey:**

Normalize input pubkeys to lowercase before using as dictionary keys:

```csharp
public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
{
    // Normalize inputs to lowercase
    var oldPubkey = input.OldPubkey.ToLower();
    var newPubkey = input.NewPubkey.ToLower();
    
    Assert(IsCurrentCandidateOrInitialMiner(oldPubkey), ...);
    // Use normalized variables for all dictionary operations
    var candidateVotes = State.CandidateVotes[oldPubkey];
    ...
}
```

**2. Add Validation to Enforce Lowercase:**

Add explicit validation that pubkeys are in correct format:

```csharp
private void ValidatePubkeyFormat(string pubkey)
{
    var normalized = pubkey.ToLower();
    Assert(pubkey == normalized, "Pubkey must be lowercase hex string");
}
```

**3. Add Consistency Check:**

Before migration, verify that the old pubkey entry exists:

```csharp
var candidateVotes = State.CandidateVotes[oldPubkey];
Assert(candidateVotes != null, "Cannot find vote data for old pubkey - possible case mismatch");
```

**4. Test Case:**

Add test that calls `ReplaceCandidatePubkey` with uppercase inputs to verify proper handling or rejection.

### Proof of Concept

**Initial State:**
1. Initial miner with pubkey bytes P1 has announced election
2. `State.CandidateInformationMap["p1_lowercase"]` exists with vote data
3. `State.CandidateVotes["p1_lowercase"]` exists with 1000 votes
4. `State.Candidates` contains ByteString of P1

**Attack Sequence:**

1. Admin calls `ReplaceCandidatePubkey`:
   ```
   OldPubkey: "P1_UPPERCASE" (same bytes as P1 but uppercase string)
   NewPubkey: "P2_UPPERCASE" (new pubkey bytes, uppercase string)
   ```

2. Validation passes (initial miner check uses bytes, case-insensitive)

3. Migration attempts:
   - `State.CandidateVotes["P1_UPPERCASE"]` → returns `null` (actual key is "p1_lowercase")
   - Vote data NOT migrated
   - `State.Candidates` updated: removes P1 bytes, adds P2 bytes

4. Query `GetVictories()`:
   - Iterates `State.Candidates`, finds P2 bytes
   - Converts P2 to lowercase: "p2_lowercase"
   - Checks `State.CandidateVotes["p2_lowercase"]` → doesn't exist
   - P2 excluded from valid candidates

**Expected Result:** 
Candidate with 1000 votes included in victory calculation

**Actual Result:**
Candidate with 1000 votes excluded, votes orphaned at unreachable key "p1_lowercase"

**Success Condition:**
Call `GetValidCandidates()` after replacement - the replaced candidate (P2) is not in the returned list despite having vote data under the old pubkey.

### Citations

**File:** src/AElf.Types/Extensions/ByteStringExtensions.cs (L8-32)
```csharp
        public static string ToHex(this ByteString bytes, bool withPrefix = false)
        {
            var offset = withPrefix ? 2 : 0;
            var length = bytes.Length * 2 + offset;
            var c = new char[length];

            byte b;

            if (withPrefix)
            {
                c[0] = '0';
                c[1] = 'x';
            }

            for (int bx = 0, cx = offset; bx < bytes.Length; ++bx, ++cx)
            {
                b = (byte)(bytes[bx] >> 4);
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
            }

            return new string(c);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L421-467)
```csharp
    public override Hash Vote(VoteMinerInput input)
    {
        // Check candidate information map instead of candidates. 
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);

        var electorPubkey = Context.RecoverPublicKey();

        var lockSeconds = (input.EndTimestamp - Context.CurrentBlockTime).Seconds;
        AssertValidLockSeconds(lockSeconds);

        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;

        UpdateElectorInformation(electorPubkey, input.Amount, voteId);

        var candidateVotesAmount = UpdateCandidateInformation(input.CandidatePubkey, input.Amount, voteId);

        LockTokensOfVoter(input.Amount, voteId);
        TransferTokensToVoter(input.Amount);
        CallVoteContractVote(input.Amount, input.CandidatePubkey, voteId);
        AddBeneficiaryToVoter(GetVotesWeight(input.Amount, lockSeconds), lockSeconds, voteId);

        var rankingList = State.DataCentersRankingList.Value;
        if (rankingList.DataCenters.ContainsKey(input.CandidatePubkey))
        {
            rankingList.DataCenters[input.CandidatePubkey] =
                rankingList.DataCenters[input.CandidatePubkey].Add(input.Amount);
            State.DataCentersRankingList.Value = rankingList;
        }
        else
        {
            if (rankingList.DataCenters.Count < GetValidationDataCenterCount())
            {
                State.DataCentersRankingList.Value.DataCenters.Add(input.CandidatePubkey,
                    candidateVotesAmount);
                AddBeneficiary(input.CandidatePubkey);
            }
            else
            {
                TryToBecomeAValidationDataCenter(input, candidateVotesAmount, rankingList);
            }
        }

        return voteId;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L175-178)
```csharp
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L180-181)
```csharp
        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L189-197)
```csharp
        //     Remove origin pubkey from Candidates, DataCentersRankingList and InitialMiners; then add new pubkey.
        var candidates = State.Candidates.Value;
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L229-235)
```csharp
        var candidateVotes = State.CandidateVotes[input.OldPubkey];
        if (candidateVotes != null)
        {
            candidateVotes.Pubkey = newPubkeyBytes;
            State.CandidateVotes[input.NewPubkey] = candidateVotes;
            State.CandidateVotes.Remove(input.OldPubkey);
        }
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-19)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L41-50)
```csharp
    public override PubkeyList GetVictories(Empty input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        var currentMiners = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(k => k.ToHex()).ToList();
        return new PubkeyList { Value = { GetVictories(currentMiners) } };
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L86-95)
```csharp
    private List<string> GetValidCandidates()
    {
        if (State.Candidates.Value == null) return new List<string>();

        return State.Candidates.Value.Value
            .Where(c => State.CandidateVotes[c.ToHex()] != null &&
                        State.CandidateVotes[c.ToHex()].ObtainedActiveVotedVotesAmount > 0)
            .Select(p => p.ToHex())
            .ToList();
    }
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ReplaceCandidateTests.cs (L38-42)
```csharp
        await candidateAdminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
        {
            OldPubkey = announceElectionKeyPair.PublicKey.ToHex(),
            NewPubkey = newKeyPair.PublicKey.ToHex()
        });
```
