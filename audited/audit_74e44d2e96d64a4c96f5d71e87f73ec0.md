### Title
Sponsor Can DOS Voters by Rapidly Exhausting Snapshots Regardless of EndTimestamp

### Summary
The `TakeSnapshot` function lacks time-based restrictions, allowing the sponsor to rapidly exhaust all snapshots and prematurely terminate voting. Since voting eligibility depends solely on `CurrentSnapshotNumber <= TotalSnapshotNumber` rather than the declared `EndTimestamp`, sponsors can effectively end voting after just a few blocks instead of the intended voting period, denying voters the ability to participate.

### Finding Description

The vulnerability exists in the `TakeSnapshot` function where the sponsor has unrestricted control over snapshot progression without time-based validation. [1](#0-0) 

The function only validates sponsor authorization and snapshot count limits, but imposes no minimum time interval between snapshots: [2](#0-1) 

Each `TakeSnapshot` call increments `CurrentSnapshotNumber`: [3](#0-2) 

The new snapshot's start timestamp is set to the current block time without any validation against the voting item's `EndTimestamp`: [4](#0-3) 

The voting eligibility check in `AssertValidVoteInput` only validates snapshot count, not time: [5](#0-4) 

During registration, `EndTimestamp` is recorded but only validated to be after `StartTimestamp`: [6](#0-5) 

The `EndTimestamp` field is never checked during voting or snapshot operations, making it purely informational: [7](#0-6) 

### Impact Explanation

**Operational DOS Impact:**
- Voters are denied the ability to participate in voting despite the declared voting period
- A voting item registered with a 30-day `EndTimestamp` can be terminated in 10 blocks if `TotalSnapshotNumber = 10`
- Early voters gain unfair advantage while late voters are completely excluded
- The voting system cannot honor its time commitments, undermining trust and governance legitimacy

**Severity: High**
- Complete denial of core voting functionality
- Sponsor can manipulate governance outcomes by controlling voter participation windows
- Breaks the fundamental expectation that `EndTimestamp` defines the voting period
- No fund theft occurs, but governance manipulation can lead to protocol-level damage

Test evidence confirms this behavior - when all snapshots are exhausted, voting fails immediately: [8](#0-7) 

### Likelihood Explanation

**Attack Complexity: Low**
- Entry point is the public `TakeSnapshot` method accessible to sponsors
- No special preconditions beyond being the sponsor (a legitimate role)
- Execution is trivial: repeatedly call `TakeSnapshot` with sequential snapshot numbers

**Feasibility: High**
- Sponsor role is part of normal operation, not a compromised account
- Attack can be executed in consecutive blocks or even within a single block (gas permitting)
- No economic barriers - only gas costs, which are negligible compared to governance impact

**Detection: Difficult**
- Rapid snapshots appear as legitimate sponsor activity
- No on-chain indicators distinguish malicious from legitimate snapshot progression
- Voters only discover the DOS when their transactions fail

Test suite demonstrates snapshots can be taken in rapid succession without time delays: [9](#0-8) 

### Recommendation

**Add Time-Based Validation:**

1. Enforce `EndTimestamp` in the `Vote` function - reject votes after `Context.CurrentBlockTime > EndTimestamp`

2. Add minimum snapshot duration check in `TakeSnapshot`:
   ```csharp
   var previousSnapshotDuration = Context.CurrentBlockTime - votingItem.CurrentSnapshotStartTimestamp;
   var minimumSnapshotDuration = (votingItem.EndTimestamp - votingItem.StartTimestamp) / votingItem.TotalSnapshotNumber;
   Assert(previousSnapshotDuration >= minimumSnapshotDuration, "Minimum snapshot duration not met.");
   ```

3. Add validation that voting cannot end before `EndTimestamp`:
   ```csharp
   Assert(Context.CurrentBlockTime <= votingItem.EndTimestamp, "Cannot take snapshot after voting period ended.");
   ```

4. Update `AssertValidVoteInput` to check both snapshot count AND time:
   ```csharp
   Assert(Context.CurrentBlockTime >= votingItem.StartTimestamp && 
          Context.CurrentBlockTime <= votingItem.EndTimestamp, 
          "Voting period not active.");
   ```

**Regression Test:**
Add test case that attempts to take multiple snapshots rapidly and verifies minimum time enforcement prevents premature voting termination.

### Proof of Concept

**Initial State:**
- Sponsor registers voting item with:
  - `StartTimestamp = CurrentBlockTime`
  - `EndTimestamp = CurrentBlockTime + 30 days`
  - `TotalSnapshotNumber = 10`
  - `AcceptedCurrency = "ELF"`
- Expected behavior: Voting should remain open for 30 days

**Attack Sequence:**
1. Block N: Sponsor calls `Register(...)` - creates voting item with `CurrentSnapshotNumber = 1`
2. Block N+1: Sponsor calls `TakeSnapshot(votingItemId, 1)` - advances to snapshot 2
3. Block N+2: Sponsor calls `TakeSnapshot(votingItemId, 2)` - advances to snapshot 3
4. Block N+3-N+10: Sponsor continues calling `TakeSnapshot` sequentially
5. Block N+10: After `TakeSnapshot(votingItemId, 10)`, `CurrentSnapshotNumber = 11`
6. Block N+11: Voter attempts `Vote(votingItemId, option, amount)`

**Expected Result:**
- Voting should succeed since `CurrentBlockTime` is still within 30-day period

**Actual Result:**
- Vote transaction fails with error: "Current voting item already ended"
- `CurrentSnapshotNumber (11) > TotalSnapshotNumber (10)` check fails
- Voting period effectively lasted only 10 blocks (~30-50 seconds) instead of 30 days
- All voters after block N+10 are denied participation despite `EndTimestamp` not being reached

**Success Condition:**
The attack succeeds when `CurrentSnapshotNumber > TotalSnapshotNumber` is reached before `EndTimestamp`, preventing all future votes regardless of remaining time in the declared voting period.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L45-47)
```csharp
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L241-273)
```csharp
    public override Empty TakeSnapshot(TakeSnapshotInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);

        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");

        Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");

        // Update previous voting going information.
        var previousVotingResultHash = GetVotingResultHash(input.VotingItemId, votingItem.CurrentSnapshotNumber);
        var previousVotingResult = State.VotingResults[previousVotingResultHash];
        previousVotingResult.SnapshotEndTimestamp = Context.CurrentBlockTime;
        State.VotingResults[previousVotingResultHash] = previousVotingResult;

        Assert(votingItem.CurrentSnapshotNumber == input.SnapshotNumber,
            $"Can only take snapshot of current snapshot number: {votingItem.CurrentSnapshotNumber}, but {input.SnapshotNumber}");
        var nextSnapshotNumber = input.SnapshotNumber.Add(1);
        votingItem.CurrentSnapshotNumber = nextSnapshotNumber;
        State.VotingItems[votingItem.VotingItemId] = votingItem;

        // Initial next voting going information.
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L361-361)
```csharp
        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L382-383)
```csharp
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L92-102)
```csharp
        //voting item have been out of date
        {
            var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1);
            await TakeSnapshot(registerItem.VotingItemId, 1);

            var voter = Accounts[11].KeyPair;
            var voteResult =
                await VoteWithException(voter, registerItem.VotingItemId, registerItem.Options[0], 100);
            voteResult.Status.ShouldBe(TransactionResultStatus.Failed);
            voteResult.Error.Contains("Current voting item already ended").ShouldBeTrue();
        }
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/SnapshotTests.cs (L78-101)
```csharp
    public async Task VoteContract_TakeSnapshot_Success_Test()
    {
        var registerItem = await RegisterVotingItemAsync(10, 4, true, DefaultSender, 3);
        for (var i = 0; i < 3; i++)
        {
            var transactionResult = (await VoteContractStub.TakeSnapshot.SendAsync(
                new TakeSnapshotInput
                {
                    VotingItemId = registerItem.VotingItemId,
                    SnapshotNumber = i + 1
                })).TransactionResult;

            transactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            var votingItem = await GetVoteItem(registerItem.VotingItemId);
            votingItem.CurrentSnapshotNumber.ShouldBe(i + 2);
            var voteResult = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
            {
                VotingItemId = registerItem.VotingItemId,
                SnapshotNumber = i + 2
            });
            voteResult.SnapshotNumber.ShouldBe(i + 2);
        }
    }
```
