# Audit Report

## Title
Unbounded Rental Debt Accumulation Can Exceed Total Token Supply Making Debt Mathematically Unpayable

## Summary
The `PayRental()` method in the MultiToken contract accumulates rental debt for side chain resource tokens (CPU, RAM, DISK, NET) without any ceiling validation. This allows debt to grow indefinitely and eventually exceed the fixed total supply of 500,000,000 tokens per resource type, creating a mathematically impossible debt that can never be repaid.

## Finding Description

The vulnerability exists in the rental payment mechanism for side chains. When a side chain creator's balance is insufficient to pay resource rental fees, the system accumulates debt in `State.OwningRental[symbol]` without validating that this debt remains below the token's total supply.

**Execution Flow:**

1. The `DonateResourceToken()` method is called automatically by miners during block production [1](#0-0) 

2. For side chains, this calls `PayRental()` which calculates rental fees as: `duration × ResourceAmount[symbol] × Rental[symbol]` [2](#0-1) 

3. When the creator's balance is insufficient, the shortfall is added to debt without any ceiling check [3](#0-2) 

**The Critical Issue:**

The `OwningRental` state variable is defined as a simple `MappedState<string, long>` with no constraints [4](#0-3) 

However, resource tokens have a fixed total supply of 500,000,000 tokens [5](#0-4) 

**Why This Breaks Token Economics:**

Once `OwningRental[symbol]` exceeds 500,000,000 tokens, the debt becomes mathematically unpayable. Even if the side chain creator somehow obtained 100% of all tokens in circulation for that resource type, they still could not clear the debt. This violates the fundamental invariant that debt obligations should be bounded by available token supply.

## Impact Explanation

**High Severity - Protocol State Integrity Violation**

This vulnerability creates a permanently unresolvable state in the protocol:

1. **Mathematically Impossible Debt**: When debt > total supply, the creator faces an obligation that cannot physically be fulfilled within the token system's constraints.

2. **Quantified Timeline**: Using test parameters:
   - CPU rental: 4 units × 100 tokens/minute = 400 tokens/minute
   - Daily accumulation: 576,000 tokens
   - Annual accumulation: 210,240,000 tokens  
   - **Time to exceed 500M supply: ~2.38 years of non-payment**

3. **Affected Parties**: 
   - Side chain creators become permanently indebted with no recovery mechanism
   - Consensus contract expectations are violated (expects payment that can never arrive)
   - Resource accounting integrity is compromised

4. **Protocol Invariant Broken**: The critical invariant that "all token obligations must respect total supply constraints" is violated, undermining the economic model.

## Likelihood Explanation

**Medium-High Likelihood**

This is not an attack scenario but a natural protocol behavior under realistic conditions:

1. **No Attacker Required**: Simply requires a side chain creator's balance to deplete, which naturally happens with:
   - Abandoned side chain projects
   - Economic downturns
   - Token price crashes
   - Prolonged operational difficulties

2. **Automatic Trigger**: The debt accumulation happens automatically every minute during block production without any user action needed.

3. **Proven Behavior**: Test cases confirm this behavior [6](#0-5) 

4. **Long-Term Probability**: Over multi-year timeframes, it's highly probable that some side chains will experience extended periods of insufficient balance, leading to debt accumulation beyond the total supply threshold.

5. **Observable but Unpreventable**: While the `RentalAccountBalanceInsufficient` event fires when debt accumulates, there's no automatic protection mechanism to cap the debt.

## Recommendation

Add a ceiling validation in the `PayRental()` method to prevent debt from exceeding the total supply:

```csharp
// After line 1074, before line 1075:
var own = rental.Sub(availableBalance);

// Add this validation:
var maxDebt = EconomicContractConstants.ResourceTokenTotalSupply;
var currentDebt = State.OwningRental[symbol];
var newDebt = currentDebt.Add(own);

if (newDebt > maxDebt)
{
    // Cap debt at total supply
    State.OwningRental[symbol] = maxDebt;
    
    // Fire event indicating debt has been capped
    Context.Fire(new RentalDebtCapped
    {
        Symbol = symbol,
        AttemptedAmount = newDebt,
        CappedAmount = maxDebt
    });
}
else
{
    State.OwningRental[symbol] = newDebt;
}
```

Alternatively, implement a mechanism to halt side chain operations or adjust rental rates when debt approaches the total supply threshold.

## Proof of Concept

The existing test case demonstrates the vulnerability: [6](#0-5) 

This test shows that when the creator has zero balance, debt accumulates in `OwningRental` for each resource token. Running this test with extended time periods (simulating years of non-payment) would demonstrate debt exceeding the 500,000,000 token supply limit, with no validation preventing this impossible state.

To reproduce:
1. Initialize a side chain with resource rentals
2. Ensure creator balance is zero for resource tokens
3. Simulate time passage (minutes/days/years)
4. Observe `State.OwningRental[symbol]` grow without bounds
5. Verify it can exceed 500,000,000 (total supply)

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L913-953)
```csharp
    public override Empty DonateResourceToken(TotalResourceTokensMaps input)
    {
        AssertSenderIsCurrentMiner();
        var donateResourceTokenExecuteHeight = State.DonateResourceTokenExecuteHeight.Value;
        if (donateResourceTokenExecuteHeight == 0)
        {
            donateResourceTokenExecuteHeight = Context.CurrentHeight;
        }

        Assert(donateResourceTokenExecuteHeight == Context.CurrentHeight,
            $"This method already executed in height {State.DonateResourceTokenExecuteHeight.Value}");
        State.DonateResourceTokenExecuteHeight.Value = donateResourceTokenExecuteHeight.Add(1);
        Context.LogDebug(() => $"Start donate resource token. {input}");
        State.LatestTotalResourceTokensMapsHash.Value = HashHelper.ComputeFrom(input);
        Context.LogDebug(() =>
            $"Now LatestTotalResourceTokensMapsHash is {State.LatestTotalResourceTokensMapsHash.Value}");

        var isMainChain = true;
        if (State.DividendPoolContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            if (treasuryContractAddress == null)
            {
                isMainChain = false;
            }
            else
            {
                State.DividendPoolContract.Value = treasuryContractAddress;
            }
        }

        PayResourceTokens(input, isMainChain);

        if (!isMainChain)
        {
            PayRental();
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1061-1061)
```csharp
            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1067-1082)
```csharp
            else // Fail
            {
                // Donate all existing balance. Directly reset the donates.
                donates = GetBalance(creator, symbol);
                State.Balances[creator][symbol] = 0;

                // Update owning rental to record a new debt.
                var own = rental.Sub(availableBalance);
                State.OwningRental[symbol] = State.OwningRental[symbol].Add(own);

                Context.Fire(new RentalAccountBalanceInsufficient
                {
                    Symbol = symbol,
                    Amount = own
                });
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState_ChargeFee.cs (L33-36)
```csharp
    /// <summary>
    /// Symbol -> Amount
    /// </summary>
    public MappedState<string, long> OwningRental { get; set; }
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L10-11)
```csharp
    // Resource token related.
    public const long ResourceTokenTotalSupply = 500_000_000_00000000;
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainSideChainRentFeeTest.cs (L96-119)
```csharp
    public async Task OwnResourceTest()
    {
        await InitialTokenContractAsync(false);

        // Check balance before mining
        {
            var cpuBalance = await GetCreatorBalanceOfAsync("CPU");
            cpuBalance.ShouldBe(0);
            var ramBalance = await GetCreatorBalanceOfAsync("RAM");
            ramBalance.ShouldBe(0);
            var diskBalance = await GetCreatorBalanceOfAsync("DISK");
            diskBalance.ShouldBe(0);
            var netBalance = await GetCreatorBalanceOfAsync("NET");
            netBalance.ShouldBe(0);
        }

        await DelayOneMinuteAsync();

        var owningRental = await TokenContractStub.GetOwningRental.CallAsync(new Empty());
        owningRental.ResourceAmount["CPU"].ShouldBe(CpuAmount * Rental);
        owningRental.ResourceAmount["RAM"].ShouldBe(RamAmount * Rental);
        owningRental.ResourceAmount["DISK"].ShouldBe(DiskAmount * Rental);
        owningRental.ResourceAmount["NET"].ShouldBe(NetAmount * Rental);
    }
```
