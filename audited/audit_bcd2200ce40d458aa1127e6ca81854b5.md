### Title
Unauthorized Round Termination Due to Missing Extra Block Producer Authorization Check

### Summary
The `IsInMinerList` check at line 26 only validates miner list membership, not authorization to terminate the current round. Any miner who has already produced a block in the round can prematurely trigger NextRound/NextTerm behaviors once their time slot expires, bypassing the designated extra block producer mechanism and violating consensus protocol integrity.

### Finding Description

The vulnerability exists in the consensus command generation flow:

**1. Insufficient Authorization Check** [1](#0-0) 

The `IsInMinerList` method only checks if a miner's public key exists in the round's miner dictionary, not whether they are authorized for specific consensus actions: [2](#0-1) 

**2. Flawed Behavior Determination Logic**

The behavior provider allows any miner who has mined (OutValue != null) and whose time slot has passed to receive round-terminating behaviors: [3](#0-2) 

When a miner's `OutValue` is not null and `_isTimeSlotPassed` is true, the code skips TinyBlock logic and directly returns `GetConsensusBehaviourToTerminateCurrentRound()`, which yields NextRound or NextTerm behavior without checking extra block producer authorization.

**3. Missing Validation During Execution**

None of the validation providers enforce extra block producer authorization:

- `MiningPermissionValidationProvider` only checks miner list membership: [4](#0-3) 

- `RoundTerminateValidationProvider` only validates round/term number correctness: [5](#0-4) 

- `TimeSlotValidationProvider` only checks new round time slot spacing: [6](#0-5) 

**4. Design Intent Violation**

The codebase explicitly documents that only the designated extra block producer should terminate rounds: [7](#0-6) 

Each round has one designated extra block producer (marked with `IsExtraBlockProducer = true`): [8](#0-7) 

However, this designation is never validated in the consensus command generation or validation pipeline.

### Impact Explanation

**Consensus Protocol Integrity Violation**: The attack allows miners to bypass the fair block production schedule by prematurely terminating rounds. Miners scheduled later in the round (including the legitimate extra block producer) lose their opportunity to produce blocks, receiving zero rewards for that round.

**Quantified Impact**: In a round with N miners where the attacker is at position K < N:
- (N - K) miners lose their block production slot
- The designated extra block producer's role is usurped
- Round rewards are unfairly redistributed to earlier miners

**Affected Parties**:
- Legitimate miners lose block rewards (economic loss)
- Network suffers from consensus schedule manipulation
- Extra block producer mechanism becomes meaningless

**Severity Justification**: This is a **Medium severity** vulnerability because:
- It requires the attacker to be an elected miner (high privilege)
- Direct economic impact on other miners' rewards
- Violates critical consensus invariant: "miner schedule integrity"
- Does not allow direct fund theft but enables reward manipulation

### Likelihood Explanation

**Attacker Capabilities Required**:
- Must be in the current miner list (requires election/staking)
- Must have already produced at least one block in the current round
- No additional privileges or vulnerabilities needed

**Attack Complexity**: Low
- Single transaction call to `GetConsensusCommand` after the attacker's time slot expires
- No race conditions or timing attacks required
- Deterministic success once preconditions are met

**Feasibility Conditions**:
- Attacker waits until their regular time slot passes
- Simply requests consensus command with NextRound/NextTerm behavior
- The block is validated and accepted by the network

**Detection Constraints**: 
- The attack appears as a legitimate round transition
- No obvious on-chain indicators distinguish it from proper extra block producer behavior
- Difficult to detect without analyzing the `IsExtraBlockProducer` flag post-facto

**Probability Assessment**: Medium-High
- Common scenario in normal operations (miners regularly transition rounds)
- Low technical barrier once miner status is achieved
- Economic incentive exists (monopolize remaining block rewards)

### Recommendation

**1. Add Extra Block Producer Validation in Behavior Provider**

Modify `ConsensusBehaviourProviderBase.GetConsensusBehaviour()` to check if the miner is the designated extra block producer before returning round-terminating behaviors:

```csharp
// Before line 82, add:
var extraBlockProducer = CurrentRound.GetExtraBlockProducerInformation();
if (extraBlockProducer.Pubkey != _pubkey)
    return AElfConsensusBehaviour.Nothing;
```

**2. Add Validation Provider for Extra Block Producer Authorization**

Create `ExtraBlockProducerValidationProvider` to enforce authorization during block validation:

```csharp
public class ExtraBlockProducerValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var behaviour = validationContext.ExtraData.Behaviour;
        if (behaviour == AElfConsensusBehaviour.NextRound || behaviour == AElfConsensusBehaviour.NextTerm)
        {
            var extraBlockProducer = validationContext.BaseRound.GetExtraBlockProducerInformation();
            if (extraBlockProducer.Pubkey != validationContext.SenderPubkey)
            {
                return new ValidationResult 
                { 
                    Message = "Only designated extra block producer can terminate the round." 
                };
            }
        }
        return new ValidationResult { Success = true };
    }
}
```

Add this provider to the validation pipeline in `ValidateBeforeExecution`: [9](#0-8) 

**3. Add Regression Tests**

Create test cases verifying:
- Non-extra-block-producer miners cannot trigger NextRound/NextTerm
- Only the designated extra block producer can successfully terminate rounds
- Validation properly rejects unauthorized round termination attempts

### Proof of Concept

**Initial State**:
- Round has 5 miners: A, B, C, D, E with orders 1-5
- Miner D (order 4) is designated as extra block producer (`IsExtraBlockProducer = true`)
- Miners A, B, C have already produced blocks in this round
- Current block time is after C's time slot ends but before D's time slot begins

**Attack Sequence**:

1. **Miner C requests consensus command**:
   - Calls `GetConsensusCommand(C_pubkey_bytes)`
   - Line 26: `IsInMinerList` check passes (C is in miner list)
   
2. **Behavior determination**:
   - `ConsensusBehaviourProviderBase` constructor sets `_isTimeSlotPassed = true` (C's slot expired)
   - C's `OutValue != null` (already mined this round)
   - Logic reaches line 82, returns `NextRound` from `GetConsensusBehaviourToTerminateCurrentRound()`

3. **Consensus command returned**:
   - Line 51-53: Behaviour is not `Nothing`, so valid consensus command is generated
   - C receives NextRound command despite not being the designated extra block producer

4. **Block validation**:
   - `MiningPermissionValidationProvider`: Passes (C is in miner list)
   - `TimeSlotValidationProvider`: Passes (only checks new round time slot spacing)
   - `RoundTerminateValidationProvider`: Passes (only checks round number increments correctly)
   - **No validator checks if C is the designated extra block producer**

5. **Block execution**:
   - C's NextRound block is accepted
   - Round transitions prematurely
   - Miners D and E lose their turn to produce blocks
   - Designated extra block producer D is bypassed

**Expected Result**: Only miner D should be allowed to terminate the round.

**Actual Result**: Miner C successfully terminates the round, violating the extra block producer mechanism.

**Success Condition**: C produces a valid NextRound block and the new round begins, despite C not being the designated extra block producer marked in the current round's `IsExtraBlockProducer` field.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L49-83)
```csharp
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L13-34)
```csharp
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L60-64)
```csharp
    /// <summary>
    ///     In current AElf Consensus design, each miner produce his block in one time slot, then the extra block producer
    ///     produce a block to terminate current round and confirm the mining order of next round.
    ///     So totally, the time of one round is:
    ///     MiningInterval * MinersCount + MiningInterval.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-91)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```
