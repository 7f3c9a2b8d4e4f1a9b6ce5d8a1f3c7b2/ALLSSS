### Title
Insufficient Validation in ChangeMethodFeeController Allows Permanent Governance Lock Through Unreachable Approval Thresholds

### Summary
The `ChangeMethodFeeController` method only validates that a new controller organization exists but does not verify that its approval thresholds are achievable. This allows changing the method fee controller to a Parliament organization requiring 100% miner approval or an Association requiring all member approval, permanently locking fee configuration if any participant becomes unavailable.

### Finding Description

The vulnerability exists in `ChangeMethodFeeController` where validation is insufficient: [1](#0-0) 

The only validation performed is `CheckOrganizationExist`, which merely verifies the organization address exists in contract state: [2](#0-1) [3](#0-2) 

**Root Cause**: No validation that the new controller's approval thresholds are practically achievable.

**Why Protections Fail**: Parliament organization validation allows `MinimalApprovalThreshold` up to 10000 (100%): [4](#0-3) [5](#0-4) 

With `MinimalApprovalThreshold = 10000`, the approval check requires unanimous consent: [6](#0-5) 

Similarly, Association organizations can require all members to approve: [7](#0-6) 

**Execution Path**: Once the controller is changed, both `SetMethodFee` and `ChangeMethodFeeController` require authorization from the new controller's OwnerAddress: [8](#0-7) 

If the organization requires unanimous approval and any miner/member is unavailable (lost keys, offline, malicious non-participation), proposals can never reach the release threshold, permanently locking fee configuration.

### Impact Explanation

**Concrete Harm**: Permanent loss of governance control over method fee configuration for all system contracts implementing ACS1: [9](#0-8) 

**Affected Parties**: 
- All system contracts lose ability to adjust transaction fees
- Network cannot respond to economic conditions or spam attacks through fee adjustments
- Cannot revert the controller change without meeting impossible approval threshold

**Severity Justification (Critical)**:
- **Permanence**: No recovery mechanism or emergency override exists
- **Scope**: Affects critical economic parameters across entire protocol
- **Operational Impact**: Complete denial of governance over fee configuration
- **Cascading Effects**: Inability to adapt fees could enable economic attacks or render system unusable

### Likelihood Explanation

**Attacker Capabilities Required**:
- Governance majority (2/3 of miners for default Parliament) to approve the controller change proposal
- Ability to create an organization with extreme thresholds

**Attack Complexity**: Low
1. Create Parliament organization with `MinimalApprovalThreshold = 10000` or Association with `MinimalApprovalThreshold = memberCount`
2. Propose `ChangeMethodFeeController` to current governance pointing to new organization
3. Obtain approval from governance majority (standard governance process)

**Feasibility Conditions**:
- Governance carelessness: Proposal could be presented as "enhanced security" without realizing impossibility
- Governance compromise: Malicious supermajority intentionally locks configuration
- Configuration error: Legitimate attempt to strengthen security backfires

**Probability Reasoning**: Medium-High
- Does not require single actor compromise (governance majority needed)
- Could result from legitimate governance mistake rather than purely malicious intent
- Once executed, cannot be reversed regardless of subsequent governance will
- Attack becomes permanent with single successful governance vote

### Recommendation

**Code-Level Mitigation**:
Add validation in `ChangeMethodFeeController` to ensure the new controller organization has achievable thresholds:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    // NEW: Validate organization has reasonable thresholds
    ValidateControllerOrganizationThresholds(input);
    
    State.MethodFeeController.Value = input;
    return new Empty();
}

private void ValidateControllerOrganizationThresholds(AuthorityInfo authorityInfo)
{
    // Query organization details from the governance contract
    var organization = Context.Call<Organization>(
        authorityInfo.ContractAddress,
        "GetOrganization",
        authorityInfo.OwnerAddress);
    
    // For Parliament: ensure threshold < 100% (e.g., max 90%)
    // For Association: ensure threshold < memberCount
    // Specific limits should be based on governance requirements
    Assert(organization != null && 
           organization.ProposalReleaseThreshold.MinimalApprovalThreshold < 9000,
           "Controller organization threshold too high - must allow for member unavailability");
}
```

**Invariant Checks**:
- Controller organization must have `MinimalApprovalThreshold < 9000` (90%) for Parliament
- Controller organization must have `MinimalApprovalThreshold < OrganizationMemberList.Count` for Association
- Consider requiring minimum organization size (e.g., â‰¥ 3 members) to prevent single-point-of-failure

**Test Cases**:
1. Attempt to change controller to Parliament organization with 100% threshold - should revert
2. Attempt to change controller to Association requiring all members - should revert  
3. Verify valid controller changes with reasonable thresholds succeed
4. Test recovery scenarios if member becomes unavailable

### Proof of Concept

**Initial State**:
- Parliament contract initialized with default organization as fee controller
- Default organization has 66.67% approval threshold
- 21 active miners in current miner list

**Attack Sequence**:

1. **Create Malicious Organization** (via default organization proposal):
   - Create Parliament organization with `ProposalReleaseThreshold`:
     - `MinimalApprovalThreshold = 10000` (100%)
     - `MinimalVoteThreshold = 10000`
     - `MaximalAbstentionThreshold = 0`
     - `MaximalRejectionThreshold = 0`
   - Organization validates successfully per validation rules
   - Organization address: `MaliciousOrg`

2. **Change Controller** (via default organization proposal):
   - Create proposal calling `ChangeMethodFeeController` with:
     - `AuthorityInfo { OwnerAddress = MaliciousOrg, ContractAddress = ParliamentContract }`
   - Obtain 14+ miner approvals (2/3 of 21)
   - Release proposal - executes successfully
   - Controller now set to organization requiring unanimous approval

3. **Verify Lock**:
   - Attempt to call `SetMethodFee` or `ChangeMethodFeeController`
   - Requires proposal through `MaliciousOrg` with 21/21 miner approval
   - If even 1 miner is offline/unavailable, proposal cannot reach threshold
   - Fee configuration permanently locked

**Expected vs Actual Result**:
- **Expected**: Controller change should reject organizations with unreachable thresholds
- **Actual**: Controller change succeeds, permanently locking fee governance with no recovery path

**Success Condition**: After step 3, any attempt to modify fee configuration fails unless all 21 miners approve, which is practically impossible to achieve consistently.

### Citations

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L56-60)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** protobuf/acs1.proto (L19-38)
```text
service MethodFeeProviderContract {
    
    // Set the method fees for the specified method. Note that this will override all fees of the method.
    rpc SetMethodFee (MethodFees) returns (google.protobuf.Empty) {
    }

    // Change the method fee controller, the default is parliament and default organization.
    rpc ChangeMethodFeeController (AuthorityInfo) returns (google.protobuf.Empty) {
    }
    
    // Query method fee information by method name.
    rpc GetMethodFee (google.protobuf.StringValue) returns (MethodFees) {
        option (aelf.is_view) = true;
    }

    // Query the method fee controller.
    rpc GetMethodFeeController (google.protobuf.Empty) returns (AuthorityInfo) {
        option (aelf.is_view) = true;
    }
}
```
