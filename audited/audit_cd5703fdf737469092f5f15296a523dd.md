### Title
Parliament Governance Bypass via Miner Set Transition Manipulation

### Summary
The Parliament contract evaluates proposal approval thresholds against the current miner set at release time rather than the miner set at voting time. This allows an attacker to create a proposal with insufficient approval (e.g., 60% of 15 miners), manipulate consensus elections to reduce the miner set to only include approvers (9 miners), and then release the proposal with 100% approval from the new reduced set, bypassing the required 66.67% supermajority from the original voter base.

### Finding Description

The vulnerability exists in the proposal release threshold validation logic in `Parliament_Helper.cs`. When `Release()` is called on a proposal [1](#0-0) , it invokes `IsReleaseThresholdReached()` which retrieves the **current** miner list from the consensus contract [2](#0-1) .

The critical flaw occurs in `CheckEnoughVoteAndApprovals()` where approval count is calculated by filtering the stored approval addresses to only count those present in the current miner set [3](#0-2) . The threshold calculation then compares this filtered approval count against the current total miner count, not the original miner count at voting time.

The miner set changes during term transitions when `ProcessNextTerm()` updates the miner list based on election results [4](#0-3) . New miners are determined by calling `GetVictories()` from the Election contract [5](#0-4) , which can result in a completely different miner set.

The approval addresses are stored in `ProposalInfo.Approvals` [6](#0-5)  when miners vote [7](#0-6) , but there is no snapshot of which miner set was active at voting time. The default approval threshold is 6667 (66.67%) [8](#0-7) .

### Impact Explanation

**Critical Governance Bypass**: An attacker can execute proposals that never achieved legitimate supermajority support, completely undermining Parliament governance security.

**Concrete Attack Scenario**:
- Initial state: 15 active miners (term N)
- Attacker creates a malicious proposal (e.g., treasury drain, unauthorized contract upgrade)
- 9 miners approve (60% < 66.67% required), 3 reject, 1 abstains
- Proposal cannot pass under current rules (60% < 66.67%)
- Via election manipulation (vote buying, staking control, or collusion), attacker ensures only the 9 approving miners are elected in term N+1
- Miner set becomes: 9 miners (all previous approvers)
- When releasing in term N+1: 9 approvals / 9 current miners = 100% > 66.67% ✓
- Proposal executes despite never having proper supermajority

**Quantified Impact**:
- Enables unauthorized treasury withdrawals (unlimited ELF tokens)
- Allows malicious contract upgrades or parameter changes
- Bypasses the fundamental 2/3 supermajority security guarantee
- Affects all Parliament-governed contracts (MultiToken, Consensus, Treasury, etc.)

### Likelihood Explanation

**High Likelihood - Practically Exploitable**:

**Attacker Capabilities**: Requires ability to influence consensus elections through vote buying, large-scale staking, or miner collusion. In DPoS systems, this is economically feasible for high-value targets.

**Attack Complexity**: Medium - requires coordination but no technical exploits:
1. Create proposal and obtain partial approval (straightforward)
2. Manipulate elections to change miner composition (requires economic resources but no code exploits)
3. Release proposal after favorable miner set change (trivial transaction)

**Feasibility Conditions**:
- No time constraints prevent long-lived proposals from spanning term transitions
- Election manipulation is possible through standard DPoS mechanisms (voting/staking)
- No cryptographic or technical barriers exist

**Economic Rationality**: Highly rational for valuable targets. If a malicious proposal can extract $10M from treasury, spending $2M on election manipulation is profitable. The cost scales with the voting/staking requirements, but remains feasible for determined attackers targeting high-value governance actions.

**Detection Constraints**: Difficult to detect as all individual actions (voting, participating in elections, releasing proposals) are legitimate. The attack emerges from their combination across term boundaries.

### Recommendation

**Immediate Fix - Snapshot Miner Set**:

1. **Record miner set at proposal creation**: In `CreateNewProposal()`, store a snapshot of the current miner list in `ProposalInfo`:
   ```
   // Add to ProposalInfo in protobuf:
   repeated bytes miner_pubkeys_at_creation = [new_field_number];
   
   // In CreateNewProposal():
   var currentMiners = GetCurrentMinerList();
   proposal.MinerPubkeysAtCreation.AddRange(currentMiners.Select(m => m.ToByteString()));
   ```

2. **Validate against snapshot**: Modify `CheckEnoughVoteAndApprovals()` to use the snapshot:
   ```
   var minerAddressesAtCreation = proposal.MinerPubkeysAtCreation
       .Select(pk => Address.FromPublicKey(pk.ToByteArray())).ToList();
   var approvedMemberCount = proposal.Approvals.Count(minerAddressesAtCreation.Contains);
   var threshold = approvedMemberCount * AbstractVoteTotal >= 
       organization.ProposalReleaseThreshold.MinimalApprovalThreshold * 
       minerAddressesAtCreation.Count;
   ```

3. **Add invariant check**: Ensure the snapshot is always set:
   ```
   Assert(proposal.MinerPubkeysAtCreation.Any(), 
          "Proposal must have miner snapshot.");
   ```

4. **Test cases**: Add comprehensive tests covering:
   - Proposals spanning term transitions
   - Miner set shrinking/expanding scenarios
   - Approval count changes due to miner set mutations

**Alternative Fix - Require Current Miner Approval**:
Require that approvals come only from addresses that were miners at creation AND remain current miners, ensuring double validation.

### Proof of Concept

**Initial State**:
- Term 1: 15 miners (Miner_01 through Miner_15)
- Default Parliament organization with 66.67% approval threshold

**Transaction Sequence**:

1. **T1 - Create Malicious Proposal** (Block 1000):
   ```
   Caller: Miner_01
   Method: CreateProposal(TransferInput{To: AttackerAddress, Amount: 1000000 ELF})
   Result: ProposalId = 0xABC...
   Current Miners: 15 (Miner_01 to Miner_15)
   ```

2. **T2-T10 - Collect Partial Approvals** (Blocks 1001-1009):
   ```
   Callers: Miner_01, Miner_02, ..., Miner_09
   Method: Approve(0xABC...)
   Result: proposal.Approvals = [Miner_01...Miner_09]
   Approval: 9/15 = 60% < 66.67% (INSUFFICIENT)
   ```

3. **T11-T13 - Collect Rejections/Abstentions** (Blocks 1010-1012):
   ```
   Callers: Miner_10, Miner_11, Miner_12 (Reject)
   Caller: Miner_13 (Abstain)
   Total Votes: 13/15 = 86.67% > 75% vote threshold (SUFFICIENT)
   ```

4. **T14 - Attempt Release** (Block 1013):
   ```
   Caller: Miner_01
   Method: Release(0xABC...)
   Result: FAILED - "Not approved" (9/15 = 60% < 66.67%)
   ```

5. **Term Transition** (Block 2000):
   ```
   Method: NextTerm()
   Election Results: Only Miner_01 through Miner_09 elected
   New Miner Set: 9 miners (previous approvers only)
   GetCurrentMinerList() now returns: [Miner_01...Miner_09]
   ```

6. **T15 - Release After Term Change** (Block 2001):
   ```
   Caller: Miner_01
   Method: Release(0xABC...)
   
   Execution in IsReleaseThresholdReached():
   - parliamentMembers = GetCurrentMinerList() = [Miner_01...Miner_09] (9 miners)
   - approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains) = 9
   - Threshold check: 9 * 10000 >= 6667 * 9 → 90000 >= 59993 ✓
   - Vote threshold: 9/9 = 100% >= 75% ✓
   
   Result: SUCCESS - Proposal executes malicious transfer
   ```

**Expected vs Actual**:
- **Expected**: Proposal remains rejected (insufficient 66.67% from original 15 miners)
- **Actual**: Proposal executes (100% approval from new 9-miner set)

**Success Condition**: Attacker receives 1,000,000 ELF from treasury despite never achieving legitimate supermajority approval.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L78-94)
```csharp
    public override Empty Approve(Hash input)
    {
        var parliamentMemberAddress = GetAndCheckActualParliamentMemberAddress();
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedByMember(proposal, parliamentMemberAddress);
        proposal.Approvals.Add(parliamentMemberAddress);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = parliamentMemberAddress,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L36-48)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var parliamentMembers = GetCurrentMinerList();
        var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
        if (isAbstained)
            return false;

        return CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentState.cs (L22-22)
```csharp
    public MappedState<Hash, ProposalInfo> Proposals { get; set; }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L5-5)
```csharp
    private const int DefaultOrganizationMinimalApprovalThreshold = 6667;
```
