# Audit Report

## Title
Mining Interval Manipulation Allows Time Slot Compression via Insufficient Validation

## Summary
The AEDPoS consensus contract's round time slot validation only enforces that mining intervals are greater than zero without a minimum bound. A malicious miner producing a NextRound or NextTerm block can manipulate the Round data to set arbitrarily small mining intervals (e.g., 1ms) in the ExpectedMiningTime values. The manipulated Round is accepted and stored, causing all miners to operate under compressed time slots and enabling block production at rates far exceeding the intended 4000ms default interval.

## Finding Description

The vulnerability exists in the round validation logic where insufficient checks allow mining interval manipulation.

The mining interval is derived from ExpectedMiningTime differences between consecutive miners. [1](#0-0) 

When a miner produces a NextRound or NextTerm block, they provide Round data containing ExpectedMiningTime values. This data is directly copied without regeneration through the ToRound() method. [2](#0-1) 

The TimeSlotValidationProvider invokes CheckRoundTimeSlots() for validation when a new round is provided. [3](#0-2) 

However, CheckRoundTimeSlots() only validates that the mining interval is strictly greater than zero, with no minimum bound enforced. [4](#0-3) 

A malicious miner can set ExpectedMiningTime values 1 millisecond apart. This passes validation (1 > 0) but allows mining at 4000x the intended frequency. The manipulated Round is stored via AddRoundInformation() in ProcessNextRound or ProcessNextTerm. [5](#0-4) 

The compromised interval propagates because TinyBlockCommandStrategy and future round generation use the current round's mining interval. [6](#0-5) 

Subsequent rounds generated from the manipulated round inherit the compressed interval. [7](#0-6) 

The after-execution validation only compares round hashes and does not regenerate the Round to verify ExpectedMiningTime values. [8](#0-7) 

## Impact Explanation

**Consensus Integrity Violation**: The fundamental consensus timing mechanism is compromised. The intended mining interval ensures proper network propagation, block validation time, and prevents resource exhaustion.

**Block Production Rate Manipulation**: With a 1ms interval, miners could produce 4000 blocks per intended time slot instead of 1, potentially reaching 1,000,000 blocks per second in extreme cases, overwhelming network bandwidth and node processing capacity.

**Chain Stability Impact**: Honest nodes may be unable to keep up with block validation, causing chain reorganizations to become more frequent. Consensus participation becomes effectively restricted to high-resource operators, and the system deviates from intended tokenomics for block rewards.

**Systemic Effect**: Once a manipulated round is accepted, ALL miners in that round operate under the compressed time slots. The manipulation persists as future rounds use the compromised interval to calculate their own ExpectedMiningTime values.

## Likelihood Explanation

**Attacker Requirements**: The attacker must be an active miner in the current round and be designated to produce the round-terminating (NextRound) or term-terminating (NextTerm) block. These opportunities occur regularly (every round/term).

**Attack Complexity**: Low. The attack requires modifying the Round data before including it in the block. No complex cryptographic operations or timing attacks are needed. The transaction structure directly accepts the manipulated data through NextRoundInput or NextTermInput.

**Feasibility**: The validation logic is deterministic and bypassable with any interval > 0. No consensus-level rejection mechanism for suspicious intervals exists. The State.MiningInterval is only set during FirstRound initialization and not updated thereafter for NextRound transitions. [9](#0-8) 

**Detection**: While monitoring could detect abnormal mining rates, the validation passes legitimately at the protocol level, making prevention absent.

## Recommendation

Add a minimum mining interval validation in CheckRoundTimeSlots():

```csharp
public ValidationResult CheckRoundTimeSlots()
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

    var baseMiningInterval =
        (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

    // ADD MINIMUM BOUND CHECK
    const int MinimumMiningInterval = 1000; // 1 second minimum
    if (baseMiningInterval < MinimumMiningInterval)
        return new ValidationResult { Message = $"Mining interval must be at least {MinimumMiningInterval}ms.\n{this}" };

    for (var i = 1; i < miners.Count - 1; i++)
    {
        var miningInterval =
            (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
        if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
            return new ValidationResult { Message = "Time slots are so different." };
    }

    return new ValidationResult { Success = true };
}
```

Additionally, consider implementing validation that regenerates the expected Round data and compares it against the provided Round to ensure ExpectedMiningTime values match the deterministic calculation.

## Proof of Concept

```csharp
[Fact]
public async Task MiningIntervalManipulation_AcceptsOneMillisecondInterval()
{
    // Setup: Initialize consensus with normal miners
    await InitializeConsensusContract();
    await FirstRoundAsync();
    
    // Get current round
    var currentRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Malicious miner creates NextRound with 1ms intervals
    var maliciousRound = new Round
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        RealTimeMinersInformation = { }
    };
    
    // Set ExpectedMiningTime values 1ms apart
    var baseTime = TimestampHelper.GetUtcNow();
    int order = 1;
    foreach (var miner in currentRound.RealTimeMinersInformation.Keys)
    {
        maliciousRound.RealTimeMinersInformation[miner] = new MinerInRound
        {
            Pubkey = miner,
            Order = order,
            ExpectedMiningTime = baseTime.AddMilliseconds(order) // 1ms intervals
        };
        order++;
    }
    
    // Create NextRoundInput with manipulated Round
    var nextRoundInput = new NextRoundInput
    {
        RoundNumber = maliciousRound.RoundNumber,
        RealTimeMinersInformation = { maliciousRound.RealTimeMinersInformation },
        TermNumber = maliciousRound.TermNumber,
        RandomNumber = HashHelper.ComputeFrom("random").ToByteString()
    };
    
    // Execute NextRound - should FAIL but will PASS with current validation
    var result = await ConsensusContract.NextRound.SendAsync(nextRoundInput);
    
    // Verify the manipulated round was accepted
    var newRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    var miningInterval = newRound.GetMiningInterval();
    
    // Assert: Mining interval is 1ms (should be rejected but isn't)
    Assert.Equal(1, miningInterval);
    
    // This demonstrates the vulnerability: a 1ms mining interval passes validation
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-47)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L37-37)
```csharp
        protected int MiningInterval => CurrentRound.GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L20-36)
```csharp
        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-113)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L74-92)
```csharp
    public override Empty FirstRound(Round input)
    {
        /* Basic checks. */
        Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");

        /* Initial settings. */
        State.CurrentTermNumber.Value = 1;
        State.CurrentRoundNumber.Value = 1;
        State.FirstRoundNumberOfEachTerm[1] = 1;
        State.MiningInterval.Value = input.GetMiningInterval();
        SetMinerList(input.GetMinerList(), 1);

        AddRoundInformation(input);

        Context.LogDebug(() =>
            $"Initial Miners: {input.RealTimeMinersInformation.Keys.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");

        return new Empty();
    }
```
