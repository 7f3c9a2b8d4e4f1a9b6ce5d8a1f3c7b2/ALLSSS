### Title
Profit Contract DoS via Unbounded Token Symbol Accumulation in ReceivedTokenSymbols

### Summary
The Profit contract allows unlimited token symbols to be added to a scheme's `ReceivedTokenSymbols` list through `ContributeProfits`, with no validation or cap enforced. When beneficiaries attempt to claim profits via `ClaimProfits`, the nested loop structure (profitable details × token symbols × periods per detail × operations) can exceed AElf's `ExecutionCallThreshold` of 15,000, causing transaction reversion and permanently locking all legitimate profits for affected beneficiaries.

### Finding Description

**Root Cause:**

The vulnerability stems from three design flaws:

1. **Unbounded Symbol Accumulation**: [1](#0-0) 
   Anyone can call `ContributeProfits` with any valid token symbol, and it gets unconditionally added to `ReceivedTokenSymbols` without any limit check.

2. **Constants Do Not Protect Against Symbol-Based DoS**: [2](#0-1) 
   The constants `ProfitReceivingLimitForEachTime=10` and `DefaultMaximumProfitReceivingPeriodCountOfOneTime=100` only limit profitable detail count and period count distribution, but provide no protection against symbol count.

3. **No Symbol Filtering in ClaimProfits**: [3](#0-2) 
   The `ClaimProfitsInput` message has no symbol parameter, forcing beneficiaries to process ALL accumulated symbols.

**Execution Path:**

The claiming logic operates as follows: [4](#0-3) 

When there are 10 profitable details, `maxProfitReceivingPeriodCount` = 100/10 = 10 periods per detail (contrary to the question's assumption of 100 periods per detail). [5](#0-4) 

For each of up to 10 details, `ProfitAllPeriods` is called with the shared `maxProfitReceivingPeriodCount`. [6](#0-5) 

The inner method processes ALL token symbols in `ReceivedTokenSymbols` (since `targetSymbol` is null from `ClaimProfits`), creating nested loops: [7](#0-6) 

For each (symbol, period) combination, the code performs approximately 6-8 method calls including virtual address generation, state reads, profit calculation, virtual inline calls, and event firing.

**Why Existing Protections Fail:**

The period distribution logic in `GetMaximumPeriodCountForProfitableDetail` correctly divides the total period budget among details: [8](#0-7) 

However, this provides NO protection against the multiplicative effect of token symbols. The actual operation count is:
`profitableDetailCount × tokenSymbolCount × periodsPerDetail × operationsPerIteration`

With 10 details claiming 10 periods each and N symbols:
`10 × N × 10 × 7 = 700N operations`

When N ≥ 22 symbols, operations exceed the execution threshold: [9](#0-8) 

### Impact Explanation

**Direct Fund Impact:**
- All accumulated profits (across all token types) become permanently unclaimable for affected beneficiaries
- While funds are not stolen, they are effectively locked in the contract
- Legitimate token profits (e.g., native ELF) are locked alongside griefing tokens

**Affected Parties:**
- All beneficiaries of any profit scheme where an attacker has contributed multiple token symbols
- High-value schemes (Treasury, Election rewards, TokenHolder dividends) are primary targets

**Quantified Damage:**
- An attacker adding ~25-30 worthless token symbols can make claiming impossible
- With 100 token symbols (easily achievable), even schemes with 1 profitable detail claiming 1 period would exceed limits: `1 × 100 × 1 × 7 = 700` operations per period, and beneficiaries often need to claim many periods

**Severity Justification:**
Critical severity because:
1. Permanent fund lockage (no recovery mechanism exists)
2. Low attack cost (just transaction fees + 1 unit of self-created tokens)
3. Affects core economic contracts (Treasury, TokenHolder, Election)
4. No administrator override to rescue locked funds

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Create or obtain multiple token types (can be worthless custom tokens)
2. Call `ContributeProfits` for each token with minimal amounts (1 unit each)
3. No special permissions required - any account can contribute

**Attack Complexity:**
Low - The attack requires only:
- Creating N token contracts (or using existing ones)
- Calling `ContributeProfits` N times with 1 unit of each token
- Cost: N transaction fees + N token units (negligible if using self-created tokens)

**Feasibility Conditions:**
- Target scheme must exist (all major schemes already exist in production)
- No preconditions on attacker relationship to scheme
- Attack works against any scheme, including governance-controlled ones

**Detection Constraints:**
- Attack is difficult to detect until victims attempt to claim
- ReceivedTokenSymbols grows silently with each contribution
- No events or warnings indicate approaching DoS threshold

**Probability Assessment:**
High likelihood because:
1. Entry point (`ContributeProfits`) is unrestricted public method
2. Economic cost is minimal (under $100 for 30 tokens)
3. Impact is severe (locks potentially millions in rewards)
4. No monitoring or prevention exists in current code

### Recommendation

**Immediate Mitigation:**

1. Add hard limit on token symbol count per scheme:
```csharp
// In ProfitContractConstants.cs
public const int MaxTokenSymbolsPerScheme = 10;

// In ContributeProfits method after line 716
Assert(scheme.ReceivedTokenSymbols.Count < ProfitContractConstants.MaxTokenSymbolsPerScheme, 
    $"Scheme has reached maximum token symbol limit of {ProfitContractConstants.MaxTokenSymbolsPerScheme}");
```

2. Add symbol filtering parameter to ClaimProfitsInput:
```protobuf
message ClaimProfitsInput {
    aelf.Hash scheme_id = 1;
    aelf.Address beneficiary = 2;
    string symbol = 3; // Optional: claim specific token only
}
```

3. Modify ProfitAllPeriods to respect symbol parameter:
```csharp
// Line 851 becomes:
var symbols = !string.IsNullOrEmpty(input.Symbol) 
    ? new List<string> { input.Symbol } 
    : scheme.ReceivedTokenSymbols.ToList();
```

**Invariant Checks:**
- Assert `ReceivedTokenSymbols.Count ≤ MaxTokenSymbolsPerScheme` before adding new symbols
- Add view method to calculate estimated operation count before claiming
- Emit warning event when symbol count exceeds safe threshold (e.g., 5 symbols)

**Test Cases:**
1. Test that ContributeProfits reverts when MaxTokenSymbolsPerScheme is reached
2. Test ClaimProfits with symbol parameter claims only specified token
3. Test that claiming 10 details × 10 periods × 10 symbols stays under ExecutionCallThreshold
4. Test that existing schemes with >10 symbols can still be claimed with symbol filter

### Proof of Concept

**Initial State:**
- Profit scheme exists with ID `schemeId`
- Legitimate beneficiary has 1 profitable detail needing to claim 100 periods
- Scheme currently has 1-2 legitimate token symbols (e.g., "ELF", "USDT")

**Attack Steps:**

1. Attacker creates 25 worthless token contracts (Token1, Token2, ..., Token25)

2. For each token, attacker calls:
```
ContributeProfits({
    scheme_id: schemeId,
    symbol: "Token1",
    amount: 1,
    period: 0
})
```
Repeat for Token2 through Token25. [10](#0-9) 

3. After 25 contributions, `scheme.ReceivedTokenSymbols` contains 27 symbols (2 legitimate + 25 griefing)

4. Beneficiary attempts to claim:
```
ClaimProfits({
    scheme_id: schemeId,
    beneficiary: victimAddress
})
```

**Expected vs Actual Result:**

Expected: Beneficiary claims all accumulated profits across legitimate tokens

Actual: Transaction reverts with execution limit exceeded
- Operation count: 1 detail × 27 symbols × 100 periods × 7 ops = 18,900 operations
- Exceeds ExecutionCallThreshold of 15,000
- ALL profits (including legitimate ELF/USDT) become permanently locked

**Success Condition:**
ClaimProfits transaction fails consistently, confirming funds are locked. No recovery mechanism exists in the contract.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-721)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }

        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null)
        {
            throw new AssertionException("Scheme not found.");
        }
        // ReSharper disable once PossibleNullReferenceException
        var virtualAddress = scheme.VirtualAddress;

        if (input.Period == 0)
        {

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = virtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount,
                Memo = $"Add {input.Amount} dividends."
            });
        }
        else
        {
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);

            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
        }

        // If someone directly use virtual address to do the contribution, won't sense the token symbol he was using.
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);

        State.SchemeInfos[scheme.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L772-774)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L777-785)
```csharp
        for (var i = 0; i < profitableDetailCount; i++)
        {
            var profitDetail = profitableDetails[i];
            if (profitDetail.LastProfitPeriod == 0)
                // This detail never performed profit before.
                profitDetail.LastProfitPeriod = profitDetail.StartPeriod;

            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L822-833)
```csharp
    private int GetMaximumPeriodCountForProfitableDetail(int profitableDetailCount)
    {
        // Get the maximum profit receiving period count
        var maxPeriodCount = GetMaximumProfitReceivingPeriodCount();
        // Check if the maximum period count is greater than the profitable detail count
        // and if the profitable detail count is greater than 0
        return maxPeriodCount > profitableDetailCount && profitableDetailCount > 0
            // Divide the maximum period count by the profitable detail count
            ? maxPeriodCount.Div(profitableDetailCount)
            // If the conditions are not met, return 1 as the maximum period count
            : 1;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L851-853)
```csharp
        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

        foreach (var symbol in symbols)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-912)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L5-9)
```csharp
    public const int ProfitReceivingLimitForEachTime = 10;
    public const int DefaultProfitReceivingDuePeriodCount = 10;
    public const int MaximumProfitReceivingDuePeriodCount = 1024;
    public const int TokenAmountLimit = 5;
    public const int DefaultMaximumProfitReceivingPeriodCountOfOneTime = 100;
```

**File:** protobuf/profit_contract.proto (L217-222)
```text
message ClaimProfitsInput {
    // The scheme id.
    aelf.Hash scheme_id = 1;
    // The address of beneficiary.
    aelf.Address beneficiary = 2;
}
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-5)
```csharp
    public const int ExecutionCallThreshold = 15000;
```
