# Audit Report

## Title
Token Issuer and Owner Modifications Never Persist to Storage

## Summary
The `ModifyTokenIssuerAndOwner()` function in the MultiToken contract modifies token issuer and owner fields in memory but fails to persist these changes to contract state. This renders the function completely non-operational, preventing any token governance transfer and potentially bricking tokens whose issuers lose access to their keys.

## Finding Description
The vulnerability exists in the `ModifyTokenIssuerAndOwner()` method where it retrieves tokenInfo from storage, modifies the Issuer and Owner fields in memory, but returns without persisting these changes. [1](#0-0) 

In AElf's contract state model, reading from `State.TokenInfos[symbol]` via `GetTokenInfo()` returns a deserialized copy. [2](#0-1)  Modifications to this copy must be explicitly written back using `SetTokenInfo(tokenInfo)` or direct state assignment. [3](#0-2) 

The state storage documentation explicitly warns about this requirement. [4](#0-3) 

The contract consistently follows the persistence pattern in other functions:
- `Issue()` calls `SetTokenInfo()` after modifications [5](#0-4) 
- `CrossChainReceiveToken()` calls `SetTokenInfo()` after modifications [6](#0-5) 
- `SetSymbolAlias()` calls `SetTokenInfo()` after modifications [7](#0-6) 
- `ExtendSeedExpirationTime()` directly assigns to state after modifications [8](#0-7) 

The test suite only validates error conditions and never verifies the success case where changes should persist. [9](#0-8) 

## Impact Explanation
This vulnerability completely breaks token governance transfer capability. The `issuer` field controls who can issue additional tokens, while the `owner` field controls privileged token operations. The inability to modify these fields means:

1. **Governance DoS:** Tokens cannot transfer control after creation, blocking organizational governance scenarios where control transfer is required
2. **Bricked Tokens:** If an issuer calls this function expecting it to work (it returns success silently), then loses access to their key before discovering the change never persisted, the token becomes permanently stuck with an inaccessible issuer
3. **Silent Failure:** The function returns `Empty` with no error, making it appear successful while actually failing, leading to delayed discovery

This affects all token creators who need governance transfer capabilities, particularly in multi-sig or organizational scenarios.

## Likelihood Explanation
**Certainty: 100%** - The function never persists changes under any circumstance due to missing persistence logic.

**Reachability:** The function is a public method callable by any address that is the current token issuer for a token without an owner set - normal operational conditions.

**Detection:** The bug is silent - returns success without error, making users discover the failure only later when attempting operations with the supposedly-updated issuer/owner.

**Complexity:** Zero - simply calling the function demonstrates it doesn't work. No special attack sequence required.

## Recommendation
Add the missing state persistence call before returning. The fix requires adding one line:

```csharp
public override Empty ModifyTokenIssuerAndOwner(ModifyTokenIssuerAndOwnerInput input)
{
    Assert(!State.TokenIssuerAndOwnerModificationDisabled.Value, "Set token issuer and owner disabled.");
    Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
    Assert(input.Issuer != null && !input.Issuer.Value.IsNullOrEmpty(), "Invalid input issuer.");
    Assert(input.Owner != null && !input.Owner.Value.IsNullOrEmpty(), "Invalid input owner.");

    var tokenInfo = GetTokenInfo(input.Symbol);

    Assert(tokenInfo != null, "Token is not found.");
    Assert(tokenInfo.Issuer == Context.Sender, "Only token issuer can set token issuer and owner.");
    Assert(tokenInfo.Owner == null, "Can only set token which does not have owner.");
    
    tokenInfo.Issuer = input.Issuer;
    tokenInfo.Owner = input.Owner;
    
    SetTokenInfo(tokenInfo);  // ADD THIS LINE
    
    return new Empty();
}
```

## Proof of Concept
```csharp
[Fact]
public async Task ModifyTokenIssuerAndOwner_ChangesNotPersisted_Test()
{
    // Create a token without owner
    var symbol = "TEST";
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = symbol,
        TokenName = "Test Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultAddress,
        IsBurnable = true
    });
    
    // Get initial token info
    var tokenInfoBefore = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = symbol });
    tokenInfoBefore.Issuer.ShouldBe(DefaultAddress);
    tokenInfoBefore.Owner.ShouldBeNull();
    
    // Modify issuer and owner
    var newIssuer = User1Address;
    var newOwner = User2Address;
    await TokenContractStub.ModifyTokenIssuerAndOwner.SendAsync(new ModifyTokenIssuerAndOwnerInput
    {
        Symbol = symbol,
        Issuer = newIssuer,
        Owner = newOwner
    });
    
    // VULNERABILITY: Changes were not persisted
    var tokenInfoAfter = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = symbol });
    tokenInfoAfter.Issuer.ShouldBe(newIssuer);  // FAILS - Still DefaultAddress
    tokenInfoAfter.Owner.ShouldBe(newOwner);    // FAILS - Still null
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L163-167)
```csharp
        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L620-622)
```csharp
        tokenInfo.Supply = tokenInfo.Supply.Add(amount);
        Assert(tokenInfo.Supply <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L642-659)
```csharp
    public override Empty ModifyTokenIssuerAndOwner(ModifyTokenIssuerAndOwnerInput input)
    {
        Assert(!State.TokenIssuerAndOwnerModificationDisabled.Value, "Set token issuer and owner disabled.");
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        Assert(input.Issuer != null && !input.Issuer.Value.IsNullOrEmpty(), "Invalid input issuer.");
        Assert(input.Owner != null && !input.Owner.Value.IsNullOrEmpty(), "Invalid input owner.");

        var tokenInfo = GetTokenInfo(input.Symbol);

        Assert(tokenInfo != null, "Token is not found.");
        Assert(tokenInfo.Issuer == Context.Sender, "Only token issuer can set token issuer and owner.");
        Assert(tokenInfo.Owner == null, "Can only set token which does not have owner.");
        
        tokenInfo.Issuer = input.Issuer;
        tokenInfo.Owner = input.Owner;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L711-713)
```csharp
        tokenInfo.ExternalInfo.Value[TokenContractConstants.SeedExpireTimeExternalInfoKey] =
            input.ExpirationTime.ToString();
        State.TokenInfos[input.Symbol] = tokenInfo;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L763-766)
```csharp
        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L407-416)
```csharp
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L418-422)
```csharp
    private void SetTokenInfo(TokenInfo tokenInfo)
    {
        var symbol = tokenInfo.Symbol;
        State.TokenInfos[symbol] = tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L12-16)
```csharp
    /// <summary>
    /// WARNING: Use GetTokenInfo & SetTokenInfo to operate TokenInfos
    /// due to token symbol alias feature.
    /// </summary>
    public MappedState<string, TokenInfo> TokenInfos { get; set; }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenApplicationTests.cs (L1826-1900)
```csharp
    [Fact]
    public async Task TokenIssuerAndOwnerModification_Test()
    {
        var result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput());
        result.TransactionResult.Error.ShouldContain("Invalid input symbol.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = "TEST"
        });
        result.TransactionResult.Error.ShouldContain("Invalid input issuer.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = "TEST",
            Issuer = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Invalid input owner.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = "TEST",
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Token is not found.");
        
        result = await TokenContractStubUser.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = DefaultSymbol,
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Only token issuer can set token issuer and owner.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = DefaultSymbol,
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Can only set token which does not have owner.");
        
        var output = await TokenContractStub.GetTokenIssuerAndOwnerModificationEnabled.CallAsync(new Empty());
        output.Value.ShouldBeTrue();
        
        result = await TokenContractStub.SetTokenIssuerAndOwnerModificationEnabled.SendWithExceptionAsync(
            new SetTokenIssuerAndOwnerModificationEnabledInput
            {
                Enabled = false
            });
        result.TransactionResult.Error.ShouldContain("Unauthorized behavior.");
        
        var defaultParliament = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
        var proposalId = await CreateProposalAsync(TokenContractAddress,
            defaultParliament, nameof(TokenContractStub.SetTokenIssuerAndOwnerModificationEnabled),
            new SetTokenIssuerAndOwnerModificationEnabledInput
            {
                Enabled = false
            });
        await ApproveWithMinersAsync(proposalId);
        await ParliamentContractStub.Release.SendAsync(proposalId);
        
        output = await TokenContractStub.GetTokenIssuerAndOwnerModificationEnabled.CallAsync(new Empty());
        output.Value.ShouldBeFalse();
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = DefaultSymbol,
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Set token issuer and owner disabled.");

    }
```
