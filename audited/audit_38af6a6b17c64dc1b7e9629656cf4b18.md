### Title
Missing Uniqueness Validation for Treasury Scheme IDs Enables Consensus Failure

### Summary
The `SetTreasurySchemeIdsToElectionContract()` function in EconomicContract and `SetTreasurySchemeIds()` in ElectionContract lack validation to ensure the five profit scheme IDs (Treasury, Welcome, Flexible, Subsidy, Welfare) are unique. If duplicate scheme IDs are passed due to bugs in the Profit Contract, partial ResetManager failures, or initialization errors, the Election Contract's `TakeSnapshot()` function will fail when attempting to distribute profits twice to the same scheme in the same period, causing consensus failure and potential chain halt.

### Finding Description

The vulnerability exists in the initialization flow where scheme IDs are transferred from the Economic Contract to the Election Contract: [1](#0-0) 

The function retrieves scheme IDs from two different managers (Treasury and Election contracts) and passes them to the Election Contract without validating uniqueness. The Election Contract accepts these IDs without validation: [2](#0-1) 

The root cause is the absence of defensive validation despite the critical nature of these IDs. The function relies entirely on correct behavior of upstream contracts (Profit Contract's `GetManagingSchemeIds` and Treasury Contract's `ResetManager`) without verifying the result.

If duplicate scheme IDs exist, the Election Contract's `TakeSnapshot()` method calls `DistributeProfits` for both `SubsidyHash` and `WelfareHash`: [3](#0-2) 

If these IDs are duplicates, the first `DistributeProfits` call succeeds and increments the scheme's `CurrentPeriod`. The second call fails at the period validation: [4](#0-3) 

Because `CurrentPeriod` was already incremented, the assertion fails with "Invalid period," causing the entire `TakeSnapshot` transaction to revert.

### Impact Explanation

**Operational Impact - Consensus Failure:**

The `TakeSnapshot` method is invoked by the AEDPoS consensus contract during term transitions. If this method fails due to duplicate scheme IDs: [5](#0-4) 

The consensus contract will be unable to complete term transitions, leading to:
- **Chain halt or degraded consensus**: Term transitions cannot complete
- **Block production disruption**: Miners cannot be updated for new terms  
- **Economic system freeze**: Profit distributions cannot occur
- **Complete system failure**: All dependent contracts (Treasury, TokenHolder, etc.) cannot function

This affects all network participants: miners lose rewards, voters cannot claim profits, and the entire chain's economic system becomes inoperable.

### Likelihood Explanation

**Preconditions for exploitation:**

1. **Profit Contract bug**: `GetManagingSchemeIds` returns duplicate IDs in its list
2. **ResetManager failure**: Partial state update where scheme removed from old manager but not added to new manager, causing overlap
3. **Initialization race condition**: Though AElf uses sequential execution, upgrade scenarios could introduce timing issues
4. **Array indexing mismatch**: If Treasury creates fewer than 7 schemes or in different order, hardcoded indices [0], [3], [4] access wrong elements

**Attack complexity: N/A (No attacker needed)**

This is not an exploitable vulnerability by malicious actors, but rather a defensive programming weakness. The issue would manifest from:
- Contract bugs in upstream dependencies (Profit Contract, Treasury Contract)
- Deployment/upgrade errors
- Initialization sequence failures

**Likelihood assessment:**
- Under normal operation: **LOW** (existing code paths appear correct)
- Under abnormal conditions (bugs, upgrades, initialization errors): **MEDIUM**
- Detection: Transaction would fail immediately, making it detectable but not preventable without the fix

The one-time initialization check prevents repeated calls, but doesn't prevent the initial call from containing duplicates: [6](#0-5) 

### Recommendation

**Immediate fix - Add uniqueness validation:**

In `ElectionContract.SetTreasurySchemeIds()`, add validation after line 164:

```csharp
Assert(State.TreasuryHash.Value == null, "Treasury profit ids already set.");

// Add uniqueness validation
var schemeIds = new[] { input.TreasuryHash, input.WelcomeHash, input.FlexibleHash, 
                        input.SubsidyHash, input.WelfareHash };
var distinctCount = schemeIds.Distinct().Count();
Assert(distinctCount == 5, "Scheme IDs must be unique.");
Assert(schemeIds.All(id => id != null && id != Hash.Empty), "Invalid scheme IDs.");

State.TreasuryHash.Value = input.TreasuryHash;
// ... rest of the code
```

**Additional defensive measures:**

1. In `EconomicContract.SetTreasurySchemeIdsToElectionContract()`, add pre-validation before sending:
   - Verify array bounds before accessing indices [0], [3], [4] and [0], [1]
   - Check that retrieved scheme IDs are not null or empty
   - Validate uniqueness before cross-contract call

2. Add integration tests that verify:
   - All 7 schemes are created successfully
   - ResetManager completes for schemes 2 and 3
   - Retrieved scheme IDs are unique
   - TakeSnapshot succeeds after initialization

3. Add assertion in `TreasuryContract.InitialMiningRewardProfitItem()` to verify exactly 7 schemes exist before proceeding.

### Proof of Concept

**Scenario: Profit Contract Bug Returns Duplicate IDs**

**Initial state:**
- Economic Contract initialized
- Treasury Contract creates 7 schemes
- ResetManager partially fails for scheme 2, leaving it in both Treasury and Election manager lists

**Execution steps:**

1. `EconomicContract.InitialEconomicSystem()` is called
2. Reaches `SetTreasurySchemeIdsToElectionContract()` at line 33 [7](#0-6) 

3. `GetManagingSchemeIds` returns:
   - Treasury: [scheme0, scheme1, scheme2, scheme4, scheme5, scheme6] (scheme 2 not removed due to bug)
   - Election: [scheme2, scheme3]

4. Function sets:
   - `SubsidyHash` = scheme2 (from Election list[0])
   - `FlexibleHash` = scheme2 (from Treasury list[4] which is actually scheme2)
   
5. **Result**: SubsidyHash and FlexibleHash both equal scheme2
6. No validation catches this duplication
7. Later, when consensus calls `TakeSnapshot()`, two `DistributeProfits` calls are made with the same scheme ID and period
8. First call succeeds, second call fails with "Invalid period" assertion
9. **Consensus fails**, term cannot transition, chain halts

**Expected behavior:**
System should detect duplicate scheme IDs during initialization and reject the configuration, preventing consensus failure.

**Actual behavior:**
Duplicate IDs are accepted, causing deferred consensus failure at runtime.

### Citations

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L33-33)
```csharp
        SetTreasurySchemeIdsToElectionContract();
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L187-209)
```csharp
    private void SetTreasurySchemeIdsToElectionContract()
    {
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
        var schemeIdsManagingByTreasuryContract = State.ProfitContract.GetManagingSchemeIds.Call(
            new GetManagingSchemeIdsInput
            {
                Manager = Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)
            }).SchemeIds;
        var schemeIdsManagingByElectionContract = State.ProfitContract.GetManagingSchemeIds.Call(
            new GetManagingSchemeIdsInput
            {
                Manager = Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName)
            }).SchemeIds;
        State.ElectionContract.SetTreasurySchemeIds.Send(new SetTreasurySchemeIdsInput
        {
            TreasuryHash = schemeIdsManagingByTreasuryContract[0],
            WelcomeHash = schemeIdsManagingByTreasuryContract[3],
            FlexibleHash = schemeIdsManagingByTreasuryContract[4],
            SubsidyHash = schemeIdsManagingByElectionContract[0],
            WelfareHash = schemeIdsManagingByElectionContract[1]
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L162-171)
```csharp
    public override Empty SetTreasurySchemeIds(SetTreasurySchemeIdsInput input)
    {
        Assert(State.TreasuryHash.Value == null, "Treasury profit ids already set.");
        State.TreasuryHash.Value = input.TreasuryHash;
        State.WelfareHash.Value = input.WelfareHash;
        State.SubsidyHash.Value = input.SubsidyHash;
        State.WelcomeHash.Value = input.WelcomeHash;
        State.FlexibleHash.Value = input.FlexibleHash;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L402-408)
```csharp
    public override Empty TakeSnapshot(TakeElectionSnapshotInput input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        Assert(State.AEDPoSContract.Value == Context.Sender, "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L442-454)
```csharp
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.SubsidyHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.WelfareHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L479-480)
```csharp
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```
