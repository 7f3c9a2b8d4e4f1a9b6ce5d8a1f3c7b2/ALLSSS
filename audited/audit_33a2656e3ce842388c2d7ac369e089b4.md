### Title
Consensus Takeover via Unvalidated NextTerm Miner List - State Poisoning Leading to Complete Consensus Breach

### Summary
The `NextTerm` consensus method fails to validate that the provided miner list matches the authoritative Election contract's `GetVictories` results during `ValidateBeforeExecution`. A malicious current miner can submit a `NextTerm` transaction with an arbitrary miner list, which gets stored in StateDb and used by all future validations. This allows unauthorized miners to produce blocks while blocking legitimate elected miners, achieving complete consensus takeover for the entire term.

### Finding Description

**Root Cause:**

The vulnerability exists in the validation pipeline for `NextTerm` transactions. When a block containing a `NextTerm` consensus behavior is validated, the system reads `BaseRound` and `PreviousRound` from StateDb to create a `ConsensusValidationContext`. [1](#0-0) 

The validation providers used for `NextTerm` behavior do not verify that the miner list in the provided Round matches the Election contract's authoritative miner list: [2](#0-1) 

The `RoundTerminateValidationProvider` only validates that round and term numbers increment correctly, not the miner list contents: [3](#0-2) 

After validation passes, `ProcessNextTerm` directly stores the provided miner list without verification against Election contract: [4](#0-3) 

**Why Existing Protections Fail:**

1. **No Pre-Execution Validation**: While `GenerateFirstRoundOfNextTerm` correctly queries the Election contract's `GetVictories` to build the proper miner list, this is only used for generating the *intended* input. The validation does not verify that the *actual* submitted input matches this. [5](#0-4) 

2. **Post-Execution Validation Insufficient**: `ValidateConsensusAfterExecution` only checks for individual miner replacements (pubkey updates), not wholesale miner list manipulation. After execution, both the header and state contain the same (malicious) miner list, so the comparison passes. [6](#0-5) 

3. **Mining Permission Based on Poisoned State**: Future blocks validate mining permission using `BaseRound` from StateDb, which now contains the corrupted miner list: [7](#0-6) 

**Round Structure Vulnerability:**

The Round message contains `real_time_miners_information` which maps pubkeys to miner information, and this mapping is never validated against Election results: [8](#0-7) 

### Impact Explanation

**Concrete Harm:**

1. **Complete Consensus Takeover**: An attacker who is a current miner can produce a `NextTerm` block with an arbitrary miner list, replacing elected miners with themselves or accomplices. This gives them control over block production for the entire term.

2. **Democracy Subversion**: Election results from the Election contract are completely ignored. Voters' choices are nullified as unauthorized miners take control.

3. **Legitimate Miner DoS**: Properly elected miners are removed from the miner list and cannot produce blocks. Their validation fails at `MiningPermissionValidationProvider` because `BaseRound.RealTimeMinersInformation` doesn't contain their pubkeys.

4. **Persistent Attack**: The corrupted miner list remains in StateDb for the entire term. The attacker can maintain control by continuing to submit malicious `NextTerm` transactions at each term boundary.

5. **Chain Fork Risk**: If different nodes accept different miner lists (due to race conditions or network partitions during the attack), the chain could fork with different nodes following different miner sets.

**Affected Parties:**
- All legitimate elected miners (blocked from mining)
- Token holders who voted (their votes ignored)
- Network security (consensus centralized to attacker)
- DApp users (malicious miners could censor/reorder transactions)

**Severity Justification:** CRITICAL - Complete compromise of consensus mechanism, the foundation of blockchain security.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an authorized miner in the current term (to pass `PreCheck`)
- Must produce the `NextTerm` block for the term transition
- Can craft custom transaction payloads (standard capability)

**Attack Complexity:** LOW
- No cryptographic breaks required
- No timing attacks needed
- Simple transaction crafting
- Deterministic outcome once block is accepted

**Feasibility Conditions:**
- Attacker has ~1/N probability of producing the NextTerm block (N = number of current miners)
- If unsuccessful, attacker can try again at next term boundary
- Multiple malicious miners can coordinate to increase probability

**Detection Constraints:**
- Attack is visible on-chain but may appear as normal consensus operation
- Off-chain monitoring could compare stored miner list with Election contract results
- But by the time detection occurs, corrupted state is already committed

**Probability Assessment:** HIGH
- Any current miner has opportunity at each term transition
- Attacker gets multiple attempts (every term)
- No special resources or timing required
- Economic incentive is high (control block production, MEV capture, censorship power)

### Recommendation

**Immediate Fix - Add Miner List Validation:**

Create a new validation provider `TermMinerListValidationProvider` that verifies the NextTerm miner list matches Election contract:

```csharp
public class TermMinerListValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        if (validationContext.ExtraData.Behaviour != AElfConsensusBehaviour.NextTerm)
            return new ValidationResult { Success = true };
            
        // Get authoritative miner list from Election contract
        var electionMiners = validationContext.State.ElectionContract.GetVictories.Call(new Empty());
        var providedMiners = validationContext.ProvidedRound.RealTimeMinersInformation.Keys.ToList();
        
        // Verify miner lists match
        if (electionMiners.Value.Count != providedMiners.Count)
            return new ValidationResult { Message = "Miner count mismatch with Election contract" };
            
        foreach (var electionMiner in electionMiners.Value)
        {
            if (!providedMiners.Contains(electionMiner.ToHex()))
                return new ValidationResult { Message = $"Unauthorized miner {electionMiner.ToHex()} in NextTerm" };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Add this provider to the validation list for NextTerm behavior: [2](#0-1) 

**Additional Hardening:**

1. Add integrity checks when reading from StateDb - verify BaseRound miner list matches stored MinerListMap
2. Implement periodic re-validation against Election contract
3. Add monitoring/events when miner list changes to enable off-chain detection
4. Consider adding a state hash or signature from Election contract to prove miner list authenticity

**Test Cases:**

1. Test that NextTerm with incorrect miner list is rejected
2. Test that NextTerm with extra unauthorized miners is rejected  
3. Test that NextTerm with missing elected miners is rejected
4. Test that legitimate NextTerm with correct miner list still passes
5. Test that manipulated BaseRound in StateDb causes validation failure for subsequent blocks

### Proof of Concept

**Initial State:**
- Current term has miners: [MinerA, MinerB, MinerC]
- MinerA is the attacker
- Election contract GetVictories returns: [MinerX, MinerY, MinerZ] for next term
- Term boundary is approaching

**Attack Sequence:**

1. **MinerA produces NextTerm block**:
   - Instead of calling `GenerateFirstRoundOfNextTerm` honestly, MinerA crafts malicious `NextTermInput`
   - Sets `NextTermInput.Round.RealTimeMinersInformation` to: {MinerA, MinerA_Accomplice, MinerA_Accomplice2}
   - Sets `NextTermInput.Round.TermNumber` to CurrentTerm + 1 (correct increment)
   - Sets `NextTermInput.Round.RoundNumber` to NextRound (correct increment)
   - Submits transaction: `NextTerm(maliciousInput)`

2. **Validation executes** (ValidateBeforeExecution):
   - Reads BaseRound from StateDb (current term's round)
   - Creates ConsensusValidationContext with BaseRound
   - RoundTerminateValidationProvider checks: CurrentTerm + 1 == NextTerm ✓ (passes)
   - RoundTerminateValidationProvider checks: CurrentRound + 1 == NextRound ✓ (passes)
   - **NO CHECK** against Election.GetVictories
   - Validation returns Success = true

3. **Execution processes**:
   - ProcessNextTerm stores malicious miner list: `State.MinerListMap[nextTerm] = {MinerA, MinerA_Accomplice, MinerA_Accomplice2}`
   - Stores malicious Round: `State.Rounds[nextRound] = corrupted_round`
   - Updates term number: `State.CurrentTermNumber = nextTerm`

4. **Future block validation broken**:
   - MinerX (legitimately elected) tries to produce block
   - ValidateBeforeExecution reads BaseRound from StateDb (corrupted)
   - MiningPermissionValidationProvider checks: Is MinerX in BaseRound.RealTimeMinersInformation? ✗ (false - MinerX not in corrupted list)
   - Validation fails: "Sender is not a miner"
   - MinerX's block rejected

5. **Attack succeeds**:
   - MinerA produces blocks: passes validation (in corrupted miner list)
   - MinerA_Accomplice produces blocks: passes validation
   - MinerX, MinerY, MinerZ: all rejected (not in corrupted miner list)
   - Consensus fully controlled by attacker for entire term

**Expected vs Actual:**
- **Expected**: Only [MinerX, MinerY, MinerZ] can produce blocks (elected miners)
- **Actual**: Only [MinerA, MinerA_Accomplice, MinerA_Accomplice2] can produce blocks (attacker's choice)

**Success Condition:** 
Attacker maintains block production control, legitimate miners are permanently blocked, until next term where attacker can repeat the attack.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-196)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-113)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-21)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** protobuf/aedpos_contract.proto (L243-264)
```text
message Round {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producers’ expecting time (second).
    int64 round_id_for_validation = 10;
}
```
