### Title
NFT Contract GetMethodFeeController Returns Empty AuthorityInfo Breaking ACS1 Standard and Governance Control

### Summary
The NFT contract's `GetMethodFeeController()` method returns an empty `AuthorityInfo{}` instead of initializing it with Parliament's default organization as required by the ACS1 standard. [1](#0-0)  This violates the documented ACS1 specification [2](#0-1)  and prevents any governance-based mechanism from managing method fees for the NFT contract, making the hard-coded 100 ELF fee for the `Create` method immutable without a contract upgrade. [3](#0-2) 

### Finding Description

The NFT contract implements ACS1's `GetMethodFeeController()` as a stub that simply returns an empty `AuthorityInfo{}`. [1](#0-0)  This contrasts sharply with all other AElf system contracts, which follow the standard pattern of calling `RequiredMethodFeeControllerSet()` to initialize the controller with Parliament's default organization.

For comparison, the Parliament contract properly implements this: [4](#0-3)  with initialization logic that sets the default authority: [5](#0-4) 

Similarly, other contracts like Association [6](#0-5) , TokenHolder [7](#0-6) , and MultiToken [8](#0-7)  all properly initialize the method fee controller.

The ACS1 documentation explicitly states that `ChangeMethodFeeController` is to "Change the method fee controller, the default is parliament and default organization." [9](#0-8) 

Additionally, the NFT contract's `SetMethodFee` and `ChangeMethodFeeController` methods are stub implementations that return empty without performing any logic: [10](#0-9) 

This means there is no state variable for `MethodFeeController`, no storage for transaction fees, and no mechanism for governance to control method fees.

### Impact Explanation

This violation has three concrete impacts:

1. **Governance Bypass**: The ACS1 standard is designed to allow governance (via Parliament's default organization requiring 2/3 miner approval) to manage method fees for all system contracts. The NFT contract completely bypasses this governance mechanism, preventing any DAO-level control over its fee structure.

2. **Operational Inflexibility**: The `Create` method fee is hard-coded at 100 ELF (10,000,000,000 base units). [3](#0-2)  If economic conditions change (e.g., ELF price increases significantly) or spam prevention requires fee adjustment, the only recourse is a full contract upgrade rather than a simple governance proposal. This creates unnecessary operational burden and risk.

3. **Standard Non-Compliance**: Integration tests across the codebase explicitly verify that `GetMethodFeeController` returns valid `AuthorityInfo` with Parliament's default organization. [11](#0-10)  The NFT contract fails these standard expectations, making it the only system contract with broken ACS1 compliance.

The severity is HIGH because this breaks a fundamental governance invariant that all AElf system contracts must respect method-fee provider authority controlled by Parliament's default organization.

### Likelihood Explanation

This issue has 100% likelihood and requires no attack:

1. **Reachable Entry Point**: `GetMethodFeeController` is a public view method accessible to anyone. [1](#0-0) 

2. **No Preconditions**: Anyone can call this method at any time and observe that it returns an empty `AuthorityInfo{}` with no `OwnerAddress` or `ContractAddress` set.

3. **Immediate Impact**: The governance mechanism is already broken. Any attempt by Parliament to manage NFT contract fees through standard ACS1 methods would fail because:
   - `SetMethodFee` ignores all inputs and returns empty [12](#0-11) 
   - `ChangeMethodFeeController` ignores all inputs and returns empty [13](#0-12) 

4. **Detection**: This is easily verifiable by calling `GetMethodFeeController()` and observing the empty return value, contrasting with the expected behavior documented in ACS1 implementation examples. [14](#0-13) 

### Recommendation

Implement proper ACS1 compliance by following the standard pattern used in all other system contracts:

1. **Add State Variable**: Add `SingletonState<AuthorityInfo> MethodFeeController` and `MappedState<string, MethodFees> TransactionFees` to the NFT contract's state definition.

2. **Implement RequiredMethodFeeControllerSet**: Create a private method that initializes the controller with Parliament's default organization if not already set, following the pattern in TokenHolder: [15](#0-14) 

3. **Update GetMethodFeeController**: Change the implementation to call `RequiredMethodFeeControllerSet()` and return the initialized value instead of empty `AuthorityInfo{}`.

4. **Implement SetMethodFee**: Add authorization checks and state updates following the standard pattern. [16](#0-15) 

5. **Implement ChangeMethodFeeController**: Add authorization checks and controller updates. [17](#0-16) 

6. **Add Tests**: Create test cases similar to those in other contracts to verify proper ACS1 compliance. [18](#0-17) 

### Proof of Concept

**Current Behavior:**
1. Call `NFTContract.GetMethodFeeController(Empty)`
2. Returns: `AuthorityInfo { OwnerAddress = null, ContractAddress = null }`
3. Expected: `AuthorityInfo { OwnerAddress = [Parliament Default Org], ContractAddress = [Parliament Contract] }`

**Governance Failure:**
1. Attempt to create a Parliament proposal to call `NFTContract.SetMethodFee` to adjust the Create method fee
2. Even if proposal passes, `SetMethodFee` is a stub that does nothing [12](#0-11) 
3. Fee remains at 100 ELF with no way to change it through governance
4. Only solution is contract upgrade, violating the governance design pattern

**Standard Violation:**
Compare NFT contract behavior with standard implementation in TokenConverter tests which verify: [19](#0-18) 
- `methodFeeController.OwnerAddress.ShouldBe(defaultOrganization)` ✗ FAILS for NFT (returns null)
- `methodFeeController.ContractAddress.ShouldBe(ParliamentContractAddress)` ✗ FAILS for NFT (returns null)

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-16)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }

    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L22-34)
```csharp
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L39-42)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        return new AuthorityInfo();
    }
```

**File:** protobuf/acs1.proto (L25-26)
```text
    // Change the method fee controller, the default is parliament and default organization.
    rpc ChangeMethodFeeController (AuthorityInfo) returns (google.protobuf.Empty) {
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L46-50)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L62-73)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.DefaultOrganizationAddress.Value,
            ContractAddress = Context.Self
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L39-43)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L40-44)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L50-64)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L54-58)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }
```

**File:** docs-sphinx/reference/acs/acs1.rst (L19-19)
```text
| ChangeMethodFeeController   | `AuthorityInfo <#AuthorityInfo>`__                               | `google.protobuf.Empty <#google.protobuf.Empty>`__   | Change the method fee controller, the default is parliament and default organization.                |
```

**File:** docs-sphinx/reference/acs/acs1.rst (L375-383)
```text
The implementation of ``GetMethodFeeController`` is also very easy：

.. code:: c#

   public override AuthorityInfo GetMethodFeeController(Empty input)
   {
       RequiredMethodFeeControllerSet();
       return State.MethodFeeController.Value;
   }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/ACS1_ImplementTest.cs (L33-37)
```csharp
        var methodFeeController = await DefaultStub.GetMethodFeeController.CallAsync(new Empty());
        var defaultOrganization =
            await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(
                new Empty());
        methodFeeController.OwnerAddress.ShouldBe(defaultOrganization);
```

**File:** test/AElf.Contracts.TokenConverter.Tests/ACS1_ImplementTest.cs (L82-88)
```csharp
    public async Task GetMethodFeeController_Test()
    {
        var defaultController = await DefaultStub.GetMethodFeeController.CallAsync(new Empty());
        defaultController.ContractAddress.ShouldBe(ParliamentContractAddress);
        var defaultParliament = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
        defaultController.OwnerAddress.ShouldBe(defaultParliament);
    }
```

**File:** test/AElf.Contracts.Profit.Tests/BVT/ACS1Tests.cs (L61-93)
```csharp
        public async Task ChangeMethodFeeController_Test()
        {
            var createOrganizationResult =
                await ParliamentContractStub.CreateOrganization.SendAsync(
                    new CreateOrganizationInput
                    {
                        ProposalReleaseThreshold = new ProposalReleaseThreshold
                        {
                            MinimalApprovalThreshold = 1000,
                            MinimalVoteThreshold = 1000
                        }
                    });
            var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.TransactionResult.ReturnValue);

            var methodFeeController = await ProfitContractStub.GetMethodFeeController.CallAsync(new Empty());
            var defaultOrganization = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
            methodFeeController.OwnerAddress.ShouldBe(defaultOrganization);

            const string proposalCreationMethodName = nameof(ProfitContractStub.ChangeMethodFeeController);
            var proposalId = await CreateProposalAsync(ProfitContractAddress,
                methodFeeController.OwnerAddress, proposalCreationMethodName, new AuthorityInfo
                {
                    OwnerAddress = organizationAddress,
                    ContractAddress = ParliamentContractAddress
                });
            await ApproveWithMinersAsync(proposalId);
            var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId);
            releaseResult.TransactionResult.Error.ShouldBeNullOrEmpty();
            releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            var newMethodFeeController = await ProfitContractStub.GetMethodFeeController.CallAsync(new Empty());
            newMethodFeeController.OwnerAddress.ShouldBe(organizationAddress);
        }
```
