# Audit Report

## Title
Missing Cross-Chain Verification in NFT Protocol Creation Allows Unauthorized Protocol Registration

## Summary
The `CrossChainCreate()` function in the NFT contract lacks any cross-chain verification mechanisms. Any address can call this function to create NFT protocols for tokens that exist in the local TokenContract, completely bypassing the mainchain-only creation requirement and proper merkle proof verification that is standard in AElf's cross-chain operations.

## Finding Description

The vulnerability exists in the `CrossChainCreate()` function which accepts only a symbol parameter and performs no cryptographic verification. [1](#0-0) 

The function simply:
1. Checks if the protocol already exists
2. Reads token information from the local TokenContract  
3. Creates an NFT protocol from that data

The input message definition shows it only accepts a symbol string: [2](#0-1) 

This contrasts sharply with the secure implementation in MultiToken's `CrossChainCreateToken()`, which properly implements cross-chain verification: [3](#0-2) 

The MultiToken contract accepts comprehensive cross-chain verification parameters: [4](#0-3) 

And calls the `CrossChainVerify` helper method that performs cryptographic merkle proof validation: [5](#0-4) 

The NFT contract has NO such verification despite the function's name suggesting cross-chain functionality. Additionally, while the `Create()` function enforces mainchain-only creation: [6](#0-5) 

The `CrossChainCreate()` function has no such chain ID validation, allowing it to be called on any chain.

## Impact Explanation

**Critical Security Violations**:

1. **Unauthorized Protocol Creation**: Any address can create NFT protocols for any token in the local TokenContract without authorization from the token creator or proper cross-chain validation

2. **Bypass Mainchain-Only Invariant**: The system enforces that NFT protocols should only be created on the AELF mainchain, but `CrossChainCreate()` allows this security boundary to be bypassed on sidechains

3. **Front-Running Attacks**: Attackers can monitor pending legitimate cross-chain NFT protocol registrations and front-run them by calling `CrossChainCreate()` first. The legitimate transaction will then fail since the protocol already exists

4. **Cross-Chain Integrity Violation**: This completely defeats AElf's cross-chain security model which requires cryptographic merkle proof verification for all cross-chain operations

**Affected Parties**:
- NFT protocol creators expecting secure cross-chain registration
- Token creators whose tokens can be converted to NFT protocols without consent
- The entire sidechain NFT infrastructure's integrity

The severity is **CRITICAL** because it breaks fundamental cross-chain security guarantees that the AElf blockchain relies upon for secure multi-chain operations.

## Likelihood Explanation

**Attacker Requirements**:
- Any address can call the function - it has no authorization checks
- Only requires ability to send a transaction (standard capability)
- Function is publicly accessible as a standard RPC method [7](#0-6) 

**Attack Complexity**: 
- Extremely Low - single function call with one parameter
- Precondition: A token with the target symbol must exist in the local TokenContract (very common on sidechains where tokens are cross-chain transferred)

**Feasibility**:
- Standard gas costs only
- No timing requirements
- Easily reproducible
- Difficult to prevent or detect before execution

The probability is **HIGH** - the attack is trivial to execute and economically rational for griefing, front-running, or exploiting protocol assumptions.

## Recommendation

The `CrossChainCreate()` function must be redesigned to match the security model of `CrossChainCreateToken()`:

1. **Update the input message** to include cross-chain verification parameters:
```protobuf
message CrossChainCreateInput {
    string symbol = 1;
    int32 from_chain_id = 2;
    int64 parent_chain_height = 3;
    bytes transaction_bytes = 4;
    aelf.MerklePath merkle_path = 5;
}
```

2. **Implement proper verification** in the function:
   - Validate the source chain's NFT contract address is registered
   - Parse the original transaction from transaction_bytes
   - Verify the transaction using CrossChainVerify() with the merkle path
   - Only create the protocol after cryptographic verification succeeds

3. **Add authorization checks** if the function should only be callable by specific addresses

4. **Consider adding chain ID validation** to ensure it's only called on appropriate chains

The implementation should mirror the security model in TokenContract_Actions.cs CrossChainCreateToken() method.

## Proof of Concept

```csharp
// On a sidechain where token "TEST-1" exists in TokenContract:

// Attacker calls CrossChainCreate
var result = await NFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
{
    Symbol = "TEST-1"  // Any token that exists in local TokenContract
});

// NFT protocol is created WITHOUT:
// - Authorization check
// - Merkle proof verification  
// - Chain ID validation
// - Any cross-chain verification whatsoever

// Verify protocol was created
var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue
{
    Value = "TEST-1"
});

// Protocol exists - attack succeeded
Assert.NotNull(protocolInfo);
```

## Notes

The NFT contract's reference state shows it has no reference to the CrossChain contract: [8](#0-7) 

This indicates the contract was never designed to perform cross-chain verification, despite the function's name implying such functionality. This is a fundamental design flaw that must be addressed to maintain the integrity of AElf's cross-chain NFT infrastructure.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-17)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-129)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;

        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = input.Symbol,
            Creator = nftProtocolInfo.Creator,
            IsBurnable = nftProtocolInfo.IsBurnable,
            IssueChainId = nftProtocolInfo.IssueChainId,
            ProtocolName = nftProtocolInfo.ProtocolName,
            TotalSupply = nftProtocolInfo.TotalSupply,
            Metadata = nftProtocolInfo.Metadata,
            BaseUri = nftProtocolInfo.BaseUri,
            IsTokenIdReuse = isTokenIdReuse,
            NftType = nftProtocolInfo.NftType
        });
        return new Empty();
    }
```

**File:** protobuf/nft_contract.proto (L25-26)
```text
    rpc CrossChainCreate (CrossChainCreateInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/nft_contract.proto (L132-134)
```text
message CrossChainCreateInput {
    string symbol = 1;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-500)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
```

**File:** protobuf/token_contract.proto (L571-580)
```text
message CrossChainCreateTokenInput {
    // The chain id of the chain on which the token was created.
    int32 from_chain_id = 1;
    // The height of the transaction that created the token.
    int64 parent_chain_height = 2;
    // The transaction that created the token.
    bytes transaction_bytes = 3;
    // The merkle path created from the transaction that created the transaction.
    aelf.MerklePath merkle_path = 4;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractReferenceState.cs (L1-15)
```csharp
using AElf.Contracts.MultiToken;
using AElf.Contracts.Parliament;
using AElf.Standards.ACS6;

namespace AElf.Contracts.NFT;

public partial class NFTContractState
{
    internal TokenContractContainer.TokenContractReferenceState TokenContract { get; set; }

    internal RandomNumberProviderContractContainer.RandomNumberProviderContractReferenceState
        RandomNumberProviderContract { get; set; }

    internal ParliamentContractContainer.ParliamentContractReferenceState ParliamentContract { get; set; }
}
```
