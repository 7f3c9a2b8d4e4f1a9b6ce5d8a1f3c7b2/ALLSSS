# Audit Report

## Title
Permanent Loss of Fungible Tokens When Assembled NFTs Are Burned Directly

## Summary
The NFT contract's `Burn` method allows minters to destroy assembled NFTs without returning the locked fungible tokens to the owner. This creates an irreversible loss of funds as the `AssembledFtsMap` state remains orphaned with no recovery mechanism.

## Finding Description

The NFT contract provides an `Assemble` functionality that allows users to lock fungible tokens (FTs) inside NFTs. When assembling, FTs are transferred from the user to the contract and tracked in the `AssembledFtsMap` state variable. [1](#0-0) 

The assembled FTs mapping is stored in contract state: [2](#0-1) 

The intended disassembly flow retrieves these FTs and returns them to the receiver, then removes the state mapping: [3](#0-2) 

However, the `Burn` method provides an alternative path that only validates burnable status, balance, and minter permissions. It does NOT check whether the NFT has assembled FTs, nor does it clean up the `AssembledFtsMap` entry or return the locked tokens: [4](#0-3) 

When a minter calls `Burn` directly on an assembled NFT:
1. The NFT is destroyed (balance reduced, supply decreased, potentially marked as burned)
2. The `AssembledFtsMap[tokenHash]` entry persists in state
3. The FTs locked in the contract become permanently inaccessible

The `Disassemble` method cannot be used for recovery because it first calls `Burn`, which would fail when the NFT no longer exists (zero balance). [5](#0-4) 

The state variable definition shows these are the only mappings for tracking assembled tokens: [6](#0-5) 

Analysis of the entire codebase confirms `AssembledFtsMap` is only accessed in three locations (Assemble to write, Disassemble to read and delete), with no admin recovery functions.

## Impact Explanation

**Critical Fund Loss**: Fungible tokens become permanently locked in the NFT contract address with no retrieval mechanism. For example, if 100 ELF tokens are assembled into an NFT and the NFT is subsequently burned directly, those 100 ELF tokens remain in the contract forever.

**Irreversible Consequences**:
- The `AssembledFtsMap` entry persists indefinitely but becomes inaccessible since the tokenHash no longer corresponds to any existing NFT
- The `Disassemble` method cannot be invoked because its internal `Burn` call requires the caller to own the NFT (balance check)
- No administrative recovery functions exist in the contract to retrieve orphaned FTs
- The tokens are effectively removed from circulating supply without proper accounting

**Affected Parties**:
- NFT holders who accidentally burn assembled NFTs lose all locked FTs (user error scenario)
- Malicious minters could intentionally lock and destroy value
- The protocol experiences unexpected token supply reduction without burn events for the FTs
- Given minters have elevated privileges and may assemble significant value, potential losses are HIGH

## Likelihood Explanation

**Required Conditions**: The attacker must satisfy:
1. Minter authorization (in the protocol's minter list for the NFT symbol)
2. Ownership of the assembled NFT (sufficient balance)
3. Protocol must have `IsBurnable` set to true

**Attack Complexity**: LOW
- Direct public method invocation with standard parameters
- No complex state setup or multi-step transactions required
- Can occur accidentally through user error or intentionally
- Single transaction execution

**Feasibility**: HIGH
- Minters are trusted but fallible roles that can make mistakes or have compromised private keys
- No safeguards exist in the code to prevent this scenario
- The test suite includes an `AssembleTest` demonstrating the assembly functionality, but lacks corresponding disassembly or burn validation tests: [7](#0-6) 
- The absence of test coverage for this edge case indicates it was not considered during development

**Detection**: The loss would only be discovered when attempting to retrieve the FTs, at which point recovery is mathematically impossible within the contract's logic.

## Recommendation

Modify the `Burn` method to prevent burning assembled NFTs or implement automatic FT return:

**Option 1 - Prevent Burning (Safer)**:
Add a check in the `Burn` method to revert if the NFT has assembled tokens:

```csharp
public override Empty Burn(BurnInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    
    // Add this check
    Assert(State.AssembledFtsMap[tokenHash] == null && State.AssembledNftsMap[tokenHash] == null,
        "Cannot burn assembled NFT directly. Use Disassemble method instead.");
    
    // ... rest of existing burn logic
}
```

**Option 2 - Auto-Return Assembled Tokens**:
Modify `Burn` to automatically return assembled tokens before burning:

```csharp
public override Empty Burn(BurnInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    
    // Return assembled FTs if they exist
    var assembledFts = State.AssembledFtsMap[tokenHash];
    if (assembledFts != null)
    {
        foreach (var pair in assembledFts.Value)
        {
            State.TokenContract.Transfer.Send(new MultiToken.TransferInput
            {
                Symbol = pair.Key,
                Amount = pair.Value,
                To = Context.Sender
            });
        }
        State.AssembledFtsMap.Remove(tokenHash);
    }
    
    // Return assembled NFTs if they exist
    var assembledNfts = State.AssembledNftsMap[tokenHash];
    if (assembledNfts != null)
    {
        foreach (var pair in assembledNfts.Value)
        {
            DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, Context.Sender, pair.Value);
        }
        State.AssembledNftsMap.Remove(tokenHash);
    }
    
    // ... rest of existing burn logic
}
```

**Recommended Approach**: Option 1 is safer as it enforces the intended workflow and prevents accidental losses. Option 2 provides better UX but requires careful testing to ensure token transfers succeed before the NFT is destroyed.

## Proof of Concept

```csharp
[Fact]
public async Task BurnAssembledNFT_PermanentlyLocksTokens()
{
    // Setup: Create an NFT protocol and add minter
    var symbol = await CreateTest();
    await AddMinterAsync(symbol);
    
    // Mint an NFT
    var tokenHash = (await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        Owner = DefaultAddress
    })).Output;
    
    // Transfer ELF to DefaultAddress and approve NFT contract
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "ELF",
        Amount = 100_00000000,
        To = DefaultAddress
    });
    
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = NFTContractAddress,
        Symbol = "ELF",
        Amount = 100_00000000
    });
    
    // Get initial NFT contract ELF balance
    var initialContractBalance = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = NFTContractAddress, Symbol = "ELF" })).Balance;
    
    // Assemble NFT with 100 ELF
    var assembledTokenHash = (await NFTContractStub.Assemble.SendAsync(new AssembleInput
    {
        Symbol = symbol,
        AssembledFts = new AssembledFts
        {
            Value = { ["ELF"] = 100_00000000 }
        }
    })).Output;
    
    // Verify ELF was transferred to contract
    var contractBalanceAfterAssemble = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = NFTContractAddress, Symbol = "ELF" })).Balance;
    contractBalanceAfterAssemble.ShouldBe(initialContractBalance + 100_00000000);
    
    // VULNERABILITY: Burn the assembled NFT directly
    await NFTContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = symbol,
        TokenId = 2, // Assembled NFT gets tokenId 2
        Amount = 1
    });
    
    // Verify the NFT is burned
    var nftInfo = await NFTContractStub.GetNFTInfo.CallAsync(
        new GetNFTInfoInput { Symbol = symbol, TokenId = 2 });
    nftInfo.Quantity.ShouldBe(0);
    
    // PROOF OF LOSS: ELF remains locked in contract
    var finalContractBalance = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = NFTContractAddress, Symbol = "ELF" })).Balance;
    finalContractBalance.ShouldBe(contractBalanceAfterAssemble); // ELF still locked
    
    // PROOF OF IRREVERSIBILITY: Disassemble cannot be called (NFT no longer exists)
    var disassembleResult = await NFTContractStub.Disassemble.SendWithExceptionAsync(
        new DisassembleInput { Symbol = symbol, TokenId = 2 });
    disassembleResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    disassembleResult.TransactionResult.Error.ShouldContain("No permission"); // Burn fails due to zero balance
}
```

This test demonstrates that burning an assembled NFT leaves the fungible tokens permanently locked in the contract with no recovery mechanism.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L155-162)
```csharp
                State.TokenContract.TransferFrom.Send(new MultiToken.TransferFromInput
                {
                    From = Context.Sender,
                    To = Context.Self,
                    Symbol = symbol,
                    Amount = amount
                });
            }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L178-178)
```csharp
        if (input.AssembledFts.Value.Any()) State.AssembledFtsMap[nftMinted.TokenHash] = input.AssembledFts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L193-198)
```csharp
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L212-224)
```csharp
        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
        if (assembledFts != null)
        {
            var fts = assembledFts;
            foreach (var pair in fts.Value)
                State.TokenContract.Transfer.Send(new MultiToken.TransferInput
                {
                    Symbol = pair.Key,
                    Amount = pair.Value,
                    To = receiver
                });

            State.AssembledFtsMap.Remove(tokenHash);
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L32-33)
```csharp
    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }
```

**File:** test/AElf.Contracts.NFT.Tests/NFTContractTests.cs (L231-261)
```csharp
    public async Task AssembleTest()
    {
        var (symbol, tokenHash) = await MintTest();

        await TokenContractStub.Approve.SendAsync(new MultiToken.ApproveInput
        {
            Spender = NFTContractAddress,
            Symbol = "ELF",
            Amount = long.MaxValue
        });

        await NFTContractStub.Assemble.SendAsync(new AssembleInput
        {
            Symbol = symbol,
            AssembledNfts = new AssembledNfts
            {
                Value = { [tokenHash.ToHex()] = 1 }
            },
            AssembledFts = new AssembledFts
            {
                Value = { ["ELF"] = 100 }
            },
            Metadata = new Metadata
            {
                Value =
                {
                    ["Advanced Property"] = "whatever"
                }
            }
        });
    }
```
