### Title
DoS of ClaimProfits Function via Unbounded ProfitDetail Accumulation

### Summary
The `ClaimProfits` function performs full iteration over all ProfitDetails for filtering before applying the 10-detail processing limit, creating a gas exhaustion vulnerability. Users can accumulate unlimited ProfitDetails through repeated voting in the Election contract (each vote creates a unique ProfitDetail), causing ClaimProfits to fail due to exceeding gas limits when attempting to claim welfare profits.

### Finding Description

The vulnerability exists in the `ClaimProfits` function where filtering operations iterate through the entire `profitDetails.Details` collection before limiting processing to 10 details: [1](#0-0) 

These LINQ `Where().ToList()` operations create two complete passes over all ProfitDetails, regardless of collection size. The limit is only applied afterwards: [2](#0-1) 

Additional gas-intensive operations compound the issue. The `Remove()` operation on line 803 is O(n) per removal: [3](#0-2) 

And the entire filtered collection is written back to state: [4](#0-3) 

The `AddBeneficiary` function allows unlimited ProfitDetails to be added for the same beneficiary with different `ProfitDetailId` values, with no duplicate checking or quantity limits: [5](#0-4) 

The cleanup mechanism only removes expired details under specific conditions and does not prevent accumulation: [6](#0-5) 

The primary attack vector is through the Election contract's voting mechanism. Each vote creates a new ProfitDetail with the voteId as the ProfitDetailId: [7](#0-6) 

The Election contract's `Vote` function has no per-user vote count limit, only requiring valid candidate and lock time: [8](#0-7) 

The constant limiting processing is set to only 10 details: [9](#0-8) 

### Impact Explanation

**Operational DoS Impact**: Beneficiaries become unable to claim their legitimate profit distributions when ProfitDetail count exceeds gas limits. If a user accumulates 1,000+ ProfitDetails through voting, the filtering operations alone (two O(n) passes plus O(m*n) removals where m≤10) will exceed transaction gas limits, causing all ClaimProfits attempts to fail.

**Affected Users**: 
- Election welfare scheme participants who vote frequently
- Any beneficiary whose scheme manager maliciously adds excessive details
- Token stakers in schemes integrated with Election voting

**Severity Justification (High)**:
- Complete denial of profit claiming functionality for affected users
- No remediation available to users (cannot remove their own ProfitDetails)
- Profits remain locked until old votes expire and automatic cleanup occurs
- Attack is economically rational for griefers (only requires token locking, not loss)

### Likelihood Explanation

**Reachable Entry Point**: The Election contract's `Vote` function is a public method callable by any user with tokens to lock.

**Attacker Capabilities**: 
- Self-DoS: A user can unintentionally DoS themselves by voting hundreds of times over time
- Targeted Attack: An attacker with sufficient tokens can spam votes to accumulate details
- Scheme Manager Attack: A malicious scheme manager can directly call AddBeneficiary repeatedly

**Execution Practicality**: 
- No special permissions required beyond having lockable tokens
- Each vote is a normal, legitimate operation
- No limit exists on votes per user
- Attack scales linearly with token balance (more tokens = more votes)

**Economic Rationality**: 
- Voting locks tokens but they are recoverable after lock period
- Griefing cost is temporary token illiquidity, not permanent loss
- For self-DoS scenario, users may accumulate details naturally through normal voting behavior

**Feasibility**: Highly likely. Users participating actively in governance could easily accumulate 100+ votes over months/years, triggering this issue without malicious intent.

### Recommendation

**Immediate Fix**: Apply the detail count limit BEFORE filtering operations:

```csharp
public override Empty ClaimProfits(ClaimProfitsInput input)
{
    var scheme = State.SchemeInfos[input.SchemeId];
    if (scheme == null) throw new AssertionException("Scheme not found.");
    var beneficiary = input.Beneficiary ?? Context.Sender;
    var profitDetails = State.ProfitDetailsMap[input.SchemeId][beneficiary];
    if (profitDetails == null) throw new AssertionException("Profit details not found.");

    // Take only the first N details for processing to prevent gas exhaustion
    var detailsToProcess = profitDetails.Details
        .Take(ProfitContractConstants.ProfitReceivingLimitForEachTime * 2) // Buffer for filtering
        .ToList();
    
    var availableDetails = detailsToProcess.Where(d =>
        d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
    var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();
    
    // ... rest of function
}
```

**Long-term Fix**: Implement a hard cap on ProfitDetails per beneficiary in `AddBeneficiary`:

```csharp
Assert(currentProfitDetails.Details.Count < MAX_PROFIT_DETAILS_PER_BENEFICIARY, 
    "Maximum profit details limit reached.");
```

**Additional Safeguards**:
1. Add batched cleanup mechanism to remove old expired details proactively
2. Implement pagination for ClaimProfits to allow multiple calls to process large detail sets
3. Add monitoring/events when detail count exceeds warning thresholds

**Test Cases**:
- Verify ClaimProfits succeeds with 100+ ProfitDetails
- Test gas consumption with 1000+ details
- Validate that detail count cap is enforced in AddBeneficiary
- Test that pagination/chunking works correctly across multiple ClaimProfits calls

### Proof of Concept

**Initial State**:
- Election welfare scheme exists with scheme ID `WELFARE_SCHEME_ID`
- Attacker has 1000 ELF tokens available for locking
- Valid candidate exists for voting

**Attack Sequence**:

1. **Accumulate ProfitDetails** (repeat 500 times):
   ```
   Vote(candidate_pubkey, amount: 2 ELF, lock_duration: 90 days)
   → Creates new voteId
   → AddBeneficiary called with ProfitDetailId = voteId
   → Attacker now has 1 more ProfitDetail
   ```

2. **Attempt to Claim Profits**:
   ```
   ClaimProfits(schemeId: WELFARE_SCHEME_ID, beneficiary: attacker_address)
   → Line 765-767: Filters through all 500 details (1000+ iterations)
   → Line 801-804: Up to 10 * 500 = 5000 list operations
   → Line 806: Writes 490+ details back to state
   → Transaction fails: "Execution exceeded gas limit"
   ```

**Expected Result**: ClaimProfits processes up to 10 details and succeeds within gas limits.

**Actual Result**: ClaimProfits fails with gas exhaustion due to filtering all 500 details before applying the 10-detail limit.

**Success Condition**: Transaction reverts with gas limit error, preventing the attacker from claiming any welfare profits despite having legitimate entitlement to them.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L204-207)
```csharp
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-767)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
        var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L772-773)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L801-804)
```csharp
        foreach (var profitDetail in profitDetailsToRemove)
        {
            availableDetails.Remove(profitDetail);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L806-806)
```csharp
        State.ProfitDetailsMap[input.SchemeId][beneficiary] = new ProfitDetails { Details = { availableDetails } };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-382)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L421-443)
```csharp
    public override Hash Vote(VoteMinerInput input)
    {
        // Check candidate information map instead of candidates. 
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);

        var electorPubkey = Context.RecoverPublicKey();

        var lockSeconds = (input.EndTimestamp - Context.CurrentBlockTime).Seconds;
        AssertValidLockSeconds(lockSeconds);

        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;

        UpdateElectorInformation(electorPubkey, input.Amount, voteId);

        var candidateVotesAmount = UpdateCandidateInformation(input.CandidatePubkey, input.Amount, voteId);

        LockTokensOfVoter(input.Amount, voteId);
        TransferTokensToVoter(input.Amount);
        CallVoteContractVote(input.Amount, input.CandidatePubkey, voteId);
        AddBeneficiaryToVoter(GetVotesWeight(input.Amount, lockSeconds), lockSeconds, voteId);
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L5-5)
```csharp
    public const int ProfitReceivingLimitForEachTime = 10;
```
