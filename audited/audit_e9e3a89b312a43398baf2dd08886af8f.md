### Title
Unvalidated TuneOrderInformation Allows Injection of Negative Order Values Leading to Consensus Disruption

### Summary
A malicious miner can inject negative `FinalOrderOfNextRound` values through the `TuneOrderInformation` field in `UpdateValueInput` without any validation. These negative values propagate to the next round generation, creating miners with negative `Order` values and past `ExpectedMiningTime` timestamps, breaking critical consensus invariants and disrupting the mining schedule.

### Finding Description

**Root Cause:**

The `ProcessUpdateValue` function directly applies `TuneOrderInformation` values to `FinalOrderOfNextRound` without any bounds checking: [1](#0-0) 

The protobuf definition allows `int32` values for `tune_order_information`, which includes negative numbers: [2](#0-1) 

**Why Validation Fails:**

The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`, but completely ignores `TuneOrderInformation`: [3](#0-2) 

The `NextRoundMiningOrderValidationProvider` checks `FinalOrderOfNextRound > 0` in the provided round, but for a newly generated next round, all `FinalOrderOfNextRound` values are 0 (unset), so the validation passes trivially (0 == 0): [4](#0-3) 

**Exploitation Path:**

1. When generating the next round, miners are ordered by their `FinalOrderOfNextRound` values (negative values sort first): [5](#0-4) 

2. The negative order is directly assigned as the miner's `Order` in the next round: [6](#0-5) 

3. This creates an `ExpectedMiningTime` in the **past** (negative millisecond offset from current time), breaking time slot calculations.

4. The `CheckRoundTimeSlots` validation calculates mining intervals between consecutive miners but doesn't fail for negative orders because the time difference calculation remains positive (though doubled): [7](#0-6) 

### Impact Explanation

**Consensus Integrity Violation:**
- Breaks the critical invariant that miner `Order` values must be in the range `[1, minersCount]`
- Creates miners with past `ExpectedMiningTime` timestamps, corrupting the time slot schedule
- Disrupts the deterministic mining order that consensus relies upon

**Operational Impact:**
- Miners with negative orders have already-passed time slots, causing timing conflicts
- Time slot validation logic may behave unexpectedly with past timestamps
- The corrupted round persists and affects subsequent round transitions
- Could prevent proper round advancement if time slot validations fail

**Affected Parties:**
- All network participants experience consensus disruption
- Honest miners may miss their time slots or produce invalid blocks
- Block production schedule becomes unpredictable

**Severity Justification:**
Medium severity because while it doesn't directly steal funds, it breaks critical consensus invariants and can cause operational failures in the mining schedule, though the network can potentially recover in subsequent rounds when honest miners regain control.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires being an active miner in the current round
- Must produce an `UpdateValue` block during their time slot
- Can craft custom `UpdateValueInput` with arbitrary `TuneOrderInformation` values

**Attack Complexity:**
- Low complexity: Simply construct `UpdateValueInput` with `TuneOrderInformation` containing negative values
- Can craft matching block header consensus data to pass `ValidateConsensusAfterExecution`
- No special cryptographic knowledge or coordination required

**Feasibility:**
- Highly feasible: The `UpdateValue` method is a public entry point that all miners use: [8](#0-7) 

- No additional permissions beyond being in the current miner list are required
- The attack can be executed in a single block

**Economic Rationality:**
- Attacker must be a miner (already has stake/investment in the network)
- Attack disrupts consensus, potentially harming the attacker's own interests
- However, could be used strategically to disrupt competitors' mining or during contentious governance situations
- Cost is limited to normal block production costs

### Recommendation

**Immediate Fix:**
Add validation in `ProcessUpdateValue` to ensure all `TuneOrderInformation` values are within valid bounds:

```csharp
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    Assert(tuneOrder.Value > 0 && tuneOrder.Value <= minersCount, 
        $"Invalid tune order value: {tuneOrder.Value}. Must be in range [1, {minersCount}]");
    Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key),
        $"Cannot tune order for non-existent miner: {tuneOrder.Key}");
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}
```

**Additional Safeguards:**
1. Add validation in `UpdateValueValidationProvider` to pre-emptively check `TuneOrderInformation` bounds before execution
2. Enhance `NextRoundMiningOrderValidationProvider` to also validate the `Order` field (not just `FinalOrderOfNextRound`) in the provided round
3. Add a check in `GenerateNextRoundInformation` to assert all assigned `Order` values are positive

**Test Cases:**
1. Test that `UpdateValue` rejects `TuneOrderInformation` with negative values
2. Test that `UpdateValue` rejects `TuneOrderInformation` with values > `minersCount`
3. Test that `UpdateValue` rejects `TuneOrderInformation` for non-existent miners
4. Verify round generation fails gracefully if invalid `FinalOrderOfNextRound` values are detected

### Proof of Concept

**Initial State:**
- Current round has 3 miners: MinerA, MinerB, MinerC
- MinerA and MinerB have already mined (have `OutValue` set)
- Current round is at block height N

**Attack Steps:**

1. **MinerC produces an UpdateValue block** with crafted input:
   ```
   UpdateValueInput {
     OutValue: <valid_hash>
     Signature: <valid_signature>
     SupposedOrderOfNextRound: 3
     TuneOrderInformation: {
       "MinerA": -1,
       "MinerB": -5
     }
     ... other valid fields ...
   }
   ```

2. **Validation passes** because:
   - `UpdateValueValidationProvider` doesn't check `TuneOrderInformation`
   - `OutValue` and `Signature` are valid

3. **ProcessUpdateValue executes**:
   - Sets `currentRound.RealTimeMinersInformation["MinerA"].FinalOrderOfNextRound = -1`
   - Sets `currentRound.RealTimeMinersInformation["MinerB"].FinalOrderOfNextRound = -5`
   - Current round state is now corrupted

4. **NextRound is triggered** at block height N+1:
   - `GenerateNextRoundInformation` orders miners by `FinalOrderOfNextRound`: [-5, -1, 3]
   - Creates next round with:
     - MinerB: Order = -5, ExpectedMiningTime = currentTime - 5*miningInterval (past)
     - MinerA: Order = -1, ExpectedMiningTime = currentTime - 1*miningInterval (past)
     - MinerC: Order = 1, ExpectedMiningTime = currentTime + 1*miningInterval (future)

5. **NextRound validation passes** because:
   - All `FinalOrderOfNextRound` in new round are 0
   - Validation checks: 0 distinct values with FinalOrderOfNextRound > 0 == 0 miners with OutValue != null
   - Time slot checks don't fail despite negative orders

**Expected Result:**
The attack should be blocked with validation error.

**Actual Result:**
Next round is created with miners having negative `Order` values and past `ExpectedMiningTime`, breaking consensus invariants and causing operational disruption.

**Success Condition:**
After the attack, querying the next round's miner information shows miners with Order < 1, violating the invariant that Order âˆˆ [1, minersCount].

### Notes

The vulnerability stems from a fundamental gap in input validation where `TuneOrderInformation` is treated as trusted data despite being user-controlled. The existing `NextRoundMiningOrderValidationProvider` validates the wrong round (checks `FinalOrderOfNextRound` in the generated next round instead of the current round where values are actually set), making it ineffective against this attack vector.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-28)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-33)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L35-47)
```csharp
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-100)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
```
