### Title
Governance Downgrade Attack via Insufficient Organization Validation in ChangeSideChainRentalController

### Summary
The `ChangeSideChainRentalController()` function only validates that a new controller organization exists but does not verify its security properties (member count, approval thresholds, organization type). An attacker can leverage social engineering or a compromised governance member to change the controller from a secure 2-of-2 multisig (parliament + side chain creator) to a single-member association they control, gaining permanent unilateral authority over side chain rental parameters.

### Finding Description

**Location**: [1](#0-0) 

**Root Cause**: The validation function `CheckOrganizationExist()` only verifies organizational existence without checking security properties: [2](#0-1) 

This calls `ValidateOrganizationExist` on the governance contract, which merely checks if the organization address exists in state: [3](#0-2) 

The authorization check `AssertControllerForSideChainRental()` only validates that the sender is the current controller: [4](#0-3) 

**Why Protections Fail**: The default side chain rental controller is initialized as a secure 2-of-2 Association requiring both parliament and side chain creator approval: [5](#0-4) 

However, the system allows changing this to ANY valid organization without validating that the new controller maintains adequate security properties (minimum member count, approval thresholds, governance structure).

**Execution Path**:
1. Attacker creates a single-member Association organization they control
2. Through social engineering or compromising one governance member, attacker gets the current controller to approve a proposal calling `ChangeSideChainRentalController` with the malicious organization
3. The validation only checks organizational existence, not security properties
4. Controller is permanently changed to attacker-controlled single-member organization
5. Attacker gains unilateral control over `UpdateRental` and `UpdateRentedResources`: [6](#0-5) 

### Impact Explanation

**Governance Impact**: The attacker permanently downgrades decentralized governance (2-of-2 multisig) to centralized control (1-of-1 single-sig). Once changed, there is no recovery mechanism - the attacker can prevent any future controller changes.

**Economic Impact**: The attacker gains unilateral authority to:
- Manipulate rental prices (set to 0 to avoid fees or extreme values for economic exploitation)
- Alter rented resource amounts affecting side chain economics
- DoS side chain operations through prohibitive pricing

**Affected Parties**: All side chain users and the parent chain ecosystem relying on proper rental fee collection and resource management.

**Severity Justification**: HIGH - While the attack requires obtaining current controller approval, the weak validation enables a permanent governance takeover through realistic social engineering vectors, and the impact is irreversible control loss over critical economic parameters.

### Likelihood Explanation

**Reachable Entry Point**: `ChangeSideChainRentalController` is a public method callable through governance proposals.

**Feasible Preconditions**: Attack requires current controller (parliament + side chain creator) approval. This is achievable through:
- Social engineering: Governance members may not understand they're approving permanent control loss
- Compromised member: Only one of two members needs to be compromised or coerced
- Governance process mistake: Legitimate controller change proposal could be maliciously crafted

**Execution Practicality**: The test suite explicitly demonstrates this attack vector: [7](#0-6) 

The test shows creating a single-member organization (lines 230-249), changing the controller to it (lines 260-261), and the single member then having unilateral control (lines 262-280).

**Detection Constraints**: The controller change appears as a legitimate governance action, making detection difficult until the attacker exercises unilateral control.

**Probability**: MEDIUM-HIGH - Social engineering of blockchain governance is a documented attack vector. The technical validation weakness combined with realistic social attack vectors creates a practical exploitation path.

### Recommendation

**Code-Level Mitigation**:

Add security property validation in `ChangeSideChainRentalController()`:

```csharp
public override Empty ChangeSideChainRentalController(AuthorityInfo input)
{
    AssertControllerForSideChainRental();
    Assert(CheckOrganizationExist(input), "new controller does not exist");
    
    // Add validation for organization security properties
    Assert(ValidateOrganizationSecurityProperties(input), 
        "new controller does not meet minimum security requirements");
    
    State.SideChainRentalController.Value = input;
    return new Empty();
}

private bool ValidateOrganizationSecurityProperties(AuthorityInfo authorityInfo)
{
    // Verify it's an Association or Parliament (not arbitrary organization)
    Assert(authorityInfo.ContractAddress == State.AssociationContract.Value || 
           authorityInfo.ContractAddress == State.ParliamentContract.Value,
           "Controller must be Association or Parliament organization");
    
    if (authorityInfo.ContractAddress == State.AssociationContract.Value)
    {
        var organization = Context.Call<Organization>(
            authorityInfo.ContractAddress,
            nameof(AssociationContractContainer.AssociationContractReferenceState.GetOrganization),
            authorityInfo.OwnerAddress);
        
        // Require minimum 2 members
        Assert(organization.OrganizationMemberList.OrganizationMembers.Count >= 2,
            "Controller must have at least 2 members");
        
        // Require approval threshold >= 2
        Assert(organization.ProposalReleaseThreshold.MinimalApprovalThreshold >= 2,
            "Controller must require at least 2 approvals");
    }
    
    return true;
}
```

**Invariant Checks**:
- Minimum 2 organization members
- Minimum approval threshold of 2
- Controller must be Association or Parliament type
- Prevent downgrade from current security level

**Test Cases**:
- Test rejecting single-member controller change
- Test rejecting controller with insufficient approval threshold
- Test rejecting non-governance contract types
- Test successful change only with adequate security properties

Apply the same validation to all controller change functions: `ChangeSymbolsToPayTXSizeFeeController`, `ChangeUserFeeController`, `ChangeDeveloperController`, `ChangeCrossChainTokenContractRegistrationController`.

### Proof of Concept

**Initial State**:
- Side chain rental controller initialized as 2-of-2 Association (parliament + side chain creator)
- Test environment from existing test suite

**Attack Steps**:

1. **Attacker creates malicious single-member organization**:
```
CreateOrganizationInput maliciousOrg = {
    OrganizationMembers: [AttackerAddress],
    MinimalApprovalThreshold: 1,
    MinimalVoteThreshold: 1
}
maliciousOrgAddress = AssociationContract.CreateOrganization(maliciousOrg)
```

2. **Attacker crafts proposal through current controller** (via social engineering):
```
CreateProposalInput proposal = {
    ToAddress: TokenContract,
    MethodName: "ChangeSideChainRentalController",
    Params: AuthorityInfo {
        ContractAddress: AssociationContract,
        OwnerAddress: maliciousOrgAddress
    },
    OrganizationAddress: currentControllerAddress
}
```

3. **Proposal gets approved** (due to social engineering or compromised member) and released

4. **Attacker now has unilateral control**:
```
// Attacker can now call UpdateRental without any other approval
UpdateRentalInput evilRental = {
    Rental: { "CPU": 0, "RAM": 0, "DISK": 0, "NET": 0 }  // Set to 0 to avoid fees
}
TokenContract.UpdateRental(evilRental)  // Success - only attacker approval needed
```

**Expected Result**: Transaction should be rejected due to insufficient organization security properties.

**Actual Result**: Transaction succeeds, controller is changed to single-member organization, attacker gains permanent unilateral control over rental parameters.

**Success Condition**: The test from the existing suite demonstrates this exact attack pattern succeeds: [7](#0-6)

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L53-59)
```csharp
    public override Empty ChangeSideChainRentalController(AuthorityInfo input)
    {
        AssertControllerForSideChainRental();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.SideChainRentalController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L244-269)
```csharp
    private Association.CreateOrganizationBySystemContractInput GetControllerCreateInputForSideChainRental(
        Address sideChainCreator, Address parliamentAddress)
    {
        var proposers = new List<Address> { parliamentAddress, sideChainCreator };
        return new Association.CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new Association.CreateOrganizationInput
            {
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { proposers }
                },
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = proposers.Count,
                    MinimalVoteThreshold = proposers.Count,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { proposers }
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L407-413)
```csharp
    private void AssertControllerForSideChainRental()
    {
        Assert(State.SideChainRentalController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");
        // ReSharper disable once PossibleNullReferenceException
        Assert(State.SideChainRentalController.Value.OwnerAddress == Context.Sender, "no permission");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1099-1127)
```csharp
    public override Empty UpdateRental(UpdateRentalInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.Rental)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.Rental[pair.Key] = pair.Value;
        }

        return new Empty();
    }

    public override Empty UpdateRentedResources(UpdateRentedResourcesInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.ResourceAmount)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.ResourceAmount[pair.Key] = pair.Value;
        }

        return new Empty();
    }
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainSideChainRentFeeTest.cs (L227-281)
```csharp
    public async Task ChangeSIdeChainRentalController_Success()
    {
        await InitialTokenContractAsync();
        var member = Accounts[0].Address;
        var proposers = new List<Address> { member };
        var newOrganizationCreationInput = new CreateOrganizationInput
        {
            OrganizationMemberList = new OrganizationMemberList
            {
                OrganizationMembers = { proposers }
            },
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = proposers.Count,
                MinimalVoteThreshold = proposers.Count,
                MaximalRejectionThreshold = 0,
                MaximalAbstentionThreshold = 0
            },
            ProposerWhiteList = new ProposerWhiteList
            {
                Proposers = { proposers }
            }
        };
        var createNewAssociationOrganization =
            await AssociationContractStub.CreateOrganization.SendAsync(newOrganizationCreationInput);
        var newControllerAddress = new Address();
        newControllerAddress.MergeFrom(createNewAssociationOrganization.TransactionResult.ReturnValue);
        var authority = new AuthorityInfo
        {
            ContractAddress = AssociationContractAddress,
            OwnerAddress = newControllerAddress
        };

        await UpdateSideChainRentalDefaultProposalAsync(
            nameof(TokenContractImplContainer.TokenContractImplStub.ChangeSideChainRentalController), authority);
        var updateParam = new UpdateRentedResourcesInput();
        var symbolDic = new Dictionary<string, int> { ["CPU"] = 101 };
        updateParam.ResourceAmount.Add(symbolDic);
        var updateProposal = new CreateProposalInput
        {
            ToAddress = TokenContractAddress,
            ContractMethodName = nameof(TokenContractImplContainer.TokenContractImplStub.UpdateRentedResources),
            Params = updateParam.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = newControllerAddress
        };
        var updateProposalRet = (await AssociationContractStub.CreateProposal.SendAsync(updateProposal))
            .TransactionResult;
        var updateProposalId = new Hash();
        updateProposalId.MergeFrom(updateProposalRet.ReturnValue);
        await AssociationContractStub.Approve.SendAsync(updateProposalId);
        await AssociationContractStub.Release.SendAsync(updateProposalId);
        var resourceUsage = await TokenContractStub.GetResourceUsage.CallAsync(new Empty());
        resourceUsage.Value["CPU"].ShouldBe(101);
    }
```
