# Audit Report

## Title
Missing Order Uniqueness Validation in NextTerm Allows Consensus Disruption via Duplicate Time Slot Assignment

## Summary
The NextTerm consensus behavior lacks validation to ensure unique Order values in RealTimeMinersInformation, allowing a malicious miner to craft consensus data where multiple miners claim the same order position. This breaks time slot calculations and causes consensus integrity failures, as critical methods assume Order uniqueness for determining mining intervals and block production sequence.

## Finding Description

The AEDPoS consensus system relies on unique Order values (1, 2, 3, ..., N) to determine each miner's position in the block production sequence and calculate time slots. However, during NextTerm transitions, no validation enforces this uniqueness invariant.

When a miner produces a NextTerm block, the consensus extra data generation creates a new Round through `GenerateFirstRoundOfNextTerm`, which correctly assigns unique Orders. [1](#0-0)  However, the block producer controls the consensus extra data included in their block and can modify it to contain duplicate Order values before broadcasting.

The validation pipeline for NextTerm behavior only includes basic checks and RoundTerminateValidationProvider, which validates round/term number increments but not Order uniqueness. [2](#0-1) 

The RoundTerminateValidationProvider's NextTerm validation only checks term number correctness. [3](#0-2) 

While TimeSlotValidationProvider calls CheckRoundTimeSlots for new rounds, this method only validates that mining intervals are consistent - it does not verify Order uniqueness. [4](#0-3)  An attacker can craft duplicate Orders with appropriately-spaced ExpectedMiningTimes to pass this validation.

Multiple critical methods assume Order uniqueness and break with duplicates:

1. **GetMiningInterval()** queries miners with Order 1 or 2 and accesses array indices, returning incorrect intervals when duplicates exist. [5](#0-4) 

2. **FirstMiner()** returns an arbitrary miner when multiple have Order 1, breaking deterministic miner selection. [6](#0-5) 

3. **BreakContinuousMining()** in round generation uses First() on specific Order values, returning arbitrary miners with duplicates and corrupting the next round's structure. [7](#0-6) 

The NextTermInput.Create() method copies RealTimeMinersInformation directly without validation. [8](#0-7) 

## Impact Explanation

**Critical Consensus Failure:** Once a Round with duplicate Orders is accepted into state, the consensus system's fundamental assumptions break:

- GetMiningInterval() calculates intervals based on arbitrary miner pairs, returning incorrect time slot durations
- FirstMiner() selection becomes non-deterministic in its semantic meaning, even if technically deterministic in iteration
- Subsequent round generation through BreakContinuousMining() uses First() on Order queries, potentially selecting wrong miners for position swaps
- Time slot validation logic breaks because GetMiningInterval() returns corrupted values

**Operational Impact:**
- The blockchain cannot correctly proceed past the corrupted NextTerm round
- All miners are affected as time slot calculations depend on correct Order values  
- Mining interval calculations become meaningless
- Subsequent blocks may be rejected due to incorrect time slot validation
- Recovery requires manual intervention or chain rollback

**Severity Justification:** This is CRITICAL because it:
- Directly breaks the consensus mechanism's core time slot allocation
- Affects the entire network's ability to produce valid blocks
- Can be triggered by a single malicious miner during their NextTerm block slot
- Violates fundamental consensus invariants
- Requires privileged attacker but one that exists in normal operation (elected miners)

## Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be elected as a miner (realistic - miners are elected through public voting mechanisms)
- Attacker must be scheduled to produce the NextTerm block (happens periodically based on term duration configuration)
- Attacker controls their block's consensus extra data before broadcasting (inherent capability of block producers)

**Attack Complexity: Low**
- Simply modify Order fields in RealTimeMinersInformation before block creation
- Set ExpectedMiningTimes with consistent intervals to bypass CheckRoundTimeSlots
- No complex cryptographic operations or race conditions required
- Deterministically executable when attacker's turn arrives

**Feasibility:** HIGH
- Standard operational conditions (being an elected miner)
- Term transitions occur regularly (typically every few days)
- No additional preconditions needed beyond scheduled NextTerm slot
- The validation gap is systematic and always present

**Detection:** Post-exploitation only
- Attack immediately visible as consensus degradation after NextTerm
- However, malicious Round already committed to state by then
- Other miners cannot produce valid blocks until issue resolved

**Probability: Medium-High** if malicious actor becomes miner
- The validation gap is systematic
- Economic incentive exists for competitors to disrupt consensus
- No special conditions needed beyond standard miner election

## Recommendation

Add explicit Order uniqueness validation to the NextTerm validation pipeline:

1. Create a new validation provider `OrderUniquenessValidationProvider` that checks all Order values in RealTimeMinersInformation are unique and sequential (1, 2, 3, ..., N)

2. Add this provider to the NextTerm validation chain in `AEDPoSContract_Validation.cs`:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new OrderUniquenessValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

3. The validator should verify:
   - All Order values are positive integers
   - All Order values are unique
   - Order values form a consecutive sequence from 1 to N where N = miner count
   - No gaps in the sequence

This ensures the Order uniqueness invariant is enforced at validation time, preventing malicious Rounds from entering consensus state.

## Proof of Concept

A proof of concept would require:

1. Set up AElf test environment with multiple miners
2. Elect test account as miner
3. Wait for NextTerm trigger condition
4. Intercept consensus extra data generation
5. Modify Round to set multiple miners to Order = 1 with ExpectedMiningTimes spaced at regular intervals (e.g., 1000ms apart)
6. Submit NextTerm transaction with modified Round
7. Observe validation passes CheckRoundTimeSlots (intervals are consistent)
8. Observe Round committed to state
9. Next block producer calls GetMiningInterval() and receives incorrect interval
10. Observe consensus disruption or subsequent block validation failures

The test would demonstrate that duplicate Orders pass validation and corrupt subsequent consensus operations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L23-38)
```csharp
        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L142-148)
```csharp
    public MinerInRound FirstMiner()
    {
        return RealTimeMinersInformation.Count > 0
            ? RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == 1)
            // Unlikely.
            : new MinerInRound();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-108)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }

        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```
