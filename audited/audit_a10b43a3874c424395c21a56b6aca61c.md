### Title
LIB Height Reset During Term Transition Due to Missing Validation

### Summary
The consensus contract lacks LIB height validation during NextTerm transitions, allowing a malicious miner to reset the contract's `ConfirmedIrreversibleBlockHeight` to an arbitrary lower value. While node-level protections prevent the actual chain LIB from decreasing, the contract state becomes corrupted and inconsistent with the node state, violating the critical invariant that LIB heights must only increase.

### Finding Description

The vulnerability exists in the term transition flow where LIB heights are preserved without validation: [1](#0-0) 

During NextTerm behavior, the validation providers do not include `LibInformationValidationProvider`: [2](#0-1) 

In contrast, UpdateValue behavior correctly includes this validator: [3](#0-2) 

The `LibInformationValidationProvider` checks whether LIB heights decrease, but it is never invoked for NextTerm: [4](#0-3) 

Additionally, the round hash validation in `ValidateConsensusAfterExecution` cannot detect LIB manipulation because `GetCheckableRound` explicitly excludes these fields from the hash: [5](#0-4) 

The `NextTermInput.ToRound()` method preserves attacker-controlled LIB heights: [6](#0-5) 

These values are then stored directly in contract state: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Impact:**
- The contract's `ConfirmedIrreversibleBlockHeight` state can be reset to any lower value chosen by the attacker
- This violates the critical invariant that LIB heights must monotonically increase
- Creates state inconsistency between the consensus contract and the blockchain node

**Operational Impact:**
- Any contracts or operations querying the consensus contract's round information will receive incorrect LIB heights
- The contract state remains corrupted until subsequent UpdateValue operations gradually restore correct values
- During this window, cross-contract queries about irreversibility may return incorrect results

**Mitigation Factor:**
Node-level protection prevents the actual chain LIB from decreasing: [8](#0-7) 

However, this does not excuse the contract-level vulnerability, as contract state corruption itself is a serious issue that violates protocol invariants.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an active miner (passes PreCheck authorization)
- Attacker must be scheduled to produce the NextTerm block
- Given sufficient miners and term duration, this opportunity occurs regularly

**Attack Complexity:**
- Low complexity: Simply craft consensus extra data with modified LIB height values
- No sophisticated techniques required beyond being able to produce a block
- The modified data passes all validations due to the missing validator

**Execution Practicality:**
- Highly practical: The attack requires only modifying the consensus data before mining the NextTerm block
- No timing constraints beyond normal block production schedule
- No economic cost beyond normal block production

**Detection Constraints:**
- Difficult to detect: The manipulated block passes all consensus validations
- No immediate observable impact since node LIB remains protected
- Contract state corruption only visible through direct state queries

### Recommendation

**Immediate Fix:**
Add `LibInformationValidationProvider` to the NextTerm validation flow in `ValidateBeforeExecution`: [2](#0-1) 

Modify to:
```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

**Additional Protection:**
Also add the validator for NextRound behavior, which has the same vulnerability: [9](#0-8) 

**Invariant Check:**
Add explicit assertion in `ProcessNextTerm` to verify LIB heights never decrease: [10](#0-9) 

Add validation:
```csharp
TryToGetCurrentRoundInformation(out var currentRound);
Assert(nextRound.ConfirmedIrreversibleBlockHeight >= currentRound.ConfirmedIrreversibleBlockHeight,
    "LIB height cannot decrease");
```

**Test Cases:**
1. Test that NextTerm with lower LIB height is rejected
2. Test that NextRound with lower LIB height is rejected
3. Test that only equal or higher LIB heights are accepted during transitions

### Proof of Concept

**Initial State:**
- Current term N with `ConfirmedIrreversibleBlockHeight = 10000`
- Malicious miner M is scheduled to produce the NextTerm block for term N+1

**Attack Steps:**

1. Miner M's node calls `GetConsensusExtraData` which generates correct consensus data: [11](#0-10) 

2. The generated data includes `ConfirmedIrreversibleBlockHeight = 10000` copied from state

3. Before mining the block, attacker modifies the consensus data to set `ConfirmedIrreversibleBlockHeight = 1000` (or any value < 10000)

4. Attacker mines the NextTerm block with the modified consensus data

5. Other nodes validate the block via `ValidateConsensusBeforeExecution`, but LibInformationValidationProvider is not invoked for NextTerm

6. Block passes validation and is accepted

7. `ProcessNextTerm` executes, calling `input.ToRound()` which converts the malicious input including the lower LIB height

8. `AddRoundInformation` stores the round with the corrupted LIB height in contract state

**Expected Result:**
- Block should be rejected with "Incorrect lib information" error from LibInformationValidationProvider

**Actual Result:**
- Block is accepted
- Contract state's `ConfirmedIrreversibleBlockHeight` is reset from 10000 to 1000
- Node's actual LIB remains at correct value due to node-level protection
- Contract state is now inconsistent with node state

**Success Condition:**
Query the consensus contract's current round information after the attack - it will show a lower `ConfirmedIrreversibleBlockHeight` than before the NextTerm transition, violating the monotonic increase invariant.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L244-245)
```csharp
        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L199-206)
```csharp
        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockFoundLogEventProcessor.cs (L60-61)
```csharp
            if (chain.LastIrreversibleBlockHeight > irreversibleBlockFound.IrreversibleBlockHeight)
                return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```
