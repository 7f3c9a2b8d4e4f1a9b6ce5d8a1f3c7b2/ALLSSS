### Title
Missing Validation of Tiny Block Minimum Spacing Allows Violation of 50ms Interval Invariant

### Summary
The 50ms minimum interval between tiny blocks (TinyBlockMinimumInterval) is only enforced during consensus command scheduling but not validated when blocks are actually produced. Miners can produce tiny blocks with timestamps spaced less than 50ms apart, violating the tiny block spacing invariant, as long as timestamps remain within the 4-second future tolerance and the miner's allocated time slot.

### Finding Description

The root cause is in the consensus validation flow. The `TinyBlockMinimumInterval` constant is defined as 50ms [1](#0-0)  and used in scheduling via `ArrangeMiningTimeWithOffset` [2](#0-1) , which simply adds the offset to the current block time without any subsequent validation [3](#0-2) .

When a tiny block is produced, the `ActualMiningTime` is set to `Context.CurrentBlockTime` (the block's timestamp) [4](#0-3) . This timestamp is validated only to ensure it's not more than 4 seconds in the future [5](#0-4) [6](#0-5) .

The `TimeSlotValidationProvider` checks only if the latest mining time is within the miner's time slot [7](#0-6) , but does NOT validate minimum spacing between consecutive block timestamps. The consensus behaviour provider only checks the count of tiny blocks, not their timing [8](#0-7) .

### Impact Explanation

**Consensus Integrity Violation**: Miners can produce tiny blocks spaced less than 50ms apart (e.g., 10ms intervals), directly violating the documented tiny block spacing invariant. With the typical 8 tiny blocks per time slot, a malicious miner could compress 400ms of expected spacing into 80ms or less.

**Network Congestion**: Rapid block production can overwhelm network bandwidth and node processing capacity, as blocks propagate faster than the network was designed to handle. This affects all network participants during the malicious miner's time slot.

**Unfair Transaction Processing**: The miner gains unfair advantage by processing transactions faster than intended, potentially front-running or manipulating transaction ordering within their slot.

**Synchronization Issues**: Honest nodes receiving blocks faster than expected may experience synchronization problems, temporary forks, or increased orphan block rates.

The severity is Medium because while it violates a critical invariant and impacts network operations, the miner cannot produce more blocks than allowed or extend beyond their allocated time slot.

### Likelihood Explanation

**Attack Complexity**: Low. A miner simply needs to set block timestamps closer together when producing tiny blocks. No complex state manipulation or cryptographic attacks required.

**Attacker Capabilities**: Any authorized miner in the current round can execute this attack during their time slot. The only requirement is the ability to control block timestamps, which is inherent to block production.

**Feasibility**: High. The attack works as long as:
1. Timestamps remain within 4 seconds of actual system time (ample room for manipulation)
2. Timestamps stay within the miner's allocated time slot
3. Maximum block count is respected

**Detection**: Difficult during execution. Post-hoc analysis could detect unusual timestamp patterns, but real-time prevention is absent.

**Economic Rationality**: Zero additional cost to the attacker while potentially providing competitive advantages in transaction inclusion and MEV extraction.

### Recommendation

Add explicit validation of minimum spacing between consecutive tiny block timestamps in the `TimeSlotValidationProvider.CheckMinerTimeSlot` method:

```csharp
private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
{
    if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
    var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
    if (latestActualMiningTime == null) return true;
    
    // NEW: Validate minimum spacing for tiny blocks
    var newBlockTime = validationContext.ExtraData.Round.RealTimeMinersInformation[validationContext.SenderPubkey]
        .ActualMiningTimes.OrderBy(t => t).LastOrDefault();
    if (newBlockTime != null && validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
    {
        if ((newBlockTime - latestActualMiningTime).Milliseconds() < TinyBlockMinimumInterval)
            return false;
    }
    
    var expectedMiningTime = minerInRound.ExpectedMiningTime;
    var endOfExpectedTimeSlot = expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
    if (latestActualMiningTime < expectedMiningTime)
        return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();
    return latestActualMiningTime < endOfExpectedTimeSlot;
}
```

Add test cases that:
1. Verify tiny blocks with timestamps less than 50ms apart are rejected
2. Confirm blocks spaced exactly 50ms or more are accepted
3. Test edge cases with clock skew near the 4-second tolerance

### Proof of Concept

**Initial State**:
- Miner is authorized in current round with a 4-second time slot
- MaximumBlocksCount = 8 tiny blocks allowed

**Attack Sequence**:
1. Miner produces tiny block #1 at real time T0 with timestamp T0
2. Miner immediately (at real time T0 + 10ms) produces tiny block #2 with timestamp T0 + 10ms (violating 50ms requirement)
3. Miner continues producing blocks at 10ms intervals: T0+20ms, T0+30ms, etc.
4. All 8 tiny blocks completed in 80ms instead of intended 400ms minimum

**Validation Results**:
- Block timestamp validation: ✓ PASS (all timestamps within 4-second tolerance)
- Time slot validation: ✓ PASS (all timestamps within miner's allocated slot)
- Block count validation: ✓ PASS (exactly 8 blocks, within limit)
- **Minimum spacing validation: ✗ ABSENT** (no check exists)

**Expected Result**: Blocks should be rejected for violating 50ms minimum spacing

**Actual Result**: All blocks are accepted, allowing 80ms total production time instead of required 400ms minimum, violating the tiny block spacing invariant

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L22-22)
```csharp
        protected const int TinyBlockMinimumInterval = 50;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L28-30)
```csharp
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeMiningTimeWithOffset(CurrentBlockTime,
                    TinyBlockMinimumInterval);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MiningTimeArrangingService.cs (L12-15)
```csharp
        public static Timestamp ArrangeMiningTimeWithOffset(Timestamp currentBlockTime, int offset)
        {
            return currentBlockTime.AddMilliseconds(offset);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L162-163)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** src/AElf.Kernel.Types/KernelConstants.cs (L19-19)
```csharp
    public static Duration AllowedFutureBlockTimeSpan = new() { Seconds = 4 };
```

**File:** src/AElf.Kernel.Core/Blockchain/Application/IBlockValidationProvider.cs (L133-139)
```csharp
        if (block.Header.Height != AElfConstants.GenesisBlockHeight &&
            block.Header.Time.ToDateTime() - TimestampHelper.GetUtcNow().ToDateTime() >
            KernelConstants.AllowedFutureBlockTimeSpan.ToTimeSpan())
        {
            Logger.LogDebug("Future block received {Block}, {BlockTime}", block, block.Header.Time.ToDateTime());
            return Task.FromResult(false);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-62)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```
