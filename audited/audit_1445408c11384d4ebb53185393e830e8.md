### Title
Inefficient Lazy Initialization in View Function Causes Repeated Expensive Operations Without State Persistence

### Summary
The `GetMethodFeeController()` view function performs expensive lazy initialization (including cross-contract calls) on every query when the controller is not set, because view functions in AElf discard all state changes. This creates unnecessary resource consumption on query nodes as the initialization code executes repeatedly without ever persisting the controller value.

### Finding Description

**Location:** [1](#0-0) 

The `GetMethodFeeController()` function is marked as a view method and calls `RequiredMethodFeeControllerSet()` before returning the controller.

**Root Cause:** [2](#0-1) 

When `State.MethodFeeController.Value` is null, `RequiredMethodFeeControllerSet()` performs:
1. System call to get Parliament contract address
2. Cross-contract call to `GetDefaultOrganizationAddress` 
3. Creates AuthorityInfo object
4. Writes to `State.MethodFeeController.Value`

**Why Protections Fail:** [3](#0-2) 

In AElf's execution model, view functions have their state changes discarded by setting `StateSet` to an empty `TransactionExecutingStateSet`. This means all state writes performed during view execution are never persisted to blockchain state.

**Execution Path:** [4](#0-3) 

When called via RPC as a read-only query through `CallReadOnlyAsync`, the transaction executes but state changes are discarded, causing the initialization to repeat on every subsequent query.

### Impact Explanation

**Resource Consumption:** Each query to `GetMethodFeeController()` before the controller is set executes:
- One system contract lookup call
- One cross-contract call to Parliament's `GetDefaultOrganizationAddress`
- Memory allocations and object creation
- State read/write operations that are subsequently discarded

**Who is Affected:** Query nodes serving RPC requests bear the computational cost of repeated initialization operations.

**Severity Justification:** Low severity because:
1. No funds at risk or protocol integrity compromised
2. RPC endpoints typically implement rate limiting
3. The controller should be set early via state-modifying methods (`SetMethodFee` or `ChangeMethodFeeController`)
4. Impact limited to resource consumption on individual query nodes
5. Same inefficient pattern exists across multiple system contracts [5](#0-4) [6](#0-5) 

### Likelihood Explanation

**Attacker Capabilities:** Attacker needs only the ability to make RPC queries to the node, which requires no special permissions or funds.

**Preconditions:** The vulnerability only manifests when:
1. Contract is deployed but controller has never been set via state-modifying methods
2. No initialization method explicitly sets the controller (TokenHolder has no initialization) [7](#0-6) 

**Feasibility:** While technically exploitable, practical likelihood is low because:
1. The controller gets initialized on first call to `SetMethodFee` or `ChangeMethodFeeController`
2. These methods are typically called early in contract lifecycle for fee configuration
3. RPC rate limiting prevents sustained abuse
4. Query validation prevents view transactions from being packaged into blocks [8](#0-7) 

### Recommendation

**Option 1 - Remove Lazy Initialization from View Function:**
```
public override AuthorityInfo GetMethodFeeController(Empty input)
{
    return State.MethodFeeController.Value;  // Return null if not set, don't initialize
}
```

**Option 2 - Initialize During Contract Deployment:**
Add explicit initialization method that sets MethodFeeController before contract becomes active, ensuring view queries never encounter null state.

**Option 3 - Cache Check Result:**
Add a flag to prevent re-execution of initialization logic in same query context, though this doesn't solve the cross-query inefficiency.

**Test Case:** Verify that repeated calls to `GetMethodFeeController()` as view queries do not repeatedly execute cross-contract calls when controller is unset.

### Proof of Concept

**Initial State:**
- TokenHolder contract deployed
- `State.MethodFeeController.Value` is null (no initialization method called)
- Parliament contract deployed and functional

**Attack Steps:**
1. Attacker repeatedly calls `GetMethodFeeController()` via RPC as read-only query
2. Each call executes `RequiredMethodFeeControllerSet()`
3. System call to `GetContractAddressByName` executes
4. Cross-contract call to `GetDefaultOrganizationAddress` executes
5. State write to `MethodFeeController.Value` occurs
6. View function returns but state changes are discarded
7. Next query repeats steps 2-6 identically

**Expected Behavior:** Lazy initialization should persist after first execution, subsequent queries should be simple state reads.

**Actual Behavior:** Initialization code executes on every query without persisting, consuming node resources unnecessarily.

**Success Condition:** Monitor node resource consumption (CPU, state read operations) during repeated `GetMethodFeeController()` queries before controller is set, confirming repeated execution of initialization logic.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L40-44)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L50-64)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** src/AElf.Runtime.CSharp/Executive.cs (L143-146)
```csharp
            if (!handler.IsView())
                CurrentTransactionContext.Trace.StateSet = GetChanges();
            else
                CurrentTransactionContext.Trace.StateSet = new TransactionExecutingStateSet();
```

**File:** src/AElf.WebApp.Application.Chain/Services/TransactionAppService.cs (L463-474)
```csharp
    private async Task<byte[]> CallReadOnlyAsync(Transaction tx)
    {
        var chainContext = await GetChainContextAsync();

        var trace = await _transactionReadOnlyExecutionService.ExecuteAsync(chainContext, tx,
            DateTime.UtcNow.ToTimestamp());

        if (!string.IsNullOrEmpty(trace.Error))
            throw new Exception(trace.Error);

        return trace.ReturnValue.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L40-64)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }

    #endregion

    #region private methods

    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L54-76)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }

    #endregion

    #region private methods

    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        EnsureParliamentContractAddressSet();

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** src/AElf.EconomicSystem/TokenHolderContractInitializationProvider.cs (L13-16)
```csharp
    public List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        return new List<ContractInitializationMethodCall>();
    }
```

**File:** docs-sphinx/protocol/transactions.md (L104-104)
```markdown
- TransactionMethodValidationProvider. To prevent transaction which call view-only contract method from packaging to new block.
```
