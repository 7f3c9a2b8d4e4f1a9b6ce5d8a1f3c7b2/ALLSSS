### Title
Unvalidated Miner Election Allows Malicious Candidates to Control Consensus via Vote Manipulation

### Summary
The `GetVictories()` method in the Election contract returns candidates purely based on vote count without validating their legitimacy, allowing attackers to register malicious nodes and vote them into the miner set. Once elected during term transitions, these malicious miners control consensus for up to 3 days (4,320 time slots) before the evil miner detection system activates, enabling censorship attacks, chain halts, or double-spend attempts.

### Finding Description

**Code Locations:**
- Term transition: [1](#0-0) 
- Miner list retrieval: [2](#0-1) 
- Victory determination: [3](#0-2) 
- Unvalidated candidate selection: [4](#0-3) 
- Candidate registration: [5](#0-4) 

**Root Cause:**

When `GetConsensusBehaviourToTerminateCurrentRound()` returns `NextTerm`, the system calls `ProcessNextTerm()` which invokes `GenerateFirstRoundOfNextTerm()` [6](#0-5) . This calls `TryToGetVictories()` which directly uses the result from `ElectionContract.GetVictories()` without any validation.

The `GetVictories()` method selects candidates based solely on `ObtainedActiveVotedVotesAmount` [7](#0-6) . The `GetValidCandidates()` helper only checks if candidates have votes greater than zero, with no verification of node legitimacy [8](#0-7) .

Anyone can register as a candidate by calling `AnnounceElection()` with only a 100,000 ELF deposit [9](#0-8) . Vote amounts are increased through the `Vote()` method which locks real tokens but performs no validation on candidate trustworthiness [10](#0-9) .

**Why Existing Protections Fail:**

The system has reactive protections but no proactive validation:
- Evil miner detection only triggers after 4,320 missed time slots (3 days) [11](#0-10) 
- Detection occurs in `TryToDetectEvilMiners()` during round processing [12](#0-11) 
- Banning happens only AFTER malicious behavior is detected [13](#0-12) 
- No checks exist to verify candidates are running actual nodes before election

The new miner list is set directly from `GetVictories()` results during term processing [14](#0-13)  with the miner list update at [15](#0-14) .

### Impact Explanation

**Concrete Harm:**
Attackers who control elected malicious miners can:
1. **Censorship**: Refuse to include specific transactions for 3 days
2. **Chain Halt**: Collectively refuse to produce blocks, causing complete consensus failure
3. **Double-Spend**: With >2/3 control (12+ of 17 miners), manipulate block finality and attempt double-spends
4. **Transaction Ordering**: Front-run or reorder transactions for profit

**Quantified Damage:**
- The 3-day window before detection provides 4,320 time slots of malicious control
- If attackers gain majority control (9+ miners with `SupposedMinersCount=17`), they control consensus completely
- Chain downtime costs compound: halted transactions, user exodus, market cap loss

**Affected Parties:**
- All network users experience transaction censorship or delays
- DApp developers face unreliable infrastructure  
- Token holders suffer from loss of chain security and market confidence
- Legitimate miners are displaced from their rightful positions

**Severity Justification:**
Critical severity due to complete compromise of consensus integrity, the foundational security layer of the blockchain. The 3-day detection window is catastrophically long for a production blockchain.

### Likelihood Explanation

**Attacker Capabilities:**
Attacker must:
1. Hold or acquire sufficient tokens to outvote legitimate miners
2. Register malicious candidate nodes (100K ELF per candidate)
3. Vote for these candidates or coordinate with accomplices to do so

**Feasibility Conditions:**
The attack becomes practical when:
- Voter participation is low, reducing the token threshold needed
- Token distribution is concentrated, enabling a single actor to accumulate voting power
- Early chain state with limited legitimate candidates
- Coordinated attack by multiple colluding parties pooling resources
- Governance apathy where token holders don't actively participate in elections

**Attack Complexity:**
Moderate complexity:
1. Register N malicious candidates via `AnnounceElection()` (public method)
2. Vote for them via `Vote()` (public method)  
3. Wait for term transition when `NextTerm` is called
4. Malicious miners are automatically elected via `GetVictories()`

**Economic Rationality:**
- Cost: 100K ELF deposit per candidate (recoverable) + voting tokens (locked but eventually unlocked)
- For 9 miners (majority): 900K ELF deposit + voting tokens to exceed legitimate candidate votes
- Gain: Control of blockchain enabling censorship, halts, or double-spends worth potentially millions
- The attack is economically rational for competitors, nation-state actors, or short-sellers

**Detection Constraints:**
The attack is difficult to detect until miners fail to produce blocks, and even then, the system requires 3 days to respond. No proactive monitoring exists for candidate legitimacy.

### Recommendation

**Code-Level Mitigation:**

1. **Add Candidate Validation in GetVictories:**
   Modify `GetValidCandidates()` to include reputation checks:
   - Verify minimum historical block production
   - Check candidate is not a fresh identity (minimum age requirement)
   - Validate candidate has demonstrated node operation capability
   
2. **Implement Proactive Node Verification:**
   Add a validation step in `TryToGetVictories()` after calling `GetVictories()`:
   - Ping candidate nodes to verify they're running and responsive
   - Check P2P connectivity and synchronization status
   - Validate public key corresponds to an active peer

3. **Reduce Evil Miner Detection Window:**
   Lower `TolerableMissedTimeSlotsCount` from 4,320 (3 days) to a more reasonable threshold like 720 (12 hours) to limit damage window.

4. **Add Stake Slashing:**
   Burn the 100K ELF deposit of candidates who are marked as evil miners instead of allowing recovery, increasing attack cost.

5. **Implement Candidate Whitelisting or Social Coordination:**
   Add a governance-controlled whitelist of approved candidates or require social vetting before candidates can receive votes.

**Invariant Checks:**
- Assert all candidates in victory list have positive reputation scores
- Verify all elected miners are reachable on the P2P network
- Validate no single entity controls >33% of elected miners (Sybil detection)

**Test Cases:**
- Test where attacker registers multiple malicious candidates and votes them in
- Verify evil miner detection triggers within acceptable timeframe
- Test term transition with mix of legitimate and malicious candidates
- Validate stake slashing occurs for detected evil nodes

### Proof of Concept

**Initial State:**
- Blockchain operational with term number T
- MinersCount = 17
- Current legitimate miners with established voting support
- Attacker has sufficient tokens (e.g., 2M ELF for deposit + 50M for votes)

**Attack Steps:**

1. **Register Malicious Candidates (T0):**
   ```
   For i = 1 to 10:
     Call AnnounceElection(maliciousAdmin[i])
     Lock 100K ELF per candidate
   Total: 1M ELF locked
   ```

2. **Vote for Malicious Candidates (T0 + 1 hour):**
   ```
   For each maliciousCandidate[i]:
     Call Vote(candidate=maliciousCandidate[i], amount=5M ELF, lockTime=90 days)
   Total: 50M ELF locked in votes
   ```

3. **Wait for Term Transition (T0 + term period):**
   ```
   NextTerm is called by current miner when NeedToChangeTerm() returns true
   GenerateFirstRoundOfNextTerm() calls TryToGetVictories()
   GetVictories() returns top 17 candidates by vote amount
   Result: 10 malicious + 7 legitimate miners elected
   ```

4. **Execute Malicious Behavior (T0 + term period + 1 minute):**
   ```
   Malicious miners (10/17 = 59% majority):
     - Refuse to produce blocks when scheduled
     - OR selectively censor specific transactions
     - OR collude to manipulate block ordering
   ```

**Expected vs Actual Result:**

- **Expected**: Only validated, trustworthy miners should be elected
- **Actual**: Any candidate with sufficient votes becomes a miner, regardless of legitimacy
- **Success Condition**: Malicious candidates appear in `State.MinerListMap[newTermNumber]` and receive time slots in the consensus round

**Impact Manifestation:**
Within the first round of the new term, missed blocks appear as malicious miners fail to produce. Chain throughput degrades immediately, but formal detection and replacement only occurs after 4,320 missed slots (3 days).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L41-50)
```csharp
    public override PubkeyList GetVictories(Empty input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        var currentMiners = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(k => k.ToHex()).ToList();
        return new PubkeyList { Value = { GetVictories(currentMiners) } };
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L86-95)
```csharp
    private List<string> GetValidCandidates()
    {
        if (State.Candidates.Value == null) return new List<string>();

        return State.Candidates.Value.Value
            .Where(c => State.CandidateVotes[c.ToHex()] != null &&
                        State.CandidateVotes[c.ToHex()].ObtainedActiveVotedVotesAmount > 0)
            .Select(p => p.ToHex())
            .ToList();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L421-467)
```csharp
    public override Hash Vote(VoteMinerInput input)
    {
        // Check candidate information map instead of candidates. 
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);

        var electorPubkey = Context.RecoverPublicKey();

        var lockSeconds = (input.EndTimestamp - Context.CurrentBlockTime).Seconds;
        AssertValidLockSeconds(lockSeconds);

        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;

        UpdateElectorInformation(electorPubkey, input.Amount, voteId);

        var candidateVotesAmount = UpdateCandidateInformation(input.CandidatePubkey, input.Amount, voteId);

        LockTokensOfVoter(input.Amount, voteId);
        TransferTokensToVoter(input.Amount);
        CallVoteContractVote(input.Amount, input.CandidatePubkey, voteId);
        AddBeneficiaryToVoter(GetVotesWeight(input.Amount, lockSeconds), lockSeconds, voteId);

        var rankingList = State.DataCentersRankingList.Value;
        if (rankingList.DataCenters.ContainsKey(input.CandidatePubkey))
        {
            rankingList.DataCenters[input.CandidatePubkey] =
                rankingList.DataCenters[input.CandidatePubkey].Add(input.Amount);
            State.DataCentersRankingList.Value = rankingList;
        }
        else
        {
            if (rankingList.DataCenters.Count < GetValidationDataCenterCount())
            {
                State.DataCentersRankingList.Value.DataCenters.Add(input.CandidatePubkey,
                    candidateVotesAmount);
                AddBeneficiary(input.CandidatePubkey);
            }
            else
            {
                TryToBecomeAValidationDataCenter(input, candidateVotesAmount, rankingList);
            }
        }

        return voteId;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L83-120)
```csharp
    public override Empty UpdateCandidateInformation(UpdateCandidateInformationInput input)
    {
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) ==
            Context.Sender || Context.Sender == GetEmergencyResponseOrganizationAddress(),
            "Only consensus contract can update candidate information.");

        var candidateInformation = State.CandidateInformationMap[input.Pubkey];
        if (candidateInformation == null) return new Empty();

        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
        }

        candidateInformation.ProducedBlocks = candidateInformation.ProducedBlocks.Add(input.RecentlyProducedBlocks);
        candidateInformation.MissedTimeSlots =
            candidateInformation.MissedTimeSlots.Add(input.RecentlyMissedTimeSlots);
        State.CandidateInformationMap[input.Pubkey] = candidateInformation;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```
