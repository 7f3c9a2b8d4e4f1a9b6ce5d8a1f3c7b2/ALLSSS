# Audit Report

## Title
Unvalidated MinersPreviousInValues Allows Consensus DoS via PreviousInValue Poisoning

## Summary
The AEDPoS consensus contract's secret sharing mechanism unconditionally accepts attacker-supplied `MinersPreviousInValues` without cryptographic or logical validation, allowing malicious miners to poison other miners' `PreviousInValue` fields in on-chain state. This causes victim miners' blocks to fail validation and be rejected, resulting in targeted denial-of-service attacks on consensus participants.

## Finding Description

The vulnerability exists in the interaction between three contract components that creates an exploitable state poisoning attack:

**Root Cause 1: Unconditional Overwrite Without Validation**

The `PerformSecretSharing()` function unconditionally overwrites any miner's `PreviousInValue` with attacker-controlled values from `input.MinersPreviousInValues` without validating correctness. [1](#0-0) 

The function accepts arbitrary hash values for any miner's `PreviousInValue` and directly assigns them to the round state with no verification that these values are correctly reconstructed from secret shares or that they hash to the miners' previous `OutValue`.

**Root Cause 2: Conditional Set Prevents Victim Override**

The `ApplyNormalConsensusData()` function only sets `PreviousInValue` if it is currently empty or null, preventing victims from correcting poisoned values during block generation. [2](#0-1) 

When a victim miner generates their block, they load the poisoned round state from storage. Even though they have the correct `previousInValue` from trigger information, this conditional check prevents overwriting the already-set poisoned value.

**Root Cause 3: Validation Only Checks Sender's Own Value**

The `UpdateValueValidationProvider` validates that the sender's own `PreviousInValue` matches their previous `OutValue`, but does not validate the `MinersPreviousInValues` map being submitted for other miners. [3](#0-2) 

The validation logic only checks `validationContext.SenderPubkey` and ignores all other entries in the `MinersPreviousInValues` dictionary, allowing attackers to submit arbitrary values for victim miners without triggering validation failures.

**Attack Execution:**

1. **Poisoning Phase**: Attacker produces an `UpdateValue` block before victim with malicious `MinersPreviousInValues[VictimPubkey] = WrongHash` where `Hash(WrongHash) != Victim's previous OutValue`

2. **State Corruption**: `ProcessUpdateValue()` calls `PerformSecretSharing()` which unconditionally stores the wrong value on-chain [4](#0-3) 

3. **Victim Block Generation Failure**: When victim loads the round state and calls `GetConsensusExtraDataToPublishOutValue()`, then applies their consensus data, the conditional check prevents overriding the poisoned value [5](#0-4) 

4. **Validation Rejection**: The victim's block undergoes validation where `UpdateValueValidationProvider` is invoked [6](#0-5) 

The validation fails because `Hash(PoisonedValue) != Victim's previous OutValue`, causing block rejection.

**Extended Impact - Propagation to Next Round:**

If the victim fails to produce a block in the current round, `SupplyCurrentRoundInformation()` retrieves the poisoned `PreviousInValue` and uses it to calculate the victim's `InValue` and `Signature` for the next round. [7](#0-6) 

This propagates the attack's impact beyond the current round, corrupting the victim's consensus participation in subsequent rounds.

## Impact Explanation

**Severity: HIGH** - This vulnerability enables targeted denial-of-service attacks against consensus participants with direct protocol impact:

**Consensus Disruption:**
- Any active miner can prevent specific miners from producing valid blocks within the current round
- Multiple miners can be targeted simultaneously via a single malicious `UpdateValue` transaction
- If sufficient miners are targeted, the network cannot reach consensus and block production halts

**Direct Harm to Victims:**
- **Revenue Loss**: Targeted miners lose block rewards and transaction fees for missed blocks
- **Reputation Damage**: Missed time slots increment the victim's `MissedTimeSlots` counter, potentially triggering penalties
- **Extended Disruption**: Via `SupplyCurrentRoundInformation()`, the poisoned value propagates to next round calculations, extending the attack's duration

**Network-Wide Impact:**
- **Availability**: Sustained attacks reduce overall network liveness and transaction processing capacity  
- **Trust**: Observable consensus manipulation undermines blockchain security guarantees
- **Economics**: Reduced block production affects token emission schedules and network economics

The impact is immediate, deterministic, and affects core consensus integrityâ€”the most critical security property of any blockchain system.

## Likelihood Explanation

**Likelihood: HIGH** - The attack is highly feasible with minimal barriers:

**Attacker Prerequisites:**
- Must be an active miner in the current round (achievable through standard staking/election process)
- Requires no special privileges beyond normal miner status
- Does not require compromising cryptographic keys or consensus contracts

**Attack Complexity:**
- **Simple Execution**: Attacker only needs to modify the `MinersPreviousInValues` field in their `UpdateValue` transaction input
- **No Timing Constraints**: Can be executed during any `UpdateValue` block when attacker's mining slot occurs before victim's
- **Deterministic Success**: No probabilistic factors; if attacker mines first, attack succeeds with 100% certainty

**Economic Feasibility:**
- **Minimal Cost**: Only requires normal transaction fees for `UpdateValue` 
- **High Reward**: Can eliminate competition from other miners or extort victims for ransom
- **Low Risk**: Attack is visible on-chain but may not be immediately recognized as malicious

**Detection Difficulty:**
- No built-in monitoring for malicious `MinersPreviousInValues` values
- Requires manual inspection of transaction inputs to detect
- By the time detection occurs, victim blocks are already rejected

The attack requires only standard miner capabilities with no specialized knowledge or resources, making it highly likely to occur in adversarial environments.

## Recommendation

Implement cryptographic validation of `MinersPreviousInValues` entries against the secret sharing reconstruction:

```csharp
private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
    string publicKey)
{
    minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
    foreach (var decryptedPreviousInValue in input.DecryptedPieces)
        round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
            .Add(publicKey, decryptedPreviousInValue.Value);

    // VALIDATION: Verify each MinersPreviousInValues entry matches reconstruction
    var minersCount = round.RealTimeMinersInformation.Count;
    var minimumCount = minersCount.Mul(2).Div(3);
    
    foreach (var previousInValue in input.MinersPreviousInValues)
    {
        var targetMiner = round.RealTimeMinersInformation[previousInValue.Key];
        
        // Skip if insufficient decrypted pieces for validation
        if (targetMiner.DecryptedPieces.Count < minimumCount) continue;
        
        // Reconstruct the InValue from decrypted pieces
        var orders = targetMiner.DecryptedPieces.Select((t, i) =>
            round.RealTimeMinersInformation.Values
                .First(m => m.Pubkey == targetMiner.DecryptedPieces.Keys.ToList()[i]).Order).ToList();
        var sharedParts = targetMiner.DecryptedPieces.Values.ToList().Select(s => s.ToByteArray()).ToList();
        var reconstructedInValue = HashHelper.ComputeFrom(
            SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
        
        // Only accept if provided value matches reconstruction
        if (reconstructedInValue == previousInValue.Value)
        {
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
        }
        // Optionally log or reject if mismatch detected
    }
}
```

**Additional Mitigations:**

1. **Add validation in `UpdateValueValidationProvider`** to cross-check `MinersPreviousInValues` against available `DecryptedPieces`

2. **Emit warning events** when mismatched `MinersPreviousInValues` are submitted to aid detection

3. **Implement rate limiting** on failed block validations to detect ongoing attacks

4. **Document the threat model** for `MinersPreviousInValues` to inform auditors and node operators

## Proof of Concept

```csharp
[Fact]
public async Task PoisonedMinersPreviousInValues_CausesVictimBlockRejection()
{
    // Setup: Initialize consensus with 3 miners
    var (keyPairs, minerPubkeys) = await BootMinerAsync(3);
    var attackerKeyPair = keyPairs[0];
    var victimKeyPair = keyPairs[1];
    var victimPubkey = minerPubkeys[1];
    
    // Round N-1: Victim produces block with valid OutValue
    await ProduceNormalBlock(victimKeyPair);
    var previousRound = await GetCurrentRoundAsync();
    var victimPreviousOutValue = previousRound.RealTimeMinersInformation[victimPubkey].OutValue;
    
    // Round N: Move to next round
    await BootMinerChangeRoundAsync(false);
    
    // Attack: Attacker produces UpdateValue with poisoned MinersPreviousInValues
    var poisonedHash = HashHelper.ComputeFrom("wrong_value");
    Assert.NotEqual(victimPreviousOutValue, HashHelper.ComputeFrom(poisonedHash));
    
    var maliciousUpdateValue = new UpdateValueInput
    {
        // ... normal fields ...
        MinersPreviousInValues = { { victimPubkey, poisonedHash } }
    };
    
    // Attacker submits malicious transaction
    await UpdateValueAsync(attackerKeyPair, maliciousUpdateValue);
    
    // Verify: Victim's PreviousInValue is poisoned in stored state
    var currentRound = await GetCurrentRoundAsync();
    var storedPreviousInValue = currentRound.RealTimeMinersInformation[victimPubkey].PreviousInValue;
    Assert.Equal(poisonedHash, storedPreviousInValue);
    
    // Victim attempts to produce block - will fail validation
    var victimBlockResult = await ProduceNormalBlock(victimKeyPair);
    
    // Assert: Victim's block is rejected due to validation failure
    Assert.False(victimBlockResult.Success);
    Assert.Contains("Incorrect previous in value", victimBlockResult.Message);
    
    // Verify consensus disruption: Victim cannot produce valid blocks
    var victimMinedBlocks = currentRound.RealTimeMinersInformation[victimPubkey].ProducedBlocks;
    Assert.Equal(0, victimMinedBlocks); // Victim produced no blocks this round
}
```

**Notes:**
- The vulnerability exists in production consensus contract code and is actively exploitable
- Secret sharing is enabled by default in AEDPoS for InValue recovery functionality  
- The poisoned state persists until round/term transition clears miner information
- Multiple victims can be targeted simultaneously via a single malicious transaction
- The attack is detectable on-chain but requires manual inspection of transaction inputs

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L14-16)
```csharp
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-80)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L189-199)
```csharp
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```
