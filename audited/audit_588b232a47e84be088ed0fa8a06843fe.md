### Title
Status Oscillation Between Normal and Abnormal Causing Inconsistent Block Production Limits

### Summary
The `GetMaximumBlocksCount()` function can oscillate between returning Normal status (8 blocks) and Abnormal status (reduced blocks) when the round number difference hovers around the boundary condition (libRoundNumber + 2 to + 3). This occurs because `ConfirmedIrreversibleBlockRoundNumber` can update mid-round during `ProcessUpdateValue`, causing different miners in the same round to receive inconsistent maximum block counts based on query timing.

### Finding Description

The vulnerability exists in the status determination logic within `GetMaximumBlocksCount()`. [1](#0-0) 

The status transitions are defined as:
- **Normal**: currentRoundNumber ≤ libRoundNumber + 2 → returns MaximumTinyBlocksCount (8)
- **Abnormal**: libRoundNumber + 2 < currentRoundNumber < libRoundNumber + CB1 → returns reduced count
- **Severe**: currentRoundNumber ≥ libRoundNumber + CB1 → returns 1

The root cause is that `ConfirmedIrreversibleBlockRoundNumber` (libRoundNumber) updates during `ProcessUpdateValue` execution within the same round. [2](#0-1) 

When LIB advances, the round number is set to `currentRound.RoundNumber.Sub(1)`, causing the difference between current round and LIB round to change mid-round.

`GetMaximumBlocksCount()` is called at multiple points: [3](#0-2)  and [4](#0-3) 

This means different miners querying `GetConsensusCommand()` at different block heights within the same round can receive different maximum block production limits if the status transitions from Abnormal to Normal or vice versa mid-round.

### Impact Explanation

The oscillation creates operational instability affecting block production:

1. **Inconsistent Miner Limits**: Within round R, Miner A querying before LIB update receives reduced block limit (e.g., 6), while Miner B querying after LIB update receives full limit (8). Both miners are in the same round but face different constraints.

2. **Unpredictable Behavior**: The blockchain alternates between restricting and unrestricting block production based on boundary conditions, preventing stable convergence to either Normal or recovery mode.

3. **Fairness Issues**: Miners are treated differently based on query timing rather than their actual consensus participation, creating inconsistent enforcement of block production rules.

4. **ConsensusBehaviourProvider Impact**: The maximum blocks count determines tiny block production strategy. [5](#0-4)  Oscillating values cause miners to switch strategies unpredictably.

**Severity**: Medium - operational instability and inconsistent consensus behavior, but no direct fund loss or consensus failure.

### Likelihood Explanation

**Feasibility**: HIGH - occurs naturally without attacker intervention.

**Preconditions**: 
- Blockchain operates with libRoundNumber consistently 2-3 rounds behind currentRoundNumber
- This state occurs during network degradation, recovery periods, or when consensus participation is suboptimal
- LIB advances intermittently, causing the difference to fluctuate

**Execution Path**:
1. Round R with R_LIB = R-3 → Abnormal status
2. ProcessUpdateValue advances R_LIB to R-2 → Normal status  
3. Round R+1 with R_LIB = R-2 → Abnormal status again
4. Pattern repeats as long as LIB advancement rate keeps difference oscillating

**Detectability**: Difficult to detect as the behavior appears as normal status transitions rather than a stuck state. Logs show alternating status without clear indication of problematic oscillation.

**Non-exploitable**: Cannot be triggered maliciously as round progression and LIB advancement are determined by consensus participation and 2/3+ miner agreement.

### Recommendation

**Fix 1 - Add Hysteresis to Status Transitions**:
Implement a damping mechanism to prevent rapid oscillation at boundaries:

```csharp
private int GetMaximumBlocksCount()
{
    // ... existing code ...
    
    // Add hysteresis: require status to be maintained for at least one round
    // before transitioning back to Normal from Abnormal
    if (blockchainMiningStatus == BlockchainMiningStatus.Normal && 
        State.IsPreviousBlockInAbnormalStatus.Value)
    {
        State.IsPreviousBlockInAbnormalStatus.Value = false;
    }
    
    if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
    {
        State.IsPreviousBlockInAbnormalStatus.Value = true;
        // Apply reduction
    }
    
    // Only return to full count if status has been Normal for full round
    // ...
}
```

**Fix 2 - Use Round-Start Snapshot**:
Calculate and cache `GetMaximumBlocksCount()` result at round start, use cached value for entire round:

```csharp
// Cache in round initialization
State.MaximumBlocksCountForCurrentRound.Value = CalculateMaximumBlocksCount();

// Use cached value instead of recalculating
private int GetMaximumBlocksCount()
{
    return State.MaximumBlocksCountForCurrentRound.Value ?? 
           AEDPoSContractConstants.MaximumTinyBlocksCount;
}
```

**Fix 3 - Widen Boundary**:
Change inequality to require difference ≥ 4 for Abnormal status, creating a buffer zone at the boundary.

**Test Cases**:
1. Verify maximum blocks count remains constant within a single round despite LIB updates
2. Test status transitions require sustained condition over multiple rounds before applying restrictions
3. Validate all miners in same round receive identical maximum block counts

### Proof of Concept

**Initial State**:
- Current Round: 100
- LIB Round: 97
- Difference: 3 → Abnormal Status

**Execution Sequence**:

1. **Block 1000 (Round 100, R_LIB=97)**:
   - Miner A calls `GetConsensusCommand()`
   - `GetMaximumBlocksCount()` returns 6 (Abnormal)
   - Miner A limited to 6 tiny blocks

2. **Block 1001 (Round 100, R_LIB=97)**:
   - UpdateValue processes, LIB calculation advances
   - R_LIB updates to 98 (difference now = 2)

3. **Block 1002 (Round 100, R_LIB=98)**:
   - Miner B calls `GetConsensusCommand()`  
   - `GetMaximumBlocksCount()` returns 8 (Normal)
   - Miner B limited to 8 tiny blocks

4. **Block 1003 (Round 101, R_LIB=98)**:
   - Difference = 3 → Back to Abnormal
   - Miner C receives limit of 6

5. **Block 1004 (Round 101, R_LIB=99)**:
   - After LIB update, difference = 2 → Normal
   - Miner D receives limit of 8

**Result**: Oscillation confirmed - miners in rounds 100 and 101 receive inconsistent limits (6 vs 8) based on query timing relative to LIB updates, creating operational instability as the blockchain cannot maintain a stable block production policy.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L123-128)
```csharp
            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L68-68)
```csharp
        var minersCountInTheory = GetMaximumBlocksCount();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L272-281)
```csharp
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L40-46)
```csharp
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-62)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```
