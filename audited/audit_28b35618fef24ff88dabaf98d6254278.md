### Title
LIB Height Validation Bypass Through Pre-Validation State Mutation

### Summary
The `ValidateBeforeExecution` function contains a critical ordering flaw where `RecoverFromUpdateValue` modifies the `baseRound` object before validation occurs. This causes `LibInformationValidationProvider` to compare the modified `baseRound` against `providedRound`, both containing identical values, rendering the check ineffective and allowing malicious miners to submit decreased `ImpliedIrreversibleBlockHeight` values that violate consensus finality guarantees.

### Finding Description

The vulnerability exists in the validation flow within `ValidateBeforeExecution`: [1](#0-0) 

First, `baseRound` is fetched from state containing the trusted, previous `ImpliedIrreversibleBlockHeight` value. [2](#0-1) 

For `UpdateValue` behavior, `RecoverFromUpdateValue` is called, which modifies `baseRound` in-place: [3](#0-2) 

This copies the provided `ImpliedIrreversibleBlockHeight` value into `baseRound`, overwriting the trusted state value. [4](#0-3) 

The `ConsensusValidationContext` is then created with the **modified** `baseRound` and `ExtraData` containing the original provided round: [5](#0-4) 

The `ProvidedRound` property returns `ExtraData.Round`, which is the same object passed to `RecoverFromUpdateValue`. [6](#0-5) 

`LibInformationValidationProvider` is added to validate LIB information. [7](#0-6) 

The validation check compares `baseRound.ImpliedIrreversibleBlockHeight` (now containing the provided value) against `providedRound.ImpliedIrreversibleBlockHeight` (the original provided value). Since these are now identical due to the pre-validation mutation, the check `baseRound > providedRound` will always be false, even when the provided value represents a decrease from the original state.

### Impact Explanation

**Consensus Integrity Violation:**
A malicious miner can submit an `UpdateValue` block with a decreased `ImpliedIrreversibleBlockHeight`, bypassing validation. This value is then persisted to state: [8](#0-7) 

The decreased value directly impacts LIB calculation: [9](#0-8) [10](#0-9) 

The `LastIrreversibleBlockHeightCalculator` uses sorted implied heights from miners to calculate the confirmed LIB. If miners can decrease their implied heights, the calculated `ConfirmedIrreversibleBlockHeight` can be artificially lowered, violating the fundamental invariant that LIB must never decrease.

**Severity: CRITICAL** - This breaks blockchain finality guarantees, potentially enabling:
- Re-organization attacks beyond the expected finality window
- Double-spending attacks on transactions thought to be irreversible
- Cross-chain bridge exploits relying on LIB verification
- Consensus safety violations affecting all network participants

### Likelihood Explanation

**Attacker Capabilities:** Any active miner/block producer in the consensus set can exploit this vulnerability.

**Attack Complexity:** Low - requires only submitting a block with decreased `ImpliedIrreversibleBlockHeight` in the `UpdateValue` consensus data.

**Preconditions:**
- Attacker must be a valid miner in the current round (passes `MiningPermissionValidationProvider`)
- Attacker must produce block during their assigned time slot (passes `TimeSlotValidationProvider`)

**Execution Practicality:** Highly practical - the exploit requires no special conditions beyond normal block production. The validation flaw is deterministic and guaranteed to succeed.

**Detection Difficulty:** The decreased LIB would be recorded on-chain and visible in round state, but may not trigger immediate alarms if monitoring only checks for LIB increases in the normal case.

**Economic Rationality:** High - the attacker gains ability to manipulate finality with minimal cost (normal block production), while maintaining plausible deniability through consensus mechanism.

### Recommendation

**Immediate Fix:** Preserve the original `baseRound` state for validation by cloning before mutation:

```csharp
// In ValidateBeforeExecution, lines 46-60
if (!TryToGetCurrentRoundInformation(out var baseRound))
    return new ValidationResult { Success = false, Message = "Failed to get current round information." };

// Clone for validation BEFORE mutation
var originalBaseRound = baseRound.Clone(); // Add Clone() method to Round

if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
    baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

var validationContext = new ConsensusValidationContext
{
    BaseRound = originalBaseRound, // Use unmodified version for validation
    RecoveredRound = baseRound,     // Add new property for recovered round
    // ... rest of initialization
};
```

**Alternative Fix:** Move validation before mutation:

```csharp
// Validate BEFORE calling RecoverFromUpdateValue
var validationContext = new ConsensusValidationContext
{
    BaseRound = baseRound,  // Original state
    // ... rest
};

var validationResult = service.ValidateInformation(validationContext);
if (!validationResult.Success) return validationResult;

// Only AFTER validation passes, apply the recovery
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**Invariant Enforcement:** Add explicit monotonicity check:
```csharp
// In LibInformationValidationProvider
var originalHeight = baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
var providedHeight = providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;

if (providedHeight != 0 && originalHeight > providedHeight)
{
    validationResult.Message = $"ImpliedIrreversibleBlockHeight cannot decrease from {originalHeight} to {providedHeight}";
    return validationResult;
}
```

**Test Cases:**
1. Test miner submitting decreased `ImpliedIrreversibleBlockHeight` - must reject
2. Test miner submitting same value - should accept
3. Test miner submitting increased value - should accept
4. Test impact on LIB calculation with manipulated values

### Proof of Concept

**Initial State:**
- Current round R in state: `State.Rounds[R].RealTimeMinersInformation[MinerA].ImpliedIrreversibleBlockHeight = 1000`

**Attack Sequence:**

1. **Block N:** MinerA produces valid block with `UpdateValue` setting `ImpliedIrreversibleBlockHeight = 1000`
   - State updated: `State.Rounds[R].RealTimeMinersInformation[MinerA].ImpliedIrreversibleBlockHeight = 1000`

2. **Block N+1 (Malicious):** MinerA produces block with `UpdateValue` containing:
   - `extraData.Round.RealTimeMinersInformation[MinerA].ImpliedIrreversibleBlockHeight = 500` (decreased!)

3. **Validation Flow:**
   - `baseRound` fetched from state: `ImpliedIrreversibleBlockHeight = 1000` (trusted value)
   - `RecoverFromUpdateValue(extraData.Round, MinerA)` called
   - `baseRound.ImpliedIrreversibleBlockHeight` mutated to `500`
   - `LibInformationValidationProvider` executes:
     - Check: `baseRound.ImpliedIrreversibleBlockHeight (500) > providedRound.ImpliedIrreversibleBlockHeight (500)`?
     - Result: `false` → **Validation PASSES** (incorrectly!)

4. **State Update:**
   - `ProcessUpdateValue` stores decreased value: `State.Rounds[R].RealTimeMinersInformation[MinerA].ImpliedIrreversibleBlockHeight = 500`

5. **LIB Calculation Impact:**
   - Next round's `LastIrreversibleBlockHeightCalculator` uses the decreased value `500`
   - Calculated LIB potentially decreases, violating finality

**Expected Result:** Validation should reject block with decreased `ImpliedIrreversibleBlockHeight` (1000 → 500)

**Actual Result:** Validation passes, allowing LIB height manipulation and consensus finality violation

### Notes

The vulnerability stems from conflating two distinct phases: (1) data recovery/normalization and (2) validation. The `RecoverFromUpdateValue` method is designed to restore full round state from simplified header data for **processing**, but it executes **before validation**, contaminating the baseline used for security checks. The `LibInformationValidationProvider` was correctly designed to prevent LIB decreases, but operates on corrupted input due to this ordering flaw.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L14-20)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L22-27)
```csharp
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```
