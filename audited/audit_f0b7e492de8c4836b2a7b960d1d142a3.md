### Title
NFT Alias Symbol Collision Causes Incorrect Balance Reporting

### Summary
The `SetSymbolAlias` function fails to validate whether a regular token with the same symbol already exists before setting an NFT alias, and conversely `CreateToken` doesn't check for existing aliases. Due to `GetActualTokenSymbol` prioritizing direct symbol lookup over alias resolution, NFT holders querying balances via alias receive incorrect balances when a regular token shares the same symbol, breaking the NFT alias functionality.

### Finding Description

The vulnerability exists in the interaction between NFT alias creation and regular token creation in the MultiToken contract: [1](#0-0) 

The `SetSymbolAlias` method only validates that the alias doesn't already exist in `SymbolAliasMap` but never checks if a regular token with that symbol exists in `TokenInfos`: [2](#0-1) 

Similarly, the token creation flow only validates symbol uniqueness against `TokenInfos` and `InsensitiveTokenExisting`, never checking `SymbolAliasMap`: [3](#0-2) 

The `CheckTokenAlias` validation enforces that NFT aliases MUST equal the collection prefix (e.g., for collection "TP-0", the alias MUST be "TP"): [4](#0-3) 

When querying balances, `GetActualTokenSymbol` prioritizes `TokenInfos` lookup over `SymbolAliasMap`, causing it to return the regular token symbol instead of resolving the alias: [5](#0-4) 

This prioritization in `GetBalance` leads to incorrect balance reporting: [6](#0-5) 

### Impact Explanation

**Concrete Harm:**
- NFT holders who set aliases for their NFT items receive incorrect balance information when querying via the alias if a regular token with the same symbol exists
- The alias mechanism becomes unreliable and non-functional, defeating its intended purpose of providing user-friendly symbol names
- Users must resort to using full NFT symbols (e.g., "TP-31175") instead of aliases (e.g., "TP"), eliminating the usability benefit

**Affected Parties:**
- NFT collection owners who set aliases expecting them to work reliably
- NFT holders who attempt to query balances or perform transfers using aliases
- Applications/wallets integrating alias functionality

**Severity Justification:**
Medium severity because:
1. Causes incorrect balance reporting, violating the "Token Supply & Fees" invariant for accurate balance queries
2. Breaks intended functionality of the alias system
3. Does not directly steal funds but creates operational confusion
4. NFTs remain accessible via full symbol, providing a workaround
5. Can be exploited intentionally by creating regular tokens to shadow NFT aliases (griefing attack)

### Likelihood Explanation

**Attacker Capabilities:**
- Creating a regular token requires only possessing a seed NFT (or being in the whitelist)
- Creating NFT collections and setting aliases requires being the collection owner/issuer
- Both operations are available to any user meeting basic requirements

**Attack Complexity:**
Low - two straightforward scenarios:
1. **Scenario A:** Attacker creates regular token "TP" first, then victim creates NFT collection "TP-0" and sets alias "TP" - alias becomes inaccessible
2. **Scenario B:** Victim creates NFT "TP-0" with alias "TP" first, then attacker creates regular token "TP" - alias gets shadowed

**Feasibility:**
- No special permissions required beyond standard token creation requirements
- The `CheckTokenAlias` constraint that enforces alias = collection prefix makes collisions inevitable for popular symbol names
- Attack sequence is executable in normal contract operations

**Detection:**
Difficult to detect proactively as both token creation and alias setting are legitimate operations that succeed independently

**Probability:**
High for accidental collisions with popular prefixes (e.g., common acronyms), moderate for intentional griefing attacks

### Recommendation

**Code-Level Mitigation:**

1. Modify `SetSymbolAlias` to validate that the alias doesn't conflict with existing tokens:
```
Assert(State.TokenInfos[input.Alias] == null && State.InsensitiveTokenExisting[input.Alias.ToUpper()] == false, 
       $"Token alias {input.Alias} conflicts with existing token symbol.");
```

2. Modify `CheckTokenExists` or add validation in `CreateToken` to check against existing aliases:
```
Assert(State.SymbolAliasMap[symbol] == null, 
       $"Symbol {symbol} conflicts with existing NFT alias.");
```

3. Consider modifying `GetActualTokenSymbol` to document the precedence behavior clearly, though prioritizing direct symbols is reasonable for backward compatibility.

**Invariant Checks:**
- Enforce mutual exclusivity: a string cannot exist as both a direct symbol in `TokenInfos` and as an alias in `SymbolAliasMap`
- Validate this invariant at both token creation and alias setting time

**Test Cases:**
- Test creating regular token "TP" then attempting to set NFT alias "TP" (should fail)
- Test setting NFT alias "TP" then attempting to create regular token "TP" (should fail)
- Test `GetBalance` behavior when both exist (if backward compatibility prevents fix, document the precedence)

### Proof of Concept

**Initial State:**
- Default addresses and contract stubs initialized
- Seed NFT system operational

**Exploitation Sequence:**

1. **Attacker creates regular token "TP":**
   - Call `Create({Symbol: "TP", TokenName: "Test Token", ...})`
   - `State.TokenInfos["TP"]` now contains regular token info

2. **Victim creates NFT collection "TP-0":**
   - Call `Create({Symbol: "TP-0", TokenName: "NFT Collection", ...})`
   - `State.TokenInfos["TP-0"]` contains collection info

3. **Victim creates NFT item "TP-31175":**
   - Call `Create({Symbol: "TP-31175", ...})`
   - `State.TokenInfos["TP-31175"]` contains NFT item info

4. **Victim sets alias "TP" for NFT item:**
   - Call `SetSymbolAlias({Symbol: "TP-31175", Alias: "TP"})`
   - `CheckTokenAlias` validates "TP" == prefix of "TP-0" ✓
   - Checks `State.SymbolAliasMap["TP"] == null` ✓ (passes)
   - **Sets `State.SymbolAliasMap["TP"] = "TP-31175"`** (succeeds despite regular token "TP" existing)

5. **Victim issues NFT to themselves:**
   - Call `Issue({Symbol: "TP-31175", Amount: 1, To: VictimAddress})`
   - `State.Balances[VictimAddress]["TP-31175"] = 1`

6. **Victim queries balance via alias:**
   - Call `GetBalance({Owner: VictimAddress, Symbol: "TP"})`
   - `GetActualTokenSymbol("TP")` checks `State.TokenInfos["TP"]` - finds regular token
   - Returns "TP" (regular token symbol, NOT "TP-31175")
   - Queries `State.Balances[VictimAddress]["TP"]`
   - **Returns 0** (regular token balance)

**Expected Result:** Balance of 1 for NFT item "TP-31175"

**Actual Result:** Balance of 0 for regular token "TP"

**Success Condition:** Incorrect balance returned, demonstrating the alias is shadowed and non-functional.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L738-778)
```csharp
    public override Empty SetSymbolAlias(SetSymbolAliasInput input)
    {
        // Alias setting can only work for NFT Item for now.
        // And the setting exists on the TokenInfo of the NFT Collection.

        // Can only happen on Main Chain.
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "Symbol alias setting only works on MainChain.");

        var collectionSymbol = GetNftCollectionSymbol(input.Symbol, true);

        // For now, token alias can only be set once.
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");

        CheckTokenAlias(input.Alias, collectionSymbol);

        var collectionTokenInfo = GetTokenInfo(collectionSymbol);
        if (collectionTokenInfo == null)
        {
            throw new AssertionException($"NFT Collection {collectionSymbol} not found.");
        }

        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");

        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);

        State.SymbolAliasMap[input.Alias] = input.Symbol;

        Context.LogDebug(() => $"Token alias added: {input.Symbol} -> {input.Alias}");

        Context.Fire(new SymbolAliasAdded
        {
            Symbol = input.Symbol,
            Alias = input.Alias
        });

        return new Empty();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L840-852)
```csharp
    private void CheckTokenAlias(string alias, string collectionSymbol)
    {
        if (collectionSymbol == null)
        {
            throw new AssertionException("Token alias can only be set for NFT Item.");
        }

        // Current Rule: Alias must be the seed name.
        var parts = collectionSymbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(parts.Length == 2, $"Incorrect collection symbol: {collectionSymbol}.");
        Assert(parts.Last() == TokenContractConstants.CollectionSymbolSuffix, "Incorrect collection symbol suffix.");
        Assert(alias == parts.First(), $"Alias for an item of {collectionSymbol} cannot be {alias}.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L39-48)
```csharp
    public override GetBalanceOutput GetBalance(GetBalanceInput input)
    {
        var symbol = GetActualTokenSymbol(input.Symbol);
        return new GetBalanceOutput
        {
            Symbol = input.Symbol,
            Owner = input.Owner,
            Balance = GetBalance(input.Owner, symbol)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L286-294)
```csharp
    private string GetActualTokenSymbol(string aliasOrSymbol)
    {
        if (State.TokenInfos[aliasOrSymbol] == null)
        {
            return State.SymbolAliasMap[aliasOrSymbol] ?? aliasOrSymbol;
        }

        return aliasOrSymbol;
    }
```
