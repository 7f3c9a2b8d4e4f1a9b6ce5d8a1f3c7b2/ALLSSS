### Title
Missing LIB Height Upper Bound Validation in NextRound Allows Future Block Height Attacks

### Summary
The `NextRoundInput.Create()` function accepts arbitrary `ConfirmedIrreversibleBlockHeight` values without validating they don't exceed the current block height. The NextRound consensus behavior lacks the `LibInformationValidationProvider` that would prevent this, allowing malicious miners to store fake future LIB heights that persist in state and corrupt consensus calculations.

### Finding Description

**Root Cause:** 
The `NextRoundInput.Create()` function directly copies `ConfirmedIrreversibleBlockHeight` from the provided Round object without any validation: [1](#0-0) 

**Missing Validation:**
In the consensus validation flow, `LibInformationValidationProvider` is only added for `UpdateValue` behavior, NOT for `NextRound` or `NextTerm` behaviors: [2](#0-1) 

The `LibInformationValidationProvider` itself only checks that LIB doesn't decrease, not that it doesn't exceed current height: [3](#0-2) 

**Storage Without Recalculation:**
`ProcessNextRound` directly converts the input to a Round object and stores it via `AddRoundInformation` without recalculating or validating the LIB: [4](#0-3) [5](#0-4) 

**Persistence Mechanism:**
The fake LIB persists because `ProcessUpdateValue` only updates LIB when calculated LIB is *higher* than stored LIB. If attacker sets LIB to a very high future value, it won't be overwritten: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Compromise:**
The fake LIB corrupts the `GetMaximumBlocksCount` calculation which uses `ConfirmedIrreversibleBlockHeight` to determine blockchain mining status: [7](#0-6) 

With a fake future LIB:
- The `DistanceToIrreversibleBlockHeight` calculation at line 63 becomes negative or incorrect
- Blockchain mining status evaluation breaks, potentially preventing or incorrectly triggering "Severe" status
- Block production limits become miscalculated, affecting consensus performance
- The system claims non-existent blocks are irreversible, violating fundamental consensus safety

**Affected Parties:**
- All network participants: consensus mechanism operates on corrupted state
- Cross-chain operations: may rely on fake LIB for merkle proof verification
- Block validators: cannot properly assess chain finality

**Severity:** CRITICAL - Violates the fundamental consensus invariant that Last Irreversible Block height must represent actual finalized blocks, not future fictional heights.

### Likelihood Explanation

**Attacker Capabilities:**
Any miner in the current miner set can execute this attack when producing their assigned NextRound extra block. No special permissions beyond being an elected miner are required.

**Attack Complexity:** 
LOW - Attacker needs to:
1. Generate proper next round data via the contract's view methods
2. Modify the `ConfirmedIrreversibleBlockHeight` field to a future value (e.g., current_height + 1000000)
3. Submit the modified NextRound transaction during their assigned time slot

**Feasibility:**
The attack is fully executable:
- Entry point is the public `NextRound` method
- No authorization checks prevent data manipulation before submission
- Validation explicitly lacks LIB height upper bound checks for NextRound behavior
- The fake value persists indefinitely until naturally exceeded

**Detection Difficulty:**
MODERATE - The fake LIB would be visible in round state queries but might not be immediately obvious without active monitoring of LIB progression patterns.

**Economic Rationality:**
The attack cost is minimal (just gas for one block production during assigned slot) with potentially severe impact on consensus integrity.

### Recommendation

**Add Upper Bound Validation:**
Extend `LibInformationValidationProvider` to also be used for `NextRound` and `NextTerm` behaviors, and add validation that `ConfirmedIrreversibleBlockHeight <= Context.CurrentHeight`:

```csharp
// In LibInformationValidationProvider.cs
if (providedRound.ConfirmedIrreversibleBlockHeight > validationContext.CurrentHeight)
{
    validationResult.Message = "LIB height cannot exceed current block height.";
    return validationResult;
}
```

**Update Validation Flow:**
In `AEDPoSContract_Validation.cs`, add `LibInformationValidationProvider` to NextRound and NextTerm behaviors:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

**Add ConsensusValidationContext Enhancement:**
Ensure `Context.CurrentHeight` is accessible in validation context for the upper bound check.

**Test Cases:**
1. Attempt NextRound with `ConfirmedIrreversibleBlockHeight = CurrentHeight + 1` → should fail
2. Attempt NextRound with `ConfirmedIrreversibleBlockHeight = CurrentHeight` → should pass
3. Attempt NextRound with `ConfirmedIrreversibleBlockHeight < PreviousRound.ConfirmedIrreversibleBlockHeight` → should fail (existing check)

### Proof of Concept

**Initial State:**
- Blockchain at height H = 1000, round R = 50
- Current round has legitimate `ConfirmedIrreversibleBlockHeight = 990`
- Attacker is the designated extra block producer for round transition

**Attack Steps:**

1. Attacker calls contract view method to generate proper next round data:
   - `GetConsensusBlockExtraData` returns next round with `ConfirmedIrreversibleBlockHeight = 990`

2. Before submitting transaction, attacker modifies the round data:
   - Set `ConfirmedIrreversibleBlockHeight = 1000000` (far future value)
   - Set `ConfirmedIrreversibleBlockRoundNumber = 49` (keep other fields valid)

3. Attacker submits `NextRound` transaction with modified data at height 1000

4. Validation executes but lacks LIB upper bound check:
   - `NextRoundMiningOrderValidationProvider` checks mining order → PASS
   - `RoundTerminateValidationProvider` checks round number increment → PASS
   - **NO `LibInformationValidationProvider` runs for NextRound behavior**

5. `ProcessNextRound` stores the fake round via `AddRoundInformation`

**Expected vs Actual Result:**
- **Expected:** Transaction rejected with "LIB height cannot exceed current block height"
- **Actual:** Transaction accepted, round with `ConfirmedIrreversibleBlockHeight = 1000000` stored in state

**Success Condition:**
Query `GetCurrentRoundInformation` shows `ConfirmedIrreversibleBlockHeight = 1000000` while blockchain height is only 1000, proving fake future LIB was accepted and stored.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L78-92)
```csharp
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-106)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-67)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```
