# Audit Report

## Title
Consensus DoS via Missing Extra Block Producer Validation in Round Transition

## Summary
A malicious authorized miner can craft a `NextRoundInput` without designating any miner as the extra block producer, bypass validation, and store this malformed round in state. When any miner subsequently attempts to generate consensus commands for round termination, the system invokes `GetExtraBlockProducerInformation()` which uses `First()` on an empty sequence, throwing an `InvalidOperationException` and halting all consensus operations indefinitely.

## Finding Description

The AEDPoS consensus contract contains a critical validation gap that allows malicious round data to be persisted to state, breaking a fundamental invariant that every round must have exactly one extra block producer.

**Root Cause:**

The `GetExtraBlockProducerInformation()` method unconditionally uses `First()` to retrieve the extra block producer: [1](#0-0) 

This method is called during consensus command generation when miners need to arrange extra block mining time: [2](#0-1) [3](#0-2) 

And during round termination command generation: [4](#0-3) [5](#0-4) 

**Validation Gap:**

The `NextRound` method accepts arbitrary `NextRoundInput` from any authorized miner: [6](#0-5) 

The input is converted to a `Round` object through simple field copying with no validation: [7](#0-6) 

The `RoundTerminateValidationProvider` only validates round number increment and null InValues, but **does not** check for extra block producer existence: [8](#0-7) 

The malicious round is then stored directly to state: [9](#0-8) [10](#0-9) 

**Exploit Sequence:**

1. Malicious authorized miner constructs a `NextRoundInput` where all miners have `IsExtraBlockProducer = false`
2. Submits transaction calling `NextRound()` - passes `PreCheck()` as authorized miner
3. Validation passes (no check for extra block producer)
4. Malformed round stored to `State.Rounds[roundNumber]`
5. When any miner calls `GetConsensusCommand()` for NextRound/NextTerm behavior: [11](#0-10) 

6. The command strategy invokes `GetExtraBlockProducerInformation()` which executes `First()` on an empty sequence
7. `InvalidOperationException` thrown, consensus command generation fails
8. All miners affected - blockchain halts

## Impact Explanation

**Severity: Critical**

This vulnerability enables complete denial of service of the consensus mechanism with catastrophic consequences:

- **Consensus Failure**: No miner can generate valid consensus commands once the malformed round is stored
- **Blockchain Halt**: Block production stops indefinitely as all command generation attempts throw exceptions
- **Transaction Processing**: All pending and new transactions cannot be processed
- **Cross-Chain Operations**: Side chains depending on this chain cannot proceed with cross-chain indexing
- **Economic Impact**: Staking rewards freeze, token operations halt, all DApp functionality stops
- **Recovery Difficulty**: The chain cannot recover through normal consensus flow - requires manual intervention and potentially hard fork

**Affected Parties:**
- All network validators and miners
- All users with pending transactions
- DApp operators and users
- Dependent side chains
- Token holders and stakers

The impact is maximal because once exploited, the entire blockchain becomes non-functional and cannot self-recover.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- Must be an authorized miner in the current miner list
- While this requires insider access or miner compromise, it's a realistic threat scenario

**Attack Complexity: Low**
- No complex timing requirements
- No race conditions to exploit
- Single transaction exploit
- Malicious input is trivial to construct (set all `IsExtraBlockProducer` flags to false)

**Feasibility: High**
- The validation gap is structural, not dependent on specific state conditions
- Exploitable immediately once miner access is obtained
- No additional privileges beyond miner status needed
- The vulnerability is deterministic and reproducible

**Detection: Post-Exploitation Only**
- The malicious round is stored before any failure occurs
- Consensus failure becomes apparent only when miners attempt command generation
- By that point, the damage is irreversible through normal consensus

Given that blockchain consensus systems must be resilient against Byzantine actors, and the attack requires only miner-level access with trivial execution complexity, this represents a significant practical threat.

## Recommendation

**Primary Fix: Add Extra Block Producer Validation**

Add validation in `RoundTerminateValidationProvider.ValidationForNextRound()` to ensure at least one miner is designated as extra block producer:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing checks
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };

    // NEW: Validate extra block producer existence
    if (!extraData.Round.RealTimeMinersInformation.Values.Any(m => m.IsExtraBlockProducer))
        return new ValidationResult { Message = "Next round must have an extra block producer." };

    // Additional check: Ensure exactly one extra block producer
    var extraBlockProducerCount = extraData.Round.RealTimeMinersInformation.Values.Count(m => m.IsExtraBlockProducer);
    if (extraBlockProducerCount != 1)
        return new ValidationResult { Message = $"Next round must have exactly one extra block producer, found {extraBlockProducerCount}." };

    return new ValidationResult { Success = true };
}
```

**Secondary Fix: Defensive Programming**

Change `GetExtraBlockProducerInformation()` to use `FirstOrDefault()` with null check and graceful degradation:

```csharp
private MinerInRound GetExtraBlockProducerInformation()
{
    var extraBlockProducer = RealTimeMinersInformation.FirstOrDefault(bp => bp.Value.IsExtraBlockProducer).Value;
    Assert(extraBlockProducer != null, "No extra block producer found in round information.");
    return extraBlockProducer;
}
```

This provides defense-in-depth but should not be the sole fix as it only prevents the crash, not the underlying invariant violation.

## Proof of Concept

```csharp
[Fact]
public async Task ExploitConsensusDoS_NoExtraBlockProducer()
{
    // Setup: Initialize consensus with valid first round
    var initialMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensusAsync(initialMiners);
    
    // Attacker: Craft malicious NextRoundInput with no extra block producer
    var currentRound = await GetCurrentRoundAsync();
    var maliciousNextRound = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        RealTimeMinersInformation = 
        {
            // Create miner info with ALL IsExtraBlockProducer = false
            initialMiners.Select((miner, index) => new 
            {
                Key = miner,
                Value = new MinerInRound
                {
                    Pubkey = miner,
                    Order = index + 1,
                    IsExtraBlockProducer = false, // MALICIOUS: No extra block producer
                    ExpectedMiningTime = TimestampHelper.GetUtcNow().AddSeconds((index + 1) * 4)
                }
            }).ToDictionary(x => x.Key, x => x.Value)
        },
        RandomNumber = ByteString.CopyFromUtf8("random")
    };
    
    // Execute attack: Submit malicious NextRound
    var attackerStub = GetConsensusStub("miner1"); // Authorized miner
    var result = await attackerStub.NextRound.SendAsync(maliciousNextRound);
    
    // Verify: Malicious round stored (attack succeeds)
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var storedRound = await GetCurrentRoundAsync();
    storedRound.RoundNumber.ShouldBe(maliciousNextRound.RoundNumber);
    storedRound.RealTimeMinersInformation.Values.Any(m => m.IsExtraBlockProducer).ShouldBe(false);
    
    // Demonstrate impact: Any miner trying to get consensus command will crash
    var victimStub = GetConsensusStub("miner2");
    var commandRequest = BytesValue.Parser.ParseFrom(ByteStringHelper.FromHexString("miner2"));
    
    // This should throw InvalidOperationException when GetExtraBlockProducerInformation() is called
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await victimStub.GetConsensusCommand.CallAsync(commandRequest);
    });
    
    // Verify the exception is due to First() on empty sequence
    exception.Message.ShouldContain("Sequence contains no matching element");
    
    // Consensus is now permanently halted - no miner can generate commands
}
```

## Notes

The vulnerability exploits a fundamental design assumption that all rounds entering the system through normal generation (`GenerateNextRoundInformation`) always have an extra block producer set. However, the `NextRound()` method accepts pre-constructed round data directly, bypassing this invariant enforcement. The validation layer (`RoundTerminateValidationProvider`) fails to verify this critical invariant, allowing corrupted consensus state to be persisted.

This represents a failure to validate external inputs against protocol invariants at trust boundaries, enabling Byzantine actors to violate fundamental consensus assumptions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L19-31)
```csharp
    public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
        bool mustExceededCurrentRound = false)
    {
        var miningInterval = GetMiningInterval();

        var minerInRound = RealTimeMinersInformation[pubkey];

        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MiningTimeArrangingService.cs (L22-25)
```csharp
        public static Timestamp ArrangeExtraBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
        {
            return round.ArrangeAbnormalMiningTime(pubkey, currentBlockTime);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-27)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L39-44)
```csharp
            case AElfConsensusBehaviour.NextRound:
            case AElfConsensusBehaviour.NextTerm:
                return new ConsensusCommandProvider(
                        new TerminateRoundCommandStrategy(currentRound, pubkey, currentBlockTime,
                            behaviour == AElfConsensusBehaviour.NextTerm))
                    .GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```
