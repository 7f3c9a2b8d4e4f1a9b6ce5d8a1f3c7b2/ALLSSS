# Audit Report

## Title
Unfair Extra Block Producer Selection Due to Non-Deterministic Fallback Logic and Validation Bypass

## Summary
The AEDPoS consensus contract's extra block producer selection mechanism contains a critical flaw where duplicate `FinalOrderOfNextRound` values can create gaps in the order sequence, triggering a `.First()` fallback that systematically favors miners with the lowest order values. This occurs because `TuneOrderInformation` is applied without validation during `UpdateValue`, and the validation provider incorrectly uses `.Distinct()` on entire miner objects rather than order values, failing to detect duplicates.

## Finding Description

The vulnerability exists across three interconnected components:

**1. Unvalidated Order Tuning**

When miners call `UpdateValue`, they can submit arbitrary `TuneOrderInformation` values that are blindly applied to other miners' `FinalOrderOfNextRound` without any validation: [1](#0-0) 

The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`, but completely ignores `TuneOrderInformation`: [2](#0-1) 

**2. Broken Duplicate Detection**

The `NextRoundMiningOrderValidationProvider` attempts to validate unique orders but fails because it calls `.Distinct()` on `MinerInRound` objects rather than extracting the `FinalOrderOfNextRound` values first: [3](#0-2) 

Since `MinerInRound` is a protobuf-generated class, `.Distinct()` uses reference equality on each miner object instance, not value equality on the order field. This means even if multiple miners have identical `FinalOrderOfNextRound` values, they are counted as distinct, allowing duplicates to pass validation.

**3. Biased Fallback Selection**

During round generation, when the calculated extra block producer order doesn't correspond to any miner (due to gaps from duplicates), the code falls back to selecting the first miner: [4](#0-3) 

Since miners are inserted into `nextRound` in ascending `FinalOrderOfNextRound` order, `.First()` deterministically returns the miner with the lowest order value: [5](#0-4) 

**Attack Scenario:**

1. Malicious Miner A crafts an `UpdateValueInput` transaction with `TuneOrderInformation = {MinerB -> 1, MinerC -> 1}`, creating duplicate order values
2. This passes validation because `UpdateValueValidationProvider` doesn't check tuning values
3. When `NextRound` is called, `NextRoundMiningOrderValidationProvider` fails to detect the duplicates due to the `.Distinct()` bug
4. `GenerateNextRoundInformation` creates a round where both MinerB and MinerC have `Order = 1`, leaving other order positions empty (e.g., no miner has `Order = 2`)
5. If `CalculateNextExtraBlockProducerOrder()` returns 2, no miner matches, triggering the `.First()` fallback
6. The miner with the lowest order (either MinerB or MinerC) is selected as extra block producer

## Impact Explanation

**Consensus Fairness Violation**: The extra block producer role should be distributed based on cryptographic randomness through `CalculateNextExtraBlockProducerOrder()`, which uses miner signatures to generate a pseudo-random order. The `.First()` fallback bypasses this randomness, creating a deterministic bias toward miners with lower `FinalOrderOfNextRound` values.

**Reward Misallocation**: Extra block producers receive additional block production rewards. By systematically favoring miners with lower orders when gaps exist, the protocol violates its fairness guarantees. Miners can amplify this bias by strategically manipulating order assignments through unvalidated `TuneOrderInformation`.

**Decentralization Weakness**: If certain miners consistently receive more rewards due to favorable order positions, the economic incentive structure becomes imbalanced, potentially leading to centralization pressure.

## Likelihood Explanation

**Medium-High Feasibility**: Any miner can craft a malicious `UpdateValue` transaction with arbitrary `TuneOrderInformation` values. The transaction will pass all validation checks because:
- `UpdateValueValidationProvider` doesn't validate tuning values
- `NextRoundMiningOrderValidationProvider`'s duplicate detection is broken
- No other validation provider checks order uniqueness

**Natural Occurrence**: While signature-based order collisions can occur naturally through the modulo operation in `ApplyNormalConsensusData`, the conflict resolution logic should handle most cases: [6](#0-5) 

**Strategic Manipulation**: A malicious miner can deliberately create duplicates to increase the probability of favorable fallback selection, though they cannot fully control which order value is calculated for extra block producer selection.

## Recommendation

**1. Validate TuneOrderInformation**: Add validation in `ProcessUpdateValue` or create a new validation provider to ensure:
   - Tuned order values are within valid range [1, minersCount]
   - No duplicate order values result after tuning
   - Tuning is only applied when justified by actual conflicts

**2. Fix Duplicate Detection**: Correct the `.Distinct()` usage to operate on order values:
```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
```

**3. Remove Biased Fallback**: Instead of `.First()`, either:
   - Use deterministic selection based on block hash or round number
   - Recalculate with different parameters
   - Revert the transaction if extra block producer cannot be properly assigned

**4. Add Comprehensive Order Validation**: Ensure that before NextRound is accepted, all miners have unique, sequential orders from 1 to minersCount.

## Proof of Concept

```csharp
// Test: Demonstrate duplicate orders bypass validation and trigger biased fallback
public async Task DuplicateOrdersBypassValidationTest()
{
    // Setup: 3 miners in current round
    var round = new Round();
    round.RealTimeMinersInformation["MinerA"] = new MinerInRound 
    { 
        Pubkey = "MinerA", 
        OutValue = Hash.FromString("a"),
        FinalOrderOfNextRound = 1 
    };
    round.RealTimeMinersInformation["MinerB"] = new MinerInRound 
    { 
        Pubkey = "MinerB", 
        OutValue = Hash.FromString("b"),
        FinalOrderOfNextRound = 2 
    };
    round.RealTimeMinersInformation["MinerC"] = new MinerInRound 
    { 
        Pubkey = "MinerC", 
        OutValue = Hash.FromString("c"),
        FinalOrderOfNextRound = 3 
    };
    
    // Attack: MinerA submits malicious TuneOrderInformation
    var maliciousTuning = new Dictionary<string, int>
    {
        { "MinerB", 1 }, // Set MinerB to order 1 (duplicate with MinerA)
        { "MinerC", 1 }  // Set MinerC to order 1 (duplicate)
    };
    
    // Apply tuning (mimicking ProcessUpdateValue lines 259-260)
    foreach (var tuneOrder in maliciousTuning)
        round.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
    
    // Verify duplicates exist
    Assert.Equal(1, round.RealTimeMinersInformation["MinerA"].FinalOrderOfNextRound);
    Assert.Equal(1, round.RealTimeMinersInformation["MinerB"].FinalOrderOfNextRound);
    Assert.Equal(1, round.RealTimeMinersInformation["MinerC"].FinalOrderOfNextRound);
    
    // Test validation - should fail but doesn't due to .Distinct() bug
    var distinctCount = round.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0)
        .Distinct()
        .Count();
    Assert.Equal(3, distinctCount); // Bug: counts 3 distinct miners, not 1 distinct order
    
    // Generate next round with duplicates
    Round nextRound = new Round();
    foreach (var miner in round.RealTimeMinersInformation.Values.OrderBy(m => m.FinalOrderOfNextRound))
    {
        nextRound.RealTimeMinersInformation[miner.Pubkey] = new MinerInRound
        {
            Pubkey = miner.Pubkey,
            Order = miner.FinalOrderOfNextRound
        };
    }
    
    // Simulate extra block producer selection with gap at order 2
    int calculatedOrder = 2; // Assume calculation returns 2
    var expectedProducer = nextRound.RealTimeMinersInformation.Values
        .FirstOrDefault(m => m.Order == calculatedOrder);
    
    // Verify fallback triggers and selects first miner (biased)
    Assert.Null(expectedProducer); // No miner has order 2
    var fallbackProducer = nextRound.RealTimeMinersInformation.Values.First();
    Assert.NotNull(fallbackProducer); // First() always succeeds, creates bias
}
```

## Notes

This vulnerability combines three separate issues that collectively break consensus fairness:
1. **Input validation gap**: `TuneOrderInformation` is never validated
2. **Logic error**: `.Distinct()` operates on wrong collection type
3. **Design flaw**: `.First()` fallback creates systematic bias

The issue is particularly insidious because each component appears reasonable in isolation, but together they create an exploitable weakness. The fix requires addressing all three layers to fully restore fairness to extra block producer selection.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-65)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```
