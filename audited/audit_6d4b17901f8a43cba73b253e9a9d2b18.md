### Title
Case-Insensitive Token Uniqueness Bypass via CrossChainCreateToken

### Summary
The `CrossChainCreateToken` method bypasses case-insensitive token uniqueness validation by performing only a case-sensitive existence check before calling `RegisterTokenInfo`. This allows an attacker controlling a registered side-chain to create tokens that differ only in case (e.g., "token" after "TOKEN"), violating the protocol's design invariant enforced by `State.InsensitiveTokenExisting`.

### Finding Description

The vulnerability exists in the token creation flow through cross-chain operations.

**Normal Creation Flow (Secure):**
The standard `Create` method properly enforces case-insensitive uniqueness [1](#0-0) 

The `CheckTokenExists` method validates both case-sensitive and case-insensitive uniqueness [2](#0-1) 

**Vulnerable Path:**
The `CrossChainCreateToken` method only performs a case-sensitive check at line 506 before calling `RegisterTokenInfo` [3](#0-2) 

The `AssertNftCollectionExist` call at line 491 returns null for non-NFT tokens, providing no validation [4](#0-3) 

**Root Cause:**
`RegisterTokenInfo` unconditionally sets `State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true` without checking if it's already true [5](#0-4) 

The case-sensitive check `if (State.TokenInfos[tokenInfo.Symbol] == null)` at line 506 is insufficient because `State.TokenInfos` uses case-sensitive string keys, so "TOKEN" and "token" are distinct entries.

### Impact Explanation

**Protocol Integrity Violation:**
The `State.InsensitiveTokenExisting` mapped state exists specifically to enforce case-insensitive uniqueness [6](#0-5) 

**Concrete Harm:**
1. **Token Impersonation**: Attacker can create "token" to impersonate the legitimate "TOKEN", confusing users and applications
2. **Financial Loss**: Users may purchase or interact with the wrong token believing it's the legitimate one
3. **Independent State**: Both tokens exist with separate `State.TokenInfos` entries, separate balances, supplies, and issuers
4. **Symbol Resolution Confusion**: `GetTokenInfo("TOKEN")` and `GetTokenInfo("token")` return different tokens since lookups are case-sensitive [7](#0-6) 

**Affected Parties:**
- Token holders and traders
- DApps relying on symbol-based token identification
- Cross-chain bridge users
- DEX and marketplace platforms

**Severity Justification:** High - Violates fundamental protocol invariant, enables impersonation attacks, causes financial harm.

### Likelihood Explanation

**Reachable Entry Point:**
`CrossChainCreateToken` is a public method callable by anyone with valid cross-chain proofs [8](#0-7) 

**Attacker Capabilities:**
1. Deploy or control a side-chain (permissionless or semi-permissionless in AElf architecture)
2. Register their side-chain's token contract address (requires parliament approval but achievable)
3. Create token with different case on their side-chain
4. Generate valid cross-chain merkle proofs

**Execution Practicality:**
- Cross-chain token creation is standard functionality tested in the codebase [9](#0-8) 
- No special permissions required beyond registered token contract
- Attack steps follow normal cross-chain token creation flow

**Economic Rationality:**
- Side-chain deployment cost vs. value of impersonating high-value tokens
- Impersonation of popular tokens (e.g., stablecoins, governance tokens) is highly profitable

**Probability Assessment:** Medium-to-High likelihood in environments with permissionless side-chain creation.

### Recommendation

**Option 1 (Recommended):** Add case-insensitive validation in `CrossChainCreateToken`:
```
Before line 508, add:
CheckTokenExists(tokenInfo.Symbol);
```

**Option 2:** Modify `RegisterTokenInfo` to validate before setting:
```
Add before line 232:
Assert(!State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()], 
       "Token already exists.");
```

**Option 3:** Enhance the existence check at line 506:
```
Replace line 506 with:
if (State.TokenInfos[tokenInfo.Symbol] == null && 
    !State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()])
```

**Test Case:**
Add test verifying that `CrossChainCreateToken` fails when attempting to create "token" after "TOKEN" exists with error "Token already exists."

### Proof of Concept

**Initial State:**
- Main chain has token "TOKEN" created via normal `Create` flow
- `State.TokenInfos["TOKEN"]` exists
- `State.InsensitiveTokenExisting["TOKEN"]` = true

**Attack Steps:**
1. Attacker deploys side-chain and registers its token contract address
2. Attacker creates token "token" (lowercase) on their side-chain
3. Attacker calls `CrossChainCreateToken` with:
   - Valid `ValidateTokenInfoExistsInput` for "token"
   - Valid merkle proof and cross-chain verification data
   - Transaction bytes from registered token contract

**Execution Flow:**
- Line 491: `AssertNftCollectionExist("token")` returns null (no validation for non-NFT)
- Line 506: `State.TokenInfos["token"] == null` evaluates to TRUE (case-sensitive lookup)
- Line 508: `RegisterTokenInfo` is called
  - Sets `State.TokenInfos["token"]` = new token info
  - Sets `State.InsensitiveTokenExisting["TOKEN"]` = true (already true, no-op)

**Result:**
- Both `State.TokenInfos["TOKEN"]` and `State.TokenInfos["token"]` exist as distinct tokens
- `GetTokenInfo("TOKEN")` returns original token
- `GetTokenInfo("token")` returns attacker's token
- Case-insensitive uniqueness invariant violated

**Success Condition:**
Query both symbols and verify they return different TokenInfo objects with different issuers/properties.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L48-88)
```csharp
    private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
    {
        AssertValidCreateInput(input, symbolType);
        if (symbolType == SymbolType.Token || symbolType == SymbolType.NftCollection)
        {
            // can not call create on side chain
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
        }

        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };

        if (IsAliasSettingExists(tokenInfo))
        {
            Assert(symbolType == SymbolType.NftCollection, "Token alias can only be set for NFT Item.");
            SetTokenAlias(tokenInfo);
        }

        CheckTokenExists(tokenInfo.Symbol);
        RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-534)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L163-170)
```csharp
    private TokenInfo AssertNftCollectionExist(string symbol)
    {
        var collectionSymbol = GetNftCollectionSymbol(symbol);
        if (collectionSymbol == null) return null;
        var collectionInfo = GetTokenInfo(collectionSymbol);
        Assert(collectionInfo != null, "NFT collection not exist");
        return collectionInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L17-17)
```csharp
    public MappedState<string, bool> InsensitiveTokenExisting { get; set; }
```

**File:** test/AElf.Contracts.MultiTokenCrossChainTransfer.Tests/MultiTokenContractCrossChainTest.cs (L330-367)
```csharp
    {
        await GenerateSideChainAsync();
        await RegisterSideChainContractAddressOnMainChainAsync();

        await BootMinerChangeRoundAsync(AEDPoSContractStub, true);
        var createTransaction = await CreateTransactionForTokenCreation(TokenContractStub,
            DefaultAccount.Address, SymbolForTesting, TokenContractAddress);
        var blockExecutedSet = await MineAsync(new List<Transaction> { createTransaction });
        var createResult = blockExecutedSet.TransactionResultMap[createTransaction.GetHash()];
        Assert.True(createResult.Status == TransactionResultStatus.Mined, createResult.Error);
        var sideCreateTransaction = await CreateTransactionForTokenCreation(SideChainTokenContractStub,
            SideChainTestKit.DefaultAccount.Address, SymbolForTesting, SideTokenContractAddress);
        blockExecutedSet = await SideChainTestKit.MineAsync(new List<Transaction> { sideCreateTransaction });
        var sideCreateResult = blockExecutedSet.TransactionResultMap[sideCreateTransaction.GetHash()];
        Assert.True(sideCreateResult.Status == TransactionResultStatus.Mined, sideCreateResult.Error);

        var createdTokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
        {
            Symbol = SymbolForTesting
        });
        var tokenValidationTransaction = CreateTokenInfoValidationTransaction(createdTokenInfo, TokenContractStub);
        var executedSet = await MineAsync(new List<Transaction> { tokenValidationTransaction });
        var merklePath = GetTransactionMerklePathAndRoot(tokenValidationTransaction, out var blockRoot);
        await IndexMainChainTransactionAsync(executedSet.Height, blockRoot, blockRoot);
        var crossChainCreateTokenInput = new CrossChainCreateTokenInput
        {
            FromChainId = MainChainId,
            ParentChainHeight = executedSet.Height,
            TransactionBytes = tokenValidationTransaction.ToByteString(),
            MerklePath = merklePath
        };

        var executionResult =
            await SideChainTokenContractStub.CrossChainCreateToken.SendWithExceptionAsync(
                crossChainCreateTokenInput);
        Assert.True(executionResult.TransactionResult.Status == TransactionResultStatus.Failed);
        Assert.Contains("Token already exists.", executionResult.TransactionResult.Error);
    }
```
