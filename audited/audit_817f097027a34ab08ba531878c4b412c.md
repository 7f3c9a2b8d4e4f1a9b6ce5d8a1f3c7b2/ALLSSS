### Title
Referendum Proposals Can Be Created with Maximum Timestamp Causing Indefinite Token Lock

### Summary
The Referendum contract allows authorized proposers to create proposals with `ExpiredTime` set to the maximum timestamp value (year 9999), effectively creating never-expiring proposals. This causes voter tokens to be locked indefinitely since token reclamation requires the proposal to be expired, resulting in permanent loss of access to funds for voters.

### Finding Description

The vulnerability exists in the proposal validation and creation flow across the Referendum contract:

**Root Cause:** The `Validate(ProposalInfo)` function only checks that `ExpiredTime` is not null and is in the future, but does not enforce any maximum bound. [1](#0-0) 

When creating a proposal, `ExpiredTime` is taken directly from user input without any upper bound validation. [2](#0-1) 

The `CheckCreateProposalInput` function only validates the length of title, description, and URL, but completely ignores `ExpiredTime` constraints. [3](#0-2) 

**Why Protections Fail:** An authorized proposer can set `ExpiredTime` to `TimestampHelper.MaxValue` (9999-12-31T23:59:59.999999999Z). [4](#0-3) 

**Execution Path:**
1. Authorized proposer creates proposal via `CreateProposal` with maximum timestamp [5](#0-4) 
2. Voters vote on the proposal (Approve/Reject/Abstain), which locks their tokens via `LockToken` [6](#0-5) 
3. If proposal doesn't reach release threshold, voters attempt to reclaim tokens via `ReclaimVoteToken`, which requires `Context.CurrentBlockTime >= proposal.ExpiredTime` [7](#0-6) 
4. Since `ExpiredTime` is set to year 9999, the condition will never be satisfied, permanently locking voter tokens

**Note:** This same vulnerability exists in Association and Parliament contracts with identical validation logic. [8](#0-7) 

### Impact Explanation

**Direct Fund Impact:**
- Voters who participate in such proposals have their tokens permanently locked in the contract
- Locked tokens cannot be reclaimed for ~8000 years until the timestamp is reached
- This is equivalent to permanent loss of funds for affected voters

**Operational Impact:**
- Storage bloat: Proposals cannot be cleared via `ClearProposal` until expired [9](#0-8) 
- Griefing attack vector against voters who trust the governance process

**Who is Affected:**
- Any voter (token holder) who votes on malicious proposals with maximum `ExpiredTime`
- The entire organization if the malicious proposer creates multiple such proposals

**Severity Justification:** MEDIUM
- High impact (permanent token lockup = fund loss)
- Medium likelihood (requires malicious authorized proposer, but feasible if proposer is compromised or becomes malicious)

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be in the `ProposerWhiteList` for the target organization
- This is a trusted role, but trust assumptions can be violated through:
  - Compromised proposer account
  - Initially honest proposer becoming malicious
  - Social engineering during whitelist addition

**Attack Complexity:**
- Very low complexity: Simply set `ExpiredTime = TimestampHelper.MaxValue` when creating proposal
- No special timing or state manipulation required
- Single transaction execution

**Feasibility Conditions:**
- Attacker must have proposer authorization (feasible but requires trust breach)
- Victims must vote on the malicious proposal (requires social engineering, but proposals with legitimate-looking content can attract votes)
- No on-chain mechanism exists to detect or prevent maximum timestamp usage

**Detection/Operational Constraints:**
- No event or check warns about abnormally long proposal durations
- Voters may not inspect `ExpiredTime` before voting
- Once tokens are locked, recovery is impossible without contract upgrade

**Probability Reasoning:**
While this requires a malicious authorized proposer (reducing likelihood), the ease of execution, lack of detection mechanisms, and permanent damage make this a realistic threat in scenarios where proposer trust is compromised.

### Recommendation

**Code-Level Mitigation:**

Add maximum `ExpiredTime` constraint in `CheckCreateProposalInput`:

```csharp
private void CheckCreateProposalInput(CreateProposalInput input)
{
    // Check the length of title
    Assert(input.Title.Length <= ReferendumConstants.MaxLengthForTitle, "Title is too long.");
    // Check the length of description
    Assert(input.Description.Length <= ReferendumConstants.MaxLengthForDescription, "Description is too long.");
    // Check the length of description url
    Assert(input.ProposalDescriptionUrl.Length <= ReferendumConstants.MaxLengthForProposalDescriptionUrl,
        "Description url is too long.");
    
    // ADD THIS: Check maximum expiration time
    var maxExpiredTime = Context.CurrentBlockTime.AddDays(ReferendumConstants.MaxProposalDurationDays);
    Assert(input.ExpiredTime <= maxExpiredTime, "Proposal expiration time exceeds maximum allowed duration.");
}
```

**Invariant Checks to Add:**
1. Define `MaxProposalDurationDays` constant (e.g., 90 days for Referendum, configurable per organization)
2. Apply same fix to Association and Parliament contracts
3. Consider adding a view function to query maximum allowed duration

**Test Cases to Prevent Regression:**
1. Test proposal creation with `ExpiredTime = TimestampHelper.MaxValue` - should fail
2. Test proposal creation with `ExpiredTime = CurrentBlockTime + MaxDuration + 1 second` - should fail  
3. Test proposal creation with `ExpiredTime = CurrentBlockTime + MaxDuration` - should succeed
4. Test edge cases around the maximum duration boundary

### Proof of Concept

**Required Initial State:**
- Referendum organization created with proposer in whitelist
- Token contract initialized with voter having sufficient token balance and allowance

**Transaction Steps:**

1. **Malicious proposer creates proposal with maximum timestamp:**
   ```
   Input: CreateProposalInput {
       ContractMethodName = "SomeMethod",
       ToAddress = <target>,
       ExpiredTime = TimestampHelper.MaxValue, // 9999-12-31T23:59:59.999999999Z
       OrganizationAddress = <org_address>,
       ... other fields
   }
   Result: Proposal created successfully (no validation error)
   ProposalId: <proposal_id>
   ```

2. **Victim approves proposal (locks tokens):**
   ```
   Call: Approve(<proposal_id>)
   Result: Tokens locked in proposal virtual address
   State: LockedTokenAmount[voter][proposal_id] = { Amount: X, ... }
   ```

3. **Proposal fails to reach threshold (normal scenario):**
   ```
   State: Proposal not released, remains in storage
   ```

4. **Victim attempts to reclaim tokens:**
   ```
   Call: ReclaimVoteToken(<proposal_id>)
   Result: Transaction FAILS with "Unable to reclaim at this time."
   Reason: Context.CurrentBlockTime (e.g., 2024) < proposal.ExpiredTime (9999)
   ```

**Expected vs Actual Result:**
- **Expected:** Proposals should have reasonable expiration times (days/weeks/months), allowing token reclamation after a reasonable period
- **Actual:** Proposals can be created with year 9999 expiration, permanently locking voter tokens until that far-future date

**Success Condition:**
The vulnerability is confirmed when `ReclaimVoteToken` fails for a proposal with maximum `ExpiredTime`, and the check in the code explicitly requires `Context.CurrentBlockTime >= proposal.ExpiredTime`, which will not be satisfied for thousands of years.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L39-72)
```csharp
    private ReferendumReceiptCreated LockToken(string symbol, long amount, Hash proposalId, Address lockedAddress,
        Address organizationAddress)
    {
        Assert(State.LockedTokenAmount[lockedAddress][proposalId] == null, "Already locked.");

        var lockId = Context.GenerateId(Context.Self,
            HashHelper.ConcatAndCompute(proposalId, HashHelper.ComputeFrom(lockedAddress)));
        RequireTokenContractStateSet();
        Context.SendVirtualInline(proposalId, State.TokenContract.Value,
            nameof(TokenContractContainer.TokenContractReferenceState.TransferFrom), new TransferFromInput
            {
                From = Context.Sender,
                To = GetProposalVirtualAddress(proposalId),
                Symbol = symbol,
                Amount = amount,
                Memo = "Referendum."
            });
        State.LockedTokenAmount[Context.Sender][proposalId] = new Receipt
        {
            Amount = amount,
            LockId = lockId,
            TokenSymbol = symbol
        };

        return new ReferendumReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = proposalId,
            Amount = amount,
            Symbol = symbol,
            Time = Context.CurrentBlockTime,
            OrganizationAddress = organizationAddress
        };
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L159-187)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ToAddress = input.ToAddress,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            OrganizationAddress = input.OrganizationAddress,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId, 
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L189-198)
```csharp
    private void CheckCreateProposalInput(CreateProposalInput input)
    {
        // Check the length of title
        Assert(input.Title.Length <= ReferendumConstants.MaxLengthForTitle, "Title is too long.");
        // Check the length of description
        Assert(input.Description.Length <= ReferendumConstants.MaxLengthForDescription, "Description is too long.");
        // Check the length of description url
        Assert(input.ProposalDescriptionUrl.Length <= ReferendumConstants.MaxLengthForProposalDescriptionUrl,
            "Description url is too long.");
    }
```

**File:** contract/AElf.Contracts.Election/TimestampHelper.cs (L12-15)
```csharp
    /// <summary>
    ///     9999-12-31T23:59:59.999999999Z
    /// </summary>
    public static Timestamp MaxValue => new() { Nanos = 999999999, Seconds = 253402300799L };
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-59)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L115-122)
```csharp
    public override Empty ReclaimVoteToken(Hash input)
    {
        var proposal = State.Proposals[input];
        Assert(proposal == null ||
               Context.CurrentBlockTime >= proposal.ExpiredTime, "Unable to reclaim at this time.");
        UnlockToken(input, Context.Sender);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L154-161)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```
