### Title
GetVotingIds() Function Throws Exception When Querying Non-Existent Voter-VotingItem Combination

### Summary
The `GetVotingIds()` view method will throw an `InvalidOperationException` when querying for a voting item that a voter has not participated in, or a `NullReferenceException` if the voter has never voted on any item. This causes a denial-of-service for legitimate vote status queries and breaks external applications relying on this method.

### Finding Description

The vulnerability exists in the `GetVotingIds()` function at [1](#0-0) 

**Root Cause:**
The function chains `Where().Select().First()` LINQ operations without checking if the filtered sequence is empty. This creates two failure scenarios:

1. **Null Reference Failure**: If `State.VotedItemsMap[input.Voter]` returns null (voter never voted on anything), accessing `.VotedItemVoteIds` throws a `NullReferenceException`.

2. **Empty Sequence Failure**: If the voter exists in VotedItemsMap but has never voted on the specific `input.VotingItemId`, the `Where(p => p.Key == input.VotingItemId.ToHex())` clause returns an empty sequence. Calling `.First()` on an empty sequence throws an `InvalidOperationException`.

**Missing Protections:**
Unlike the similar `GetVotedItems()` function [2](#0-1) , which properly handles null cases with the `??` operator, `GetVotingIds()` has no null-safety or empty-check protections.

**Data Structure Context:**
The `VotedItemsMap` state variable [3](#0-2)  maps voter addresses to `VotedItems` objects, which contain a dictionary `VotedItemVoteIds` [4](#0-3)  mapping voting item IDs (as hex strings) to `VotedIds` objects.

### Impact Explanation

**Operational DoS of Critical View Functionality:**
- Any query for a non-existent voter or voter-voting item combination causes the contract call to fail with an exception
- Prevents legitimate use cases such as checking whether a voter has participated in a specific voting item
- Breaks external monitoring tools, analytics dashboards, and UI applications that depend on this method
- No alternative method exists to safely check if a voter has voted on a specific item

**Affected Parties:**
- Users attempting to query their own voting history
- Frontend applications displaying voting participation
- Election contract functionality that queries vote IDs [5](#0-4) 
- Monitoring and analytics systems tracking voting behavior

**Severity Justification:**
While view methods don't modify state, this is a HIGH severity operational issue because:
- The method is part of the public API defined in the protobuf contract [6](#0-5) 
- It completely breaks a core query functionality with no workaround
- Testing shows this method is only called after votes exist [7](#0-6) , indicating missing edge case validation

### Likelihood Explanation

**Very High Exploitability:**

1. **Reachable Entry Point**: `GetVotingIds()` is a public view method (marked with `is_view = true`) that requires no special permissions and can be called by anyone.

2. **Feasible Preconditions**: 
   - No preconditions required beyond knowing a valid voter address and voting item ID
   - Common legitimate scenario: checking if an address has voted on a specific proposal before it actually has
   - No authorization or ownership checks prevent the call

3. **Deterministic Failure**: The exception is guaranteed to occur given invalid input combinations, making this 100% reproducible.

4. **Attack Complexity**: Trivial - single contract call with any voter address that hasn't voted on the specified voting item.

5. **Economic Rationality**: Zero cost attack - view methods are free to call and cause no gas consumption for the caller.

6. **Detection**: Failures appear as transaction exceptions, making them easily observable but also indicating the vulnerability is actively causing operational issues.

### Recommendation

**Immediate Fix:**
Replace `.First()` with `.FirstOrDefault()` and handle the null case:

```csharp
public override VotedIds GetVotingIds(GetVotingIdsInput input)
{
    var votedItems = State.VotedItemsMap[input.Voter];
    if (votedItems == null)
        return new VotedIds();
    
    return votedItems.VotedItemVoteIds
        .Where(p => p.Key == input.VotingItemId.ToHex())
        .Select(p => p.Value)
        .FirstOrDefault() ?? new VotedIds();
}
```

**Alternative Fix:**
Add explicit validation and return empty result for non-existent combinations:

```csharp
public override VotedIds GetVotingIds(GetVotingIdsInput input)
{
    var votedItems = State.VotedItemsMap[input.Voter];
    if (votedItems == null || !votedItems.VotedItemVoteIds.ContainsKey(input.VotingItemId.ToHex()))
        return new VotedIds();
    
    return votedItems.VotedItemVoteIds[input.VotingItemId.ToHex()];
}
```

**Test Cases to Add:**
1. Test calling `GetVotingIds()` with an address that has never voted
2. Test calling `GetVotingIds()` with a voter who voted on different voting items
3. Test calling `GetVotingIds()` with non-existent voting item IDs

### Proof of Concept

**Initial State:**
- Voting item A is registered with ID `votingItemA`
- Voting item B is registered with ID `votingItemB`
- User Alice votes on voting item A
- User Bob has never voted on anything

**Exploitation Steps:**

**Scenario 1 - Query Non-Existent Voter:**
```
Call: GetVotingIds(voter=Bob, votingItemId=votingItemA)
Expected: Returns empty VotedIds or gracefully indicates no votes
Actual: Throws NullReferenceException because State.VotedItemsMap[Bob] is null
```

**Scenario 2 - Query Non-Participated Voting Item:**
```
Call: GetVotingIds(voter=Alice, votingItemId=votingItemB)
Expected: Returns empty VotedIds indicating Alice hasn't voted on item B
Actual: Throws InvalidOperationException because Where() returns empty sequence and First() fails
```

**Success Condition:**
The transaction fails with an exception instead of returning an empty or null result, confirming the DoS vulnerability in vote status queries.

### Citations

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L15-18)
```csharp
    public override VotedItems GetVotedItems(Address input)
    {
        return State.VotedItemsMap[input] ?? new VotedItems();
    }
```

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L55-59)
```csharp
    public override VotedIds GetVotingIds(GetVotingIdsInput input)
    {
        return State.VotedItemsMap[input.Voter].VotedItemVoteIds.Where(p => p.Key == input.VotingItemId.ToHex())
            .Select(p => p.Value).First();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L24-24)
```csharp
    public MappedState<Address, VotedItems> VotedItemsMap { get; set; }
```

**File:** protobuf/vote_contract.proto (L82-84)
```text
    rpc GetVotingIds (GetVotingIdsInput) returns (VotedIds) {
        option (aelf.is_view) = true;
    }
```

**File:** protobuf/vote_contract.proto (L235-238)
```text
message VotedItems {
    // The voted ids.
    map<string, VotedIds> voted_item_vote_ids = 1;
}
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ElectionTests.cs (L1570-1574)
```csharp
        var voteIdOfVoter2 = await VoteContractStub.GetVotingIds.CallAsync(new GetVotingIdsInput
        {
            Voter = Address.FromPublicKey(voter2.PublicKey),
            VotingItemId = electionVoteItemId
        });
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L653-666)
```csharp
    public async Task VoteContract_GetVotingIds_Test()
    {
        var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1);
        var voteUser = Accounts[1];
        var voteItemId = registerItem.VotingItemId;
        var voteAmount = 100;
        await Vote(voteUser.KeyPair, voteItemId, registerItem.Options[1], voteAmount);
        var voteIds = await VoteContractStub.GetVotingIds.CallAsync(new GetVotingIdsInput
        {
            Voter = voteUser.Address,
            VotingItemId = registerItem.VotingItemId
        });
        voteIds.ActiveVotes.Count.ShouldBe(1);
    }
```
