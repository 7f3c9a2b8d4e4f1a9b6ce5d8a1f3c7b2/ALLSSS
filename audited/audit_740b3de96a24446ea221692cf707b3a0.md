# Audit Report

## Title
Association Organization Permanent Deadlock via 100% Vote Threshold Requirement

## Summary
The Association contract's validation logic allows organizations to be configured with `MinimalVoteThreshold` equal to `organizationMemberCount`, requiring 100% member participation for all proposals. This creates an unrecoverable deadlock when any single member becomes unavailable, permanently locking all governance functions and any assets controlled by the organization. No recovery mechanism exists.

## Finding Description

The vulnerability originates in the organization validation logic that permits unanimous vote requirements without safeguards against member unavailability.

The validation method uses a less-than-or-equal comparison, explicitly allowing `MinimalVoteThreshold` to equal the total member count. [1](#0-0)  This enables organizations to require 100% member participation for any proposal to pass.

The vote threshold checking logic requires that total votes (approvals + rejections + abstentions) must meet or exceed `MinimalVoteThreshold`. [2](#0-1)  When `MinimalVoteThreshold` equals member count, all members must vote for proposals to reach the release threshold. [3](#0-2) 

All organization modification methods—including `ChangeOrganizationThreshold`, `AddMember`, `RemoveMember`, and `ChangeMember`—require that `Context.Sender` equals the organization address. [4](#0-3) [5](#0-4) [6](#0-5) 

The organization address can only become `Context.Sender` when a proposal is executed via `SendVirtualInlineBySystemContract`. [7](#0-6) 

This creates an inescapable deadlock scenario:
1. Organization configured with `MinimalVoteThreshold = memberCount` (e.g., 3 members, threshold 3)
2. One member becomes unavailable (lost private key, malicious refusal, death, dispute)
3. Maximum achievable votes: `memberCount - 1` (e.g., only 2 members can vote)
4. Required votes: `memberCount` (e.g., threshold remains 3)
5. No proposal can reach threshold → cannot execute any modifications
6. Cannot remove unavailable member (requires proposal)
7. Cannot lower threshold (requires proposal)
8. Cannot add members to compensate (requires proposal)
9. **Permanent deadlock achieved**

While system contracts intentionally use this pattern with contract addresses as members (which cannot become unavailable), [8](#0-7) [9](#0-8)  user-created organizations with human members face real unavailability risks that system contracts do not.

## Impact Explanation

**Permanent Loss of Governance Control:**
Association organizations can control significant assets and permissions. The organization address can hold tokens, be set as an authority for contract methods, and manage critical protocol configurations. Once deadlocked, all organization-controlled resources become permanently inaccessible with no recovery mechanism.

**Griefing/Extortion Vector:**
A malicious actor can intentionally create a 100% threshold organization, wait until other members contribute funds or delegate important permissions to it, then refuse to participate in any proposals. This holds all other members' assets hostage indefinitely. The attack cost is zero—the malicious actor simply stops participating.

**Affected Scope:**
- All user-created Association organizations with `MinimalVoteThreshold = organizationMemberCount`
- Any tokens held by such organizations
- Any protocol permissions/authorities delegated to such organizations
- Multi-party agreements and DAOs using Association contract governance

The severity is amplified because:
1. No warning exists that this configuration creates unrecoverable risk
2. The configuration appears reasonable for organizations wanting strong consensus
3. System contracts use this pattern, implicitly validating it as "normal"
4. Member unavailability is common in real-world scenarios (not theoretical)

## Likelihood Explanation

**High Likelihood:**

The vulnerability has high likelihood of occurrence because:

1. **Appears Reasonable:** Users wanting unanimous decision-making will naturally set `MinimalVoteThreshold = memberCount`, not realizing this creates permanent deadlock risk if any member becomes unavailable.

2. **No Warnings:** The contract provides no indication that this configuration is dangerous. The validation permits it without any error message or event warning users of the risk. [10](#0-9) 

3. **System Contract Precedent:** Multiple system contracts create organizations with this exact configuration, [11](#0-10)  which implicitly signals to users that this is a valid and safe pattern.

4. **Common Unavailability:** Member unavailability is realistic:
   - Lost/compromised private keys
   - Inactive/deceased members
   - Business disputes leading to non-participation
   - Malicious griefing attacks

5. **Zero Attack Cost:** For griefing attacks, the malicious actor simply stops participating—no transaction cost, no complex exploit needed.

**Execution Path:**
1. User calls `CreateOrganization` with `MinimalVoteThreshold = memberCount` [12](#0-11) 
2. Organization operates normally while all members remain active
3. One member becomes unavailable (realistic scenario)
4. Deadlock immediately occurs—no proposals can pass, no recovery possible

This is fully executable under normal AElf runtime semantics without requiring any special privileges or unrealistic preconditions.

## Recommendation

**Immediate Fix:**
Modify the validation logic to prevent 100% thresholds for user-created organizations while preserving system contract functionality:

```csharp
private bool Validate(Organization organization)
{
    if (organization.ProposerWhiteList.Empty() ||
        organization.ProposerWhiteList.AnyDuplicate() ||
        organization.OrganizationMemberList.Empty() ||
        organization.OrganizationMemberList.AnyDuplicate())
        return false;
    if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
        return false;
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    var organizationMemberCount = organization.OrganizationMemberList.Count();
    
    // Prevent 100% threshold for user organizations (allow for system contracts via special creation method)
    var maxAllowedThreshold = organizationMemberCount;
    if (!Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender))
    {
        // For user-created organizations, require at least one member buffer
        maxAllowedThreshold = organizationMemberCount - 1;
    }
    
    return proposalReleaseThreshold.MinimalVoteThreshold <= maxAllowedThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
           proposalReleaseThreshold.MaximalRejectionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
}
```

**Alternative Approach:**
Add an emergency recovery mechanism allowing a super-majority (e.g., 80% of members) to force-pass critical organizational changes when the normal threshold cannot be met.

**Long-term:**
Document the risks of high threshold configurations and provide clear guidance on choosing appropriate values that balance security with operational resilience.

## Proof of Concept

```csharp
[Fact]
public void AssociationOrganization_100PercentThreshold_CreatesDeadlock()
{
    // Setup: Create organization with 3 members and 100% vote threshold
    var member1 = SampleAccount.Accounts[0].Address;
    var member2 = SampleAccount.Accounts[1].Address;
    var member3 = SampleAccount.Accounts[2].Address;
    
    var createOrganizationInput = new CreateOrganizationInput
    {
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 3,  // Requires all 3 members to approve
            MinimalVoteThreshold = 3,       // Requires all 3 members to vote
            MaximalRejectionThreshold = 0,
            MaximalAbstentionThreshold = 0
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { member1, member2, member3 }
        },
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { member1, member2, member3 }
        }
    };
    
    var organizationAddress = AssociationContractStub.CreateOrganization.SendAsync(createOrganizationInput)
        .Result.Output;
    
    // Simulate member3 becoming unavailable - create proposal to remove them
    var proposalInput = new CreateProposalInput
    {
        OrganizationAddress = organizationAddress,
        ToAddress = AssociationContractAddress,
        ContractMethodName = nameof(AssociationContractStub.RemoveMember),
        Params = member3.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
    };
    
    var proposalId = AssociationContractStub.CreateProposal.SendAsync(proposalInput).Result.Output;
    
    // Only member1 and member2 can vote (member3 is unavailable)
    AssociationContractStub.Approve.SendAsync(proposalId);  // member1 approves
    
    var member2Stub = GetAssociationContractStub(SampleAccount.Accounts[1].KeyPair);
    member2Stub.Approve.SendAsync(proposalId);  // member2 approves
    
    // Attempt to release proposal with only 2 votes (requires 3)
    var proposal = AssociationContractStub.GetProposal.CallAsync(proposalId).Result;
    proposal.ApprovalCount.ShouldBe(2);
    proposal.ToBeReleased.ShouldBeFalse();  // Cannot be released - deadlock confirmed
    
    // Verify Release fails
    var releaseResult = AssociationContractStub.Release.SendAsync(proposalId).Result;
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
    
    // Organization is now permanently deadlocked - no recovery possible
}
```

## Notes

The distinction between system contract usage (safe) and user organization usage (unsafe) of 100% thresholds is critical. System contracts use contract addresses as members, which are always available and cannot lose keys. User organizations with human-controlled addresses face real-world unavailability that makes this configuration permanently dangerous. The contract currently treats both cases identically, creating the vulnerability.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-58)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-216)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L639-645)
```csharp
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = organizationMembers.ToList().Count,
                MinimalVoteThreshold = organizationMembers.ToList().Count,
                MaximalRejectionThreshold = 0,
                MaximalAbstentionThreshold = 0
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L229-235)
```csharp
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = actualProposalCount,
                    MinimalVoteThreshold = actualProposalCount,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L256-262)
```csharp
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = proposers.Count,
                    MinimalVoteThreshold = proposers.Count,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
```
