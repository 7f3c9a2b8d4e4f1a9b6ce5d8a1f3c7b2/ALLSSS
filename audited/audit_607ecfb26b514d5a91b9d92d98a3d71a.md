### Title
Case-Insensitive Token Collision via Cross-Chain Creation Bypass

### Summary
The `CrossChainCreateToken` method bypasses the case-insensitive uniqueness check that prevents tokens like 'ABC-0' and 'abc-0' from coexisting, allowing case-variant NFT collections to exist simultaneously in the system. This violates the NFT uniqueness invariant and enables token confusion, phishing attacks, and protocol inconsistencies.

### Finding Description

The MultiToken contract implements case-insensitive token uniqueness through `State.InsensitiveTokenExisting` which stores uppercase versions of all token symbols [1](#0-0) . 

The regular token creation path properly enforces this through `CheckTokenExists`, which checks both case-sensitive and case-insensitive existence [2](#0-1) , and is called before `RegisterTokenInfo` [3](#0-2) .

However, the `CrossChainCreateToken` method bypasses this protection entirely. It only performs a case-sensitive check `State.TokenInfos[tokenInfo.Symbol] == null` [4](#0-3)  before calling `RegisterTokenInfo`. For NFT collections (symbols ending in "-0"), the `AssertNftCollectionExist` validation returns null without checking case-insensitive uniqueness [5](#0-4) .

The `GetSymbolType` function is case-sensitive and will classify both "ABC-0" and "abc-0" as `NftCollection` [6](#0-5) , allowing both to pass validation independently.

**Execution Path:**
1. Token "ABC-0" created locally → `State.TokenInfos["ABC-0"]` and `State.InsensitiveTokenExisting["ABC-0"]` set
2. Cross-chain sync of "abc-0" → only checks `State.TokenInfos["abc-0"] == null` (true) → proceeds
3. `RegisterTokenInfo` creates `State.TokenInfos["abc-0"]` and sets `State.InsensitiveTokenExisting["ABC-0"]` again
4. Both tokens now exist as distinct entities in `State.TokenInfos` but share the same insensitive key

### Impact Explanation

**Direct Protocol Impact:**
- Violates the critical invariant that `State.InsensitiveTokenExisting` ensures token uniqueness
- Two distinct TokenInfo objects exist for case-variant symbols, each with independent supply, issuer, and owner
- `GetTokenInfo` calls return different tokens based on case [7](#0-6) , causing operational inconsistencies

**Security Impact:**
- **NFT Collection Confusion**: Users cannot distinguish between legitimate "ABC-0" collection and malicious "abc-0" collection
- **Phishing Enabler**: Attackers can create near-identical collections to established projects (e.g., "BAYC-0" vs "bayc-0")
- **Balance Fragmentation**: User balances split across case-variant tokens, appearing as partial holdings
- **Market Manipulation**: Fake collections can mislead marketplaces and users about authentic NFT provenance

**Affected Parties:**
- NFT collection owners whose brand can be impersonated
- Users who may transact with wrong token variant
- Marketplace integrations that assume case-insensitive uniqueness
- Cross-chain bridge users during multi-chain NFT operations

### Likelihood Explanation

**Realistic Exploitation Scenarios:**

1. **Cross-Chain Protocol Upgrade Window**: When parent chain upgrades to include case-insensitive checks but child chain hasn't upgraded, case-variant tokens from parent can sync to child that already has one variant.

2. **Natural Multi-Chain Collision**: Independent chains create "ABC-0" and "abc-0" legitimately without knowledge of each other. During cross-chain indexing, both sync to a common chain.

3. **Legacy Chain Integration**: Chains running older contract versions without `InsensitiveTokenExisting` protection could have case-variant collections that propagate via cross-chain sync.

**Attacker Capabilities Required:**
- Valid cross-chain transaction proof with merkle path (obtainable for legitimate parent chain transactions)
- Whitelisted token contract registration for source chain (established during chain setup)
- No need to compromise trusted roles or validators

**Execution Practicality:**
- Cross-chain token synchronization is a standard operational flow [8](#0-7) 
- The vulnerability triggers automatically during legitimate cross-chain operations when case-variants exist on source chain
- Detection difficulty: Case-variant tokens appear as valid separate collections to most monitoring systems

**Probability Assessment**: Medium-to-High during cross-chain operations, especially in multi-chain ecosystems with varying contract version deployments or during upgrade transitions.

### Recommendation

**Immediate Fix:**
Modify `CrossChainCreateToken` to call `CheckTokenExists` before `RegisterTokenInfo`, matching the local creation flow:

```csharp
// In CrossChainCreateToken method, after line 505
var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
CheckTokenExists(tokenInfo.Symbol);  // ADD THIS LINE
if (State.TokenInfos[tokenInfo.Symbol] == null)
{
    RegisterTokenInfo(tokenInfo);
    // ... rest of code
}
```

**Additional Hardening:**
1. Add assertion in `RegisterTokenInfo` to verify `State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()]` is false before proceeding
2. Implement cross-chain token validation that checks case-insensitive collisions against existing tokens
3. Add test case: attempt cross-chain creation of "abc-0" when "ABC-0" exists locally, verify rejection

**Invariant to Enforce:**
`State.InsensitiveTokenExisting.ContainsKey(symbol.ToUpper()) ⟹ exactly one State.TokenInfos entry exists for any case variant of symbol`

### Proof of Concept

**Initial State:**
- Chain A (current chain) has no tokens
- Chain B (parent chain) whitelisted in `State.CrossChainTransferWhiteList`

**Exploitation Steps:**

1. **On Chain A**: User creates NFT collection "ABC-0" via `Create` method
   - `CheckTokenExists("ABC-0")` passes
   - `RegisterTokenInfo` sets `State.TokenInfos["ABC-0"]` and `State.InsensitiveTokenExisting["ABC-0"] = true`

2. **On Chain B**: Different user creates NFT collection "abc-0" (possible if Chain B has older code or different validation)

3. **Cross-Chain Sync**: Chain B user calls `CrossChainCreateToken` on Chain A with valid proof for "abc-0" transaction
   - Line 491: `AssertNftCollectionExist("abc-0")` returns null (no error for collection itself)
   - Line 506: `State.TokenInfos["abc-0"] == null` evaluates to TRUE (case-sensitive check)
   - Line 508: `RegisterTokenInfo("abc-0")` executes successfully
   - Sets `State.TokenInfos["abc-0"]` and `State.InsensitiveTokenExisting["ABC-0"] = true` (already true)

**Expected Result**: Transaction should fail with "Token already exists"

**Actual Result**: Transaction succeeds, creating second token

**Success Verification:**
- `GetTokenInfo("ABC-0")` returns first token with its specific properties
- `GetTokenInfo("abc-0")` returns second token with different properties  
- Both tokens operational but share uppercase key in `InsensitiveTokenExisting`
- Attempting to create "aBc-0" locally via `Create` fails (correctly blocked by insensitive check)
- System now has inconsistent state with two case-variant NFT collections

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L233-233)
```csharp
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L87-88)
```csharp
        CheckTokenExists(tokenInfo.Symbol);
        RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-533)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }

        return new Empty();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L163-170)
```csharp
    private TokenInfo AssertNftCollectionExist(string symbol)
    {
        var collectionSymbol = GetNftCollectionSymbol(symbol);
        if (collectionSymbol == null) return null;
        var collectionInfo = GetTokenInfo(collectionSymbol);
        Assert(collectionInfo != null, "NFT collection not exist");
        return collectionInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```
