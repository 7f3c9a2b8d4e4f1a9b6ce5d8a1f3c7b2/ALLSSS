### Title
Extra Block Producer Privilege Escalation via Unvalidated ExtraBlockProducerOfPreviousRound Field

### Summary
Any miner who produces a NextRound block can falsely set themselves as the `ExtraBlockProducerOfPreviousRound` without validation, gaining unauthorized extra block production privileges in the subsequent round. This breaks consensus fairness by allowing non-designated miners to produce blocks before the round starts and produce additional tiny blocks beyond their normal allocation.

### Finding Description

**Root Cause:**
When a miner produces a NextRound block to transition to the next consensus round, the `GetConsensusExtraDataForNextRound()` method unconditionally sets `ExtraBlockProducerOfPreviousRound` to the current block producer's public key without verifying they were actually the designated extra block producer of the current round. [1](#0-0) 

The `ProcessNextRound()` method accepts this field from the input without any validation against the actual extra block producer from the current round: [2](#0-1) 

**Why Protections Fail:**
The consensus behavior determination in `GetConsensusBehaviourToTerminateCurrentRound()` returns NextRound or NextTerm based solely on round number and term change conditions, with no check that the requesting miner is the designated extra block producer: [3](#0-2) 

The `PreCheck()` only validates that the miner is in the current or previous miner list, not their specific role: [4](#0-3) 

**Exploitation Path:**
Once a malicious miner falsely sets themselves as `ExtraBlockProducerOfPreviousRound`, they gain two unauthorized privileges in the next round:

1. **Early Mining Privilege**: `IsCurrentMiner()` allows them to mine before the round starts: [5](#0-4) 

2. **Extra Tiny Blocks**: `GetConsensusBehaviour()` allows them to produce additional tiny blocks beyond normal limits: [6](#0-5) 

### Impact Explanation

**Consensus Fairness Violation:**
- Malicious miners gain unfair advantage by producing more blocks than their allocated time slot
- Extra block producer role is critical for round termination and carries additional mining opportunities
- Multiple miners exploiting this simultaneously could concentrate block production

**Block Production Manipulation:**
- Attacker mines blocks before the round officially starts when only the legitimate extra block producer should be allowed
- Attacker produces `_maximumBlocksCount + blocksBeforeCurrentRound` tiny blocks instead of just `_maximumBlocksCount`
- This directly increases their block rewards and transaction fee collection

**Protocol Integrity:**
- Violates the fundamental consensus invariant that only the designated extra block producer has special privileges
- Breaks the AEDPoS round transition fairness mechanism
- Could lead to centralization if exploited systematically

**Severity: HIGH** - Direct consensus protocol violation allowing privilege escalation without requiring any special permissions beyond being a regular miner.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires being an active miner in the current round (achievable through normal election)
- No special privileges or compromised keys needed beyond regular miner status
- Can execute during normal consensus operations without detection

**Attack Complexity:**
- LOW - Simply requires producing the NextRound block when conditions allow
- Any miner whose time slot has passed can attempt to get NextRound behavior
- No complex transaction sequences or timing manipulation required

**Feasibility Conditions:**
- Occurs naturally whenever a non-extra-block-producer miner produces the NextRound block
- Main chain consensus allows any qualified miner to terminate the round based on timing
- No cryptographic challenges or resource-intensive operations needed

**Detection Constraints:**
- Difficult to detect as the field is accepted without validation
- Appears as normal round transition in logs
- Would require off-chain monitoring of actual vs. claimed extra block producers

**Economic Rationality:**
- Attack cost: Standard block production cost (gas fees)
- Attack benefit: Extra block production opportunities and increased rewards
- Highly profitable for malicious miners seeking unfair advantage

**Probability: HIGH** - Easily executable by any miner, low complexity, high reward, difficult to detect.

### Recommendation

**Immediate Fix:**
Add validation in `ProcessNextRound()` to verify the `ExtraBlockProducerOfPreviousRound` matches the actual extra block producer from the current round:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // VALIDATION: Verify ExtraBlockProducerOfPreviousRound is correct
    var actualExtraBlockProducer = currentRound.RealTimeMinersInformation.Values
        .Single(m => m.IsExtraBlockProducer).Pubkey;
    Assert(
        nextRound.ExtraBlockProducerOfPreviousRound == actualExtraBlockProducer,
        $"Invalid ExtraBlockProducerOfPreviousRound. Expected: {actualExtraBlockProducer}, Got: {nextRound.ExtraBlockProducerOfPreviousRound}"
    );
    
    RecordMinedMinerListOfCurrentRound();
    // ... rest of method
}
```

**Alternative Approach:**
Set the field server-side in `ProcessNextRound()` rather than accepting it from client input:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // OVERRIDE: Set correct value regardless of input
    nextRound.ExtraBlockProducerOfPreviousRound = currentRound.RealTimeMinersInformation.Values
        .Single(m => m.IsExtraBlockProducer).Pubkey;
    
    RecordMinedMinerListOfCurrentRound();
    // ... rest of method
}
```

**Test Cases:**
1. Verify non-extra-block-producer cannot produce NextRound block with their pubkey as ExtraBlockProducerOfPreviousRound
2. Verify NextRound transaction reverts if ExtraBlockProducerOfPreviousRound doesn't match actual extra block producer
3. Test that only legitimate extra block producer gains early mining privileges in next round
4. Verify tiny block count limits are enforced correctly for non-extra-block-producers

### Proof of Concept

**Initial State:**
- Current round has miners A, B, C, D, E
- Miner E is designated as extra block producer (IsExtraBlockProducer = true)
- Miner B has completed their time slot in the current round

**Attack Steps:**
1. Miner B's time slot passes and round is ready to terminate
2. Miner B calls consensus contract to get behavior → receives `AElfConsensusBehaviour.NextRound`
3. Miner B produces NextRound block, which triggers `GetConsensusExtraDataForNextRound()`
4. Line 178 executes: `nextRound.ExtraBlockProducerOfPreviousRound = "MinerB_Pubkey"`
5. `ProcessNextRound()` accepts the NextRoundInput without validation
6. Next round state is stored with `ExtraBlockProducerOfPreviousRound = "MinerB_Pubkey"`

**Next Round Exploitation:**
7. In next round, before round start time, Miner B calls `IsCurrentMiner()`
8. Line 150-151 check passes: `Context.CurrentBlockTime <= currentRound.GetRoundStartTime() && currentRound.ExtraBlockProducerOfPreviousRound == "MinerB_Pubkey"`
9. Returns `true` → Miner B can mine before round starts (should only be Miner E)
10. Miner B also gets increased tiny block limit via lines 71-79 in ConsensusBehaviourProviderBase

**Expected vs Actual Result:**
- Expected: Only Miner E (actual extra block producer) can mine before round start and get extra tiny blocks
- Actual: Miner B (non-extra-block-producer) gains these privileges by falsifying the field

**Success Condition:**
Miner B successfully produces blocks before the next round's official start time and produces more tiny blocks than their normal allocation, demonstrating unauthorized privilege escalation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-178)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-114)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L149-155)
```csharp
        // Check confirmed extra block producer of previous round.
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L70-79)
```csharp

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```
