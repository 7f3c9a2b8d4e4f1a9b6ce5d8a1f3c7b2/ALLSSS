### Title
Missing Options Count Validation During Registration Allows Unlimited Options

### Summary
The `Register()` function in VoteContract does not validate the number of options during voting item creation, allowing attackers to bypass the intended 64-option limit (`MaximumOptionsCount`) by registering voting items with unlimited options. While `AddOption()` correctly enforces the limit for post-registration additions, the initial registration bypasses this constraint entirely.

### Finding Description

The vulnerability exists in the `Register()` function where options are added without count validation: [1](#0-0) 

The validation helper `AssertValidNewVotingItem()` performs several checks but does not validate the option count: [2](#0-1) 

The system defines a maximum options limit of 64: [3](#0-2) 

While `AddOption()` correctly enforces this limit by checking the count before adding: [4](#0-3) 

And `AddOptions()` checks after adding (causing transaction revert if exceeded): [5](#0-4) 

The protobuf definition allows unlimited options in the registration input: [6](#0-5) 

**Root Cause:** The `Register()` function accepts the `input.Options` array directly without validating its length, while `AssertValidNewVotingItem()` only checks voting item uniqueness, timestamps, and snapshot numbers.

**Note on Original Question:** The specific attack path mentioned (register with exactly 64 options, then call `AddOption()`) does NOT work because `AddOption()` correctly prevents exceeding 64 by checking `Count < 64` before adding. However, the real vulnerability is that registration itself has no validation, allowing creation with 65+ options initially.

### Impact Explanation

**Operational Impact - DoS and Resource Exhaustion:**

1. **State Bloat:** Each option stored consumes blockchain state. An attacker could register voting items with thousands or millions of options, causing unbounded state growth.

2. **Gas Cost Attacks:** Operations that iterate over all options become prohibitively expensive:
   - `Vote()` function validates the option exists by checking `votingItem.Options.Contains(input.Option)`
   - Query operations retrieving voting items with massive option lists
   - Result aggregation across all options

3. **Degraded Protocol Performance:** Legitimate voting items become unusable if polluted with excessive options, disrupting governance or community voting processes.

4. **Design Constraint Violation:** The 64-option limit exists as a design constraint. Bypassing it may break assumptions in integrating systems or frontend applications expecting bounded option lists.

**Affected Parties:**
- Protocol users attempting to vote on items with excessive options face high gas costs
- Node operators storing bloated state
- Applications querying voting items

**Severity Justification:** Medium - While this doesn't directly steal funds or compromise consensus, it enables DoS attacks on the voting system and causes operational degradation through state bloat and gas cost manipulation.

### Likelihood Explanation

**High Likelihood:**

1. **Reachable Entry Point:** `Register()` is a public function callable by any user without special permissions.

2. **No Preconditions:** Attack requires only:
   - Normal registration parameters (token symbol, timestamps, etc.)
   - An options array with >64 elements

3. **Trivial Execution:** 
   ```
   VotingRegisterInput input = new VotingRegisterInput {
       Options = { /* 100+ option strings */ },
       // ... other fields
   }
   VoteContract.Register(input);
   ```

4. **Economic Rationality:** Registration cost is fixed regardless of option count, making the attack economically viable.

5. **No Detection:** The contract emits `VotingItemRegistered` event but doesn't include option count, making excessive options hard to detect until queried.

### Recommendation

**Immediate Fix:**

Add option count validation in the `Register()` function or `AssertValidNewVotingItem()`:

```csharp
// In AssertValidNewVotingItem() before returning:
Assert(input.Options.Count <= VoteContractConstants.MaximumOptionsCount,
    $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**Additional Checks:**

1. Validate option length in registration (currently only checked in `AssertOption()`):
   ```csharp
   foreach (var option in input.Options)
   {
       Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid option length.");
   }
   ```

2. Check for duplicate options during registration to prevent option list padding attacks.

**Test Case:**

Add a test that attempts to register with >64 options and expects failure:

```csharp
[Fact]
public async Task Register_With_Excessive_Options_Should_Fail()
{
    var input = new VotingRegisterInput {
        Options = { GenerateOptions(65) }, // 65 > MaximumOptionsCount
        // ... other valid fields
    };
    var result = await VoteContractStub.Register.SendWithExceptionAsync(input);
    result.TransactionResult.Error.ShouldContain("can't greater than 64");
}
```

### Proof of Concept

**Initial State:**
- Any user with a valid address
- Token symbol in whitelist for voting

**Attack Steps:**

1. **Create malicious registration input:**
   ```
   VotingRegisterInput input = {
       StartTimestamp: now,
       EndTimestamp: now + 10 days,
       AcceptedCurrency: "ELF",
       IsLockToken: true,
       TotalSnapshotNumber: 1,
       Options: ["Option1", "Option2", ..., "Option100"], // 100 options
       IsQuadratic: false
   }
   ```

2. **Call Register():**
   ```
   VoteContract.Register(input)
   ```

3. **Expected Result:** Transaction fails with option count validation error

4. **Actual Result:** Transaction succeeds, voting item created with 100 options

5. **Verification:** 
   - Query `GetVotingItem()` returns item with 100 options
   - Subsequent `AddOption()` calls fail because count already exceeds 64
   - State contains voting item violating the 64-option invariant

**Success Condition:** Voting item exists with `Options.Count > MaximumOptionsCount` (64), proving the limit bypass.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L49-49)
```csharp
            Options = { input.Options },
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L285-286)
```csharp
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L319-321)
```csharp
        votingItem.Options.AddRange(input.Options);
        Assert(votingItem.Options.Count <= VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-5)
```csharp
    public const int MaximumOptionsCount = 64;
```

**File:** protobuf/vote_contract.proto (L99-99)
```text
    repeated string options = 6;
```
