### Title
Consensus Behavior Substitution Allows Miners to Bypass Cryptographic Value Publication

### Summary
A miner producing their first block in a round can incorrectly use `TinyBlock` behavior instead of the required `UpdateValue` behavior, avoiding publication of essential consensus values (OutValue, Signature, PreviousInValue). This breaks the consensus randomness mechanism and creates inconsistent state where miners produce blocks without contributing to the cryptographic chain, ultimately being misclassified as non-mining nodes in subsequent rounds.

### Finding Description

**Root Cause**: Missing validation to enforce correct behavior type selection based on miner state.

The consensus system has two block production behaviors with different data requirements:
- `UpdateValue`: Used for first block in round, requires OutValue, Signature, PreviousInValue [1](#0-0) 
- `TinyBlock`: Used for subsequent blocks, excludes these fields [2](#0-1) 

The behavior determination logic shows miners should use `UpdateValue` when `OutValue == null` (first block in round): [3](#0-2) 

However, during validation, no check enforces this requirement. The validation only recovers data based on the claimed behavior without verifying the behavior itself is correct: [4](#0-3) 

For `TinyBlock` behavior, `UpdateValueValidationProvider` is never added to the validation pipeline, allowing miners to bypass OutValue/Signature validation: [5](#0-4) 

The recovery function for TinyBlock only copies ActualMiningTimes and ImpliedIrreversibleBlockHeight, completely ignoring OutValue, Signature, and PreviousInValue even if present: [6](#0-5) 

Processing TinyBlock only updates block counts without setting consensus values: [7](#0-6) 

Since `ApplyNormalConsensusData` (which sets `SupposedOrderOfNextRound` based on signature) is never called, the miner's order field remains 0: [8](#0-7) 

### Impact Explanation

**Consensus Integrity Breach**:
1. Miners produce blocks (ProducedBlocks incremented) but OutValue/Signature/PreviousInValue remain null
2. The cryptographic chain is broken - missing values prevent proper randomness contribution
3. Next round generation classifies these miners as non-mining (`SupposedOrderOfNextRound == 0`) despite block production: [9](#0-8) 
4. Miners are incorrectly penalized with incremented MissedTimeSlots: [10](#0-9) 
5. Extra block producer selection relies on signature availability, defaulting to order 1 if no signatures exist: [11](#0-10) 

**Protocol Damage**: If multiple miners exploit this, consensus randomness degrades significantly as signature-based mining order determination fails. The system enters an inconsistent state where block production occurs without corresponding consensus value updates, breaking the fundamental commit-reveal scheme underlying AEDPoS security.

**Affected Parties**: All network participants suffer from compromised consensus integrity and predictable/manipulable block producer ordering.

### Likelihood Explanation

**Attacker Capabilities**: Must be a legitimate consensus miner with block production rights.

**Attack Complexity**: Low - requires only sending TinyBlock consensus transaction when UpdateValue is expected. No complex state manipulation needed.

**Feasibility Conditions**:
- Attacker is in active miner set
- Attacker is within their assigned time slot
- No validator checks correct behavior for miner's state (OutValue null/not-null)

**Detection**: Observable on-chain through missing OutValue/Signature fields in round state for miners who produced blocks.

**Economic Rationality**: Attack is detectable but miner gets penalized (MissedTimeSlots incremented, treated as non-miner in next round). More likely as griefing/disruption attack rather than direct profit motive. However, coordinated attack by multiple miners could manipulate next round ordering.

**Probability**: Medium - requires miner role but straightforward execution once access obtained.

### Recommendation

Add behavior enforcement validation that checks whether the claimed behavior matches the miner's current state:

1. In `AEDPoSContract_Validation.cs`, before behavior-specific validation providers are added, insert a new validator:

```csharp
// After line 75 in ValidateBeforeExecution, before the switch statement:
validationProviders.Add(new ConsensusBehaviourValidationProvider());
```

2. Create new validation provider `ConsensusBehaviourValidationProvider.cs`:

```csharp
public class ConsensusBehaviourValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var behaviour = validationContext.ExtraData.Behaviour;
        
        // If OutValue is null, this is the first block in round - must use UpdateValue
        if (minerInRound.OutValue == null && 
            behaviour == AElfConsensusBehaviour.TinyBlock &&
            !IsExtraBlockProducerBeforeRoundStart(validationContext))
        {
            return new ValidationResult 
            { 
                Message = "TinyBlock behaviour not allowed for first block in round. Must use UpdateValue." 
            };
        }
        
        return new ValidationResult { Success = true };
    }
    
    private bool IsExtraBlockProducerBeforeRoundStart(ConsensusValidationContext context)
    {
        return context.BaseRound.ExtraBlockProducerOfPreviousRound == context.SenderPubkey &&
               context.ExtraData.Round.GetRoundStartTime() > context.BaseRound.GetRoundStartTime();
    }
}
```

3. Add test case verifying rejection of TinyBlock when OutValue is null for normal miners.

### Proof of Concept

**Initial State**:
- Miner M is in active miner set for round R
- M has not yet produced any block in round R (OutValue is null)
- Current time is within M's allocated time slot
- M has block production permissions

**Attack Steps**:
1. M calls `GetConsensusCommand` - system correctly returns UpdateValue behavior
2. M ignores the correct behavior and manually constructs TinyBlock consensus transaction:
   - Set Behaviour = TinyBlock
   - Set ActualMiningTime within time slot
   - Set ImpliedIrreversibleBlockHeight
   - Omit OutValue, Signature, PreviousInValue
3. M submits block with TinyBlock consensus header

**Validation Flow**:
1. `ValidateBeforeExecution` extracts Behaviour = TinyBlock [12](#0-11) 
2. `RecoverFromTinyBlock` only copies ActualMiningTime (OutValue remains null)
3. TimeSlotValidationProvider passes (time within slot)
4. MiningPermissionValidationProvider passes (M is valid miner)
5. ContinuousBlocksValidationProvider passes (not excessive continuous blocks)
6. UpdateValueValidationProvider NOT executed (only for UpdateValue behaviour)
7. Validation succeeds

**Processing**:
1. `ProcessTinyBlock` increments ProducedBlocks but does not set OutValue/Signature/PreviousInValue [7](#0-6) 
2. Round state stored with M's OutValue still null despite block production

**Result**:
- **Expected**: M's OutValue, Signature, PreviousInValue recorded; SupposedOrderOfNextRound calculated
- **Actual**: M produced block but OutValue/Signature/PreviousInValue remain null; SupposedOrderOfNextRound remains 0

**Verification**: Query round state after M's block - M.ProducedBlocks > 0 but M.OutValue == null and M.SupposedOrderOfNextRound == 0, confirming inconsistent state.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-56)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = pubkey,
                    OutValue = minerInRound.OutValue,
                    Signature = minerInRound.Signature,
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    PreviousInValue = minerInRound.PreviousInValue,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
                    Order = minerInRound.Order,
                    IsExtraBlockProducer = minerInRound.IsExtraBlockProducer
                }
            }
        };
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }

        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L58-82)
```csharp
    public Round GetTinyBlockRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = minerInRound.Pubkey,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight
                }
            }
        };

        foreach (var otherPubkey in RealTimeMinersInformation.Keys.Except(new List<string> { pubkey }))
            round.RealTimeMinersInformation.Add(otherPubkey, new MinerInRound());

        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-56)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-47)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L46-56)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-135)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }

    private List<MinerInRound> GetNotMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound == 0).ToList();
    }
```
