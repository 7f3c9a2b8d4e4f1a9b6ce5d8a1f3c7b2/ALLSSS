# Audit Report

## Title
Unvalidated Extra Block Producer Invariant Enables Consensus DoS via Single() Exception

## Summary
The `IsCurrentMiner` function enforces that exactly one miner has `IsExtraBlockProducer=true` by using `.Single()`, which throws `InvalidOperationException` if this invariant is violated. Byzantine miners can submit `NextRoundInput` with corrupted round data (zero or multiple extra block producers) that bypasses all validation checks, causing denial of service for cross-chain indexing and other consensus operations.

## Finding Description

The vulnerability exists because round data submitted by miners is not properly validated before storage.

**Root Cause - Unsafe Direct Copy:**

When miners submit `NextRound`, the input is converted via `ToRound()` which directly copies all fields including the `RealTimeMinersInformation` dictionary with all `IsExtraBlockProducer` flags, without any regeneration or validation of the extra block producer invariant. [1](#0-0) 

This converted round is then stored directly into state: [2](#0-1) [3](#0-2) 

**Missing Validation:**

The validation logic for `NextRound` only checks round number increment, mining order consistency, and InValue nullness - but NOT the extra block producer count: [4](#0-3) [5](#0-4) [6](#0-5) 

**Dangerous Assumption:**

The `IsCurrentMiner` function assumes exactly one extra block producer exists and uses `.Single()` which throws if this invariant is violated: [7](#0-6) 

Similarly, `GetExtraBlockProducerInformation()` uses `.First()` which throws on empty sequences: [8](#0-7) 

**Attack Flow:**

1. Byzantine miner constructs `NextRoundInput` where zero or multiple miners have `IsExtraBlockProducer = true`
2. Submits via `NextRound()` during their mining turn (permission check only verifies miner status, not input validity)
3. Corrupted round data passes all validation and gets stored
4. Subsequent operations calling `IsCurrentMiner` throw `InvalidOperationException`

**Impact Demonstration:**

Cross-chain indexing operations are completely blocked because they require the `IsCurrentMiner` check: [9](#0-8) [10](#0-9) [11](#0-10) [12](#0-11) 

## Impact Explanation

**Severity: HIGH - Complete Operational DoS**

The vulnerability causes complete denial of service for critical protocol operations:

1. **Cross-Chain Communication Halted**: Miners cannot propose or release cross-chain indexing data, completely blocking parent-child chain communication until the corrupted round ages out

2. **Consensus Operations Disrupted**: Any operation depending on `IsCurrentMiner` or `GetExtraBlockProducerInformation` fails with exceptions, including abnormal mining time arrangement

3. **No Fund Loss but Severe Protocol Disruption**: While no funds are directly at risk, the inability to perform cross-chain operations and consensus coordination represents a critical protocol failure

4. **Recovery Requires Time or Governance**: The corrupted round data persists in state until it ages out (determined by `AEDPoSContractConstants.KeepRounds`) or governance intervention occurs

## Likelihood Explanation

**Probability: MEDIUM**

**Attacker Requirements:**
- Must be an active miner (reduces likelihood as miners have stake at risk)
- Must wait for their scheduled mining turn (timing constraint)

**Attack Complexity: TRIVIAL**
- No cryptographic bypasses required
- Simple modification of `IsExtraBlockProducer` flags in `NextRoundInput`
- Attack is immediately executable once conditions are met

**Economic Considerations:**
- Economically irrational for long-term honest miners (reputation damage, potential slashing)
- Feasible for compromised nodes or attackers willing to sacrifice miner stake for temporary disruption
- Attack is immediately visible and traceable to the malicious miner

**Realistic Threat Scenario:**
Byzantine fault tolerance assumes some percentage of miners may be compromised or malicious. This attack is trivially executable by any such miner during their turn.

## Recommendation

Add validation to enforce the extra block producer invariant before storing round data:

```csharp
// In AEDPoSContract_Validation.cs, add a new validation provider:
public class ExtraBlockProducerValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        
        var extraBlockProducerCount = providedRound.RealTimeMinersInformation.Values
            .Count(m => m.IsExtraBlockProducer);
            
        if (extraBlockProducerCount != 1)
        {
            validationResult.Message = $"Invalid extra block producer count: {extraBlockProducerCount}. Expected exactly 1.";
            return validationResult;
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}

// Add this provider to validation for NextRound and NextTerm behaviors:
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new ExtraBlockProducerValidationProvider()); // Add this
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new ExtraBlockProducerValidationProvider()); // Add this
    break;
```

Additionally, consider using defensive coding in `IsCurrentMiner`:

```csharp
// Use FirstOrDefault instead of Single to prevent exceptions
var supposedExtraBlockProducer = currentRound.RealTimeMinersInformation
    .FirstOrDefault(m => m.Value.IsExtraBlockProducer).Key;
    
if (supposedExtraBlockProducer == null)
{
    Context.LogDebug(() => "No extra block producer found in current round");
    return false;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task Test_ExtraBlockProducerInvariantViolation_CausesDoS()
{
    // Setup: Initialize consensus with valid round
    await InitializeConsensusAsync();
    
    // Get current miner
    var minerKeyPair = InitialCoreDataCenterKeyPairs[0];
    var minerAddress = Address.FromPublicKey(minerKeyPair.PublicKey);
    
    // Create malicious NextRoundInput with ZERO extra block producers
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = 2,
        RealTimeMinersInformation = 
        {
            // Add miners but set IsExtraBlockProducer = false for all
            InitialCoreDataCenterKeyPairs.Select((kp, i) => new
            {
                Key = kp.PublicKey.ToHex(),
                Value = new MinerInRound
                {
                    Pubkey = kp.PublicKey.ToHex(),
                    Order = i + 1,
                    IsExtraBlockProducer = false // VIOLATES INVARIANT
                }
            }).ToDictionary(x => x.Key, x => x.Value)
        }
    };
    
    // Submit malicious round (should pass validation but shouldn't)
    var submitResult = await ConsensusStub.NextRound.SendAsync(maliciousInput);
    submitResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify DoS: IsCurrentMiner now throws
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await ConsensusStub.IsCurrentMiner.CallAsync(minerAddress);
    });
    
    // Verify cross-chain operations are blocked
    var crossChainException = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await CrossChainStub.ProposeCrossChainIndexing.SendAsync(new CrossChainBlockData());
    });
    
    exception.Message.ShouldContain("Sequence contains no matching element"); // .Single() exception
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-170)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-290)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-301)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```
