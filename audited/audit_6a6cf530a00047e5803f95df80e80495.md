# Audit Report

## Title
Dictionary Access Without Key Validation in IsCurrentMiner During Miner List Changes Causes KeyNotFoundException

## Summary
The `IsCurrentMiner` private method in the AEDPoS consensus contract contains a conditional safety check that is bypassed when the miner list has just changed (`IsMinerListJustChanged = true`). This leads to unguarded dictionary accesses that throw `KeyNotFoundException` when removed miners attempt to call authorization-protected functions during term transitions or miner replacements, causing transaction failures and operational disruption.

## Finding Description

The vulnerability exists in the `IsCurrentMiner(string pubkey)` private method where a safety check only validates dictionary key existence when the miner list has NOT changed: [1](#0-0) 

When `IsMinerListJustChanged` is true, this check is completely bypassed, yet the code proceeds to directly access the `RealTimeMinersInformation` dictionary without validation: [2](#0-1) 

The `IsMinerListJustChanged` flag is set to true in two scenarios:

1. When generating the first round of a new term: [3](#0-2) 

2. When replacing evil miners within a term: [4](#0-3) 

The vulnerability is triggered when `ConvertAddressToPubkey` returns a pubkey that exists in the previous round but not in the current round, because it searches BOTH rounds: [5](#0-4) 

Additional vulnerable dictionary accesses exist at line 182 which calls `ArrangeAbnormalMiningTime`, containing another unguarded access: [6](#0-5) 

And at line 205 using `.Single()` which throws if the key doesn't exist: [7](#0-6) 

The public entry points that internally invoke `IsCurrentMiner` include:

**ClaimTransactionFees:** [8](#0-7) [9](#0-8) 

**DonateResourceToken:** [10](#0-9) 

**ProposeCrossChainIndexing:** [11](#0-10) [12](#0-11) [13](#0-12) 

**ReleaseCrossChainIndexingProposal:** [14](#0-13) 

## Impact Explanation

**Operational Impact - Critical DoS:**
- Transaction failures via `KeyNotFoundException` during term transitions and miner replacements
- Affects critical system operations: `ClaimTransactionFees`, `DonateResourceToken`, `ProposeCrossChainIndexing`, `ReleaseCrossChainIndexingProposal`
- Removed miners cannot complete legitimate operations (e.g., claiming accumulated transaction fees from their last blocks before removal)
- System instability during consensus transitions, which are regularly occurring events in AEDPoS

**Affected Parties:**
- Removed/replaced miners who need to claim fees or perform cross-chain operations
- The broader network during term transitions when multiple miners may be replaced simultaneously
- Cross-chain indexing operations become unavailable if executed by recently removed miners

**Severity Justification:**
This is a Critical severity issue because it causes guaranteed transaction failures during normal protocol operation (term changes), affects multiple core system functions, and creates operational disruption without requiring any malicious intent. The DoS impact is deterministic and affects consensus-critical operations.

## Likelihood Explanation

**Reachable Entry Point:**
Public methods `ClaimTransactionFees`, `DonateResourceToken`, `ProposeCrossChainIndexing`, and `ReleaseCrossChainIndexingProposal` are callable by any miner address and internally invoke `IsCurrentMiner`.

**Feasible Preconditions:**
- Term changes occur regularly in AEDPoS (every `PeriodSeconds` configured in the protocol)
- Miner replacements occur when miners miss too many time slots (evil node detection)
- No attacker capabilities required - happens during normal protocol operation

**Execution Practicality:**
1. Wait for or trigger a term change/miner replacement (natural protocol behavior)
2. As a removed miner, call `ClaimTransactionFees()` or similar function to claim legitimately earned fees
3. `IsCurrentMiner` receives pubkey from previous round via `ConvertAddressToPubkey`
4. Safety check at lines 142-144 is bypassed because `IsMinerListJustChanged = true`
5. Dictionary access at line 158, 182, or 205 throws `KeyNotFoundException`

**Economic Rationality:**
Zero attack cost - this occurs during legitimate protocol operations. Removed miners have strong economic incentive to claim transaction fees they earned before removal, making this scenario highly probable.

**Probability:**
High probability during every term transition or miner replacement event, affecting any removed miner who attempts to perform protected operations. Given that term transitions are regular events and miners legitimately want to claim earned fees, this vulnerability will be triggered frequently.

## Recommendation

Add proper key validation before all dictionary accesses, regardless of the `IsMinerListJustChanged` flag value:

```csharp
private bool IsCurrentMiner(string pubkey)
{
    if (pubkey == null) return false;

    if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;

    // Always validate key existence before accessing dictionary
    if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
        return false;

    // ... rest of the method
}
```

Alternatively, use `TryGetValue` pattern for safe dictionary access:

```csharp
if (!currentRound.RealTimeMinersInformation.TryGetValue(pubkey, out var minerInRound))
    return false;
```

Also fix the `ArrangeAbnormalMiningTime` method to validate key existence before accessing the dictionary:

```csharp
public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
    bool mustExceededCurrentRound = false)
{
    var miningInterval = GetMiningInterval();

    if (!RealTimeMinersInformation.TryGetValue(pubkey, out var minerInRound))
        return currentBlockTime; // or throw appropriate exception

    // ... rest of the method
}
```

## Proof of Concept

```csharp
[Fact]
public async Task IsCurrentMiner_ThrowsKeyNotFoundException_WhenMinerRemovedDuringListChange()
{
    // Setup: Initialize consensus with multiple miners
    await InitializeConsensusAsync();
    
    // Create a miner that will be removed
    var removedMinerKeyPair = CryptoHelper.GenerateKeyPair();
    var removedMinerAddress = Address.FromPublicKey(removedMinerKeyPair.PublicKey);
    
    // Simulate term transition where this miner is removed
    // IsMinerListJustChanged will be set to true
    // The removed miner's pubkey exists in previous round but not current round
    await SimulateTermTransitionWithMinerRemoval(removedMinerKeyPair);
    
    // Act: Removed miner attempts to claim transaction fees
    // This should throw KeyNotFoundException due to unguarded dictionary access
    var exception = await Record.ExceptionAsync(async () =>
    {
        await TokenContractStub.ClaimTransactionFees.SendAsync(new TotalTransactionFeesMap());
    });
    
    // Assert: Verify KeyNotFoundException is thrown
    exception.ShouldNotBeNull();
    exception.ShouldBeOfType<KeyNotFoundException>();
}
```

## Notes

The vulnerability stems from an incorrect assumption that when `IsMinerListJustChanged` is true, all pubkeys returned by `ConvertAddressToPubkey` will exist in the current round's dictionary. However, `ConvertAddressToPubkey` searches BOTH current and previous rounds, meaning it can return pubkeys of removed miners that only exist in the previous round. This creates a race condition during consensus transitions where removed miners cannot perform legitimate operations without causing transaction failures.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L128-130)
```csharp
        var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
        if (TryToGetPreviousRoundInformation(out var previousRound))
            possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L142-144)
```csharp
        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L158-158)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L205-205)
```csharp
                    currentRound.RealTimeMinersInformation.Single(i => i.Key == pubkey).Value.Order;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L341-341)
```csharp
                isMinerListChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L42-42)
```csharp
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L24-24)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L867-869)
```csharp
    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L897-905)
```csharp
    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L913-915)
```csharp
    public override Empty DonateResourceToken(TotalResourceTokensMaps input)
    {
        AssertSenderIsCurrentMiner();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-286)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-297)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-294)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-27)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
```
