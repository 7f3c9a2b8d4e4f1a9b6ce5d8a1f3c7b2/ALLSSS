# Audit Report

## Title
Scheme Manager Can Modify Critical Parameters After User Registration, Breaking Withdrawal and Lock Period Expectations

## Summary
The TokenHolder contract's `CreateScheme` method lacks protection against repeated invocation by the same manager, allowing scheme parameters (Symbol, MinimumLockMinutes, AutoDistributeThreshold) to be overwritten after users have already registered and locked tokens. This creates a critical mismatch where users lock tokens with one set of parameters but must withdraw using different parameters, causing permanent fund lockup or arbitrary lock period extensions.

## Finding Description

The `CreateScheme` method unconditionally overwrites scheme parameters without any existence check: [1](#0-0) 

The method directly assigns a new `TokenHolderProfitScheme` to `State.TokenHolderProfitSchemes[Context.Sender]` at line 27-32 without validation. Each invocation creates a NEW scheme in the underlying Profit contract with a different SchemeId: [2](#0-1) 

The Profit contract generates unique schemeIds based on the count of existing schemes (line 56-70), allowing multiple schemes per manager.

When users register, they lock tokens based on the CURRENT scheme parameters: [3](#0-2) 

Tokens are locked with `scheme.Symbol` (line 162), and the lockId is stored (line 166). However, when users withdraw, the contract retrieves the CURRENT scheme parameters from state: [4](#0-3) 

The withdrawal logic uses the current `scheme.Symbol` to query locked amounts (line 220-225), validates against the current `scheme.MinimumLockMinutes` (line 227), and unlocks using the current `scheme.Symbol` (line 230-236).

MultiToken's lock/unlock operations are symbol-specific. The `GetLockedAmount` method queries balances for a specific symbol: [5](#0-4) 

If parameters change between lock and unlock, the symbol mismatch causes the query to return 0, and the unlock operation fails to release the originally locked tokens.

## Impact Explanation

**Symbol Modification Attack:** If a manager changes Symbol from "ELF" to "BTC" after users lock ELF tokens, the `Withdraw` function queries locked amounts for "BTC" (returning 0 since tokens were locked as "ELF") and attempts to unlock "BTC" tokens. This leaves users' ELF tokens permanently locked with no recovery mechanism, as the lockId-symbol pair no longer matches.

**MinimumLockMinutes Extension Attack:** If a manager increases MinimumLockMinutes from 1440 minutes (1 day) to 43200 minutes (30 days) after users register, users expecting to withdraw after 1 day find their funds inaccessible for 30 days. This can be repeated indefinitely by calling `CreateScheme` again with even longer lock periods, effectively enabling permanent fund seizure.

**AutoDistributeThreshold Manipulation:** Changing distribution thresholds alters when and how profits are distributed to existing participants who registered under different expectations, disrupting expected reward flows.

This represents direct fund theft/seizure capability for scheme managers, violating the fundamental security guarantee that users control when they can withdraw their locked tokens after the agreed-upon lock period expires.

## Likelihood Explanation

**Reachable Entry Point:** `CreateScheme` is a public method at line 14 with no authorization restrictions beyond being callable by any address. Nothing prevents the same manager from calling it multiple times.

**Feasible Preconditions:** The attacker must be the scheme manager, which is simply the address that initially called `CreateScheme`. This is not a privileged admin role but a standard user capability. Any scheme creator, whether malicious initially or later compromised, can execute this attack.

**Execution Practicality:** The attack requires only two simple transactions: (1) Initial `CreateScheme` call to establish a scheme and attract users, then (2) Second `CreateScheme` call with modified parameters. No complex contract interactions, timing windows, or external dependencies exist.

**Economic Rationality:** Attack cost is minimal (two transaction gas fees), but enables trapping arbitrary amounts of user funds. A malicious scheme manager could profit by collecting user contributions/profits while preventing stake withdrawals, or by extorting users to return their funds.

The absence of any test case verifying that `CreateScheme` cannot be called twice suggests this attack vector was not considered during development.

## Recommendation

Add an existence check in `CreateScheme` to prevent overwriting existing schemes:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add this check
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists for this manager.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, implement a dedicated `UpdateScheme` method with proper safeguards that migrates existing user locks to new parameters, or prevents updates while users have active locks.

## Proof of Concept

```csharp
[Fact]
public async Task CreateScheme_Twice_Causes_Withdrawal_Failure()
{
    var manager = Starter;
    var user = UserAddresses.First();
    var lockAmount = 1000L;
    
    // Manager creates initial scheme with ELF symbol
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1  // 1 minute for testing
    });
    
    // User registers and locks ELF tokens
    var userStub = GetTester<TokenHolderContractImplContainer.TokenHolderContractImplStub>(
        TokenHolderContractAddress, UserKeyPairs.First());
    await userStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = lockAmount,
        SchemeManager = manager
    });
    
    // Verify tokens are locked
    var beforeBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = "ELF",
        Owner = user
    })).Balance;
    
    // Manager maliciously calls CreateScheme again with different symbol
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "BTC",  // Different symbol!
        MinimumLockMinutes = 1
    });
    
    // Wait for lock period to expire
    await Task.Delay(70000);  // Wait >1 minute
    
    // User tries to withdraw - THIS WILL FAIL
    var withdrawResult = await userStub.Withdraw.SendWithExceptionAsync(manager);
    
    // Withdrawal fails because it queries for "BTC" locked amount (which is 0)
    // while user's tokens are locked as "ELF"
    var afterBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = "ELF",
        Owner = user
    })).Balance;
    
    // User's balance hasn't increased - tokens remain locked!
    afterBalance.ShouldBe(beforeBalance);
    
    // User's ELF tokens are now permanently locked
}
```

This test demonstrates that after the manager calls `CreateScheme` twice with different symbols, users cannot withdraw their locked tokens even after the lock period expires, resulting in permanent fund lockup.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-177)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-244)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L44-84)
```csharp
    public override Hash CreateScheme(CreateSchemeInput input)
    {
        ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);

        if (input.ProfitReceivingDuePeriodCount == 0)
            input.ProfitReceivingDuePeriodCount = ProfitContractConstants.DefaultProfitReceivingDuePeriodCount;
        else
            Assert(
                input.ProfitReceivingDuePeriodCount > 0 &&
                input.ProfitReceivingDuePeriodCount <= ProfitContractConstants.MaximumProfitReceivingDuePeriodCount,
                "Invalid profit receiving due period count.");

        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
        State.SchemeInfos[schemeId] = scheme;

        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;

        Context.LogDebug(() => $"Created scheme {State.SchemeInfos[schemeId]}");

        Context.Fire(new SchemeCreated
        {
            SchemeId = scheme.SchemeId,
            Manager = scheme.Manager,
            IsReleaseAllBalanceEveryTimeByDefault = scheme.IsReleaseAllBalanceEveryTimeByDefault,
            ProfitReceivingDuePeriodCount = scheme.ProfitReceivingDuePeriodCount,
            VirtualAddress = scheme.VirtualAddress
        });
        return schemeId;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-116)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
    }
```
