# Audit Report

## Title
Unauthorized Candidate Registration Enables Preemptive DoS Attack on Election System

## Summary
The `AnnounceElectionFor()` function in the Election contract lacks authorization checks to verify that the caller owns or has permission to register a given public key as a candidate. An attacker can force-register arbitrary public keys by paying the lock deposit, permanently preventing legitimate owners from announcing their candidacy and requiring Parliament intervention to recover.

## Finding Description

The vulnerability exists in the `AnnounceElectionFor()` function which accepts any public key string as input without verifying the caller's ownership or authorization. [1](#0-0) 

The function directly calls the internal `AnnounceElection(byte[] pubkeyBytes)` method at line 126 without any authorization check that verifies `Context.Sender` owns the private key corresponding to the provided public key. [2](#0-1) 

The internal method enforces that a public key can only be registered once as a current candidate through an assertion that prevents re-registration. [3](#0-2)  Once a public key is registered with `IsCurrentCandidate = true`, any subsequent registration attempt will fail with "This public key already announced election."

In contrast, the legitimate `AnnounceElection(Address input)` method properly verifies ownership by recovering the public key from the transaction signature using `Context.RecoverPublicKey()`, ensuring the caller actually owns the private key. [4](#0-3) 

The attacker sets themselves as the admin for the registered public key. If no admin is explicitly provided in the input, it defaults to `Context.Sender` (the attacker). [5](#0-4)  The admin field controls who can subsequently quit the election or modify admin rights.

Recovery mechanisms are blocked because `SetCandidateAdmin()` requires the caller to be either the current admin (the attacker) or Parliament default address. [6](#0-5)  Once an admin is set, the legitimate public key owner cannot override it without Parliament intervention.

**Attack Sequence:**
1. Attacker calls `AnnounceElectionFor({ Pubkey: "victim_public_key", Admin: attacker_address })` (or omits Admin to default to themselves)
2. Contract locks 100,000 tokens from attacker's balance [7](#0-6) 
3. Victim's public key is registered with attacker as admin
4. Internal check prevents victim from re-registering using either `AnnounceElection()` or `AnnounceElectionFor()`
5. Victim cannot participate in elections or receive mining rewards
6. Only Parliament can change the admin to allow victim to regain control

## Impact Explanation

**Governance Disruption**: An attacker can systematically prevent legitimate validators from participating in elections, effectively censoring candidates and centralizing power to attacker-controlled or pre-existing candidates only. This breaks the decentralized election mechanism that is fundamental to AElf's consensus.

**Candidate Lockout**: Legitimate public key owners lose the ability to register themselves for candidacy, blocking their eligibility for mining rewards, governance participation, and profit distribution from the subsidy scheme. [8](#0-7) 

**Requires Emergency Governance**: Recovery requires Parliament default organization to manually override admin controls for each affected public key, consuming governance bandwidth and delaying election processes.

**Quantified Damage**:
- Attack cost: 100,000 tokens per public key registered
- For typical blockchain with 17-21 miners, validation data center count would be 85-105 (5x multiplier) [9](#0-8) 
- Total attack cost for complete DoS: 8.5M - 10.5M tokens
- Attacker can potentially recover tokens later by quitting elections, reducing net cost

## Likelihood Explanation

**Attacker Capabilities Required**:
- Sufficient token balance to pay lock deposits (100,000 tokens per target)
- Knowledge of target public keys (publicly available for known validators on-chain)
- Ability to execute transactions faster than legitimate candidates (frontrunning potential)

**Attack Complexity**:
- **Low technical complexity**: Single contract call with target public key string
- **No special permissions**: Any account with sufficient token balance can execute
- **Automation feasible**: Can target multiple candidates in parallel transactions

**Economic Feasibility**:
- **Targeted attack** (10-20 key validators): 1M-2M tokens - highly feasible for motivated attacker
- **Complete DoS** (85-105 candidates): 8.5M-10.5M tokens - feasible for well-funded adversary or competitor
- **Reduced net cost**: Tokens can be recovered by calling `QuitElection()` later [10](#0-9) 
- **High-value scenarios**: Governance takeover, competitor elimination, or manipulation justify costs

**Detection/Prevention**:
- No on-chain detection mechanism exists before damage occurs
- Once executed, requires Parliament governance action to remediate
- Legitimate candidates may not realize they're locked out until attempting registration

## Recommendation

Add authorization check to `AnnounceElectionFor()` to verify the caller has permission to register the given public key:

```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var pubkey = input.Pubkey;
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
    var address = Address.FromPublicKey(pubkeyBytes);
    
    // ADD THIS CHECK: Verify the caller is authorized to register this pubkey
    // Option 1: Require a signature from the pubkey owner in the input
    // Option 2: Require the pubkey owner to pre-approve the sponsor
    // Option 3: Require Context.Sender to be the pubkey owner (defeats sponsorship purpose)
    
    // For sponsorship use cases, implement approval mechanism:
    Assert(State.CandidateRegistrationApprovals[pubkey][Context.Sender], 
        "Sponsor not approved by pubkey owner.");
    
    AnnounceElection(pubkeyBytes);
    // ... rest of function
}

// Add approval function:
public override Empty ApproveCandidateRegistration(ApproveCandidateRegistrationInput input)
{
    var recoveredPublicKey = Context.RecoverPublicKey();
    var pubkey = recoveredPublicKey.ToHex();
    State.CandidateRegistrationApprovals[pubkey][input.Sponsor] = true;
    return new Empty();
}
```

Alternatively, if sponsorship without pre-approval is required, always set the admin to the public key owner address (derived from the pubkey), not the sponsor:

```csharp
var admin = input.Admin ?? Address.FromPublicKey(pubkeyBytes); // Not Context.Sender
```

## Proof of Concept

```csharp
[Fact]
public async Task AnnounceElectionFor_Unauthorized_DoS_Attack()
{
    // Victim's keypair (legitimate candidate)
    var victimKeyPair = ValidationDataCenterKeyPairs.First();
    var victimPubkey = victimKeyPair.PublicKey.ToHex();
    
    // Attacker's keypair (malicious sponsor)
    var attackerKeyPair = ValidationDataCenterKeyPairs.Last();
    
    // Attacker announces election for victim's pubkey WITHOUT permission
    var attackerStub = GetElectionContractTester(attackerKeyPair);
    await attackerStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = victimPubkey,
        Admin = Address.FromPublicKey(attackerKeyPair.PublicKey) // Attacker sets self as admin
    });
    
    // Verify victim's pubkey is now registered
    var candidateInfo = await ElectionContractStub.GetCandidateInformation.CallAsync(
        new StringValue { Value = victimPubkey });
    candidateInfo.IsCurrentCandidate.ShouldBeTrue();
    
    // Verify attacker controls the admin
    var admin = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = victimPubkey });
    admin.ShouldBe(Address.FromPublicKey(attackerKeyPair.PublicKey));
    
    // Victim tries to announce election themselves - FAILS
    var victimStub = GetElectionContractTester(victimKeyPair);
    var result = await victimStub.AnnounceElection.SendWithExceptionAsync(
        Address.FromPublicKey(victimKeyPair.PublicKey));
    result.TransactionResult.Error.ShouldContain("This public key already announced election");
    
    // Victim cannot recover without Parliament intervention
    // SetCandidateAdmin requires current admin (attacker) or Parliament
    var setAdminResult = await victimStub.SetCandidateAdmin.SendWithExceptionAsync(
        new SetCandidateAdminInput
        {
            Pubkey = victimPubkey,
            Admin = Address.FromPublicKey(victimKeyPair.PublicKey)
        });
    setAdminResult.TransactionResult.Error.ShouldContain("No permission");
    
    // DoS successful: Legitimate candidate locked out permanently without Parliament
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L27-38)
```csharp
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-96)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L112-116)
```csharp
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L156-157)
```csharp
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-249)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L406-409)
```csharp
    private int GetValidationDataCenterCount()
    {
        return GetMinersCount(new Empty()).Value.Mul(5);
    }
```
