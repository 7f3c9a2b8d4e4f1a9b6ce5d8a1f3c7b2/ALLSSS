### Title
Integer Overflow in GetMiningInterval() Enables Consensus Disruption via Malicious Round Submission

### Summary
The `GetMiningInterval()` method casts a potentially large `long` value to `int` without overflow protection, allowing a malicious miner to submit a `NextRoundInput` with `ExpectedMiningTime` intervals exceeding `int.MaxValue` (~2.1 billion milliseconds or ~24.8 days). This causes integer overflow when the mining interval is retrieved, disrupting time slot validation for subsequent blocks and potentially halting consensus progression.

### Finding Description

**Root Cause:**

The vulnerability originates in `GetMiningInterval()` where a `long` value returned by `Milliseconds()` is unsafely cast to `int`: [1](#0-0) 

The `Milliseconds()` extension method can return values up to `long.MaxValue`: [2](#0-1) 

When the difference between `ExpectedMiningTime` values exceeds `int.MaxValue` (2,147,483,647 milliseconds), the cast wraps around due to two's complement arithmetic, producing a negative or incorrect positive value even after `Math.Abs()`.

**Insufficient Validation:**

The `CheckRoundTimeSlots()` validation only checks that intervals are positive but does NOT validate they fit within `int` range: [3](#0-2) 

**Attack Vector:**

A malicious miner submitting `NextRound` can craft a `NextRoundInput` with manipulated `ExpectedMiningTime` values. The validation in `TimeSlotValidationProvider` calls `CheckRoundTimeSlots()` on the provided round: [4](#0-3) 

Since `CheckRoundTimeSlots()` validates intervals as `long` values without upper bound checking, the malicious round passes validation and gets stored: [5](#0-4) 

**Exploitation Path:**

Once the corrupted round becomes current, `GetMiningInterval()` is called during time slot validation: [6](#0-5) 

The overflowed integer value causes incorrect timestamp calculations via `AddMilliseconds()`: [7](#0-6) 

**Propagation:**

The corrupted interval also propagates when generating subsequent rounds, as `GenerateNextRoundInformation()` retrieves the mining interval from the current round: [8](#0-7) 

And uses it to calculate `ExpectedMiningTime` for the next round: [9](#0-8) 

### Impact Explanation

**Consensus Disruption:**
Legitimate miners will fail time slot validation because `CheckMinerTimeSlot()` uses the corrupted interval to compute `endOfExpectedTimeSlot`. For example, if the actual interval should be 3,000,000,000 milliseconds but overflows to -1,294,967,296 (then becomes 1,294,967,296 after `Math.Abs()`), the time slot window becomes ~15 days instead of ~35 days, causing legitimate blocks to be rejected.

**Cascade Effect:**
The corrupted interval propagates through `GenerateNextRoundInformation()` to subsequent rounds, potentially requiring manual intervention or chain restart to recover.

**Affected Parties:**
All network participants experience consensus instability. Honest miners cannot produce valid blocks, transactions remain unconfirmed, and the blockchain may halt progression.

**Severity Justification:**
Medium severity due to operational impact on consensus integrity. While it requires miner privileges to execute, the attack is straightforward and causes immediate network-wide disruption until remediated.

### Likelihood Explanation

**Attacker Capabilities:**
The attacker must be an active miner (in the miner list) authorized to submit `NextRound` transactions. This is achievable for elected miners or during term transitions.

**Attack Complexity:**
Low complexity. The attacker crafts a `NextRoundInput` protobuf message with `ExpectedMiningTime` values differing by more than `int.MaxValue` milliseconds (e.g., 3,000,000,000 milliseconds = ~35 days between consecutive miners). This passes all validation checks and gets stored.

**Feasibility Conditions:**
- Attacker must be the designated miner to produce the next round (extra block producer or first miner of new round)
- No special state conditions required
- Attack succeeds immediately upon transaction execution

**Detection Constraints:**
The attack is detectable post-execution when subsequent blocks fail validation, but by then the corrupted round is already stored in state. Recovery requires governance intervention or consensus contract upgrade.

**Probability:**
Medium probability. While miner compromise is required, the attack is deterministic once executed and immediately disrupts the network.

### Recommendation

**Immediate Fix:**

Add overflow validation in `CheckRoundTimeSlots()` to reject intervals exceeding `int.MaxValue`:

```csharp
public ValidationResult CheckRoundTimeSlots()
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

    var baseMiningInterval =
        (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

    // ADD THIS CHECK:
    if (baseMiningInterval > int.MaxValue)
        return new ValidationResult { Message = $"Mining interval exceeds maximum allowed value.\n{this}" };

    if (baseMiningInterval <= 0)
        return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

    // ... rest of validation
}
```

**Alternative Fix:**

Change `GetMiningInterval()` return type from `int` to `long` and update all callers to handle `long` values. However, this requires broader codebase changes.

**Invariant to Enforce:**
Mining intervals must satisfy: `0 < interval <= int.MaxValue` (0 to 2,147,483,647 milliseconds or ~24.8 days).

**Test Cases:**
1. Submit `NextRoundInput` with interval = `int.MaxValue + 1` → should be rejected
2. Submit `NextRoundInput` with interval = `long.MaxValue` → should be rejected
3. Submit `NextRoundInput` with interval = `int.MaxValue` → should be accepted (edge case)
4. Verify `GetMiningInterval()` never returns negative values after the fix

### Proof of Concept

**Initial State:**
- Blockchain running with multiple miners (e.g., 5 miners)
- Current round has legitimate 4000ms mining intervals
- Attacker is an active miner scheduled to submit the next round

**Attack Steps:**

1. **Craft Malicious NextRoundInput:**
   ```
   NextRoundInput {
     RoundNumber: currentRound + 1
     TermNumber: currentTerm
     RealTimeMinersInformation: {
       Miner1: { Order: 1, ExpectedMiningTime: currentBlockTime + 1000ms }
       Miner2: { Order: 2, ExpectedMiningTime: currentBlockTime + 3,000,000,000ms }  // Exceeds int.MaxValue
       Miner3: { Order: 3, ExpectedMiningTime: currentBlockTime + 6,000,000,000ms }
       // ... consistent intervals of ~3 billion ms
     }
   }
   ```

2. **Submit NextRound Transaction:**
   Attacker submits the crafted `NextRoundInput` when their turn arrives

3. **Validation Passes:**
   - `CheckRoundTimeSlots()` calculates `baseMiningInterval = 2,999,999,000` (long)
   - Check `baseMiningInterval <= 0` → FALSE (passes)
   - Check intervals are consistent → TRUE (passes)
   - Round is stored to state

4. **Subsequent Block Fails:**
   Next miner attempts to produce block:
   - `GetMiningInterval()` called on the corrupted round
   - Cast `(int)2,999,999,000` → overflows to `-1,294,967,296`
   - `Math.Abs(-1,294,967,296)` → `1,294,967,296`
   - Time slot calculation uses wrong interval
   - Block validation fails with "Time slot already passed"

**Expected vs Actual Result:**
- **Expected:** NextRoundInput with unrealistic intervals should be rejected during validation
- **Actual:** Malicious round is accepted, stored, and disrupts all subsequent consensus operations

**Success Condition:**
Attack succeeds when the corrupted round is stored and causes time slot validation failures for legitimate miners in subsequent blocks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-47)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** src/AElf.CSharp.Core/Extension/TimestampExtensions.cs (L16-20)
```csharp
    public static Timestamp AddMilliseconds(this Timestamp timestamp, long milliseconds)
    {
        return timestamp + new Duration
            { Seconds = milliseconds / 1000, Nanos = (int)(milliseconds % 1000).Mul(1000000) };
    }
```

**File:** src/AElf.CSharp.Core/Extension/TimestampExtensions.cs (L71-76)
```csharp
    public static long Milliseconds(this Duration duration)
    {
        return duration.Seconds > long.MaxValue.Div(1000)
            ? long.MaxValue
            : duration.Seconds.Mul(1000).Add(duration.Nanos.Div(1000000));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L44-45)
```csharp
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L20-20)
```csharp
        var miningInterval = GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L33-33)
```csharp
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```
