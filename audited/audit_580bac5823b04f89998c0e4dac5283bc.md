# Audit Report

## Title
BurnProfits Unconditionally Overwrites DistributedProfitsMap Causing Loss of Pre-Contributed Profits

## Summary
The `BurnProfits` function creates a new `DistributedProfitsInfo` object without reading existing state and unconditionally overwrites the `DistributedProfitsMap` entry for a period. When users contribute profits to future periods via `ContributeProfits`, and the scheme later has zero `totalShares` when that period arrives, `BurnProfits` destroys the accounting record while the contributed tokens remain permanently locked in the period-specific virtual address.

## Finding Description

The vulnerability arises from the interaction between three operations in the Profit contract:

**Step 1: Future Period Contribution**

When users call `ContributeProfits` for a future period, the contract allows this explicitly and transfers tokens to a period-specific virtual address. [1](#0-0) 

The period-specific virtual address is consistently generated using XOR of the scheme ID and period hash. [2](#0-1) 

**Step 2: Beneficiary Removal**

The scheme manager can legitimately remove all beneficiaries, causing `totalShares` to become zero. [3](#0-2) 

**Step 3: Critical Flaw in BurnProfits**

When `DistributeProfits` is called with `totalShares <= 0`, it invokes `BurnProfits`. [4](#0-3) 

The critical vulnerability is in the `BurnProfits` implementation. It creates a completely new `DistributedProfitsInfo` object at line 522 without reading any existing state from `State.DistributedProfitsMap[profitsReceivingVirtualAddress]`. It then burns tokens from the scheme's general ledger (not the period-specific address where pre-contributions were deposited) and unconditionally overwrites the state map at line 556, destroying any record of previously contributed profits. [5](#0-4) 

**Contrast with Correct Implementation**

The `UpdateDistributedProfits` function (used when `totalShares > 0`) demonstrates the correct approach: it reads the existing `DistributedProfitsMap` entry first, queries the actual balance from the period-specific virtual address, and adds this to the distributed amounts, thereby preserving any pre-contributions. [6](#0-5) 

**Prevention of Recovery**

After `BurnProfits` executes, it sets `IsReleased = true` in the new object. The `ContributeProfits` function checks this flag and prevents further contributions to released periods. [7](#0-6) 

This creates a permanent loss scenario: the pre-contributed tokens remain in the period-specific virtual address, but the accounting record in `DistributedProfitsMap` either shows zero or negative amounts (from burned general ledger tokens), and the `IsReleased` flag prevents any correction.

## Impact Explanation

**Direct Financial Loss:**

This vulnerability causes permanent loss of user funds. When tokens are contributed to future periods and then `BurnProfits` is called, the contributed tokens become irrecoverable. The tokens physically exist in the period-specific virtual address but have no accounting record, and `ClaimProfits` cannot retrieve them because it reads from the destroyed `DistributedProfitsMap` entry.

**Quantified Damage:**

The impact scales linearly with contribution amounts. For example:
- If 10,000 ELF tokens are contributed to period 5
- And the scheme has zero beneficiaries when period 5 arrives
- All 10,000 ELF become permanently locked with no recovery mechanism

**Affected Parties:**

1. **Users:** Anyone who contributes to future periods expecting normal profit distribution
2. **Scheme Managers:** May inadvertently trigger this when legitimately winding down schemes by removing beneficiaries
3. **Protocol:** Accumulates permanently locked tokens, reducing circulating supply and breaking accounting integrity

The state map is defined to track distributed profits by address. [8](#0-7) 

## Likelihood Explanation

**High Feasibility:**

This vulnerability can be triggered through entirely normal operations without requiring any special privileges beyond basic contract usage:

1. **Reachable Entry Point:** `ContributeProfits` is a public method callable by any user who has approved the contract to transfer their tokens.

2. **Realistic Preconditions:**
   - A profit scheme exists (common operational state)
   - A user contributes to a future period, e.g., period 5 when current period is 1 (this is an explicitly supported feature)
   - Before period 5 arrives, the scheme manager removes all beneficiaries (legitimate when winding down schemes or restructuring)
   - The scheme manager calls `DistributeProfits` for period 5 (normal operation)

3. **Natural Occurrence:** This scenario naturally happens when:
   - Long-running schemes accept future contributions
   - Business circumstances change and schemes need to be wound down
   - The timing gap between contribution and distribution allows for legitimate beneficiary management changes

4. **No Attack Cost:** Beyond the contribution itself, there is no additional cost. A malicious actor could even grief others by contributing to future periods of schemes they control, then removing all beneficiaries.

5. **Detection Difficulty:** Both `ContributeProfits` and `RemoveBeneficiary` are legitimate operations. The loss only becomes apparent when users attempt to claim profits and discover they cannot recover their contributed funds.

## Recommendation

The `BurnProfits` function should be modified to:

1. **Read existing state first:** Before creating a new `DistributedProfitsInfo` object, read any existing entry from `State.DistributedProfitsMap[profitsReceivingVirtualAddress]`

2. **Check period-specific balances:** Query the token balance of `profitsReceivingVirtualAddress` (not just the general ledger) to detect pre-contributed funds

3. **Preserve or return pre-contributions:** Either:
   - Transfer pre-contributed tokens back to a designated address (e.g., scheme manager or treasury)
   - Include them in the `AmountsMap` with proper accounting even when burning general ledger tokens
   - Prevent `DistributeProfits` from being called if pre-contributions exist for periods with zero shares

4. **Add validation:** In `DistributeProfits`, before calling `BurnProfits`, check if the period-specific address has any balance and revert or handle appropriately.

**Recommended Fix Pattern:**
```
Before line 522 in BurnProfits, add:
- Read existing distributedProfitsInfo from State.DistributedProfitsMap[profitsReceivingVirtualAddress]
- If it has non-zero AmountsMap entries, handle those tokens (return or preserve)
- Only then proceed with burning general ledger tokens
```

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_BurnProfits_Destroys_PreContributed_Funds_Test()
{
    // Setup
    const long futureContribution = 10000;
    const long shares = 100;
    var creator = Creators[0];
    var beneficiary = Accounts[0].Address;
    
    // Step 1: Create scheme
    var schemeId = await CreateSchemeAsync();
    
    // Step 2: Add a beneficiary so totalShares > 0
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiary, Shares = shares }
    });
    
    // Step 3: Contribute to future period (period 3)
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Amount = futureContribution,
        Period = 3,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    });
    
    // Verify contribution was recorded and tokens transferred
    var period3Address = await creator.GetSchemeAddress.CallAsync(new SchemePeriod { SchemeId = schemeId, Period = 3 });
    var balanceBefore = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = period3Address,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    })).Balance;
    balanceBefore.ShouldBe(futureContribution); // Tokens are in period-3 address
    
    var profitsInfoBefore = await creator.GetDistributedProfitsInfo.CallAsync(new SchemePeriod { SchemeId = schemeId, Period = 3 });
    profitsInfoBefore.AmountsMap[ProfitContractTestConstants.NativeTokenSymbol].ShouldBe(futureContribution); // Recorded
    profitsInfoBefore.IsReleased.ShouldBe(false);
    
    // Step 4: Remove all beneficiaries (totalShares becomes 0)
    await creator.RemoveBeneficiary.SendAsync(new RemoveBeneficiaryInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiary
    });
    
    var scheme = await creator.GetScheme.CallAsync(schemeId);
    scheme.TotalShares.ShouldBe(0); // No beneficiaries
    
    // Step 5: Advance to period 3 and call DistributeProfits (triggers BurnProfits due to zero shares)
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1,
        AmountsMap = { { ProfitContractTestConstants.NativeTokenSymbol, 0 } }
    });
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 2,
        AmountsMap = { { ProfitContractTestConstants.NativeTokenSymbol, 0 } }
    });
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 3,
        AmountsMap = { { ProfitContractTestConstants.NativeTokenSymbol, 0 } }
    });
    
    // Step 6: Verify vulnerability - tokens still in address but accounting destroyed
    var balanceAfter = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = period3Address,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    })).Balance;
    balanceAfter.ShouldBe(futureContribution); // TOKENS STILL LOCKED IN PERIOD-3 ADDRESS
    
    var profitsInfoAfter = await creator.GetDistributedProfitsInfo.CallAsync(new SchemePeriod { SchemeId = schemeId, Period = 3 });
    profitsInfoAfter.IsReleased.ShouldBe(true); // Released = true prevents further contributions
    profitsInfoAfter.AmountsMap[ProfitContractTestConstants.NativeTokenSymbol].ShouldBe(0); // ACCOUNTING DESTROYED - shows 0 instead of 10000
    
    // The 10,000 ELF tokens are permanently locked with no way to recover them
}
```

This test demonstrates that pre-contributed tokens (10,000 ELF in period-3 address) remain locked after `BurnProfits` executes, while the accounting record in `DistributedProfitsMap` is overwritten to show zero, creating a permanent loss of funds.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-263)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);

        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }

        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-486)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L517-558)
```csharp
    private Empty BurnProfits(long period, Dictionary<string, long> profitsMap, Scheme scheme,
        Address profitsReceivingVirtualAddress)
    {
        scheme.CurrentPeriod = period.Add(1);

        var distributedProfitsInfo = new DistributedProfitsInfo
        {
            IsReleased = true
        };
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            if (amount > 0)
            {
                var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = symbol
                });
                if (balanceOfToken.Balance < amount)
                    continue;
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = Context.Self,
                        Amount = amount,
                        Symbol = symbol
                    }.ToByteString());
                State.TokenContract.Burn.Send(new BurnInput
                {
                    Amount = amount,
                    Symbol = symbol
                });
                distributedProfitsInfo.AmountsMap.Add(symbol, -amount);
            }
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;
        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-583)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L684-712)
```csharp
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);

            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L51-60)
```csharp
    private Address GetDistributedPeriodProfitsVirtualAddress(Hash schemeId, long period)
    {
        return Context.ConvertVirtualAddressToContractAddress(
            GeneratePeriodVirtualAddressFromHash(schemeId, period));
    }

    private Hash GeneratePeriodVirtualAddressFromHash(Hash schemeId, long period)
    {
        return HashHelper.XorAndCompute(schemeId, HashHelper.ComputeFrom(period));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractState.cs (L11-11)
```csharp
    public MappedState<Address, DistributedProfitsInfo> DistributedProfitsMap { get; set; }
```
