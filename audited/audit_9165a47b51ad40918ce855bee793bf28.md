### Title
Missing Validation of Upper Bound Constraints in Fee Coefficient Updates Leads to Fee Undercharging

### Summary
The `AssertPieceUpperBoundsIsInOrder()` function validates that piece upper bounds are unique and ascending, but fails to ensure bounds are positive or that the final bound equals `int.MaxValue`. This allows authorized parties to misconfigure fee coefficients, causing the fee calculation logic to undercharge users whose resource consumption exceeds the final upper bound, resulting in economic loss to the protocol.

### Finding Description
The vulnerability exists in the coefficient validation logic: [1](#0-0) 

This function only validates:
1. No duplicate upper bounds (line 94-95)
2. Bounds are in ascending order (lines 97-100)

It does NOT validate:
- All bounds must be positive (> 0)
- The final bound must equal `int.MaxValue` to represent infinity

The fee calculation logic processes resource consumption in piecewise intervals: [2](#0-1) 

The critical issue occurs at lines 43-55: when `totalCount` exceeds the last piece's upper bound, the loop processes all pieces up to the last one, then exits naturally without processing the remaining count. At line 52, the break only triggers if `pieceUpperBound > totalCount`, meaning if the last bound is less than totalCount, the excess is simply ignored.

For example, with initial READ fee bounds `[10, 100, int.MaxValue]`, if an authorized party updates piece 3 to have bound `1000` instead of `int.MaxValue`, the new bounds become `[10, 100, 1000]`. For a user consuming 2000 READ operations:
- Pieces 1-3 process 10 + 90 + 900 = 1000 units
- Remaining 1000 units are never charged
- User pays significantly less than intended

The update path is: [3](#0-2) 

Line 64 calls `AssertPieceUpperBoundsIsInOrder` after updates, but this insufficient validation allows the vulnerability.

### Impact Explanation
**Direct Economic Loss**: Users with high resource consumption pay substantially less fees than intended. For READ fees using the formula `25/16 * x^2 + x/4` on the final piece, undercharging 1000 excess units results in ~1,562,750 units of lost fees per transaction.

**Affected Parties**: 
- Protocol treasury loses resource token fees (READ, STORAGE, WRITE, TRAFFIC)
- Primary token (ELF) fees via transaction size calculations
- All five fee types (FeeTypeEnum: Read=0, Storage=1, Write=2, Traffic=3, Tx=4) are vulnerable

**Severity Justification**: HIGH - This directly undermines the economic security model. Resource-intensive operations (large contracts, high storage/computation) would be systematically undercharged, potentially enabling DoS attacks at negligible cost if attackers can exceed the misconfigured bound.

### Likelihood Explanation
**Attacker Capabilities**: Requires control of either:
- Developer fee controller (for READ/STORAGE/WRITE/TRAFFIC fees) [4](#0-3) 
- User fee controller (for TX fees) [5](#0-4) 

**Feasibility**: MEDIUM-HIGH
- Requires governance authority but not full compromise
- Could occur through accidental misconfiguration during legitimate updates
- No cryptographic or consensus bypass needed
- Attack is a simple parameter update via normal governance flow

**Detection**: Difficult - fee undercharging may go unnoticed until significant economic damage accumulates, especially for resource types with variable usage patterns.

### Recommendation
Add comprehensive validation to `AssertPieceUpperBoundsIsInOrder()`:

```csharp
private void AssertPieceUpperBoundsIsInOrder(
    IReadOnlyCollection<CalculateFeePieceCoefficients> calculateFeePieceCoefficientsList)
{
    // No same piece upper bound.
    Assert(!calculateFeePieceCoefficientsList.GroupBy(i => i.Value[0]).Any(g => g.Count() > 1),
        "Piece upper bounds contains same elements.");

    var pieceUpperBounds = calculateFeePieceCoefficientsList.Select(l => l.Value[0]).ToList();
    
    // NEW: Validate all bounds are positive
    Assert(pieceUpperBounds.All(b => b > 0), 
        "All piece upper bounds must be positive.");
    
    // NEW: Validate first bound is positive (redundant but explicit)
    Assert(pieceUpperBounds[0] > 0, 
        "First piece upper bound must be positive.");
    
    // NEW: Validate last bound equals int.MaxValue
    Assert(pieceUpperBounds[pieceUpperBounds.Count - 1] == int.MaxValue,
        "Last piece upper bound must equal int.MaxValue to represent infinity.");
    
    var orderedEnumerable = pieceUpperBounds.OrderBy(i => i).ToList();
    for (var i = 0; i < calculateFeePieceCoefficientsList.Count; i++)
        Assert(pieceUpperBounds[i] == orderedEnumerable[i], "Piece upper bounds not in order.");
}
```

**Additional Test Cases**:
1. Test updating last piece to finite value (should fail)
2. Test updating any piece to negative value (should fail)
3. Test updating middle piece to `int.MaxValue` creating duplicate (should fail)
4. Test fee calculation with totalCount exceeding last bound (regression test)

### Proof of Concept

**Initial State**: READ fee coefficients initialized with bounds `[10, 100, int.MaxValue]`

**Attack Steps**:
1. Developer fee controller creates proposal via `UpdateCoefficientsForContract`
2. Proposal updates piece number 3 (last piece) with new coefficients having upper bound `1000` instead of `int.MaxValue`
3. Input: `UpdateCoefficientsInput { PieceNumbers: [3], Coefficients: { FeeTokenType: 0, PieceCoefficientsList: [{ Value: [1000, 2, 25, 16, 1, 1, 4] }] } }`
4. Proposal passes through governance (Association + Parliament approval)
5. `UpdateCoefficients` executes successfully - `AssertPieceUpperBoundsIsInOrder` passes because `[10, 100, 1000]` is ascending and unique
6. New state: READ fee bounds are `[10, 100, 1000]`

**Exploitation**:
1. User executes contract with 2000 READ operations
2. Fee calculation processes: 10 + 90 + 900 = 1000 units
3. Remaining 1000 units ignored due to loop termination at line 54-55 of `CalculateFee`
4. **Expected**: Full fee for 2000 units ≈ 3,125,500 (based on quadratic formula)
5. **Actual**: Fee for only 1000 units ≈ 1,562,750
6. **Loss**: ~50% fee undercharge = 1,562,750 units

**Success Condition**: Verified by observing actual fee charged is significantly less than expected for resource consumption exceeding the misconfigured final bound.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L16-23)
```csharp
    public override Empty UpdateCoefficientsForContract(UpdateCoefficientsInput input)
    {
        Assert(input.Coefficients != null, "Invalid input coefficients.");
        Assert(input.Coefficients.FeeTokenType != (int)FeeTypeEnum.Tx, "Invalid fee type.");
        AssertDeveloperFeeController();
        UpdateCoefficients(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L25-32)
```csharp
    public override Empty UpdateCoefficientsForSender(UpdateCoefficientsInput input)
    {
        Assert(input.Coefficients != null, "Invalid input coefficients.");
        AssertUserFeeController();
        input.Coefficients.FeeTokenType = (int)FeeTypeEnum.Tx; // The only possible for now.
        UpdateCoefficients(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L34-72)
```csharp
    private void UpdateCoefficients(UpdateCoefficientsInput input)
    {
        var feeType = input.Coefficients.FeeTokenType;
        var currentAllCoefficients = State.AllCalculateFeeCoefficients.Value;

        // Get coefficients for specific fee type.
        var currentCoefficients = currentAllCoefficients.Value.SingleOrDefault(x =>
            x.FeeTokenType == feeType);
        Assert(currentCoefficients != null, "Specific fee type not existed before.");

        var inputPieceCoefficientsList = input.Coefficients.PieceCoefficientsList;
        // ReSharper disable once PossibleNullReferenceException
        var currentPieceCoefficientList = currentCoefficients.PieceCoefficientsList;

        var inputPieceCount = input.PieceNumbers.Count;
        Assert(inputPieceCount == inputPieceCoefficientsList.Count,
            "Piece numbers not match.");

        foreach (var coefficients in inputPieceCoefficientsList)
            AssertCoefficientsValid(coefficients);

        for (var i = 0; i < inputPieceCount; i++)
        {
            Assert(currentPieceCoefficientList.Count >= input.PieceNumbers[i],
                "Piece number exceeded.");
            var pieceIndex = input.PieceNumbers[i].Sub(1);
            var pieceCoefficients = inputPieceCoefficientsList[i];
            currentPieceCoefficientList[pieceIndex] = pieceCoefficients;
        }

        AssertPieceUpperBoundsIsInOrder(currentPieceCoefficientList);

        State.AllCalculateFeeCoefficients.Value = currentAllCoefficients;

        Context.Fire(new CalculateFeeAlgorithmUpdated
        {
            AllTypeFeeCoefficients = currentAllCoefficients
        });
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L90-101)
```csharp
    private void AssertPieceUpperBoundsIsInOrder(
        IReadOnlyCollection<CalculateFeePieceCoefficients> calculateFeePieceCoefficientsList)
    {
        // No same piece upper bound.
        Assert(!calculateFeePieceCoefficientsList.GroupBy(i => i.Value[0]).Any(g => g.Count() > 1),
            "Piece upper bounds contains same elements.");

        var pieceUpperBounds = calculateFeePieceCoefficientsList.Select(l => l.Value[0]).ToList();
        var orderedEnumerable = pieceUpperBounds.OrderBy(i => i).ToList();
        for (var i = 0; i < calculateFeePieceCoefficientsList.Count; i++)
            Assert(pieceUpperBounds[i] == orderedEnumerable[i], "Piece upper bounds not in order.");
    }
```

**File:** src/AElf.Kernel.FeeCalculation/Infrastructure/CalculateFunction.cs (L34-58)
```csharp
    public long CalculateFee(int totalCount)
    {
        if (CalculateFeeCoefficients.PieceCoefficientsList.Count != _currentCalculateFunctions.Count)
            throw new ArgumentOutOfRangeException(nameof(_currentCalculateFunctions),
                "Coefficients count not match.");

        var remainCount = totalCount;
        var result = 0L;
        var pieceStart = 0;
        for (var i = 0; i < _currentCalculateFunctions.Count; i++)
        {
            var function = _currentCalculateFunctions[i];
            var pieceCoefficient = CalculateFeeCoefficients.PieceCoefficientsList[i].Value;
            var pieceUpperBound = pieceCoefficient[0];
            var interval = pieceUpperBound - pieceStart;
            pieceStart = pieceUpperBound;
            var count = Math.Min(interval, remainCount);
            result += function(count);
            if (pieceUpperBound > totalCount) break;

            remainCount -= interval;
        }

        return result;
    }
```
