# Audit Report

## Title
NFT Contract Method Fees Inaccessible on Sidechains with Custom Primary Tokens

## Summary
The NFT contract's `GetMethodFee()` implementation hardcodes fees in `Context.Variables.NativeSymbol` (always "ELF"), causing transaction rejection on sidechains with custom primary tokens. Users holding only the sidechain's primary token (e.g., "TE") cannot execute NFT methods because the fee charging fallback mechanism requires the primary token to already exist in the fee map, which it does not.

## Finding Description

The vulnerability exists in the interaction between the NFT contract's fee specification and the MultiToken contract's fee charging logic on sidechains configured with custom primary tokens.

**Fee Specification Mismatch:**
The NFT contract returns fees denominated exclusively in `Context.Variables.NativeSymbol`. [1](#0-0) 

This symbol resolves to "ELF" by default from the `Economic:Symbol` configuration. [2](#0-1) 

**Sidechain Token Architecture:**
Sidechains support two distinct token concepts: a native token ("ELF" inherited from parent chain) and a chain-specific primary token (e.g., "TE") that users primarily hold for transactions. This is evidenced by sidechain initialization where the native token symbol is "ELF" but the primary token symbol is "TE". [3](#0-2) 

The primary token is set via `SetPrimaryTokenSymbol` during sidechain initialization. [4](#0-3) 

**Broken Fallback Logic:**
The fee charging mechanism attempts to fallback to the primary token, but only if the primary token already exists in `symbolToAmountMap`. [5](#0-4) 

Since `symbolToAmountMap` is built directly from `GetMethodFee()` via `GetBaseFeeDictionary`, it only contains "ELF". [6](#0-5) 

The primary token symbol retrieval confirms this distinction between primary and native tokens. [7](#0-6) 

**Transaction Rejection:**
When fee charging fails, the pre-execution plugin stops transaction execution. [8](#0-7) 

**Inability to Fix:**
Unlike other contracts (Profit, Vote) that allow fee updates via governance, the NFT contract's `SetMethodFee` is a no-op, making this issue permanent. [9](#0-8) 

## Impact Explanation

**Operational Impact - Medium Severity:**

This vulnerability causes a complete denial-of-service for NFT contract functionality on sidechains with custom primary tokens. Users who hold only the sidechain's primary token cannot execute any fee-bearing NFT methods (`Create`, etc.), even with sufficient balance.

**Affected Scope:**
- Sidechain users without cross-chain ELF transfers
- NFT projects deploying on sidechains with custom economic models
- Sidechain ecosystems designed around their primary token

**Quantified Impact:**
- 100% functional DoS of NFT operations for users without ELF
- Forces unnecessary cross-chain transfers adding friction and costs
- Undermines the architectural purpose of sidechain-specific primary tokens

This does not result in fund theft or supply inflation, but creates a critical usability barrier preventing legitimate operations. The severity is elevated because the NFT contract cannot be fixed via governance, making this a permanent architectural flaw.

## Likelihood Explanation

**High Likelihood:**

The vulnerability manifests under documented and realistic conditions:

1. **Documented Feature**: Sidechains with custom primary tokens are an officially supported feature, as evidenced by the sidechain initialization infrastructure and test cases demonstrating primary token "TE" alongside native token "ELF".

2. **Natural User Behavior**: Users on sidechains naturally acquire the primary token through mining rewards, trading, and staking. They may never hold ELF if they don't perform cross-chain transfers.

3. **Zero Attack Complexity**: This is a functional bug affecting normal users attempting legitimate operations. No attacker or special conditions are required.

4. **Immediate Trigger**: Any user calling `Create()` on the NFT contract triggers the issue immediately.

5. **Widespread Pattern**: The same pattern affects other system contracts (Profit, Vote) that use `Context.Variables.NativeSymbol` in their default fee implementations, though those contracts can be remediated via governance.

## Recommendation

**Option 1: Primary Token-Aware Fee Specification (Recommended)**
Modify `GetMethodFee()` to check if a primary token is configured and use it instead of the native symbol:

```csharp
public override MethodFees GetMethodFee(StringValue input)
{
    if (input.Value == nameof(Create))
    {
        var primaryTokenSymbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;
        return new MethodFees
        {
            MethodName = input.Value,
            Fees =
            {
                new MethodFee
                {
                    Symbol = string.IsNullOrEmpty(primaryTokenSymbol) 
                        ? Context.Variables.NativeSymbol 
                        : primaryTokenSymbol,
                    BasicFee = 100_00000000
                }
            }
        };
    }
    return new MethodFees();
}
```

**Option 2: Enable Fee Configuration**
Implement functional `SetMethodFee` and `ChangeMethodFeeController` methods to allow governance to update fees post-deployment.

**Option 3: Enhanced Fallback Logic**
Modify `ChargeFirstSufficientToken` to add the primary token to the fee map even when not originally specified, with the full required amount.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. Initialize a sidechain with custom primary token "TE" and native token "ELF"
2. Create a user with 1000 TE balance and 0 ELF balance
3. Attempt to call `NFTContract.Create()` with this user
4. Observe transaction rejection with "Transaction fee not enough" error
5. Verify that the same user with 100 ELF balance can successfully execute the transaction

The execution trace shows:
- `GetMethodFee()` returns `{"ELF": 100_00000000}`
- `ChargeFirstSufficientToken()` fails to find sufficient ELF
- Fallback checks `symbolToAmountMap.ContainsKey("TE")` â†’ returns false
- `ChargeTransactionFeesOutput.Success = false`
- `IsStopExecuting()` returns true, preventing transaction execution

This can be validated by examining the sidechain initialization test that confirms sidechains can have native token "ELF" and primary token "TE" simultaneously, combined with the fee charging logic that requires the primary token to be pre-declared in the fee map for the fallback to function.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-16)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }

    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** src/AElf.Blockchains.BasicBaseChain/BasicBaseChainAElfModule.cs (L91-94)
```csharp
        Configure<HostSmartContractBridgeContextOptions>(options =>
        {
            options.ContextVariables[ContextVariableDictionary.NativeSymbolName] =
                newConfig.GetValue("Economic:Symbol", "ELF");
```

**File:** test/AElf.Contracts.CrossChain.Tests/SideChainLifeTimeManagementTest.cs (L832-834)
```csharp
            TokenInfo.Parser.ParseFrom(chainInitializationData.NativeTokenInfoData).Symbol.ShouldBe("ELF");
            TokenInfo.Parser.ParseFrom(chainInitializationData.ChainPrimaryTokenInfo.ChainPrimaryTokenData).Symbol
                .ShouldBe("TE");
```

**File:** test/AElf.Contracts.MultiTokenCrossChainTransfer.Tests/SideChainUnitTestTokenContractInitializationProvider.cs (L74-81)
```csharp
            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractImplContainer.TokenContractImplStub.SetPrimaryTokenSymbol),
                Params = new SetPrimaryTokenSymbolInput
                {
                    Symbol = chainPrimaryTokenInfo.Symbol
                }.ToByteString()
            });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L322-327)
```csharp
    private Dictionary<string, long> GetBaseFeeDictionary(MethodFees methodFees)
    {
        return methodFees.Fees.Where(f => !string.IsNullOrEmpty(f.Symbol))
            .GroupBy(f => f.Symbol, f => f.BasicFee)
            .ToDictionary(g => g.Key, g => g.Sum());
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L732-742)
```csharp
        //For user, if charge failed and delegation is null, priority charge primary token
        if (!chargeResult)
        {
            var primaryTokenSymbol = GetPrimaryTokenSymbol(new Empty()).Value;
            if (symbolToAmountMap.ContainsKey(primaryTokenSymbol))
            {
                symbol = primaryTokenSymbol;
                existingBalance = GetBalance(fromAddress, symbol);
                existingAllowance = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbol);
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L132-141)
```csharp
    public override StringValue GetPrimaryTokenSymbol(Empty input)
    {
        if (string.IsNullOrWhiteSpace(_primaryTokenSymbol) && State.ChainPrimaryTokenSymbol.Value != null)
            _primaryTokenSymbol = State.ChainPrimaryTokenSymbol.Value;

        return new StringValue
        {
            Value = _primaryTokenSymbol ?? Context.Variables.NativeSymbol
        };
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L123-129)
```csharp
    public bool IsStopExecuting(ByteString txReturnValue, out string preExecutionInformation)
    {
        var chargeTransactionFeesOutput = new ChargeTransactionFeesOutput();
        chargeTransactionFeesOutput.MergeFrom(txReturnValue);
        preExecutionInformation = chargeTransactionFeesOutput.ChargingInformation;
        return !chargeTransactionFeesOutput.Success;
    }
```
