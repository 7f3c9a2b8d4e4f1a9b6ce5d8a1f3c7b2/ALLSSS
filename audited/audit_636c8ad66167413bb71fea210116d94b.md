### Title
Side Chain Disposal Permanently Loses Unindexed Cross-Chain Data

### Summary
The `DisposeSideChain` function terminates side chains without verifying that all cross-chain blocks have been indexed, and clears any pending indexing proposals during disposal. Once terminated, the chain's status prevents future indexing attempts, causing permanent loss of cross-chain transaction data and potentially trapping user funds that were transferred cross-chain but never recorded on the main chain.

### Finding Description

The vulnerability exists in the side chain disposal mechanism across multiple components:

**Root Cause - Missing Indexing Completeness Check:**
The `DisposeSideChain` function only verifies that the chain exists and is not already terminated, but performs no check to ensure all side chain blocks have been indexed. [1](#0-0) 

**Pending Proposal Destruction:**
During disposal, any pending indexing proposals for that chain are immediately cleared via `ResetChainIndexingProposal(chainId)`, discarding approved-but-unreleased cross-chain data. [2](#0-1) 

**Post-Termination Indexing Prevention:**
After termination, `ValidateSideChainBlockData` explicitly rejects any side chain data where the status is `Terminated`, making it impossible to index blocks from the disposed chain. [3](#0-2) 

**View Function Hiding the Issue:**
The `GetSideChainIdAndHeight()` function skips terminated chains entirely, making them invisible in queries that check indexing status. [4](#0-3) 

**Execution Path:**
1. Side chain produces blocks containing cross-chain transactions (e.g., token transfers to main chain)
2. Miners propose indexing via `ProposeCrossChainIndexing`, creating an indexing proposal
3. Before the proposal is released (or before blocks are even proposed), Parliament approves `DisposeSideChain`
4. `DisposeSideChain` executes, clearing pending proposals and marking chain as Terminated
5. Any attempt to release cleared proposals fails with "Chain indexing not proposed"
6. Any attempt to propose new indexing fails validation with "Invalid cross chain data to be indexed"
7. Cross-chain transactions remain unrecorded on main chain permanently

### Impact Explanation

**Direct Financial Impact:**
Users who initiated cross-chain transfers from the side chain to the main chain lose their funds if the side chain blocks containing those transactions are not indexed before disposal. The tokens are locked/burned on the side chain but never minted/unlocked on the main chain, resulting in permanent fund loss.

**Cross-Chain Integrity Violation:**
The main chain's view of side chain state becomes permanently incomplete. Cross-chain merkle proofs cannot be verified for transactions in unindexed blocks, breaking the cross-chain verification mechanism that is critical to AElf's multi-chain architecture.

**Affected Parties:**
- Users with pending cross-chain transactions on disposed chains
- Applications relying on cross-chain state consistency
- The protocol's cross-chain security guarantees

**Severity Justification - Medium:**
High impact (fund loss, data loss) but medium likelihood (requires governance oversight or malicious intent). The vulnerability is not easily exploitable by external attackers but represents a governance failure scenario or potential insider attack vector.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires Parliament approval to execute `DisposeSideChain` (governance-controlled)
- Does not require technical exploit or privilege escalation
- Could occur through governance oversight (accidental) or coordinated malicious governance action

**Attack Complexity:**
Low - the attack is simply calling `DisposeSideChain` through normal governance processes without checking indexing status first.

**Feasibility Conditions:**
- Governance must vote to dispose a side chain
- No automated checks prevent disposal of chains with unindexed blocks
- The `GetSideChainIdAndHeight()` function that governance might use to check status excludes terminated chains, making it harder to detect the issue post-disposal

**Probability:**
Medium - this could realistically occur through governance negligence (not verifying indexing completeness before disposal) rather than requiring sophisticated attack coordination. The test suite even includes a scenario demonstrating this exact sequence. [5](#0-4) 

### Recommendation

**Code-Level Mitigation:**
Add a mandatory check in `DisposeSideChain` that verifies all side chain blocks up to a finalized height have been indexed before allowing disposal:

1. Track the "last produced block height" for each side chain (requires side chain to report this)
2. Before disposal, assert that `State.CurrentSideChainHeight[chainId]` is greater than or equal to the last produced height (with some safety margin)
3. Alternatively, require an explicit "finalization period" where the chain stops producing blocks before disposal is allowed
4. Do not clear pending indexing proposals during disposal - instead, require them to be processed or explicitly rejected first

**Invariant Check:**
```
Assert(State.CurrentSideChainHeight[chainId] >= requiredMinimumHeight, 
       "Cannot dispose chain with unindexed blocks");
Assert(!TryGetIndexingProposal(chainId, out _), 
       "Cannot dispose chain with pending indexing proposals");
```

**Test Case:**
Add a test that attempts to dispose a side chain with unindexed blocks and verifies the transaction reverts with an appropriate error message. Extend existing test coverage to validate the minimum indexing height requirement.

### Proof of Concept

The existing test suite already demonstrates this vulnerability:

**Initial State:**
- Side chain created with ID `sideChainId`
- Two side chain blocks (height 1 and 2) are produced
- Indexing proposal created and approved by Parliament

**Transaction Steps:**
1. Call `ProposeCrossChainIndexing` with blocks 1 and 2 - succeeds, proposal created [6](#0-5) 

2. Call `DisposeSideChain` for the chain - succeeds, chain marked Terminated [7](#0-6) 

3. Attempt to call `ReleaseCrossChainIndexingProposal` to index the approved blocks - **FAILS** with "Chain indexing not proposed" [8](#0-7) 

4. Attempt to propose new indexing for block 3 - **FAILS** with "Invalid cross chain data to be indexed" [9](#0-8) 

**Expected Result:** Side chain blocks should be indexed before disposal is allowed, or disposal should fail.

**Actual Result:** Disposal succeeds, pending proposals are cleared, and blocks 1-2 remain permanently unindexed. Any cross-chain transactions in these blocks are lost.

**Success Condition:** The test explicitly verifies this behavior is working as implemented, confirming the vulnerability exists by design rather than by accident.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L222-242)
```csharp
    public override Int32Value DisposeSideChain(Int32Value input)
    {
        AssertSideChainLifetimeControllerAuthority(Context.Sender);

        var chainId = input.Value;
        var info = State.SideChainInfo[chainId];
        Assert(info != null, "Side chain not found.");
        Assert(info.SideChainStatus != SideChainStatus.Terminated, "Incorrect chain status.");

        if (TryGetIndexingProposal(chainId, out _))
            ResetChainIndexingProposal(chainId);

        UnlockTokenAndResource(info);
        info.SideChainStatus = SideChainStatus.Terminated;
        State.SideChainInfo[chainId] = info;
        Context.Fire(new Disposed
        {
            ChainId = chainId
        });
        return new Int32Value { Value = chainId };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L701-702)
```csharp
            if (info == null || info.SideChainStatus == SideChainStatus.Terminated)
                return false;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L109-110)
```csharp
            if (sideChainInfo.SideChainStatus == SideChainStatus.Terminated)
                continue;
```

**File:** test/AElf.Contracts.CrossChain.Tests/CrossChainIndexingActionTest.cs (L1069-1128)
```csharp
    public async Task Release_IndexingSideChain_Terminated()
    {
        var parentChainId = 123;
        var lockedToken = 2;
        long parentChainHeightOfCreation = 10;
        var sideChainId =
            await InitAndCreateSideChainAsync(parentChainHeightOfCreation, parentChainId, lockedToken);
        var fakeSideChainBlockHash = HashHelper.ComputeFrom("sideChainBlockHash");
        var fakeTxMerkleTreeRoot = HashHelper.ComputeFrom("txMerkleTreeRoot");
        var sideChainBlockData1 =
            CreateSideChainBlockData(fakeSideChainBlockHash, 1, sideChainId, fakeTxMerkleTreeRoot);
        var sideChainBlockData2 =
            CreateSideChainBlockData(fakeSideChainBlockHash, 2, sideChainId, fakeTxMerkleTreeRoot);

        var crossChainBlockData = new CrossChainBlockData
        {
            SideChainBlockDataList = { sideChainBlockData1, sideChainBlockData2 }
        };

        {
            var txRes = await CrossChainContractStub.ProposeCrossChainIndexing.SendAsync(crossChainBlockData);
            txRes.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
            var proposalId = ProposalCreated.Parser
                .ParseFrom(txRes.TransactionResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated)))
                    .NonIndexed)
                .ProposalId;
            proposalId.ShouldNotBeNull();
            await ApproveWithMinersAsync(proposalId);
        }

        var disposeSideChainProposalId = await DisposeSideChainProposalAsync(new Int32Value { Value = sideChainId });
        await ApproveWithMinersAsync(disposeSideChainProposalId);
        await ReleaseProposalAsync(disposeSideChainProposalId);

        {
            var chainStatus = await CrossChainContractStub.GetChainStatus.CallAsync(new Int32Value
            {
                Value = sideChainId
            });
            chainStatus.Status.ShouldBe(SideChainStatus.Terminated);
        }

        var releaseResult = await CrossChainContractStub.ReleaseCrossChainIndexingProposal.SendWithExceptionAsync(
            new ReleaseCrossChainIndexingProposalInput
            {
                ChainIdList = { sideChainId }
            });
        releaseResult.TransactionResult.Error.ShouldContain("Chain indexing not proposed.");

        {
            var sideChainBlockData3 =
                CreateSideChainBlockData(fakeSideChainBlockHash, 3, sideChainId, fakeTxMerkleTreeRoot);
            var txRes = await CrossChainContractStub.ProposeCrossChainIndexing.SendWithExceptionAsync(
                new CrossChainBlockData
                {
                    SideChainBlockDataList = { sideChainBlockData3 }
                });
            txRes.TransactionResult.Error.ShouldContain("Invalid cross chain data to be indexed");
        }
    }
```
