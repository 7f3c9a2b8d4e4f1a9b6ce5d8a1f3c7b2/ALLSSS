### Title
Missing Validation of Total Initial Issue Amount Against Side Chain Token Supply

### Summary
The `AssertValidSideChainCreationRequest()` function validates that individual amounts in `SideChainTokenInitialIssueList` are greater than zero, but fails to validate that the sum of all initial issue amounts does not exceed `SideChainTokenTotalSupply` or cause integer overflow. This allows malformed side chain creation requests to be approved, resulting in locked tokens on the parent chain while the side chain fails to initialize when token issuance exceeds the declared total supply.

### Finding Description

The validation logic in `AssertValidSideChainCreationRequest()` only performs per-amount validation: [1](#0-0) 

This check verifies that the list is non-empty and each individual amount is positive, but critically omits:
1. Validation that the sum of all amounts does not overflow `long.MaxValue`
2. Validation that the sum does not exceed `SideChainTokenTotalSupply`

The total supply is separately validated to be positive: [2](#0-1) 

However, no cross-validation occurs between the total supply and the sum of initial issue amounts.

When `CreateSideChain()` executes after governance approval, tokens are locked BEFORE initialization: [3](#0-2) 

The initialization data containing the problematic initial issue list is stored: [4](#0-3) 

Later, during side chain initialization, the token contract attempts to issue tokens sequentially: [5](#0-4) 

The `Issue()` method uses checked arithmetic via SafeMath and validates against total supply: [6](#0-5) 

The SafeMath.Add() uses checked arithmetic that throws on overflow: [7](#0-6) 

**Root Cause**: The validation occurs too late—after tokens are locked and the proposal is approved. If the cumulative issued amount exceeds `TotalSupply` or causes overflow, initialization fails but tokens remain locked.

### Impact Explanation

**Direct Harm**:
- Proposer's `LockedTokenAmount` becomes permanently locked or difficult to recover on the parent chain
- Side chain cannot successfully initialize and becomes unusable
- Cross-chain functionality is disrupted for the failed side chain

**Affected Parties**:
- Side chain creator who locked tokens
- Intended recipients of initial token issuance
- Any parties depending on the side chain's operation

**Severity Justification**: MEDIUM
- Not direct theft, but causes locked tokens and failed infrastructure
- Affects token supply invariant at the initialization boundary
- Creates operational DoS for specific side chain instance
- Economic loss proportional to `LockedTokenAmount`

### Likelihood Explanation

**Attacker Capabilities**:
- Any address with sufficient allowance can call `RequestSideChainCreation()`
- Attacker crafts `SideChainTokenInitialIssueList` where sum exceeds `SideChainTokenTotalSupply`
- Example: TotalSupply=1,000,000 but InitialIssueList=[300,000, 300,000, 300,000, 300,000] (sum=1,200,000)

**Attack Complexity**: LOW
- Single transaction to submit malformed proposal
- No special privileges required beyond proposal submission rights
- Governance may approve without manually calculating sum of all initial issue amounts

**Feasibility Conditions**:
- Governance approval required (not a direct exploit)
- However, governance is expected to validate proposals based on contract assertions
- Missing validation creates false sense of security—"if contract accepted it, must be valid"

**Detection Constraints**:
- No on-chain validation prevents malformed requests
- Off-chain review would require manual summation of potentially many initial issue entries
- Test suite confirms no existing test coverage for this scenario: [8](#0-7) 

Tests only validate empty lists and zero amounts, not sum validation.

### Recommendation

**Code-Level Mitigation**:

Add validation in `AssertValidSideChainCreationRequest()` after line 136:

```csharp
// Validate sum of initial issue amounts
long totalInitialIssue = 0;
foreach (var issue in sideChainCreationRequest.SideChainTokenInitialIssueList)
{
    totalInitialIssue = totalInitialIssue.Add(issue.Amount); // Uses SafeMath, throws on overflow
}
Assert(
    totalInitialIssue <= sideChainCreationRequest.SideChainTokenCreationRequest.SideChainTokenTotalSupply,
    "Sum of initial issue amounts exceeds total supply.");
```

**Invariant Check**:
- Enforce: `Σ(SideChainTokenInitialIssueList[i].Amount) <= SideChainTokenTotalSupply`
- This check must occur before proposal creation, not during initialization

**Test Cases**:

1. **Test overflow scenario**: InitialIssueList with amounts that sum to overflow `long.MaxValue`, expect rejection
2. **Test sum exceeds supply**: InitialIssueList where sum > TotalSupply but no overflow, expect rejection  
3. **Test edge case**: InitialIssueList where sum exactly equals TotalSupply, should succeed
4. **Test valid case**: InitialIssueList where sum < TotalSupply, should succeed

### Proof of Concept

**Initial State**:
- Proposer has approved sufficient allowance for `LockedTokenAmount`
- Parent chain CrossChain contract initialized
- Proposer has governance proposal rights

**Attack Sequence**:

1. **Attacker submits malicious side chain creation request**:
   - `SideChainTokenTotalSupply`: 1,000,000
   - `SideChainTokenInitialIssueList`: [
       {address: A, amount: 300,000},
       {address: B, amount: 300,000},
       {address: C, amount: 300,000},
       {address: D, amount: 300,000}
     ]
   - Sum: 1,200,000 > 1,000,000
   - Each individual amount passes the `amount > 0` check

2. **Request succeeds** at validation: [9](#0-8) 

3. **Governance approves** the proposal (appears valid per contract checks)

4. **CreateSideChain executes**:
   - Tokens locked: [3](#0-2) 
   - Initialization data stored with malformed initial issue list
   - Transaction succeeds, returns chain ID

5. **Side chain attempts initialization**:
   - First Issue(300,000): Issued = 300,000 <= 1,000,000 ✓
   - Second Issue(300,000): Issued = 600,000 <= 1,000,000 ✓
   - Third Issue(300,000): Issued = 900,000 <= 1,000,000 ✓
   - Fourth Issue(300,000): Issued = 1,200,000 <= 1,000,000 ✗ **FAILS**

**Expected Result**: Side chain creation request rejected during validation

**Actual Result**: 
- Request accepted and proposal approved
- Tokens locked on parent chain
- Side chain initialization fails with "Total supply exceeded"
- Side chain unusable, tokens locked/lost

**Success Condition**: Attacker causes tokens to be locked while creating an unusable side chain, demonstrating the validation gap.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L134-136)
```csharp
        Assert(sideChainCreationRequest.SideChainTokenInitialIssueList.Count > 0 &&
               sideChainCreationRequest.SideChainTokenInitialIssueList.All(issue => issue.Amount > 0),
            "Invalid side chain token initial issue list.");
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L147-154)
```csharp
    private void AssertValidSideChainTokenInfo(SideChainTokenCreationRequest sideChainTokenCreationRequest)
    {
        Assert(
            !string.IsNullOrEmpty(sideChainTokenCreationRequest.SideChainTokenSymbol) &&
            !string.IsNullOrEmpty(sideChainTokenCreationRequest.SideChainTokenName),
            "Invalid side chain token name.");
        Assert(sideChainTokenCreationRequest.SideChainTokenTotalSupply > 0, "Invalid side chain token supply.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L90-96)
```csharp
    public override Empty RequestSideChainCreation(SideChainCreationRequest input)
    {
        AssertValidSideChainCreationRequest(input, Context.Sender);
        var sideChainCreationRequestState = ProposeNewSideChain(input, Context.Sender);
        State.ProposedSideChainCreationRequestState[Context.Sender] = sideChainCreationRequestState;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L141-141)
```csharp
        ChargeSideChainIndexingFee(input.Proposer, sideChainCreationRequest.LockedTokenAmount, chainId);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L157-159)
```csharp
        var chainInitializationData =
            GetChainInitializationData(sideChainInfo, sideChainCreationRequest);
        State.SideChainInitializationData[sideChainInfo.SideChainId] = chainInitializationData;
```

**File:** test/AElf.Contracts.MultiToken.Tests/SideChainUnitTestTokenContractInitializationProvider.cs (L62-73)
```csharp
            foreach (var issueStuff in initializationData.TokenInitialIssueList)
                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractImplContainer.TokenContractImplStub.Issue),
                    Params = new IssueInput
                    {
                        Symbol = chainPrimaryTokenInfo.Symbol,
                        Amount = issueStuff.Amount,
                        Memo = "Initial issue",
                        To = issueStuff.Address
                    }.ToByteString()
                });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L163-166)
```csharp
        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L100-106)
```csharp
    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```

**File:** test/AElf.Contracts.CrossChain.Tests/SideChainLifeTimeManagementTest.cs (L1192-1198)
```csharp
            var createProposalInput = CreateSideChainCreationRequest(lockedTokenAmount, lockedTokenAmount,
                GetValidResourceAmount(), new SideChainTokenInitialIssue[0], true);
            var requestSideChainCreation =
                await CrossChainContractStub.RequestSideChainCreation.SendWithExceptionAsync(createProposalInput);
            requestSideChainCreation.TransactionResult.Error.ShouldContain(
                "Invalid side chain token initial issue list.");
        }
```
