# Audit Report

## Title
FinalOrderOfNextRound Collision Not Detected Due to Incorrect Distinct() Usage in Mining Order Validation

## Summary
The `NextRoundMiningOrderValidationProvider` fails to detect when multiple miners are assigned the same `FinalOrderOfNextRound` value because it applies `Distinct()` to entire `MinerInRound` objects rather than to the order values themselves. This allows malicious miners to create order collisions via `TuneOrderInformation`, resulting in multiple miners being assigned the same mining slot in the next round, causing consensus failure and blockchain forks.

## Finding Description

The validation logic contains a critical flaw where `Distinct()` operates on `MinerInRound` objects instead of the `FinalOrderOfNextRound` values being validated. [1](#0-0) 

Since protobuf-generated classes implement `Equals()` based on ALL fields (including `pubkey`, `order`, `produced_blocks`, etc.), two different miners with identical `FinalOrderOfNextRound` values but different pubkeys are counted as distinct objects. If Miner A and Miner B both have `FinalOrderOfNextRound = 5`, the `distinctCount` would be 2, allowing the validation to pass.

The attack exploits that miners can set arbitrary `TuneOrderInformation` values during `UpdateValue` without validation. The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`: [2](#0-1) 

When `ProcessUpdateValue()` executes, it directly applies the malicious `TuneOrderInformation` without any collision checks: [3](#0-2) 

Subsequently, `GenerateNextRoundInformation()` uses these `FinalOrderOfNextRound` values to assign mining orders in the next round: [4](#0-3) 

Multiple miners with the same `FinalOrderOfNextRound` receive identical `Order` and `ExpectedMiningTime` values, each stored as separate dictionary entries with unique pubkeys.

When `GetNextMinerPubkey()` determines the current block producer, it returns the first miner whose `ExpectedMiningTime` exceeds the current time: [5](#0-4) 

With identical `ExpectedMiningTime` values, the selection becomes non-deterministic, causing different nodes to accept different blocks as valid, fragmenting the network.

## Impact Explanation

**Consensus Integrity Violation (Critical):**
- Multiple miners are assigned identical mining time slots
- Both have legitimate authority to produce blocks at the same height
- The blockchain experiences simultaneous block production, causing forks

**Blockchain Fork and Network Fragmentation:**
- Different nodes may accept different blocks as valid
- The consensus mechanism loses deterministic block producer selection
- Network fragments into incompatible branches

**Denial of Service:**
- Any active miner can trigger this attack
- Continuous exploitation renders the blockchain inoperable
- Recovery requires manual intervention to exclude malicious miners

This represents a complete breakdown of consensus integrity, the fundamental security property of the blockchain.

## Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an active miner (member of `RealTimeMinersInformation`)
- No special privileges beyond normal miner status required
- Attack executed through the standard `UpdateValue` method

**Attack Complexity: LOW**
- Single transaction with crafted `TuneOrderInformation` map: `{MinerA.Pubkey: 5, MinerB.Pubkey: 5}`
- No timing requirements or race conditions
- Deterministic outcome - validation always fails to detect the collision

**Feasibility: HIGH**
- Attacker controls at least one miner identity
- Can execute during any `UpdateValue` in any round
- No economic cost beyond normal mining operations
- Attack succeeds with 100% probability given the validation flaw

The validation provider is invoked during NextRound behavior validation: [6](#0-5) 

However, by that point the malicious `TuneOrderInformation` has already been committed to state, and the flawed validation logic allows it to proceed.

## Recommendation

Fix the validation to check for uniqueness of `FinalOrderOfNextRound` values, not uniqueness of `MinerInRound` objects:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
```

Additionally, add validation in `UpdateValueValidationProvider` to ensure no duplicate values exist in `TuneOrderInformation`, and verify that all values are within the valid range `[1, minersCount]`.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task Malicious_Miner_Creates_Order_Collision_Causing_Fork()
{
    // Setup: Initialize consensus with multiple miners
    var miners = new[] { "MinerA", "MinerB", "MinerC" };
    await InitializeConsensusWithMiners(miners);
    
    // Attack: MinerA submits UpdateValue with duplicate TuneOrderInformation
    var maliciousTuneOrder = new Dictionary<string, int>
    {
        { "MinerB", 5 },  // Assign same order
        { "MinerC", 5 }   // Assign same order
    };
    
    var updateValueInput = new UpdateValueInput
    {
        OutValue = GenerateHash(),
        Signature = GenerateSignature(),
        TuneOrderInformation = { maliciousTuneOrder }
    };
    
    // Execute UpdateValue - should process without error due to missing validation
    await ExecuteConsensusTransaction("MinerA", updateValueInput);
    
    // Trigger NextRound - validation should pass due to Distinct() flaw
    await ExecuteNextRound();
    
    // Verify: Both MinerB and MinerC have identical Order in next round
    var nextRound = await GetCurrentRound();
    var minerBInfo = nextRound.RealTimeMinersInformation["MinerB"];
    var minerCInfo = nextRound.RealTimeMinersInformation["MinerC"];
    
    Assert.Equal(minerBInfo.Order, minerCInfo.Order); // Both have Order = 5
    Assert.Equal(minerBInfo.ExpectedMiningTime, minerCInfo.ExpectedMiningTime); // Same mining time
    
    // Impact: Both miners attempt to produce blocks at same time
    // GetNextMinerPubkey() returns non-deterministic result
    // Network fragments into incompatible forks
}
```

**Notes:**
- The vulnerability requires the attacker to be an active miner, which is a realistic threat model assumption in AEDPoS consensus
- The flaw exists because `Distinct()` on line 16 of `NextRoundMiningOrderValidationProvider.cs` operates on the entire protobuf-generated `MinerInRound` objects, which compare all 17+ fields for equality, rather than just comparing the `FinalOrderOfNextRound` values
- This is a consensus-breaking vulnerability with critical impact and high likelihood

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L96-98)
```csharp
                Value = round.RealTimeMinersInformation.Values
                            .FirstOrDefault(m => m.ExpectedMiningTime > Context.CurrentBlockTime)?.Pubkey ??
                        round.RealTimeMinersInformation.Values.First(m => m.IsExtraBlockProducer).Pubkey
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-86)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
```
