# Audit Report

## Title
Scheme Manager Can Bypass Minimum Lock Period by Calling CreateScheme Multiple Times

## Summary
The `CreateScheme` method in TokenHolderContract lacks validation to prevent duplicate scheme creation by the same manager. A scheme manager can call `CreateScheme` again with a different `MinimumLockMinutes` value, overwriting the stored scheme parameters while users remain registered in the original Profit scheme. This allows manipulation of withdrawal timelock for all existing token lockers.

## Finding Description

The vulnerability exists because `CreateScheme` does not validate if a scheme already exists for the caller before overwriting state. [1](#0-0) 

The method directly overwrites `State.TokenHolderProfitSchemes[Context.Sender]` without any existence check. Each call also creates a new Profit contract scheme with a unique ID generated based on the manager's scheme count. [2](#0-1) 

When the manager calls `CreateScheme` a second time, the Profit contract creates Scheme #2 (count=1), but the TokenHolder contract overwrites its stored parameters with the new `MinimumLockMinutes` value. [3](#0-2) 

When users register via `RegisterForProfits`, they are added as beneficiaries to the FIRST Profit scheme, and their lock timestamp is recorded. [4](#0-3) 

The critical issue manifests during withdrawal. The `Withdraw` method retrieves the scheme and validates timing using the current `MinimumLockMinutes` value. [5](#0-4) 

The `GetValidScheme` helper retrieves the current TokenHolder scheme (which may have overwritten parameters) and calls `UpdateTokenHolderProfitScheme` to populate the SchemeId. [6](#0-5) 

`UpdateTokenHolderProfitScheme` retrieves the FIRST Profit scheme ID where users are registered, but uses the `MinimumLockMinutes` from the potentially overwritten TokenHolder scheme. [7](#0-6) 

**Attack Scenario:**
1. Manager creates scheme with `MinimumLockMinutes = 100000`
2. User locks 1000 tokens at time T=0
3. Manager calls `CreateScheme` again with `MinimumLockMinutes = 1`
4. User can withdraw at T=2 minutes instead of waiting 100000 minutes

## Impact Explanation

**HIGH Severity** - This vulnerability enables arbitrary manipulation of the fundamental lock duration parameter affecting all existing participants:

**Direct Fund Impact:**
- Users who locked tokens with a 100,000 minute expectation can withdraw prematurely after just 1 minute if the manager reduces `MinimumLockMinutes`
- Conversely, users expecting a 1-minute lock can be trapped for 100,000 minutes if the manager increases the value
- Breaks the core security guarantee that locked tokens remain inaccessible for the agreed duration

**Economic Model Breach:**
- Profit distribution schemes depend on predictable token lock durations to ensure fair dividend allocation
- Early withdrawal allows users to claim profits without maintaining expected commitment periods
- Undermines incentive alignment between scheme participants

**Trust Violation:**
- Users commit funds based on explicit lock period terms at registration time
- Unilateral parameter modification by the manager violates this agreement
- Affects all existing lockers simultaneously without their consent or awareness

## Likelihood Explanation

**HIGH Likelihood** - This vulnerability is trivially exploitable:

**Reachable Entry Point:**
`CreateScheme` is a public method callable by any address without special permissions. The scheme manager can simply invoke it again.

**Attack Complexity:**
Extremely low - requires only two transactions:
1. Initial `CreateScheme` with original parameters
2. Second `CreateScheme` with modified `MinimumLockMinutes`

**Attacker Prerequisites:**
- Must be the scheme manager (the address that created the scheme initially)
- No governance approvals or additional privileges required
- Standard transaction with normal gas costs

**Feasibility:**
- No race conditions or timing requirements
- No external dependencies
- Could occur accidentally (e.g., manager attempting to "update" scheme parameters)

**Detection:**
- Overwrite happens through normal contract call
- No specific events indicate parameter changes to existing schemes
- Users may not discover the change until attempting withdrawal

## Recommendation

Add validation to prevent duplicate scheme creation:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add this check
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
           "Scheme already exists for this manager.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
    
    // ... rest of the method
}
```

If scheme parameter updates are intended functionality, implement a separate `UpdateScheme` method with:
- Proper authorization checks
- Event emission for transparency
- Validation that changes don't retroactively harm existing participants
- Consider grace periods or migration mechanisms for affected users

## Proof of Concept

```csharp
[Fact]
public async Task ProofOfConcept_ManagerBypassesMinimumLockPeriod()
{
    const long originalLockMinutes = 100000;
    const long manipulatedLockMinutes = 1;
    const long userLockAmount = 1000;
    
    // Step 1: Manager creates scheme with 100,000 minute lock
    await TokenHolderContractStub.CreateScheme.SendAsync(
        new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "ELF",
            MinimumLockMinutes = originalLockMinutes
        });
    
    // Step 2: User locks tokens expecting 100,000 minute lock period
    var userStub = GetTester<TokenHolderContractImplContainer.TokenHolderContractImplStub>(
        TokenHolderContractAddress, UserKeyPairs.First());
    await userStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = Starter,
        Amount = userLockAmount
    });
    
    // Step 3: Manager calls CreateScheme again with 1 minute lock (EXPLOIT)
    await TokenHolderContractStub.CreateScheme.SendAsync(
        new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "ELF",
            MinimumLockMinutes = manipulatedLockMinutes
        });
    
    // Step 4: User can immediately withdraw instead of waiting 100,000 minutes
    var withdrawResult = await userStub.Withdraw.SendAsync(Starter);
    
    // Vulnerability confirmed: withdrawal succeeds after 1 minute instead of 100,000
    withdrawResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify tokens were unlocked
    var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserAddresses.First(),
        Symbol = "ELF"
    });
    balance.Balance.ShouldBeGreaterThanOrEqualTo(userLockAmount);
}
```

## Notes

The vulnerability is confirmed through direct code analysis. The `CreateScheme` method has no duplicate prevention logic, allowing managers to overwrite scheme parameters at will. The `UpdateTokenHolderProfitScheme` method retrieves the first Profit scheme ID but combines it with potentially overwritten `MinimumLockMinutes` values from the TokenHolder scheme storage, creating a dangerous parameter mismatch that can be exploited to bypass lock periods.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L166-167)
```csharp
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-284)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L290-298)
```csharp
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```
