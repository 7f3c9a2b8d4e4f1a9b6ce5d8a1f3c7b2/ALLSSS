# Audit Report

## Title
State Corruption in TokenHolder Scheme Initialization - Writes to Wrong Address

## Summary
The `UpdateTokenHolderProfitScheme` helper method contains a critical bug where it writes scheme initialization data to `Context.Sender` (the transaction caller) instead of to the `manager` parameter (the scheme owner's address). This causes permanent state corruption when users interact with newly created TokenHolder profit schemes, leaving the manager's scheme uninitialized and scattering scheme data across multiple addresses.

## Finding Description

The vulnerability exists in the private `UpdateTokenHolderProfitScheme` method. [1](#0-0) 

When a scheme is created via `CreateScheme`, it stores basic configuration (Symbol, MinimumLockMinutes, AutoDistributeThreshold) at the manager's address but leaves the `SchemeId` field as null. [2](#0-1) 

When any user subsequently calls operations like `ClaimProfits`, the contract invokes `GetValidScheme` which reads the scheme from the manager's address and calls `UpdateTokenHolderProfitScheme` to initialize the missing fields. [3](#0-2) 

The bug occurs at line 298 where the updated scheme (now containing the initialized `SchemeId` and `Period` fields fetched from the Profit contract) is written to `State.TokenHolderProfitSchemes[Context.Sender]` instead of `State.TokenHolderProfitSchemes[manager]`. This means the initialized data goes to the caller's address, not the scheme owner's address.

**Why Protections Fail**: Other methods in the same contract correctly write to the manager's address. For example, `DistributeProfits` and `RegisterForProfits` both write to `input.SchemeManager`. [4](#0-3) [5](#0-4) 

## Impact Explanation

**Severity: Medium** - The vulnerability causes operational denial of service and permanent state corruption but does not directly enable fund theft.

1. **View Function Failure**: The `GetProfitsMap` view function reads the scheme directly from the manager's address without validation. [6](#0-5)  When `SchemeId` remains null at the manager's address, it passes null to the Profit contract, causing failures or incorrect results.

2. **Permanent State Corruption**: The manager's scheme at `TokenHolderProfitSchemes[manager]` remains uninitialized indefinitely. Every subsequent call to methods like `ClaimProfits`, `ContributeProfits`, `RegisterForProfits`, or `Withdraw` repeats the bug, writing initialized data to different callers' addresses but never fixing the manager's state.

3. **Cross-Contamination**: If a caller who triggers the bug is also a scheme manager for a different scheme, their own scheme configuration at their address gets overwritten with the corrupted data from the manager's scheme they're interacting with.

4. **Inconsistent State**: Scheme data becomes fragmented - basic configuration fields exist at the manager's address while critical operational fields (SchemeId, Period) are scattered at various user addresses.

The actual profit distribution mechanism remains secure because it's handled by the underlying Profit contract based on properly registered beneficiary shares, preventing direct fund loss.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability is highly likely to occur in production environments:

1. **Multiple Entry Points**: The bug can be triggered through any of these public methods: `ClaimProfits`, `ContributeProfits`, `RegisterForProfits`, or `Withdraw`. [7](#0-6) [8](#0-7) [9](#0-8) [10](#0-9) 

2. **Realistic Preconditions**: The exploit only requires that a TokenHolder scheme is newly created and external users interact with it before the manager performs certain operations. This is a completely natural usage pattern - schemes are created to be used by beneficiaries.

3. **No Special Permissions Required**: Any user can trigger the bug through normal contract interaction without any privileged access.

4. **Attack Complexity: Low**: No sophisticated techniques are needed. The bug triggers automatically during routine operations.

## Recommendation

Fix the bug by writing the updated scheme to the `manager` address instead of `Context.Sender`:

```csharp
private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
    bool updateSchemePeriod)
{
    if (scheme.SchemeId != null && !updateSchemePeriod) return;
    var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
    {
        Manager = manager
    }).SchemeIds.FirstOrDefault();
    Assert(originSchemeId != null, "Origin scheme not found.");
    var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
    scheme.SchemeId = originScheme.SchemeId;
    scheme.Period = originScheme.CurrentPeriod;
    State.TokenHolderProfitSchemes[manager] = scheme;  // FIX: write to manager instead of Context.Sender
}
```

This aligns with the correct pattern used in other methods like `DistributeProfits` and `RegisterForProfits`.

## Proof of Concept

```csharp
[Fact]
public async Task StateCorruption_WritesToWrongAddress()
{
    // Alice creates a scheme
    var alice = Accounts[1].Address;
    var aliceStub = GetTokenHolderContractStub(Accounts[1].KeyPair);
    
    await aliceStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100
    });
    
    // Verify Alice's scheme has null SchemeId
    var aliceScheme = await aliceStub.GetScheme.CallAsync(alice);
    aliceScheme.SchemeId.ShouldBeNull();
    
    // Bob (different user) calls ContributeProfits for Alice's scheme
    var bob = Accounts[2].Address;
    var bobStub = GetTokenHolderContractStub(Accounts[2].KeyPair);
    
    await bobStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = alice,
        Symbol = "ELF",
        Amount = 100
    });
    
    // BUG: Alice's scheme still has null SchemeId (not initialized)
    aliceScheme = await aliceStub.GetScheme.CallAsync(alice);
    aliceScheme.SchemeId.ShouldBeNull(); // This should fail but doesn't - bug confirmed
    
    // BUG: Bob's address now has Alice's scheme data
    var bobScheme = await bobStub.GetScheme.CallAsync(bob);
    bobScheme.SchemeId.ShouldNotBeNull(); // Bob has scheme data he shouldn't have
    bobScheme.Symbol.ShouldBe("ELF"); // Bob has Alice's scheme configuration
    
    // View function failure: GetProfitsMap fails because Alice's SchemeId is null
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await aliceStub.GetProfitsMap.CallAsync(new ClaimProfitsInput
        {
            SchemeManager = alice,
            Beneficiary = bob
        });
    });
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L100-129)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.Self,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        State.TokenContract.Approve.Send(new ApproveInput
        {
            Spender = State.ProfitContract.Value,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        State.ProfitContract.ContributeProfits.Send(new Profit.ContributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Symbol = input.Symbol,
            Amount = input.Amount
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L131-147)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager, true);
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
        var distributeProfitsInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
        if (input.AmountsMap != null && input.AmountsMap.Any()) distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

        State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
        scheme.Period = scheme.Period.Add(1);
        State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-209)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

        // Check auto-distribute threshold.
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-245)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L247-257)
```csharp
    public override Empty ClaimProfits(ClaimProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
        var beneficiary = input.Beneficiary ?? Context.Sender;
        State.ProfitContract.ClaimProfits.Send(new Profit.ClaimProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = beneficiary
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L264-276)
```csharp
    public override ReceivedProfitsMap GetProfitsMap(ClaimProfitsInput input)
    {
        var scheme = State.TokenHolderProfitSchemes[input.SchemeManager];
        var profitsMap = State.ProfitContract.GetProfitsMap.Call(new Profit.ClaimProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary ?? Context.Sender
        });
        return new ReceivedProfitsMap
        {
            Value = { profitsMap.Value }
        };
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-284)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```
