### Title
Governance Bypass via Malicious Authorization Contract in Method Fee Controller

### Summary
The `ChangeMethodFeeController` method validates new authority by calling `ValidateOrganizationExist` on the attacker-supplied contract address without verifying it's a legitimate authorization contract. An attacker can obtain one Parliament approval to change the controller to point to a malicious contract, then permanently control method fees without further governance oversight, bypassing the intended Parliament-based governance mechanism.

### Finding Description

**Exact Code Locations:** [1](#0-0) [2](#0-1) 

**Root Cause:**
The `CheckOrganizationExist` validation method makes a cross-contract call to `authorityInfo.ContractAddress` to validate the organization exists. However, there is no validation ensuring this contract address is one of the legitimate system authorization contracts (Parliament, Association, or Referendum). The validation is circular - it asks the attacker-provided contract to validate itself. [2](#0-1) 

**Why Existing Protections Fail:**
The `AssertSenderAddressWith` check only verifies the caller is the current controller's owner address, which initially requires Parliament approval. However, once an attacker obtains ONE governance approval to execute `ChangeMethodFeeController`, they can provide arbitrary parameters including a malicious contract address that bypasses proper validation.

**System Contract Address Protection (Not Applicable to This Issue):**
State.ParliamentContract and State.TokenContract ARE protected because they're set via `Context.GetContractAddressByName`, which retrieves immutable addresses from the Genesis contract's name mapping: [3](#0-2) [4](#0-3) 

The `NameAddressMapping` is only set once during deployment and has no update mechanism: [5](#0-4) [6](#0-5) 

### Impact Explanation

**Governance Takeover:**
After obtaining one Parliament approval, the attacker permanently controls method fee configuration without requiring ongoing governance oversight. The attacker's address becomes the `MethodFeeController.Value.OwnerAddress` and can directly call `SetMethodFee` to set arbitrary transaction fees. [7](#0-6) 

**Protocol-Wide Impact:**
This pattern exists across multiple system contracts using the same vulnerable validation approach: [8](#0-7) [9](#0-8) 

**Severity Justification:**
Critical - Breaks the fundamental governance invariant that method fee controllers must be legitimate, auditable governance organizations subject to ongoing oversight.

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Deploy a malicious contract implementing `ValidateOrganizationExist` that always returns true
2. Create a Parliament proposal to call `ChangeMethodFeeController` with the malicious contract address
3. Obtain sufficient Parliament votes for proposal approval (realistic for a sophisticated attacker or during governance inattention)

**Attack Complexity:**
Moderate - Requires one successful governance proposal, but the malicious parameters may not be obvious during proposal review since the contract address appears as a valid address.

**Feasibility Conditions:**
The attack is executable when:
- Block Producers don't thoroughly validate the contract address in proposals
- The proposal is disguised or rushed through governance
- MPs assume address validation is handled by the contract logic itself

**Economic Rationality:**
High - The cost is obtaining one governance approval, but the reward is permanent control over method fees without further oversight. This enables censorship, DoS via prohibitive fees, or protocol manipulation.

### Recommendation

**Code-Level Mitigation:**
Add validation that the `ContractAddress` is a recognized system authorization contract before accepting the authority change:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    
    // NEW: Validate contract address is a legitimate authorization contract
    Assert(IsLegitimateAuthorizationContract(input.ContractAddress), 
        "Contract address must be Parliament, Association, or Referendum contract.");
    
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    State.MethodFeeController.Value = input;
    return new Empty();
}

private bool IsLegitimateAuthorizationContract(Address contractAddress)
{
    SetContractStateRequired(State.ParliamentContract, SmartContractConstants.ParliamentContractSystemName);
    SetContractStateRequired(State.AssociationContract, SmartContractConstants.AssociationContractSystemName);
    // Add Referendum contract check if needed
    
    return contractAddress == State.ParliamentContract.Value ||
           contractAddress == State.AssociationContract.Value;
}
```

**Invariant Checks:**
Ensure all controller change methods across system contracts validate that `AuthorityInfo.ContractAddress` is a whitelisted system authorization contract address.

**Test Cases:**
1. Test that `ChangeMethodFeeController` rejects non-system contract addresses
2. Test that only Parliament/Association/Referendum addresses are accepted
3. Test that user-deployed contracts mimicking authorization interfaces are rejected

### Proof of Concept

**Initial State:**
- CrossChain contract initialized with default Parliament controller
- Parliament default organization controls method fee changes

**Attack Steps:**

1. **Attacker deploys malicious contract:**
```
Deploy contract with ValidateOrganizationExist always returning true
MaliciousContract deployed at address 0xMALICIOUS
```

2. **Attacker creates Parliament proposal:**
```
Proposal parameters:
    - ToAddress: CrossChainContract
    - MethodName: ChangeMethodFeeController
    - Params: AuthorityInfo {
    ContractAddress: 0xMALICIOUS,
    OwnerAddress: AttackerAddress
  }
```

3. **Parliament approves and releases proposal:**
```
Sufficient BPs approve the proposal
Proposal executes ChangeMethodFeeController
```

4. **Validation bypass occurs:** [10](#0-9) 

The call to `CheckOrganizationExist` invokes the malicious contract, which returns true

5. **Controller permanently changed:**
```
State.MethodFeeController.Value = {
    ContractAddress: 0xMALICIOUS,
    OwnerAddress: AttackerAddress
}
```

6. **Attacker now controls fees without governance:**
```
Attacker directly calls SetMethodFee with arbitrary fees
No Parliament approval required for subsequent changes
```

**Expected vs Actual:**
- Expected: Only legitimate Parliament/Association/Referendum organizations control method fees
- Actual: Attacker-controlled address with fake governance contract controls fees

**Success Condition:**
The attack succeeds when `State.MethodFeeController.Value.ContractAddress` points to a non-system contract address after the governance proposal executes.

### Notes

**Critical Distinction:**
- `State.ParliamentContract` and `State.TokenContract` are SAFE - they use immutable system contract addresses from the Genesis contract name mapping
- `authorityInfo.ContractAddress` (user input) is VULNERABLE - no validation it's a legitimate authorization contract

**Cross-Contract Pattern:**
This vulnerability exists across multiple system contracts using the same validation pattern. A comprehensive fix requires updating all controller change methods system-wide.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_ACS1_TransactionFeeProvider.cs (L12-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_ACS1_TransactionFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_ACS1_TransactionFeeProvider.cs (L80-85)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L156-161)
```csharp
    private void SetContractStateRequired(ContractReferenceState state, string contractSystemName)
    {
        if (state.Value != null)
            return;
        state.Value = Context.GetContractAddressByName(contractSystemName);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L15-95)
```csharp
    private Address DeploySmartContract(Hash name, int category, byte[] code, bool isSystemContract,
        Address author, bool isUserContract, Address deployer = null, Hash salt = null)
    {
        if (name != null)
            Assert(State.NameAddressMapping[name] == null, "contract name has already been registered before");

        var codeHash = HashHelper.ComputeFrom(code);
        AssertContractNotExists(codeHash);

        long serialNumber;
        Address contractAddress;

        if (salt == null)
        {
            serialNumber = State.ContractSerialNumber.Value;
            // Increment
            State.ContractSerialNumber.Value = serialNumber + 1;
            contractAddress = AddressHelper.ComputeContractAddress(Context.ChainId, serialNumber);
        }
        else
        {
            serialNumber = 0;
            contractAddress = AddressHelper.ComputeContractAddress(deployer, salt);
        }

        Assert(State.ContractInfos[contractAddress] == null, "Contract address exists.");

        var info = new ContractInfo
        {
            SerialNumber = serialNumber,
            Author = author,
            Category = category,
            CodeHash = codeHash,
            IsSystemContract = isSystemContract,
            Version = 1,
            IsUserContract = isUserContract,
            Deployer = deployer
        };

        var reg = new SmartContractRegistration
        {
            Category = category,
            Code = ByteString.CopyFrom(code),
            CodeHash = codeHash,
            IsSystemContract = info.IsSystemContract,
            Version = info.Version,
            ContractAddress = contractAddress,
            IsUserContract = isUserContract
        };

        var contractInfo = Context.DeploySmartContract(contractAddress, reg, name);

        info.ContractVersion = contractInfo.ContractVersion;
        reg.ContractVersion = info.ContractVersion;

        State.ContractInfos[contractAddress] = info;
        State.SmartContractRegistrations[reg.CodeHash] = reg;

        Context.Fire(new ContractDeployed
        {
            CodeHash = codeHash,
            Address = contractAddress,
            Author = author,
            Version = info.Version,
            Name = name,
            ContractVersion = info.ContractVersion,
            Deployer = deployer
        });

        Context.LogDebug(() => "BasicContractZero - Deployment ContractHash: " + codeHash.ToHex());
        Context.LogDebug(() => "BasicContractZero - Deployment success: " + contractAddress.ToBase58());

        if (name != null)
            State.NameAddressMapping[name] = contractAddress;

        var contractCodeHashList =
            State.ContractCodeHashListMap[Context.CurrentHeight] ?? new ContractCodeHashList();
        contractCodeHashList.Value.Add(codeHash);
        State.ContractCodeHashListMap[Context.CurrentHeight] = contractCodeHashList;

        return contractAddress;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L45-78)
```csharp
    public override Empty ChangeSymbolsToPayTXSizeFeeController(AuthorityInfo input)
    {
        AssertControllerForSymbolToPayTxSizeFee();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.SymbolToPayTxFeeController.Value = input;
        return new Empty();
    }

    public override Empty ChangeSideChainRentalController(AuthorityInfo input)
    {
        AssertControllerForSideChainRental();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.SideChainRentalController.Value = input;
        return new Empty();
    }

    public override Empty ChangeCrossChainTokenContractRegistrationController(AuthorityInfo input)
    {
        CheckCrossChainTokenContractRegistrationControllerAuthority();
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.CrossChainTokenContractRegistrationController.Value = input;
        return new Empty();
    }

    public override Empty ChangeUserFeeController(AuthorityInfo input)
    {
        AssertUserFeeController();
        Assert(CheckOrganizationExist(input), "Invalid authority input.");
        State.UserFeeController.Value.RootController = input;
        State.UserFeeController.Value.ParliamentController = null;
        State.UserFeeController.Value.ReferendumController = null;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L366-382)
```csharp
    public override Empty ChangeContractDeploymentController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.ContractDeploymentController.Value = input;
        return new Empty();
    }

    public override Empty ChangeCodeCheckController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.CodeCheckController.Value.OwnerAddress);
        Assert(CheckOrganizationExist(input),
            "Invalid authority input.");
        State.CodeCheckController.Value = input;
        return new Empty();
    }
```
