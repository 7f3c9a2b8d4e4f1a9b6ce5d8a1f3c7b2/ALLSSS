### Title
Broken ImpliedIrreversibleBlockHeight Validation Allows Malicious LIB Manipulation

### Summary
The `LibInformationValidationProvider` validation is designed to prevent miners from reporting a lower `ImpliedIrreversibleBlockHeight` than previously recorded. However, a critical logic error causes `RecoverFromUpdateValue` to execute before the validation check, overwriting the baseline value with the attacker-provided value, making the validation compare a value against itself. This allows malicious miners to artificially lower the Last Irreversible Block (LIB) height, delaying chain finality.

### Finding Description

The vulnerability exists in the consensus validation flow in `AEDPoSContract_Validation.cs`. When validating consensus information before execution:

1. The current round is fetched from state as `baseRound` [1](#0-0) 

2. For UpdateValue behavior, `RecoverFromUpdateValue` is called on `baseRound`, which modifies it by copying values from the provided round, including `ImpliedIrreversibleBlockHeight` [2](#0-1) 

3. The recovery operation explicitly overwrites the miner's `ImpliedIrreversibleBlockHeight` in `baseRound` with the value from the provided round [3](#0-2) 

4. The validation context is then created using this **already-modified** `baseRound` [4](#0-3) 

5. `LibInformationValidationProvider` is added to validate the consensus information [5](#0-4) 

6. The validation check compares `baseRound[pubkey].ImpliedIrreversibleBlockHeight` (now equal to the provided value) with `providedRound[pubkey].ImpliedIrreversibleBlockHeight` [6](#0-5) 

**Root Cause**: Since `RecoverFromUpdateValue` executes before validation, the check effectively compares the attacker's value against itself (value > value = false), always passing regardless of whether the value decreased.

The malicious value is then stored in the round state during `ProcessUpdateValue` [7](#0-6)  and subsequently used in LIB calculation [8](#0-7) 

The LIB calculator retrieves implied heights from the previous round for miners who mined in the current round, sorts them, and takes the value at index `(count-1)/3` [9](#0-8) 

### Impact Explanation

**Consensus/Cross-Chain Integrity Violation**: A malicious miner can report an artificially low `ImpliedIrreversibleBlockHeight` (e.g., 500 instead of 1500), which directly affects the LIB calculation algorithm that uses these values to determine chain finality.

**Concrete Harm**:
- The LIB height is calculated using the 1/3 quantile of sorted implied heights from miners [10](#0-9) 
- A maliciously low value in the bottom third of sorted heights directly lowers the calculated LIB
- Lower LIB means delayed finality, as blocks take longer to become irreversible
- Cross-chain operations depend on LIB for indexing and verification, creating potential for inconsistencies
- Enables window for double-spend attempts by keeping blocks reversible longer than intended

**Severity**: HIGH - Direct violation of consensus finality guarantees, fundamental to blockchain security and cross-chain operations.

### Likelihood Explanation

**Attacker Capabilities**: Any active block producer (miner) in the current round can execute this attack, as they control the consensus extra data they submit [11](#0-10) 

**Attack Complexity**: LOW
- Miner generates consensus extra data where `ImpliedIrreversibleBlockHeight` is normally set to `Context.CurrentHeight`
- Miner modifies this value to be lower than their previous reported value
- Submit block with modified consensus data
- Broken validation fails to detect the manipulation

**Feasibility Conditions**:
- Attacker must be an active miner in the consensus round
- No cryptographic integrity check prevents modification (the hash validation in `ValidateConsensusAfterExecution` suffers from the same logic error)
- The attack is repeatable across multiple rounds

**Detection**: Low - The malicious values are stored in state but there's no alerting mechanism for abnormally low values relative to block heights.

**Probability**: MEDIUM-HIGH - Requires miner compromise but the attack is straightforward with guaranteed success due to the broken validation.

### Recommendation

**Immediate Fix**: Reorder the validation flow to check the **original** `baseRound` values before calling `RecoverFromUpdateValue`:

```
// In AEDPoSContract_Validation.cs, ValidateBeforeExecution:
1. Fetch baseRound from state
2. Create validation context with ORIGINAL baseRound (before recovery)
3. Run all validations including LibInformationValidationProvider
4. ONLY IF validation passes, then call RecoverFromUpdateValue
```

**Additional Invariant Checks**:
1. Add validation that `ImpliedIrreversibleBlockHeight` must be greater than or equal to the miner's previous round value
2. Add sanity check that `ImpliedIrreversibleBlockHeight` is within reasonable range of actual block height (e.g., within current height ± small tolerance)
3. Fix the hash validation in `ValidateConsensusAfterExecution` to compare against unmodified state

**Test Cases**:
1. Test that a miner providing lower `ImpliedIrreversibleBlockHeight` than previous round is rejected
2. Test that a miner providing `ImpliedIrreversibleBlockHeight` significantly below current block height is rejected
3. Test LIB calculation with mixed legitimate and manipulated values to verify proper rejection

### Proof of Concept

**Initial State**:
- Current round N, block height 1000
- Miner A previously reported `ImpliedIrreversibleBlockHeight = 999` in round N-1
- Miner A is scheduled to produce next block in round N

**Attack Steps**:
1. Miner A receives consensus command to produce block at height 1000
2. Normal flow: `GetConsensusBlockExtraData` would set `updatedRound.RealTimeMinersInformation[A].ImpliedIrreversibleBlockHeight = 1000`
3. **Attack**: Miner A modifies the consensus extra data to set `ImpliedIrreversibleBlockHeight = 500` (maliciously low)
4. Miner A submits block with this modified consensus data
5. `ValidateBeforeExecution` is called:
   - `baseRound[A].ImpliedIrreversibleBlockHeight = 999` (from state)
   - `RecoverFromUpdateValue` executes: sets `baseRound[A].ImpliedIrreversibleBlockHeight = 500`
   - `LibInformationValidationProvider` checks: if (500 > 500) → false → validation passes
6. `ProcessUpdateValue` stores 500 in `State.Rounds[N].RealTimeMinersInformation[A].ImpliedIrreversibleBlockHeight`

**Expected Result**: Validation should reject the block because 500 < 999 (decreasing value)

**Actual Result**: Validation passes, and the malicious value 500 is stored in state

**Success Condition**: In subsequent rounds when LIB is calculated using round N values, the artificially low value of 500 will be included in the sorted list, lowering the calculated LIB below its legitimate value.

---

**Notes**: This vulnerability directly contradicts the intended consensus invariant that miners cannot report decreasing implied irreversible block heights. The broken validation logic creates a critical security flaw in the finality mechanism, which is foundational to blockchain security and cross-chain operations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L82-82)
```csharp
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L19-19)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-282)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-33)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```
