# Audit Report

## Title
Missing Minimum Block Count Validation Allows Premature Round Termination in AEDPoS Consensus

## Summary
The AEDPoS consensus validation system lacks enforcement of minimum block production before allowing round transitions. The `ValidationForNextRound()` function only validates round number increments and InValue field states, enabling malicious miners to prematurely terminate rounds with insufficient participation, causing unfair penalties to legitimate miners and degrading network throughput.

## Finding Description

The `ValidationForNextRound()` method performs only two checks when validating NextRound transitions: [1](#0-0) 

These checks validate round number increments by exactly 1 and ensure all InValue fields are null, but **do not validate** that a minimum number of blocks were produced or that a minimum percentage of miners participated.

The validation system registers multiple providers for NextRound behavior: [2](#0-1) 

The `NextRoundMiningOrderValidationProvider` only ensures consistency between miners with `FinalOrderOfNextRound > 0` and those with `OutValue != null`, not that a minimum participated: [3](#0-2) 

Round generation accepts any number of miners who produced blocks: [4](#0-3) 

Where `GetMinedMiners()` simply returns all miners with `SupposedOrderOfNextRound != 0`: [5](#0-4) 

Miners who didn't produce blocks receive unfair `MissedTimeSlots` penalties: [6](#0-5) 

While `SolitaryMinerDetection` provides limited protection, it only prevents a single miner from mining alone after round 3: [7](#0-6) 

This protection is insufficient as it's off-chain (in `GetConsensusCommand`), only activates after round 3, and doesn't prevent 2+ miners from colluding.

The `NextRound` method is publicly callable by any current miner: [8](#0-7) 

With authorization only requiring the sender to be in the current or previous miner list: [9](#0-8) 

## Impact Explanation

**Consensus Integrity Violation:**
- Rounds can terminate with only 2 out of 10+ miners producing blocks, violating the expected consensus schedule
- Network fails to utilize full mining capacity as designed
- Expected block production timeline is disrupted

**Unfair Miner Penalization:**
- Miners who haven't reached their time slots get `MissedTimeSlots` incremented
- These miners are marked as having "missed" opportunities they never had
- Accumulation of undeserved penalties affects miner reputation and potentially reduces future rewards

**Operational DoS:**
- Repeated premature round termination significantly reduces overall block production rate
- Network throughput degraded as fewer blocks are produced per round than intended
- Legitimate blocks that should have been produced are permanently lost

**Attack Amplification:**
- In rounds 1-3: Single malicious miner can execute (SolitaryMinerDetection inactive)
- After round 3: Only 2+ miners needed (low collusion threshold)
- No economic disincentive or on-chain penalty prevents this behavior
- Attackers can manipulate miner ordering for the next round

**Severity: HIGH** - This directly compromises a critical consensus invariant (proper round transitions and fair miner scheduling) and enables operational degradation of the consensus mechanism.

## Likelihood Explanation

**Reachable Entry Point:**
The `NextRound` function is a public RPC method with minimal authorization requirements.

**Feasible Preconditions:**
- Attacker must be a current miner (achievable through standard election/staking process)
- Attacker must have produced their block (normal mining activity)
- For rounds 1-3: single miner can execute unilaterally
- For rounds 4+: requires only 2 miners (extremely low collusion threshold)

**Execution Practicality:**
1. Miner produces their block normally, setting `OutValue` and `SupposedOrderOfNextRound`
2. Miner calls `NextRound` with `NextRoundInput` containing only miners who produced blocks
3. All validation checks pass (verified in Finding Description)
4. Round advances prematurely with insufficient participation
5. Remaining miners unfairly penalized

**Detection/Operational Constraints:**
- No on-chain detection mechanism for insufficient block production
- `SolitaryMinerDetection` provides limited off-chain protection only
- Visible in block explorers but no automatic remediation
- Difficult to distinguish from legitimate network issues without deep analysis

**Economic Rationality:**
- Zero additional cost beyond normal mining operations
- No direct financial penalty for premature round termination
- Potential strategic benefit: manipulate early time slots in next round
- Extremely low barrier for 2+ miner coordination

**Likelihood: MEDIUM-HIGH** - Attack is practical with low complexity, requiring only miner status (publicly attainable) and minimal coordination (2 miners) after round 3.

## Recommendation

Add minimum participation validation to `RoundTerminateValidationProvider.ValidationForNextRound()`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing checks
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Enforce minimum participation threshold
    var totalMiners = validationContext.BaseRound.RealTimeMinersInformation.Count;
    var minedMiners = validationContext.BaseRound.GetMinedMiners().Count;
    var minimumRequired = totalMiners > 1 ? (totalMiners * 2 / 3) : 1; // 2/3 majority
    
    if (minedMiners < minimumRequired)
        return new ValidationResult 
        { 
            Message = $"Insufficient block production: {minedMiners}/{totalMiners} miners participated, minimum {minimumRequired} required." 
        };
    
    return new ValidationResult { Success = true };
}
```

This enforces a 2/3 supermajority participation requirement before allowing round termination, preventing premature transitions while maintaining liveness in legitimate network conditions.

## Proof of Concept

```csharp
[Fact]
public async Task PrematureRoundTermination_WithInsufficientMiners_ShouldFail()
{
    // Setup: Initialize consensus with 10 miners
    var minerCount = 10;
    var miners = GenerateMiners(minerCount);
    await InitializeConsensusAsync(miners);
    
    // Only 2 out of 10 miners produce blocks
    var miner1 = miners[0];
    var miner2 = miners[1];
    
    await ProduceBlockAsync(miner1);
    await ProduceBlockAsync(miner2);
    
    // Attempt to advance round with only 2/10 miners having participated
    var currentRound = await GetCurrentRoundAsync();
    var nextRoundInput = GenerateNextRoundInput(currentRound);
    
    // Execute NextRound call
    var result = await ExecuteNextRoundAsync(miner2, nextRoundInput);
    
    // VULNERABILITY: This succeeds when it should fail
    Assert.True(result.Success); // Currently passes - this is the bug
    
    // Verify unfair penalties were applied
    var newRound = await GetCurrentRoundAsync();
    var penalizedMiners = newRound.RealTimeMinersInformation.Values
        .Where(m => m.MissedTimeSlots > 0).Count();
    
    // 8 miners were unfairly penalized despite never having their time slot
    Assert.Equal(8, penalizedMiners); // Demonstrates the impact
}
```

This test demonstrates that `NextRound` succeeds with only 2/10 miners participating, and 8 miners are unfairly penalized with incremented `MissedTimeSlots`, confirming the vulnerability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-37)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L42-56)
```csharp
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L66-96)
```csharp
    private bool SolitaryMinerDetection(Round currentRound, string pubkey)
    {
        var isAlone = false;
        // Skip this detection until 4th round.
        if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
        {
            // Not single node.

            var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
            isAlone = minedMinersOfCurrentRound.Count == 0;

            // If only this node mined during previous round, stop mining.
            if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
            {
                var minedMiners = previousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }

            // check one further round.
            if (isAlone && TryToGetRoundInformation(previousRound.RoundNumber.Sub(1),
                    out var previousPreviousRound))
            {
                var minedMiners = previousPreviousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }
        }

        return isAlone;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```
