### Title
Broken ImpliedIrreversibleBlockHeight Validation Allows LIB Manipulation

### Summary
The `LibInformationValidationProvider.ValidateHeaderInformation()` contains a broken validation check that always passes due to premature state modification by `RecoverFromUpdateValue()`. This allows miners to set arbitrary `ImpliedIrreversibleBlockHeight` values without validation, enabling LIB (Last Irreversible Block) manipulation when sufficient miners collude.

### Finding Description

**Root Cause:**
The validation logic at lines 23-30 of `LibInformationValidationProvider.cs` attempts to prevent `ImpliedIrreversibleBlockHeight` from decreasing, but this check is completely ineffective. [1](#0-0) 

**Why the Check Fails:**
Before validation occurs, `RecoverFromUpdateValue()` is called in the validation flow, which modifies `baseRound` by copying `providedRound`'s `ImpliedIrreversibleBlockHeight` value: [2](#0-1) [3](#0-2) 

After line 19 of `Round_Recover.cs` executes, `baseRound[pubkey].ImpliedIrreversibleBlockHeight` equals `providedRound[pubkey].ImpliedIrreversibleBlockHeight`. The subsequent validation check compares this value to itself, making the condition `baseRound[pubkey].ImpliedIrreversibleBlockHeight > providedRound[pubkey].ImpliedIrreversibleBlockHeight` always evaluate to false.

**Missing Validations:**
1. No validation that `ImpliedIrreversibleBlockHeight` is monotonically increasing per miner
2. No bounds checking that `ImpliedIrreversibleBlockHeight <= Context.CurrentHeight`
3. No consistency check between implied and confirmed LIB values
4. No verification that the value is reasonable relative to the miner's previous reports

**Execution Path:**
When miners produce blocks with `UpdateValue` behavior, they should set `ImpliedIrreversibleBlockHeight` to the current block height: [4](#0-3) 

However, a malicious miner can modify this value in their block header before submitting, and the broken validation will accept any value. This value is then stored in the round state: [5](#0-4) 

### Impact Explanation

**Consensus Integrity Violation:**
These manipulated `ImpliedIrreversibleBlockHeight` values are used in LIB calculation in subsequent rounds: [6](#0-5) [7](#0-6) 

The LIB calculator uses a 2/3+1 consensus rule (taking the value at position `(count-1)/3` from sorted implied heights). 

**Attack Scenarios:**

1. **LIB Stalling (DoS):** If >1/3 of miners collude and report artificially low `ImpliedIrreversibleBlockHeight` values (e.g., 0 or far behind actual height), the LIB calculation will use these low values, preventing LIB from advancing. This stalls:
   - Cross-chain operations dependent on LIB
   - Block pruning and chain finalization
   - User transaction finality guarantees

2. **Premature LIB Advancement (Critical):** If >1/3 of miners report artificially high `ImpliedIrreversibleBlockHeight` values (exceeding actual irreversible height), the LIB could advance beyond truly irreversible blocks. This causes:
   - False finality signals to users and applications
   - Cross-chain bridges accepting non-final state
   - Potential for chain reorganization after "finality"
   - Violation of Byzantine fault tolerance guarantees

**Affected Parties:**
- All chain participants relying on LIB for finality
- Cross-chain bridges and side-chain operations
- Applications requiring transaction finality guarantees

### Likelihood Explanation

**Attacker Capabilities:**
- Any active miner can exploit this by modifying their block header data
- No special permissions beyond being in the current miner list
- Single miner can influence LIB calculation (limited by 2/3+1 rule)
- >1/3 colluding miners can fully control LIB progression

**Attack Complexity:**
- Low: Simply set `ImpliedIrreversibleBlockHeight` to arbitrary values in block headers
- The validation is broken and will always pass
- No cryptographic or computational barriers

**Feasibility Conditions:**
- Miner must be in active rotation (normal consensus operation)
- For significant impact, requires >1/3 miner collusion
- Detection: Malicious values would be visible on-chain but may not trigger alarms without specific monitoring

**Economic Rationality:**
- Attack cost: Minimal (just modify block data)
- Potential gain: DoS attack on chain, or advance LIB to create fake finality for double-spend attempts
- Risk: On-chain evidence of misbehavior, but validation doesn't prevent it

**Overall Likelihood:** Medium
- Single miner: Low-Medium impact, high probability
- Colluding miners (>1/3): High impact, lower probability but realistic in adversarial scenarios

### Recommendation

**Immediate Fix:**
Preserve the original `baseRound` state before calling `RecoverFromUpdateValue()` and use it for validation:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var baseRound = validationContext.BaseRound;
    var providedRound = validationContext.ProvidedRound;
    var pubkey = validationContext.SenderPubkey;
    
    // Store original implied LIB before baseRound was modified by RecoverFromUpdateValue
    var originalImpliedLib = validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.UpdateValue
        ? State.Rounds[baseRound.RoundNumber].RealTimeMinersInformation[pubkey]?.ImpliedIrreversibleBlockHeight ?? 0
        : 0;
    
    // Existing confirmed LIB checks
    if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
        providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
        (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
         baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
    {
        validationResult.Message = "Incorrect lib information.";
        return validationResult;
    }

    // Fixed implied LIB validation using original state
    if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
        providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0)
    {
        var providedImpliedLib = providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
        
        // Check monotonicity
        if (originalImpliedLib > providedImpliedLib)
        {
            validationResult.Message = "Implied lib height cannot decrease.";
            return validationResult;
        }
        
        // Add bounds checking
        if (providedImpliedLib > validationContext.ExtraData.Round.RoundNumber * 100 + 1000)  // Reasonable upper bound
        {
            validationResult.Message = "Implied lib height exceeds reasonable bounds.";
            return validationResult;
        }
    }

    validationResult.Success = true;
    return validationResult;
}
```

**Additional Invariant Checks:**
1. Validate `ImpliedIrreversibleBlockHeight <= currentBlockHeight + small_tolerance`
2. Validate `ImpliedIrreversibleBlockHeight >= ConfirmedIrreversibleBlockHeight - tolerance`
3. Validate rate of change is reasonable (not jumping thousands of blocks)

**Alternative Architecture:**
Consider moving validation BEFORE `RecoverFromUpdateValue()` is called, or pass both original and modified states to validators.

**Test Cases:**
1. Test that setting `ImpliedIrreversibleBlockHeight` backwards is rejected
2. Test that setting excessively high values is rejected
3. Test that valid monotonically increasing values are accepted
4. Test collusion scenarios with >1/3 miners setting malicious values

### Proof of Concept

**Initial State:**
- Active miner with pubkey "miner1" 
- Current round N with miner1's `ImpliedIrreversibleBlockHeight = 1000`
- Current block height = 1050

**Attack Steps:**

1. Miner prepares to produce block, receives consensus extra data with:
   ```
   ImpliedIrreversibleBlockHeight = 1050 (Context.CurrentHeight)
   ```

2. Malicious miner modifies block header before submission:
   ```
   UpdateValueInput.ImpliedIrreversibleBlockHeight = 500  // Artificially low (backwards)
   OR
   UpdateValueInput.ImpliedIrreversibleBlockHeight = 5000 // Artificially high (premature)
   ```

3. Block validation occurs:
   - `RecoverFromUpdateValue()` executes (line 47 of AEDPoSContract_Validation.cs)
   - `baseRound[miner1].ImpliedIrreversibleBlockHeight` becomes 500 or 5000
   - `LibInformationValidationProvider` validates (lines 23-30)
   - Condition checks: `baseRound[miner1].ImpliedIrreversibleBlockHeight (500) > providedRound[miner1].ImpliedIrreversibleBlockHeight (500)` 
   - Result: FALSE (values are equal), validation passes âœ“

4. Malicious value stored in state (line 248 of AEDPoSContract_ProcessConsensusInformation.cs)

5. Next round: `LastIrreversibleBlockHeightCalculator` uses this malicious value in LIB calculation

**Expected Result:** 
Validation should reject backwards or excessive forward jumps in `ImpliedIrreversibleBlockHeight`

**Actual Result:** 
Validation passes, allowing arbitrary values that corrupt LIB calculation in subsequent rounds

**Success Condition:** 
With >1/3 colluding miners, LIB can be stalled (low values) or advanced prematurely (high values), breaking consensus finality guarantees.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-60)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-20)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-281)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```
