### Title
Inconsistent Null Handling in GetProfitDetails Causes DoS in TokenHolder and Election Contracts

### Summary
The `GetProfitDetails()` view method returns `null` when accessing a non-existent beneficiary without any null checking, while the similar `GetAllProfitsMap()` method explicitly handles null cases. This inconsistency causes `NullReferenceException` crashes in multiple callers including `TokenHolderContract.AddBeneficiary`, `TokenHolderContract.RemoveBeneficiary`, and `ElectionContract_Elector`, creating a denial-of-service condition that prevents legitimate operations.

### Finding Description

The root cause is inconsistent null handling in the Profit contract's view methods: [1](#0-0) 

The nested dictionary access returns `null` when a beneficiary doesn't exist in a scheme, as confirmed by the AElf state storage implementation: [2](#0-1) [3](#0-2) 

In contrast, the similar method `GetAllProfitsMap()` properly handles null cases: [4](#0-3) 

This inconsistency causes crashes in multiple critical callers:

**TokenHolderContract.AddBeneficiary** - Crashes when adding a new beneficiary: [5](#0-4) 

**TokenHolderContract.RemoveBeneficiary** - Crashes on invalid beneficiary: [6](#0-5) 

**ElectionContract_Elector.GetProfitDetailByElectionVotingRecord** - Crashes when processing voting records: [7](#0-6) 

The Profit contract's own `AddBeneficiary` method demonstrates the correct pattern: [8](#0-7) 

### Impact Explanation

**Operational DoS Impact:**
- **TokenHolder schemes**: Scheme managers cannot add new beneficiaries to their profit schemes. The first `AddBeneficiary` call for any new address triggers a `NullReferenceException`, permanently blocking that operation path.
- **Election system**: Vote processing fails when querying profit details for voters who haven't been registered yet, disrupting the election reward distribution mechanism.
- **Profit scheme management**: Users cannot remove beneficiaries that don't exist (though this is a less critical self-DoS scenario).

**Affected parties:**
- TokenHolder scheme managers and participants
- Election voters and reward recipients  
- Any external contracts calling `GetProfitDetails` without null guards

**Severity justification:** This breaks core economic functionality (profit distribution, staking rewards, election rewards) across multiple critical contracts, preventing legitimate users from participating in the system's incentive mechanisms.

### Likelihood Explanation

**Reachable entry points:** All affected methods are public contract methods callable by users:
- `TokenHolderContract.AddBeneficiary` is callable by any scheme manager
- `TokenHolderContract.RemoveBeneficiary` is callable by scheme managers
- Election contract methods are triggered during normal voting operations

**Preconditions:** Minimal - simply calling `AddBeneficiary` with a new beneficiary address (the normal use case) triggers the vulnerability.

**Execution practicality:** The bug manifests during normal, legitimate operations. No special attack construction is needed - the first time anyone tries to add a new beneficiary to a TokenHolder scheme, the contract crashes.

**Economic rationality:** No attack cost - this occurs naturally during normal operations. A malicious scheme manager could intentionally DoS their own scheme, but more importantly, any legitimate user will encounter this when performing the first beneficiary addition.

**Detection/constraints:** The bug is deterministic and reproducible. Every `AddBeneficiary` call for a non-existent beneficiary will fail.

### Recommendation

**Immediate fix for GetProfitDetails:**

Add null handling consistent with `GetAllProfitsMap()`:

```csharp
public override ProfitDetails GetProfitDetails(GetProfitDetailsInput input)
{
    var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];
    return profitDetails ?? new ProfitDetails();
}
```

Location to modify: [1](#0-0) 

**Defensive fixes for callers:**

Add null checks in TokenHolderContract: [9](#0-8) 

Add null checks in ElectionContract: [10](#0-9) 

**Test cases:**
- Test `GetProfitDetails` with non-existent SchemeId
- Test `GetProfitDetails` with valid SchemeId but non-existent Beneficiary
- Test `TokenHolderContract.AddBeneficiary` for first-time beneficiary addition
- Test `TokenHolderContract.RemoveBeneficiary` with non-existent beneficiary
- Verify all view methods in the Profit contract have consistent null handling

### Proof of Concept

**Initial state:**
1. Deploy Profit, TokenHolder, and Token contracts
2. Create a TokenHolder profit scheme via `CreateScheme`
3. Scheme exists but has no beneficiaries yet

**Exploit sequence:**
```
Step 1: TokenHolderContractStub.AddBeneficiary({
    Beneficiary: <any_new_address>,
    Shares: 1
})

Expected: Beneficiary successfully added to the scheme
Actual: Transaction fails with NullReferenceException at line 46 of TokenHolderContract.cs
```

**Success condition:** 
The transaction fails instead of completing, preventing any new beneficiaries from being added to TokenHolder schemes. The DoS is complete when legitimate scheme managers cannot add participants to their profit distribution schemes.

**Evidence from codebase:**
The execution path is: `AddBeneficiary` → `GetProfitDetails.Call()` → returns `null` → `detail.Details.Any()` → `NullReferenceException`

State storage behavior confirming null return: [11](#0-10)

### Citations

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L46-49)
```csharp
    public override ProfitDetails GetProfitDetails(GetProfitDetailsInput input)
    {
        return State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L103-111)
```csharp
    private GetAllProfitsMapOutput GetAllProfitsMap(Hash schemeId, Address beneficiary, string symbol = null)
    {
        var scheme = State.SchemeInfos[schemeId];
        Assert(scheme != null, "Scheme not found.");
        beneficiary = beneficiary ?? Context.Sender;
        var profitDetails = State.ProfitDetailsMap[schemeId][beneficiary];

        if (profitDetails == null) return new GetAllProfitsMapOutput();

```

**File:** src/AElf.Types/Helper/SerializationHelper.cs (L88-91)
```csharp
        public static T Deserialize<T>(byte[] bytes)
        {
            if (bytes == null)
                return default;
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L26-37)
```csharp
    public TEntity this[TKey key]
    {
        get
        {
            if (!Cache.TryGetValue(key, out var valuePair))
            {
                valuePair = LoadKey(key);
                Cache[key] = valuePair;
            }

            return valuePair.IsDeleted ? SerializationHelper.Deserialize<TEntity>(null) : valuePair.Value;
        }
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L95-108)
```csharp
    private ValuePair LoadKey(TKey key)
    {
        var path = GetSubStatePath(key.ToString());
        var bytes = Provider.Get(path);
        var value = SerializationHelper.Deserialize<TEntity>(bytes);
        var originalValue = SerializationHelper.Deserialize<TEntity>(bytes);

        return new ValuePair
        {
            OriginalValue = originalValue,
            Value = value,
            IsDeleted = false
        };
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L40-56)
```csharp
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L74-78)
```csharp
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L168-180)
```csharp
    private ProfitDetail GetProfitDetailByElectionVotingRecord(ElectionVotingRecord electionVotingRecord)
    {
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
        // However, in the old world, profitDetail.Id is null, so use Shares.
        if (profitDetail == null)
        {
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```
