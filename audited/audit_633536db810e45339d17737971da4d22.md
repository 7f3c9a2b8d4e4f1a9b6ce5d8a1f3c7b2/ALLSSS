# Audit Report

## Title
Continuous Block Limit Bypass via Candidate Public Key Replacement

## Summary
A miner can bypass the continuous blocks production limit by exploiting the candidate public key replacement mechanism. When `ReplaceCandidatePubkey` is called, the consensus contract updates round information but fails to update the `LatestPubkeyToTinyBlocksCount` state, creating a pubkey mismatch that allows validation checks to be bypassed and the counter to be reset, enabling unlimited continuous block production.

## Finding Description

The AEDPoS consensus system enforces a continuous blocks limit (defined as `MaximumTinyBlocksCount = 8`) [1](#0-0)  to prevent network forks and ensure decentralization. This limit is tracked in `State.LatestPubkeyToTinyBlocksCount` [2](#0-1)  and enforced through three critical checkpoints:

**Validation Check:** The `ContinuousBlocksValidationProvider` validates that a miner hasn't exceeded the limit by checking if the stored pubkey matches the sender's pubkey and if the counter is negative [3](#0-2) 

**Command Generation Check:** The `GetConsensusCommand` method forces a `NextRound` behavior when the stored pubkey matches the miner's pubkey and the counter is negative [4](#0-3) 

**Counter Reset Logic:** The `ResetLatestProviderToTinyBlocksCount` method either decrements the counter (if pubkeys match) or resets it to maximum (if pubkeys differ) [5](#0-4) 

All three checks depend on pubkey equality comparison.

**Root Cause:** When a miner calls `ReplaceCandidatePubkey` through the Election contract [6](#0-5) , the consensus contract's `RecordCandidateReplacement` method updates the round information by swapping the old pubkey for the new one in `RealTimeMinersInformation` [7](#0-6) 

However, `RecordCandidateReplacement` **never updates** `State.LatestPubkeyToTinyBlocksCount`. This creates a permanent mismatch where:
- `LatestPubkeyToTinyBlocksCount.Pubkey` = old pubkey
- `SenderPubkey` / `_processingBlockMinerPubkey` = new pubkey

When the miner produces the next block with their new key:
1. **Validation passes** even if `BlocksCount < 0` because `"OLD" != "NEW"` returns false
2. **GetConsensusCommand** doesn't force `NextRound` behavior because the pubkey check fails
3. **Counter resets** to maximum value (`minersCountInTheory - 1`) instead of decrementing

The old pubkey becomes banned after replacement [8](#0-7) , but a miner can prepare multiple keypairs in advance and repeat this exploit indefinitely.

## Impact Explanation

**Consensus Integrity Violation:** The continuous blocks limit exists to prevent network instability and forks. The maximum blocks count is dynamically adjusted based on blockchain health to detect abnormal or severe network conditions [9](#0-8) 

By bypassing this limit, a malicious miner can:
- Produce unlimited continuous blocks by repeatedly changing keys
- Defeat fork prevention mechanisms designed to protect network synchronization
- Cause network instability for other nodes attempting to synchronize
- Violate protocol-level decentralization guarantees
- Undermine the blockchain health monitoring system

**Affected Parties:** All network participants suffer from potential network instability, increased fork risk, and compromised consensus integrity. This breaks a fundamental consensus safety mechanism that ensures no single miner can monopolize block production.

**Severity:** Medium - While this violates a critical consensus safety mechanism, it requires preparation (multiple keypairs), is visible on-chain, and doesn't directly steal funds or compromise other miners' rewards.

## Likelihood Explanation

**Attacker Capabilities:**
- Miner must control their candidate admin account (typical scenario verified by permission check [10](#0-9) )
- Miner must have multiple valid keypairs prepared in advance
- Each old key becomes banned after replacement, requiring fresh keypairs for each exploit iteration

**Attack Complexity:** Low - The attack requires only calling a public contract method (`ReplaceCandidatePubkey`) between block productions. No complex timing or state manipulation is needed.

**Feasibility:** High
- Entry point is publicly accessible with no special privileges required beyond normal miner admin control
- No rate limiting or cooldown period exists on key replacements (verified by examining all instances where `LatestPubkeyToTinyBlocksCount` is set)
- Miner can prepare multiple keypairs offline before initiating the attack
- Execution between blocks is straightforward

**Detection:** Partial - Replacements are visible on-chain via `CandidatePubkeyReplaced` events [11](#0-10) . However, distinguishing legitimate replacements from exploit attempts is difficult without additional context.

**Economic Rationality:** High - The cost is minimal (only transaction fees for calling `ReplaceCandidatePubkey`), no collateral is at risk, and the potential advantage in block production could provide competitive benefits.

**Overall Likelihood:** Medium - Practical for any motivated miner to execute with modest preparation of multiple keypairs.

## Recommendation

Update the `RecordCandidateReplacement` method to also update `State.LatestPubkeyToTinyBlocksCount` when a pubkey replacement occurs:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");

    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

    // If this candidate is current miner, need to modify current round information.
    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
    realTimeMinerInformation.Pubkey = input.NewPubkey;
    currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
    currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
    if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
        currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
    State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

    // FIX: Update LatestPubkeyToTinyBlocksCount to reflect the new pubkey
    if (State.LatestPubkeyToTinyBlocksCount.Value != null &&
        State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == input.OldPubkey)
    {
        State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
        {
            Pubkey = input.NewPubkey,
            BlocksCount = State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount
        };
    }

    // Notify Treasury Contract to update replacement information.
    State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
    {
        OldPubkey = input.OldPubkey,
        NewPubkey = input.NewPubkey,
        CurrentTermNumber = State.CurrentTermNumber.Value
    });

    return new Empty();
}
```

Additionally, consider implementing rate limiting on `ReplaceCandidatePubkey` to prevent rapid successive replacements.

## Proof of Concept

```csharp
[Fact]
public async Task ContinuousBlockLimitBypass_ViaKeyReplacement()
{
    // Setup: Miner produces blocks until counter reaches near limit
    var oldPubkey = "MINER_OLD_KEY";
    var newPubkey = "MINER_NEW_KEY";
    
    // Step 1: Miner produces 8 continuous blocks, counter reaches 0 or negative
    // At this point, validation should block further continuous blocks
    
    // Step 2: Miner calls ReplaceCandidatePubkey(oldPubkey, newPubkey)
    var result = await ElectionContractStub.ReplaceCandidatePubkey.SendAsync(
        new ReplaceCandidatePubkeyInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
    
    // Step 3: Verify RecordCandidateReplacement was called
    // Round info is updated with new pubkey
    var currentRound = await ConsensusContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    currentRound.RealTimeMinersInformation.ShouldContainKey(newPubkey);
    currentRound.RealTimeMinersInformation.ShouldNotContainKey(oldPubkey);
    
    // Step 4: Check LatestPubkeyToTinyBlocksCount - VULNERABILITY: Still has old pubkey
    var latestCount = await ConsensusContractStub.GetLatestPubkeyToTinyBlocksCount.CallAsync(new Empty());
    latestCount.Pubkey.ShouldBe(oldPubkey); // Still the old key!
    
    // Step 5: Miner produces next block with NEW key
    // Validation passes because "oldPubkey != newPubkey" check fails
    // Counter RESETS to maximum instead of staying negative
    
    // Step 6: Verify counter was reset (vulnerability confirmed)
    var updatedCount = await ConsensusContractStub.GetLatestPubkeyToTinyBlocksCount.CallAsync(new Empty());
    updatedCount.Pubkey.ShouldBe(newPubkey); // Now updated
    updatedCount.BlocksCount.ShouldBeGreaterThan(0); // RESET instead of negative!
    
    // Miner can now produce 8 MORE continuous blocks, bypassing the limit entirely
}
```

## Notes

This vulnerability specifically affects the continuous blocks limit enforcement mechanism in the AEDPoS consensus system. The root cause is the incomplete state synchronization in `RecordCandidateReplacement` [7](#0-6) . While the method correctly updates round information, it fails to update the `LatestPubkeyToTinyBlocksCount` state variable, causing all three enforcement checkpoints to fail their pubkey equality checks.

The validation context is constructed with the current state value [12](#0-11) , which means the old pubkey persists through the validation phase, allowing the bypass.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L44-44)
```csharp
    public SingletonState<LatestPubkeyToTinyBlocksCount> LatestPubkeyToTinyBlocksCount { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L350-364)
```csharp
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L245-246)
```csharp
        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L250-254)
```csharp
        Context.Fire(new CandidatePubkeyReplaced
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L42-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```
