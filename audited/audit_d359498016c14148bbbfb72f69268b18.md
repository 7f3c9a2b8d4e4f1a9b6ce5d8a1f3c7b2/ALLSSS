### Title
Referendum Organizations Can Be Permanently Bricked With Invalid Proposer Addresses

### Summary
The Referendum contract's organization validation only checks if the ProposerWhiteList is empty but does not validate that addresses within the list are valid (non-null, non-empty). An attacker can create organizations with whitelists containing only invalid addresses (null or empty ByteString values), which pass validation but are permanently unusable since no valid address can create proposals and the whitelist cannot be updated without executing a proposal.

### Finding Description

The vulnerability exists in the organization validation flow during creation: [1](#0-0) 

The `Empty()` method only checks if the count is zero, not whether the addresses in the list are valid. [2](#0-1) 

The `Validate()` method calls `organization.ProposerWhiteList.Empty()` and returns false if the list is empty, but never validates individual address validity. It only checks that the list is non-empty, not that addresses have valid ByteString values. [3](#0-2) 

During organization creation, if validation passes (line 28), the organization is stored in state. The issue is that protobuf3 allows Address messages with empty or null ByteString values to be added to the repeated `proposers` field. [4](#0-3) 

The ProposerWhiteList structure contains a repeated Address field with no inherent validation.

When attempting to create proposals, the authorization check occurs: [5](#0-4) 

The `Contains()` check will fail for any valid sender address because only invalid addresses exist in the whitelist. No valid user can create proposals.

The recovery mechanism is blocked: [6](#0-5) 

`ChangeOrganizationProposerWhiteList()` requires `Context.Sender` to be the organization address itself (line 141), which can only happen through proposal execution. Since no proposals can be created, the whitelist cannot be updated, permanently bricking the organization.

### Impact Explanation

**Operational Impact - Denial of Service:**
- Any user can create permanently unusable Referendum organizations that occupy state storage
- Legitimate users attempting to create organizations with specific configurations may find them pre-occupied by bricked organizations (deterministic address generation)
- State bloat from accumulation of unusable organizations
- Griefing attack vector requiring only gas costs

**Governance Impact:**
- Organizations intended for governance operations become non-functional
- No mechanism exists to recover or delete bricked organizations
- Affects the critical governance invariant requiring valid proposer whitelist checks

The severity is HIGH because it allows permanent DoS of the Referendum governance mechanism with minimal cost and no recovery path.

### Likelihood Explanation

**Reachable Entry Point:** [7](#0-6) 
The `CreateOrganization` method is publicly accessible to any user.

**Feasible Preconditions:**
- Attacker constructs a `CreateOrganizationInput` with ProposerWhiteList containing Address objects with empty ByteString values
- In protobuf3, this is trivial: `new Address { Value = ByteString.Empty }` or using default Address instances
- All other fields can be set to valid values to pass other validation checks

**Execution Practicality:**
- Single transaction to create the bricked organization
- Gas cost is minimal (standard organization creation)
- No special permissions or roles required
- Executable under normal AElf contract semantics

**Economic Rationality:**
- Attack cost: Only transaction gas fees
- Impact: Permanent DoS of organization functionality
- High impact-to-cost ratio makes this economically rational for griefing

The likelihood is HIGH due to trivial execution with public access and minimal cost.

### Recommendation

Add address validation to the `Validate()` method in `Referendum_Helper.cs`:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    
    // NEW: Validate all addresses in proposer whitelist
    foreach (var proposer in organization.ProposerWhiteList.Proposers)
    {
        if (proposer == null || proposer.Value.IsNullOrEmpty())
            return false;
    }
    
    Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

Add test case to verify rejection of invalid addresses:
```csharp
[Fact]
public async Task CreateOrganization_With_Invalid_Proposer_Address_Test()
{
    var validInput = GetValidCreateOrganizationInput();
    validInput.ProposerWhiteList.Proposers.Clear();
    validInput.ProposerWhiteList.Proposers.Add(new Address { Value = ByteString.Empty });
    var ret = await ReferendumContractStub.CreateOrganization.SendWithExceptionAsync(validInput);
    ret.TransactionResult.Error.ShouldContain("Invalid organization data");
}
```

**Note:** The same validation should be applied to `ChangeOrganizationProposerWhiteList()` to prevent updating to an invalid whitelist.

### Proof of Concept

**Initial State:**
- Referendum contract deployed and initialized
- Attacker has account with sufficient gas

**Attack Steps:**

1. Construct malicious organization input:
```csharp
var maliciousInput = new CreateOrganizationInput
{
    TokenSymbol = "ELF",
    ProposalReleaseThreshold = new ProposalReleaseThreshold
    {
        MinimalApprovalThreshold = 1,
        MinimalVoteThreshold = 1,
        MaximalAbstentionThreshold = 0,
        MaximalRejectionThreshold = 0
    },
    ProposerWhiteList = new ProposerWhiteList
    {
        Proposers = { new Address { Value = ByteString.Empty } }
    }
};
```

2. Call `CreateOrganization(maliciousInput)`
   - Expected: Validation fails with "Invalid organization data"
   - **Actual: Organization created successfully** (vulnerability present)

3. Attempt to create proposal with valid address:
```csharp
var proposalInput = new CreateProposalInput
{
    OrganizationAddress = organizationAddress,
    // ... other valid fields
};
await ReferendumContractStub.CreateProposal(proposalInput);
```
   - Result: Transaction fails with "Unauthorized to propose"

4. Attempt to update whitelist:
```csharp
await ReferendumContractStub.ChangeOrganizationProposerWhiteList(validWhitelist);
```
   - Result: Transaction fails (only organization address can call)

**Success Condition:** Organization exists in state but no valid address can create proposals or update the whitelist, confirming permanent bricking.

### Citations

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L13-16)
```csharp
    public static bool Empty(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Count() == 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L12-40)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            TokenSymbol = input.TokenSymbol,
            OrganizationHash = organizationHash,
            ProposerWhiteList = input.ProposerWhiteList,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization data.");

        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;

        State.Organizations[organizationAddress] = organization;
        Context.Fire(new OrganizationCreated
        {
            OrganizationAddress = organizationAddress
        });

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** protobuf/acs3.proto (L139-142)
```text
message ProposerWhiteList{
    // The address of the proposers
    repeated aelf.Address proposers = 1;
}
```
