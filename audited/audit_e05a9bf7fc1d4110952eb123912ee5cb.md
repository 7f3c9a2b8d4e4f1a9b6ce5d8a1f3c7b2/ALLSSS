### Title
Permanent Method Fee Controller Lock Due to Null Parliament Contract During Initialization

### Summary
If `RequiredMethodFeeControllerSet()` is invoked when the Parliament contract is not deployed or not registered, it persists an `AuthorityInfo` with null `OwnerAddress` to `State.MethodFeeController.Value`. This creates a permanently locked state where no address can satisfy the authorization check (`Context.Sender == null` is always false), preventing any future calls to `ChangeMethodFeeController()` or `SetMethodFee()` from succeeding, thus permanently breaking method fee governance for the TokenContract.

### Finding Description

The vulnerability exists in the `RequiredMethodFeeControllerSet()` method [1](#0-0) .

When `State.MethodFeeController.Value` is null, the method attempts to retrieve the Parliament contract address. If `Context.GetContractAddressByName()` returns null (Parliament not deployed or not registered), the code proceeds to create an empty `AuthorityInfo` object. The conditional check at line 101 fails because `State.ParliamentContract.Value` is null, so the `defaultAuthority` object remains with null `OwnerAddress` and null `ContractAddress`. This invalid authority is then persisted to state at line 108.

Once this state corruption occurs, subsequent calls to `ChangeMethodFeeController()` [2](#0-1)  will always fail at line 27, where `AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress)` evaluates to checking if `Context.Sender == null`. Since `Context.Sender` can never be null in AElf's execution model, this assertion always fails [3](#0-2) .

Similarly, `SetMethodFee()` calls `RequiredMethodFeeControllerSet()` first and then checks sender authorization at line 18, which also fails for the same reason [4](#0-3) .

The `CheckOrganizationExist()` validation at line 28-29 would also fail if reached, as it attempts to call a null contract address [5](#0-4) .

### Impact Explanation

**Governance Breakdown**: The method fee controller becomes permanently locked, preventing any changes to transaction fee parameters or controller authority for the TokenContract - a core system contract responsible for all token operations.

**No Recovery Path**: There is no administrative override or emergency recovery mechanism. Even contract upgrades via the Genesis contract's `UpdateSmartContract` mechanism would preserve the corrupted state [6](#0-5) , as state is maintained across upgrades and any migration method would still need to pass the same broken authorization check.

**System-Wide Impact**: Since TokenContract is a foundational system contract used across the entire blockchain, this affects the ability to adjust economic parameters like transaction fees, which are critical for chain operation and governance.

**Severity**: HIGH - Complete and permanent loss of method fee governance capability for a critical system contract, with no recovery mechanism.

### Likelihood Explanation

**Precondition**: The vulnerability requires that `RequiredMethodFeeControllerSet()` be called (via `ChangeMethodFeeController()`, `SetMethodFee()`, or `GetMethodFeeController()`) before the Parliament contract is deployed and registered in the Genesis contract's name registry.

**Normal Deployment Protection**: In standard mainchain and sidechain deployments, Parliament is deployed before Token in the deployment sequence [7](#0-6)  and [8](#0-7) , which should prevent this scenario.

**Edge Cases**: However, the code explicitly anticipates this scenario with the comment "Parliament Auth Contract maybe not deployed" [9](#0-8) , suggesting the developers considered non-standard deployment scenarios such as:
- Test environments where Parliament is intentionally omitted
- Custom contract deployment configurations
- Manual deployments outside the standard initialization provider flow
- Timing issues during parallel initialization

**Trigger Complexity**: LOW - Any call to the affected methods triggers the vulnerability if preconditions are met.

**Overall Likelihood**: MEDIUM - While unlikely in production with standard deployment procedures, the defensive code pattern indicates this scenario was anticipated, and misconfigurations or non-standard deployments could trigger it.

### Recommendation

**Immediate Fix**: Modify `RequiredMethodFeeControllerSet()` to prevent persisting an invalid controller state:

```csharp
private void RequiredMethodFeeControllerSet()
{
    if (State.MethodFeeController.Value != null) return;
    if (State.ParliamentContract.Value == null)
        State.ParliamentContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

    // Do not persist controller if Parliament is not available
    Assert(State.ParliamentContract.Value != null, 
        "Parliament contract must be deployed before method fee controller can be initialized.");
    
    var defaultAuthority = new AuthorityInfo
    {
        OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
        ContractAddress = State.ParliamentContract.Value
    };

    State.MethodFeeController.Value = defaultAuthority;
}
```

**Alternative Approach**: Add a separate initialization method that must be called after Parliament deployment to explicitly set the controller, similar to how `InitializeAuthorizedController` works for other controllers [10](#0-9) .

**Deployment Validation**: Add deployment-time checks in `TokenContractInitializationProvider` to verify Parliament is deployed before TokenContract initialization proceeds [11](#0-10) .

**Emergency Recovery**: Implement a recovery method callable only by the Genesis contract that can reset the MethodFeeController in case of initialization failure.

### Proof of Concept

**Initial State**:
1. Genesis contract deployed
2. TokenContract deployed but Parliament contract NOT deployed or not registered

**Attack Sequence**:
1. Any user calls `GetMethodFeeController()` on TokenContract
   - This triggers `RequiredMethodFeeControllerSet()` at line 56
   - `State.MethodFeeController.Value` is null, so execution continues
   - `Context.GetContractAddressByName()` returns null
   - Empty `AuthorityInfo` with null fields is created
   - Persisted to `State.MethodFeeController.Value` at line 108

2. Later, after Parliament is deployed, operator attempts to call `ChangeMethodFeeController(validAuthority)`
   - `RequiredMethodFeeControllerSet()` returns early (controller already set)
   - Line 27 checks: `Context.Sender == null` → Always false
   - Transaction reverts with "Unauthorized behavior."

3. Operator attempts to call `SetMethodFee(fees)`
   - Line 18 checks: `Context.Sender == null` → Always false  
   - Transaction reverts with "Unauthorized to set method fee."

**Expected Result**: Should either block initialization until Parliament is available, or allow updating from null state.

**Actual Result**: Method fee controller permanently locked, no recovery possible.

**Success Condition**: All attempts to modify method fees or change controller fail with authorization errors, and state inspection shows `MethodFeeController.Value.OwnerAddress == null`.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L91-109)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo();

        // Parliament Auth Contract maybe not deployed.
        if (State.ParliamentContract.Value != null)
        {
            defaultAuthority.OwnerAddress =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
            defaultAuthority.ContractAddress = State.ParliamentContract.Value;
        }

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L111-114)
```csharp
    private void AssertSenderAddressWith(Address address)
    {
        Assert(Context.Sender == address, "Unauthorized behavior.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L15-80)
```csharp
    private Address DeploySmartContract(Hash name, int category, byte[] code, bool isSystemContract,
        Address author, bool isUserContract, Address deployer = null, Hash salt = null)
    {
        if (name != null)
            Assert(State.NameAddressMapping[name] == null, "contract name has already been registered before");

        var codeHash = HashHelper.ComputeFrom(code);
        AssertContractNotExists(codeHash);

        long serialNumber;
        Address contractAddress;

        if (salt == null)
        {
            serialNumber = State.ContractSerialNumber.Value;
            // Increment
            State.ContractSerialNumber.Value = serialNumber + 1;
            contractAddress = AddressHelper.ComputeContractAddress(Context.ChainId, serialNumber);
        }
        else
        {
            serialNumber = 0;
            contractAddress = AddressHelper.ComputeContractAddress(deployer, salt);
        }

        Assert(State.ContractInfos[contractAddress] == null, "Contract address exists.");

        var info = new ContractInfo
        {
            SerialNumber = serialNumber,
            Author = author,
            Category = category,
            CodeHash = codeHash,
            IsSystemContract = isSystemContract,
            Version = 1,
            IsUserContract = isUserContract,
            Deployer = deployer
        };

        var reg = new SmartContractRegistration
        {
            Category = category,
            Code = ByteString.CopyFrom(code),
            CodeHash = codeHash,
            IsSystemContract = info.IsSystemContract,
            Version = info.Version,
            ContractAddress = contractAddress,
            IsUserContract = isUserContract
        };

        var contractInfo = Context.DeploySmartContract(contractAddress, reg, name);

        info.ContractVersion = contractInfo.ContractVersion;
        reg.ContractVersion = info.ContractVersion;

        State.ContractInfos[contractAddress] = info;
        State.SmartContractRegistrations[reg.CodeHash] = reg;

        Context.Fire(new ContractDeployed
        {
            CodeHash = codeHash,
            Address = contractAddress,
            Author = author,
            Version = info.Version,
            Name = name,
            ContractVersion = info.ContractVersion,
```

**File:** src/AElf.Blockchains.MainChain/MainChainContractDeploymentListProvider.cs (L18-34)
```csharp
        return new List<Hash>
        {
            VoteSmartContractAddressNameProvider.Name,
            ProfitSmartContractAddressNameProvider.Name,
            ElectionSmartContractAddressNameProvider.Name,
            TreasurySmartContractAddressNameProvider.Name,
            ParliamentSmartContractAddressNameProvider.Name,
            AssociationSmartContractAddressNameProvider.Name,
            ReferendumSmartContractAddressNameProvider.Name,
            TokenSmartContractAddressNameProvider.Name,
            CrossChainSmartContractAddressNameProvider.Name,
            ConfigurationSmartContractAddressNameProvider.Name,
            ConsensusSmartContractAddressNameProvider.Name,
            TokenConverterSmartContractAddressNameProvider.Name,
            TokenHolderSmartContractAddressNameProvider.Name,
            EconomicSmartContractAddressNameProvider.Name
        };
```

**File:** src/AElf.Blockchains.SideChain/SideChainContractDeploymentListProvider.cs (L18-29)
```csharp
        return new List<Hash>
        {
            ProfitSmartContractAddressNameProvider.Name,
            TokenHolderSmartContractAddressNameProvider.Name,
            ConsensusSmartContractAddressNameProvider.Name,
            AssociationSmartContractAddressNameProvider.Name,
            ReferendumSmartContractAddressNameProvider.Name,
            ParliamentSmartContractAddressNameProvider.Name,
            TokenSmartContractAddressNameProvider.Name,
            CrossChainSmartContractAddressNameProvider.Name,
            ConfigurationSmartContractAddressNameProvider.Name
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L16-43)
```csharp
    public override Empty InitializeAuthorizedController(Empty input)
    {
        var defaultParliamentController = GetDefaultParliamentController();
        if (State.UserFeeController.Value == null)
        {
            var defaultUserFeeController = GetDefaultUserFeeController(defaultParliamentController);
            CreateReferendumControllerForUserFee(defaultParliamentController.OwnerAddress);
            CreateAssociationControllerForUserFee(defaultParliamentController.OwnerAddress,
                defaultUserFeeController.ReferendumController.OwnerAddress);
            State.UserFeeController.Value = defaultUserFeeController;
        }

        if (State.DeveloperFeeController.Value == null)
        {
            var developerController = GetDefaultDeveloperFeeController(defaultParliamentController);
            CreateDeveloperController(defaultParliamentController.OwnerAddress);
            CreateAssociationControllerForDeveloperFee(defaultParliamentController.OwnerAddress,
                developerController.DeveloperController.OwnerAddress);
            State.DeveloperFeeController.Value = developerController;
        }

        if (State.SideChainCreator.Value == null || State.SideChainRentalController.Value != null) return new Empty();
        var sideChainRentalController = GetDefaultSideChainRentalController(defaultParliamentController);
        CreateAssociationControllerForSideChainRental(State.SideChainCreator.Value,
            defaultParliamentController.OwnerAddress);
        State.SideChainRentalController.Value = sideChainRentalController;
        return new Empty();
    }
```

**File:** src/AElf.Kernel.Token/TokenContractInitializationProvider.cs (L24-129)
```csharp
    public virtual List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        var methodList = new List<ContractInitializationMethodCall>();
        var initializationData = _tokenContractInitializationDataProvider.GetContractInitializationData();

        // For the main chain, we use the economic contract to initialize the token contract.
        // So no initialization methods are required in here.
        // But for the side chain, which has no economic contract, we need initialize token contract.
        if (initializationData != null)
        {
            var nativeTokenInfo = TokenInfo.Parser.ParseFrom(initializationData.NativeTokenInfoData);
            var resourceTokenList =
                TokenInfoList.Parser.ParseFrom(initializationData.ResourceTokenListData);

            // native token
            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractContainer.TokenContractStub.Create),
                Params = GenerateTokenCreateInput(nativeTokenInfo).ToByteString()
            });

            // resource token
            foreach (var resourceTokenInfo in resourceTokenList.Value)
                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.Create),
                    Params = GenerateTokenCreateInput(resourceTokenInfo).ToByteString()
                });

            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractContainer.TokenContractStub.InitialCoefficients),
                Params = new Empty().ToByteString()
            });

            if (initializationData.PrimaryTokenInfoData != null)
            {
                // primary token
                var chainPrimaryTokenInfo =
                    TokenInfo.Parser.ParseFrom(initializationData.PrimaryTokenInfoData);

                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.Create),
                    Params = GenerateTokenCreateInput(chainPrimaryTokenInfo, initializationData.Creator)
                        .ToByteString()
                });

                foreach (var issueStuff in initializationData.TokenInitialIssueList)
                    methodList.Add(new ContractInitializationMethodCall
                    {
                        MethodName = nameof(TokenContractContainer.TokenContractStub.Issue),
                        Params = new IssueInput
                        {
                            Symbol = chainPrimaryTokenInfo.Symbol,
                            Amount = issueStuff.Amount,
                            Memo = "Initial issue",
                            To = issueStuff.Address
                        }.ToByteString()
                    });

                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.SetPrimaryTokenSymbol),
                    Params = new SetPrimaryTokenSymbolInput
                    {
                        Symbol = chainPrimaryTokenInfo.Symbol
                    }.ToByteString()
                });
            }
            else
            {
                // set primary token with native token 
                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.SetPrimaryTokenSymbol),
                    Params = new SetPrimaryTokenSymbolInput
                    {
                        Symbol = nativeTokenInfo.Symbol
                    }.ToByteString()
                });
            }

            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractContainer.TokenContractStub.InitializeFromParentChain),
                Params = new InitializeFromParentChainInput
                {
                    ResourceAmount = { initializationData.ResourceAmount },
                    RegisteredOtherTokenContractAddresses =
                    {
                        initializationData.RegisteredOtherTokenContractAddresses
                    },
                    Creator = initializationData.Creator
                }.ToByteString()
            });

            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractContainer.TokenContractStub.InitializeAuthorizedController),
                Params = ByteString.Empty
            });
        }

        return methodList;
    }
```
