# Audit Report

## Title
Side Chain Validator Permanent Control Through Cross-Chain Indexing Censorship

## Summary
AElf side chains lack autonomous validator update mechanisms, creating a critical architectural vulnerability where validators can maintain permanent control by refusing to index parent chain consensus data. Since validator updates require current validators' cooperation through cross-chain indexing, compromised validators can censor this process indefinitely with no recovery path.

## Finding Description

Side chains in AElf's architecture contain a structural flaw in their validator update mechanism that creates an unbreakable circular dependency.

**The Critical Design Flaw:**

Side chains receive their initial validator set from the parent chain's current miners during deployment. [1](#0-0)  However, unlike main chains which use election-based validator updates through NextTerm transitions, side chains permanently operate in NextRound mode [2](#0-1)  and have no Election Contract. [3](#0-2) 

**The Only Update Path:**

The sole mechanism for validator updates on side chains is through `GenerateNextRoundInformation`, which checks if the main chain miner list has changed. [4](#0-3)  This check depends on `State.MainChainCurrentMinerList.Value`, which is ONLY updated by `UpdateInformationFromCrossChain`. [5](#0-4) 

**The Circular Dependency:**

`UpdateInformationFromCrossChain` can ONLY be called by the CrossChain contract and ONLY on side chains. [6](#0-5)  The CrossChain contract calls this method ONLY when indexing parent chain blocks containing consensus extra data. [7](#0-6) 

However, both proposing and releasing cross-chain indexing require the caller to be a current miner: [8](#0-7) [9](#0-8)  This permission check delegates to the consensus contract's `IsCurrentMiner` verification. [10](#0-9) 

**Why Alternative Protections Don't Exist:**

The `RecordCandidateReplacement` mechanism requires an Election Contract sender, [11](#0-10)  which side chains never initialize. The evil node replacement logic in `GenerateNextRoundInformation` is explicitly only for main chains. [12](#0-11) 

**Attack Execution:**

If validators become compromised or collude after side chain deployment:
1. They refuse to call `ProposeCrossChainIndexing` or `ReleaseCrossChainIndexingProposal` with parent chain consensus data
2. `State.MainChainCurrentMinerList` never updates
3. `GenerateNextRoundInformation` never changes the validator set
4. Malicious validators maintain permanent control with zero consequences

No emergency governance override, time-bound updates, or parent chain force mechanisms exist to break this cycle.

## Impact Explanation

**Critical Severity** - This represents a complete compromise of side chain security and governance:

**Permanent Governance Capture:** Compromised validators maintain indefinite control over all consensus, block production, and transaction inclusion on the side chain. They can censor transactions, manipulate block ordering, and prevent any governance actions requiring validator participation.

**Cross-Chain Bridge Failure:** The side chain becomes isolated from parent chain updates. Users cannot receive legitimate validator list changes, security patches, or protocol upgrades. Cross-chain asset transfers and state synchronization break down completely.

**No Recovery Path:** Unlike main chains with slashing, delegation changes, and election mechanisms, side chains have zero recovery options. The parent chain cannot force updates, governance organizations cannot override validator actions, and time-based mechanisms don't exist. The only option is complete side chain abandonment via `DisposeSideChain`, which doesn't recover user funds or state.

**Trust Model Violation:** The fundamental architecture assumes parent chains can govern side chains, but this assumption is broken. A side chain with compromised validators becomes a separate, ungovernable chain while still claiming parent chain legitimacy.

**Affected Parties:**
- All users and applications on the compromised side chain
- Parent chain stakeholders expecting governance authority
- Cross-chain protocols depending on reliable validator synchronization
- Asset holders with locked funds on the side chain

## Likelihood Explanation

**High Likelihood** given the right preconditions:

**Realistic Threat Model:** While initial validators are legitimately set from the parent chain, post-deployment validator compromise is a realistic threat:
- Validators could be coerced by external parties controlling side chain economic incentives
- Validator keys could be stolen through social engineering or infrastructure compromise
- Validators could collude for economic gain specific to the side chain
- Single entity could acquire control of multiple validator keys over time

**Trivial Attack Execution:** The attack is entirely passive - malicious validators simply don't call two specific public functions. No complex exploits, timing attacks, or cryptographic breaks required. Attack success probability is 100% once validators are compromised.

**Difficult Detection:** The attack appears identical to network connectivity issues or operational failures. No automatic alerts exist, and distinguishing malicious censorship from technical problems is nearly impossible without out-of-band communication.

**No Countermeasures:** The architecture provides zero defensive mechanisms:
- No time-bound forced updates
- No emergency governance overrides
- No parent chain intervention capability
- No alternative validator update paths
- No slashing or penalties for refusing to index

## Recommendation

Implement multiple recovery mechanisms for side chain validator updates:

**1. Time-Bound Forced Updates:**
Add a maximum staleness check in `GenerateNextRoundInformation` that forces validator rotation if parent chain data hasn't been indexed within a specified period (e.g., 7 days). This breaks the circular dependency by making continued operation dependent on timely indexing.

**2. Parent Chain Override Capability:**
Create a mechanism where the parent chain's governance (Parliament) can force a validator update on the side chain through a special cross-chain message that bypasses the current validator permission check.

**3. Emergency Governance Path:**
Implement an emergency organization (multi-sig of trusted parties) that can call `UpdateInformationFromCrossChain` directly during crisis scenarios, with strict authorization controls and time-locks.

**4. Minimum Indexing Requirements:**
Modify consensus validation to require validators to demonstrate recent cross-chain indexing activity (e.g., must have indexed within last N blocks) to remain eligible for block production.

**Example Implementation:**
```csharp
// In GenerateNextRoundInformation
if (!IsMainChain)
{
    var staleness = Context.CurrentBlockTime - State.LastMainChainIndexTime.Value;
    if (staleness > State.MaxStalenessSeconds.Value)
    {
        // Force emergency validator rotation or enter safe mode
        Assert(false, "Side chain critically out of sync with parent chain");
    }
    
    if (IsMainChainMinerListChanged(currentRound))
    {
        // existing logic
    }
}
```

## Proof of Concept

A complete proof of concept would require:
1. Deploy a side chain with initial validators copied from main chain
2. Have validators process blocks normally initially
3. Validators stop calling `ProposeCrossChainIndexing` for parent chain data
4. Verify main chain validator list updates normally through elections
5. Verify side chain validator list never updates
6. Demonstrate no recovery mechanism exists (DisposeSideChain only terminates, doesn't recover)

The vulnerability is provable through code analysis showing the circular dependency exists with no break conditions.

---

**Notes:**

This vulnerability differs from typical "compromised key" scenarios because:
- Initial state is legitimate (validators properly authorized)
- Vulnerability is in missing **recovery mechanisms** for post-deployment compromise
- Similar to smart contracts lacking emergency pause functionality

The severity is justified by complete governance capture with no time-bound recovery, distinguishing it from temporary DoS scenarios that naturally resolve.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L218-224)
```csharp
    private ByteString GetInitialConsensusInformation()
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var miners = State.CrossChainInteractionContract.GetChainInitializationInformation.Call(new BytesValue());
        return miners.Value;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L783-788)
```csharp
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L16-23)
```csharp
        /// <summary>
        ///     Simply return NEXT_ROUND for side chain.
        /// </summary>
        /// <returns></returns>
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L37-41)
```csharp
        if (input.IsTermStayOne || input.IsSideChain)
        {
            State.IsMainChain.Value = false;
            return new Empty();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-294)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-343)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-63)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };

        return new Empty();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-291)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```
