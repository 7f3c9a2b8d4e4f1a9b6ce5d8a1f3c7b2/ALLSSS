### Title
Stale NFT Approvals Persist After Token Transfer Enabling Unauthorized Reuse

### Summary
The NFT contract's `AllowanceMap` approvals are not invalidated when tokens are transferred via `Transfer()` or burned via `Burn()`. This allows approved spenders to reuse stale approvals if the original owner later re-acquires tokens with the same tokenId, enabling unauthorized transfers without fresh approval.

### Finding Description

The `AllowanceMap` state variable stores NFT approvals keyed by `[tokenHash][owner][spender]` where `tokenHash = Hash(symbol+tokenId)`. [1](#0-0) 

When a token owner calls `Transfer()`, the method only updates balances through `DoTransfer()` but never clears or modifies the `AllowanceMap`: [2](#0-1) 

The `DoTransfer()` helper function exclusively manipulates balance mappings: [3](#0-2) 

Similarly, the `Burn()` method only decrements balances and supply counters without touching approvals: [4](#0-3) 

The `TransferFrom()` method checks and decrements allowances only when called by a spender (not operator), but it cannot prevent reuse of approvals that persist across ownership changes: [5](#0-4) 

The root cause is that approvals are tied to `(tokenHash, owner, spender)` tuples rather than specific ownership periods. When ownership cycles occur (transfer away then re-acquire), the approval mapping entry remains unchanged and can be exploited.

### Impact Explanation

**Direct Fund Impact - Asset Theft:**

An attacker with a stale approval can steal NFTs without authorization. Attack scenario:

1. Alice owns 10 NFTs (symbol="GOLD", tokenId=5) valued at 1000 ELF each
2. Alice approves Bob for 10 NFTs via `Approve()`
3. Alice transfers all 10 NFTs to Charlie using `Transfer()` 
4. Bob's approval `AllowanceMap[Hash("GOLD5")][Alice][Bob] = 10` persists
5. Alice later mints/receives 10 new NFTs with same tokenId=5
6. Bob executes `TransferFrom(From=Alice, Amount=10)` using the stale approval
7. Bob steals Alice's 10 new NFTs worth 10,000 ELF without her consent

**Who is Affected:**
- NFT owners who transfer tokens after granting approvals
- Particularly affects high-value NFT collections where tokenIds are reused
- Protocols using the NFT contract for marketplace approvals

**Severity Justification:**
This is a **High severity** vulnerability (despite "Medium" classification in the question) because:
- Enables direct theft of valuable assets
- Exploits normal approval workflow patterns
- No authorization needed beyond initial (legitimate) approval
- Affects all NFT tokens where tokenIds can be reused per protocol settings

### Likelihood Explanation

**Reachable Entry Point:** 
The attack uses standard public methods: `Approve()`, `Transfer()`, and `TransferFrom()` - all accessible to any user.

**Feasible Preconditions:**
1. Victim grants approval (normal marketplace/DApp interaction)
2. Victim transfers tokens away using `Transfer()` (common operation)
3. Victim later receives/mints tokens with same tokenId (likely with protocol's `IsTokenIdReuse=true`)

**Execution Practicality:**
- No special privileges required beyond initial approval
- Works with standard transaction flows
- NFT protocols with `IsTokenIdReuse=true` are especially vulnerable (protocol setting visible at mint time)
- Attack is undetectable until execution since approval state looks legitimate

**Attack Complexity:** Low
- Single `TransferFrom()` call after monitoring on-chain state
- No timing requirements or race conditions
- Attacker can wait indefinitely for victim to re-acquire matching tokens

**Economic Rationality:**
- Transaction costs (gas fees) are minimal compared to stolen NFT value
- Profitable for any NFT worth >$10-100 in gas costs
- Especially profitable for high-value NFT collections

**Probability Assessment:** Medium-High
- Requires approval + transfer + re-acquisition cycle
- Common in marketplace scenarios (approve DEX, change mind, transfer elsewhere, later buy back)
- Higher probability with tokenId-reusable NFT protocols

### Recommendation

**Code-Level Mitigation:**

Implement approval invalidation on balance-reducing operations. Modify `DoTransfer()` to clear approvals when sender's balance reaches zero:

```csharp
private void DoTransfer(Hash tokenHash, Address from, Address to, long amount)
{
    if (amount < 0) throw new AssertionException("Invalid transfer amount.");
    if (amount == 0) return;
    
    Assert(State.BalanceMap[tokenHash][from] >= amount, "Insufficient balance.");
    
    var newBalance = State.BalanceMap[tokenHash][from].Sub(amount);
    State.BalanceMap[tokenHash][from] = newBalance;
    State.BalanceMap[tokenHash][to] = State.BalanceMap[tokenHash][to].Add(amount);
    
    // Clear all approvals if balance becomes zero
    if (newBalance == 0)
    {
        // Note: Requires iterating all spenders or maintaining spender list
        // Alternative: use nonce-based approvals (see below)
    }
}
```

**Better Solution - Nonce-Based Approvals:**

Add an owner nonce that increments on transfers/burns, making old approvals invalid:

```csharp
// In NFTContractState.cs
public MappedState<Hash, Address, long> OwnerNonceMap { get; set; }
public MappedState<Hash, Address, Address, long, long> AllowanceMapV2 { get; set; } // Added nonce key

// In DoTransfer()
State.OwnerNonceMap[tokenHash][from] = State.OwnerNonceMap[tokenHash][from].Add(1);

// In TransferFrom()
var currentNonce = State.OwnerNonceMap[tokenHash][input.From];
var allowance = State.AllowanceMapV2[tokenHash][input.From][Context.Sender][currentNonce];
```

**Invariant Checks to Add:**
- Assert that approvals cannot be used after owner balance has been zero since approval was granted
- Add tests verifying approval invalidation after transfer cycles

**Test Cases:**
1. Test: Approve → Transfer away (balance=0) → Re-acquire → TransferFrom should fail
2. Test: Approve → Burn all → Mint new → TransferFrom should fail  
3. Test: Approve → Partial transfer → TransferFrom should only work for remaining approved amount
4. Test: Multiple spender approvals cleared correctly on balance depletion

### Proof of Concept

**Initial State:**
- Alice has minted 100 NFTs (symbol="TEST", tokenId=1)
- Bob has no NFTs
- Protocol has `IsTokenIdReuse=false` (but vulnerability works either way)

**Attack Sequence:**

**Step 1:** Alice approves Bob for 50 NFTs
```csharp
// Alice calls
Approve(new ApproveInput {
    Spender = BobAddress,
    Symbol = "TEST",
    TokenId = 1,
    Amount = 50
});
// State: AllowanceMap[Hash("TEST1")][Alice][Bob] = 50
```

**Step 2:** Bob uses 20 of the approval (legitimate use)
```csharp
// Bob calls
TransferFrom(new TransferFromInput {
    From = Alice,
    To = Bob,
    Symbol = "TEST",
    TokenId = 1,
    Amount = 20
});
// State: AllowanceMap[Hash("TEST1")][Alice][Bob] = 30 (decremented)
// Alice balance: 80, Bob balance: 20
```

**Step 3:** Alice transfers remaining tokens to Charlie
```csharp
// Alice calls
Transfer(new TransferInput {
    To = CharlieAddress,
    Symbol = "TEST",
    TokenId = 1,
    Amount = 80
});
// State: AllowanceMap[Hash("TEST1")][Alice][Bob] = 30 (UNCHANGED!)
// Alice balance: 0, Charlie balance: 80
```

**Step 4:** Alice later receives/mints new NFTs with same tokenId
```csharp
// Alice mints or receives from another user
// Alice balance: 50
```

**Step 5:** Bob exploits stale approval
```csharp
// Bob calls
TransferFrom(new TransferFromInput {
    From = Alice,
    To = Bob,
    Symbol = "TEST", 
    TokenId = 1,
    Amount = 30
});
// SUCCESS! Bob steals 30 NFTs using stale approval
// Final: Alice balance: 20, Bob balance: 50 (20 + 30)
```

**Expected Result:** Transaction should fail with "Not approved" since Alice never re-approved Bob after the transfer cycle.

**Actual Result:** Transaction succeeds. Bob transfers 30 NFTs from Alice using the stale approval that survived Alice's complete transfer of her original tokens.

**Success Condition Verification:**
```csharp
var allowanceBefore = GetAllowance(Alice, Bob, "TEST", 1); // Returns 30
var aliceBalanceBefore = GetBalance(Alice, "TEST", 1); // Returns 50
TransferFrom(From=Alice, To=Bob, Amount=30);
var aliceBalanceAfter = GetBalance(Alice, "TEST", 1); // Returns 20
var bobBalanceAfter = GetBalance(Bob, "TEST", 1); // Returns 50
// Attack successful: Bob gained 30 NFTs without valid current approval
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L26-30)
```csharp
    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L21-35)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        DoTransfer(tokenHash, Context.Sender, input.To, input.Amount);
        Context.Fire(new Transferred
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L46-55)
```csharp
    private void DoTransfer(Hash tokenHash, Address from, Address to, long amount)
    {
        if (amount < 0) throw new AssertionException("Invalid transfer amount.");

        if (amount == 0) return;

        Assert(State.BalanceMap[tokenHash][from] >= amount, "Insufficient balance.");
        State.BalanceMap[tokenHash][from] = State.BalanceMap[tokenHash][from].Sub(amount);
        State.BalanceMap[tokenHash][to] = State.BalanceMap[tokenHash][to].Add(amount);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L57-80)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var operatorList = State.OperatorMap[input.Symbol][input.From];
        var isOperator = operatorList?.Value.Contains(Context.Sender) ?? false;
        if (!isOperator)
        {
            var allowance = State.AllowanceMap[tokenHash][input.From][Context.Sender];
            Assert(allowance >= input.Amount, "Not approved.");
            State.AllowanceMap[tokenHash][input.From][Context.Sender] = allowance.Sub(input.Amount);
        }

        DoTransfer(tokenHash, input.From, input.To, input.Amount);
        Context.Fire(new Transferred
        {
            From = input.From,
            To = input.To,
            Amount = input.Amount,
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```
