### Title
Predictable Consensus Randomness via Public DecryptedPieces Exposure Allows Block Production Order Manipulation

### Summary
DecryptedPieces used in the secret sharing scheme are stored in publicly-readable contract state and exposed through view methods, allowing any participant to reconstruct InValues and predict future consensus randomness. This enables malicious miners to anticipate block production order in advance and manipulate their mining behavior for unfair advantages, violating the fundamental security property of unpredictable consensus randomness.

### Finding Description

The vulnerability exists in the consensus secret sharing mechanism across multiple contract files:

**Root Cause:**
DecryptedPieces are added to Round state during consensus updates [1](#0-0)  and persisted to contract storage [2](#0-1) . Although DecryptedPieces are cleared from block headers before publication [3](#0-2) , they remain in persistent State storage.

**Public Exposure:**
The contract exposes public view methods that return complete Round objects including DecryptedPieces [4](#0-3) , confirmed as view methods in the protocol definition [5](#0-4) . The Round message structure contains DecryptedPieces as part of MinerInRound data [6](#0-5) .

**InValue Reconstruction:**
The RevealSharedInValues function demonstrates how InValues are reconstructed from DecryptedPieces using secret sharing decode [7](#0-6) . Any party with access to DecryptedPieces can perform identical reconstruction.

**Consensus Impact Chain:**
Signatures are calculated from InValues [8](#0-7)  and [9](#0-8) . Block production order for the next round is deterministically computed from signatures [10](#0-9) , and the extra block producer order is similarly determined [11](#0-10) .

**Why Protections Fail:**
While DecryptedPieces are removed from block headers to prevent immediate public visibility, this protection is insufficient because the data remains accessible in contract State through standard view method queries.

### Impact Explanation

**Consensus Integrity Violation:**
Miners can predict future block production order by:
1. Querying public view methods to retrieve DecryptedPieces
2. Reconstructing InValues using the same secret sharing decode algorithm
3. Computing signatures from InValues
4. Calculating exact miner ordering for future rounds

**Concrete Harm:**
- **MEV Exploitation**: Miners knowing they will produce consecutive blocks can optimize transaction ordering and extraction
- **Selective Mining**: Miners can skip unprofitable time slots knowing their future position
- **Consensus Manipulation**: Coordinated miners can optimize their collective advantage by predicting the full sequence
- **Fairness Violation**: Informed miners gain systematic advantages over honest participants who don't exploit this information

**Affected Parties:**
- All network participants suffer from degraded consensus fairness
- Transaction submitters face increased MEV extraction
- Honest miners face competitive disadvantage
- Protocol security assumptions are violated

**Severity Justification:**
CRITICAL - This violates the core security property of unpredictable consensus randomness, which is fundamental to the AEDPoS consensus mechanism's fairness guarantees.

### Likelihood Explanation

**Attacker Capabilities:**
- Any network participant (including miners, full nodes, or external observers) can exploit this vulnerability
- Requires only ability to call public view methods (no special privileges needed)
- Secret sharing decoding is computationally trivial

**Attack Complexity:**
- LOW - Exploitation requires simple steps:
  1. Call GetCurrentRoundInformation() or GetRoundInformation(roundNumber)
  2. Extract DecryptedPieces from returned Round data
  3. Apply SecretSharingHelper.DecodeSecret (standard library function)
  4. Compute signatures and block order using public functions

**Feasibility Conditions:**
- Always feasible once DecryptedPieces are published (happens every round during normal consensus operation)
- No special network conditions required
- No timing windows or race conditions to exploit

**Detection Constraints:**
- Exploitation is undetectable (passive reading of public state)
- No on-chain evidence of prediction activity
- Manipulation of mining behavior appears as normal miner decisions

**Probability:**
HIGH - Given the simplicity, lack of detection, and direct economic incentives, rational miners will exploit this information.

### Recommendation

**Immediate Fix:**
1. **Remove DecryptedPieces from public state exposure** - Modify GetCurrentRoundInformation and GetRoundInformation to filter out sensitive secret sharing data before returning [4](#0-3) 

2. **Apply secret clearing consistently** - Ensure DeleteSecretSharingInformation is called on Round objects before storing to State, not just before block header publication [12](#0-11) 

3. **Create internal-only Round representation** - Maintain DecryptedPieces in memory for RevealSharedInValues but never persist to queryable State

**Code-Level Mitigation:**
```
// In AEDPoSContract_ViewMethods.cs
public override Round GetCurrentRoundInformation(Empty input)
{
    if (TryToGetCurrentRoundInformation(out var currentRound))
    {
        currentRound.DeleteSecretSharingInformation(); // Clear before returning
        return currentRound;
    }
    return new Round();
}
```

**Invariant Checks:**
- Add assertion that returned Round objects contain no DecryptedPieces or EncryptedPieces
- Verify InValue reconstruction is only possible through authorized RevealSharedInValues path
- Test that view methods never expose uncommitted secret sharing data

**Test Cases:**
1. Verify GetCurrentRoundInformation returns Round with empty DecryptedPieces
2. Verify GetRoundInformation returns Round with empty EncryptedPieces
3. Confirm RevealSharedInValues still functions with internal-only DecryptedPieces access
4. Validate that block production order cannot be predicted from publicly available data

### Proof of Concept

**Required Initial State:**
- AEDPoS consensus contract deployed and active
- Multiple miners participating in consensus
- Secret sharing enabled (IsSecretSharingEnabled returns true)
- At least one full round completed with DecryptedPieces published

**Exploitation Steps:**

1. **Query Public State:**
   - Call `GetCurrentRoundInformation()` view method
   - Receive Round object containing RealTimeMinersInformation

2. **Extract DecryptedPieces:**
   - For each miner M in RealTimeMinersInformation:
     - Extract M.DecryptedPieces map (pubkey → encrypted_piece)
     - Collect sufficient pieces (≥ minimumCount threshold)

3. **Reconstruct InValues:**
   - For target miner T:
     - Collect T.DecryptedPieces.Values as sharedParts
     - Collect corresponding orders from RealTimeMinersInformation
     - Call SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount)
     - Compute revealedInValue = Hash(decoded_secret)

4. **Predict Future Signatures:**
   - Calculate next round signature = CalculateSignature(revealedInValue)
   - Compute signature XOR aggregation across miners

5. **Determine Block Production Order:**
   - For each miner: supposedOrderOfNextRound = GetAbsModulus(signature.ToInt64(), minersCount) + 1
   - Identify which miner will produce which block in next round
   - Determine extra block producer order

**Expected Result:** 
Attacker should NOT be able to access DecryptedPieces from public view methods

**Actual Result:**
Attacker CAN access DecryptedPieces and successfully predict complete next-round block production sequence, enabling strategic manipulation

**Success Condition:**
Predicted block production order matches actual order when next round executes, confirming successful prediction and validating the vulnerability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L126-132)
```csharp
    private bool TryToUpdateRoundInformation(Round round)
    {
        var ri = State.Rounds[round.RoundNumber];
        if (ri == null) return false;
        State.Rounds[round.RoundNumber] = round;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_GetLighterRound.cs (L7-14)
```csharp
    public void DeleteSecretSharingInformation()
    {
        var encryptedPieces = RealTimeMinersInformation.Values.Select(i => i.EncryptedPieces);
        foreach (var encryptedPiece in encryptedPieces) encryptedPiece.Clear();

        var decryptedPieces = RealTimeMinersInformation.Values.Select(i => i.DecryptedPieces);
        foreach (var decryptedPiece in decryptedPieces) decryptedPiece.Clear();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L21-29)
```csharp
    public override Round GetCurrentRoundInformation(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var currentRound) ? currentRound : new Round();
    }

    public override Round GetRoundInformation(Int64Value input)
    {
        return TryToGetRoundInformation(input.Value, out var round) ? round : new Round();
    }
```

**File:** protobuf/aedpos_contract.proto (L78-90)
```text
    rpc GetRoundInformation (google.protobuf.Int64Value) returns (Round) {
        option (aelf.is_view) = true;
    }
    
    // Get the current round number.
    rpc GetCurrentRoundNumber (google.protobuf.Empty) returns (google.protobuf.Int64Value) {
        option (aelf.is_view) = true;
    }
    
    // Get the current round information.
    rpc GetCurrentRoundInformation (google.protobuf.Empty) returns (Round) {
        option (aelf.is_view) = true;
    }
```

**File:** protobuf/aedpos_contract.proto (L295-296)
```text
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L46-52)
```csharp
            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L118-122)
```csharp
        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
```
