# Audit Report

## Title
Infinite Loop in NFT Symbol Generation Due to Fixed Hash Reuse in Collision Handling

## Summary
The `GenerateSymbolNumber()` function in the NFT contract contains a critical flaw where it reuses the same hash value when checking for symbol number collisions. Since `Context.ConvertHashToInt64()` is deterministic, any collision results in an infinite loop that only terminates when transaction gas is exhausted, causing complete DoS of NFT protocol creation.

## Finding Description
The vulnerability exists in the collision-handling logic of the `GenerateSymbolNumber()` function. [1](#0-0) 

The root cause is that `randomHash` is computed once before entering the collision-checking do-while loop [2](#0-1) , but this same hash is reused on every iteration [3](#0-2) .

The `Context.ConvertHashToInt64()` method is deterministic [4](#0-3)  - it uses modulo arithmetic on the hash bytes and always returns the same value for identical inputs. When a generated symbol number already exists in `State.IsCreatedMap`, the while condition evaluates to true, but because the hash never changes, the exact same number is regenerated on the next iteration, creating an infinite loop with no exit condition except gas exhaustion.

This function is called from the publicly accessible `Create()` method [5](#0-4)  via the `GetSymbol()` helper [6](#0-5) .

## Impact Explanation
**Direct Operational Impact:**
- Any user attempting to create an NFT protocol whose generated symbol number collides with an existing entry experiences complete transaction failure due to gas exhaustion
- Users lose all gas fees paid for the failed transaction without any NFT protocol being created
- As the symbol space fills over time (tracked in `State.IsCreatedMap`), the probability of collisions increases, making legitimate operations progressively more likely to fail

**Griefing Attack Vector:**
- The random number generation is predictable (based on sender address and block height from [7](#0-6) )
- An attacker can calculate which number will be generated for a target user's transaction
- By front-running with strategic NFT protocol creations, the attacker can force specific users' transactions to hit collisions
- This is particularly damaging for high-value NFT protocol launches where timing is critical

**Severity Justification:**
This is HIGH severity because it causes guaranteed DoS of a core protocol function (NFT protocol creation on mainchain [8](#0-7) ), results in direct financial loss through wasted gas fees, enables targeted griefing attacks, and becomes progressively worse as the protocol matures.

## Likelihood Explanation
**Attacker Capabilities:**
- Any user can call the public `Create()` method without special permissions
- The random number generation is deterministic and predictable based on observable blockchain state
- An attacker can compute what number will be generated for any pending transaction

**Attack Feasibility:**
- Low complexity: Simply create NFT protocols that occupy target symbol numbers
- Front-running is feasible on blockchain networks with mempool visibility  
- No special permissions or complex state manipulation required
- Natural collisions become increasingly likely as the symbol space fills (birthday paradox effect)

**No Defensive Mechanisms:**
- No maximum iteration limit exists in the loop
- No hash regeneration mechanism when collisions occur
- No fallback strategy or circuit breaker
- Failed transactions appear as normal out-of-gas failures, making root cause diagnosis difficult

**Probability Assessment:**
HIGH likelihood because the vulnerability is triggered by any collision (natural or engineered), requires minimal sophistication to exploit, can be executed by any user, and the occurrence rate increases over time as more NFT protocols are created.

## Recommendation
The hash must be regenerated inside the loop when a collision is detected. Modify the `GenerateSymbolNumber()` function to incorporate new entropy on each iteration:

```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
    {
        Value = Context.CurrentHeight.Sub(1)
    }.ToBytesValue());
    var randomHash = HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
        HashHelper.ComputeFrom(randomBytes));
    
    long randomNumber;
    int attempts = 0;
    const int maxAttempts = 1000; // Safety limit
    
    do
    {
        randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        if (!State.IsCreatedMap[randomNumber])
            break;
            
        // Regenerate hash on collision
        randomHash = HashHelper.ConcatAndCompute(randomHash, HashHelper.ComputeFrom(attempts));
        attempts++;
        
        Assert(attempts < maxAttempts, "Failed to generate unique symbol number after maximum attempts");
    } while (true);

    return randomNumber;
}
```

This ensures each iteration uses a different hash, preventing infinite loops while maintaining deterministic behavior for consensus.

## Proof of Concept
A proof of concept would involve:

1. Deploy the NFT contract on a test chain
2. Create multiple NFT protocols to populate `State.IsCreatedMap` with several symbol numbers
3. Monitor the random number generation for a specific user address and block height to predict the output
4. Pre-create an NFT protocol using that exact symbol number
5. Have the target user attempt to create an NFT protocol
6. Observe the transaction fail with out-of-gas error
7. Verify via transaction trace that the `GenerateSymbolNumber()` loop executed repeatedly generating the same number

The test would confirm that when `Context.ConvertHashToInt64()` produces a number already in `State.IsCreatedMap`, the transaction enters an infinite loop consuming all available gas without completing NFT protocol creation.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-27)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L169-177)
```csharp
    public long ConvertHashToInt64(Hash hash, long start = 0, long end = long.MaxValue)
    {
        if (start < 0 || start > end) throw new ArgumentException("Incorrect arguments.");

        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```
