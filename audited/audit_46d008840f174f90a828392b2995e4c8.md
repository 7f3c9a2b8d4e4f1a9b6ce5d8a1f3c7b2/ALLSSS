### Title
Integer Division Vulnerability in Mining Interval Configuration Causes Complete Blockchain Denial of Service

### Summary
When MiningInterval is configured below approximately 16 milliseconds during genesis initialization, integer division in the consensus command generation logic causes DefaultBlockMiningLimit to become 0. This results in immediate cancellation of block execution, preventing any transactions from being included in blocks and rendering the blockchain non-functional with no recovery mechanism.

### Finding Description

The vulnerability exists in the consensus command generation logic where mining time limits are calculated through integer division without minimum value validation.

**Root Cause Location:**

The DefaultBlockMiningLimit is calculated in [1](#0-0) 

The calculation chain is:
- TinyBlockSlotInterval = MiningInterval / 8
- DefaultBlockMiningLimit = (TinyBlockSlotInterval * 3) / 5

For MiningInterval values below 16ms, this produces DefaultBlockMiningLimit = 0 due to integer division truncation.

**Missing Validation:**

The MiningInterval value is set during genesis without any minimum value checks:

1. Configuration flows through ConsensusOptions with no validation: [2](#0-1) 

2. FirstRound method accepts the value without validation: [3](#0-2) 

3. Round validation only checks that mining interval > 0, not that it's sufficient to prevent integer division to zero: [4](#0-3) 

**Execution Path to DoS:**

When DefaultBlockMiningLimit = 0, it's used as LimitMillisecondsOfMiningBlock in the consensus command: [5](#0-4) 

This flows to the mining service where BlockExecutionTime = 0ms causes immediate cancellation: [6](#0-5) 

The cancelled token prevents block execution: [7](#0-6) 

### Impact Explanation

**Harm:** Complete blockchain denial of service. No transactions can be processed because block execution is immediately cancelled before any transaction execution occurs.

**Affected Parties:** 
- All blockchain users cannot submit or execute transactions
- All miners cannot produce valid blocks with transactions
- Entire blockchain network becomes non-functional

**Severity Justification:** 
This is a HIGH severity issue because:
1. Complete operational failure of the blockchain
2. No recovery mechanism exists (FirstRound can only be called once during genesis)
3. Requires chain redeployment to fix
4. While configuration override exists via MiningTime.LimitMillisecondsOfMiningBlock, if that's also not set or set to 0, the blockchain is permanently broken

The override mechanism in ConsensusService provides partial mitigation only if explicitly configured: [8](#0-7) 

### Likelihood Explanation

**Nature:** This is a configuration vulnerability, not a runtime exploit.

**Conditions Required:**
1. Chain operator configures MiningInterval < 16ms during genesis initialization
2. MiningTime.LimitMillisecondsOfMiningBlock is not set or is set to 0

**Feasibility:** 
- MEDIUM-HIGH likelihood as a configuration error
- No validation exists to prevent operator error
- Default configuration uses 4000ms which is safe
- However, operators customizing for "high performance" chains might inadvertently set dangerously low values
- Once set at genesis, cannot be changed (FirstRound is one-time only): [9](#0-8) 

**Detection:** The issue would be immediately apparent at chain launch as no blocks with transactions could be produced.

### Recommendation

**Immediate Fix:**

Add minimum value validation in the FirstRound method:

```csharp
public override Empty FirstRound(Round input)
{
    Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");
    
    var miningInterval = input.GetMiningInterval();
    // Ensure mining interval is large enough to prevent DefaultBlockMiningLimit from becoming 0
    // Minimum: (8 * 5 / 3) = 14, but use 100ms as safe minimum
    Assert(miningInterval >= 100, "Mining interval must be at least 100ms.");
    
    State.CurrentTermNumber.Value = 1;
    State.CurrentRoundNumber.Value = 1;
    State.FirstRoundNumberOfEachTerm[1] = 1;
    State.MiningInterval.Value = miningInterval;
    SetMinerList(input.GetMinerList(), 1);
    AddRoundInformation(input);
    
    return new Empty();
}
```

**Additional Protections:**

1. Add validation in ConsensusOptions or configuration loading layer
2. Add validation in AEDPoSContractInitializationDataProvider
3. Update CheckRoundTimeSlots to validate sufficient mining interval
4. Add unit tests with edge cases: MiningInterval values of 1ms, 8ms, 15ms, 16ms, 100ms

**Configuration Documentation:**

Document that MiningInterval must be at least 100ms to ensure safe operation, with explanation of the integer division calculation.

### Proof of Concept

**Initial State:**
- Fresh blockchain deployment
- Genesis configuration preparation

**Configuration Steps:**

1. Set MiningInterval to 1ms in appsettings.json or ConsensusOptions:
```json
"Consensus": {
    "MiningInterval": 1
}
```

2. Do NOT set MiningTime.LimitMillisecondsOfMiningBlock override, or set it to 0

3. Initialize blockchain with genesis block

**Execution:**

The initialization provider generates FirstRound call: [10](#0-9) 

MinerList.GenerateFirstRoundOfNewTerm uses MiningInterval = 1ms: [11](#0-10) 

**Result:**
- TinyBlockSlotInterval = 1 / 8 = 0
- DefaultBlockMiningLimit = 0 * 3 / 5 = 0
- BlockExecutionTime = 0ms
- Cancellation token cancelled immediately
- No transactions can execute
- Blockchain cannot produce functional blocks

**Expected vs Actual:**
- Expected: Blockchain operates normally with 1ms mining interval (if possible)
- Actual: Blockchain completely non-functional, cannot process any transactions

**Success Condition:** With MiningInterval = 1ms and no override configured, attempting to mine any block will result in immediate execution cancellation, preventing transaction inclusion.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L42-49)
```csharp
        private int TinyBlockSlotInterval => MiningInterval.Div(TinyBlocksCount);

        protected int MinersCount => CurrentRound.RealTimeMinersInformation.Count;

        /// <summary>
        ///     Give 3/5 of producing time for mining by default.
        /// </summary>
        protected int DefaultBlockMiningLimit => TinyBlockSlotInterval.Mul(3).Div(5);
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/ConsensusOptions.cs (L10-10)
```csharp
    public int MiningInterval { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L74-92)
```csharp
    public override Empty FirstRound(Round input)
    {
        /* Basic checks. */
        Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");

        /* Initial settings. */
        State.CurrentTermNumber.Value = 1;
        State.CurrentRoundNumber.Value = 1;
        State.FirstRoundNumberOfEachTerm[1] = 1;
        State.MiningInterval.Value = input.GetMiningInterval();
        SetMinerList(input.GetMinerList(), 1);

        AddRoundInformation(input);

        Context.LogDebug(() =>
            $"Initial Miners: {input.RealTimeMinersInformation.Keys.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L46-47)
```csharp
        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L36-37)
```csharp
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
```

**File:** src/AElf.Kernel/Miner/Application/MiningService.cs (L50-62)
```csharp
            using var cts = new CancellationTokenSource();
            var expirationTime = blockTime + requestMiningDto.BlockExecutionTime;
            if (expirationTime < TimestampHelper.GetUtcNow())
            {
                cts.Cancel();
            }
            else
            {
                var ts = (expirationTime - TimestampHelper.GetUtcNow()).ToTimeSpan();
                if (ts.TotalMilliseconds > int.MaxValue) ts = TimeSpan.FromMilliseconds(int.MaxValue);

                cts.CancelAfter(ts);
            }
```

**File:** src/AElf.Kernel/Miner/Application/MiningService.cs (L77-78)
```csharp
            var blockExecutedSet = await _blockExecutingService.ExecuteBlockAsync(block.Header,
                systemTransactions, pending, cts.Token);
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L93-100)
```csharp
        var configuredMiningTime = await _miningTimeProvider.GetLimitMillisecondsOfMiningBlockAsync(new BlockIndex
        {
            BlockHeight = chainContext.BlockHeight,
            BlockHash = chainContext.BlockHash
        });
        var limitMillisecondsOfMiningBlock = configuredMiningTime == 0
            ? _consensusCommand.LimitMillisecondsOfMiningBlock
            : configuredMiningTime;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/AEDPoSContractInitializationProvider.cs (L49-50)
```csharp
                }.GenerateFirstRoundOfNewTerm(initializationData.MiningInterval,
                    initializationData.StartTimestamp.ToDateTime()).ToByteString()
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L32-33)
```csharp
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
```
