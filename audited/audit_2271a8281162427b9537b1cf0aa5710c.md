### Title
Missing Extra Block Producer Validation Allows Consensus DoS via InvalidOperationException

### Summary
The AEDPoS consensus contract does not validate that incoming Round objects submitted via NextRound or NextTerm transactions contain at least one miner designated as the extra block producer (IsExtraBlockProducer == true). A malicious miner can exploit this to store a malformed Round that causes critical consensus methods to throw InvalidOperationException, halting block production, validation, and network operations.

### Finding Description

**Root Cause**: The consensus contract accepts Round objects without validating the existence of an extra block producer.

**Vulnerable Code Location 1 - GetNextMinerPubkey()**: [1](#0-0) 

When all miners' ExpectedMiningTime values have passed (â‰¤ Context.CurrentBlockTime), line 98 executes `First(m => m.IsExtraBlockProducer)` which throws InvalidOperationException if no miner has IsExtraBlockProducer == true.

**Vulnerable Code Location 2 - IsCurrentMiner()**: [2](#0-1) 

Uses `Single(m => m.Value.IsExtraBlockProducer)` which throws if no miner (or multiple miners) has IsExtraBlockProducer == true.

**Vulnerable Code Location 3 - GetExtraBlockProducerInformation()**: [3](#0-2) 

Called by ArrangeAbnormalMiningTime and consensus command generation, uses `First(bp => bp.Value.IsExtraBlockProducer)` which throws if no extra block producer exists.

**Missing Validation in Entry Points**: [4](#0-3) 

ProcessNextRound accepts NextRoundInput, converts it to Round via ToRound(), and stores it via AddRoundInformation without validating extra block producer existence. [5](#0-4) 

ProcessNextTerm has the same vulnerability - no validation of extra block producer.

**Insufficient Validation Providers**: [6](#0-5) 

RoundTerminateValidationProvider only validates round numbers and InValue nullness, not the presence of extra block producer.

**Normal Round Generation Always Sets Extra Block Producer**: [7](#0-6) 

While legitimate round generation always sets an extra block producer, the contract accepts externally provided Round objects without this invariant check.

### Impact Explanation

**Operational Impact - Complete Consensus Halt**:

1. **Block Broadcasting Failure**: GetNextMinerPubkey is used by NetworkService to determine the next miner for priority block broadcasting. An exception here breaks block propagation across the network.

2. **Mining Permission Validation Failure**: IsCurrentMiner validates whether a node can produce blocks at the current time. An exception prevents all miners from validating their mining rights, blocking block production.

3. **Consensus Command Generation Failure**: ArrangeAbnormalMiningTime (via GetExtraBlockProducerInformation) is used in TerminateRoundCommandStrategy for generating NextRound/NextTerm commands. An exception prevents round termination. [8](#0-7) 

**Affected Parties**: All network participants - miners cannot produce blocks, nodes cannot validate, network cannot progress.

**Severity Justification**: HIGH - Complete disruption of consensus mechanism leading to chain halt. Once a malformed Round is stored, the chain cannot recover without intervention.

### Likelihood Explanation

**Attacker Capabilities Required**: Must be in current or previous round's miner list to pass PreCheck. [9](#0-8) 

**Attack Complexity**: LOW
- Attacker crafts a NextRoundInput or NextTermInput with valid round/term numbers and miner information
- Sets all miners' IsExtraBlockProducer to false (or simply omits setting any to true)
- Submits via NextRound or NextTerm transaction
- Round passes all existing validations and gets stored

**Feasibility Conditions**: 
- Attack is practical for any malicious miner
- Economic cost is just transaction fees
- No special privileges beyond being a miner required
- No detection mechanisms exist before the Round is stored

**Probability Reasoning**: MEDIUM-HIGH
- Miners have economic incentives to attack competing chains or disrupt governance
- Attack is non-obvious but straightforward once discovered
- Single malicious transaction can halt entire chain

### Recommendation

**Immediate Fix - Add Extra Block Producer Validation**:

Add a validation check in RoundTerminateValidationProvider or create a new dedicated validator:

```csharp
public class ExtraBlockProducerValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var round = validationContext.ExtraData.Round;
        
        if (round.RealTimeMinersInformation.Count == 0)
            return new ValidationResult { Message = "Round must contain at least one miner." };
            
        var extraBlockProducerCount = round.RealTimeMinersInformation.Values
            .Count(m => m.IsExtraBlockProducer);
            
        if (extraBlockProducerCount == 0)
            return new ValidationResult { Message = "Round must have exactly one extra block producer." };
            
        if (extraBlockProducerCount > 1)
            return new ValidationResult { Message = "Round must have exactly one extra block producer." };
            
        return new ValidationResult { Success = true };
    }
}
```

Register this provider for NextRound and NextTerm behaviours in ValidateBeforeExecution.

**Defensive Programming - Use Safe Accessors**:

Replace `First()` and `Single()` with defensive alternatives:
- Change GetNextMinerPubkey to use `FirstOrDefault()` and return empty string if no extra block producer
- Change IsCurrentMiner to use `SingleOrDefault()` and return false if no/multiple extra block producers
- Change GetExtraBlockProducerInformation to check count first and handle gracefully

**Test Cases**:
1. Test NextRound with Round containing no extra block producer - should reject
2. Test NextRound with Round containing multiple extra block producers - should reject
3. Test NextRound with Round containing empty miner list - should reject
4. Test GetNextMinerPubkey after round ends with valid extra block producer - should succeed
5. Test consensus command generation with valid extra block producer - should succeed

### Proof of Concept

**Required Initial State**:
- Chain is running with AEDPoS consensus
- Attacker is a miner in current or previous round
- Current round is near completion

**Attack Steps**:

1. Attacker crafts a NextRoundInput:
```
NextRoundInput maliciousInput = new NextRoundInput
{
    RoundNumber = currentRound.RoundNumber + 1,
    TermNumber = currentRound.TermNumber,
    RealTimeMinersInformation = {
        // Add all miners with proper Order, ExpectedMiningTime, etc.
        // BUT set IsExtraBlockProducer = false for all miners
    },
    // Set other required fields correctly
};
```

2. Attacker calls NextRound(maliciousInput)
   - PreCheck passes (attacker is in miner list)
   - Validation providers check round numbers, mining orders (all pass)
   - Extra block producer validation is MISSING
   - Malformed Round is stored via AddRoundInformation

3. Next time any node calls GetNextMinerPubkey():
   - Expected: Returns extra block producer's pubkey
   - Actual: Throws InvalidOperationException: "Sequence contains no matching element"

4. Chain operations halt:
   - Block broadcasting fails (NetworkService exception)
   - Mining validation fails (IsCurrentMiner exception)
   - Consensus commands fail (command generation exception)

**Success Condition**: Chain unable to produce new blocks or validate mining permissions, requiring manual intervention to recover.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L91-102)
```csharp
    public override StringValue GetNextMinerPubkey(Empty input)
    {
        if (TryToGetCurrentRoundInformation(out var round))
            return new StringValue
            {
                Value = round.RealTimeMinersInformation.Values
                            .FirstOrDefault(m => m.ExpectedMiningTime > Context.CurrentBlockTime)?.Pubkey ??
                        round.RealTimeMinersInformation.Values.First(m => m.IsExtraBlockProducer).Pubkey
            };

        return new StringValue();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-170)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-65)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-39)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
        }
```
