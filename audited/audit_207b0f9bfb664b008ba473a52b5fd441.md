# Audit Report

## Title
Auto-Distribution Only Triggers for First Qualifying Token, Not All Eligible Tokens

## Summary
The `RegisterForProfits()` function in the TokenHolder contract contains a premature loop termination (break statement) that causes only the first token meeting its auto-distribution threshold to be distributed, even when multiple tokens qualify simultaneously. This breaks the intended multi-token auto-distribution feature and delays profit distribution for beneficiaries.

## Finding Description

The auto-distribution logic in `RegisterForProfits()` is designed to automatically trigger profit distribution when token balances in a scheme's virtual address exceed configured thresholds. However, the implementation contains a critical flaw. [1](#0-0) 

The code iterates through the `AutoDistributeThreshold` map, checking each token's balance against its threshold. When it finds a qualifying token (balance >= threshold), it adds that token to `distributedInput.AmountsMap` and then immediately executes a `break` statement at line 199, exiting the loop entirely. This prevents the remaining tokens from being evaluated, even if they also meet their thresholds.

The Profit contract's `DistributeProfits` function only processes tokens present in the input `AmountsMap`: [2](#0-1) 

Since only one token gets added to `AmountsMap` due to the premature break, only that single token is distributed. All other qualifying tokens remain undistributed in the scheme's virtual address until the next auto-distribution trigger or manual distribution call.

The design clearly intends for all qualifying tokens to be distributed:
- `AutoDistributeThreshold` is defined as a map structure supporting multiple token symbols [3](#0-2) 

- The protobuf comment describes it as "Threshold setting for releasing dividends" (plural)
- Test cases demonstrate scenarios with multiple tokens configured and contributed [4](#0-3) 

## Impact Explanation

**Severity: Medium**

This vulnerability causes reward misallocation in TokenHolder profit schemes:

1. **Delayed Access to Profits**: When multiple tokens simultaneously meet their thresholds, only one token gets distributed while others remain locked in the virtual address. Beneficiaries cannot access their entitled profits for these undistributed tokens until another trigger event occurs.

2. **Broken Protocol Guarantee**: The auto-distribution feature is advertised as a mechanism to automatically release profits when thresholds are met. This guarantee is violated for multi-token scenarios, breaking the documented contract behavior.

3. **No Permanent Loss**: Funds are not permanently lostâ€”they remain in the scheme's virtual address and can be recovered through manual `DistributeProfits()` calls or subsequent auto-distribution triggers. This prevents the severity from being High.

4. **Affected Users**: All beneficiaries participating in TokenHolder schemes configured with multiple auto-distribution thresholds are impacted whenever multiple tokens qualify simultaneously.

## Likelihood Explanation

**Likelihood: High**

This bug triggers deterministically during normal protocol operation:

1. **No Attacker Required**: This is a logic bug, not an exploit requiring malicious input. It manifests during legitimate user interactions.

2. **Common Preconditions**: 
   - Scheme managers frequently configure multiple token types for auto-distribution (e.g., ELF + governance tokens)
   - Multiple tokens naturally accumulate in schemes that accept diverse contributions
   - When beneficiaries register, multiple tokens commonly exceed thresholds simultaneously

3. **Automatic Trigger**: Any user calling `RegisterForProfits()` on a scheme where multiple tokens meet thresholds will trigger this bug. No special timing or state manipulation is required.

4. **Production Relevance**: Multi-token profit distribution is a standard use case for the TokenHolder contract, making this scenario highly practical in production deployments.

## Recommendation

Remove the `break` statement at line 199 to allow all qualifying tokens to be processed:

**Fixed Code:**
```csharp
foreach (var threshold in scheme.AutoDistributeThreshold)
{
    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
    {
        Owner = virtualAddress,
        Symbol = threshold.Key
    }).Balance;
    if (balance < threshold.Value) continue;
    if (distributedInput == null)
        distributedInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
    distributedInput.AmountsMap[threshold.Key] = 0;
    // REMOVED: break;  <-- Delete this line
}
```

This allows the loop to continue evaluating all thresholds, adding all qualifying tokens to `AmountsMap` for distribution.

## Proof of Concept

```csharp
[Fact]
public async Task RegisterForProfits_MultiToken_AutoDistribute_Bug_PoC()
{
    // Setup: Create scheme with auto-distribute thresholds for 2 tokens
    var thresholdAmount = 1000L;
    var tokenA = "ELF";
    var tokenB = "TEST";
    
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = tokenA,
        AutoDistributeThreshold = 
        {
            { tokenA, thresholdAmount },
            { tokenB, thresholdAmount }
        }
    });
    
    // Contribute both tokens above threshold
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Amount = thresholdAmount,
        Symbol = tokenA
    });
    
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Amount = thresholdAmount,
        Symbol = tokenB
    });
    
    // Trigger auto-distribution via RegisterForProfits
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = 100L,
        SchemeManager = Starter
    });
    
    // Check profits map - should contain both tokens, but bug causes only 1
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = Starter });
    var profitMap = await ProfitContractStub.GetProfitsMap.CallAsync(
        new Profit.ClaimProfitsInput
        {
            Beneficiary = Starter,
            SchemeId = schemeIds.SchemeIds.First()
        });
    
    // BUG DEMONSTRATED: Only 1 token distributed instead of 2
    profitMap.Value.Count.ShouldBe(2); // This assertion FAILS due to bug
}
```

## Notes

The iteration order of the `AutoDistributeThreshold` map determines which token gets distributed (likely based on key sorting in protobuf maps). This means the bug's manifestation is deterministic but depends on token symbol lexicographic ordering, making it harder to notice in testing if test cases use carefully chosen token names that don't reveal the issue.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L184-200)
```csharp
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L433-446)
```csharp
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
```

**File:** protobuf/token_holder_contract.proto (L68-69)
```text
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 3;
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L365-385)
```csharp
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = nativeTokenSymbol,
            AutoDistributeThreshold =
            {
                { nativeTokenSymbol, amount },
                { tokenA, amount }
            }
        });
        await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeManager = Starter,
            Amount = amount,
            Symbol = nativeTokenSymbol
        });
        await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeManager = Starter,
            Amount = amount,
            Symbol = tokenA
        });
```
