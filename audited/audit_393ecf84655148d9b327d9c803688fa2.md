### Title
RemoveSubScheme Fails to Update CachedDelayTotalShares Leading to Profit Misallocation

### Summary
The `RemoveSubScheme` function does not update the `CachedDelayTotalShares` map when removing a sub-scheme, unlike the analogous `RemoveBeneficiary` function. This causes stale cached share values to be used during profit distribution in schemes with `DelayDistributePeriodCount > 0`, resulting in inflated total shares calculations and profit misallocation where legitimate beneficiaries receive less than their entitled share.

### Finding Description
The vulnerability exists in the `RemoveSubScheme` function [1](#0-0) , which only updates `TotalShares` and removes the sub-scheme from the `SubSchemes` list, but fails to update `CachedDelayTotalShares`.

When a scheme uses delayed distribution (`DelayDistributePeriodCount > 0`), the `DistributeProfits` function caches the current `TotalShares` for future periods [2](#0-1) . When that future period arrives, the cached value is retrieved and used as the `totalShares` for profit calculations [3](#0-2) .

The root cause is the inconsistency between `RemoveSubScheme` and `RemoveBeneficiary`. The `RemoveBeneficiary` function properly updates `CachedDelayTotalShares` by iterating through affected periods and subtracting removed shares [4](#0-3) , but `RemoveSubScheme` lacks this logic entirely.

The cached totalShares is then used in `UpdateDistributedProfits` to set the `DistributedProfitsInfo.TotalShares` [5](#0-4) , which individual beneficiaries use when claiming profits through `SafeCalculateProfits` [6](#0-5) .

### Impact Explanation
**Direct Fund Impact - Profit Misallocation:**

When a sub-scheme is added and then removed before its delayed start period, the cached TotalShares remains inflated by the removed sub-scheme's shares. This causes:

1. **Underpayment to beneficiaries**: Individual beneficiaries receive `(theirShares / inflatedTotalShares) * distributedAmount` instead of `(theirShares / actualTotalShares) * distributedAmount`, resulting in less profit than entitled.

2. **Locked funds**: The difference between what should be distributed and what is actually claimed becomes permanently locked in the period's virtual address, as no beneficiary has sufficient shares to claim it.

**Quantified Example:**
- Scheme has 100 shares from regular beneficiaries, DelayDistributePeriodCount = 2
- Period 1: Manager adds sub-scheme with 100 shares (TotalShares = 200, cached for period 3)
- Period 1: Distribute 1000 ELF (CachedDelayTotalShares[3] = 200)
- Period 2: Manager removes sub-scheme (TotalShares = 100, but CachedDelayTotalShares[3] still = 200)
- Period 3: Distribute profits using totalShares = 200 from cache
- Result: Regular beneficiaries with 100 shares receive only 500 ELF (100/200 * 1000) instead of 1000 ELF
- Impact: 50% loss for legitimate beneficiaries, 500 ELF permanently locked

**Affected parties**: All non-sub-scheme beneficiaries in profit schemes using delayed distribution.

### Likelihood Explanation
**Attacker Capabilities:**
- Attacker must be the scheme manager (authorized role for AddSubScheme/RemoveSubScheme)
- Or exploit this through negligent/compromised manager actions

**Attack Complexity: LOW**
The attack requires only three straightforward operations:
1. Call `AddSubScheme` to add a sub-scheme with significant shares
2. Call `DistributeProfits` to cache the inflated TotalShares for a future period
3. Call `RemoveSubScheme` before the delayed period arrives
4. Wait for the cached period to arrive - profits automatically miscalculated

**Feasibility Conditions:**
- Scheme must have `DelayDistributePeriodCount > 0` (common for vesting-style schemes)
- Manager has control over sub-scheme addition/removal (by design)
- No special timing constraints beyond normal period progression

**Detection Constraints:**
- Silent failure - no transaction reverts or error messages
- Impact only visible when beneficiaries claim and notice shortfall
- Cached values are internal state not easily audited

**Probability: MEDIUM-HIGH**
While requiring manager access, delayed distribution schemes are common in tokenomics (vesting, staking rewards), and manager actions may be automated or follow governance that doesn't anticipate this issue. Additionally, a malicious manager could exploit this deliberately, or legitimate operational changes (adding/removing sub-schemes) could trigger it accidentally.

### Recommendation
**Code-Level Mitigation:**
Modify `RemoveSubScheme` to update `CachedDelayTotalShares` similar to `RemoveBeneficiary`:

```csharp
public override Empty RemoveSubScheme(RemoveSubSchemeInput input)
{
    // ... existing validation code ...
    
    var shares = scheme.SubSchemes.SingleOrDefault(d => d.SchemeId == input.SubSchemeId);
    if (shares == null) return new Empty();
    
    // ... existing code ...
    
    // ADD THIS: Update cached delay total shares
    if (scheme.DelayDistributePeriodCount > 0)
    {
        var removePeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount);
        for (var period = scheme.CurrentPeriod; period <= removePeriod; period++)
        {
            if (scheme.CachedDelayTotalShares.ContainsKey(period))
            {
                scheme.CachedDelayTotalShares[period] = 
                    scheme.CachedDelayTotalShares[period].Sub(shares.Shares);
            }
        }
    }
    
    scheme.SubSchemes.Remove(shares);
    scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
    State.SchemeInfos[input.SchemeId] = scheme;
    
    return new Empty();
}
```

**Invariant Checks:**
- Assert that `CachedDelayTotalShares` values never exceed current `TotalShares` plus pending additions
- Add event logging when cached shares are updated for audit trails

**Test Cases:**
1. Add sub-scheme → Distribute (caching) → Remove sub-scheme → Distribute at cached period → Verify beneficiaries receive correct shares
2. Multiple rapid add/remove cycles with varying shares → Verify final distribution correctness
3. Edge case: Remove sub-scheme in same period as addition, before distribution

### Proof of Concept
**Initial State:**
- Profit scheme created with `DelayDistributePeriodCount = 2`, `CurrentPeriod = 1`
- Regular beneficiary with 100 shares added
- `TotalShares = 100`

**Transaction Sequence:**

1. **Period 1 - Add Sub-Scheme:**
   - Manager calls `AddSubScheme(schemeId, subSchemeB, 100 shares)`
   - `TotalShares` becomes 200
   - Sub-scheme's `ProfitDetail.StartPeriod = 3` (1 + 2 delay)

2. **Period 1 - Distribute Profits:**
   - Call `DistributeProfits(schemeId, period=1, 1000 ELF)`
   - Line 466 executes: `CachedDelayTotalShares[3] = 200`
   - Actual distribution uses `totalShares = 0` (delay not reached)

3. **Period 2 - Remove Sub-Scheme:**
   - Manager calls `RemoveSubScheme(schemeId, subSchemeB)`
   - `TotalShares` becomes 100
   - **BUG: `CachedDelayTotalShares[3]` remains 200**

4. **Period 3 - Distribute Profits:**
   - Call `DistributeProfits(schemeId, period=3, 1000 ELF)`
   - Line 469 retrieves: `totalShares = CachedDelayTotalShares[3] = 200`
   - `DistributedProfitsInfo[period3].TotalShares = 200`
   - Only regular beneficiary with 100 shares can claim

5. **Beneficiary Claims:**
   - Regular beneficiary calls `ClaimProfits` for period 3
   - Calculation: `(100 shares / 200 totalShares) * 1000 ELF = 500 ELF`
   - Beneficiary receives only 500 ELF instead of entitled 1000 ELF

**Expected Result:** Beneficiary receives 1000 ELF (100% of distribution since only beneficiary)
**Actual Result:** Beneficiary receives 500 ELF (50% due to inflated cached totalShares)
**Success Condition:** 500 ELF permanently locked in period 3's virtual address, unclaimable by any party

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L131-156)
```csharp
    public override Empty RemoveSubScheme(RemoveSubSchemeInput input)
    {
        Assert(input.SchemeId != input.SubSchemeId, "Two schemes cannot be same.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only manager can remove sub-scheme.");

        var shares = scheme.SubSchemes.SingleOrDefault(d => d.SchemeId == input.SubSchemeId);
        if (shares == null) return new Empty();

        var subSchemeId = input.SubSchemeId;
        var subScheme = State.SchemeInfos[subSchemeId];
        Assert(subScheme != null, "Sub scheme not found.");

        var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
        // Remove profit details
        State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
        scheme.SubSchemes.Remove(shares);
        scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L243-257)
```csharp
        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-583)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```
