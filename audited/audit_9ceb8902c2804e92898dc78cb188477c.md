### Title
Consensus Round Data Pollution via Unvalidated Cross-Miner State Injection

### Summary
A malicious miner can inject arbitrary `SupposedOrderOfNextRound`, `FinalOrderOfNextRound`, and `PreviousInValue` values for ALL miners in the consensus round by manipulating the simplified Round in their block's consensus header. The `RecoverFromUpdateValue` function blindly copies these values for all miners without validation, and the corrupted data persists to state via `ProcessUpdateValue`, enabling mining schedule manipulation and VRF chain corruption.

### Finding Description

**Root Cause:**

The `RecoverFromUpdateValue` function unconditionally overwrites consensus-critical fields for ALL miners from attacker-controlled block header data: [1](#0-0) 

**Attack Flow:**

1. **Block Production**: When creating a block, the miner's node calls `GetUpdateValueRound` to generate simplified Round data for the consensus header: [2](#0-1) 

This simplified Round includes `SupposedOrderOfNextRound`, `FinalOrderOfNextRound`, and `PreviousInValue` for ALL miners. A malicious miner can modify these values before including the Round in the block header.

2. **Transaction Generation**: The corrupted Round is extracted to create the UpdateValue transaction: [3](#0-2) [4](#0-3) 

The `TuneOrderInformation` dictionary captures the malicious `FinalOrderOfNextRound` values, and `MinersPreviousInValues` captures the malicious `PreviousInValue` values.

3. **Execution Without Validation**: `ProcessUpdateValue` blindly applies the attacker's values to ALL miners: [5](#0-4) [6](#0-5) 

4. **Broken Validation**: The hash comparison in `ValidateConsensusAfterExecution` is ineffective because `RecoverFromUpdateValue` modifies `currentRound` in-place and returns it, making both sides of the comparison reference the same object: [7](#0-6) 

The validation only checks the sender's data, not other miners': [8](#0-7) 

### Impact Explanation

**Direct Consensus Integrity Violation:**

1. **Mining Schedule Manipulation**: By setting arbitrary `FinalOrderOfNextRound` values, the attacker can:
   - Assign themselves or colluding miners additional mining slots in the next round
   - Exclude or demote competing miners from their expected positions
   - Violate the deterministic order conflict resolution in `ApplyNormalConsensusData` [9](#0-8) 

2. **VRF Random Number Chain Corruption**: By setting arbitrary `PreviousInValue` for other miners:
   - Breaks the cryptographic VRF chain used for random number generation
   - Can cause legitimate miners to fail validation when they produce blocks (their actual previous-in-value won't match the corrupted stored value)
   - May enable prediction or manipulation of future random numbers used in consensus

3. **Systemic Impact**: Every miner who produces a block can corrupt ALL other miners' state, leading to cascading consensus failures and potential chain halts if multiple miners are malicious.

**Severity: CRITICAL** - Violates core consensus invariant: "Correct round transitions and time-slot validation, miner schedule integrity."

### Likelihood Explanation

**High Exploitability:**

1. **Reachable Entry Point**: Any miner during their scheduled time slot can execute this attack. The entry point is the standard block production flow through `GetConsensusBlockExtraData`.

2. **Low Attack Complexity**: 
   - Attacker only needs to modify their node software to tamper with the `GetUpdateValueRound` output before block creation
   - No cryptographic barriers (signatures only authenticate the sender, not the correctness of other miners' data)
   - No economic cost beyond normal block production

3. **Feasible Preconditions**: 
   - Attacker must be a current miner (staked and elected)
   - Must wait for their turn in the mining schedule
   - Standard in rotating consensus systems

4. **Detection Difficulty**: 
   - The validation logic fails to detect the attack
   - Corrupted state appears valid to honest nodes
   - May only be detected when affected miners fail to produce blocks or anomalies in mining order emerge

5. **Economic Rationality**: 
   - Increased mining rewards from additional slots
   - Competitive advantage by disrupting rivals
   - Low risk due to validation failures

**Probability: HIGH** - Practical attack executable by any malicious miner.

### Recommendation

**Immediate Fixes:**

1. **Add Deterministic Validation in UpdateValueValidationProvider**: Before accepting order changes, verify that `TuneOrderInformation` matches the deterministic conflict resolution algorithm:

```csharp
// In UpdateValueValidationProvider.ValidateHeaderInformation()
// Reconstruct what TuneOrderInformation SHOULD be based on sender's signature
// Compare with provided TuneOrderInformation
// Reject if mismatch
```

2. **Validate PreviousInValue Updates**: Add cryptographic verification for `MinersPreviousInValues`:
   - Only allow updates when secret sharing is enabled and proper decryption proofs exist
   - Verify hash pre-images: `Hash(PreviousInValue) == StoredOutValue`
   - Reject arbitrary PreviousInValue injections

3. **Fix ValidateConsensusAfterExecution Hash Comparison**: Store the original `currentRound` before calling `RecoverFromUpdateValue`:

```csharp
var originalRound = currentRound.Clone(); // Deep clone before modification
headerInformation.Round = currentRound.RecoverFromUpdateValue(headerInformation.Round, ...);
if (headerInformation.Round.GetHash(...) != originalRound.GetHash(...))
    return ValidationResult.Failure(...);
```

4. **Remove Cross-Miner Writes in RecoverFromUpdateValue**: Lines 22-30 should only copy sender's data if proper validation cannot be added:

```csharp
// Remove the foreach loop that overwrites ALL miners' data
// Only merge sender's information
```

**Invariant Checks to Add:**

- Assert that `FinalOrderOfNextRound` changes follow deterministic conflict resolution
- Assert that `PreviousInValue` changes have cryptographic proofs
- Compare reconstructed Round with provided Round using independent state

**Test Cases:**

1. Malicious miner sets arbitrary `FinalOrderOfNextRound` for others → should be rejected
2. Malicious miner sets fake `PreviousInValue` without proof → should be rejected  
3. Hash comparison test with modified vs. unmodified Round → should detect tampering
4. End-to-end test: corrupt header should fail validation, not persist to state

### Proof of Concept

**Initial State:**
- Chain running with 7 miners
- Current round number: 100
- Miner "MaliciousMiner" has legitimate turn at time slot

**Attack Steps:**

1. **Modify Node Software**: MaliciousMiner modifies their node to intercept `GetUpdateValueRound` output

2. **Inject Malicious Data**: Before creating block, tamper with simplified Round:
```json
{
  "MinerA": { "FinalOrderOfNextRound": 7 },  // Should be 1, now last
  "MinerB": { "FinalOrderOfNextRound": 1 },  // Promoted to first  
  "MinerC": { "PreviousInValue": "0xFAKE_HASH" },  // Corrupted VRF
  "MaliciousMiner": { /* legitimate data */ }
}
```

3. **Produce Block**: MaliciousMiner produces block with corrupted consensus header

4. **Block Propagation**: Honest nodes receive block

5. **Validation Passes**: 
   - `UpdateValueValidationProvider` only checks MaliciousMiner's data → passes
   - `ValidateConsensusAfterExecution` compares same object → passes

6. **Execution**: `ProcessUpdateValue` applies via `TuneOrderInformation` and `MinersPreviousInValues`

**Expected vs Actual Result:**

**Expected**: Block rejected due to invalid cross-miner data injection

**Actual**: 
- Block accepted
- State updated with corrupted values
- Next round (101): MinerB mines first (should be MinerA)
- MinerA demoted to last position  
- MinerC's VRF chain broken, may fail validation when producing next block

**Success Condition**: Query Round 100 state → observe MinerA.FinalOrderOfNextRound = 7, MinerC.PreviousInValue = "0xFAKE_HASH" (corrupted values persisted)

### Notes

This vulnerability stems from architectural decisions where:
1. The simplified Round serves dual purposes (header serialization AND cross-miner state propagation)
2. Validation logic assumes honest miner behavior for other miners' data
3. The hash comparison mechanism has a reference-equality bug

The attack is particularly severe because it affects ALL miners simultaneously and can be repeated by any malicious miner during their turn, creating cascading consensus degradation. The fix requires both architectural changes (separate sender-only updates from cross-miner coordination) and cryptographic validation (proof-based state transitions).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L35-53)
```csharp
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L87-101)
```csharp
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L137-147)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                Context.LogDebug(() =>
                    $"Previous in value in extra data:{round.RealTimeMinersInformation[pubkey.ToHex()].PreviousInValue}");
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-47)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);

        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);

        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-296)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```
