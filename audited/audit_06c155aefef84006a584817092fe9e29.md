### Title
Missing Validation of ConfirmedIrreversibleBlockRoundNumber During NextRound Transitions Enables Blockchain DoS

### Summary
The `LibInformationValidationProvider` is not applied during `NextRound` transitions, allowing a malicious extra block producer to set `ConfirmedIrreversibleBlockRoundNumber` to an arbitrary value (including 0) without validation. This manipulated value is then used by `GetMaximumBlocksCount()` to determine blockchain mining status, enabling an attacker to force the chain into "Severe" status and restrict block production to 1 block per miner, effectively causing a denial-of-service.

### Finding Description

**Root Cause:**
During `NextRound` behavior validation, `LibInformationValidationProvider` is explicitly excluded from the validation pipeline. [1](#0-0) 

Only `UpdateValue` behavior includes this validator. [2](#0-1) 

**Validation Gap:**
The `RoundTerminateValidationProvider` used for `NextRound` only validates round number correctness and InValue nullness, but does NOT check `ConfirmedIrreversibleBlockRoundNumber`. [3](#0-2) 

**Storage Without Validation:**
The manipulated round information is stored directly via `AddRoundInformation()` without any LIB field validation. [4](#0-3) 

**Attack Vector:**
An attacker producing a `NextRound` block can manually construct `NextRoundInput` with an invalid `ConfirmedIrreversibleBlockRoundNumber` value (e.g., 0), which bypasses validation entirely since `LibInformationValidationProvider` is not invoked.

**Secondary Vulnerability:**
Even if `LibInformationValidationProvider` were added to `NextRound` validation, it contains a bypass: when `providedRound.ConfirmedIrreversibleBlockRoundNumber == 0`, the validation check is skipped entirely. [5](#0-4) 

**Impact Mechanism:**
The corrupted `ConfirmedIrreversibleBlockRoundNumber` is consumed by `GetMaximumBlocksCount()` which uses it as `libRoundNumber` to determine blockchain mining status. [6](#0-5) 

When `libRoundNumber` is set to 0 and `currentRoundNumber` >= 8, the status becomes "Severe". [7](#0-6) 

In Severe status, the maximum blocks count is reduced to 1. [8](#0-7) 

**Persistence:**
The malicious value persists across subsequent rounds because `GenerateNextRoundInformation()` copies LIB fields from the current round. [9](#0-8) 

### Impact Explanation

**Operational Impact - Consensus DoS:**
- An attacker can force the blockchain into permanent "Severe" status by setting `ConfirmedIrreversibleBlockRoundNumber = 0`
- In Severe status, miners are restricted to producing only 1 block per time slot instead of the normal limit (typically 8+)
- This reduces blockchain throughput by ~87.5% (1 block vs 8 blocks)
- The restriction persists indefinitely as the corrupted value propagates through subsequent rounds

**Affected Parties:**
- All network participants experience degraded blockchain performance
- Normal transactions face extreme delays
- Cross-chain operations that rely on timely block production are disrupted
- The chain effectively becomes unusable for production workloads

**Severity Justification:**
This is a **HIGH severity** vulnerability because:
1. It causes complete operational disruption of the consensus mechanism
2. The attack persists across multiple rounds without automatic recovery
3. Only requires control of one extra block producer slot (achievable through normal consensus participation)
4. No special privileges beyond being in the current miner rotation are needed

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be in the current round's miner list
- Attacker must be selected as the extra block producer for that round (probability ~1/N where N is miner count, typically ~17)
- Alternatively, attacker can wait/retry across multiple rounds until selected as extra block producer

**Attack Complexity:**
- **LOW**: Simple modification of `NextRoundInput.ConfirmedIrreversibleBlockRoundNumber` to 0 before signing the block
- No complex cryptographic operations or timing exploits required
- Can be executed with standard consensus client modifications

**Feasibility Conditions:**
- Entry point is the public `NextRound` method, callable by any authorized miner [10](#0-9) 
- PreCheck only validates the sender is in current or previous miner list [11](#0-10) 
- No additional authorization checks prevent the attack

**Detection/Operational Constraints:**
- Attack is immediately visible as blockchain enters Severe status and fires `IrreversibleBlockHeightUnacceptable` event
- However, by the time it's detected, the malicious value is already committed to chain state
- Recovery requires coordinated action to update the corrupted round information

**Probability Assessment:**
- **MEDIUM-HIGH**: Any malicious miner has ~5.9% chance per round (assuming 17 miners) to execute this attack
- Over 100 rounds, probability approaches certainty if even one miner is malicious
- Economic cost is minimal - just requires being selected as extra block producer through normal rotation

### Recommendation

**Immediate Fix - Add LibInformationValidationProvider for NextRound:**
```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```
Location: [1](#0-0) 

**Critical Fix - Remove Zero-Value Bypass:**
Modify `LibInformationValidationProvider` to enforce LIB progression even when values are 0:
```csharp
// Remove the bypass conditions that allow zero values
// Instead, validate that:
// 1. providedRound.ConfirmedIrreversibleBlockRoundNumber <= baseRound.RoundNumber
// 2. providedRound.ConfirmedIrreversibleBlockRoundNumber >= baseRound.ConfirmedIrreversibleBlockRoundNumber
```
Location: [5](#0-4) 

**Additional Validation - Enforce Upper Bound:**
Add check that `providedRound.ConfirmedIrreversibleBlockRoundNumber <= providedRound.RoundNumber - 1` since LIB is always updated to `currentRound.RoundNumber.Sub(1)` in the update logic. [12](#0-11) 

**Test Cases:**
1. Test NextRound with `ConfirmedIrreversibleBlockRoundNumber = 0` → should reject
2. Test NextRound with `ConfirmedIrreversibleBlockRoundNumber > currentRoundNumber` → should reject
3. Test NextRound with `ConfirmedIrreversibleBlockRoundNumber < baseRound.ConfirmedIrreversibleBlockRoundNumber` → should reject
4. Test NextRound with valid LIB progression → should accept

### Proof of Concept

**Initial State:**
- Blockchain at round N = 10
- Current round state: `ConfirmedIrreversibleBlockRoundNumber = 9`
- Attacker is extra block producer for round 10

**Attack Steps:**
1. Attacker calls `GetConsensusExtraDataForNextRound()` which generates valid round 11 data with `ConfirmedIrreversibleBlockRoundNumber = 9`
2. Before submitting the block, attacker manually modifies `NextRoundInput`:
   - Set `ConfirmedIrreversibleBlockRoundNumber = 0`
   - Keep all other fields valid (RoundNumber = 11, proper miner orders, etc.)
3. Attacker signs and submits the malicious NextRound transaction
4. Validation passes because `LibInformationValidationProvider` is not invoked for NextRound behavior
5. Malicious round 11 with `ConfirmedIrreversibleBlockRoundNumber = 0` is stored in state

**Expected vs Actual Result:**
- **Expected:** Validation should reject NextRound with invalid LIB round number
- **Actual:** Block is accepted and corrupted LIB value is stored

**Success Condition:**
In round 11, when any miner calls `GetMaximumBlocksCount()`:
- `libRoundNumber = 0` (malicious value)
- `currentRoundNumber = 11`
- Evaluation: `11 >= 0 + 8` → Severe status
- Returns: `maximumBlocksCount = 1` (reduced from normal 8+)
- Event `IrreversibleBlockHeightUnacceptable` is fired
- Blockchain throughput is reduced by ~87.5%

This demonstrates complete consensus disruption through an unvalidated round transition parameter.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-158)
```csharp
        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L280-280)
```csharp
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L24-36)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L127-128)
```csharp
            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
