# Audit Report

## Title
Consensus DoS via Missing Extra Block Producer Validation in Round Transition

## Summary
A malicious authorized miner can submit a `NextRoundInput` with no extra block producer, bypassing validation and permanently halting consensus by causing all subsequent round termination attempts to throw `InvalidOperationException`.

## Finding Description

**Root Cause:**

The `GetExtraBlockProducerInformation()` method unconditionally uses `First()` to retrieve the extra block producer, which throws an exception when no miner has `IsExtraBlockProducer = true`: [1](#0-0) 

This method is invoked during consensus command generation when miners need to terminate rounds. The call chain is: `GetConsensusCommand()` determines behavior, instantiates `TerminateRoundCommandStrategy` for NextRound/NextTerm: [2](#0-1) 

Which calls `ArrangeExtraBlockMiningTime()`: [3](#0-2) 

Leading to: [4](#0-3) 

Which invokes `ArrangeAbnormalMiningTime()` that calls the vulnerable `GetExtraBlockProducerInformation()`: [5](#0-4) 

**Validation Failure:**

The `NextRound()` method accepts arbitrary input from authorized miners: [6](#0-5) 

Authorization only checks if sender is in the miner list, not input validity: [7](#0-6) 

The `NextRoundInput.ToRound()` performs no validation, just field copying: [8](#0-7) 

The `RoundTerminateValidationProvider` only validates round number increment and null InValues, but NOT extra block producer existence: [9](#0-8) 

The malicious round is stored without validation: [10](#0-9) 

**Attack Execution:**

1. Malicious miner crafts `NextRoundInput` with all `IsExtraBlockProducer` flags set to false
2. Calls `NextRound()` - passes authorization check
3. Malicious round stored via `AddRoundInformation()`
4. When any miner calls `GetConsensusCommand()` (a view method): [11](#0-10) 

The command generation throws `InvalidOperationException`, preventing all miners from obtaining NextRound/NextTerm mining commands. The blockchain becomes stuck in the malicious round permanently.

## Impact Explanation

**Critical Severity - Complete Consensus Halt:**

- No miner can generate valid consensus commands to terminate the round
- Once all miners exhaust their time slots, the round cannot progress
- All consensus-dependent operations halt: rewards distribution, term changes, election updates
- Cross-chain operations dependent on consensus fail
- Requires hard fork or emergency intervention to recover
- Economic activities freeze indefinitely

The impact is total consensus denial-of-service affecting the entire blockchain and all dependent systems.

## Likelihood Explanation

**Medium-to-High Likelihood:**

**Attacker Requirements:**
- Must be an authorized miner (achievable through election or compromise)
- Can directly call `NextRound()` with crafted input

**Attack Complexity:**
- Trivial: construct `NextRoundInput` with `IsExtraBlockProducer = false` for all miners
- Single transaction to exploit
- No timing dependencies or complex state manipulation required

**Feasibility:**
- Insider threat or single compromised miner sufficient
- Structural validation gap (not race condition)
- Immediately exploitable once miner access obtained
- Attack succeeds before detection (malicious round stored)

## Recommendation

Add validation in `RoundTerminateValidationProvider.ValidationForNextRound()` to ensure exactly one miner has `IsExtraBlockProducer = true`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // Add validation for extra block producer
    var extraBlockProducers = extraData.Round.RealTimeMinersInformation.Values
        .Count(m => m.IsExtraBlockProducer);
    if (extraBlockProducers != 1)
        return new ValidationResult { Message = "Next round must have exactly one extra block producer." };

    return new ValidationResult { Success = true };
}
```

Additionally, add a defensive check in `GetExtraBlockProducerInformation()`:

```csharp
private MinerInRound GetExtraBlockProducerInformation()
{
    var producer = RealTimeMinersInformation.FirstOrDefault(bp => bp.Value.IsExtraBlockProducer).Value;
    Assert(producer != null, "No extra block producer found in round.");
    return producer;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ConsensusDoS_MissingExtraBlockProducer_CausesHalt()
{
    // Setup: Valid round with extra block producer
    var currentRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Craft malicious NextRoundInput with no extra block producer
    var maliciousNextRound = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber
    };
    
    foreach (var miner in currentRound.RealTimeMinersInformation)
    {
        maliciousNextRound.RealTimeMinersInformation.Add(miner.Key, new MinerInRound
        {
            Pubkey = miner.Value.Pubkey,
            Order = miner.Value.Order,
            IsExtraBlockProducer = false, // All set to false!
            ExpectedMiningTime = miner.Value.ExpectedMiningTime
        });
    }
    
    // Execute attack: authorized miner submits malicious input
    var result = await ConsensusContract.NextRound.SendAsync(maliciousNextRound);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Accepted!
    
    // Verify DoS: GetConsensusCommand now throws for NextRound behavior
    var exception = await Assert.ThrowsAsync<InvalidOperationException>(async () =>
    {
        await ConsensusContract.GetConsensusCommand.CallAsync(
            BytesValue.Parser.ParseFrom(InitialMinersKeyPairs.First().PublicKey));
    });
    
    exception.Message.ShouldContain("Sequence contains no matching element");
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L19-26)
```csharp
    public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
        bool mustExceededCurrentRound = false)
    {
        var miningInterval = GetMiningInterval();

        var minerInRound = RealTimeMinersInformation[pubkey];

        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L39-44)
```csharp
            case AElfConsensusBehaviour.NextRound:
            case AElfConsensusBehaviour.NextTerm:
                return new ConsensusCommandProvider(
                        new TerminateRoundCommandStrategy(currentRound, pubkey, currentBlockTime,
                            behaviour == AElfConsensusBehaviour.NextTerm))
                    .GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-27)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MiningTimeArrangingService.cs (L22-25)
```csharp
        public static Timestamp ArrangeExtraBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
        {
            return round.ArrangeAbnormalMiningTime(pubkey, currentBlockTime);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** protobuf/acs4.proto (L20-22)
```text
    rpc GetConsensusCommand (google.protobuf.BytesValue) returns (ConsensusCommand) {
        option (aelf.is_view) = true;
    }
```
