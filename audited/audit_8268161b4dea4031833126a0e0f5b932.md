### Title
Permanent Token Lock and Side Chain Disposal DoS Due to Unhandled Transfer Failure

### Summary
The `UnlockTokenAndResource()` function in the CrossChain contract calls `TransferDepositToken()` without any error handling mechanism. If this transfer fails (e.g., when the proposer address is blacklisted), the entire `DisposeSideChain` transaction reverts, preventing the side chain from being disposed and permanently locking all deposited tokens in the virtual address with no recovery mechanism.

### Finding Description

The vulnerability exists in the side chain disposal flow where token unlock occurs before state updates: [1](#0-0) 

The `UnlockTokenAndResource()` function attempts to transfer tokens without error handling: [2](#0-1) 

The transfer is executed via `TransferDepositToken()` using `Context.SendVirtualInline()`, which will revert the entire transaction if it fails: [3](#0-2) 

**Root Cause**: The inline call mechanism in AElf means any failure in the token transfer will cause the entire `DisposeSideChain` transaction to revert. This occurs BEFORE the side chain status is updated to `Terminated` at line 235, leaving the system in an inconsistent state where:
- The side chain cannot be disposed
- The status remains active
- All deposited tokens remain locked in the virtual address forever

**Why Protections Fail**: The token transfer can fail due to validation checks in the MultiToken contract: [4](#0-3) 

Specifically, if the proposer address is added to the transfer blacklist: [5](#0-4) 

There is no alternative disposal mechanism, no try-catch around the transfer, and no emergency recovery function. The contract has only one disposal entry point with no fallback path.

### Impact Explanation

**Direct Fund Impact**: All tokens deposited for side chain indexing fees (potentially millions in native tokens) become permanently locked in the virtual address with no recovery mechanism. These funds cannot be withdrawn, transferred, or accessed by any party.

**Operational Impact**: Complete DoS of the side chain disposal functionality. Once a proposer is blacklisted (or any other permanent transfer failure condition occurs), the side chain can never be disposed, creating a permanent zombie chain that consumes state storage and cannot be removed from the system.

**Affected Parties**: 
- Side chain proposers lose all deposited indexing fees
- The parent chain suffers from inability to clean up terminated chains
- Protocol governance loses the ability to properly manage side chain lifecycle

**Severity Justification**: High severity because it results in:
1. Permanent, irrecoverable fund loss
2. Complete DoS of critical disposal functionality
3. No mitigation or recovery path exists
4. Impact scales with the number of side chains and deposit amounts

### Likelihood Explanation

**Attacker Capabilities**: No malicious attacker is required. The vulnerability can be triggered through normal protocol operations:
1. A proposer address gets added to the transfer blacklist via the authorized `AddToTransferBlackList` function (controlled by transfer blacklist controller)
2. When governance attempts to dispose that side chain, the transaction fails

**Attack Complexity**: Minimal. The failure scenario requires only:
- A side chain with deposited tokens
- The proposer address being added to the transfer blacklist
- An attempt to call `DisposeSideChain`

**Feasibility Conditions**: The MultiToken contract explicitly supports transfer blacklisting as a feature, making this a realistic operational scenario rather than an edge case.

**Probability Reasoning**: Medium-to-high probability because:
- Transfer blacklisting is a legitimate protocol feature used for compliance or security purposes
- Proposer addresses can be blacklisted for valid reasons (compromised addresses, regulatory requirements)
- No special conditions or privileges are needed beyond normal protocol operations
- Once triggered, the condition is permanent with no recovery

### Recommendation

**Code-Level Mitigation**:

1. Implement a try-catch pattern around the token transfer in `UnlockTokenAndResource()`:
```
Try to transfer tokens to proposer
If transfer succeeds: continue normally
If transfer fails: 
  - Emit event with failure details
  - Allow disposal to continue
  - Provide alternative withdrawal mechanism for locked tokens
```

2. Add an emergency recovery function that allows the side chain lifetime controller to dispose a chain and redirect locked tokens to an alternative address (e.g., Treasury) when normal transfer fails.

3. Separate the disposal status update from the token unlock operation, ensuring disposal can complete even if unlock fails.

**Invariant Checks**:
- Side chain disposal must succeed regardless of token transfer outcome
- Tokens must always have a recovery path, even if primary transfer fails
- Disposal status updates must be atomic and not dependent on external calls

**Test Cases**:
1. Test disposal when proposer is blacklisted - should succeed with tokens redirected
2. Test disposal when proposer address is invalid - should succeed with tokens held for later claim
3. Test that disposed chains cannot be re-disposed
4. Test that locked tokens have alternative recovery mechanisms

### Proof of Concept

**Required Initial State**:
- Side chain created with chainId=X, proposer=Address_A, indexing fee deposit=1000 tokens
- Address_A has deposited tokens into the virtual address for indexing fees
- Side chain is operational

**Transaction Steps**:
1. Transfer blacklist controller calls `AddToTransferBlackList(Address_A)` to blacklist the proposer [5](#0-4) 

2. Side chain lifetime controller calls `DisposeSideChain(chainId=X)` [6](#0-5) 

3. Execution reaches `UnlockTokenAndResource(info)` at line 234 [2](#0-1) 

4. `TransferDepositToken()` is called, which invokes `Context.SendVirtualInline()` to transfer tokens to blacklisted Address_A

5. The token contract's `DoTransfer()` executes and fails the blacklist check [7](#0-6) 

**Expected Result**: Side chain should be disposed and tokens should be recovered through alternative mechanism

**Actual Result**: 
- Entire transaction reverts due to inline call failure
- Side chain status remains NOT Terminated
- 1000 tokens remain permanently locked in virtual address
- `DisposeSideChain` can never succeed for this chain
- No recovery mechanism exists

**Success Condition for Exploit**: The vulnerability is successfully demonstrated when `DisposeSideChain` permanently fails for any side chain whose proposer has been blacklisted, with no alternative path to dispose the chain or recover the tokens.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L222-242)
```csharp
    public override Int32Value DisposeSideChain(Int32Value input)
    {
        AssertSideChainLifetimeControllerAuthority(Context.Sender);

        var chainId = input.Value;
        var info = State.SideChainInfo[chainId];
        Assert(info != null, "Side chain not found.");
        Assert(info.SideChainStatus != SideChainStatus.Terminated, "Incorrect chain status.");

        if (TryGetIndexingProposal(chainId, out _))
            ResetChainIndexingProposal(chainId);

        UnlockTokenAndResource(info);
        info.SideChainStatus = SideChainStatus.Terminated;
        State.SideChainInfo[chainId] = info;
        Context.Fire(new Disposed
        {
            ChainId = chainId
        });
        return new Int32Value { Value = chainId };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L73-86)
```csharp
    private void UnlockTokenAndResource(SideChainInfo sideChainInfo)
    {
        // unlock token
        var chainId = sideChainInfo.SideChainId;
        var balance = GetSideChainIndexingFeeDeposit(chainId);
        if (balance <= 0)
            return;
        TransferDepositToken(new TransferInput
        {
            To = sideChainInfo.Proposer,
            Amount = balance,
            Symbol = Context.Variables.NativeSymbol
        }, chainId);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L163-168)
```csharp
    private void TransferDepositToken(TransferInput input, int chainId)
    {
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        Context.SendVirtualInline(ConvertChainIdToHash(chainId), State.TokenContract.Value,
            nameof(State.TokenContract.Transfer), input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L99-114)
```csharp
    private void DoTransfer(Address from, Address to, string symbol, long amount, string memo = null)
    {
        Assert(!IsInTransferBlackListInternal(from), "From address is in transfer blacklist.");
        Assert(from != to, "Can't do transfer to sender itself.");
        AssertValidMemo(memo);
        ModifyBalance(from, symbol, -amount);
        ModifyBalance(to, symbol, amount);
        Context.Fire(new Transferred
        {
            From = from,
            To = to,
            Symbol = symbol,
            Amount = amount,
            Memo = memo ?? string.Empty
        });
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L854-860)
```csharp
    public override Empty AddToTransferBlackList(Address input)
    {
        AssertControllerForTransferBlackList();
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid address.");
        State.TransferBlackList[input] = true;
        return new Empty();
    }
```
