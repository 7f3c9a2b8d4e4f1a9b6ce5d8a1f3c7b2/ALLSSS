### Title
Null Signature Handling Causes Consensus DoS in CalculateSignature()

### Summary
The `CalculateSignature()` function in the AEDPoS consensus contract aggregates miner signatures without null checks, and the underlying `HashHelper.XorAndCompute()` method crashes when passed a null Hash parameter. When miners miss their time slots in the first round of a term, their signatures remain uninitialized (null), causing `SupplyCurrentRoundInformation()` to crash when attempting to calculate signatures for the next round, halting consensus entirely.

### Finding Description

The vulnerability exists in the signature aggregation logic: [1](#0-0) 

This function aggregates all miner signatures using `HashHelper.XorAndCompute()`, which does not handle null parameters safely: [2](#0-1) 

When `h2` is null, the expression `h2.Value[i]` throws a `NullReferenceException`.

The root cause is that when a new round is generated, miner signatures are never initialized: [3](#0-2) 

The `Signature` field (defined in the protobuf as optional) remains null: [4](#0-3) 

The vulnerability is triggered when `NextRound` is called and invokes `SupplyCurrentRoundInformation()`: [5](#0-4) 

This method attempts to fill in signatures for miners who didn't mine in the previous round: [6](#0-5) 

When `previousRound.CalculateSignature()` is called and `previousRound` contains any miner with a null signature, the aggregation fails with a `NullReferenceException`.

### Impact Explanation

**Operational Impact - Consensus DoS:**
- When a miner misses their time slot in the first round of any term, their signature remains null
- The next round cannot be initialized because `SupplyCurrentRoundInformation()` crashes with a `NullReferenceException`
- Consensus halts completely - no blocks can be produced
- The blockchain becomes unresponsive until manual intervention or network restart
- All network participants are affected (validators, users, applications)

**Severity: High** - This is a complete consensus failure that requires only a single missed time slot in the first round, which can occur through network issues, node downtime, or intentional griefing.

### Likelihood Explanation

**Likelihood: Medium-High**

**Reachable Entry Point:** The public `NextRound()` method is the standard consensus progression path called by validators.

**Feasible Preconditions:**
- A new term begins (first round of the term)
- At least one miner fails to produce a block in this first round (missed time slot)
- This can happen naturally due to: network latency, node crashes, power outage, or malicious behavior

**Execution Practicality:**
- Missed time slots are a normal occurrence in any consensus system
- No special attacker privileges required - any miner can simply not mine
- The first round of each term is vulnerable (recurring condition)

**Economic Rationality:**
- No cost to the attacker - simply don't produce a block
- Griefing attack is free and halts the entire chain

**Detection:** The crash occurs during transaction execution, making it immediately observable but also immediately fatal to consensus.

### Recommendation

**1. Add null safety check in CalculateSignature:**

Before aggregating, replace null signatures with `Hash.Empty`:

```csharp
public Hash CalculateSignature(Hash inValue)
{
    return HashHelper.XorAndCompute(inValue,
        RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
            (current, minerInRound) => HashHelper.XorAndCompute(current, 
                minerInRound.Signature ?? Hash.Empty)));
}
```

**2. Initialize signatures in GenerateFirstRoundOfNewTerm:**

Explicitly set signature to `Hash.Empty` during round generation:

```csharp
minerInRound.Signature = Hash.Empty;
```

**3. Add defensive check in SupplyCurrentRoundInformation:**

Before calling `CalculateSignature`, verify all signatures are non-null or substitute `Hash.Empty`.

**4. Add regression test:**

Create a test case that simulates a miner missing their time slot in the first round and then progressing to the next round, ensuring no crash occurs.

### Proof of Concept

**Initial State:**
1. Chain initialized with 5 miners
2. First round of new term begins

**Attack Sequence:**

**Transaction 1-4:** Miners A, B, C, D produce blocks normally
- Their signatures get calculated and stored

**Transaction 5:** Miner E misses time slot (doesn't produce block)
- Miner E's signature remains null in Round 1

**Transaction 6:** Extra block producer calls `NextRound()` to progress consensus
- `NextRound()` calls `SupplyCurrentRoundInformation()` (line 163)
- For Miner E (who didn't mine), it calls `previousRound.CalculateSignature(previousInValue)` (line 199)
- `CalculateSignature` iterates through all miners including Miner E
- When aggregating, it calls `HashHelper.XorAndCompute(current, minerE.Signature)` where `minerE.Signature` is null
- `XorAndCompute` executes `h2.Value[i]` where `h2` is null
- **NullReferenceException is thrown**
- Transaction fails, round cannot progress

**Expected Result:** Round 2 begins successfully with missing miner's signature handled gracefully

**Actual Result:** Consensus halts with `NullReferenceException`, blockchain stops producing blocks

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** src/AElf.Types/Helper/HashHelper.cs (L66-72)
```csharp
        public static Hash XorAndCompute(Hash h1, Hash h2)
        {
            var newBytes = new byte[AElfConstants.HashByteArrayLength];
            for (var i = 0; i < newBytes.Length; i++) newBytes[i] = (byte)(h1.Value[i] ^ h2.Value[i]);

            return ComputeFrom(newBytes);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L23-38)
```csharp
        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }
```

**File:** protobuf/aedpos_contract.proto (L266-276)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-165)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L186-201)
```csharp
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
            }
```
