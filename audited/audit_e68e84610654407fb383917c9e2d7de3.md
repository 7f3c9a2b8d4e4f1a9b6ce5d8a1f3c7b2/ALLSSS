### Title
Abstention Short-Circuit Logic Blocks Proposals Meeting Approval Threshold

### Summary
The `IsReleaseThresholdReached()` function checks abstention thresholds before approval thresholds, creating edge cases where proposals with sufficient approvals are incorrectly rejected due to excessive abstentions. This is particularly problematic when `MaximalAbstentionThreshold + MinimalApprovalThreshold` approaches 100%, as allowed by the organization validation constraints.

### Finding Description

The `IsReleaseThresholdReached()` function implements a short-circuit evaluation pattern that checks rejection and abstention limits before verifying approval requirements. [1](#0-0) 

The function returns `false` if abstentions exceed the `MaximalAbstentionThreshold` (line 43-45), even before checking if approvals meet the `MinimalApprovalThreshold` (line 47). The abstention check uses strict inequality (`>`), while the approval check uses inclusive inequality (`>=`). [2](#0-1) [3](#0-2) 

The organization validation allows `MaximalAbstentionThreshold + MinimalApprovalThreshold <= AbstractVoteTotal`, permitting configurations where these thresholds sum to 100%. [4](#0-3) 

**Concrete Example with Default Configuration:** [5](#0-4) 

With 100 parliament members:
- 67 members approve (67.0% ≥ 66.67% threshold ✓)
- 21 members abstain (21.0% > 20.0% threshold ✗)
- **Result:** Proposal BLOCKED despite meeting approval requirements

**Mathematical verification:**
- Approval check: `67 * 10000 = 670,000 >= 6667 * 100 = 666,700` ✓
- Abstention check: `21 * 10000 = 210,000 > 2000 * 100 = 200,000` ✗ (blocks release)

**Emergency Organization (Most Vulnerable):** [6](#0-5) 

With thresholds summing to exactly 100% (9000 + 1000 = 10000), any proposal with ≥90% approval but >10% abstention is blocked, despite meeting all approval requirements.

The `Release()` function enforces this flawed check, preventing execution of legitimately approved proposals. [7](#0-6) 

### Impact Explanation

**Governance Disruption:**
Proposals with sufficient community approval cannot execute, breaking the fundamental governance invariant that proposals meeting approval thresholds should be releasable. This affects:

1. **Default Organization:** Proposals with 66.67%-80% approval can be blocked by 20.1%-33.3% abstentions
2. **Emergency Organization:** Critical proposals with 90%-99% approval can be blocked by 10.1%-10% abstentions
3. **Custom Organizations:** Any organization with `MaximalAbstentionThreshold + MinimalApprovalThreshold ≥ 90%` is vulnerable

**Strategic Exploitation:**
Malicious actors can intentionally abstain (rather than reject) to block proposals they oppose, even when those proposals have overwhelming approval. This is particularly dangerous because:
- Abstaining appears less confrontational than rejecting
- The blocking mechanism is non-obvious to voters
- No direct financial cost to abstaining voters

**Severity Justification:**
Medium severity due to governance disruption affecting proposal execution, though not directly compromising funds. The impact is severe for emergency responses where time-sensitive proposals may be blocked despite near-unanimous support.

### Likelihood Explanation

**Attacker Capabilities:**
Any parliament member (current miner or managed pubkey holder) can vote, including abstaining. No special privileges required beyond normal governance participation. [8](#0-7) 

**Execution Practicality:**
1. **Default Configuration:** Requires 21+ members abstaining when 67+ approve (out of 100)
   - Feasible in contentious proposals where ~20% prefer neutrality
   - Natural voting pattern, no coordination required

2. **Emergency Configuration:** Requires 11+ members abstaining when 90+ approve (out of 100)
   - More difficult but still realistic for controversial emergency actions
   - Only 11% strategic abstention needed to block critical proposals

**Realistic Scenarios:**
- Controversial economic policy changes where minority opposes but prefers abstention over rejection
- Time-sensitive emergency responses where delay benefits certain parties
- Protocol upgrades with legitimate concerns from a minority of validators

**Detection Difficulty:**
The blocking mechanism is non-obvious. Voters may not realize their abstentions are blocking an otherwise approved proposal, making this exploitable through social engineering or natural voting patterns.

**Probability Assessment:**
High for organizations with threshold sums ≥90%, Medium for default configuration. The emergency organization is immediately vulnerable due to 100% threshold sum.

### Recommendation

**Primary Fix - Reorder Evaluation Logic:**
Check approval requirements first, then verify rejections/abstentions don't invalidate the approval:

```csharp
private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
{
    var parliamentMembers = GetCurrentMinerList();
    
    // First check if proposal has enough approvals
    if (!CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers))
        return false;
    
    // Then check if it's blocked by excessive rejections or abstentions
    var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
    if (isRejected)
        return false;
        
    var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
    if (isAbstained)
        return false;
    
    return true;
}
```

**Alternative Fix - Strengthen Validation Constraints:**
Ensure threshold sums cannot approach 100%:

```csharp
// In Validate(Organization organization)
return /* existing checks */ &&
       proposalReleaseThreshold.MaximalAbstentionThreshold +
       proposalReleaseThreshold.MaximalRejectionThreshold +
       proposalReleaseThreshold.MinimalApprovalThreshold < AbstractVoteTotal - 1000; // 10% buffer
```

**Test Cases:**
1. Proposal with 67% approval, 21% abstention, 0% rejection → should PASS with default config
2. Proposal with 90% approval, 11% abstention, 0% rejection → should PASS with emergency config
3. Proposal with 50% approval, 15% abstention, 5% rejection → should FAIL (insufficient approval)
4. Verify threshold validation rejects sums ≥90% if using alternative fix

### Proof of Concept

**Initial State:**
- Default Parliament organization exists with standard thresholds
- 100 current miners in parliament
- Proposal created for critical governance action

**Transaction Steps:**

1. **Create Proposal** (any authorized proposer)
   - Target: System contract method requiring governance approval
   - Organization: Default Parliament organization

2. **67 Members Approve** 
   - Each calls `Approve(proposalId)`
   - Approval count: 67/100 = 67.0% ≥ 66.67% threshold

3. **21 Members Abstain**
   - Each calls `Abstain(proposalId)`  
   - Abstention count: 21/100 = 21.0% > 20.0% threshold

4. **Proposer Attempts Release**
   - Calls `Release(proposalId)`
   - Check: `67 * 10000 = 670,000 >= 6667 * 100 = 666,700` ✓ (approval sufficient)
   - Check: `21 * 10000 = 210,000 > 2000 * 100 = 200,000` ✗ (abstention exceeds limit)

**Expected Result:**
Proposal should execute because it meets the 66.67% approval threshold and has 88% total participation (67 + 21).

**Actual Result:**
`Release()` reverts with "Not approved" error message because `IsReleaseThresholdReached()` returns `false` at line 44-45 due to excessive abstentions, before ever checking that approvals meet the threshold.

**Success Condition Verification:**
The vulnerability is exploitable if a proposal with approvals meeting `MinimalApprovalThreshold` is rejected due to abstentions exceeding `MaximalAbstentionThreshold`, which contradicts the governance model where sufficient approvals should authorize execution.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L36-48)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var parliamentMembers = GetCurrentMinerList();
        var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
        if (isAbstained)
            return false;

        return CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L72-78)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(parliamentMembers.Contains);
        return abstentionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L151-154)
```csharp
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L318-324)
```csharp
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 9000,
                MinimalVoteThreshold = 9000,
                MaximalAbstentionThreshold = 1000,
                MaximalRejectionThreshold = 1000
            },
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L5-9)
```csharp
    private const int DefaultOrganizationMinimalApprovalThreshold = 6667;
    private const int DefaultOrganizationMaximalAbstentionThreshold = 2000;
    private const int DefaultOrganizationMaximalRejectionThreshold = 2000;
    private const int DefaultOrganizationMinimalVoteThresholdThreshold = 7500;
    private const int AbstractVoteTotal = 10000;
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L114-130)
```csharp
    public override Empty Abstain(Hash input)
    {
        var parliamentMemberAddress = GetAndCheckActualParliamentMemberAddress();
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedByMember(proposal, parliamentMemberAddress);
        proposal.Abstentions.Add(parliamentMemberAddress);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = parliamentMemberAddress,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Abstain),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```
