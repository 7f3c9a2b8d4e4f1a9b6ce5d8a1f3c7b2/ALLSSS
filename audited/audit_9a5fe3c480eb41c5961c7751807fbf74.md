# Audit Report

## Title
Miners Can Force UpdateValue Behaviour to Prevent Round/Term Transitions

## Summary
The AEDPoS consensus contract allows miners to arbitrarily choose their consensus behaviour (UpdateValue, NextRound, or NextTerm) when producing blocks. The validation system only checks that the submitted data is well-formed for the chosen behaviour but does not verify that the behaviour choice itself is appropriate for the current consensus state. This enables malicious miners to force UpdateValue behaviour when they should be terminating rounds with NextRound or NextTerm, preventing consensus progression and monopolizing block production.

## Finding Description

The consensus system operates in two phases: behaviour determination and behaviour execution. The contract determines the expected behaviour through `GetConsensusBehaviour()`, which uses `IsTimeSlotPassed()` to decide whether a miner should update values within their time slot or terminate the round when their time slot has expired. [1](#0-0) 

The critical issue is that this behaviour determination is purely advisory. When miners produce blocks, they provide their own behaviour choice in `AElfConsensusTriggerInformation`, which is defined to include a `behaviour` field that miners control. [2](#0-1) 

The contract's `GetConsensusBlockExtraData` method directly uses whatever behaviour the miner provides without any validation that this matches what `GetConsensusBehaviour()` would recommend: [3](#0-2) 

The validation system in `ValidateBeforeExecution` selects different validators based on the miner-provided behaviour, but critically, none of these validators check whether the behaviour choice itself is appropriate: [4](#0-3) 

The `UpdateValueValidationProvider` only validates that OutValue and Signature fields are properly filled, not whether UpdateValue should be used at all: [5](#0-4) 

Similarly, `TimeSlotValidationProvider` checks that a miner's actual mining times fall within their allocated time slot boundaries, but does not enforce that UpdateValue must transition to NextRound/NextTerm when the time slot passes: [6](#0-5) 

The `IsTimeSlotPassed` method determines when a miner's time slot has expired and they should terminate the round: [7](#0-6) 

However, there is no validator that enforces: "If `IsTimeSlotPassed` returns true, reject UpdateValue and require NextRound/NextTerm." This allows malicious miners to continuously submit UpdateValue when they should be terminating rounds.

## Impact Explanation

**Critical Consensus Failure:**

A malicious miner can completely halt consensus progression by forcing UpdateValue behaviour when their time slot has passed. This breaks multiple critical invariants:

1. **Consensus Stalling**: The round/term never advances because the designated terminator continuously uses UpdateValue instead of NextRound/NextTerm [8](#0-7) 

2. **Block Production Monopolization**: Other miners cannot mine because their time slots are defined relative to round progression, which is blocked

3. **Reward Capture**: The malicious miner captures all block rewards that should be distributed across the miner set over multiple rounds

4. **LIB Calculation Disruption**: Last Irreversible Block calculation depends on multiple miners providing inputs across rounds; monopolization by a single miner breaks this mechanism

5. **Term Transition Prevention**: On the main chain, malicious miners can prevent NextTerm transitions, maintaining an outdated miner set and blocking legitimate validator rotation through the election process

The impact is severe because it breaks the fundamental consensus guarantee that rounds and terms will progress according to the time-slot schedule.

## Likelihood Explanation

**High Likelihood of Exploitation:**

- **Low Barrier to Entry**: Any active miner in the miner set can execute this attack. Becoming a miner only requires staking tokens and getting elected, which are normal protocol operations

- **Simple Execution**: The attack requires minimal modification to a mining node - simply override the behaviour field in `AElfConsensusTriggerInformation` to always use UpdateValue instead of respecting the hint from `GetConsensusCommand`

- **Passes All Validations**: The attack succeeds because the validation system has a fundamental gap - it validates data format but not behaviour appropriateness. All validators pass because UpdateValue data is well-formed

- **High Economic Incentive**: Monopolizing block production is highly profitable through reward accumulation. The attacker gains all mining rewards while preventing other miners from earning

- **Difficult to Detect**: The attack appears as normal UpdateValue transactions. Distinguishing malicious from legitimate UpdateValue requires off-chain analysis of whether the miner should have terminated the round

The vulnerability exists in production code with no mitigations or monitoring in place.

## Recommendation

Add a validator that enforces behaviour appropriateness based on consensus state. The validation system should include a check that replicates the logic from `GetConsensusBehaviour()`:

```csharp
public class BehaviourAppropriatenessValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var currentRound = validationContext.BaseRound;
        var minerInRound = currentRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var currentBlockTime = validationContext.ExtraData.Round.RealTimeMinersInformation[validationContext.SenderPubkey]
            .ActualMiningTimes.LastOrDefault();
        
        // Check if time slot has passed
        var isTimeSlotPassed = currentRound.IsTimeSlotPassed(validationContext.SenderPubkey, currentBlockTime);
        
        // If time slot passed and miner has already produced blocks, they should terminate round
        if (isTimeSlotPassed && minerInRound.OutValue != null)
        {
            if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            {
                return new ValidationResult 
                { 
                    Message = "Time slot passed - must use NextRound or NextTerm instead of UpdateValue." 
                };
            }
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Add this validator to the validation provider list in `ValidateBeforeExecution` before behaviour-specific validators execute.

## Proof of Concept

This vulnerability cannot be fully demonstrated without a complete test environment that includes node-level modifications, as the attack requires overriding the behaviour in the trigger information before it reaches the contract. However, the validation gap can be verified by examining the code:

1. The behaviour determination logic in `ConsensusBehaviourProviderBase.GetConsensusBehaviour()` returns NextRound/NextTerm when `IsTimeSlotPassed` is true and `OutValue != null`

2. The validation logic in `ValidateBeforeExecution` never re-checks this condition - it only validates that the provided behaviour's data is well-formed

3. No validator enforces: "If consensus state requires NextRound/NextTerm, reject UpdateValue"

To exploit in practice:
1. Deploy a modified mining node that ignores the `hint.Behaviour` returned by `GetConsensusCommand`
2. Override `AElfConsensusTriggerInformation.Behaviour` to always be `UpdateValue` 
3. Produce blocks using UpdateValue even when time slot has passed
4. Observe that validation passes and round progression halts

The code evidence demonstrates this is exploitable because there is no validation preventing behaviour choice manipulation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** protobuf/aedpos_contract.proto (L329-346)
```text
message AElfConsensusTriggerInformation {
    // The miner public key.
    bytes pubkey = 1;
    // The InValue for current round.
    aelf.Hash in_value = 2;
    // The InValue for previous round.
    aelf.Hash previous_in_value = 3;
    // The behaviour of consensus.
    AElfConsensusBehaviour behaviour = 4;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 5;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 6;
    // The revealed InValues.
    map<string, aelf.Hash> revealed_in_values = 7;
    // The random number.
    bytes random_number = 8;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L26-47)
```csharp
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-33)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-99)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```
