### Title
Sponsor Fund Lock in AnnounceElectionFor Due to Admin/Sponsor Separation Without Recovery Mechanism

### Summary
The `AnnounceElectionFor()` function allows a sponsor to lock 100,000 ELF for candidate election while designating a different address as admin. Since only the admin can call `QuitElection()` to unlock funds (which are then returned to the sponsor), a sponsor who specifies an admin different from themselves loses all control over recovering their locked 100,000 ELF. If the admin becomes unresponsive, compromised, or malicious, the sponsor's funds remain locked indefinitely with no recovery mechanism.

### Finding Description

The vulnerability exists in the `AnnounceElectionFor()` function where the admin and sponsor roles are decoupled without proper safeguards. [1](#0-0) 

The admin is set to either the provided `input.Admin` or defaults to `Context.Sender`, while: [2](#0-1) 

The sponsor is always recorded as `Context.Sender`. When these differ, the sponsor's 100,000 ELF is locked via: [3](#0-2) 

Where `Context.Sender` (the sponsor) provides the locked tokens.

The only mechanism to unlock these funds is through `QuitElection()`: [4](#0-3) 

Which requires the caller to be the admin, but: [5](#0-4) 

Returns the tokens to the sponsor. This is the ONLY code path that unlocks candidate deposit tokens from the virtual address - there is no emergency withdrawal, timeout mechanism, or sponsor override capability.

**Root Cause:** The design decouples operational control (admin) from capital provision (sponsor) without:
1. Requiring admin to equal sponsor
2. Providing sponsor emergency exit capability  
3. Implementing any timelock or forced unlock mechanism
4. Adding multi-signature or governance override for recovery

### Impact Explanation

**Direct Financial Impact:**
- Each vulnerable transaction locks 100,000 ELF (valued at 100,000 tokens per the constant): [6](#0-5) 

- Sponsors lose complete control over their locked capital if admin ≠ sponsor
- Funds remain locked indefinitely with no recovery path
- No expiration period exists on the lock

**Who Is Affected:**
- Any sponsor who calls `AnnounceElectionFor()` with an admin address different from themselves
- Particularly affects organizations/DAOs that want to sponsor candidates while delegating operational control
- Affects scenarios where sponsors trust but cannot fully control admin accounts

**Severity Justification (Medium):**
- Direct fund lock of substantial amount (100,000 ELF per candidate)
- Requires user error (specifying different admin) but creates permanent fund loss
- No protocol-level protection against this configuration
- Cannot be exploited by external attackers but creates systemic risk for legitimate users
- Impact is concrete and quantifiable, likelihood requires specific user configuration

### Likelihood Explanation

**Reachability:** `AnnounceElectionFor()` is a public method callable by any user: [7](#0-6) 

**Feasibility:** 
- No special preconditions needed
- Attacker capabilities: None required - this affects legitimate users making configuration choices
- The protocol message explicitly allows admin specification: [8](#0-7) 

**Execution Practicality:**
- Single transaction execution
- No complex state setup required
- Legitimate use case where sponsor wants to delegate management to another party (DAO, organization, candidate themselves)

**Probability Reasoning:**
- The existing test suite only tests the case where admin = candidate address, not admin ≠ sponsor: [9](#0-8) 

- No documentation warning against this configuration
- Reasonable use case: sponsor pays, candidate/organization manages
- Higher likelihood in organizational contexts where separation of concerns is desired

### Recommendation

**Immediate Fix:**
Add one of the following protective mechanisms to `AnnounceElectionFor()`:

**Option 1 - Require Admin Equals Sponsor:**
```csharp
// After line 127
Assert(admin == Context.Sender, 
    "Admin must be sponsor to prevent fund lock. Use SetCandidateAdmin after announcement.");
```

**Option 2 - Add Sponsor Emergency Withdrawal:**
Add a new function:
```csharp
public override Empty SponsorWithdrawDeposit(StringValue pubkey)
{
    var sponsor = State.CandidateSponsorMap[pubkey.Value];
    Assert(Context.Sender == sponsor, "Only sponsor can emergency withdraw.");
    
    // Add timelock (e.g., 7 days after announcement with no admin action)
    var candidateInfo = State.CandidateInformationMap[pubkey.Value];
    var timeSinceAnnounce = Context.CurrentBlockTime - GetTransactionTime(candidateInfo.AnnouncementTransactionId);
    Assert(timeSinceAnnounce.Seconds > 7 * 24 * 3600, "Must wait 7 days for emergency withdrawal.");
    
    // Unlock and return tokens
    var lockId = candidateInfo.AnnouncementTransactionId;
    var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
    State.TokenContract.TransferFrom.Send(new TransferFromInput {
        From = lockVirtualAddress,
        To = sponsor,
        Symbol = Context.Variables.NativeSymbol,
        Amount = ElectionContractConstants.LockTokenForElection,
        Memo = "Sponsor emergency withdrawal."
    });
    
    // Clean up state
    candidateInfo.IsCurrentCandidate = false;
    State.CandidateInformationMap[pubkey.Value] = candidateInfo;
    // ... additional cleanup
}
```

**Option 3 - Co-signature Requirement:**
Modify `QuitElection()` to require both admin AND sponsor signatures when they differ.

**Invariant Check to Add:**
- Assert that if admin ≠ sponsor, explicit acknowledgment is required via separate confirmation transaction
- Document the trust assumption clearly in comments and external documentation

**Test Cases to Add:**
1. Test `AnnounceElectionFor` with admin ≠ sponsor
2. Test that sponsor cannot directly call `QuitElection`
3. Test emergency withdrawal mechanism after timelock
4. Test admin quits and sponsor receives funds correctly
5. Negative test: verify sponsor cannot withdraw before timelock

### Proof of Concept

**Initial State:**
- Alice has 200,000 ELF balance
- Bob's address exists but may be unresponsive/malicious
- Candidate public key = "04abc...def"

**Attack/Scenario Steps:**

1. **Alice calls AnnounceElectionFor:**
```
Input: {
    Pubkey: "04abc...def",
    Admin: Bob's Address  // Different from Alice
}
Sender: Alice
```

2. **State After Transaction:**
    - `State.CandidateSponsorMap["04abc...def"] = Alice`
    - `State.CandidateAdmins["04abc...def"] = Bob`
    - Alice's balance: 100,000 ELF (locked 100,000)
    - Tokens locked at virtual address derived from transaction hash

3. **Alice Attempts to Quit (to recover funds):**
```
QuitElection("04abc...def")
Sender: Alice
```
**Result:** Transaction fails with "Only admin can quit election." assertion

4. **Bob Is Unresponsive/Malicious:**
    - Bob never calls `QuitElection()`
    - OR Bob demands payment from Alice to call it
    - OR Bob's account is compromised/lost

5. **Final State:**
    - Alice's 100,000 ELF remains locked indefinitely
    - No expiration, no recovery mechanism
    - Alice has permanently lost access to her funds

**Expected vs Actual:**
- **Expected:** Sponsor should have recovery mechanism or admin must equal sponsor
- **Actual:** Sponsor funds locked with no recovery path when admin ≠ sponsor

**Success Condition for Exploit:** Alice specifies Bob as admin → Alice loses control of 100,000 ELF → Funds locked permanently if Bob doesn't cooperate.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L242-249)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** protobuf/election_contract.proto (L519-522)
```text
message AnnounceElectionForInput {
    string pubkey = 1;
    aelf.Address admin = 2;
}
```

**File:** test/AElf.Contracts.Election.Tests/BVT/SponsorTests.cs (L24-29)
```csharp
        var candidateAdmin = Address.FromPublicKey(candidatesKeyPair.PublicKey);
        await electionStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
        {
            Admin = candidateAdmin,
            Pubkey = candidatesKeyPair.PublicKey.ToHex()
        });
```
