### Title
Missing Signature Verification Allows Miner Order Manipulation in Next Round

### Summary
The `ApplyNormalConsensusData` function derives a miner's order for the next round from a signature value without verifying that the signature is correctly computed. Malicious miners can provide arbitrary signature values to manipulate their mining order, breaking the cryptographic randomness of the consensus mechanism and allowing strategic positioning in the mining schedule.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:**
The signature value used to derive mining order is never verified during validation. When a miner produces a block, they should compute the signature as: [2](#0-1) 

This signature is deterministically calculated from the previous round's state: [3](#0-2) 

However, the validation flow never recomputes this signature to verify correctness. The `UpdateValueValidationProvider` only checks that the signature field is non-empty: [4](#0-3) 

And that the PreviousInValue matches the committed value: [5](#0-4) 

But it never verifies: `CalculateSignature(PreviousInValue) == providedSignature`

When the UpdateValue transaction executes, it directly assigns the unverified signature: [6](#0-5) 

**Why Existing Protections Fail:**
While the block signature itself is cryptographically verified and `AEDPoSExtraDataExtractor` verifies SenderPubkey matches SignerPubkey [7](#0-6) , this only proves the block was produced by an authorized miner. It does NOT verify that the consensus signature value used for order derivation is correctly computed.

### Impact Explanation

**Consensus Integrity Compromise:**
A malicious miner can choose their mining position in the next round by manipulating the signature value. Since order is derived as `GetAbsModulus(signature.ToInt64(), minersCount) + 1`, the miner can compute which signature values yield favorable orders (e.g., mining earlier to collect more fees, or at specific times to exploit other conditions).

**Randomness Pollution:**
The false signature becomes part of the round state and is used by `CalculateSignature` in subsequent rounds: [8](#0-7) 

This pollutes the randomness pool, affecting mining order calculations for future rounds and potentially benefiting the attacker across multiple rounds.

**Fairness Violation:**
The consensus mechanism relies on deterministic but unpredictable order assignment. By manipulating their order, miners gain unfair advantages in transaction fee collection, MEV opportunities, and strategic block production timing.

**Severity:** Critical - breaks a core consensus invariant (miner schedule integrity) with direct economic impact and zero detection.

### Likelihood Explanation

**Attacker Capabilities:**
Any authorized miner in the consensus set can execute this attack. No special privileges beyond normal mining rights are required.

**Attack Complexity:**
Low. The attacker simply modifies their node's consensus extra data generation to:
1. Compute correct PreviousInValue (passes hash validation)
2. Try different signature values to find favorable orders
3. Include chosen signature in consensus extra data

**Feasibility:**
The attack is immediately executable. The miner controls the consensus extra data generation process on their node before block production: [9](#0-8) 

**Detection Constraints:**
The manipulated signature appears valid (non-null, correct format). Without independent recomputation, other nodes cannot detect the manipulation. The attack leaves no trace in validation failures.

**Economic Rationality:**
Zero additional cost beyond normal block production. The attacker gains strategic mining position advantages with no risk of detection or penalty.

### Recommendation

**Code-Level Mitigation:**
Add signature verification to `UpdateValueValidationProvider.ValidateHeaderInformation`:

```csharp
private bool ValidateSignature(ConsensusValidationContext validationContext)
{
    var publicKey = validationContext.SenderPubkey;
    var providedSignature = validationContext.ProvidedRound.RealTimeMinersInformation[publicKey].Signature;
    var previousInValue = validationContext.ProvidedRound.RealTimeMinersInformation[publicKey].PreviousInValue;
    
    if (previousInValue == null || previousInValue == Hash.Empty)
        return true; // Handle edge cases consistently with current logic
    
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
    return providedSignature == expectedSignature;
}
```

Call this in `ValidateHeaderInformation` after existing checks: [10](#0-9) 

**Invariant to Enforce:**
`Signature == previousRound.CalculateSignature(PreviousInValue)` must hold for all UpdateValue consensus data.

**Test Cases:**
1. Test that UpdateValue with incorrect signature is rejected
2. Test that order cannot be manipulated by changing signature
3. Test edge cases (first round, missed previous round) maintain signature verification

### Proof of Concept

**Initial State:**
- Attacker is an authorized miner in the current round
- Previous round has completed with miner's committed OutValue

**Attack Steps:**

1. **Normal Flow:** Attacker should compute:
   ```
   correctSignature = previousRound.CalculateSignature(previousInValue)
   correctOrder = GetAbsModulus(correctSignature.ToInt64(), minersCount) + 1
   ```

2. **Attack:** Instead, attacker:
   - Computes multiple signature candidates
   - Finds `maliciousSignature` where `GetAbsModulus(maliciousSignature.ToInt64(), minersCount) + 1` yields desired order (e.g., 1 for first position)
   - Generates consensus extra data with `maliciousSignature` instead of `correctSignature`
   - Produces and signs block normally

3. **Validation:** Other nodes:
   - Verify block signature (passes - block properly signed)
   - Check SenderPubkey == SignerPubkey (passes)
   - Check Hash(PreviousInValue) == PreviousOutValue (passes)
   - Check Signature is non-null (passes)
   - **Missing check:** Verify signature computation (NOT PERFORMED)

4. **Result:** 
   - UpdateValue transaction executes, storing malicious signature
   - Attacker gets chosen order in next round
   - Expected: Order should be deterministic based on correct signature
   - Actual: Order is manipulated by attacker's chosen signature

**Success Condition:**
Attacker's `FinalOrderOfNextRound` equals their chosen value instead of the deterministically computed value, with no validation failure.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L48-48)
```csharp
        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-247)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L32-32)
```csharp
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
```
