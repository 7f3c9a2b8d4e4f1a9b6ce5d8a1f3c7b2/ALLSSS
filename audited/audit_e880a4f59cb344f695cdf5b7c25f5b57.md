### Title
Permanent DOS of Configuration Contract Due to Hard Dependency on Parliament Contract Initialization

### Summary
The Configuration contract uses lazy initialization to set its ConfigurationController by calling the Parliament contract's `GetDefaultOrganizationAddress` method. If the Parliament contract is destroyed or unavailable when ConfigurationController is first accessed, all configuration operations fail permanently with no recovery mechanism, even for the privileged Zero contract.

### Finding Description

The Configuration contract stores a reference to the Parliament contract in its state: [1](#0-0) 

The contract uses lazy initialization for the ConfigurationController. When `State.ConfigurationController.Value` is null, the `GetDefaultConfigurationController()` method is invoked to initialize it: [2](#0-1) 

This initialization occurs in both authorization methods before any permission checks: [3](#0-2) 

Critically, the Configuration contract has **no explicit initialization method** during deployment: [4](#0-3) 

When `State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty())` is invoked on line 17 of ConfigurationContract_Helper.cs, if the Parliament contract is unavailable or destroyed, the `.Call()` method throws a `ContractCallException`: [5](#0-4) 

**Root Cause**: The initialization check runs BEFORE the Zero contract bypass permission check on lines 40-42 of ConfigurationContract_Helper.cs. Even though `SetConfiguration` allows the Zero contract to bypass normal permissions, it cannot bypass the ConfigurationController initialization that fails when Parliament is unavailable.

**Why Existing Protections Fail**: 
- No try-catch error handling around Parliament contract calls
- No fallback mechanism if Parliament is unavailable
- No alternative initialization path
- Zero contract privilege applies only AFTER successful initialization

### Impact Explanation

**Complete Configuration System DOS**: All configuration operations become permanently unusable:
- `SetConfiguration`: Cannot set any system configuration parameters (e.g., BlockTransactionLimit)
- `ChangeConfigurationController`: Cannot change the controller to recover
- `GetConfigurationController`: Cannot query controller information

**System-Wide Critical Impact**: The Configuration contract manages critical blockchain parameters. Its failure affects:
- Block transaction limits
- Method fee configurations
- Other system-wide settings essential for chain operation

**No Recovery Path**: Once in this state:
1. Cannot call `SetConfiguration` (even Zero contract blocked by initialization failure)
2. Cannot call `ChangeConfigurationController` (also blocked by same initialization)
3. ConfigurationController.Value remains null permanently
4. Requires contract upgrade/migration to recover

**Affected Parties**: All chain participants lose access to configuration management capabilities. The Zero contract, despite having special privileges for governance-free configuration updates, is also completely blocked.

### Likelihood Explanation

**Preconditions Required**:
1. Configuration contract deployed with ConfigurationController.Value = null (guaranteed on fresh deployment due to no initialization method)
2. Parliament contract becomes unavailable (destroyed, undeployed, or returning errors)

**Feasibility Conditions**:
- **Deployment Ordering Issues**: Most likely during initial chain setup or upgrades where Configuration is deployed before Parliament, or Parliament deployment fails
- **Parliament Contract Bugs**: Contract bugs that cause Parliament to become non-functional
- **Upgrade Scenarios**: Improper contract upgrade sequences that temporarily or permanently break Parliament

**Attack Complexity**: LOW - Does not require attacker action if conditions arise naturally during deployment/upgrade. If Parliament has governance vulnerabilities allowing self-destruction, this becomes an attack vector.

**Economic Rationality**: Not applicable - this is primarily an operational/deployment risk, though could be exploited if Parliament governance is compromised.

**Detection**: Immediately apparent on first attempt to use any Configuration contract method when ConfigurationController is uninitialized.

**Likelihood Assessment**: MEDIUM - While Parliament destruction is unlikely in normal operations, deployment/upgrade sequencing issues or contract bugs make this scenario realistic enough to warrant HIGH severity given the critical impact.

### Recommendation

**Immediate Mitigation**: Implement explicit initialization method with error handling:

```csharp
public override Empty Initialize(Empty input)
{
    Assert(!State.Initialized.Value, "Already initialized.");
    
    try 
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value = 
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
        
        var defaultController = new AuthorityInfo
        {
            ContractAddress = State.ParliamentContract.Value,
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty())
        };
        State.ConfigurationController.Value = defaultController;
    }
    catch
    {
        // Fallback: Set Zero contract as controller if Parliament unavailable
        State.ConfigurationController.Value = new AuthorityInfo
        {
            ContractAddress = Context.GetZeroSmartContractAddress(),
            OwnerAddress = Context.GetZeroSmartContractAddress()
        };
    }
    
    State.Initialized.Value = true;
    return new Empty();
}
```

**Additional Safeguards**:
1. Add try-catch around Parliament calls with Zero contract fallback
2. Allow Zero contract to force-reset ConfigurationController
3. Add validation in deployment scripts to ensure Parliament is deployed first
4. Update ConfigurationContractInitializationProvider to return the Initialize method

**Test Cases**:
- Deploy Configuration before Parliament and verify graceful fallback
- Simulate Parliament contract failure and verify Zero contract can recover
- Test initialization with valid and invalid Parliament contract addresses

### Proof of Concept

**Initial State**:
1. Fresh AElf chain deployment
2. Configuration contract deployed with no initialization
3. Parliament contract not deployed OR destroyed/unavailable
4. `State.ConfigurationController.Value == null`

**Exploitation Steps**:

**Step 1**: Zero contract attempts to call `SetConfiguration`:
```
SetConfiguration({
    Key: "BlockTransactionLimit",
    Value: ByteString(100)
})
```

**Step 2**: Execution flow:
- `SetConfiguration` invokes `AssertPerformedByConfigurationControllerOrZeroContract()` (line 12)
- Check finds `State.ConfigurationController.Value == null` (line 34)
- Calls `GetDefaultConfigurationController()` (line 36)
- Attempts `State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty())` (line 17)
- Parliament contract unavailable â†’ `Call()` throws `ContractCallException`
- Transaction fails with error

**Step 3**: Attempt to recover via `ChangeConfigurationController`:
```
ChangeConfigurationController({
    ContractAddress: <some-valid-contract>,
    OwnerAddress: <some-valid-address>
})
```

**Step 4**: Execution flow:
- Same initialization check runs (lines 23-27)
- Same Parliament call fails
- Transaction fails again

**Expected Result**: Configuration operations should succeed or have fallback mechanism

**Actual Result**: ALL configuration operations fail indefinitely with `ContractCallException`. No recovery possible without contract upgrade.

**Success Condition**: Transaction status = `TransactionResultStatus.Failed` with error message from `ContractCallException` indicating Parliament contract call failure. Configuration contract becomes permanently unusable.

### Citations

**File:** contract/AElf.Contracts.Configuration/ConfigurationReferenceState.cs (L8-8)
```csharp
    internal ParliamentContractContainer.ParliamentContractReferenceState ParliamentContract { get; set; }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_Helper.cs (L8-19)
```csharp
    private AuthorityInfo GetDefaultConfigurationController()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        return new AuthorityInfo
        {
            ContractAddress = State.ParliamentContract.Value,
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty())
        };
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_Helper.cs (L32-38)
```csharp
    private void AssertPerformedByConfigurationControllerOrZeroContract()
    {
        if (State.ConfigurationController.Value == null)
        {
            var defaultConfigurationController = GetDefaultConfigurationController();
            State.ConfigurationController.Value = defaultConfigurationController;
        }
```

**File:** src/AElf.Kernel.Configuration/ConfigurationContractInitializationProvider.cs (L13-16)
```csharp
    public List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        return new List<ContractInitializationMethodCall>();
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L221-221)
```csharp
        if (!trace.IsSuccessful()) throw new ContractCallException(trace.Error);
```
