# Audit Report

## Title
Last Miner InValue Grinding Attack - Mining Order Manipulation

## Summary
The `UpdateValueValidationProvider` in the AEDPoS consensus mechanism fails to enforce unbiased `InValue` commitment, allowing the last miner in each round to grind their current `InValue` to manipulate mining order in subsequent rounds. This violates the consensus mechanism's fundamental randomness guarantee.

## Finding Description

The AEDPoS consensus uses a commit-reveal scheme where miners commit `OutValue = hash(InValue)` in round N and reveal `InValue` in round N+1. The revealed `InValue` is XORed with all signatures from the previous round to calculate the miner's signature for the current round, which determines their mining order in the next round. [1](#0-0) 

The mining order is calculated using modulo arithmetic on the signature: [2](#0-1) 

**Root Cause:** The validation only verifies backward consistency (that the revealed `PreviousInValue` hashes to the previously committed `PreviousOutValue`): [3](#0-2) 

There is NO validation of the randomness or unbiased generation of the CURRENT `InValue` being committed. The contract cannot enforce how the `InValue` was generated - it only checks hash consistency.

**Attack Execution:**
When a miner is last in round N:
1. All K-1 other miners have already published their signatures for round N on-chain
2. The attacker calculates their own signature for round N (deterministic from their `PreviousInValue_{N-1}`)
3. The attacker now knows ALL K signatures for round N
4. The attacker tries different `InValue_N` candidates offline
5. For each candidate: `Signature_{N+1} = XOR(InValue_N, all_round_N_signatures)`
6. Calculate `order_{N+2} = (Signature_{N+1}.ToInt64() % K) + 1`
7. Select `InValue_N` that produces the most favorable order (e.g., order 1)
8. Publish `OutValue_N = Hash(chosen_InValue_N)`

The signature calculation occurs when generating consensus extra data: [4](#0-3) 

## Impact Explanation

**Consensus Integrity Violation:** This breaks the fundamental randomness guarantee documented in the consensus protocol: [5](#0-4) 

The assumption that "no node can know all other nodes' inputs in a specific round" is violated - the last miner DOES know all other inputs before committing their own value.

**Concrete Harm:**
- The last miner systematically obtains better mining positions (e.g., order 1) more frequently than probability would allow
- Better positions mean more block production opportunities and higher mining rewards
- Over many rounds, this advantage compounds significantly
- Honest miners following the protocol are disadvantaged
- The network's decentralization is compromised as the attacking miner gains disproportionate influence
- Block reward distribution becomes unfairly skewed

**Severity:** Medium - Requires being last in order (1/K probability per round), but the attack is cheap to execute, hard to detect, and accumulates advantage over time. While it doesn't directly steal funds, it manipulates a critical consensus invariant.

## Likelihood Explanation

**High Likelihood:**
- Any elected miner can execute this attack when they mine last in their round order
- Occurs with probability 1/K per round for each miner (where K is the number of miners)
- Computational cost is minimal (just hash calculations offline)
- No complex timing requirements or coordination needed
- Can be trivially automated in mining software
- Detection is extremely difficult since the chosen `InValue` appears as random as any other value
- Validation only checks hash consistency, not generation method or randomness
- Statistical analysis would require extensive data and is inconclusive

The attack is straightforward and practical for any technically capable miner.

## Recommendation

Implement verifiable randomness for `InValue` generation using one of these approaches:

1. **Commit to InValue Earlier:** Require miners to commit their `InValue` for round N+1 before they can observe all signatures from round N. This could use a two-phase commit where:
   - Phase 1 (round N-1): Commit `OutValue_N`
   - Phase 2 (round N): Reveal `InValue_N` and commit `OutValue_{N+1}`
   - This ensures the commitment happens before complete information is available

2. **VRF-based InValue:** Use the existing VRF (Verifiable Random Function) mechanism more extensively. Require the `InValue` to be the output of a VRF computation on the previous round's information, making it verifiable and deterministic but unpredictable until revealed.

3. **Collective Randomness:** Use threshold signatures or distributed randomness protocols where the `InValue` is the result of aggregating contributions from multiple miners, making it impossible for any single miner to control.

4. **Delayed Order Calculation:** Calculate mining order for round N+2 using signatures from round N-1 instead of round N, reducing the information advantage of the last miner.

The fix should ensure that when a miner commits their `OutValue`, they cannot yet know enough information to grind for favorable outcomes.

## Proof of Concept

The vulnerability can be demonstrated by simulating the following scenario:

```csharp
// Proof of Concept (conceptual - requires integration testing)
public void TestInValueGrinding()
{
    // Setup: 5 miners in a round
    int minersCount = 5;
    
    // Simulate round N where attacker is last miner (order 5)
    // First 4 miners have already published their signatures
    Hash sig1 = HashHelper.ComputeFrom("sig1");
    Hash sig2 = HashHelper.ComputeFrom("sig2");
    Hash sig3 = HashHelper.ComputeFrom("sig3");
    Hash sig4 = HashHelper.ComputeFrom("sig4");
    
    // Attacker calculates accumulated XOR
    Hash accumulatedSigs = HashHelper.XorAndCompute(
        HashHelper.XorAndCompute(
            HashHelper.XorAndCompute(sig1, sig2), 
            sig3
        ), 
        sig4
    );
    
    // Attacker grinds InValue to find favorable order
    int targetOrder = 1; // Want to be first in round N+2
    for (int nonce = 0; nonce < 1000000; nonce++)
    {
        Hash candidateInValue = HashHelper.ComputeFrom($"invalue_{nonce}");
        
        // Calculate what signature this would produce in round N+1
        Hash attackerSigN = HashHelper.ComputeFrom("attacker_prev_in"); // Their sig for round N
        Hash allSigsN = HashHelper.XorAndCompute(accumulatedSigs, attackerSigN);
        Hash signatureNPlus1 = HashHelper.XorAndCompute(candidateInValue, allSigsN);
        
        // Calculate order in round N+2
        long sigNum = signatureNPlus1.ToInt64();
        int orderNPlus2 = (int)Math.Abs(sigNum % minersCount) + 1;
        
        if (orderNPlus2 == targetOrder)
        {
            // Found favorable InValue!
            // Attacker commits: OutValue = Hash(candidateInValue)
            Hash outValue = HashHelper.ComputeFrom(candidateInValue);
            
            // This passes validation since it's just a hash
            Assert.True(HashHelper.ComputeFrom(candidateInValue) == outValue);
            
            // Attacker will have order 1 in round N+2
            Assert.Equal(targetOrder, orderNPlus2);
            return; // Attack successful
        }
    }
    
    Assert.True(false, "Should have found favorable InValue");
}
```

This demonstrates that an attacker with knowledge of all other signatures can iterate through `InValue` candidates until finding one that produces their desired mining order, and this value passes all existing validations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L72-92)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound) && !IsFirstRoundOfCurrentTerm(out _))
        {
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** docs-sphinx/protocol/consensus.md (L75-76)
```markdown
So it can only be calculated after the previous round **(t-1)** completed. Moreover, as it needs all the signatures from the previous round and the **in** value is input by each node independently, there is no way to control the ordering. The extra block generation is used to increase the randomness. In general, we create a random system that relies on extra inputs from outside. Based on the assumption that no node can know all other nodesâ€™ inputs in a specific round, no one node could control the ordering.

```
