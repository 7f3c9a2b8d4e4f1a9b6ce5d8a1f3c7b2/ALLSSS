# Audit Report

## Title
Division by Zero in Consensus Miner Count Calculation Due to Insufficient MinerIncreaseInterval Validation

## Summary
The `SetMinerIncreaseInterval()` function contains a backwards validation check that only enforces an upper bound, allowing the `MinerIncreaseInterval` to be set to zero or negative values through Parliament governance. This causes deterministic `DivideByZeroException` in critical consensus operations during round processing and term transitions, resulting in complete and irreversible blockchain halt.

## Finding Description

The root cause is an inverted validation assertion in `SetMinerIncreaseInterval()` [1](#0-0) 

The assertion only checks that the new value is less than or equal to the current value (`input.Value <= State.MinerIncreaseInterval.Value`), which allows indefinite decrease including to zero or negative values, but provides no lower bound protection.

The `MinerIncreaseInterval` is initialized with a default value of 31,536,000 seconds (1 year) [2](#0-1) 

Once set to zero, the value is used as a divisor in two critical locations:

**Location 1 - Internal consensus calculation:** [3](#0-2) 

**Location 2 - Miner count determination:** [4](#0-3) 

The `Div()` extension method performs standard C# division which throws `DivideByZeroException` when the divisor is zero [5](#0-4) 

This is confirmed by unit tests [6](#0-5) 

These division operations are called during critical consensus operations:

**During first round processing:** [7](#0-6) 

**During term transitions:** [8](#0-7) 

## Impact Explanation

**Complete Blockchain Halt (Critical DoS)**

When `MinerIncreaseInterval` is set to zero, the blockchain becomes completely non-functional:

1. **Consensus Operations Fail**: All round processing and term transitions throw `DivideByZeroException`, preventing block production
2. **No Recovery Mechanism**: Once set to zero, the value cannot be increased back due to the backwards validation check - any attempt to increase fails the assertion
3. **Permanent Failed State**: The blockchain enters an unrecoverable state requiring hard fork or chain restart with state rollback
4. **Network-Wide Impact**: All nodes are affected simultaneously, all users lose access, all transactions stop

The severity is **CRITICAL** because:
- Consensus systems require zero tolerance for availability failures
- Complete operational disruption of the entire blockchain
- No automatic or governance-based recovery path exists
- Affects all network participants immediately and permanently

## Likelihood Explanation

**Medium Likelihood**

**Required Capabilities:**
- Ability to create and pass a Parliament governance proposal [9](#0-8) 

**Attack Complexity: Low**
1. Create Parliament proposal calling `SetMinerIncreaseInterval(0)`
2. Obtain sufficient votes for approval through legitimate governance process
3. Execute the approved proposal
4. Wait for next automatic consensus operation (happens during normal block production)

**Feasibility Factors:**
- Can occur through malicious governance proposal with sufficient support
- Can occur accidentally through misconfiguration by well-intentioned governance actors
- Can occur through social engineering of governance participants
- No technical complexity barriers exist

**Evidence of Validation Failure:**
Existing tests demonstrate the one-way validation [10](#0-9) 

The test shows that attempting to increase the value fails (lines 121-132), while decreasing succeeds (lines 134-144), but never validates against zero as a lower bound.

## Recommendation

Add a lower bound validation to prevent zero and negative values in `SetMinerIncreaseInterval()`:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Miner increase interval must be positive.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

Alternatively, consider allowing bidirectional changes with proper bounds:

```csharp
Assert(input.Value > 0, "Miner increase interval must be positive.");
// Remove the backwards-only check to allow increases when needed
```

## Proof of Concept

```csharp
[Fact]
public async Task SetMinerIncreaseIntervalToZero_CausesConsensusHalt()
{
    // Initialize contracts
    InitialContracts();
    await BlockMiningService.MineBlockToNextTermAsync();
    InitialAcs3Stubs();
    await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput());
    
    var defaultOrganizationAddress = 
        await ParliamentStubs.First().GetDefaultOrganizationAddress.CallAsync(new Empty());
    
    // Set MinerIncreaseInterval to zero through Parliament proposal
    await ParliamentReachAnAgreementAsync(new CreateProposalInput
    {
        ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
        Params = new Int64Value { Value = 0 }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        OrganizationAddress = defaultOrganizationAddress
    });
    
    // Verify value was set to zero
    var interval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
    interval.Value.ShouldBe(0);
    
    // Trigger consensus operation that uses GetMinersCount
    // This will throw DivideByZeroException and halt the blockchain
    Should.Throw<DivideByZeroException>(() => 
    {
        ConsensusStub.GetMaximumMinersCount.CallAsync(new Empty()).Wait();
    });
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L31-43)
```csharp
    private void RequiredMaximumMinersCountControllerSet()
    {
        if (State.MaximumMinersCountController.Value != null) return;
        EnsureParliamentContractAddressSet();

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MaximumMinersCountController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L22-31)
```csharp
    public override Empty InitialAElfConsensusContract(InitialAElfConsensusContractInput input)
    {
        Assert(State.CurrentRoundNumber.Value == 0 && !State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        State.PeriodSeconds.Value = input.IsTermStayOne
            ? int.MaxValue
            : input.PeriodSeconds;

        State.MinerIncreaseInterval.Value = input.MinerIncreaseInterval;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L50-51)
```csharp
        Should.Throw<DivideByZeroException>(() => { number1.Div(0); });
        Should.Throw<DivideByZeroException>(() => { number2.Div(0); });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L126-135)
```csharp
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-60)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L121-146)
```csharp
        var transactionResult = await ParliamentReachAnAgreementWithExceptionAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = minerIncreaseInterval.Value + 1
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        transactionResult.Error.ShouldContain("Invalid interval");
        var newMinerIncreaseInterval = minerIncreaseInterval.Value - 1;
        await ParliamentReachAnAgreementAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = newMinerIncreaseInterval
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
        minerIncreaseInterval.Value.ShouldBe(newMinerIncreaseInterval);
```
