### Title
NextTerm Validation Bypass Allows Outdated Miner Keys After Replacement

### Summary
The `ValidateConsensusAfterExecution` function only validates miner replacements when the round hash differs between header and state. For NextTerm blocks, the state round is set directly from the header input during execution, causing hashes to always match and bypassing the `GetNewestPubkey` replacement check. This allows blocks with outdated miner lists to be accepted even after candidate key replacements have occurred.

### Finding Description

The vulnerability exists in the validation logic at: [1](#0-0) 

The validation only checks for miner replacements when the round hash differs: [2](#0-1) 

For NextTerm blocks, the `ProcessNextTerm` function sets the current round directly from the input without validation: [3](#0-2) 

The NextTerm input comes from consensus extra data generated by calling `GetVictories` at generation time: [4](#0-3) 

**Root Cause:** The validation assumes that if header and state round hashes match, the miner list is valid. However, for NextTerm blocks, the state is updated FROM the header, making this check circular. The validation never verifies that the miners in the NextTerm round match the current election results or that no replacements have occurred since generation.

**Why Protections Fail:**
1. `ValidateBeforeExecution` for NextTerm only validates round termination, not the miner list [5](#0-4) 

2. `RecordCandidateReplacement` only updates the current round, not future rounds in pending blocks [6](#0-5) 

3. `ProcessNextTerm` accepts the input miner list without cross-validating against `GetVictories`

### Impact Explanation

**Consensus Integrity Violation:**
- A new term can start with a miner list containing replaced (potentially compromised) public keys
- If miner A was replaced with A' due to key compromise, the old compromised key A can still produce blocks
- If A' is the legitimate new key holder, they cannot produce blocks (denial of service)
- Breaks the security invariant that replaced miners are immediately removed from consensus

**Affected Parties:**
- The network consensus security is compromised
- Legitimate miner with new key A' loses block production rewards
- Users face consensus instability if compromised key produces invalid blocks

**Severity:** High - Directly violates "miner schedule integrity" critical invariant and allows continued participation of compromised/banned validator keys in consensus.

### Likelihood Explanation

**Attack Scenario:**
1. Block N with NextTerm is generated at time T1, calling `GetVictories()` which returns [A, B, C]
2. Block M (M < N) executes `ReplaceCandidatePubkey(A → A')` due to key compromise
3. During chain reorganization or network delays, Block N is validated after Block M is finalized
4. Validation compares header [A,B,C] vs state [A,B,C] (just set from header), hashes match, replacement check skipped
5. NextTerm activates with miner A instead of A'

**Feasibility:**
- Realistic during chain reorganizations where blocks are revalidated in different chain contexts
- Can occur with network delays where different nodes have different views of finalized state
- No special privileges needed beyond timing the replacement transaction
- The replacement function is legitimately called by candidate admins for valid security reasons [7](#0-6) 

**Attack Complexity:** Medium - requires timing coordination but exploits normal protocol operations.

### Recommendation

**1. Add Miner List Validation in ProcessNextTerm:**
Before line 190 in `AEDPoSContract_ProcessConsensusInformation.cs`, add validation:
```csharp
// Validate miner list against current election results
var currentVictories = State.ElectionContract.GetVictories.Call(new Empty());
var expectedMiners = new HashSet<string>(currentVictories.Value.Select(v => v.ToHex()));
foreach (var minerPubkey in nextRound.RealTimeMinersInformation.Keys)
{
    var newestPubkey = State.ElectionContract.GetNewestPubkey.Call(
        new StringValue { Value = minerPubkey }).Value;
    Assert(expectedMiners.Contains(newestPubkey), 
        $"Miner {minerPubkey} is outdated or not in victory list. Newest: {newestPubkey}");
}
```

**2. Always Check Replacements in ValidateConsensusAfterExecution:**
Modify the validation logic to check for replacements regardless of hash match for NextTerm behavior:
```csharp
if (headerInformation.Behaviour == AElfConsensusBehaviour.NextTerm)
{
    // For NextTerm, always validate against Election contract
    foreach (var miner in headerInformation.Round.RealTimeMinersInformation.Keys)
    {
        var newest = State.ElectionContract.GetNewestPubkey.Call(
            new StringValue { Value = miner }).Value;
        Assert(newest == miner, $"Miner {miner} has been replaced by {newest}");
    }
}
```

**3. Test Cases:**
- Test NextTerm validation after mid-term replacement
- Test chain reorganization with replacement in alternate chain
- Test concurrent replacement and NextTerm transactions

### Proof of Concept

**Initial State:**
- Current term has miners [X, Y, Z]
- Election has candidates A, B, C with most votes
- `GetVictories()` returns [A, B, C]

**Attack Sequence:**

1. **T1 - Generate NextTerm Block:**
   - Miner X generates Block N (height H+1) with NextTerm
   - Calls `GetConsensusExtraData` → `GenerateFirstRoundOfNextTerm` → `GetVictories()` → returns [A, B, C]
   - Block N header contains round with miners [A, B, C]

2. **T2 - Execute Replacement:**
   - Block M (height H) executes on the canonical chain
   - Transaction: `ReplaceCandidatePubkey(A, A')` (admin replaces due to key compromise)
   - Election contract: Sets `InitialToNewestPubkeyMap[A_initial] = A'` [8](#0-7) 
   - Consensus contract: `RecordCandidateReplacement` returns early (A not in current round yet) [9](#0-8) 

3. **T3 - Validate Outdated Block:**
   - Block N arrives for validation (after Block M is finalized)
   - `ValidateBeforeExecution`: passes (only checks round termination)
   - Execute: `ProcessNextTerm` sets `State.Rounds[newRoundNumber] = round with [A,B,C]`
   - `ValidateAfterExecution`:
     - `currentRound = [A, B, C]` (from state, just set)
     - `headerRound = [A, B, C]` (from header)
     - `GetHash()` comparison: **equal** → replacement check **SKIPPED**
   - Validation passes ✓

**Expected Result:**
- Validation should fail because miner A has been replaced by A'
- `GetNewestPubkey(A)` should be called and return A'
- Assert should trigger: "Incorrect replacement information"

**Actual Result:**
- Validation passes because hash comparison short-circuits the replacement check
- New term starts with compromised key A instead of legitimate key A'
- Security invariant violated ✗

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-124)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-146)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L280-291)
```csharp
    private void PerformReplacement(string oldPubkey, string newPubkey)
    {
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;
```
