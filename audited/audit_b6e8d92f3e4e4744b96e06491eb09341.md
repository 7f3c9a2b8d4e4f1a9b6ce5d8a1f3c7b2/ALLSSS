### Title
Missing Input Validation Allows Zero or Negative Lock Periods, Enabling Immediate Token Withdrawal

### Summary
The `CreateScheme()` function in TokenHolderContract lacks validation for the `MinimumLockMinutes` parameter, allowing it to be set to zero or negative values. This completely bypasses the token lock mechanism, enabling users to withdraw tokens immediately after registration, defeating the core purpose of incentivizing long-term token holding for profit distribution.

### Finding Description

The vulnerability exists in the `CreateScheme()` function where `input.MinimumLockMinutes` is accepted without any validation: [1](#0-0) 

The `MinimumLockMinutes` parameter is defined as `int64` in the protobuf schema, which permits negative values: [2](#0-1) 

The lock period enforcement occurs in the `Withdraw()` function using a timestamp comparison: [3](#0-2) 

The `AddMinutes()` extension method does not validate its input and simply performs arithmetic: [4](#0-3) 

**Root Cause**: No bounds checking or validation on `MinimumLockMinutes` in `CreateScheme()`, allowing:
- Zero value: Makes `State.LockTimestamp[lockId].AddMinutes(0)` equal to the lock timestamp, allowing withdrawal in the next block
- Negative value: Makes the unlock time earlier than the lock time, allowing immediate withdrawal

**Why Protections Fail**: The assertion in `Withdraw()` compares against a computed timestamp that can be manipulated at scheme creation time. No validation prevents scheme creators from setting exploitable lock periods.

### Impact Explanation

**Direct Impact on Token Lock Mechanism:**
- Users can bypass the entire lock period by creating schemes with `MinimumLockMinutes = 0` or negative values
- Tokens can be withdrawn immediately after registration, defeating the purpose of requiring locked token commitment
- Dividend distribution systems that rely on time-locked tokens for economic alignment are compromised

**Affected Parties:**
- Profit distribution schemes expecting long-term token commitment
- Side chain consensus systems using TokenHolder for validator incentives (if misconfigured)
- Any protocol relying on TokenHolder's time-lock guarantees for economic security

**Severity Justification (High):**
- Complete bypass of a critical security mechanism (lock period)
- Undermines economic incentive alignment in profit distribution
- Enables gaming of dividend systems without actual token commitment
- Can affect production systems if period calculations result in zero or schemes are misconfigured

The existing test suite inadvertently demonstrates this vulnerability by successfully withdrawing from a scheme with no specified lock period (defaulting to 0): [5](#0-4) 

### Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to call public contract methods (any account)
- No special privileges or permissions needed
- Can create their own scheme as manager via `CreateScheme()`

**Attack Complexity:**
- Trivial: Single function call with zero or negative parameter value
- No complex state manipulation or timing requirements
- Exploitable immediately upon scheme creation

**Feasibility Conditions:**
- Always feasible - `CreateScheme()` is a public method without access control
- Anyone can create schemes with arbitrary `MinimumLockMinutes` values
- Existing code in production systems (AEDPoS) computes this value dynamically, risking integer division producing zero: [6](#0-5) 

If `periodSeconds < 60`, division results in zero, creating an exploitable scheme.

**Probability Assessment:**
- High likelihood of occurrence through misconfiguration or malicious scheme creation
- No detection mechanisms exist to prevent or alert on zero/negative lock periods
- Economic rationality: Zero cost to set exploitable parameter

### Recommendation

**Immediate Fix - Add Input Validation:**

Add validation in `CreateScheme()` to enforce positive lock periods:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    Assert(input.MinimumLockMinutes > 0, "MinimumLockMinutes must be positive.");
    
    // ... existing code
}
```

**Additional Recommendations:**

1. **Define Minimum Lock Period Constant:**
   - Establish a protocol-wide minimum lock time (e.g., 1 day = 1440 minutes)
   - Prevents extremely short lock periods that provide minimal commitment

2. **Validate in Consensus Contract:**
   - In `AEDPoSContract_SideChainDividendsPool.cs`, ensure `periodSeconds.Div(60)` produces reasonable minimum
   - Add assertion: `Assert(periodSeconds >= 60, "Period too short for token holder scheme")`

3. **Add Invariant Test Cases:**
   - Test that `CreateScheme()` rejects zero and negative `MinimumLockMinutes`
   - Test that schemes with very short lock periods fail validation
   - Test edge case where `periodSeconds < 60` in consensus initialization

### Proof of Concept

**Initial State:**
- Attacker has ELF tokens in their account
- TokenHolder contract is deployed and accessible

**Exploitation Steps:**

1. **Create Exploitable Scheme:**
   ```
   Call: TokenHolderContract.CreateScheme({
       Symbol: "ELF",
       MinimumLockMinutes: 0  // or any negative value
   })
   Result: Scheme created with zero lock period
   ```

2. **Register for Profits:**
   ```
   Call: TokenHolderContract.RegisterForProfits({
       SchemeManager: <attacker_address>,
       Amount: 1000
   })
   Result: 1000 ELF locked, attacker becomes beneficiary
   ```

3. **Immediate Withdrawal:**
   ```
   Call: TokenHolderContract.Withdraw(<attacker_address>)
   Result: SUCCESS - Tokens unlocked immediately
   Expected: FAILURE - "Cannot withdraw" due to lock period
   ```

**Success Condition:**
- Attacker successfully withdraws tokens in the same or next block after registration
- Lock period mechanism is completely bypassed
- Attacker can claim profits while maintaining no long-term token commitment

**Evidence from Test Suite:**
The vulnerability is confirmed by the existing `Withdraw_Test` which creates a scheme without specifying `MinimumLockMinutes` (defaults to 0) and successfully withdraws immediately after registration, demonstrating the exploit path is functional in the current codebase.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** protobuf/token_holder_contract.proto (L63-70)
```text
message CreateTokenHolderProfitSchemeInput {
    // The token symbol.
    string symbol = 1;
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 2;
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 3;
}
```

**File:** src/AElf.CSharp.Core/Extension/TimestampExtensions.cs (L39-42)
```csharp
    public static Timestamp AddMinutes(this Timestamp timestamp, long minutes)
    {
        return timestamp + new Duration { Seconds = minutes.Mul(60) };
    }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L434-459)
```csharp
    public async Task Withdraw_Test()
    {
        var amount = 1000L;
        var nativeTokenSymbol = TokenHolderContractTestConstants.NativeTokenSymbol;
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = nativeTokenSymbol
        });
        await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
        {
            Amount = amount,
            SchemeManager = Starter
        });
        var beforeUnLockBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = nativeTokenSymbol,
            Owner = Starter
        })).Balance;
        await TokenHolderContractStub.Withdraw.SendAsync(Starter);
        var afterUnLockBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = nativeTokenSymbol,
            Owner = Starter
        })).Balance;
        afterUnLockBalance.ShouldBe(beforeUnLockBalance.Add(amount));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L28-32)
```csharp
        State.TokenHolderContract.CreateScheme.Send(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = AEDPoSContractConstants.SideChainShareProfitsTokenSymbol,
            MinimumLockMinutes = periodSeconds.Div(60)
        });
```
