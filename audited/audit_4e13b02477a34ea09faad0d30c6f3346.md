### Title
Token Balance Manipulation Leads to Incorrect Deposit Calculation in EnableConnector

### Summary
The `GetNeededDeposit()` function queries the TokenConverter's current token balance via external calls to determine required deposit amounts. This balance can be manipulated through frontrunning by transferring tokens to the converter before `EnableConnector()` executes, resulting in under-collateralization of the Bancor reserve pool and breaking critical pricing invariants.

### Finding Description [1](#0-0) 

The `GetNeededDeposit()` function calculates the required base token deposit by:
1. Querying external `TokenContract.GetTokenInfo()` for total supply (lines 62-66)
2. Querying external `TokenContract.GetBalance()` for converter's current balance (lines 67-72)
3. Computing `amountOutOfTokenConvert = totalSupply - balance - input.AmountToTokenConvert` (line 73)
4. Using Bancor formula to determine deposit needed for tokens in circulation (lines 81-83) [2](#0-1) 

The `EnableConnector()` function calls `GetNeededDeposit()` at line 276 and directly uses the returned value to set `State.DepositBalance` at line 297. Critically, `EnableConnector()` has **no access control** - any user can call it.

**Root Cause**: The balance query (line 67-72 in GetNeededDeposit) reflects ALL tokens held by the converter at the moment of execution, including tokens that may have been transferred there by attackers or accidentally. Since anyone can transfer tokens to the converter contract address using standard `TokenContract.Transfer()`, this balance can be manipulated before `EnableConnector()` executes.

**Why Existing Protections Fail**: 
- No validation that the converter balance should be zero or a specific expected value
- No protection against multiple parties contributing tokens before enablement
- The calculation blindly trusts the current on-chain state without considering manipulation

### Impact Explanation

**Concrete Harm**:
When an attacker frontruns `EnableConnector()` by donating X resource tokens to the converter:
- `amountOutOfTokenConvert` decreases by X (fewer tokens calculated as "in circulation")
- Required deposit decreases proportionally via Bancor formula
- After enablement, converter holds more resource tokens but less base token deposit than should back them

**Example with Numbers**:
- Resource token total supply: 1000, initial converter balance: 0
- Normal scenario: User enables with 100 tokens, deposit needed = `BancorFormula(10000, 0.5, 1000, 0.5, 900)` = 90,000 ELF
- Attack scenario: Attacker frontruns with 50 token donation, deposit needed = `BancorFormula(10000, 0.5, 1000, 0.5, 850)` ≈ 56,667 ELF
- **Result**: Converter holds 150 tokens backed by only 56,667 ELF instead of proper backing [3](#0-2) 

This breaks the **Bancor reserve ratio invariant** because subsequent Buy/Sell operations use actual balances (line 380-385 for resource tokens, line 378 for deposit balance), creating mispricing:
- Buyers get tokens cheaper than they should
- Sellers receive less base token than they should
- The reserve pool can be depleted before all tokens can be sold back

**Who is Affected**:
- Future token sellers receive unfair prices due to under-collateralized reserve
- Protocol integrity is damaged as Bancor invariants no longer hold
- The legitimate EnableConnector caller may unknowingly enable a misconfigured connector

### Likelihood Explanation

**Attacker Capabilities Required**:
- Ownership of resource tokens (obtainable via token issuance or market purchase)
- Ability to observe pending `EnableConnector()` transactions in mempool
- Ability to submit higher-priority transaction (standard frontrunning)

**Attack Complexity**: Low
- Single transaction: `TokenContract.Transfer(converterAddress, amount)`
- No special permissions required (EnableConnector is public, token transfers are permissionless)
- Execution is straightforward with standard blockchain frontrunning techniques

**Feasibility Conditions**:
- Attack works when connector is being enabled for the first time
- Can also occur accidentally if users transfer tokens to converter before intended enablement
- No on-chain detection mechanism exists

**Economic Rationality**: Medium-Low
The attacker must donate tokens (direct cost) without clear direct profit mechanism. However:
- Could be a griefing attack to damage protocol integrity
- Could occur accidentally (unintentional transfers before EnableConnector)
- Coordinated scenarios where enabler and "attacker" are related parties attempting to game deposit requirements
- The protocol damage is real even if attacker motivation is unclear

**Probability Assessment**: Medium
While direct economic incentive is limited, the vulnerability is technically trivial to exploit and could easily occur through accidental transfers or intentional griefing. The permissionless nature of both token transfers and `EnableConnector()` increases likelihood.

### Recommendation

**Immediate Mitigation**:
Add validation in `GetNeededDeposit()` or `EnableConnector()` to ensure the converter balance matches expected state:

```
// In EnableConnector, before calling GetNeededDeposit:
var currentBalance = State.TokenContract.GetBalance.Call(
    new GetBalanceInput { Owner = Context.Self, Symbol = input.TokenSymbol }).Balance;
Assert(currentBalance == 0 || currentBalance == input.AmountToTokenConvert, 
    "Unexpected token balance in converter - potential manipulation detected");
```

**Alternative Approach**:
Modify `GetNeededDeposit()` to accept expected initial balance as parameter and validate against it:

```
Assert(balance <= expectedInitialBalance, 
    "Converter balance exceeds expected value - potential frontrunning attack");
```

**Additional Hardening**:
- Consider adding access control to `EnableConnector()` requiring controller authorization
- Implement minimum time delay between connector creation and enablement
- Add events logging balance changes to improve monitoring
- Document expected EnableConnector workflow clearly

**Test Cases**:
1. Test that EnableConnector reverts if converter has unexpected non-zero balance
2. Test that frontrun token donations are detected and rejected
3. Test normal flow with expected balance passes validation
4. Fuzz test with various balance manipulation scenarios

### Proof of Concept

**Initial State**:
- Resource token (READ): total supply = 1000, all held by user Alice
- TokenConverter contract: balance = 0 READ
- Deposit connector: virtual balance = 10,000 ELF, weight = 0.5
- Resource connector: weight = 0.5, no virtual balance

**Attack Sequence**:

1. **Alice prepares to enable connector** with 100 READ tokens
   - Expected deposit: `BancorHelper.GetAmountToPayFromReturn(10000, 0.5, 1000, 0.5, 900)` = 90,000 ELF
   - Alice submits `EnableConnector(TokenSymbol: "READ", AmountToTokenConvert: 100)`

2. **Attacker Bob observes transaction in mempool** and frontruns:
   - `TokenContract.Transfer(to: TokenConverterAddress, symbol: "READ", amount: 50)`
   - Transaction executes before Alice's

3. **Alice's EnableConnector executes** with manipulated state:
   - `GetNeededDeposit()` reads balance = 50 (includes Bob's donation)
   - `amountOutOfTokenConvert = 1000 - 50 - 100 = 850`
   - `needDeposit = BancorHelper.GetAmountToPayFromReturn(10000, 0.5, 1000, 0.5, 850)` ≈ 56,667 ELF
   - Alice transfers only 56,667 ELF deposit (instead of 90,000)
   - `State.DepositBalance["(NT)READ"] = 56,667`

**Result**:
- Converter holds 150 READ (50 from Bob + 100 from Alice)
- Deposit balance = 56,667 ELF
- **Expected**: 100 READ backed by 90,000 ELF
- **Actual**: 150 READ backed by 56,667 ELF
- **Under-collateralization**: Missing ~33,333 ELF in reserves

**Verification**:
Query `GetPairConnector("READ")` and verify:
- ResourceConnector balance (via GetBalance) = 150 READ
- DepositConnector balance (via State.DepositBalance) = 56,667 ELF
- Ratio is incorrect for intended Bancor curve parameters

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L56-91)
```csharp
    public override DepositInfo GetNeededDeposit(ToBeConnectedTokenInfo input)
    {
        var toConnector = State.Connectors[input.TokenSymbol];
        Assert(toConnector != null && !toConnector.IsDepositAccount, "[GetNeededDeposit]Can't find to connector.");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[GetNeededDeposit]Can't find from connector.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(
            new GetTokenInfoInput
            {
                Symbol = input.TokenSymbol
            });
        var balance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = input.TokenSymbol
            }).Balance;
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }

        return new DepositInfo
        {
            NeedAmount = needDeposit,
            AmountOutOfTokenConvert = amountOutOfTokenConvert
        };
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```
