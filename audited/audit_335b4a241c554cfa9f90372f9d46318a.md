### Title
Incomplete WritePaths Declaration Enables Race Conditions in Token Transfer Callbacks

### Summary
The `GetResourceInfo` method for `Transfer` and `TransferFrom` operations fails to declare all state modifications that occur during execution, specifically those from cross-contract callbacks invoked via the token's ExternalInfo configuration. [1](#0-0)  When tokens have transfer callbacks configured, parallel transactions can execute simultaneously and modify shared state in callback contracts without proper isolation, violating the parallel execution system's correctness guarantees and causing race conditions.

### Finding Description

**Root Cause:**

The `Transfer` method's execution path includes a call to `DealWithExternalInfoDuringTransfer`, which checks if the token has a `TransferCallbackExternalInfoKey` in its ExternalInfo and invokes a cross-contract callback via `Context.SendInline`. [2](#0-1) [3](#0-2) 

However, the `GetResourceInfo` method only declares WritePaths for:
- Sender and receiver token balances
- Transaction fee balances  
- Delegatee fee balances
- Transaction fee free allowances

It does NOT declare any WritePaths for state that the callback contract may modify. [4](#0-3) 

The same vulnerability exists in `TransferFrom`, which also calls `DealWithExternalInfoDuringTransfer`. [5](#0-4) 

**Why Protections Fail:**

The parallel execution system relies on complete WritePaths declarations to group non-conflicting transactions. [6](#0-5)  When `GetResourceInfo` is called during resource extraction, [7](#0-6)  it has access to contract state (as evidenced by its calls to `GetPrimaryTokenSymbol` and `GetTransactionFeeSymbols` which read from state). [8](#0-7) 

The contract COULD check if a token has a transfer callback configured by reading `State.TokenInfos[symbol].ExternalInfo.Value`, but it does not perform this check. Consequently, transactions that will invoke callbacks are incorrectly grouped for parallel execution.

**Callback Configuration:**

Transfer callbacks are configured using the `TransferCallbackExternalInfoKey` constant. [9](#0-8)  The callback contains a contract address and method name. [10](#0-9) 

### Impact Explanation

**Concrete Harm:**

When multiple Transfer/TransferFrom transactions for tokens with callbacks execute in parallel:

1. Both transactions declare identical WritePaths (sender/receiver balances, fees)
2. The parallel grouper places them in the same execution group
3. Both execute simultaneously and invoke their callbacks
4. The callbacks modify shared state in the callback contract without isolation
5. This creates race conditions leading to:
   - State corruption in callback contracts
   - Incorrect accounting/balances in affected contracts
   - Broken invariants in callback contract logic
   - Non-deterministic execution outcomes

**Severity Justification:**

HIGH severity because:
- Violates fundamental correctness guarantee of parallel execution system
- Can affect any token configured with transfer callbacks
- Results in unpredictable state corruption
- Cannot be detected or prevented by callback contracts
- Undermines the reliability of the entire parallel execution framework

### Likelihood Explanation

**Attack Prerequisites:**

1. A token exists with `TransferCallbackExternalInfoKey` configured in its ExternalInfo (set during token creation)
2. The callback contract has state that is susceptible to race conditions when called concurrently
3. Multiple transfers of that token are submitted in the same block
4. The transactions are grouped for parallel execution (which will occur since WritePaths don't conflict)

**Feasibility:**

- **Entry Points:** `Transfer` and `TransferFrom` are public methods callable by anyone [11](#0-10) [12](#0-11) 
- **Preconditions:** Token creators can configure ExternalInfo during creation; the callback feature is an intentional design
- **Complexity:** Low - simply requires submitting multiple transfers of a callback-enabled token
- **Detection:** Race conditions are inherently difficult to detect and may appear intermittently

**Probability:** MEDIUM-HIGH if callback-enabled tokens are deployed in production; otherwise depends on adoption of the callback feature.

### Recommendation

**Code-Level Mitigation:**

Modify `GetResourceInfo` in the Transfer case to:

1. Parse the `TransferInput` to extract the token symbol
2. Read `State.TokenInfos[symbol]` to retrieve the TokenInfo
3. Check if `tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey)`
4. If a callback is configured, return `new ResourceInfo { NonParallelizable = true }` to prevent parallel execution

Apply the same fix to the `TransferFrom` case.

**Implementation:**

```csharp
case nameof(Transfer):
{
    var args = TransferInput.Parser.ParseFrom(txn.Params);
    var tokenInfo = State.TokenInfos[args.Symbol];
    
    // Check for transfer callback
    if (tokenInfo?.ExternalInfo?.Value != null && 
        tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
    {
        return new ResourceInfo { NonParallelizable = true };
    }
    
    // ... existing resource info declaration
}
```

**Test Cases:**

1. Create a token with TransferCallbackExternalInfoKey configured
2. Submit two concurrent Transfer transactions for that token
3. Verify they execute sequentially (NonParallelizable)
4. Verify callback state remains consistent
5. Test tokens without callbacks still execute in parallel

### Proof of Concept

**Initial State:**
1. Token "CALLBACK" exists with TransferCallbackExternalInfoKey pointing to contract address C and method M
2. Method M in contract C increments a counter state variable each time it's called
3. Alice has 1000 CALLBACK tokens
4. Bob and Charlie each have 0 CALLBACK tokens

**Attack Sequence:**

Transaction 1: Alice transfers 100 CALLBACK to Bob
- Declares WritePaths: [Balance(Alice,CALLBACK), Balance(Bob,CALLBACK), fees]
- Will invoke callback C.M()

Transaction 2: Alice transfers 200 CALLBACK to Charlie  
- Declares WritePaths: [Balance(Alice,CALLBACK), Balance(Charlie,CALLBACK), fees]
- Will invoke callback C.M()

**Expected vs Actual:**

**Expected (Sequential):** Counter = 2 (each callback increments it once)

**Actual (Parallel):** Counter may be 1, 2, or corrupted value depending on interleaving:
- Both read counter value 0
- Both increment to 1
- Both write 1
- Final counter value: 1 (lost update)

**Success Condition:** Demonstrating that the counter ends up with value 1 instead of 2 proves the race condition exists due to improper parallelization of callback-enabled transfers.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L15-38)
```csharp
            case nameof(Transfer):
            {
                var args = TransferInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), txn.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol)
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };

                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L84-96)
```csharp
    private void AddPathForTransactionFee(ResourceInfo resourceInfo, string from, string methodName)
    {
        var symbols = GetTransactionFeeSymbols(methodName);
        var primaryTokenSymbol = GetPrimaryTokenSymbol(new Empty()).Value;
        if (_primaryTokenSymbol != string.Empty && !symbols.Contains(primaryTokenSymbol))
            symbols.Add(primaryTokenSymbol);
        var paths = symbols.Select(symbol => GetPath(nameof(TokenContractState.Balances), from, symbol));
        foreach (var path in paths)
        {
            if (resourceInfo.WritePaths.Contains(path)) continue;
            resourceInfo.WritePaths.Add(path);
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L254-254)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/TransactionGrouper.cs (L115-148)
```csharp
    private List<List<Transaction>> GroupParallelizables(List<TransactionWithResourceInfo> txsWithResources)
    {
        var resourceUnionSet = new Dictionary<int, UnionFindNode>();
        var transactionResourceHandle = new Dictionary<Transaction, int>();
        var groups = new List<List<Transaction>>();
        var readOnlyPaths = txsWithResources.GetReadOnlyPaths();
        foreach (var txWithResource in txsWithResources)
        {
            UnionFindNode first = null;
            var transaction = txWithResource.Transaction;
            var transactionResourceInfo = txWithResource.TransactionResourceInfo;

            // Add resources to disjoint-set, later each resource will be connected to a node id, which will be our group id
            foreach (var resource in transactionResourceInfo.WritePaths.Concat(transactionResourceInfo.ReadPaths)
                         .Where(p => !readOnlyPaths.Contains(p))
                         .Select(p => p.GetHashCode()))
            {
                if (!resourceUnionSet.TryGetValue(resource, out var node))
                {
                    node = new UnionFindNode();
                    resourceUnionSet.Add(resource, node);
                }

                if (first == null)
                {
                    first = node;
                    transactionResourceHandle.Add(transaction, resource);
                }
                else
                {
                    node.Union(first);
                }
            }
        }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/ResourceExtractionService.cs (L127-163)
```csharp
    private async Task<TransactionResourceInfo> GetResourcesForOneAsync(IChainContext chainContext,
        Transaction transaction, CancellationToken ct)
    {
        IExecutive executive = null;
        var address = transaction.To;

        try
        {
            executive = await _smartContractExecutiveService.GetExecutiveAsync(chainContext, address);
            if (!executive.IsParallelizable())
                return new TransactionResourceInfo
                {
                    TransactionId = transaction.GetHash(),
                    ParallelType = ParallelType.NonParallelizable,
                    ContractHash = executive.ContractHash
                };

            var nonparallelContractCode =
                await _nonparallelContractCodeProvider.GetNonparallelContractCodeAsync(chainContext, address);
            if (nonparallelContractCode != null && nonparallelContractCode.CodeHash == executive.ContractHash)
                return new TransactionResourceInfo
                {
                    TransactionId = transaction.GetHash(),
                    ParallelType = ParallelType.NonParallelizable,
                    ContractHash = executive.ContractHash,
                    IsNonparallelContractCode = true
                };

            if (_resourceCache.TryGetValue(transaction.GetHash(), out var resourceCache) &&
                executive.ContractHash == resourceCache.ResourceInfo.ContractHash &&
                resourceCache.ResourceInfo.IsNonparallelContractCode == false)
                return resourceCache.ResourceInfo;

            var txContext = GetTransactionContext(chainContext, transaction.To, transaction.ToByteString());
            var resourceInfo = await executive.GetTransactionResourceInfoAsync(txContext, transaction.GetHash());
            // Try storing in cache here
            return resourceInfo;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-13)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
```

**File:** protobuf/token_contract.proto (L530-533)
```text
message CallbackInfo {
    aelf.Address contract_address = 1;
    string method_name = 2;
}
```
