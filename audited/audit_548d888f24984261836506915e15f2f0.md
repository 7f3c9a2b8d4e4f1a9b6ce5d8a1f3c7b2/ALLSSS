### Title
Double-Counting Vulnerability in RemoveBeneficiary Allows TotalShares to Become Negative via profitDetailId Bypass

### Summary
The `RemoveBeneficiary()` method contains a critical flaw where the `profitDetailId` parameter bypasses the `IsWeightRemoved` flag check, allowing already-removed shares to be subtracted from `TotalShares` multiple times. This causes `TotalShares` to become negative, completely breaking the profit distribution calculation formula and rendering the scheme inoperable.

### Finding Description

**Root Cause:** In `RemoveProfitDetails`, lines 333-338 force-add a profit detail with a matching `profitDetailId` to the removal list without verifying whether it has already been weight-removed. [1](#0-0) 

This bypasses the `!IsWeightRemoved` filter applied at lines 321-324: [2](#0-1) 

**Execution Path:**

1. First `RemoveBeneficiary` call (with `profitDetailId=null`) processes all removable details, marks them as `IsWeightRemoved=true` (line 345), and subtracts their shares from `TotalShares` (line 260): [3](#0-2) [4](#0-3) 

2. The detail remains in `profitDetails.Details` if not completely removed (lines 346-356 may shorten but not remove it): [5](#0-4) 

3. Second `RemoveBeneficiary` call with a specific `profitDetailId` bypasses the filter at line 337, adding the already-weight-removed detail back to `detailsCanBeRemoved`, causing its shares to be subtracted again.

**Why Protections Fail:**

The `SafeMath.Sub()` method for `long` type uses checked arithmetic but only prevents underflow below `long.MinValue`, not negative results within valid range: [6](#0-5) 

The calculation `100 - 200 = -100` is perfectly valid for `long` and won't throw an exception. `TotalShares` is defined as `int64` (maps to `long` in C#): [7](#0-6) 

### Impact Explanation

**Direct Harm:**
When `TotalShares` becomes negative, the profit distribution formula in `SafeCalculateProfits` breaks catastrophically: [8](#0-7) 

The formula `(totalAmount * shares) / totalShares` with negative `totalShares` produces:
- Negative profit amounts for beneficiaries (incorrect withdrawals)
- Division by negative number corrupting all future distributions
- Complete scheme inoperability

**Affected Parties:**
- All beneficiaries in the compromised scheme lose access to legitimate profit claims
- Scheme manager loses ability to distribute profits correctly
- Treasury, TokenHolder, and Election contracts using this scheme are impacted
- Protocol reputation damage from broken economics

**Severity Justification:** Critical - Direct fund loss/lock, complete scheme DOS, breaks core economic invariant that `TotalShares` must equal sum of all beneficiary shares.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be authorized to call `RemoveBeneficiary` (scheme manager or TokenHolder contract)
- Can trigger via TokenHolder withdrawal if they control beneficiary
- Election contract subsidy removal could trigger unintentionally

**Attack Complexity:** Low
1. Add beneficiary with specific `profitDetailId` (e.g., via voting in Election contract)
2. Call `RemoveBeneficiary(beneficiary, schemeId, profitDetailId=null)` 
3. Call `RemoveBeneficiary(beneficiary, schemeId, profitDetailId=X)` immediately after

**Feasibility:** High
- No special state required beyond normal scheme with beneficiaries
- Works on any scheme with `CanRemoveBeneficiaryDirectly=true`
- TokenHolder withdrawals by malicious actors can trigger this
- Even accidental double-calls by integrations cause corruption

**Detection:** Difficult - `TotalShares` is internal state; corruption only detected when distributions fail

### Recommendation

**Code-Level Mitigation:**

Add an `IsWeightRemoved` check before adding the profit detail at line 337:

```csharp
if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
    detailsCanBeRemoved.All(d => d.Id != profitDetailId))
{
    var targetDetail = profitDetails.Details.Single(d => d.Id == profitDetailId);
    // Add check to prevent double-counting
    if (!targetDetail.IsWeightRemoved)
    {
        detailsCanBeRemoved.Add(targetDetail);
    }
}
```

**Invariant Check:**

Add assertion before subtracting from `TotalShares` at line 260:

```csharp
var removedShares = removedDetails.Values.Sum();
Assert(removedShares <= scheme.TotalShares, 
    $"Cannot remove {removedShares} shares exceeding total {scheme.TotalShares}");
State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedShares);
```

**Test Cases:**

1. Test double removal with `profitDetailId`: verify second call doesn't subtract shares again
2. Test `TotalShares` non-negativity invariant after all removal operations
3. Test removal sequence: add→remove(null)→remove(specificId) should not change `TotalShares` twice

### Proof of Concept

**Initial State:**
- Create scheme with `CanRemoveBeneficiaryDirectly=true`, `CurrentPeriod=1`
- Add beneficiary A with `profitDetailId=HashX`, `shares=100`, `endPeriod=10`
- Scheme state: `TotalShares=100`

**Transaction 1: RemoveBeneficiary(A, schemeId, profitDetailId=null)**
- Line 321-322: `detailsCanBeRemoved` includes detail with `shares=100`
- Line 345: Sets `IsWeightRemoved=true` on detail
- Line 358: `removedDetails.TryAdd(1, 100)`
- Line 260: `TotalShares = 100.Sub(100) = 0`
- Result: `TotalShares=0`, detail persists with `IsWeightRemoved=true`

**Transaction 2: RemoveBeneficiary(A, schemeId, profitDetailId=HashX)**
- Line 321-322: `detailsCanBeRemoved=[]` (empty due to `IsWeightRemoved=true` filter)
- Line 334-335: All conditions pass (detail exists, not in empty list)
- Line 337: **VULNERABILITY** - Adds detail to `detailsCanBeRemoved` despite `IsWeightRemoved=true`
- Line 345: Sets `IsWeightRemoved=true` (already true)
- Line 358: `removedDetails.TryAdd(1, 100)` 
- Line 260: `TotalShares = 0.Sub(100) = -100`

**Expected Result:** Transaction 2 should remove 0 shares (already removed)

**Actual Result:** `TotalShares = -100` (negative, scheme broken)

**Success Condition:** `GetScheme(schemeId).TotalShares` returns negative value, profit distribution calls fail with division errors.

### Notes

The vulnerability specifically affects schemes where:
- `CanRemoveBeneficiaryDirectly=true` (allows immediate removal)
- Beneficiaries have `profitDetailId` set (common in Election voting subsidies)
- Multiple `RemoveBeneficiary` calls occur for the same beneficiary

The `TotalShares` field is used in critical profit calculations throughout the system [8](#0-7)  and its corruption breaks the entire profit distribution mechanism for the affected scheme, including nested sub-schemes and all dependent contracts (Treasury, TokenHolder, Election).

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L260-260)
```csharp
        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L333-338)
```csharp
        // remove the profitDetail with the profitDetailId, and de-duplicate it before involving.
        if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
            detailsCanBeRemoved.All(d => d.Id != profitDetailId))
        {
            detailsCanBeRemoved.Add(profitDetails.Details.Single(d => d.Id == profitDetailId));
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L342-345)
```csharp
            foreach (var profitDetail in detailsCanBeRemoved)
            {
                // set remove sign
                profitDetail.IsWeightRemoved = true;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L346-356)
```csharp
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** protobuf/profit_contract.proto (L139-139)
```text
    int64 total_shares = 2;
```
