### Title
Miners Can Force UpdateValue Behaviour to Prevent Round/Term Transitions

### Summary
The AEDPoS consensus contract provides behaviour hints (UpdateValue, NextRound, NextTerm) to miners via `GetConsensusCommand`, but miners can ignore these hints and submit any behaviour they choose. The validation system only checks that data is well-formed for the chosen behaviour, not whether that behaviour is appropriate for the current consensus state. This allows malicious miners to force UpdateValue when NextRound or NextTerm should be used, preventing consensus round advancement and monopolizing block production.

### Finding Description

The consensus command generation system determines the expected behaviour through `ConsensusBehaviourProviderBase.GetConsensusBehaviour()`, which returns UpdateValue when a miner's time slot hasn't passed, or calls `GetConsensusBehaviourToTerminateCurrentRound()` (returning NextRound/NextTerm) when the time slot has passed. [1](#0-0) 

This behaviour is placed in a hint structure returned to the miner: [2](#0-1) 

However, the hint is advisory. When producing a block, miners provide their own behaviour choice in `AElfConsensusTriggerInformation`: [3](#0-2) 

The contract's `GetConsensusBlockExtraData` method simply uses whatever behaviour the miner provides, without validation: [4](#0-3) 

The validation system in `ValidateBeforeExecution` selects different validators based on the provided behaviour, but none check if that behaviour choice is correct: [5](#0-4) 

`UpdateValueValidationProvider` only validates that OutValue and Signature are properly filled: [6](#0-5) 

`RoundTerminateValidationProvider` only validates NextRound/NextTerm data format: [7](#0-6) 

Critically, there is no validator that checks: "If consensus state indicates NextRound/NextTerm should be used, reject UpdateValue". The `TimeSlotValidationProvider` validates timing but not behaviour appropriateness.

### Impact Explanation

**Consensus Integrity Compromise:**
A malicious miner who should terminate a round (as the extra block producer or when their time slot has passed) can instead repeatedly submit UpdateValue transactions. This prevents round advancement and allows them to:

1. **Monopolize Block Production**: Continue producing all blocks while other miners are blocked from mining
2. **Reward Manipulation**: Capture all block rewards that should be distributed across miners in subsequent rounds
3. **Consensus Stalling**: Prevent the consensus mechanism from progressing through rounds, disrupting the entire chain
4. **LIB Calculation Disruption**: Last Irreversible Block height calculation depends on multiple miners' inputs across rounds; monopolization breaks this
5. **Term Transition Prevention**: On main chain, malicious miners can prevent NextTerm transitions, maintaining an outdated miner set and blocking legitimate validator rotation

The impact is severe because it breaks the fundamental invariant that "correct round transitions and time-slot validation, miner schedule integrity" must be maintained at all times.

### Likelihood Explanation

**High Likelihood:**

- **Reachable Entry Point**: Any miner in the active miner set can call the public `UpdateValue` method
- **Feasible Preconditions**: Attacker only needs to be an active miner (via staking/election) with their scheduled time slot
- **Execution Practicality**: The attack is straightforward:
  1. Call `GetConsensusCommand` to receive hint (advisory only)
  2. Create `AElfConsensusTriggerInformation` with UpdateValue behaviour (ignoring hint)
  3. Submit block with UpdateValue consensus data
  4. Validation passes because UpdateValue data is well-formed
  5. Repeat to maintain monopoly

- **Low Attack Cost**: No additional capital beyond existing miner stake required
- **Economic Rationality**: Monopolizing block production is highly profitable through reward accumulation
- **Detection Difficulty**: Appears as normal UpdateValue transactions; distinguishing from legitimate behavior requires analyzing consensus state expectations

The vulnerability exists in production code with no mitigations.

### Recommendation

Add a behaviour validation provider that enforces behaviour appropriateness:

**1. Create `BehaviourCorrectnessValidationProvider`:**

```csharp
public class BehaviourCorrectnessValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var expectedBehaviour = DetermineExpectedBehaviour(validationContext);
        
        if (validationContext.ExtraData.Behaviour != expectedBehaviour)
        {
            return new ValidationResult 
            { 
                Success = false,
                Message = $"Incorrect behaviour. Expected: {expectedBehaviour}, Actual: {validationContext.ExtraData.Behaviour}"
            };
        }
        
        return new ValidationResult { Success = true };
    }
    
    private AElfConsensusBehaviour DetermineExpectedBehaviour(ConsensusValidationContext context)
    {
        // Re-run the same logic used in ConsensusBehaviourProviderBase
        // to determine what behaviour SHOULD be used
    }
}
```

**2. Register in validation pipeline:** [8](#0-7) 

Add the new provider to the basic validation list (before behaviour-specific providers):

```csharp
var validationProviders = new List<IHeaderInformationValidationProvider>
{
    new MiningPermissionValidationProvider(),
    new TimeSlotValidationProvider(),
    new ContinuousBlocksValidationProvider(),
    new BehaviourCorrectnessValidationProvider()  // Add this
};
```

**3. Add test cases:**
- Test that UpdateValue is rejected when NextRound should be used (time slot passed)
- Test that UpdateValue is rejected when NextTerm should be used (term change due)
- Test that legitimate UpdateValue within time slot still succeeds

### Proof of Concept

**Initial State:**
- 5-miner consensus round (A, B, C, D, E)
- Miners A-D have completed their time slots
- Current time is in Miner E's extra block slot
- Miner E should call NextRound to terminate the round

**Attack Sequence:**

1. Miner E calls `GetConsensusCommand`:
   - Returns hint with `Behaviour = NextRound`
   
2. Miner E ignores hint and creates block with UpdateValue:
   ```
   AElfConsensusTriggerInformation {
       pubkey: E's public key,
       in_value: generated value,
       behaviour: UPDATE_VALUE,  // Should be NEXT_ROUND
       ...
   }
   ```

3. Block enters validation via `ValidateBeforeExecution`:
   - `MiningPermissionValidationProvider`: PASS (E is in miner list)
   - `TimeSlotValidationProvider`: PASS (E's timing is valid)
   - `UpdateValueValidationProvider`: PASS (OutValue/Signature well-formed)
   - **No validator checks behaviour appropriateness**: VULNERABILITY

4. `ProcessUpdateValue` executes successfully: [9](#0-8) 

5. Miner E repeats steps 2-4, producing all subsequent blocks

**Expected Result:** Miner E should be forced to use NextRound; round should advance

**Actual Result:** Miner E continues producing UpdateValue blocks indefinitely; round never advances; other miners cannot mine

**Success Condition:** Attacker successfully mines multiple consecutive blocks using UpdateValue when NextRound should be mandatory, demonstrating consensus monopolization without detection or prevention.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L28-40)
```csharp
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                {
                    Behaviour = AElfConsensusBehaviour.UpdateValue,
                    RoundId = CurrentRound.RoundId,
                    PreviousRoundId = _previousRoundId
                }.ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                // Cancel mining after time slot of current miner because of the task queue.
                MiningDueTime = CurrentRound.GetExpectedMiningTime(Pubkey).AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
            };
```

**File:** protobuf/aedpos_contract.proto (L329-346)
```text
message AElfConsensusTriggerInformation {
    // The miner public key.
    bytes pubkey = 1;
    // The InValue for current round.
    aelf.Hash in_value = 2;
    // The InValue for previous round.
    aelf.Hash previous_in_value = 3;
    // The behaviour of consensus.
    AElfConsensusBehaviour behaviour = 4;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 5;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 6;
    // The revealed InValues.
    map<string, aelf.Hash> revealed_in_values = 7;
    // The random number.
    bytes random_number = 8;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L26-48)
```csharp
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-75)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) return ValidationForNextRound(validationContext);

        if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) return ValidationForNextTerm(validationContext);

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-252)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);
```
