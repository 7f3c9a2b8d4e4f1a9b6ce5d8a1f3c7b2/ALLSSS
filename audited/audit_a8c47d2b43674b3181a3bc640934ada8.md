### Title
Initial Miners Can Bypass Election Announcement Check via ReplaceCandidatePubkey to Gain Double Subsidies

### Summary
Initial miners in the `InitialMiners` list are prevented from directly announcing election, but they can bypass this restriction through the `ReplaceCandidatePubkey` mechanism. A regular candidate can announce election, then have their admin replace their pubkey with an initial miner's pubkey, resulting in the initial miner being simultaneously present in both the `Candidates` and `InitialMiners` lists, allowing them to receive both mining rewards and backup subsidy rewards - effectively double-dipping on subsidies.

### Finding Description

The vulnerability exists in the `ReplaceCandidatePubkey` method due to insufficient validation of the new pubkey. While initial miners cannot directly announce election due to an explicit check [1](#0-0) , this protection can be bypassed through pubkey replacement.

The `ReplaceCandidatePubkey` method only validates that the new pubkey is not already a candidate [2](#0-1) , but does **not** check whether the new pubkey is already in the `InitialMiners` list.

When replacing a regular candidate's pubkey with an initial miner's pubkey:
1. The old pubkey is removed from `Candidates` and the new pubkey (initial miner) is added [3](#0-2) 
2. The code only modifies `InitialMiners` if the old pubkey was in that list [4](#0-3) 
3. Since the old pubkey (regular candidate) is not in `InitialMiners`, this block is skipped
4. The subsidy beneficiary is transferred from old to new pubkey [5](#0-4) 

**Result**: The initial miner's pubkey now exists in both `Candidates` (receiving backup subsidy) and `InitialMiners` (receiving mining rewards), violating the design invariant that initial miners are excluded from election subsidies [6](#0-5) .

### Impact Explanation

**Direct Fund Impact - Double Subsidy Extraction:**

Initial miners gain access to two separate reward streams:
1. **Mining Rewards**: As members of `InitialMiners`, they receive their share of the 20% mining reward allocation (Basic Reward, Welcome Reward, Flexible Reward) distributed through the consensus mechanism
2. **Backup Subsidy**: As members of `Candidates` with subsidy beneficiary registration, they receive the 5% backup subsidy allocated to non-mining candidates

The Treasury contract distributes mining rewards with clear separation between miner rewards (20%) and backup subsidy (5%) [7](#0-6) . Initial miners are designed to only receive mining rewards, not election subsidies.

**Affected Parties:**
- Legitimate candidates lose their fair share of backup subsidy as it's diluted by initial miners improperly included
- The economic model is broken as initial miners were never intended to participate in elections
- Treasury resources are misallocated contrary to the protocol design

**Severity Justification**: HIGH - This represents a fundamental breach of the election economic model, allowing privileged bootstrap nodes to extract unfair rewards continuously over multiple terms.

### Likelihood Explanation

**Reachable Entry Point**: `ReplaceCandidatePubkey` is a public method callable by any candidate admin [8](#0-7) .

**Feasible Preconditions**:
- Attacker needs to know an initial miner pubkey (public information from chain initialization [9](#0-8) )
- Attacker must first announce election with a different pubkey and set themselves as admin
- Announcement requires locking tokens, but this is recoverable upon quitting

**Execution Practicality**: 
1. Call `AnnounceElection` with a regular pubkey (as admin)
2. Call `ReplaceCandidatePubkey` with old=regular pubkey, new=initial miner pubkey
3. No special privileges required beyond being a candidate admin
4. All validation checks pass incorrectly

**Attack Complexity**: LOW - Two straightforward contract calls with no timing constraints or complex state manipulation required.

**Economic Rationality**: The cost is the temporary token lock for announcing election (recoverable), while the gain is continuous double subsidy over multiple terms, making this highly profitable.

**Detection Constraints**: The vulnerability may go undetected as the initial miner appears as a legitimate candidate in the `Candidates` list while simultaneously remaining in `InitialMiners`.

### Recommendation

**Code-Level Mitigation**:

Add an additional validation check in the `ReplaceCandidatePubkey` method immediately after line 191:

```csharp
Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
// ADD THIS CHECK:
var newPubkeyByteString = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));
Assert(!State.InitialMiners.Value.Value.Contains(newPubkeyByteString), 
    "New pubkey cannot be an initial miner.");
```

**Invariant to Enforce**:
- A pubkey MUST NOT exist in both `Candidates` and `InitialMiners` lists simultaneously
- Initial miners MUST NOT be able to receive election-related subsidies through any path

**Test Cases to Add**:
1. Test that `ReplaceCandidatePubkey` rejects replacement when new pubkey is in `InitialMiners`
2. Test that initial miners in `InitialMiners` cannot appear in `Candidates` through any mechanism
3. Verify subsidy distribution excludes all pubkeys in `InitialMiners` list
4. Add invariant checker that validates no overlap between `Candidates` and `InitialMiners` after any state-modifying operation

### Proof of Concept

**Initial State**:
- Initial miner pubkey `IM_PUBKEY` exists in `State.InitialMiners` (set during contract initialization)
- Attacker has keypair `ATTACKER_KEY`

**Transaction Sequence**:

1. **Announce Election** (as attacker):
   - Call `AnnounceElection(admin_address)` signed by `ATTACKER_KEY`
   - `ATTACKER_KEY.pubkey` is added to `State.Candidates`
   - `ATTACKER_KEY.pubkey` is registered to `SubsidyHash` profit scheme
   - Tokens locked for announcement

2. **Replace with Initial Miner** (as admin):
   - Call `ReplaceCandidatePubkey(oldPubkey=ATTACKER_KEY.pubkey, newPubkey=IM_PUBKEY)`
   - Validations pass:
     - ✓ Old pubkey is current candidate
     - ✓ Neither pubkey is banned
     - ✓ Sender is candidate admin
     - ✓ New pubkey not in `Candidates` (but IS in `InitialMiners` - unchecked!)
   - `ATTACKER_KEY.pubkey` removed from `Candidates`
   - `IM_PUBKEY` added to `Candidates`
   - `InitialMiners` unchanged (since old pubkey wasn't in it)
   - Subsidy beneficiary transferred to `IM_PUBKEY`

**Expected vs Actual Result**:
- **Expected**: Replacement should fail with error "New pubkey cannot be an initial miner"
- **Actual**: Replacement succeeds, `IM_PUBKEY` now in both `InitialMiners` and `Candidates`

**Success Condition**: 
- Query `GetCandidates()` - returns `IM_PUBKEY` ✓
- Query initial miners in state - contains `IM_PUBKEY` ✓
- Query subsidy profit details for `IM_PUBKEY` - shows beneficiary with 1 share ✓
- `IM_PUBKEY` receives both mining rewards and backup subsidy in next term distribution ✓

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L149-150)
```csharp
        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L34-38)
```csharp
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-173)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L191-191)
```csharp
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L192-196)
```csharp
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L216-217)
```csharp
            RemoveBeneficiary(input.OldPubkey);
            AddBeneficiary(input.NewPubkey, profitReceiver);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L370-372)
```csharp
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L28-34)
```csharp
///     (Mining Reward for Miners) - 3
///     (Subsidy for Candidates / Backups) - 1
///     (Welfare for Electors / Voters / Citizens) - 1
///     3 sub profit schemes for Mining Rewards:
///     (Basic Rewards) - 4
///     (Welcome Rewards) - 1
///     (Flexible Rewards) - 1
```
