# Audit Report

## Title
Consensus DoS via Unchecked FinalOrderOfNextRound Values in TuneOrderInformation

## Summary
A malicious miner can cause permanent consensus halt by submitting extreme integer values through the `TuneOrderInformation` parameter in `UpdateValue`. The values are applied without bounds validation, causing integer overflow exceptions during next round generation that permanently stop block production.

## Finding Description

The AEDPoS consensus system allows miners to adjust mining orders for the next round via the `TuneOrderInformation` field in `UpdateValueInput`. However, the system fails to validate that these order values are within acceptable bounds (1 to minersCount).

**Attack Flow:**

1. A malicious miner in the current round crafts an `UpdateValueInput` with `TuneOrderInformation` containing extreme values (e.g., `{"someMinerPubkey": int.MaxValue}`)

2. In `ProcessUpdateValue`, these values are directly applied to the round state without validation: [1](#0-0) 

3. The validation system fails to catch this because:
   - For `UpdateValue` behavior, only `UpdateValueValidationProvider` and `LibInformationValidationProvider` are used: [2](#0-1) 
   
   - `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`: [3](#0-2) 
   
   - `NextRoundMiningOrderValidationProvider`, which checks order-related constraints, is only applied for `NextRound` behavior, not `UpdateValue`: [4](#0-3) 

4. When the next round needs to be generated, `GenerateNextRoundInformation` processes miners ordered by their malicious `FinalOrderOfNextRound` values and attempts to calculate `ExpectedMiningTime`: [5](#0-4) 

5. The multiplication `miningInterval.Mul(order)` where `order = int.MaxValue` triggers an overflow. Since `SafeMath.Mul` uses checked arithmetic, it throws an `OverflowException`: [6](#0-5) 

6. This exception prevents the extra block producer from generating consensus extra data for the next round, permanently halting consensus progression.

## Impact Explanation

**Severity: CRITICAL**

This vulnerability causes complete blockchain denial-of-service:

- **Consensus Halt**: All block production stops permanently. Once malicious `FinalOrderOfNextRound` values are committed to state, no miner can generate valid next round consensus data.

- **Transaction Processing Freeze**: No new transactions can be included in blocks since no blocks are being produced.

- **Cross-Chain Impact**: All cross-chain operations freeze as the chain cannot progress.

- **Governance Paralysis**: Parliament, Association, and Referendum proposals cannot be executed.

- **Token Operations Halt**: All token transfers, minting, burning, and NFT operations become impossible.

- **No Automatic Recovery**: The blockchain requires manual intervention (likely a coordinated upgrade) to recover, as the malicious state persists on-chain.

The impact extends to every participant in the ecosystem: validators lose rewards, users cannot transact, dApps become non-functional, and cross-chain bridges fail.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is trivially executable by any current miner:

- **Low Barrier**: The attacker only needs to be an active miner in the current round, which is a standard consensus participant role requiring no special privileges.

- **Single Transaction**: The attack requires only one transaction calling `UpdateValue` with crafted `TuneOrderInformation`. No complex coordination or timing is needed.

- **No Technical Complexity**: The attacker simply provides `TuneOrderInformation = {"anyMinerPubkey": int.MaxValue}` in their `UpdateValueInput`. No cryptographic operations or state race conditions are required.

- **Immediate Effect**: Once the transaction is executed and the round progresses, the overflow occurs on the next round generation attempt, immediately halting consensus.

- **Economic Rationality**: While the malicious miner loses future rewards, the network-wide disruption may be worthwhile for:
  - Competitors attacking rival blockchains
  - Ransom demands for chain recovery
  - Exploiting economic positions that benefit from network downtime

The attack is detectable only after execution when the damage is already done, as the malicious values are committed to state before the overflow occurs.

## Recommendation

Add bounds validation for `TuneOrderInformation` values in `ProcessUpdateValue`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minersCount = currentRound.RealTimeMinersInformation.Count;

    // ... existing code ...

    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        // Validate bounds before applying
        Assert(tuneOrder.Value > 0 && tuneOrder.Value <= minersCount, 
               $"Invalid FinalOrderOfNextRound value {tuneOrder.Value}. Must be between 1 and {minersCount}.");
        
        currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
    }

    // ... rest of existing code ...
}
```

Additionally, consider adding a dedicated validation provider for `TuneOrderInformation` that checks:
1. All values are within [1, minersCount]
2. No duplicate values (each miner gets a unique order)
3. Only valid miner public keys are referenced

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task MaliciousMiner_CanHaltConsensus_ViaTuneOrderInformation()
{
    // Setup: Initialize consensus with miners
    var miners = await InitializeConsensusWithMiners(3);
    var maliciousMiner = miners[0];
    
    // Attack: Malicious miner sends UpdateValue with extreme FinalOrderOfNextRound
    var maliciousInput = new UpdateValueInput
    {
        OutValue = GenerateValidOutValue(),
        Signature = GenerateValidSignature(),
        SupposedOrderOfNextRound = 1,
        TuneOrderInformation = 
        {
            { miners[1].PublicKey, int.MaxValue } // Malicious value
        },
        // ... other required fields ...
    };
    
    // Execute malicious UpdateValue - should succeed
    await maliciousMiner.UpdateValue(maliciousInput);
    
    // Verify: Attempt to generate next round consensus data should fail with overflow
    var exception = await Assert.ThrowsAsync<OverflowException>(async () =>
    {
        await ExtraBlockProducer.GetConsensusExtraDataForNextRound();
    });
    
    // Consensus is now permanently halted
    Assert.Contains("Arithmetic operation resulted in an overflow", exception.Message);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L13-19)
```csharp
    public static int Mul(this int a, int b)
    {
        checked
        {
            return a * b;
        }
    }
```
