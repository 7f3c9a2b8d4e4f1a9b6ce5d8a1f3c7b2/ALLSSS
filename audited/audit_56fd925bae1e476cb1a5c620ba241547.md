### Title
Conditional Round Removal During Abnormal Blockchain Status Enables Unbounded State Growth

### Summary
The `AddRoundInformation()` function only removes old round data when `GetMaximumBlocksCount()` returns `MaximumTinyBlocksCount` (8), which occurs only during Normal blockchain status. When the blockchain enters Abnormal or Severe status due to Last Irreversible Block (LIB) advancement delays, round cleanup is disabled indefinitely, causing unbounded accumulation of round state data and eventual storage exhaustion.

### Finding Description

The vulnerability exists in the round cleanup logic within `AddRoundInformation()`: [1](#0-0) 

This conditional removal only executes when `GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount`. The constant is defined as: [2](#0-1) 

However, `GetMaximumBlocksCount()` returns different values based on blockchain mining status: [3](#0-2) 

The blockchain enters Abnormal status when `libRoundNumber + 2 < currentRoundNumber < libRoundNumber + 8`, and Severe status when `currentRoundNumber >= libRoundNumber + 8`. During these states, `GetMaximumBlocksCount()` returns values less than 8 (lines 42-54 for Abnormal, line 66 for Severe), preventing round removal.

The LIB advancement depends on 2/3+1 miner consensus: [4](#0-3) [5](#0-4) 

When fewer than `MinersCountOfConsent` miners mine blocks, the LIB doesn't update (line 28 returns libHeight = 0), preventing the gap closure. The LIB update occurs during consensus processing: [6](#0-5) 

### Impact Explanation

**Storage Exhaustion:** Under normal operation with `KeepRounds = 40960`, the system maintains approximately 40,960 rounds (~400 MB assuming ~10 KB per round including miner information, signatures, and encrypted pieces). During Abnormal/Severe status without cleanup:
- At ~4 seconds per round: 21,600 rounds accumulate daily
- After 30 days: ~648,000 rounds (~6.5 GB)
- After 90 days: ~1,944,000 rounds (~19.5 GB)

**Operational Impact:** Storage exhaustion leads to:
- Node performance degradation due to excessive state size
- Potential node crashes when storage limits are reached
- Inability to sync new nodes due to excessive state requirements
- Network fragmentation as nodes fail

**Affected Parties:** All network participants including validators, full nodes, and ultimately end users who experience service disruptions.

**Severity Justification:** High severity due to guaranteed state growth during extended Abnormal/Severe periods with no automatic recovery mechanism, directly threatening blockchain operational continuity.

### Likelihood Explanation

**Attacker Capabilities Required:** An attacker needs control over >1/3 of mining power to prevent the 2/3+1 consensus threshold needed for LIB advancement. Alternatively, legitimate network issues (widespread connectivity problems, DDoS attacks on miners) can trigger the same condition.

**Attack Complexity:** Low - once >1/3 of miners are offline or non-responsive, the condition naturally triggers. Attackers simply need to prevent their controlled miners from mining or reporting proper `ImpliedIrreversibleBlockHeight` values.

**Feasibility Conditions:**
1. Control >1/3 of validator set (Byzantine fault scenario within BFT tolerances)
2. OR exploit network partitions affecting >1/3 of miners
3. No intervention required once condition is triggered - state growth is automatic

**Detection Constraints:** While observable through monitoring blockchain status transitions and state size growth, there is no automatic mitigation or recovery mechanism. Even after blockchain returns to Normal status, previously accumulated rounds remain unless manually purged.

**Probability Assessment:** Medium-to-high likelihood given:
- Byzantine fault tolerance only guarantees safety with <1/3 Byzantine nodes
- Legitimate network issues can trigger prolonged Abnormal status
- No time-based recovery or alternative cleanup mechanism exists

### Recommendation

**Primary Fix:** Implement unconditional periodic cleanup with a maximum state retention limit regardless of blockchain status:

```csharp
private void AddRoundInformation(Round round)
{
    State.Rounds.Set(round.RoundNumber, round);
    
    // ... existing secret sharing logic ...
    
    // Unconditional cleanup with maximum retention limit
    var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
    var maximumRoundsToKeep = AEDPoSContractConstants.KeepRounds.Mul(3); // Safety factor
    var forceRemoveRoundNumber = round.RoundNumber.Sub(maximumRoundsToKeep);
    
    if (roundNumberToRemove > 1 && GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
    {
        State.Rounds.Remove(roundNumberToRemove);
    }
    else if (forceRemoveRoundNumber > 1)
    {
        // Force removal after 3x normal retention to prevent unbounded growth
        State.Rounds.Remove(forceRemoveRoundNumber);
    }
}
```

**Invariant Check:** Add state size monitoring and emit warning events when accumulated rounds exceed thresholds:

```csharp
if (round.RoundNumber.Sub(State.Rounds.Keys.Min()) > AEDPoSContractConstants.KeepRounds.Mul(2))
{
    Context.Fire(new ExcessiveRoundAccumulationWarning
    {
        AccumulatedRounds = round.RoundNumber.Sub(State.Rounds.Keys.Min()),
        CurrentStatus = blockchainMiningStatus.ToString()
    });
}
```

**Test Cases:**
1. Simulate Abnormal status for extended periods (1000+ rounds) and verify round count remains bounded
2. Test forced cleanup triggers when round accumulation exceeds 3x KeepRounds
3. Verify normal cleanup still operates during Normal status
4. Test recovery behavior when transitioning from Severe back to Normal status

### Proof of Concept

**Initial State:**
- Blockchain in Normal status with KeepRounds = 40960
- LIB advancing normally with all miners participating

**Attack Sequence:**

1. **Trigger Condition:** Attacker controlling >1/3 of validators (e.g., 6 out of 17 miners) stops their miners from properly mining or reporting `ImpliedIrreversibleBlockHeight`:

2. **LIB Stagnation:** Due to insufficient miners (< MinersCountOfConsent), LIB calculation returns 0: [7](#0-6) 

3. **Status Transition:** As `currentRoundNumber` continues incrementing while `libRoundNumber` remains static, the gap grows beyond 2, triggering Abnormal status: [8](#0-7) 

4. **Cleanup Disabled:** `GetMaximumBlocksCount()` now returns a value < 8, causing the cleanup condition to fail: [9](#0-8) 

5. **Unbounded Accumulation:** Every subsequent round adds new state without removing old rounds. After 30 days (~648,000 rounds at 4 seconds per round), state grows to ~6.5 GB versus expected ~400 MB.

**Expected Result:** Old rounds should be removed to prevent unbounded growth regardless of blockchain status.

**Actual Result:** Old rounds accumulate indefinitely during Abnormal/Severe status, causing storage exhaustion.

**Success Condition:** Blockchain state size grows unboundedly until storage capacity is exhausted or manual intervention occurs.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L117-124)
```csharp
        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-79)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }

        if (!State.IsPreviousBlockInSevereStatus.Value)
            return AEDPoSContractConstants.MaximumTinyBlocksCount;

        Context.Fire(new IrreversibleBlockHeightUnacceptable
        {
            DistanceToIrreversibleBlockHeight = 0
        });
        State.IsPreviousBlockInSevereStatus.Value = false;

        return AEDPoSContractConstants.MaximumTinyBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L123-125)
```csharp
            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```
