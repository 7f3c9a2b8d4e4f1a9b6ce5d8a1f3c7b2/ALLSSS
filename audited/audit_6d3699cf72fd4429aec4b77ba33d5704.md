### Title
Removed Proposers Retain Proposal Release Authority in Association Contract

### Summary
The Association contract's `Release()` function only verifies that the caller is the original proposer but does not re-check if that proposer is still authorized in the ProposerWhiteList. This allows proposers who have been removed from the whitelist after creating proposals to still release those proposals once approved, violating the principle that whitelist removal should revoke all associated permissions.

### Finding Description

The vulnerability exists in the proposal release authorization logic:

**At Proposal Creation:** [1](#0-0) 

The system verifies the proposer is in the ProposerWhiteList via `AssertIsAuthorizedProposer()`: [2](#0-1) 

The proposal then permanently stores the proposer's address: [3](#0-2) 

**At Proposal Release:** [4](#0-3) 

The authorization check only verifies `Context.Sender == proposalInfo.Proposer`, with no re-validation of ProposerWhiteList membership. This means if an organization removes a proposer via `ChangeOrganizationProposerWhiteList`: [5](#0-4) 

The removed proposer can still release any proposals they created before removal, as long as those proposals have met the approval threshold: [6](#0-5) 

This pattern is consistent across all three governance contracts (Association, Parliament, Referendum): [7](#0-6) [8](#0-7) 

### Impact Explanation

**Governance Authority Bypass:**
- Organizations remove proposers from whitelists to revoke their authority, typically due to security concerns, organizational changes, or loss of trust
- Despite removal, these proposers retain the ability to trigger execution of any approved proposals they created before removal
- This creates a persistent attack surface where untrusted actors maintain partial control

**Attack Scenarios:**
1. **Malicious Batch Proposals**: A proposer creates multiple proposals, some of which get approved without thorough review. After the proposer is removed for suspicious behavior, they can still release the approved malicious proposals
2. **Compromised Accounts**: If a proposer's account is compromised after proposals are approved but before release, the attacker can release proposals at strategically chosen times to maximize damage
3. **Timing Manipulation**: Removed proposers can wait for specific blockchain states (e.g., treasury balance peaks, governance transitions) before releasing proposals

**Severity Justification (Medium):**
- Impact: Unauthorized proposal execution violates governance security model
- Constraint: Proposals must still meet approval thresholds, limiting immediate exploitation
- Scope: Affects all three governance contracts system-wide

### Likelihood Explanation

**Attacker Capabilities:**
- Must initially be authorized proposer (realistic - whitelists include multiple members)
- Must create proposals that get approved (requires convincing other members, but feasible)
- Must be subsequently removed from whitelist (common in governance evolution)

**Attack Complexity:**
- Low - straightforward sequence: create proposal → get approval → get removed → call Release()
- No complex state manipulation or timing precision required
- Entry point is publicly accessible

**Feasibility Conditions:**
- Preconditions are realistic in normal governance operations
- Organizations frequently adjust member lists and permissions
- Proposal approval happens through standard voting mechanisms
- No special privileges needed beyond initial whitelist membership

**Probability Assessment:**
- Medium likelihood due to realistic preconditions
- Higher probability in organizations with:
  - Frequent proposer whitelist changes
  - Multiple concurrent proposals
  - Long proposal expiration periods
  - Limited proposal review processes

### Recommendation

**Code-Level Mitigation:**

Add ProposerWhiteList re-validation in the `Release()` function:

```csharp
public override Empty Release(Hash input)
{
    var proposalInfo = GetValidProposal(input);
    Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
    
    // Add whitelist re-check
    var organization = State.Organizations[proposalInfo.OrganizationAddress];
    Assert(organization.ProposerWhiteList.Contains(proposalInfo.Proposer), 
        "Proposer no longer authorized.");
    
    Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
    // ... rest of release logic
}
```

Apply this fix to all three governance contracts: [9](#0-8) [10](#0-9) [11](#0-10) 

**Alternative Design Options:**
1. Allow any whitelist member to release approved proposals (removes single-proposer dependency)
2. Add explicit proposal cancellation mechanism for removed proposers
3. Implement grace period where removed proposers can still release for N blocks

**Test Cases:**
- Create proposal, approve, remove proposer from whitelist, verify Release() fails
- Create proposal, approve, remove proposer, verify proposal can be cleared after expiration
- Create proposal, change whitelist to different members, verify new members cannot release
- Verify legitimate proposers can still release after whitelist expansions

### Proof of Concept

**Initial State:**
- Organization with ProposerWhiteList = {Proposer_A, Proposer_B}
- Organization members = {Member_1, Member_2, Member_3}
- MinimalApprovalThreshold = 2

**Exploit Steps:**

1. **Proposer_A creates malicious proposal:**
   - `CreateProposal(organizationAddress, maliciousParams)`
   - Check passes: Proposer_A is in whitelist
   - Proposal stored with `Proposer = Proposer_A`

2. **Members approve proposal:**
   - Member_1.Approve(proposalId)
   - Member_2.Approve(proposalId)
   - Approval threshold met (2/3)

3. **Organization removes Proposer_A:**
   - Organization calls `ChangeOrganizationProposerWhiteList({Proposer_B})`
   - ProposerWhiteList now = {Proposer_B} (Proposer_A removed)

4. **Proposer_A releases proposal (SUCCEEDS):**
   - Proposer_A calls `Release(proposalId)`
   - Line 186 check: `Context.Sender == Proposer_A` ✓ PASSES
   - Line 188 check: `IsReleaseThresholdReached()` ✓ PASSES (already approved)
   - **NO whitelist re-check performed**
   - Proposal executes successfully

**Expected Result:**
Release should fail with "Proposer no longer authorized"

**Actual Result:**
Release succeeds, allowing removed proposer to execute approved proposal

**Success Condition:**
Transaction status = Mined, proposal removed from storage, inline transaction executed

### Notes

This vulnerability represents a design inconsistency where authorization is enforced at proposal creation but not at release. While the approval threshold provides some protection (members must vote for the proposal), the inability to revoke release authority from removed proposers violates governance security assumptions and creates unnecessary risk exposure. The consistent pattern across all three governance contracts suggests this may be intentional design, but it conflicts with the expected semantics of "removing from whitelist" which should revoke all associated permissions.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L109-109)
```csharp
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L157-157)
```csharp
            Proposer = Context.Sender,
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```
