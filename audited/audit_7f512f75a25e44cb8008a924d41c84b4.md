### Title
NFT Contract Bypasses Parliament Governance for Method Fee Control

### Summary
The NFT contract's `GetMethodFeeController()` returns an empty `AuthorityInfo` object with null addresses, and both `SetMethodFee()` and `ChangeMethodFeeController()` are no-op implementations. This completely prevents Parliament from exercising governance over the NFT contract's method fees (including the hardcoded 100 ELF creation fee), violating the AElf governance model where all system contracts should be governed by Parliament's default organization.

### Finding Description

**Location:** [1](#0-0) 

The NFT contract implements the ACS1 (Transaction Fee Standard) interface but provides broken governance implementations:

1. **Empty Authority Return:** The `GetMethodFeeController()` method returns a new empty `AuthorityInfo` object with both `contract_address` and `owner_address` set to null. [1](#0-0) 

2. **No-op Fee Setting:** The `SetMethodFee()` method simply returns `Empty` without any logic, authorization checks, or state modifications. [2](#0-1) 

3. **No-op Controller Change:** The `ChangeMethodFeeController()` method also returns `Empty` without any implementation. [3](#0-2) 

4. **Hardcoded Fee:** The `GetMethodFee()` method returns a hardcoded fee of 100 ELF (100_00000000) for the "Create" method. [4](#0-3) 

5. **Missing State Variables:** The NFT contract state lacks the required `MethodFeeController` and `TransactionFees` state variables that all properly governed contracts maintain. [5](#0-4) 

**Proper Implementation Pattern:** In contrast, all other system contracts (MultiToken, Parliament, Economic, etc.) implement ACS1 correctly by:
- Calling `RequiredMethodFeeControllerSet()` in `GetMethodFeeController()` which initializes the controller to Parliament's default organization [6](#0-5) 
- Enforcing authorization in `SetMethodFee()` by checking `Context.Sender == State.MethodFeeController.Value.OwnerAddress` [7](#0-6) 
- Validating organization existence when changing controllers [8](#0-7) 
- Initializing the default authority to Parliament's default organization address [9](#0-8) 

**Why Protections Fail:** The NFT contract has no protections because the governance methods are completely stubbed out. There are no authorization checks, no state storage, and no integration with the Parliament governance system.

### Impact Explanation

**Governance Model Violation:** The ACS1 standard explicitly states that "the default [method fee controller] is parliament and default organization." [10](#0-9) 

**Concrete Harm:**
1. **Immutable Fees:** The 100 ELF creation fee cannot be adjusted through governance proposals, only through full contract upgrades
2. **No Market Responsiveness:** If ELF price increases 10x, the creation cost becomes 1000 USD equivalent, but Parliament cannot reduce it
3. **Architectural Inconsistency:** All 15+ other system contracts (Parliament, MultiToken, Economic, Consensus, etc.) properly implement Parliament governance, making NFT the sole exception
4. **Misleading Interface:** The contract exposes ACS1 governance methods that appear functional but are actually no-ops

**Affected Parties:**
- NFT creators who must pay potentially unsuitable fees
- Block producers who lose governance control over a system contract
- The broader ecosystem's governance integrity

**Severity Justification:** HIGH severity because:
- Complete bypass of a critical governance invariant
- Affects all NFT operations on the chain
- Violates documented AElf governance architecture
- 100% occurrence rate (this is the current implementation)

### Likelihood Explanation

**Current State, Not Exploit:** This is not an attack scenario but rather the existing implementation state. The likelihood is 100% because this governance break occurs for every attempt to manage NFT fees through Parliament.

**Demonstration:**
1. Any block producer attempting to propose a fee change would call `GetMethodFeeController()` and receive empty AuthorityInfo
2. Creating a Parliament proposal to call `SetMethodFee()` would succeed in execution but have no effect
3. The governance workflow that works for all other contracts (as demonstrated in MultiToken tests) fails silently for NFT [11](#0-10) 

**No Attack Complexity:** There's no attacker or exploit - this is simply broken governance that affects all legitimate users trying to adjust fees through the intended governance mechanism.

**Detection:** Trivially detectable by calling `GetMethodFeeController()` and observing empty addresses, or attempting to change fees through Parliament and observing no effect.

### Recommendation

**Immediate Fix:** Implement proper ACS1 governance in the NFT contract:

1. **Add State Variables** to `NFTContractState.cs`:
```csharp
public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
public MappedState<string, MethodFees> TransactionFees { get; set; }
```

2. **Implement `RequiredMethodFeeControllerSet()`** following the pattern from MultiToken contract [9](#0-8) 

3. **Fix `GetMethodFeeController()`** to call `RequiredMethodFeeControllerSet()` and return the proper authority [12](#0-11) 

4. **Implement `SetMethodFee()`** with authorization checks [13](#0-12) 

5. **Implement `ChangeMethodFeeController()`** with validation [14](#0-13) 

6. **Update `GetMethodFee()`** to read from state storage while keeping hardcoded defaults as fallback

**Test Cases:** Add comprehensive tests following the MultiToken pattern that verify:
- Default controller is Parliament's default organization
- Only Parliament can change fees through proposal workflow
- Unauthorized calls to SetMethodFee are rejected
- Controller changes require current controller authorization [15](#0-14) 

### Proof of Concept

**Current Broken State:**
1. Call `NFTContract.GetMethodFeeController()` 
2. **Expected (per ACS1 spec):** Returns `AuthorityInfo` with `owner_address = ParliamentDefaultOrganization` and `contract_address = ParliamentContract`
3. **Actual:** Returns empty `AuthorityInfo` with null addresses [1](#0-0) 

**Governance Attempt:**
1. Block producers create Parliament proposal to call `NFTContract.SetMethodFee()` to reduce Create fee from 100 ELF to 10 ELF
2. Proposal gets 2/3 approval from miners (following proper governance)
3. Proposal is released and executed successfully (no error)
4. **Expected:** Fee changes to 10 ELF
5. **Actual:** Fee remains 100 ELF because `SetMethodFee()` does nothing [2](#0-1) 
6. Verify: `GetMethodFee("Create")` still returns 100 ELF hardcoded value [16](#0-15) 

**Success Condition for Vulnerability:** The governance attempt has no effect despite following the correct Parliament workflow that works for all other system contracts.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-11)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L13-16)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L39-42)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        return new AuthorityInfo();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L1-46)
```csharp
ï»¿using AElf.Sdk.CSharp.State;
using AElf.Types;

namespace AElf.Contracts.NFT;

public partial class NFTContractState : ContractState
{
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L54-58)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L91-109)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo();

        // Parliament Auth Contract maybe not deployed.
        if (State.ParliamentContract.Value != null)
        {
            defaultAuthority.OwnerAddress =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
            defaultAuthority.ContractAddress = State.ParliamentContract.Value;
        }

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** docs-sphinx/reference/acs/acs1.rst (L19-19)
```text
| ChangeMethodFeeController   | `AuthorityInfo <#AuthorityInfo>`__                               | `google.protobuf.Empty <#google.protobuf.Empty>`__   | Change the method fee controller, the default is parliament and default organization.                |
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/ACS1_ImplementTest.cs (L19-53)
```csharp
    public async Task ChangeMethodFeeController_Test()
    {
        var createOrganizationResult =
            await ParliamentContractStub.CreateOrganization.SendAsync(
                new CreateOrganizationInput
                {
                    ProposalReleaseThreshold = new ProposalReleaseThreshold
                    {
                        MinimalApprovalThreshold = 1000,
                        MinimalVoteThreshold = 1000
                    }
                });
        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.TransactionResult.ReturnValue);

        var methodFeeController = await TokenContractStub.GetMethodFeeController.CallAsync(new Empty());
        var defaultOrganization =
            await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(
                new Empty());
        methodFeeController.OwnerAddress.ShouldBe(defaultOrganization);

        const string proposalCreationMethodName = nameof(TokenContractStub.ChangeMethodFeeController);
        var proposalId = await CreateProposalAsync(TokenContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName, new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = ParliamentContractAddress
            });
        await ApproveWithMinersAsync(proposalId);
        var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId);
        releaseResult.TransactionResult.Error.ShouldBeNullOrEmpty();
        releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var newMethodFeeController = await TokenContractStub.GetMethodFeeController.CallAsync(new Empty());
        newMethodFeeController.OwnerAddress.ShouldBe(organizationAddress);
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/ACS1_ImplementTest.cs (L56-78)
```csharp
    public async Task ChangeMethodFeeController_WithoutAuth_Test()
    {
        var createOrganizationResult =
            await ParliamentContractStub.CreateOrganization.SendAsync(
                new CreateOrganizationInput
                {
                    ProposalReleaseThreshold = new ProposalReleaseThreshold
                    {
                        MinimalApprovalThreshold = 1000,
                        MinimalVoteThreshold = 1000
                    }
                });
        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.TransactionResult.ReturnValue);
        var result = await TokenContractStub.ChangeMethodFeeController.SendWithExceptionAsync(
            new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = ParliamentContractAddress
            });

        result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        result.TransactionResult.Error.Contains("Unauthorized behavior.").ShouldBeTrue();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L46-50)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }
```
