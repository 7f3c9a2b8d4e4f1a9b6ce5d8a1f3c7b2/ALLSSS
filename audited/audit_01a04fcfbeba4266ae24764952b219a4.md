### Title
Insufficient Validation of ImpliedIrreversibleBlockHeight Allows Miners to Manipulate LIB Calculation

### Summary
Miners can provide arbitrary values for `ImpliedIrreversibleBlockHeight` in their `UpdateValueInput` transactions, violating the protocol's expectation that this value should equal the current block height. The validation only enforces that values don't decrease, lacking any upper bound check or reasonableness validation, allowing miners to bias the Last Irreversible Block (LIB) calculation by submitting artificially low or high values.

### Finding Description

The AEDPoS consensus contract calculates the Last Irreversible Block (LIB) height by collecting `ImpliedIrreversibleBlockHeight` values from miners and selecting the value at position `(count-1)/3` from a sorted list. [1](#0-0) 

The honest code path sets this value to `Context.CurrentHeight` when generating consensus data: [2](#0-1) 

However, when processing `UpdateValue` transactions, the contract directly accepts whatever value the miner provides without validating it against the current height: [3](#0-2) 

The only validation performed checks that the value doesn't decrease from the miner's previous value, but imposes no upper bound or reasonableness check: [4](#0-3) 

A malicious miner can bypass the honest code generation path and manually craft an `UpdateValueInput` with an arbitrary `ImpliedIrreversibleBlockHeight` value (e.g., 1 or an inflated future height). The value is extracted and submitted via: [5](#0-4) 

### Impact Explanation

**Consensus Integrity Compromise**: A malicious miner can force the LIB calculation to produce an incorrectly low value by submitting `ImpliedIrreversibleBlockHeight = 1` (or other artificially low values). When this value is included in the sorted heights list from the previous round, and the LIB is calculated by selecting the element at position `(count-1)/3`, a sufficiently low value can pull down the consensus LIB.

For example, with 7 miners where 5 have mined:
- Honest scenario: sorted heights `[990, 991, 992, 993, 994]` → LIB = `heights[1]` = 991
- With one malicious miner: `[1, 991, 992, 993, 994]` → LIB = `heights[1]` = 991

While a single malicious miner may not always affect the median position, multiple colluding miners (still below the 1/3 Byzantine threshold) can force incorrect LIB values. More critically, **any deviation from the protocol-specified behavior** (where `ImpliedIrreversibleBlockHeight` should equal `Context.CurrentHeight`) represents a consensus violation that undermines the security guarantees of the blockchain's finality mechanism.

The lack of validation also allows miners to report future block heights (higher than `Context.CurrentHeight`), which violates basic logical consistency of the LIB concept.

### Likelihood Explanation

**High Likelihood**: 
- **Reachable Entry Point**: Any authorized miner can call the public `UpdateValue` method [6](#0-5) 
- **Low Complexity**: The attacker only needs to modify their node software to bypass the honest code path in `GetConsensusBlockExtraData` and manually construct an `UpdateValueInput` with their chosen value
- **No Cost Barrier**: The attack requires no additional economic cost beyond being an authorized miner
- **Persistent Effect**: Once set, the malicious value persists in the round state and affects subsequent LIB calculations
- **Detection Difficulty**: Without explicit bounds checking, the invalid value appears valid to the validation logic

### Recommendation

Add comprehensive validation in `LibInformationValidationProvider` to enforce the protocol invariant:

1. **Add upper bound check**: Validate that `ImpliedIrreversibleBlockHeight <= Context.CurrentHeight` to prevent reporting future/impossible block heights
2. **Add lower bound check**: Validate that `ImpliedIrreversibleBlockHeight >= baseRound.ConfirmedIrreversibleBlockHeight` to ensure miners don't report heights below the consensus LIB
3. **Consider reasonableness bounds**: Optionally validate that the value is within a reasonable range of other miners' values (e.g., not more than 100 blocks different from the median)

Example validation to add in `LibInformationValidationProvider.ValidateHeaderInformation`:
```csharp
// After line 30, add:
var currentHeight = validationContext.ExtraData.SenderPubkey.ToHex() == pubkey 
    ? Context.CurrentHeight 
    : validationContext.BaseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;

if (providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight > currentHeight)
{
    validationResult.Message = "ImpliedIrreversibleBlockHeight cannot exceed current height.";
    return validationResult;
}

if (baseRound.ConfirmedIrreversibleBlockHeight > 0 && 
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight < baseRound.ConfirmedIrreversibleBlockHeight)
{
    validationResult.Message = "ImpliedIrreversibleBlockHeight cannot be below confirmed LIB.";
    return validationResult;
}
```

### Proof of Concept

**Initial State**:
- Blockchain at height 1000
- 7 miners in consensus, round N
- All honest miners set `ImpliedIrreversibleBlockHeight = Context.CurrentHeight` (≈990-996)

**Attack Steps**:
1. Malicious Miner1 modifies their node code to bypass `GetConsensusBlockExtraData`
2. In round N, Miner1 crafts `UpdateValueInput` with `ImpliedIrreversibleBlockHeight = 1`
3. Miner1 submits transaction via `UpdateValue(updateValueInput)`
4. Validation in `LibInformationValidationProvider` checks only that value ≥ previous value (passes since 1 ≥ 0 for first time)
5. Value is stored: `minerInRound.ImpliedIrreversibleBlockHeight = 1`
6. In round N+1, when another miner produces a block, `ProcessUpdateValue` calculates LIB
7. The calculation retrieves sorted heights from round N including the malicious value of 1
8. Depending on position calculation `(count-1)/3`, the artificially low value biases the result downward

**Expected**: All miners report current height, LIB calculated based on honest consensus  
**Actual**: Malicious miner reports arbitrary value, validation accepts it, LIB calculation uses biased input  
**Success Condition**: Value 1 is stored in state and used in subsequent LIB calculation, demonstrating lack of validation enforcement

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L48-48)
```csharp
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
