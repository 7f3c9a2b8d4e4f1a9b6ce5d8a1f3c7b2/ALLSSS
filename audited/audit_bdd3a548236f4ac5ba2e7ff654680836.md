### Title
Missing Upper Bound Validation on Method Fees Enables Chain-Wide Denial of Service

### Summary
The `SetMethodFee()` function across ACS1 implementations lacks upper bound validation on `BasicFee` amounts, allowing the method fee controller to set astronomical values (e.g., `long.MaxValue - 1`) for any contract method. When such fees are set for critical methods like token transfers, all user transactions fail due to insufficient balance to pay fees, effectively causing a complete denial of service on the blockchain. While this requires governance action through Parliament approval, the absence of technical safeguards violates defense-in-depth principles and exposes the chain to catastrophic DOS through malicious governance, compromised miners, or accidental misconfiguration.

### Finding Description

The vulnerability exists in the fee validation logic across all ACS1 (Method Fee Standard) implementations: [1](#0-0) [2](#0-1) 

The validation only checks that amounts are positive (`amount >= 0` or `amount > 0`) but imposes **no maximum bound**. This allows the controller to set `BasicFee` to values approaching `long.MaxValue` (9,223,372,036,854,775,807).

The method fee controller is authorized to call `SetMethodFee()`: [3](#0-2) 

By default, the controller is Parliament's default organization requiring 2/3 miner approval: [4](#0-3) [5](#0-4) 

When astronomical fees are set, the fee charging mechanism fails because users cannot afford them: [6](#0-5) 

The pre-execution plugin checks the charging result and stops transaction execution on failure: [7](#0-6) 

Transactions fail with the error "Pre-Error: Transaction fee not enough.": [8](#0-7) 

### Impact Explanation

**Operational DOS Impact**: When astronomical fees (e.g., `BasicFee = 9,223,372,036,854,775,806`) are set for critical methods, the entire blockchain becomes effectively unusable:

1. **Token Transfer DOS**: If set on `Transfer()` or `TransferFrom()` in the MultiToken contract, users cannot transfer any tokens, halting all economic activity.

2. **Governance DOS**: If set on `CreateProposal()` in Parliament/Association contracts, no new governance proposals can be created, preventing recovery through governance.

3. **Consensus DOS**: If set on consensus-related methods, block production and network operation could be disrupted.

4. **Universal Impact**: All users are affected simultaneously - nobody can afford fees in the quintillions.

5. **Irreversible Without Governance**: Recovery requires a governance proposal to reset fees, but if governance methods are also DOSed, the chain enters an unrecoverable state.

**Severity Justification**: CRITICAL - Complete protocol failure affecting all users with potential for permanent chain halt if governance is simultaneously disabled.

### Likelihood Explanation

**Governance Action Required**: The attack requires Parliament approval (66.67% of miners): [9](#0-8) 

**Feasible Attack Vectors**:

1. **Malicious Governance**: If 2/3 of miners are compromised or collude maliciously, they can intentionally DOS the chain.

2. **Accidental Misconfiguration**: A governance proposal with a typo (e.g., adding extra zeros) could accidentally set astronomical fees if approved without proper review.

3. **Social Engineering**: Attackers could craft deceptive proposals that appear legitimate but contain hidden astronomical fee settings.

4. **Governance Coordination Failure**: During emergency situations, rushed proposal approvals without thorough validation could result in accidental catastrophic fee settings.

**Probability Assessment**: LOW to MEDIUM - While requiring governance action, the complete absence of technical safeguards means a single governance mistake or compromise can cause irreversible damage. Defense-in-depth principles require bounds even on trusted operations.

### Recommendation

**Immediate Fix**: Implement maximum bound validation in all `SetMethodFee()` implementations:

```csharp
private void AssertValidToken(string symbol, long amount)
{
    Assert(amount >= 0, "Invalid amount.");
    Assert(amount <= MaxMethodFee, "Method fee exceeds maximum allowed value.");
    // ... existing token validation
}
```

Define a reasonable maximum (e.g., `MaxMethodFee = 1_000_000_000_000` = 1000 tokens with 8 decimals) in contract constants.

**Additional Safeguards**:

1. Add validation in `MethodFees` protobuf message deserializer
2. Implement rate limiting on fee increases (e.g., cannot increase more than 10x per proposal)
3. Add emergency recovery mechanism allowing fee resets through alternative authority
4. Create governance proposal templates with explicit fee value reviews

**Test Cases**:
- Test setting `BasicFee = long.MaxValue - 1` and verify rejection
- Test setting `BasicFee = MaxMethodFee + 1` and verify rejection
- Test legitimate fee updates within bounds succeed
- Test that DOS via astronomical fees is prevented

### Proof of Concept

**Initial State**:
- Parliament default organization controls method fees for Token contract
- Users have sufficient token balances (e.g., 1,000,000 ELF)

**Attack Steps**:

1. **Create Malicious Proposal**: Parliament member creates proposal to call `TokenContract.SetMethodFee()`:
   ```
   MethodFees {
     method_name: "Transfer",
     fees: [MethodFee { symbol: "ELF", basic_fee: 9223372036854775806 }]
   }
   ```

2. **Approval**: 2/3 of miners approve the proposal (either maliciously or accidentally thinking it's 100 ELF not quintillions).

3. **Release**: Proposer releases the approved proposal, executing `SetMethodFee()`.

4. **Fee Applied**: The astronomical fee is stored with no validation error: [10](#0-9) 

5. **User Transaction Attempt**: Any user attempts `Transfer(recipient, 100)`.

6. **Fee Charging Failure**: `ChargeTransactionFees()` attempts to charge 9,223,372,036,854,775,806 ELF but user only has 1,000,000 ELF. Returns `Success = false`: [11](#0-10) 

7. **Transaction DOS**: Pre-execution plugin stops execution, transaction fails with "Pre-Error: Transaction fee not enough.": [12](#0-11) 

**Expected Result**: Validation error rejecting astronomical fee during `SetMethodFee()` call.

**Actual Result**: Fee is accepted and stored, causing complete DOS of the `Transfer()` method for all users.

**Success Condition**: All subsequent `Transfer()` transactions fail, confirming chain-wide token transfer DOS.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L9-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L59-71)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        RequireParliamentContractAddressSet();

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L73-82)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L5-5)
```csharp
    private const int DefaultOrganizationMinimalApprovalThreshold = 6667;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L84-126)
```csharp
    private ChargeTransactionFeesOutput TryToChargeTransactionFee(ChargeTransactionFeesInput input, Address fromAddress,
        TransactionFeeBill bill, TransactionFreeFeeAllowanceBill allowanceBill, Dictionary<string, long> fee,
        bool isSizeFeeFree)
    {
        Context.LogDebug(() => "TryToChargeTransactionFee Start");
        var chargingResult =
            ChargeTransactionFeesToBill(input, fromAddress, ref bill, ref allowanceBill, fee, isSizeFeeFree);
        if (!chargingResult)
        {
            var delegatorAddress = fromAddress;
            chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                isSizeFeeFree, delegatorAddress);
        }

        if (!chargingResult)
        {
            var transactionFeeDelegatees =
                State.TransactionFeeDelegateInfoMap[fromAddress][input.ContractAddress][input.MethodName] ??
                State.TransactionFeeDelegateesMap[fromAddress];
            if (transactionFeeDelegatees != null)
            {
                var delegateeAddress = transactionFeeDelegatees.Delegatees;
                foreach (var (delegatee, _) in delegateeAddress)
                {
                    chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                        isSizeFeeFree, Address.FromBase58(delegatee));
                    if (chargingResult)
                    {
                        break;
                    }
                }
            }
        }

        ModifyBalance(fromAddress, bill, allowanceBill);
        var chargingOutput = new ChargeTransactionFeesOutput { Success = chargingResult };
        if (!chargingResult)
            chargingOutput.ChargingInformation = "Transaction fee not enough.";
        
        Context.LogDebug(() => "TryToChargeTransactionFee End");
        Context.LogDebug(() => "ChargeTransactionFees End");
        return chargingOutput;
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L123-129)
```csharp
    public bool IsStopExecuting(ByteString txReturnValue, out string preExecutionInformation)
    {
        var chargeTransactionFeesOutput = new ChargeTransactionFeesOutput();
        chargeTransactionFeesOutput.MergeFrom(txReturnValue);
        preExecutionInformation = chargeTransactionFeesOutput.ChargingInformation;
        return !chargeTransactionFeesOutput.Success;
    }
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutionPluginForMethodFeeTest.cs (L328-331)
```csharp
        var dummy = await userTestContractStub.DummyMethod
            .SendWithExceptionAsync(new Empty()); // This will deduct the fee
        dummy.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        dummy.TransactionResult.Error.ShouldBe("Pre-Error: Transaction fee not enough.");
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutionPluginForMethodFeeTest.cs (L407-407)
```csharp
            dummyResult.TransactionResult.Error.ShouldBe("Pre-Error: Transaction fee not enough.");
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```
