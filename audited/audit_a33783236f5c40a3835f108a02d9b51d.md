### Title
Missing Authorization and Input Validation in SetTreasurySchemeIds Allows Permanent DoS of Profit Distribution System

### Summary
The `SetTreasurySchemeIds()` function lacks both authorization checks and input validation, allowing any attacker to front-run the legitimate initialization and set invalid scheme IDs. Once set with null or invalid hashes, all profit distribution operations permanently fail, causing complete breakdown of the economic reward system including Treasury releases, voter welfare, and candidate subsidies.

### Finding Description

The `SetTreasurySchemeIds()` function in ElectionContract_Maintainence.cs has critical security flaws: [1](#0-0) 

**Root Cause 1: No Authorization Check**
The function has no sender validation. Unlike other critical initialization functions, it does not verify the caller's identity or check if the Election contract is properly initialized. Any address can call this function.

**Root Cause 2: No Input Validation**  
The function directly assigns input values to state without validating:
- Whether hashes are null or zero
- Whether hashes correspond to valid schemes in the Profit contract
- Whether schemes have correct permissions/configuration

**Root Cause 3: Insufficient Protection**
The only protection is a single-use check preventing the function from being called twice. This creates a race condition where the first caller (legitimate or malicious) wins permanently.

**Legitimate Initialization Path:**
The intended initialization occurs through the Economic contract during system setup: [2](#0-1) 

However, since `SetTreasurySchemeIds()` has no authorization check, an attacker can call it directly before the legitimate initialization completes.

**Critical Dependencies:**
These scheme IDs are used throughout the system for profit distribution:

1. **TreasuryHash** - Used in Treasury donations and releases: [3](#0-2) 

2. **WelfareHash** - Used when voters participate in elections: [4](#0-3) 

3. **SubsidyHash** - Used for backup candidate subsidies: [5](#0-4) 

**Failure Mode:**
When invalid scheme IDs are used, the Profit contract rejects operations: [6](#0-5) 

### Impact Explanation

**Complete Economic System Breakdown:**

1. **Treasury Release Failure**: The consensus contract calls `Treasury.Release()` every term to distribute mining rewards. With invalid TreasuryHash, this fails permanently, preventing all miner compensation.

2. **Voter Welfare DoS**: When users vote in elections, the contract attempts to register them as beneficiaries in the welfare scheme. With invalid WelfareHash, all voting operations fail, effectively disabling the election mechanism.

3. **Candidate Subsidy Failure**: Backup candidates cannot be added to the subsidy scheme with invalid SubsidyHash, breaking the backup miner incentive system.

4. **Permanent and Irreversible**: Since `SetTreasurySchemeIds()` can only be called once (due to the single-use check), once an attacker sets invalid values, there is no recovery mechanism. The Election contract becomes permanently non-functional.

**Affected Parties:**
- All miners lose rewards
- All voters cannot participate in governance
- All candidates cannot receive subsidies  
- The entire AElf economic model collapses

**Severity Justification:**
This is HIGH severity because:
- Impact is catastrophic (complete economic system failure)
- Attack is permanent and irreversible
- No recovery mechanism exists
- Affects all protocol participants

### Likelihood Explanation

**Attack Complexity: Trivial**
The attacker simply needs to:
1. Monitor for Election contract deployment
2. Send transaction calling `SetTreasurySchemeIds()` with null/zero hashes
3. Outpace the legitimate initialization transaction

**Attacker Capabilities Required:**
- Ability to send transactions (any address can do this)
- Timing to front-run initialization (trivial during deployment phase)
- Minimal gas cost (single transaction)

**Attack Window:**
The vulnerability exists between:
- Election contract deployment, and  
- Economic contract's `InitialEconomicSystem()` completing

This window is exploitable because:
- Contracts are typically deployed sequentially
- Multiple transactions are required for full system initialization
- No protection exists during this initialization sequence

**Economic Rationality:**
- Cost: Minimal (gas for one transaction)
- Benefit: Complete protocol disruption (extremely high value for malicious actors)
- Detection: The attack is immediately visible but irreversible by the time it's detected

**Probability Assessment: HIGH**
Given the lack of authorization, the trivial attack complexity, and the permanent impact, exploitation probability is very high during contract deployment/initialization phases.

### Recommendation

**Immediate Fix: Add Authorization Check**

```csharp
public override Empty SetTreasurySchemeIds(SetTreasurySchemeIdsInput input)
{
    // Add authorization check
    Assert(
        Context.Sender == Context.GetContractAddressByName(SmartContractConstants.EconomicContractSystemName),
        "Only Economic contract can set treasury scheme ids.");
    
    Assert(State.TreasuryHash.Value == null, "Treasury profit ids already set.");
    
    // Add input validation
    Assert(input.TreasuryHash != null && input.TreasuryHash != Hash.Empty, "Invalid TreasuryHash.");
    Assert(input.WelfareHash != null && input.WelfareHash != Hash.Empty, "Invalid WelfareHash.");
    Assert(input.SubsidyHash != null && input.SubsidyHash != Hash.Empty, "Invalid SubsidyHash.");
    Assert(input.WelcomeHash != null && input.WelcomeHash != Hash.Empty, "Invalid WelcomeHash.");
    Assert(input.FlexibleHash != null && input.FlexibleHash != Hash.Empty, "Invalid FlexibleHash.");
    
    State.TreasuryHash.Value = input.TreasuryHash;
    State.WelfareHash.Value = input.WelfareHash;
    State.SubsidyHash.Value = input.SubsidyHash;
    State.WelcomeHash.Value = input.WelcomeHash;
    State.FlexibleHash.Value = input.FlexibleHash;
    return new Empty();
}
```

**Additional Safeguards:**

1. **Verify scheme existence**: Optionally call ProfitContract.GetScheme() to verify each scheme ID is valid before storing

2. **Add Election initialization check**: Consider requiring the Election contract to be initialized first:
```csharp
Assert(State.Initialized.Value, "Election contract must be initialized first.");
```

3. **Test Coverage**: Add test cases for:
   - Unauthorized caller attempting to set scheme IDs
   - Setting null/zero hashes
   - Setting invalid scheme IDs that don't exist in Profit contract

### Proof of Concept

**Prerequisites:**
- Election contract deployed
- Economic contract deployed but `InitialEconomicSystem()` not yet called
- Attacker has any account with gas

**Attack Sequence:**

1. **Initial State**: Election contract deployed, TreasuryHash not yet set

2. **Attacker Action**: 
```
Call ElectionContract.SetTreasurySchemeIds({
    TreasuryHash: Hash.Empty,
    WelfareHash: Hash.Empty, 
    SubsidyHash: Hash.Empty,
    WelcomeHash: Hash.Empty,
    FlexibleHash: Hash.Empty
})
```

3. **Result**: Transaction succeeds, invalid hashes stored in Election contract state

4. **Legitimate Initialization Attempt**:
```
EconomicContract.InitialEconomicSystem() -> SetTreasurySchemeIdsToElectionContract()
```
This fails with: "Treasury profit ids already set."

5. **System Failure Cascade**:
   - Consensus calls Treasury.Release() -> FAILS ("Scheme not found.")
   - User calls Election.Vote() -> FAILS ("Scheme not found.")  
   - Candidate added to DataCenter -> AddBeneficiary FAILS ("Scheme not found.")

**Success Condition**: 
All profit distribution operations permanently fail. The Election and Treasury contracts are rendered non-functional with no recovery path.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L162-171)
```csharp
    public override Empty SetTreasurySchemeIds(SetTreasurySchemeIdsInput input)
    {
        Assert(State.TreasuryHash.Value == null, "Treasury profit ids already set.");
        State.TreasuryHash.Value = input.TreasuryHash;
        State.WelfareHash.Value = input.WelfareHash;
        State.SubsidyHash.Value = input.SubsidyHash;
        State.WelcomeHash.Value = input.WelcomeHash;
        State.FlexibleHash.Value = input.FlexibleHash;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L187-209)
```csharp
    private void SetTreasurySchemeIdsToElectionContract()
    {
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
        var schemeIdsManagingByTreasuryContract = State.ProfitContract.GetManagingSchemeIds.Call(
            new GetManagingSchemeIdsInput
            {
                Manager = Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)
            }).SchemeIds;
        var schemeIdsManagingByElectionContract = State.ProfitContract.GetManagingSchemeIds.Call(
            new GetManagingSchemeIdsInput
            {
                Manager = Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName)
            }).SchemeIds;
        State.ElectionContract.SetTreasurySchemeIds.Send(new SetTreasurySchemeIdsInput
        {
            TreasuryHash = schemeIdsManagingByTreasuryContract[0],
            WelcomeHash = schemeIdsManagingByTreasuryContract[3],
            FlexibleHash = schemeIdsManagingByTreasuryContract[4],
            SubsidyHash = schemeIdsManagingByElectionContract[0],
            WelfareHash = schemeIdsManagingByElectionContract[1]
        });
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L129-134)
```csharp
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.TreasuryHash.Value,
            Period = input.PeriodNumber,
            AmountsMap = { State.SymbolList.Value.Value.ToDictionary(s => s, s => 0L) }
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-380)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L785-794)
```csharp
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = beneficiaryAddress,
                Shares = 1,
            },
            ProfitDetailId = subsidyId
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L422-423)
```csharp
        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");
```
