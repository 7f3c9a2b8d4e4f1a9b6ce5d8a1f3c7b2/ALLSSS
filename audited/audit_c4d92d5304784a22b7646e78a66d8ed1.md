### Title
Insufficient OutValue and Signature Validation Allows Mining Order Manipulation and Consensus Bypass

### Summary
The `NewConsensusInformationFilled` validation only checks that `OutValue` and `Signature` byte arrays are non-empty using `.Any()`, without verifying they are properly formatted 32-byte hashes or correctly computed. A malicious miner can submit arbitrary single-byte values for both fields, bypass the commit-reveal scheme by using `PreviousInValue = Hash.Empty` in subsequent rounds, and manipulate their mining order to gain unfair block production advantages.

### Finding Description

**Root Cause:**

The validation at [1](#0-0)  only checks that `OutValue.Value.Any()` and `Signature.Value.Any()` return true (i.e., byte arrays are non-empty), without validating:

1. That `OutValue` is a properly formatted 32-byte `Hash` (required by [2](#0-1) )
2. That `OutValue` equals `HashHelper.ComputeFrom(InValue)` as documented in [3](#0-2) 
3. That `Signature` is correctly computed via `CalculateSignature` as shown in [4](#0-3) 

**Bypass Mechanism:**

When a miner submits a malformed `OutValue` (e.g., single byte `[0x00]`), the self-check during next block production at [5](#0-4)  fails (32-byte hash ≠ 1-byte value), causing `previousInValue` to be set to `Hash.Empty`. 

The validation explicitly allows this at [6](#0-5) , and the contract comments confirm at [7](#0-6)  that "It is permissible for miners not publish their in values."

**Exploitation Path:**

The `Signature` value directly determines mining order through [8](#0-7)  where `supposedOrderOfNextRound = GetAbsModulus(signature.ToInt64(), minersCount) + 1`. By providing arbitrary signature values, an attacker can position themselves at any desired order (1 through minersCount).

### Impact Explanation

**Consensus Integrity Violation:**
- Breaks the commit-reveal scheme fundamental to AEDPoS consensus security
- Allows miners to avoid contributing to consensus randomness generation
- Weakens the unpredictability guarantees of the signature-based mining order system

**Unfair Mining Advantages:**
- Attacker can manipulate their position to become the first miner (order 1)
- First miner's signature determines the extra block producer via [9](#0-8) 
- Extra block producers gain additional block production opportunities beyond their normal time slot
- More blocks produced = more transaction fee revenue and potential protocol rewards

**Severity:** Medium - Requires existing miner status (trusted role), but once achieved provides sustained unfair advantage and undermines consensus security properties affecting all network participants.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an authorized miner in `RealTimeMinersInformation` (verified at [10](#0-9) )
- Requires standard miner transaction signing capabilities

**Attack Complexity:**
- Low - Simply craft `UpdateValueInput` protobuf message with arbitrary 1-byte `out_value` and chosen `signature` bytes
- The protobuf `Hash` type at [11](#0-10)  accepts any byte length via deserialization
- No sophisticated cryptographic or timing attacks required

**Feasibility:**
- Attack persists indefinitely once initiated (no automatic detection or penalties)
- No additional cost beyond normal block production gas fees
- Can be executed repeatedly across multiple rounds to maximize advantage

**Economic Rationality:**
- Cost: Minimal (standard transaction costs)
- Benefit: Increased block production opportunities and associated rewards
- Risk: Low (appears as legitimate mining behavior, no active monitoring for malformed hash lengths)

### Recommendation

**Immediate Fix:**

Add length validation in `NewConsensusInformationFilled`:

```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    
    // Validate OutValue is exactly 32 bytes
    if (minerInRound.OutValue == null || minerInRound.OutValue.Value.Length != 32)
        return false;
    
    // Validate Signature is exactly 32 bytes  
    if (minerInRound.Signature == null || minerInRound.Signature.Value.Length != 32)
        return false;
        
    return true;
}
```

**Additional Hardening:**

Consider adding validation that `OutValue` from round N actually matches `HashHelper.ComputeFrom(PreviousInValue)` when PreviousInValue is revealed in round N+1, with penalties for mismatches.

**Test Cases:**

1. Reject `UpdateValue` with `OutValue.Value.Length == 1`
2. Reject `UpdateValue` with `Signature.Value.Length != 32`
3. Reject `UpdateValue` with `OutValue = null` or empty array
4. Accept only properly formatted 32-byte hash values

### Proof of Concept

**Initial State:**
- Attacker is an authorized miner in current round
- Current round number: N

**Attack Sequence:**

**Round N - Initial Exploitation:**
1. Attacker constructs `UpdateValueInput`:
   - `out_value`: Single byte `[0x42]` (not a valid 32-byte hash)
   - `signature`: Chosen bytes that hash to `ToInt64() % minersCount == 0` (gives order 1 in next round)
   - `previous_in_value`: Valid from round N-1 (passes validation)
2. Transaction passes validation at [1](#0-0)  (both `.Any()` return true)
3. Malformed values stored via [12](#0-11) 

**Round N+1 - Bypass Commit-Reveal:**
1. During block production, self-check at [13](#0-12)  fails (Hash(anything) ≠ single byte `[0x42]`)
2. System sets `previousInValue = Hash.Empty`
3. Block validation allows empty `PreviousInValue` per [6](#0-5) 
4. Attacker mines as order 1 due to chosen signature value
5. Attacker's signature now determines extra block producer selection for round N+2

**Round N+2+ - Sustained Advantage:**
- Repeat round N+1 behavior indefinitely
- Continue bypassing InValue revelation requirement
- Maintain favorable mining positions

**Success Condition:**
Attacker successfully mines multiple consecutive rounds with manipulated mining order while never revealing valid `InValue`, gaining disproportionate block production compared to honest miners following the commit-reveal protocol.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** src/AElf.Types/AElfConstants.cs (L7-7)
```csharp
        public const int HashByteArrayLength = 32;
```

**File:** protobuf/aedpos_contract.proto (L195-196)
```text
    // Calculated from current in value.
    aelf.Hash out_value = 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L80-85)
```csharp
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-245)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L112-122)
```csharp
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L68-68)
```csharp
            new MiningPermissionValidationProvider(),
```

**File:** protobuf/aelf/core.proto (L140-143)
```text
message Hash
{
    bytes value = 1;
}
```
