### Title
Missing Input Validation Enables Computational DOS via Oversized MinterList in NFT Create Function

### Summary
The `Create()` function in the NFT contract lacks upfront validation of the `MinterList` size, allowing attackers to pass lists with tens of thousands of addresses that trigger expensive O(n) iteration in the `Contains()` check before automatic state size validation rejects the transaction. The fee model charges only for transaction size, not computational complexity, making this attack economically rational and enabling operational DOS of NFT protocol creation. [1](#0-0) 

### Finding Description

The vulnerability exists in the `Create()` method at lines 36-38. The execution flow is:

1. Line 36 accepts an arbitrarily large `MinterList` from user input (up to 5 MB transaction limit) [2](#0-1) 

2. Line 37 performs `minterList.Value.Contains(creator)` which iterates through the entire list (O(n) complexity) [3](#0-2) 

3. Line 38 assigns to state, triggering automatic `ValidateStateSize()` which rejects lists exceeding 128 KB [4](#0-3) 

The root cause is the ordering: the expensive `Contains()` check executes BEFORE state size validation. The state size validation is automatically injected by the IL patcher before state writes, but this occurs after the O(n) iteration. [5](#0-4) 

**Why existing protections fail:**
- Transaction size limit (5 MB) allows ~154,000 addresses but state limit (128 KB) only allows ~3,855 addresses [6](#0-5) [7](#0-6) 

- State size validation happens too late (after Contains() check completes)
- Fee model charges for transaction bytes, not computational cost, making the attack economically viable [8](#0-7) 

The same vulnerability exists in the `AddMinters()` function which uses identical logic. [9](#0-8) 

### Impact Explanation

**Operational DOS of NFT Protocol Creation:**
- Attackers can force validators to process expensive Contains() iterations over lists 25-40x larger than what can actually be stored
- With 100,000 addresses (~3.4 MB), the Contains() check performs 100,000 comparisons before the transaction inevitably fails
- Repeated attacks fill blocks with computationally expensive failed transactions
- Legitimate users attempting to create NFT protocols experience delayed confirmations and degraded service
- Block processing slows as validators waste resources on doomed-to-fail transactions

**Quantified Impact:**
- Maximum exploitable list size: ~154,000 addresses (5 MB transaction limit)
- Maximum storable list size: ~3,855 addresses (128 KB state limit)  
- Computation waste factor: 40x (attacker forces 40x more iteration than necessary)
- Each attack transaction causes wasted O(n) operations where n can be 100,000+

This affects all users attempting to create NFT protocols and validators processing these transactions.

### Likelihood Explanation

**Reachable Entry Point:** The `Create()` function is publicly accessible to any caller on the AELF mainchain. [10](#0-9) 

**Feasible Preconditions:** No special permissions required. Attacker only needs to construct a `CreateInput` with an oversized `MinterList`. [11](#0-10) 

**Execution Practicality:** The attack is straightforward:
1. Construct `MinterList` with 100,000+ addresses (within transaction size limits)
2. Call `Create()` with this input
3. Transaction passes basic validation and enters execution
4. Contains() check processes all addresses
5. State size validation rejects it

**Economic Rationality:** The fee model makes this attack economically viable. Transaction fees consist of base fee + size fee, calculated based on transaction bytes, NOT computational complexity. An attacker pays for ~3.4 MB of data but causes computation proportional to 100,000 iterations. The computational cost imposed on validators exceeds the fee paid by the attacker. [12](#0-11) 

The attack can be repeated to sustain operational degradation, with each transaction having high probability of causing the intended computational waste.

### Recommendation

**1. Add upfront MinterList size validation:**
```csharp
// In Create() function, before line 36
var minterList = input.MinterList ?? new MinterList();
Assert(minterList.Value.Count <= MaxMinterListSize, 
    $"MinterList size {minterList.Value.Count} exceeds maximum allowed {MaxMinterListSize}");
```

Define `MaxMinterListSize` based on practical limits (recommended: ~1000 addresses, ensuring it stays well within the 128 KB state size limit considering serialization overhead).

**2. Apply the same validation to AddMinters():** [13](#0-12) 

Add validation to check both the input size and the resulting total list size.

**3. Add test cases:**
- Test Create() with MinterList exceeding MaxMinterListSize (should fail immediately)
- Test Create() with MinterList at boundary values
- Test AddMinters() with oversized inputs
- Performance test measuring execution time with various list sizes

**4. Consider using HashSet for minter storage:**
Replace `RepeatedField` with a more efficient data structure for Contains() checks to reduce complexity from O(n) to O(1), though upfront validation is still required.

### Proof of Concept

**Initial State:**
- NFT contract deployed on AELF mainchain
- Attacker has sufficient balance to pay transaction fees

**Attack Steps:**

1. Attacker constructs a `CreateInput` with:
   - Valid `nft_type`, `protocol_name`, `total_supply`, etc.
   - `minter_list` containing 100,000 generated addresses (~3.4 MB)

2. Attacker submits transaction calling `Create(CreateInput)`

3. Transaction passes basic validation (signature check, size check < 5 MB) [14](#0-13) 

4. During execution:
   - Line 36: `minterList` is set to the 100,000-address list
   - Line 37: `Contains(creator)` iterates through all 100,000 addresses
   - Line 38: State assignment triggers `ValidateStateSize()`, which throws `StateOverSizeException` because serialized size exceeds 128 KB [15](#0-14) 

5. Transaction fails with state size error, but validators already processed the expensive Contains() operation

**Expected Result:** Transaction fails immediately with input validation error before Contains() check

**Actual Result:** Transaction fails at state write, but only after wasting computation on 100,000-iteration Contains() check

**Success Condition:** Attacker successfully caused validators to waste computational resources processing a transaction that was guaranteed to fail, paying only transaction size fees while imposing disproportionate computational cost.

### Notes

While the security question mentions "millions of addresses," the actual maximum is constrained by the 5 MB transaction size limit to approximately 154,000 addresses (each address is ~34 bytes serialized). However, this is still sufficient to cause the described DOS condition, as it represents a 40x mismatch between what can be transmitted versus what can be stored, forcing expensive iteration before inevitable failure.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-17)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L36-38)
```csharp
        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;
```

**File:** src/AElf.CSharp.CodeOps/Instructions/IStateWrittenInstructionInjector.cs (L65-94)
```csharp
    public void InjectInstruction(ILProcessor ilProcessor, Instruction originInstruction,
        ModuleDefinition moduleDefinition)
    {
        ilProcessor.Body.SimplifyMacros();

        var localValCount = ilProcessor.Body.Variables.Count;
        ilProcessor.Body.Variables.Add(new VariableDefinition(moduleDefinition.ImportReference(typeof(object))));

        var stocInstruction =
            ilProcessor.Create(OpCodes.Stloc_S, ilProcessor.Body.Variables[localValCount]); // pop to local val 
        ilProcessor.InsertBefore(originInstruction, stocInstruction);

        var ldThisInstruction = ilProcessor.Create(OpCodes.Ldarg_0); // this
        ilProcessor.InsertAfter(stocInstruction, ldThisInstruction);

        var getContextInstruction = ilProcessor.Create(OpCodes.Call,
            moduleDefinition.ImportReference(typeof(CSharpSmartContractAbstract).GetProperty("Context")
                .GetMethod)); // get_Context
        ilProcessor.InsertAfter(ldThisInstruction, getContextInstruction);

        var ldlocInstruction =
            ilProcessor.Create(OpCodes.Ldloc_S, ilProcessor.Body.Variables[localValCount]); // load local val
        ilProcessor.InsertAfter(getContextInstruction, ldlocInstruction);

        var callInstruction = ilProcessor.Create(OpCodes.Callvirt, moduleDefinition.ImportReference(
            typeof(CSharpSmartContractContext).GetMethod(nameof(CSharpSmartContractContext.ValidateStateSize))));
        ilProcessor.InsertAfter(ldlocInstruction, callInstruction);

        ilProcessor.Body.OptimizeMacros();
    }
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L5-5)
```csharp
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-52)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L84-96)
```csharp
    private ChargeTransactionFeesOutput TryToChargeTransactionFee(ChargeTransactionFeesInput input, Address fromAddress,
        TransactionFeeBill bill, TransactionFreeFeeAllowanceBill allowanceBill, Dictionary<string, long> fee,
        bool isSizeFeeFree)
    {
        Context.LogDebug(() => "TryToChargeTransactionFee Start");
        var chargingResult =
            ChargeTransactionFeesToBill(input, fromAddress, ref bill, ref allowanceBill, fee, isSizeFeeFree);
        if (!chargingResult)
        {
            var delegatorAddress = fromAddress;
            chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                isSizeFeeFree, delegatorAddress);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-353)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol] ?? new MinterList();

        foreach (var minter in input.MinterList.Value)
            if (!minterList.Value.Contains(minter))
                minterList.Value.Add(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListAdded
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** protobuf/nft_contract.proto (L109-130)
```text
message CreateInput {
    // The type of this nft protocol.
    string nft_type = 1;
    // The name of this nft protocol.
    string protocol_name = 2;
    // The total supply of the token.
    int64 total_supply = 3;
    // The address that created the token.
    aelf.Address creator = 4;
    // A flag indicating if this token is burnable.
    bool is_burnable = 5;
    // The chain id of the token.
    int32 issue_chain_id = 6;
    // The metadata of the token.
    Metadata metadata = 7;
    // Base Uri.
    string base_uri = 8;
    // Is token id can be reused.
    bool is_token_id_reuse = 9;
    // Initial minter list (creator will be added automatically)
    MinterList minter_list = 10;
}
```

**File:** src/AElf.Kernel.TransactionPool/Infrastructure/BasicTransactionValidationProvider.cs (L32-41)
```csharp
        if (transaction.CalculateSize() > TransactionPoolConsts.TransactionSizeLimit)
        {
            await LocalEventBus.PublishAsync(new TransactionValidationStatusChangedEvent
            {
                TransactionId = transactionId,
                TransactionResultStatus = TransactionResultStatus.NodeValidationFailed,
                Error = "Transaction size exceeded."
            });
            return false;
        }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L148-160)
```csharp
    public object ValidateStateSize(object obj)
    {
        var stateSizeLimit = AsyncHelper.RunSync(() => _smartContractBridgeService.GetStateSizeLimitAsync(
            new ChainContext
            {
                BlockHash = _transactionContext.PreviousBlockHash,
                BlockHeight = _transactionContext.BlockHeight - 1
            }));
        var size = SerializationHelper.Serialize(obj).Length;
        if (size > stateSizeLimit)
            throw new StateOverSizeException($"State size {size} exceeds limit of {stateSizeLimit}.");
        return obj;
    }
```
