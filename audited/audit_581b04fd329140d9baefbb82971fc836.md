# Audit Report

## Title
TokenHash Collision via Ambiguous String Concatenation Causes NFT State Corruption

## Summary
The `CalculateTokenHash` function in the NFT contract uses undelimited string concatenation of symbol and tokenId, enabling hash collisions between different NFT protocols when symbol number lengths vary. This allows multiple distinct NFTs to share the same storage slot, corrupting ownership data, balances, and metadata.

## Finding Description

The vulnerability originates from the tokenHash calculation mechanism. [1](#0-0) 

NFT protocol symbols are generated with the format `{2-letter-code}{number}`. [2](#0-1) 

The number portion starts at 9 digits minimum. [3](#0-2) 

The number length dynamically increases as more protocols are created. [4](#0-3) 

This creates ambiguous concatenation scenarios:
- Protocol A: symbol "AR100000000" + tokenId 123 → "AR100000000123"
- Protocol B: symbol "AR1000000001" + tokenId 23 → "AR100000000123"

Both produce identical hash inputs, resulting in the same tokenHash.

During minting, this tokenHash is used to retrieve and store NFTInfo. [5](#0-4) 

When a protocol has `IsTokenIdReuse=true`, the uniqueness check is bypassed, allowing the code to modify existing NFTInfo from a completely different protocol. [6](#0-5) 

The corrupted state is then saved to all storage maps. [7](#0-6) 

There is no validation confirming that the retrieved NFTInfo's symbol and tokenId match the requested values. [8](#0-7) 

## Impact Explanation

**Critical State Corruption:**
- Multiple distinct NFTs from different protocols share the same storage slot in `State.NftInfoMap[tokenHash]`
- Balance mappings in `State.BalanceMap[tokenHash]` become mixed between unrelated NFTs
- Allowances, assembled NFTs/FTs, and all token-specific state are improperly shared

**Ownership and Value Corruption:**
- When Protocol B mints a colliding tokenId, it increments the quantity and adds its minter to Protocol A's NFTInfo
- Transfers of one NFT affect balances of the other
- Burns can destroy the wrong NFT's quantity
- Users querying GetNFTInfo receive incorrect symbol/tokenId data

This violates the fundamental invariant of NFT uniqueness and ownership isolation. The vulnerability enables theft through balance manipulation, permanent state corruption through data mixing, loss of funds through burns affecting wrong tokens, and complete protocol breakdown as NFT identity becomes ambiguous.

## Likelihood Explanation

**Attacker Capabilities:**
- Must be a minter for a protocol with `IsTokenIdReuse=true`
- Can create such a protocol or be added to an existing protocol's minter list
- No special system privileges required beyond normal protocol participation

**Attack Complexity:**
- Straightforward calculation of colliding (symbol, tokenId) pairs using publicly observable symbol format rules
- Symbol generation logic is deterministic and observable on-chain
- Attacker simply mints with the calculated colliding tokenId

**Feasibility Conditions:**
- Guaranteed to occur naturally: As protocols are created, symbol number lengths WILL transition from 9 to 10+ digits by design
- Both 9-digit and 10+ digit symbols will coexist in the system simultaneously
- Any protocol with `IsTokenIdReuse=true` enables the attack vector

**Economic Rationality:**
- Attack cost: Standard minting fees only
- Potential gain: Ability to corrupt high-value NFT ownership data and manipulate balances
- Risk: Low, as minting appears as a normal operation

The vulnerability has HIGH likelihood because symbol length transitions are inevitable in the protocol's design, making collisions a certainty rather than a possibility.

## Recommendation

Use a delimiter or structured encoding in the `CalculateTokenHash` function to prevent ambiguous concatenation:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}|{tokenId}");
}
```

Alternatively, use structured hashing:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(symbol),
        HashHelper.ComputeFrom(tokenId)
    );
}
```

Additionally, add validation in `PerformMint` to verify that retrieved NFTInfo matches the requested symbol and tokenId:

```csharp
if (nftInfo != null && (nftInfo.Symbol != input.Symbol || nftInfo.TokenId != tokenId))
{
    throw new AssertionException($"TokenHash collision detected for {input.Symbol}:{tokenId}");
}
```

## Proof of Concept

```csharp
[Fact]
public void TokenHashCollision_CausesStateCorruption()
{
    // Setup: Create Protocol A with 9-digit suffix
    var protocolASymbol = "AR100000000"; // AR + 9 digits
    CreateNFTProtocol(protocolASymbol, isTokenIdReuse: false);
    
    // Mint NFT on Protocol A with tokenId 123
    MintNFT(protocolASymbol, tokenId: 123, owner: UserA);
    var hashA = CalculateTokenHash(protocolASymbol, 123);
    var balanceA = GetBalance(protocolASymbol, 123, UserA);
    Assert.Equal(1, balanceA);
    
    // Setup: Create Protocol B with 10-digit suffix
    var protocolBSymbol = "AR1000000001"; // AR + 10 digits
    CreateNFTProtocol(protocolBSymbol, isTokenIdReuse: true);
    
    // Attack: Mint on Protocol B with colliding tokenId 23
    MintNFT(protocolBSymbol, tokenId: 23, owner: UserB);
    var hashB = CalculateTokenHash(protocolBSymbol, 23);
    
    // Verify collision: Both hashes are identical
    Assert.Equal(hashA, hashB);
    
    // Verify state corruption: Protocol A's NFT info contains Protocol B's minter
    var nftInfo = GetNFTInfo(protocolASymbol, 123);
    Assert.Contains(UserB, nftInfo.Minters); // Protocol B's minter in Protocol A's data
    Assert.Equal(2, nftInfo.Quantity); // Quantity increased from Protocol B's mint
    
    // Verify balance corruption: Protocol B's mint affected Protocol A's balance map
    var corruptedBalance = GetBalanceByTokenHash(hashA, UserA);
    Assert.NotEqual(balanceA, corruptedBalance); // Balance corrupted
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L46-55)
```csharp
    private void DoTransfer(Hash tokenHash, Address from, Address to, long amount)
    {
        if (amount < 0) throw new AssertionException("Invalid transfer amount.");

        if (amount == 0) return;

        Assert(State.BalanceMap[tokenHash][from] >= amount, "Insufficient balance.");
        State.BalanceMap[tokenHash][from] = State.BalanceMap[tokenHash][from].Sub(amount);
        State.BalanceMap[tokenHash][to] = State.BalanceMap[tokenHash][to].Add(amount);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L383-396)
```csharp
    private NFTMinted PerformMint(MintInput input, bool isTokenIdMustBeUnique = false)
    {
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        if (protocolInfo == null) throw new AssertionException($"Invalid NFT Token symbol: {input.Symbol}");

        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L433-441)
```csharp
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }

        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L87-116)
```csharp
    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L14-30)
```csharp
    public override NFTInfo GetNFTInfo(GetNFTInfoInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        return GetNFTInfoByTokenHash(tokenHash);
    }

    public override NFTInfo GetNFTInfoByTokenHash(Hash input)
    {
        var nftInfo = State.NftInfoMap[input];
        if (nftInfo == null) return new NFTInfo();
        var nftProtocolInfo = State.NftProtocolMap[nftInfo.Symbol];
        nftInfo.ProtocolName = nftProtocolInfo.ProtocolName;
        nftInfo.Creator = nftProtocolInfo.Creator;
        nftInfo.BaseUri = nftProtocolInfo.BaseUri;
        nftInfo.NftType = nftProtocolInfo.NftType;
        return nftInfo;
    }
```
