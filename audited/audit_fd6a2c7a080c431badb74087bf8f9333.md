### Title
Consensus DoS via Malicious ConfirmedIrreversibleBlockHeight in NextRound Transaction

### Summary
An authorized miner can cause consensus failure by providing a malicious `ConfirmedIrreversibleBlockHeight` value greater than the current block height in a `NextRound` transaction. The value is not validated during the NextRound behavior validation phase, gets stored in state, and subsequently causes an `OverflowException` when `GetMaximumBlocksCount()` attempts to subtract it from the current height.

### Finding Description

The vulnerability exists in the consensus round transition logic where `LibInformationValidationProvider` is selectively applied only to `UpdateValue` behavior but not to `NextRound` or `NextTerm` behaviors. [1](#0-0) 

When a miner calls `NextRound`, the input passes through `ValidateBeforeExecution` which only applies `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` - neither of which validates the `ConfirmedIrreversibleBlockHeight` field. [2](#0-1) 

The malicious `NextRoundInput` is converted to a `Round` object with the attacker-controlled `ConfirmedIrreversibleBlockHeight` value preserved: [3](#0-2) 

This malicious round is stored in state: [4](#0-3) 

Immediately after processing the round transition, `GetMaximumBlocksCount()` is called, which reads the newly stored round and attempts to compute the distance: [5](#0-4) 

When the blockchain enters "Severe" status, the code attempts to subtract `libBlockHeight` from `currentHeight`: [6](#0-5) 

Since `.Sub()` uses checked arithmetic, if `libBlockHeight > currentHeight`, an `OverflowException` is thrown: [7](#0-6) 

### Impact Explanation

**Operational Impact - Consensus DoS:**
- The consensus transaction fails with an unhandled exception
- The block containing this transaction becomes invalid
- Blockchain consensus is disrupted as the malicious miner's block cannot be validated
- Other nodes will reject the block, causing a fork or consensus stall
- This can be repeatedly exploited by any malicious miner in subsequent rounds

**Affected Parties:**
- All blockchain participants experience consensus disruption
- Legitimate transactions cannot be processed during the attack
- The network's availability and liveness are compromised

**Severity Justification:**
Medium severity - while this requires the attacker to be an authorized miner (limiting the attack surface), the impact is significant as it directly disrupts consensus. The attack is low-cost (single transaction) and repeatable.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an authorized miner in the current or previous round
- This is a realistic assumption in a DPoS system where miners are elected/rotated
- No additional privileges beyond normal miner authority are required

**Attack Complexity:**
- Low complexity - attacker simply crafts a `NextRoundInput` with `ConfirmedIrreversibleBlockHeight` set to `Context.CurrentHeight + X` where X > 0
- The malicious input passes all validation checks
- Single transaction execution causes the DoS

**Feasibility Conditions:**
- Blockchain must reach the condition where `ProcessConsensusInformation` calls `GetMaximumBlocksCount()`
- This happens on every consensus behavior (UpdateValue, NextRound, NextTerm, TinyBlock)
- The stored malicious value persists and affects subsequent operations

**Detection/Operational Constraints:**
- The attack is immediately detectable (block validation fails)
- However, prevention is not currently in place as the validation gap exists
- No economic cost to the attacker beyond normal transaction fees

**Probability:** High - the validation gap is systematic, and any miner can exploit it during their turn to produce blocks.

### Recommendation

**Add LIB Height Validation for NextRound Behavior:**

Modify the validation logic to include `LibInformationValidationProvider` for `NextRound` and `NextTerm` behaviors: [8](#0-7) 

Add the provider to both NextRound and NextTerm cases:
```
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // Add this
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // Add this
    break;
```

**Enhanced Validation:**

Additionally, add an explicit check in `LibInformationValidationProvider` to ensure `ConfirmedIrreversibleBlockHeight <= Context.CurrentHeight`:

```csharp
if (providedRound.ConfirmedIrreversibleBlockHeight > Context.CurrentHeight)
{
    validationResult.Message = "LIB height cannot exceed current block height.";
    return validationResult;
}
```

**Test Cases:**
1. Attempt NextRound with `ConfirmedIrreversibleBlockHeight = Context.CurrentHeight + 1` - should fail validation
2. Attempt NextRound with `ConfirmedIrreversibleBlockHeight = Context.CurrentHeight` - should succeed
3. Verify GetMaximumBlocksCount never receives invalid LIB heights

### Proof of Concept

**Initial State:**
- Blockchain at height 1000
- Current round R with `ConfirmedIrreversibleBlockHeight = 950`
- Malicious miner M is authorized in current round

**Attack Steps:**

1. **Miner M crafts malicious NextRoundInput:**
   - Set all standard fields correctly (round number, term number, miner information)
   - Set `ConfirmedIrreversibleBlockHeight = 10000` (>> current height of 1000)
   - Set `ConfirmedIrreversibleBlockRoundNumber` appropriately

2. **Miner M includes NextRound transaction in their block at height 1001:**
   - Transaction passes `PreCheck()` (M is authorized miner)
   - Transaction passes `ValidateBeforeExecution()`:
     - `MiningPermissionValidationProvider` ✓
     - `TimeSlotValidationProvider` ✓
     - `NextRoundMiningOrderValidationProvider` ✓
     - `RoundTerminateValidationProvider` ✓
     - `LibInformationValidationProvider` NOT CALLED ✗

3. **Transaction executes:**
   - `ProcessNextRound()` stores round with `ConfirmedIrreversibleBlockHeight = 10000`
   - `GetMaximumBlocksCount()` is called
   - Retrieves current round with malicious LIB height
   - `currentHeight = 1001`, `libBlockHeight = 10000`
   - Attempts: `currentHeight.Sub(libBlockHeight)` → `1001.Sub(10000)`
   - **OverflowException thrown**

4. **Result:**
   - Consensus transaction fails
   - Block becomes invalid
   - Consensus disrupted

**Expected vs Actual:**
- **Expected:** Malicious LIB height should be rejected during validation
- **Actual:** Malicious LIB height passes validation and causes consensus failure

**Success Condition:** The NextRound transaction with malicious `ConfirmedIrreversibleBlockHeight` should fail validation with message "Incorrect lib information" before execution begins.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L67-69)
```csharp
        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L1-10)
```csharp
﻿using System.Numerics;
using AElf.Types;

namespace AElf.CSharp.Core;

/// <summary>
///     Helper methods for safe math operations that explicitly check for overflow.
/// </summary>
public static class SafeMath
{
```
