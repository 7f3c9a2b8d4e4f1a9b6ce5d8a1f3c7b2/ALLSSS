### Title
Leading Zero Bypass Allows Duplicate NFT ItemIds in String Form

### Summary
The `IsValidItemId()` function accepts numeric strings with leading zeros (e.g., "001", "01", "1") without normalization, allowing collection owners to create multiple distinct NFTs that represent the same numeric itemId. This violates the expected uniqueness invariant of NFT itemIds and can cause serious integration issues with external systems that normalize itemIds numerically.

### Finding Description

The vulnerability exists in the NFT itemId validation logic at [1](#0-0) 

The `IsValidItemId()` function uses regex pattern `^[0-9]+$` which accepts any string of digits, including those with leading zeros. No normalization occurs when tokens are created, stored, or retrieved.

When an NFT is created, the symbol (format: `{CollectionPrefix}-{ItemId}`) is stored directly as a string key in the state without any canonicalization. The validation flow is:

1. `Create()` calls `GetSymbolType()` which validates itemId using `IsValidItemId()` [2](#0-1) 

2. For NFT creation, `CreateNFTInfo()` is invoked [3](#0-2) 

3. Eventually `CreateToken()` calls `CheckTokenExists()` to prevent duplicates [4](#0-3) 

4. `CheckTokenExists()` performs two checks:
   - Direct lookup: `GetTokenInfo(symbol)` [5](#0-4) 
   - Case-insensitive check: `State.InsensitiveTokenExisting[symbol.ToUpper()]`

However, `ToUpper()` on numeric strings does not normalize leading zeros ("TT-1" remains "TT-1" and "TT-01" remains "TT-01"), so the checks fail to detect numeric duplicates.

5. Token registration stores the exact symbol string: [6](#0-5) 

All subsequent operations (balance queries, transfers, approvals) use the exact string representation without normalization [7](#0-6) 

### Impact Explanation

**Semantic Uniqueness Violation**: The critical invariant that each NFT within a collection has a unique itemId is violated from a numeric/semantic perspective. While technically different strings, "COLLECTION-1", "COLLECTION-01", and "COLLECTION-001" all represent itemId "1" numerically.

**External System Integration Failures**: 
- Off-chain indexers and marketplaces that normalize itemIds to integers will see collisions
- Cross-protocol interactions may route operations to wrong NFT instances
- Analytics and tracking systems will report inconsistent NFT counts
- User interfaces may display only one variant, hiding the existence of others

**Operational Confusion**:
- Users may unknowingly create or purchase duplicate-semantic NFTs
- Collection metadata and rarity tracking becomes unreliable
- Audit trails and provenance tracking are complicated

**Not Direct Fund Loss**: This does not allow unauthorized minting beyond collection owner permissions, nor does it enable direct theft. However, it fundamentally breaks the NFT uniqueness model that external systems rely upon.

The severity is **Medium** because while it doesn't cause immediate fund loss, it creates serious operational and integration issues that violate protocol invariants and could lead to secondary value losses in ecosystem interactions.

### Likelihood Explanation

**Attacker Profile**: Any NFT collection owner can exploit this. Collection owners are authorized to create NFTs in their collections [8](#0-7) 

**Attack Complexity**: Trivial. The attacker simply:
1. Creates NFT with symbol "COLLECTION-1"
2. Creates NFT with symbol "COLLECTION-01" 
3. Creates NFT with symbol "COLLECTION-001"
All three succeed with no special conditions required.

**Feasibility**: 
- No additional permissions needed beyond being collection owner
- No economic cost beyond standard gas fees
- No timing or state dependencies
- Exploitation leaves no immediately visible traces

**Detection Difficulty**: The vulnerability is subtle and may go unnoticed until external systems report inconsistencies. The test suite does not cover this scenario [9](#0-8) 

**Probability**: High. While collection owners are typically trusted, a compromised owner account, malicious project, or simple mistake could trigger this. The ease of exploitation makes accidental triggering likely.

### Recommendation

**Immediate Fix**: Normalize itemIds by removing leading zeros in `IsValidItemId()`:

```csharp
private bool IsValidItemId(string symbolItemId)
{
    if (!Regex.IsMatch(symbolItemId, "^[0-9]+$"))
        return false;
    
    // Reject itemIds with leading zeros (except "0" itself)
    if (symbolItemId.Length > 1 && symbolItemId[0] == '0')
        return false;
    
    return true;
}
```

**Alternative Approach**: Normalize itemIds during validation by converting to integer and back to canonical string form, then enforce that the input matches the canonical form.

**State Migration**: For existing tokens, consider:
1. Documenting that leading-zero variants are distinct tokens
2. Providing a migration path to burn duplicates if desired
3. Adding warnings in UIs about potential semantic duplicates

**Test Cases**: Add regression tests for:
- Creating "COLLECTION-1" succeeds
- Creating "COLLECTION-01" fails with "Invalid NFT Symbol"
- Creating "COLLECTION-001" fails with "Invalid NFT Symbol"
- Verify "0" is still accepted as valid itemId

### Proof of Concept

**Initial State**:
- NFT collection "ABC-0" exists
- Collection owner is authorized to create NFTs

**Attack Steps**:
1. Collection owner calls `Create()` with symbol "ABC-1" (succeeds)
2. Collection owner calls `Create()` with symbol "ABC-01" (succeeds - should fail)
3. Collection owner calls `Create()` with symbol "ABC-001" (succeeds - should fail)

**Expected Result**: 
- Only "ABC-1" should be created
- "ABC-01" and "ABC-001" should fail validation

**Actual Result**:
- All three NFTs are created as distinct tokens
- Each has separate balance tracking, approval lists, and ownership
- External systems normalizing "1", "01", "001" to integer 1 see conflicts

**Success Condition for Exploit**:
Query `GetTokenInfo("ABC-1")`, `GetTokenInfo("ABC-01")`, and `GetTokenInfo("ABC-001")` - all three return distinct TokenInfo objects, confirming three separate NFTs exist for the same semantic itemId.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L23-26)
```csharp
    private bool IsValidItemId(string symbolItemId)
    {
        return Regex.IsMatch(symbolItemId, "^[0-9]+$");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L285-293)
```csharp
    private void CheckTokenAndCollectionExists(string symbol)
    {
        var symbols = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        var tokenSymbol = symbols.First();
        CheckTokenExists(tokenSymbol);
        var collectionSymbol = symbols.First() + TokenContractConstants.NFTSymbolSeparator +
                               TokenContractConstants.CollectionSymbolSuffix;
        CheckTokenExists(collectionSymbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L12-12)
```csharp
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L40-45)
```csharp
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L286-294)
```csharp
    private string GetActualTokenSymbol(string aliasOrSymbol)
    {
        if (State.TokenInfos[aliasOrSymbol] == null)
        {
            return State.SymbolAliasMap[aliasOrSymbol] ?? aliasOrSymbol;
        }

        return aliasOrSymbol;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L35-36)
```csharp
        var owner = nftCollectionInfo.Owner ?? nftCollectionInfo.Issuer;
        Assert(Context.Sender == owner && owner == input.Owner, "NFT owner must be collection's owner");
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/NftApplicationTests.cs (L436-454)
```csharp
    [Fact(DisplayName = "[MultiToken_Nft] Create already exist nft")]
    public async Task MultiTokenContract_Create_NFT_Already_Exist()
    {
        await CreateNftCollectionAndNft(false);
        var input = Nft721Info;
        var result = await TokenContractStub.Create.SendWithExceptionAsync(new CreateInput
        {
            Symbol = $"{NftCollection721Info.Symbol}{input.Symbol}",
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IssueChainId = input.IssueChainId,
            ExternalInfo = input.ExternalInfo,
            Owner = input.Owner
        });
        result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        result.TransactionResult.Error.ShouldContain("Token already exists.");
    }
```
