### Title
Missing Authorization on SetPrimaryTokenSymbol Allows Permanent Primary Token Hijacking

### Summary
The `SetPrimaryTokenSymbol()` function lacks any authorization check, allowing any address to set the chain's primary token symbol once. An attacker can front-run the legitimate initialization by calling this function with any existing valid token, permanently locking the primary token to an incorrect value. This breaks critical chain functionality including transaction fee calculations and contract deployment authorization.

### Finding Description

The `SetPrimaryTokenSymbol()` function in `TokenContract_Actions.cs` contains only two checks: [1](#0-0) 

The function validates that (1) the primary token hasn't been set yet and (2) the input symbol exists as a valid token. **Critically, there is no authorization check** to verify who can call this function. This is in stark contrast to other administrative functions that properly use authorization: [2](#0-1) 

The primary token symbol is used throughout critical system operations:

**Transaction fee calculation:** [3](#0-2) [4](#0-3) 

**Contract deployment authorization:** [5](#0-4) 

**Fee token weight validation:** [6](#0-5) 

While normal initialization includes `SetPrimaryTokenSymbol` in the atomic deployment transaction: [7](#0-6) 

The vulnerability exists because **after contract deployment but before/if initialization completes**, or in any scenario where the primary token is not set during initialization, the function is publicly callable without authorization.

### Impact Explanation

**Critical System Breakage:**
1. **Transaction Fee Mechanism**: If an incorrect token is set as primary, the fee calculation logic will use the wrong token for all transaction fees, potentially allowing free transactions or breaking fee collection entirely
2. **Contract Deployment Authorization**: The deployment authorization check will compare against the wrong primary token symbol, potentially bypassing security controls that restrict contract deployment to chains with specific primary tokens
3. **Permanent Lock**: The one-time-only constraint (`State.ChainPrimaryTokenSymbol.Value == null`) means once an attacker sets an incorrect primary token, it **cannot be corrected** - the chain is permanently misconfigured
4. **Fee Weight Configuration**: Setting fee token weights requires the primary token to be in the list with weight=1, which will fail validation if the wrong primary token is set

**Who is Affected:**
- All users attempting to submit transactions (incorrect fee token)
- Chain operators (cannot deploy contracts correctly)
- Governance (cannot fix the issue once set incorrectly)

**Severity Justification:**
This is HIGH severity because it enables permanent operational DoS of critical chain functions with no recovery mechanism, affecting the entire chain ecosystem.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker only needs to monitor mempool for chain initialization
- No special privileges required
- Must have access to submit transactions during the initialization window

**Attack Complexity:**
- LOW - Single transaction call with a valid token symbol
- Any existing token on the chain can be used
- No complex state manipulation required

**Feasibility Conditions:**
- Vulnerability window exists if:
  - Token contract is deployed but `SetPrimaryTokenSymbol` not yet called
  - Initialization fails or is incomplete
  - Custom initialization sequences don't include the call
  - Manual setting is attempted post-deployment

**Detection Constraints:**
- Attack is trivially detectable (event `ChainPrimaryTokenSymbolSet` is fired), but **irreversible** once executed

**Probability:**
- MEDIUM-HIGH likelihood during chain initialization phase
- Testing confirms any address can call the function: [8](#0-7) 

### Recommendation

**Immediate Fix:**
Add authorization check to `SetPrimaryTokenSymbol()` requiring Parliament controller or contract owner:

```csharp
public override Empty SetPrimaryTokenSymbol(SetPrimaryTokenSymbolInput input)
{
    // Add this line:
    AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
    
    Assert(State.ChainPrimaryTokenSymbol.Value == null, "Failed to set primary token symbol.");
    Assert(!string.IsNullOrWhiteSpace(input.Symbol) && GetTokenInfo(input.Symbol) != null, "Invalid input symbol.");
    
    State.ChainPrimaryTokenSymbol.Value = input.Symbol;
    Context.Fire(new ChainPrimaryTokenSymbolSet { TokenSymbol = input.Symbol });
    return new Empty();
}
```

**Additional Safeguards:**
1. Validate that the input symbol matches `Context.Variables.NativeSymbol` or is explicitly approved
2. Add governance-controlled mechanism to reset primary token symbol in emergency scenarios
3. Ensure all initialization sequences include `SetPrimaryTokenSymbol` atomically with contract deployment

**Test Cases:**
1. Verify unauthorized addresses cannot call `SetPrimaryTokenSymbol`
2. Verify only Parliament controller can call the function
3. Verify correct primary token is set during initialization
4. Test that attempting to set wrong primary token fails authorization

### Proof of Concept

**Initial State:**
- Token contract deployed
- Native token "ELF" created
- Attacker token "ATTACK" created by attacker
- `State.ChainPrimaryTokenSymbol.Value == null`

**Attack Steps:**
1. Attacker monitors for chain initialization
2. Before legitimate `SetPrimaryTokenSymbol("ELF")` transaction executes
3. Attacker submits: `SetPrimaryTokenSymbol("ATTACK")` with higher gas price
4. Attacker's transaction executes first
5. Primary token permanently set to "ATTACK"

**Expected Result:**
Primary token should be "ELF" and only settable by authorized address

**Actual Result:**
- Primary token is "ATTACK"
- Fee calculations use "ATTACK" token
- Contract deployment authorization checks "ATTACK" instead of "ELF"
- Cannot be corrected (one-time-only constraint)
- Chain functionality permanently broken

**Success Condition:**
Call `GetPrimaryTokenSymbol()` returns "ATTACK" instead of "ELF", and subsequent call to `SetPrimaryTokenSymbol("ELF")` fails with "Failed to set primary token symbol."

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L139-147)
```csharp
    public override Empty SetPrimaryTokenSymbol(SetPrimaryTokenSymbolInput input)
    {
        Assert(State.ChainPrimaryTokenSymbol.Value == null, "Failed to set primary token symbol.");
        Assert(!string.IsNullOrWhiteSpace(input.Symbol) && GetTokenInfo(input.Symbol) != null, "Invalid input symbol.");

        State.ChainPrimaryTokenSymbol.Value = input.Symbol;
        Context.Fire(new ChainPrimaryTokenSymbolSet { TokenSymbol = input.Symbol });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L462-467)
```csharp
    public override Empty AddAddressToCreateTokenWhiteList(Address input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        State.CreateTokenWhiteListMap[input] = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-32)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L381-390)
```csharp
        Context.LogDebug(() => "ChargeSizeFee Start");

        //If delegation != null,from address->delegateeAddress
        // Size Fee is charged in primary token, elf.
        var symbolToPayTxFee = State.ChainPrimaryTokenSymbol.Value;
        //Get primary token balance
        GetAvailableBalance(symbolToPayTxFee, fromAddress, bill, transactionFeeFreeAllowancesMap, allowanceBill,
            out var symbolChargedForBaseFee, out var amountChargedForBaseFee, out var amountChargedForBaseAllowance,
            out var availableBalance, out var availableAllowance);
        var txSizeFeeAmount = input.TransactionSizeFee;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L620-640)
```csharp
            throw new AssertionException("invalid input");
        var isPrimaryTokenExist = false;
        var symbolList = new List<string>();
        var primaryTokenSymbol = GetPrimaryTokenSymbol(new Empty());
        Assert(!string.IsNullOrEmpty(primaryTokenSymbol.Value), "primary token does not exist");
        foreach (var tokenWeightInfo in input.SymbolsToPayTxSizeFee)
        {
            if (tokenWeightInfo.TokenSymbol == primaryTokenSymbol.Value)
            {
                isPrimaryTokenExist = true;
                Assert(tokenWeightInfo.AddedTokenWeight == 1 && tokenWeightInfo.BaseTokenWeight == 1,
                    $"symbol:{tokenWeightInfo.TokenSymbol} weight should be 1");
            }

            Assert(tokenWeightInfo.AddedTokenWeight > 0 && tokenWeightInfo.BaseTokenWeight > 0,
                $"symbol:{tokenWeightInfo.TokenSymbol} weight should be greater than 0");
            Assert(!symbolList.Contains(tokenWeightInfo.TokenSymbol),
                $"symbol:{tokenWeightInfo.TokenSymbol} repeat");
            AssertSymbolToPayTxFeeIsValid(tokenWeightInfo.TokenSymbol, out var addedTokenTotalSupply);
            symbolList.Add(tokenWeightInfo.TokenSymbol);
        }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L344-357)
```csharp
    private void AssertUserDeployContract()
    {
        // Only the symbol of main chain or public side chain is native symbol.
        RequireTokenContractContractAddressSet();
        var primaryTokenSymbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;
        if (Context.Variables.NativeSymbol == primaryTokenSymbol)
        {
            return;
        }

        RequireParliamentContractAddressSet();
        var whitelist = State.ParliamentContract.GetProposerWhiteList.Call(new Empty());
        Assert(whitelist.Proposers.Contains(Context.Sender), "No permission.");
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L42-68)
```csharp
    private void CreateNativeToken(InitialEconomicSystemInput input)
    {
        var lockWhiteListBackups = new List<Address>
        {
            Context.GetContractAddressByName(SmartContractConstants.VoteContractSystemName),
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName),
            Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName),
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName),
            Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName),
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName)
        };
        var lockWhiteList = lockWhiteListBackups.Where(address => address != null).ToList();
        State.TokenContract.Create.Send(new CreateInput
        {
            Symbol = input.NativeTokenSymbol,
            TokenName = "Native Token",
            TotalSupply = input.NativeTokenTotalSupply,
            Decimals = input.NativeTokenDecimals,
            IsBurnable = input.IsNativeTokenBurnable,
            Issuer = Context.Self,
            LockWhiteList = { lockWhiteList },
            Owner = Context.Self
        });

        State.TokenContract.SetPrimaryTokenSymbol.Send(new SetPrimaryTokenSymbolInput
            { Symbol = input.NativeTokenSymbol });
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenManagementTests.cs (L513-534)
```csharp
    [Fact]
    public async Task SetPrimaryToken_Test()
    {
        var setPrimaryTokenRet = await TokenContractStub.SetPrimaryTokenSymbol.SendWithExceptionAsync(
            new SetPrimaryTokenSymbolInput
            {
                Symbol = "NOTEXISTED"
            });
        setPrimaryTokenRet.TransactionResult.Error.ShouldContain("Invalid input");
        await TokenContractStub.SetPrimaryTokenSymbol.SendAsync(new SetPrimaryTokenSymbolInput
        {
            Symbol = NativeTokenInfo.Symbol
        });
        var primaryToken = await TokenContractStub.GetPrimaryTokenSymbol.CallAsync(new Empty());
        primaryToken.Value.ShouldBe(NativeTokenInfo.Symbol);
        setPrimaryTokenRet = await TokenContractStub.SetPrimaryTokenSymbol.SendWithExceptionAsync(
            new SetPrimaryTokenSymbolInput
            {
                Symbol = NativeTokenInfo.Symbol
            });
        setPrimaryTokenRet.TransactionResult.Error.ShouldContain("Failed to set primary token symbol");
    }
```
