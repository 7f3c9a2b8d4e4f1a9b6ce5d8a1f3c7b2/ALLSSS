### Title
Byzantine Miners Can Permanently Hide In-Values by Exploiting Skip-Self Logic and Lack of Encrypted Pieces Enforcement

### Summary
Byzantine miners can exploit the skip-self logic in `RevealSharedInValues()` by deliberately not providing encrypted secret shares while simultaneously not revealing their `PreviousInValue` directly. This prevents any mechanism from revealing their in-values, while honest miners who do provide encrypted pieces remain vulnerable to having their in-values revealed. This breaks the accountability and randomness properties of the consensus mechanism.

### Finding Description

The vulnerability exists in the secret sharing mechanism's design, specifically in `RevealSharedInValues()` function. [1](#0-0) 

The function skips revealing the caller's own in-value at line 28. While this is intentional design (miners should reveal their own in-values directly), it creates an exploitable asymmetry when combined with two other facts:

1. The system explicitly permits miners not to publish their in-values: [2](#0-1) 

2. Validation allows null or empty `PreviousInValue`: [3](#0-2) 

3. Secret sharing revelation requires sufficient encrypted pieces from the target miner: [4](#0-3) 

The same skip-self logic exists in the off-chain service: [5](#0-4) 

**Attack Path:**
1. Byzantine miner A does NOT provide encrypted pieces (or provides fewer than the 2/3 threshold) in round N
2. When mining in round N+1, miner A does NOT provide `PreviousInValue` (validation passes)
3. Other miners cannot reveal A's in-value through secret sharing because insufficient encrypted pieces exist (lines 35-36 prevent it)
4. The skip-self logic ensures A doesn't reveal their own in-value
5. Result: A's in-value from round N is permanently hidden

Meanwhile, honest miners who DO provide encrypted pieces have their in-values revealed by others through the `MinersPreviousInValues` mechanism: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Impact:**
- In-values contribute to signature calculations which determine the next extra block producer: [7](#0-6) 
- Hidden in-values reduce the entropy and unpredictability of consensus randomness
- Byzantine miners can potentially manipulate which miner becomes the extra block producer

**Accountability Impact:**
- In-values are meant to provide cryptographic accountability for miner behavior
- Hidden in-values allow Byzantine miners to escape accountability while honest miners remain accountable
- This creates an unfair advantage for malicious actors

**Fairness Impact:**
- Asymmetric revelation (honest miners' in-values revealed, Byzantine miners' hidden) violates the fairness property of the consensus mechanism
- Byzantine miners gain information advantage over honest participants

The severity is Medium because while it doesn't directly steal funds, it compromises consensus integrity and fairness, potentially enabling other attacks.

### Likelihood Explanation

**Attacker Capabilities:**
- Any miner in the consensus set can execute this attack
- Attack requires only passive action (not providing encrypted pieces)
- No special privileges or resources required beyond being a miner

**Attack Complexity:**
- Trivially simple: miner simply omits encrypted pieces from their `UpdateValueInput`
- No complex timing or coordination required
- Can be executed continuously across multiple rounds

**Detection Constraints:**
- No validation enforces providing encrypted pieces
- Evil miner detection only checks `MissedTimeSlots`, not missing in-values or encrypted pieces: [8](#0-7) 
- Difficult to distinguish malicious non-provision from honest miner technical issues

**Economic Rationality:**
- Zero cost to execute (no additional transactions or fees)
- Potential benefits from information asymmetry and reduced accountability
- No penalties for not providing encrypted pieces

Likelihood is HIGH given the ease of execution and lack of countermeasures.

### Recommendation

**1. Enforce Encrypted Pieces Provision:**
Add validation in `UpdateValueValidationProvider` or create a new validation provider to ensure miners provide encrypted pieces for all other miners:

```
if (IsSecretSharingEnabled()) {
    Assert(
        minerInRound.EncryptedPieces.Count >= expectedMinersCount - 1,
        "Miner must provide encrypted pieces for all other miners"
    );
}
```

**2. Add Penalties for Non-Compliance:**
Extend evil miner detection to track miners who consistently fail to provide encrypted pieces or previous in-values. Add a counter similar to `MissedTimeSlots` to track these violations.

**3. Require PreviousInValue or Revealed Value:**
Modify validation to require that EITHER the miner provides their `PreviousInValue` directly OR other miners have successfully revealed it through secret sharing. If neither condition is met, increment a violation counter.

**4. Add Invariant Check:**
In round transition logic, verify that all miners from the previous round either provided their `PreviousInValue` or had it revealed through secret sharing. Log warnings for miners who failed both.

**5. Test Cases:**
- Test that miners failing to provide sufficient encrypted pieces are detected
- Test that the system rejects updates from miners who repeatedly hide their in-values
- Test that honest miners providing encrypted pieces can always have their in-values revealed

### Proof of Concept

**Initial State:**
- 5 miners: A (Byzantine), B, C, D, E (honest)
- Round N in progress
- Secret sharing enabled

**Attack Sequence:**

1. **Round N - Setup:**
   - Honest miners B, C, D, E generate in-values and provide encrypted pieces to all miners (including A)
   - Byzantine miner A generates in-value but provides ZERO encrypted pieces (or fewer than 3 for 2/3 threshold)
   - All miners produce blocks in their time slots

2. **Round Nâ†’N+1 Transition:**
   - Extra block producer calls `RevealSharedInValues(roundN+1, producer)`
   - For miner A: check at line 35 fails because `A.EncryptedPieces.Count < minimumCount` (0 < 3)
   - A's in-value is NOT revealed
   - For miners B, C, D, E: they have sufficient encrypted pieces, so their in-values ARE revealed

3. **Round N+1 - Mining:**
   - Miner A produces block with `UpdateValueInput` where `previous_in_value = Hash.Empty`
   - Validation passes per lines 42 and 46 (allows null/empty)
   - A's in-value from round N remains permanently hidden

4. **Expected vs Actual Result:**
   - **Expected:** All miners' in-values from round N should be revealed either directly or through secret sharing
   - **Actual:** Byzantine miner A's in-value is never revealed, while honest miners' in-values are all revealed
   - **Success Condition:** A's `PreviousInValue` in round N+1 remains `Hash.Empty` or `null`, breaking consensus accountability

This demonstrates the asymmetric revelation vulnerability where Byzantine miners can hide their in-values while honest miners cannot.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L28-28)
```csharp
            if (pair.Key == publicKey) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-36)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L42-46)
```csharp
        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L155-156)
```csharp
            // Skip himself.
            if (pair.Key == selfPubkey) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L118-122)
```csharp
        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
```
