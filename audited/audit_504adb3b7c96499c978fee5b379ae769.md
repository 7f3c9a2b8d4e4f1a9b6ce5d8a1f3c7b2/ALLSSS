### Title
Threshold Validation Bypass via Null/Empty Addresses in Organization Member List

### Summary
The Association contract's `AddMember`, `ChangeMember`, and `CreateOrganization` methods do not validate that input addresses are non-null and non-empty before adding them to the organization member list. Since `Count()` includes these invalid addresses in threshold validation but they cannot participate in voting, attackers can configure thresholds that appear valid but create impossible voting scenarios, leading to permanent governance deadlock.

### Finding Description

The vulnerability exists in multiple locations where addresses are added to the organization member list without validation: [1](#0-0) [2](#0-1) [3](#0-2) 

None of these methods validate the input address before adding it to `OrganizationMemberList.OrganizationMembers`. The `Validate()` method checks for empty lists and duplicates but not for null or empty individual addresses: [4](#0-3) 

The `Count()` function simply returns the collection count, including any null or empty addresses: [5](#0-4) 

The root cause is that threshold validation at line 72-80 uses `Count()` to ensure thresholds are mathematically valid (e.g., `MaximalRejectionThreshold + MinimalApprovalThreshold <= organizationMemberCount`), assuming all counted members can vote. However, null or empty addresses cannot vote because:

1. Voting requires calling `Approve`, `Reject`, or `Abstain` with `Context.Sender` as the voter
2. The contract verifies the voter is in the member list via `Contains()`
3. `Context.Sender` is always a real address from the transaction sender—it can never be null or have an empty `Value` [6](#0-5) [7](#0-6) 

This creates a mismatch between the member count used for threshold validation and the actual number of addresses that can vote.

### Impact Explanation

**Governance Deadlock**: An attacker controlling an organization can add null/empty addresses to inflate `Count()`, then set thresholds that appear valid mathematically but are impossible to satisfy in practice.

**Concrete Attack Scenario**:
1. Organization starts with 3 real members, thresholds: `MinimalApprovalThreshold=2`, `MaximalRejectionThreshold=1` (validates as 2+1=3≤3)
2. Attacker adds one empty address via `AddMember(new Address())`
3. `Count()` becomes 4, validation still passes
4. Attacker updates thresholds to `MinimalApprovalThreshold=3`, `MaximalRejectionThreshold=1` (validates as 3+1=4≤4)
5. Future proposals require 3 approvals, but only 3 real members exist
6. If any member rejects (within the allowed max of 1), only 2 members remain to approve, which is less than the required 3
7. **Result**: No proposal can ever pass—permanent governance deadlock

The voting logic confirms this impact: [8](#0-7) 

With the misconfigured thresholds, `approvedMemberCount` can never reach `MinimalApprovalThreshold` when rejections occur, violating the invariant that threshold validation is meant to protect.

**Affected Parties**: All organization members lose governance capability; funds controlled by the organization become inaccessible if they require proposals to transfer.

### Likelihood Explanation

**Reachable Entry Points**: 
- `AddMember` is a public method callable by the organization address itself (via proposal mechanism)
- `ChangeMember` and `CreateOrganization` are similarly accessible [9](#0-8) 

**Attacker Capabilities**: The attacker must control the organization (able to create and pass proposals), which is realistic for:
- Malicious organization creators during initial setup
- Compromised organizations where the attacker gains temporary majority control
- Organizations with low member counts where collusion is easier

**Execution Practicality**: 
1. Create proposal calling `AddMember` with `new Address()` (empty `ByteString` value)
2. Vote to approve the proposal
3. Create second proposal calling `ChangeOrganizationThreshold` with inflated thresholds
4. Vote to approve the second proposal
5. All future proposals become unpassable

C# protobuf messages like `Address` can have null references or empty `ByteString` values, both of which pass through without validation: [10](#0-9) 

**Detection Difficulty**: No events or checks specifically warn about null/empty addresses being added. The misconfiguration only becomes apparent when voting fails unexpectedly.

**Economic Rationality**: The attack requires only proposal creation costs (transaction fees), making it economically feasible for attackers seeking to disrupt governance or create DoS conditions.

### Recommendation

**1. Add Address Validation to Member Addition Methods**

Add validation checks before adding addresses to the organization member list, similar to the pattern used in TokenContract: [11](#0-10) 

Apply this validation in:
- `AddMember`: Validate `input` before line 237
- `ChangeMember`: Validate `input.NewMember` before line 254  
- `CreateOrganization`: Validate each address in `input.OrganizationMemberList.OrganizationMembers` before line 79

**2. Enhance Validate() Method**

Extend the `Validate()` method to check for null/empty addresses:

```csharp
// In Association_Helper.cs, add to Validate() method after line 66:
if (organization.OrganizationMemberList.OrganizationMembers.Any(m => m == null || m.Value.IsNullOrEmpty()))
    return false;
```

**3. Add Comprehensive Test Coverage**

Create test cases for:
- Attempting to add null address via `AddMember` (should fail)
- Attempting to add empty address `new Address()` via `AddMember` (should fail)
- Creating organization with null/empty addresses in initial member list (should fail)
- Changing member to null/empty address via `ChangeMember` (should fail)

Currently, no tests exist for these member management functions: [12](#0-11) 

### Proof of Concept

**Initial State Setup**:
1. Create organization with 3 valid member addresses: `[Member1, Member2, Member3]`
2. Set thresholds: `MinimalApprovalThreshold=2`, `MaximalRejectionThreshold=1`, `MinimalVoteThreshold=2`
3. Validation passes: `2 + 1 = 3 <= Count()=3` ✓

**Attack Execution**:
```
Step 1: Add Empty Address
- Organization creates proposal to call AddMember(new Address())
- Members approve and release proposal
- OrganizationMemberList becomes: [Member1, Member2, Member3, EmptyAddress]
- Count() returns 4
- No validation error occurs

Step 2: Update Thresholds  
- Organization creates proposal to call ChangeOrganizationThreshold
- Set: MinimalApprovalThreshold=3, MaximalRejectionThreshold=1, MinimalVoteThreshold=3
- Validation passes: 3 + 1 = 4 <= Count()=4 ✓
- Proposal approved and released

Step 3: Attempt Normal Governance
- Create new proposal for any operation
- Member1 calls Approve() ✓
- Member2 calls Approve() ✓  
- Member3 calls Reject() ✓
- EmptyAddress CANNOT call any voting method (Context.Sender cannot be empty)
- Total: 2 approvals, 1 rejection

Step 4: Attempt Release
- Proposer calls Release()
- IsProposalRejected(): 1 <= 1, so not rejected ✓
- CheckEnoughVoteAndApprovals(): approvedMemberCount=2 < MinimalApprovalThreshold=3 ✗
- Release FAILS with "Not approved" error
```

**Expected Result**: Proposal should be releasable when sufficient non-rejecting members approve

**Actual Result**: Proposal cannot be released because the threshold assumes 4 voting members but only 3 can actually vote

**Success Condition for Exploit**: Organization enters permanent deadlock state where no proposals can pass, despite having valid member participation

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L248-264)
```csharp
    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L7-10)
```csharp
    public int Count()
    {
        return organizationMembers_.Count;
    }
```

**File:** protobuf/association_contract.proto (L27-37)
```text
    // Add organization members.
    rpc AddMember(aelf.Address) returns (google.protobuf.Empty){
    }
    
    // Remove organization members.
    rpc RemoveMember(aelf.Address) returns (google.protobuf.Empty){
    }
    
    // Replace organization member with a new member.
    rpc ChangeMember(ChangeMemberInput) returns (google.protobuf.Empty){
    }
```

**File:** src/AElf.Types/Extensions/ByteStringExtensions.cs (L34-37)
```csharp
        public static bool IsNullOrEmpty(this ByteString byteString)
        {
            return byteString == null || byteString.IsEmpty;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```

**File:** test/AElf.Contracts.Association.Tests/AssociationContractTests.cs (L1-50)
```csharp
using System.Linq;
using System.Threading.Tasks;
using AElf.Contracts.MultiToken;
using AElf.ContractTestBase.ContractTestKit;
using AElf.Cryptography.ECDSA;
using AElf.CSharp.Core.Extension;
using AElf.GovernmentSystem;
using AElf.Kernel;
using AElf.Kernel.Blockchain.Application;
using AElf.Kernel.SmartContract.Application;
using AElf.Standards.ACS1;
using AElf.Standards.ACS3;
using AElf.Types;
using Google.Protobuf;
using Google.Protobuf.WellKnownTypes;
using Shouldly;
using Xunit;

namespace AElf.Contracts.Association;

public class AssociationContractTests : AssociationContractTestBase<AssociationContractTestAElfModule>
{
    private readonly IBlockchainService _blockchainService;
    private readonly TestDemoSmartContractAddressNameProvider _smartContractAddressNameProvider;
    private readonly ISmartContractAddressService _smartContractAddressService;

    public AssociationContractTests()
    {
        _smartContractAddressService = GetRequiredService<ISmartContractAddressService>();
        _blockchainService = GetRequiredService<IBlockchainService>();
        _smartContractAddressNameProvider = GetRequiredService<TestDemoSmartContractAddressNameProvider>();
    }

    [Fact]
    public async Task Get_Organization_Test()
    {
        //failed case
        {
            var organization =
                await AssociationContractStub.GetOrganization.CallAsync(Accounts[0].Address);
            organization.ShouldBe(new Organization());
        }
    }

    [Fact]
    public async Task CreateOrganization_Success_Test()
    {
        var minimalApproveThreshold = 2;
        var minimalVoteThreshold = 3;
        var maximalAbstentionThreshold = 1;
```
