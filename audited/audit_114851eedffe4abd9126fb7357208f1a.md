### Title
Inconsistent Miner Count Threshold Causes LIB Calculation Failure During Term Transitions

### Summary
The `Deconstruct()` method in `LastIrreversibleBlockHeightCalculator` compares the count of filtered implied irreversible block heights against `MinersCountOfConsent` calculated from the total current round miners. When the miner list changes between rounds (especially during term transitions), new miners who mined in the current round but didn't exist in the previous round cause the filtered height count to fall below the threshold, unfairly preventing LIB advancement even when sufficient miners participated.

### Finding Description

The vulnerability exists in the LIB calculation logic at [1](#0-0) 

The root cause is a mathematical inconsistency in how miners are counted:

1. **Line 24**: `GetMinedMiners()` retrieves miners who successfully mined in the current round [2](#0-1)  - these are miners with `SupposedOrderOfNextRound != 0`.

2. **Line 25**: `GetSortedImpliedIrreversibleBlockHeights(minedMiners)` filters the previous round's miners to only include those whose pubkeys match the current round's mined miners [3](#0-2) . This excludes new miners who didn't exist in the previous round.

3. **Line 26**: The filtered count is compared against `MinersCountOfConsent`, which is calculated as `RealTimeMinersInformation.Count * 2/3 + 1` [4](#0-3)  - based on ALL miners in the current round, not just those who exist in both rounds.

During term transitions when the miner list changes [5](#0-4) , new miners join but have no historical data in the previous round. The asymmetry between the threshold (based on total current miners) and the count (based on intersection of miners) causes legitimate LIB calculations to fail.

The LIB calculation is invoked during `ProcessUpdateValue` [6](#0-5)  when miners update their consensus values after producing blocks.

### Impact Explanation

**Operational Impact - Delayed LIB Advancement:**
- When the check at line 26-29 fails, `libHeight` is set to 0, preventing LIB advancement
- The system continues using the previous LIB value, but new irreversible blocks are not confirmed
- Cross-chain operations that depend on LIB [7](#0-6)  are delayed
- Finality guarantees are postponed during term transitions

**Concrete Scenario:**
- Previous round: 7 miners [A, B, C, D, E, F, G]
- Current round (new term): 7 miners [D, E, F, G, H, I, J] (4 overlap, 3 new)
- 5 miners mined (meeting 2/3+1 threshold): [D, E, G, H, I]
- MinersCountOfConsent = 7 * 2/3 + 1 = 5
- Filtered heights from previous round: only 3 (D, E, G exist; H, I don't)
- Check fails: 3 < 5, despite legitimate 5-miner participation

**Affected Parties:**
- Cross-chain users experience delayed transfers/verifications
- The entire network's finality progression is stalled during term transitions
- Side chains waiting for main chain LIB updates are impacted

**Severity:** Medium - causes recurring operational disruption but is temporary and self-resolving once new miners establish history across multiple rounds.

### Likelihood Explanation

**High Likelihood - Occurs During Normal Operations:**

**Trigger Conditions:**
- Happens during every term transition when the miner list changes
- Term changes occur regularly as part of the AEDPoS consensus mechanism [8](#0-7) 
- No attacker required - this is a logic flaw triggered by legitimate operations

**Feasibility:**
- Entry point: Public `UpdateValue` method called by miners during normal block production
- No special privileges needed beyond being a miner
- Occurs naturally when election results change the miner set
- The more significant the miner list change (more new miners), the more likely the issue

**Frequency:**
- Every term transition with new miners joining
- Particularly problematic when multiple new miners join simultaneously
- Affects the first 1-2 rounds of each new term until new miners build history

**Detection:**
- Observable through LIB not advancing for several rounds after term changes
- IrreversibleBlockFound events [7](#0-6)  will not be fired despite sufficient miner participation

### Recommendation

**Code-Level Mitigation:**

1. **Calculate threshold based on miner overlap:**
```
Modify MinersCountOfConsent calculation to consider only miners who exist in both rounds, or use the minimum of the two round's miner counts.
```

2. **Special handling for term transitions:**
```
When IsMinerListJustChanged is true, use a relaxed threshold or calculate LIB using only the overlapping miners' heights, adjusting the consensus requirement proportionally.
```

3. **Alternative approach - adjust the filtering:**
```
Instead of filtering previous round by current round's mined miners, filter by the intersection of both rounds' miner lists, then check if enough of those miners mined.
```

**Invariant Checks to Add:**
- Assert that the threshold used for comparison matches the population being counted
- Add explicit handling for first rounds after term changes
- Log warnings when LIB calculation fails due to insufficient overlap

**Test Cases:**
- Term transition with 50% miner list change, verify LIB still advances
- Term transition with all new miners, verify graceful degradation
- Multiple consecutive rounds after term change, verify recovery
- Cross-chain operations during term transitions complete successfully

### Proof of Concept

**Initial State:**
- Round 100 (current term): 7 miners [A, B, C, D, E, F, G] all active
- All miners have recorded ImpliedIrreversibleBlockHeight values
- LIB is advancing normally

**Exploitation Sequence:**

1. **Term Change Occurs:**
   - Election results finalize
   - `ProcessNextTerm` called with new miner list: [D, E, F, G, H, I, J]
   - Round 101 begins with IsMinerListJustChanged = true
   - New miners H, I, J join; miners A, B, C leave

2. **Round 101 Block Production:**
   - 5 miners successfully mine: D, E, G, H, I (meets 2/3+1 = 5 threshold)
   - Each miner calls `UpdateValue` with their ImpliedIrreversibleBlockHeight

3. **LIB Calculation Triggered:**
   - `ProcessUpdateValue` invoked for miner H
   - `LastIrreversibleBlockHeightCalculator.Deconstruct()` called
   - `minedMiners` = [D, E, G, H, I] (5 miners)
   - `GetSortedImpliedIrreversibleBlockHeights([D, E, G, H, I])` on round 100
   - Round 100 only contains D, E, G from this list (3 heights)
   - Check: 3 < 5 (MinersCountOfConsent)
   - Result: `libHeight = 0`

**Expected vs Actual:**
- **Expected:** LIB advances since 5 out of 7 miners (71%) successfully participated, exceeding the 2/3 threshold
- **Actual:** LIB calculation fails and returns 0, no IrreversibleBlockFound event fired, LIB does not advance

**Success Condition:**
The vulnerability is confirmed when, despite legitimate 2/3+1 miner participation in the current round, the LIB calculation fails solely because some participating miners are new and lack history in the previous round.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L40-42)
```csharp
        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```
