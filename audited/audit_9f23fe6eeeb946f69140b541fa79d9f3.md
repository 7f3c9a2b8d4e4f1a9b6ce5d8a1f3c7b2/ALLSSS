### Title
Unbounded Symbol List in Transaction Fee Charging Causes Denial of Service

### Summary
The `SetSymbolsToPayTxSizeFee` method lacks validation on the number of symbols that can be configured for transaction fee payment. An excessively large symbol list forces `GetAvailableSymbolToPayTxFee` to perform unbounded iterations with multiple state reads per symbol for every transaction, causing widespread transaction failures due to resource exhaustion.

### Finding Description

The vulnerability exists in the transaction fee charging mechanism where symbols accepted for fee payment are configured without any count limit.

**Root Cause - Missing Count Validation:**
The `SetSymbolsToPayTxSizeFee` method validates individual symbol properties (weight ratios, duplicates, token existence) but never checks the total count of symbols in the list. [1](#0-0) 

The method iterates through all input symbols performing validation but has no assertion like `Assert(input.SymbolsToPayTxSizeFee.Count <= MAX_SYMBOLS, "Too many symbols")`.

**Exploitation Path:**
For every transaction executed on the chain, the pre-execution plugin calls `ChargeTransactionFees`: [2](#0-1) 

This triggers `ChargeSizeFee` which calls `GetAvailableSymbolToPayTxFee`: [3](#0-2) 

**Unbounded Iteration:**
`GetAvailableSymbolToPayTxFee` iterates through the entire symbol list without bounds: [4](#0-3) 

For each symbol, the method performs:
- State read via `GetBalance` (line 485): [5](#0-4) 

- Allowance calculation iterating through maps (line 483-484): [6](#0-5) 

While there is an early exit at line 493 if a suitable token is found, the worst case requires full iteration (e.g., when the user has zero balance in all tokens or no suitable token exists).

**Why Existing Protections Fail:**
The authorization check only validates that the caller is the governance controller, not the validity of the symbol count: [7](#0-6) 

### Impact Explanation

**Complete Transaction Processing Denial of Service:**
- All user transactions on the chain must pass through `ChargeTransactionFees` before execution
- With thousands of symbols configured, each transaction performs thousands of state reads and computations during fee charging
- Transactions will exceed resource/computation limits and fail before reaching their intended logic
- Critical system operations (governance proposals, consensus updates, token transfers) become impossible to execute

**Scope:** Chain-wide impact affecting all transactions and all users

**Severity Justification:** HIGH - Complete operational paralysis of the blockchain requiring emergency governance intervention or hard fork to resolve

### Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to create and pass a Parliament governance proposal
- By default, requires coordination among miners to approve the proposal

**Attack Complexity:** MEDIUM
- Not exploitable by untrusted parties directly
- Requires governance process: create proposal → get miner approval → release proposal
- Could occur via:
  - Malicious coordinated attack if sufficient miners are compromised
  - Accidental misconfiguration during legitimate governance operations
  - Social engineering attack targeting governance participants

**Feasibility Conditions:**
- Parliament organization must approve the malicious/mistaken proposal
- Tests show typical usage with 1-2 symbols, making thousands of symbols clearly anomalous: [8](#0-7) 

**Detection/Mitigation Difficulty:**
- Once configured, extremely difficult to detect until transactions start failing
- Recovery requires another governance proposal to fix, during which chain remains unusable
- No automated monitoring for symbol count anomalies

**Probability:** MEDIUM - While requiring governance compromise, the complete lack of bounds checking combined with severe consequences elevates this from theoretical to realistic threat

### Recommendation

**Immediate Fix:**
Add a maximum symbol count validation in `SetSymbolsToPayTxSizeFee`:

```csharp
public override Empty SetSymbolsToPayTxSizeFee(SymbolListToPayTxSizeFee input)
{
    AssertControllerForSymbolToPayTxSizeFee();
    if (input == null)
        throw new AssertionException("invalid input");
    
    const int MaxSymbolsToPayTxSizeFee = 10;
    Assert(input.SymbolsToPayTxSizeFee.Count <= MaxSymbolsToPayTxSizeFee, 
        $"Too many symbols. Maximum allowed: {MaxSymbolsToPayTxSizeFee}");
    
    // ... rest of existing validation
```

**Invariant to Enforce:**
`State.SymbolListToPayTxSizeFee.Value.SymbolsToPayTxSizeFee.Count <= MAX_SYMBOLS` must hold at all times

**Test Cases:**
1. Attempt to set exactly MAX_SYMBOLS symbols → should succeed
2. Attempt to set MAX_SYMBOLS + 1 symbols → should fail with assertion error
3. Performance test with MAX_SYMBOLS configured → transaction should complete within acceptable gas limits

### Proof of Concept

**Initial State:**
- MultiToken contract deployed with Parliament as default controller
- Primary token (ELF) exists

**Attack Sequence:**

1. **Create malicious proposal:**
   - Construct `SymbolListToPayTxSizeFee` with 5,000 symbols
   - Each symbol has valid weights and exists in the system
   - Create Parliament proposal to call `SetSymbolsToPayTxSizeFee`

2. **Get proposal approved:**
   - Coordinate with miners (or exploit governance vulnerability)
   - Accumulate sufficient approvals
   - Release proposal to execute

3. **Configuration takes effect:**
   - `State.SymbolListToPayTxSizeFee.Value` now contains 5,000 symbols
   - Event `ExtraTokenListModified` is emitted
   - Cache is updated with the massive symbol list

4. **Trigger DOS:**
   - Any user attempts a normal transaction (e.g., token transfer)
   - Pre-execution plugin calls `ChargeTransactionFees`
   - `GetAvailableSymbolToPayTxFee` iterates through all 5,000 symbols
   - For each symbol: state read + allowance map iteration + calculations
   - Transaction exhausts resources/computation limits
   - Transaction fails with resource exhaustion error

**Expected Result:** Transaction executes successfully with fee charged

**Actual Result:** Transaction fails during fee charging phase due to excessive computation from iterating 5,000 symbols, each requiring multiple state reads and calculations. All subsequent transactions fail similarly, causing complete chain DOS.

**Success Condition:** When `GetAvailableSymbolToPayTxFee` is called with 5,000 symbols and user has zero balance in first 4,999 tokens, the method must iterate all 5,000 times performing thousands of state operations, causing transaction failure.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L393-398)
```csharp
        if (input.SymbolsToPayTxSizeFee.Any())
        {
            var allSymbolToTxFee = input.SymbolsToPayTxSizeFee.ToList();
            var availableSymbol = GetAvailableSymbolToPayTxFee(allSymbolToTxFee, fromAddress, txSizeFeeAmount,
                transactionFeeFreeAllowancesMap, symbolChargedForBaseFee, amountChargedForBaseFee,
                amountChargedForBaseAllowance, delegations);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L462-517)
```csharp
    private SymbolToPayTxSizeFee GetAvailableSymbolToPayTxFee(List<SymbolToPayTxSizeFee> allSymbolToTxFee,
        Address fromAddress, long txSizeFeeAmount, TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap,
        string symbolChargedForBaseFee, long amountChargedForBaseFee, long amountChargedForBaseAllowance,
        TransactionFeeDelegations delegations = null)
    {
        SymbolToPayTxSizeFee availableSymbol = null;
        SymbolToPayTxSizeFee availableSymbolWithAnything = null;
        SymbolToPayTxSizeFee availableSymbolWithEnoughBalance = null;
        SymbolToPayTxSizeFee availableSymbolWithEnoughBalancePlusAllowance = null;

        // get 1st Allowance > size fee, else, get 1st Balance + Allowance > 0, else get 1st > 0
        foreach (var symbolToPlayTxSizeFee in allSymbolToTxFee)
        {
            if (delegations != null)
            {
                var delegationEnough = IsDelegationEnoughBaseOnPrimaryToken(symbolToPlayTxSizeFee,
                    symbolChargedForBaseFee, amountChargedForBaseFee.Add(amountChargedForBaseAllowance),
                    txSizeFeeAmount, delegations);
                if (!delegationEnough) break;
            }

            var allowance = GetAllowanceCalculatedBaseOnPrimaryToken(symbolToPlayTxSizeFee,
                transactionFeeFreeAllowancesMap, symbolChargedForBaseFee, amountChargedForBaseAllowance);
            var balance = GetBalanceCalculatedBaseOnPrimaryToken(fromAddress, symbolToPlayTxSizeFee,
                symbolChargedForBaseFee, amountChargedForBaseFee);
            
            var balancePlusAllowance = balance.Add(allowance);

            if (allowance >= txSizeFeeAmount)
            {
                availableSymbol = symbolToPlayTxSizeFee;
                break;
            }

            if (delegations == null && balancePlusAllowance > 0)
            {
                availableSymbolWithAnything ??= symbolToPlayTxSizeFee;
            }

            if (balancePlusAllowance < txSizeFeeAmount) continue;

            if (allowance > 0)
            {
                availableSymbolWithEnoughBalancePlusAllowance ??= symbolToPlayTxSizeFee;
            }
            else
            {
                availableSymbolWithEnoughBalance ??= symbolToPlayTxSizeFee;
            }
        }

        availableSymbol ??= availableSymbolWithEnoughBalancePlusAllowance ??
                            availableSymbolWithEnoughBalance ?? availableSymbolWithAnything;

        return availableSymbol;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L616-649)
```csharp
    public override Empty SetSymbolsToPayTxSizeFee(SymbolListToPayTxSizeFee input)
    {
        AssertControllerForSymbolToPayTxSizeFee();
        if (input == null)
            throw new AssertionException("invalid input");
        var isPrimaryTokenExist = false;
        var symbolList = new List<string>();
        var primaryTokenSymbol = GetPrimaryTokenSymbol(new Empty());
        Assert(!string.IsNullOrEmpty(primaryTokenSymbol.Value), "primary token does not exist");
        foreach (var tokenWeightInfo in input.SymbolsToPayTxSizeFee)
        {
            if (tokenWeightInfo.TokenSymbol == primaryTokenSymbol.Value)
            {
                isPrimaryTokenExist = true;
                Assert(tokenWeightInfo.AddedTokenWeight == 1 && tokenWeightInfo.BaseTokenWeight == 1,
                    $"symbol:{tokenWeightInfo.TokenSymbol} weight should be 1");
            }

            Assert(tokenWeightInfo.AddedTokenWeight > 0 && tokenWeightInfo.BaseTokenWeight > 0,
                $"symbol:{tokenWeightInfo.TokenSymbol} weight should be greater than 0");
            Assert(!symbolList.Contains(tokenWeightInfo.TokenSymbol),
                $"symbol:{tokenWeightInfo.TokenSymbol} repeat");
            AssertSymbolToPayTxFeeIsValid(tokenWeightInfo.TokenSymbol, out var addedTokenTotalSupply);
            symbolList.Add(tokenWeightInfo.TokenSymbol);
        }

        Assert(isPrimaryTokenExist, $"primary token:{primaryTokenSymbol.Value} not included");
        State.SymbolListToPayTxSizeFee.Value = input;
        Context.Fire(new ExtraTokenListModified
        {
            SymbolListToPayTxSizeFee = input
        });
        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L98-107)
```csharp
            var transactionSizeFeeSymbols =
                await _transactionSizeFeeSymbolsProvider.GetTransactionSizeFeeSymbolsAsync(chainContext);
            if (transactionSizeFeeSymbols != null)
                foreach (var transactionSizeFeeSymbol in transactionSizeFeeSymbols.TransactionSizeFeeSymbolList)
                    chargeTransactionFeesInput.SymbolsToPayTxSizeFee.Add(new SymbolToPayTxSizeFee
                    {
                        TokenSymbol = transactionSizeFeeSymbol.TokenSymbol,
                        BaseTokenWeight = transactionSizeFeeSymbol.BaseTokenWeight,
                        AddedTokenWeight = transactionSizeFeeSymbol.AddedTokenWeight
                    });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L166-172)
```csharp
    private long GetBalance(Address address, string symbol)
    {
        AssertValidInputAddress(address);
        var actualSymbol = GetActualTokenSymbol(symbol);
        Assert(!string.IsNullOrWhiteSpace(actualSymbol), "Invalid symbol.");
        return State.Balances[address][actualSymbol];
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L179-194)
```csharp
    private long GetFreeFeeAllowanceAmount(TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, string symbol)
    {
        var allowance = 0L;
        var map = transactionFeeFreeAllowancesMap.Map;

        if (map == null) return allowance;

        foreach (var freeAllowances in map.Values)
        {
            freeAllowances.Map.TryGetValue(symbol, out var freeAllowance);

            allowance = allowance.Add(freeAllowance?.Amount ?? 0L);
        }

        return allowance;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L399-405)
```csharp
    private void AssertControllerForSymbolToPayTxSizeFee()
    {
        if (State.SymbolToPayTxFeeController.Value == null)
            State.SymbolToPayTxFeeController.Value = GetDefaultSymbolToPayTxFeeController();

        Assert(State.SymbolToPayTxFeeController.Value.OwnerAddress == Context.Sender, "no permission");
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/ACS2_TokenResourceTests.cs (L103-114)
```csharp
        newSymbolList.SymbolsToPayTxSizeFee.Add(new SymbolToPayTxSizeFee
        {
            TokenSymbol = "ELF",
            AddedTokenWeight = 1,
            BaseTokenWeight = 1
        });
        newSymbolList.SymbolsToPayTxSizeFee.Add(new SymbolToPayTxSizeFee
        {
            TokenSymbol = "CPU",
            AddedTokenWeight = 2,
            BaseTokenWeight = 1
        });
```
