### Title
Two-Miner Consensus Deadlock: Malicious Miner Can Permanently Block Term Transitions

### Summary
In a two-miner network, a single malicious miner can permanently block term transitions by refusing to mine, creating an unrecoverable deadlock. The `NeedToChangeTerm` method requires both miners to have mined blocks with timestamps in the new period before allowing term transition, but a non-mining attacker prevents this threshold from ever being met. This permanently freezes the miner list, blocks treasury distributions, and renders governance ineffective.

### Finding Description

**Root Cause Location:**

The vulnerability stems from the term transition logic in `GetConsensusBehaviourToTerminateCurrentRound()`: [1](#0-0) 

This method calls `NeedToChangeTerm`, which implements a two-thirds consensus requirement: [2](#0-1) 

The critical flaw is in how `MinersCountOfConsent` is calculated for a two-miner network: [3](#0-2) 

For 2 miners: `2 * 2 / 3 + 1 = 1 + 1 = 2` (using integer division), requiring both miners to agree.

**Why Protections Fail:**

The `NeedToChangeTerm` method only counts miners who have `ActualMiningTimes.Any()` - meaning it filters out miners who haven't mined in the current round. If the malicious miner refuses to mine:
- Only the honest miner has `ActualMiningTimes` with timestamps in the new period
- Count = 1
- `MinersCountOfConsent` = 2
- 1 < 2, so `NeedToChangeTerm` returns false
- `GetConsensusBehaviourToTerminateCurrentRound` returns `NextRound` instead of `NextTerm`

**Deadlock Mechanism:**

When rounds continue via `NextRound`, miners who don't participate get their `MissedTimeSlots` incremented: [4](#0-3) 

After 4320 missed slots (3 days), the evil miner is detected and marked: [5](#0-4) [6](#0-5) 

However, marking as evil only updates the Election contract state - it does NOT remove the miner from the current consensus miner list. The current miner list is only updated during term transitions via `ProcessNextTerm`: [7](#0-6) 

This creates an unbreakable circular dependency:
- To remove the evil miner from the active miner list → need term transition
- To trigger term transition → need `NextTerm` behavior
- To get `NextTerm` behavior → need `NeedToChangeTerm` to return true
- To satisfy `NeedToChangeTerm` → need both miners to mine in new period
- But the malicious miner refuses to mine → deadlock

Even the governance `RemoveEvilNode` method cannot break this deadlock, as it only updates the Election contract: [8](#0-7) 

### Impact Explanation

**Direct Operational Impact:**
- **Term Transitions Permanently Blocked**: The system can never transition to a new term, freezing at the current term indefinitely
- **Miner List Frozen**: Election results cannot be applied, preventing legitimate miners from joining and illegitimate miners from being removed
- **Treasury Distribution Halted**: Mining rewards and profit distributions to Treasury occur during term transitions and will never execute
- **Governance Paralysis**: The protocol cannot adapt to changing conditions or recover from this state

**Affected Parties:**
- Honest miners cannot join despite winning elections
- Token holders receive no treasury distributions or dividends
- The entire blockchain network becomes controlled by the malicious miner
- All governance mechanisms become ineffective

**Severity Justification:**
This is CRITICAL because:
1. It creates permanent, unrecoverable protocol failure
2. Requires only 50% miner compromise (1 of 2)
3. No timeout, fallback, or recovery mechanism exists
4. Protocol cannot self-heal without external hard fork intervention

### Likelihood Explanation

**Attacker Capabilities:**
- Requires control of 1 out of 2 miners (50% threshold)
- No special technical capabilities needed - simply refusing to mine is sufficient
- No transaction costs or capital requirements
- Attack is passive and undetectable until too late

**Attack Complexity:**
- Trivial to execute: attacker just stops mining when period boundary approaches
- No complex transaction sequencing required
- Works through natural consensus flow without exploiting bugs

**Feasibility Conditions:**
- Two-miner networks are realistic for:
  - Early-stage sidechains
  - Test networks
  - Small private chains
  - Networks during bootstrap phase
- Period boundaries occur every 7 days (default `PeriodSeconds` = 604800)

**Economic Rationality:**
- Malicious miner maintains their position and rewards indefinitely
- Prevents competitors from joining via elections
- Zero cost to execute (no transactions needed)
- High benefit: complete control over block production and rewards

**Detection Constraints:**
- Attack appears as normal network issues initially
- By the time deadlock is recognized (after 3+ days), recovery requires hard fork
- No in-protocol detection mechanism for this specific deadlock scenario

**Probability Assessment:**
High likelihood in two-miner scenarios. The attack is economically rational, technically trivial, and provides long-term control with zero cost.

### Recommendation

**Immediate Mitigation:**

Modify `NeedToChangeTerm` to use a different threshold when `MinersCountOfConsent` equals the total miner count. For networks where all miners must agree, implement a time-based fallback:

```csharp
public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
{
    var minersWithNewPeriodTimestamps = RealTimeMinersInformation.Values
        .Where(m => m.ActualMiningTimes.Any())
        .Select(m => m.ActualMiningTimes.Last())
        .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp, t, currentTermNumber, periodSeconds));
    
    // If we've met the threshold, transition immediately
    if (minersWithNewPeriodTimestamps >= MinersCountOfConsent)
        return true;
    
    // Fallback: if any miner has crossed the boundary AND we're past a grace period
    // (e.g., 2x the normal period), force transition to prevent deadlock
    if (minersWithNewPeriodTimestamps > 0)
    {
        var currentPeriod = (Context.CurrentBlockTime - blockchainStartTimestamp).Seconds.Div(periodSeconds);
        var expectedPeriod = currentTermNumber - 1;
        if (currentPeriod > expectedPeriod + 1) // One full period past deadline
            return true;
    }
    
    return false;
}
```

**Long-Term Solution:**

1. Implement a dynamic `MinersCountOfConsent` calculation that accounts for actively participating miners:
   - Track "active" vs "inactive" miners based on recent participation
   - Exclude consistently non-mining miners from consensus threshold calculations
   - Update miner list mid-term when miners are definitively proven evil

2. Add governance emergency override:
   - Allow Parliament to force term transitions in deadlock scenarios
   - Require supermajority vote to prevent abuse
   - Implement via new `ForceNextTerm` method with proper authorization

3. Prevent two-miner configurations in production:
   - Enforce minimum miner count of 3 in consensus initialization
   - Document the deadlock risk for small networks

**Test Cases:**

Add regression tests in `AEDPoSContractTest`:
- Two-miner network where one miner refuses to mine at period boundary
- Verify system can still transition after grace period
- Test governance emergency override mechanism
- Verify evil miner removal works mid-term when threshold allows

### Proof of Concept

**Initial State:**
- Two-miner network: Miner A (honest), Miner B (malicious)
- Current term: 1
- Period seconds: 604800 (7 days)
- Blockchain start timestamp: Day 0
- Current time: Day 6, 23:59:50

**Attack Sequence:**

1. **Day 7, 00:00:00 - Period Boundary Crossed**
   - Honest Miner A produces block at timestamp T1 = Day 7, 00:00:05
   - A's `ActualMiningTimes` includes T1
   - `IsTimeToChangeTerm(blockchainStart, T1, 1, 604800)` returns true for A

2. **Day 7, 00:00:10 - Malicious Miner B's Turn**
   - B refuses to mine (stops mining process)
   - B's `ActualMiningTimes` remains empty for this round

3. **Day 7, 00:00:15 - Honest Miner A's Turn**
   - A calls `GetConsensusBehaviour()`
   - Reaches `GetConsensusBehaviourToTerminateCurrentRound()`
   - Calls `NeedToChangeTerm()`
   - Count of miners with timestamps in new period: 1 (only A)
   - `MinersCountOfConsent`: 2
   - 1 < 2, returns false
   - Returns `AElfConsensusBehaviour.NextRound` (NOT `NextTerm`)
   - A produces NextRound block

4. **Day 7, 00:00:20 onwards - Deadlock Established**
   - Rounds continue with NextRound behavior
   - B continues refusing to mine
   - B's `MissedTimeSlots` increments each round
   - Term never transitions

5. **Day 10 - Evil Miner Detection**
   - B's `MissedTimeSlots` exceeds 4320
   - `TryToDetectEvilMiners` marks B as evil in Election contract
   - BUT B remains in current consensus miner list

6. **Day 14+ - Permanent Deadlock**
   - Term 1 continues indefinitely
   - Treasury distributions never occur
   - Election results never applied
   - Protocol requires hard fork to recover

**Expected vs Actual Result:**
- **Expected**: Term transitions to Term 2 after Day 7, miner list updates from election
- **Actual**: Term remains at Term 1 indefinitely, B stays in miner list forever, protocol deadlocked

**Success Condition:**
Malicious miner successfully blocks all future term transitions with zero cost while maintaining their position and rewards indefinitely.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L39-56)
```csharp
        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-177)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-351)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
    }
```
