### Title
Governance Deadlock in UserFeeController Enables Indefinite Blocking of Transaction Fee Updates

### Summary
The UserFeeController uses a 2-of-2 unanimous approval structure requiring both Referendum and Parliament organizations to approve any changes. If an attacker compromises either organization, they can permanently block all user transaction fee coefficient updates with no recovery mechanism, creating a governance deadlock that cannot be resolved without the compromised party's cooperation.

### Finding Description

The vulnerability exists in the initialization of the UserFeeController's governance structure. [1](#0-0) 

The Association organization is created with two members (referendum and parliament) and sets both `MinimalApprovalThreshold` and `MinimalVoteThreshold` to `proposers.Count` (2), requiring unanimous approval. [2](#0-1) 

The Association contract's approval logic enforces this unanimous requirement strictly. [3](#0-2) 

This creates three circular dependencies with no escape mechanism:

1. **Updating fee coefficients** requires UserFeeController approval. [4](#0-3) 

2. **Changing the UserFeeController** requires the current UserFeeController's approval. [5](#0-4) 

3. **Modifying the Association organization's thresholds** requires approval from the organization itself (which requires 2-of-2 approval). [6](#0-5) 

If either the Referendum or Parliament organization is compromised, the attacker can simply refuse to approve (or actively reject) any proposal, and the proposal will fail to meet the `MinimalApprovalThreshold` of 2. No emergency override mechanism exists - the EmergencyResponseOrganization only has authority over the Election contract, not the MultiToken contract. [7](#0-6) 

### Impact Explanation

**Direct Operational Impact:**
- Transaction fee coefficient updates (`FeeTypeEnum.Tx`) are permanently blocked
- Fee calculation algorithm cannot be adjusted to respond to changing network conditions or economic realities
- Fees may become economically inappropriate (too high or too low) relative to market token values

**Governance Integrity Impact:**
- Complete loss of governance control over user transaction fees
- No recovery path exists without cooperation from the compromised organization
- Creates permanent single point of failure in critical fee governance

**Affected Parties:**
- All blockchain users paying transaction fees with suboptimal coefficients
- Protocol governance unable to adjust economic parameters
- Entire ecosystem if fees become prohibitively expensive or ineffectively low

**Severity Justification:**
This is a High severity issue because it creates an unrecoverable denial-of-service condition on critical economic governance functionality, with no bypass or recovery mechanism available to the legitimate governance bodies.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Gain majority control of EITHER Referendum (through token acquisition) OR Parliament (through BP election)
- This is significantly more feasible than requiring compromise of BOTH organizations or a 51% attack on the entire blockchain

**Attack Complexity:**
- Low - once majority control is achieved in one organization, the attacker simply refuses to approve proposals
- No sophisticated exploitation or contract interaction required
- Attack is undetectable until proposals start failing

**Feasibility Conditions:**
- Referendum can be influenced by acquiring majority voting tokens through market purchases or accumulation
- Parliament can be influenced through the BP election process
- Persistent governance disagreement between the two bodies could also trigger deadlock without malicious intent

**Economic Rationality:**
- Cost of gaining majority control in one organization is substantially lower than controlling both
- No ongoing cost to maintain the block (just refuse to vote)
- Could be motivated by competing protocol interests or ransom demands

**Probability Assessment:**
Realistic - the governance structure explicitly depends on continued cooperation between two independent organizations with potentially divergent incentives, creating a credible deadlock risk even without malicious compromise.

### Recommendation

**Immediate Mitigation:**
Modify `GetAssociationControllerCreateInputForUserFee` to implement a threshold below unanimous approval (e.g., requiring only one of the two organizations):

```
MinimalApprovalThreshold = 1,  // Require at least one approval
MinimalVoteThreshold = 2,      // Require both to vote
```

Alternatively, implement a weighted threshold system or add a third neutral arbiter to prevent deadlock.

**Long-term Solution:**
Implement a recovery mechanism such as:
1. Emergency override by Parliament's EmergencyResponseOrganization for critical fee governance
2. Time-delayed fallback that allows Parliament-only approval after a grace period
3. Separate escalation path for deadlock scenarios
4. Add a sunset clause that reverts to Parliament-only control if no agreement is reached within a specified timeframe

**Invariant Checks:**
- Add monitoring for proposal rejection patterns to detect potential governance attacks
- Implement alerts when the same proposal fails multiple times due to lack of unanimous approval

**Test Cases:**
- Test scenario where Referendum refuses to approve fee updates
- Test scenario where Parliament refuses to approve fee updates  
- Verify recovery mechanisms work when one organization becomes unresponsive
- Test controller change under deadlock conditions

### Proof of Concept

**Initial State:**
- UserFeeController initialized with Association requiring 2-of-2 approval
- Current transaction fee coefficients set to initial values
- Referendum organization compromised by attacker gaining majority token voting power

**Exploitation Steps:**

1. Legitimate governance creates proposal to update user fee coefficients via `UpdateCoefficientsForSender`
2. Parliament organization votes to approve the Association proposal
3. Attacker-controlled Referendum organization refuses to vote or votes to reject
4. Proposal cannot reach `MinimalApprovalThreshold` of 2 (only 1 approval from Parliament)
5. Proposal fails per Association approval logic

6. Legitimate governance attempts to change UserFeeController to recover
7. Parliament organization votes to approve controller change
8. Attacker-controlled Referendum organization refuses to approve
9. Controller change fails due to same 2-of-2 requirement

10. Legitimate governance attempts to modify Association threshold to remove deadlock
11. This also requires Association approval (2-of-2)
12. Attacker-controlled Referendum refuses, blocking threshold change

**Expected Result:**
All three recovery paths fail, creating permanent governance deadlock

**Actual Result:**
System enters unrecoverable state where transaction fee coefficients cannot be updated indefinitely, confirming the vulnerability

**Success Condition:**
User fee governance remains blocked despite legitimate governance majority control of Parliament, demonstrating that single organization compromise enables indefinite blocking with no recovery path.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L70-78)
```csharp
    public override Empty ChangeUserFeeController(AuthorityInfo input)
    {
        AssertUserFeeController();
        Assert(CheckOrganizationExist(input), "Invalid authority input.");
        State.UserFeeController.Value.RootController = input;
        State.UserFeeController.Value.ParliamentController = null;
        State.UserFeeController.Value.ReferendumController = null;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L158-184)
```csharp
    private Association.CreateOrganizationBySystemContractInput GetAssociationControllerCreateInputForUserFee(
        Address parliamentAddress, Address referendumAddress)
    {
        var proposers = new List<Address>
            { referendumAddress, parliamentAddress };
        return new Association.CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new Association.CreateOrganizationInput
            {
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { proposers }
                },
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = proposers.Count,
                    MinimalVoteThreshold = proposers.Count,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { proposers }
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L25-32)
```csharp
    public override Empty UpdateCoefficientsForSender(UpdateCoefficientsInput input)
    {
        Assert(input.Coefficients != null, "Invalid input coefficients.");
        AssertUserFeeController();
        input.Coefficients.FeeTokenType = (int)FeeTypeEnum.Tx; // The only possible for now.
        UpdateCoefficients(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-216)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L83-88)
```csharp
    public override Empty UpdateCandidateInformation(UpdateCandidateInformationInput input)
    {
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) ==
            Context.Sender || Context.Sender == GetEmergencyResponseOrganizationAddress(),
            "Only consensus contract can update candidate information.");
```
