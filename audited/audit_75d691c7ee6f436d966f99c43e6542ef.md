### Title
Unhandled KeyNotFoundException in UpdateValueValidationProvider Due to Missing SenderPubkey in ProvidedRound

### Summary
The `UpdateValueValidationProvider` directly accesses `ProvidedRound.RealTimeMinersInformation[SenderPubkey]` without verifying the key exists, allowing a malicious miner to cause consensus validation exceptions by providing a crafted Round that excludes their own public key. This creates a denial-of-service vector affecting block validation across the network.

### Finding Description

The vulnerability exists in the `UpdateValueValidationProvider.NewConsensusInformationFilled` method where it performs an unsafe dictionary access: [1](#0-0) 

Similarly, the `ValidatePreviousInValue` method has two additional unsafe accesses to the ProvidedRound at lines 42 and 45, even though line 40 only checks the PreviousRound: [2](#0-1) 

**Root Cause**: The `ProvidedRound` comes from untrusted block header data (`ExtraData.Round`), defined here: [3](#0-2) 

**Why Existing Protections Fail**:

1. The `MiningPermissionValidationProvider` only validates that `SenderPubkey` exists in `BaseRound` (trusted state data), not in `ProvidedRound` (untrusted header data): [4](#0-3) 

2. The validation pipeline in `ValidateBeforeExecution` adds `UpdateValueValidationProvider` before `LibInformationValidationProvider`, which does properly check `ContainsKey`: [5](#0-4) 

3. While `RecoverFromUpdateValue` safely checks for missing keys, this only affects the recovery logic and doesn't prevent the subsequent unsafe access in validation: [6](#0-5) 

**Execution Path**: Block received → `ValidateBeforeExecution` → MiningPermissionValidationProvider (passes on BaseRound) → UpdateValueValidationProvider → KeyNotFoundException thrown at line 30.

### Impact Explanation

**Harm**: An unhandled `KeyNotFoundException` during consensus validation causes:
- Node crash or validation failure when processing the malicious block
- Disruption of consensus validation across nodes receiving the block
- Potential network-wide DoS if the malicious block propagates

**Protocol Damage**: While no funds are directly at risk, the consensus mechanism's availability and reliability are compromised. Nodes cannot properly validate blocks, potentially causing:
- Chain progression delays
- Network synchronization issues
- Degraded network performance

**Affected Parties**: All nodes attempting to validate blocks from the malicious miner.

**Severity Justification**: Medium severity because:
- Requires attacker to be a valid miner (restricted attacker set)
- Causes operational disruption but not fund loss
- Impact is temporary and detectable (exception logs reveal malicious miner)
- Nodes can recover by rejecting the malicious block

### Likelihood Explanation

**Attacker Capabilities**: Attacker must be a valid miner (passes `MiningPermissionValidationProvider`), meaning they are part of the elected miner set. This is a privileged but realistic attacker model.

**Attack Complexity**: Trivial. The normal flow creates ProvidedRound with SenderPubkey via `GetUpdateValueRound`: [7](#0-6) 

An attacker simply needs to:
1. Generate normal consensus header via `GetConsensusBlockExtraData`
2. Modify the `Round.RealTimeMinersInformation` to remove their own pubkey
3. Sign and submit the block

**Feasibility Conditions**: 
- Attacker controls a miner node
- Can modify block header data before signing
- No additional preconditions required

**Detection/Operational Constraints**: The attack is easily detectable through exception logs, making it unsuitable for prolonged exploitation. The malicious miner can be quickly identified and potentially removed from the miner set through governance.

**Probability**: High probability that a malicious miner could execute this attack, but low probability of sustained impact due to easy detection.

### Recommendation

**Code-Level Mitigation**: Add defensive key existence checks before accessing `ProvidedRound.RealTimeMinersInformation`:

```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    // Add safety check
    if (!validationContext.ProvidedRound.RealTimeMinersInformation.ContainsKey(validationContext.SenderPubkey))
        return false;
        
    var minerInRound =
        validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    return minerInRound.OutValue != null && minerInRound.Signature != null &&
           minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
}

private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;

    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

    // Add safety check before accessing ProvidedRound
    if (!extraData.Round.RealTimeMinersInformation.ContainsKey(publicKey)) return false;
    
    if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

    var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
    var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
    if (previousInValue == Hash.Empty) return true;

    return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
}
```

**Invariant to Enforce**: ProvidedRound must contain SenderPubkey in RealTimeMinersInformation when validating UpdateValue behavior.

**Test Cases**:
1. Test UpdateValue validation with ProvidedRound missing SenderPubkey - should return validation failure, not throw exception
2. Test UpdateValue validation with ProvidedRound containing SenderPubkey but missing consensus data - should return appropriate validation message
3. Test edge case where SenderPubkey exists but has null OutValue/Signature

### Proof of Concept

**Required Initial State**:
- Attacker is a valid miner in current round (has mining permission)
- Current round information stored in state includes attacker's pubkey

**Attack Steps**:
1. Attacker's node receives trigger to produce block with UpdateValue behavior
2. Node generates proper `AElfConsensusHeaderInformation` via `GetConsensusBlockExtraData` which calls `GetUpdateValueRound` to create ProvidedRound
3. Before signing block, attacker modifies the consensus header:
   - Access `information.Round.RealTimeMinersInformation`
   - Remove the entry with key matching attacker's pubkey: `information.Round.RealTimeMinersInformation.Remove(attackerPubkey)`
4. Attacker signs modified block and broadcasts to network
5. Other nodes receive block and begin validation via `ValidateBeforeExecution`

**Expected Result**: Validation should return failure message indicating improper Round structure.

**Actual Result**: 
- `MiningPermissionValidationProvider` passes (checks BaseRound, not ProvidedRound)
- `UpdateValueValidationProvider.NewConsensusInformationFilled` executes
- Line 30 attempts dictionary access: `ProvidedRound.RealTimeMinersInformation[SenderPubkey]`
- `KeyNotFoundException` thrown
- Node validation fails with unhandled exception

**Success Condition**: Exception logged on validating nodes, block rejected, consensus validation disrupted.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L29-30)
```csharp
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L40-45)
```csharp
        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-17)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L10-12)
```csharp
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L18-20)
```csharp
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
```
