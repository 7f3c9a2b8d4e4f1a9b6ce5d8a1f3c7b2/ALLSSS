### Title
Missing Upper and Lower Bound Validation for ImpliedIrreversibleBlockHeight in LIB Validation

### Summary
The `LibInformationValidationProvider.ValidateHeaderInformation()` method lacks critical bound checks on `ImpliedIrreversibleBlockHeight` values submitted by miners during `UpdateValue` consensus behavior. Malicious miners can submit values exceeding the current block height or below the confirmed LIB, potentially corrupting the Last Irreversible Block (LIB) calculation and consensus state.

### Finding Description

The `LibInformationValidationProvider` performs incomplete validation of LIB-related invariants: [1](#0-0) 

The validator only checks that `ImpliedIrreversibleBlockHeight` doesn't decrease relative to the miner's previous value (lines 23-30). It sets `validationResult.Success = true` at line 32 without validating:

1. **Upper bound**: `ImpliedIrreversibleBlockHeight` should not exceed the current block height
2. **Lower bound**: `ImpliedIrreversibleBlockHeight` should be at least as high as `baseRound.ConfirmedIrreversibleBlockHeight`

When miners produce blocks, the honest behavior sets `ImpliedIrreversibleBlockHeight` to the current height: [2](#0-1) 

However, malicious miners can modify their node software to submit arbitrary values. During processing, this value is stored directly without bounds checking: [3](#0-2) 

The LIB calculation then uses these potentially invalid values from the previous round: [4](#0-3) 

If the calculated `libHeight` exceeds the current chain height, it's still stored in consensus state: [5](#0-4) 

Note: The first validation check (lines 14-21 of LibInformationValidationProvider) is ineffective for `UpdateValue` behavior because the simplified round doesn't include `ConfirmedIrreversibleBlockHeight/RoundNumber` fields: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Compromise:**
- If 1/3+ malicious miners collude and submit `ImpliedIrreversibleBlockHeight` values exceeding actual block heights, the LIB calculation could advance to non-existent blocks
- `ConfirmedIrreversibleBlockHeight` in consensus state becomes corrupted with invalid heights
- `IrreversibleBlockFound` events fire with invalid heights, potentially affecting downstream systems

**Cross-Chain and Finality Issues:**
- Cross-chain verification relies on accurate LIB heights for parent/side-chain indexing
- Systems that consume LIB data without independent validation could be affected
- Artificially low values (but above previous) could stall LIB advancement, delaying finality

**Partial Mitigation Exists:**
The `IrreversibleBlockFoundLogEventProcessor` includes a safety check that prevents setting the chain's LIB to non-existent blocks: [7](#0-6) 

However, this is defense-in-depth only - validation should be the first line of defense, and corrupted state values remain stored in the consensus contract.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an authorized miner in the consensus miner set
- Requires modifying node software to submit invalid `ImpliedIrreversibleBlockHeight` values
- Needs 1/3+ of miners to collude for meaningful impact on LIB calculation (due to median-based consensus at position `(count-1)/3`)

**Attack Complexity:**
- Low technical complexity once miner access is obtained
- The validation gap is reachable through normal `UpdateValue` consensus transactions
- No additional authentication bypass needed beyond miner authorization

**Feasibility:**
- Miners are semi-trusted parties, but compromise or collusion is within threat model
- Economic incentives could motivate manipulation (e.g., to affect cross-chain operations or finality timing)
- Detection would be delayed as invalid LIB values might not be immediately apparent

### Recommendation

Add comprehensive bound validation to `LibInformationValidationProvider.ValidateHeaderInformation()`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var baseRound = validationContext.BaseRound;
    var providedRound = validationContext.ProvidedRound;
    var pubkey = validationContext.SenderPubkey;
    
    // Existing checks for ConfirmedIrreversibleBlockHeight/RoundNumber (lines 14-21)
    // ...
    
    // Existing check for ImpliedIrreversibleBlockHeight backward regression (lines 23-30)
    // ...
    
    // NEW: Add upper bound validation
    if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
        providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0)
    {
        // ImpliedIrreversibleBlockHeight should not exceed current block height
        // Note: Need to add CurrentHeight to ConsensusValidationContext
        if (providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight > 
            validationContext.CurrentHeight)
        {
            validationResult.Message = "Implied lib height exceeds current block height.";
            return validationResult;
        }
        
        // ImpliedIrreversibleBlockHeight should be at least as high as confirmed LIB
        if (baseRound.ConfirmedIrreversibleBlockHeight > 0 &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight < 
            baseRound.ConfirmedIrreversibleBlockHeight)
        {
            validationResult.Message = "Implied lib height below confirmed lib height.";
            return validationResult;
        }
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

**Required Changes:**
1. Extend `ConsensusValidationContext` to include `CurrentHeight` field
2. Update `ValidateBeforeExecution` to populate `CurrentHeight` from `Context.CurrentHeight`
3. Add the two new validation checks as shown above

**Test Cases:**
- Test that `ImpliedIrreversibleBlockHeight > Context.CurrentHeight` is rejected
- Test that `ImpliedIrreversibleBlockHeight < ConfirmedIrreversibleBlockHeight` is rejected  
- Test that valid values within bounds are accepted
- Test collusion scenario with 1/3+ miners submitting invalid values

### Proof of Concept

**Required Initial State:**
- Node operates as an authorized miner in the consensus miner set
- Current round number: R, current block height: H
- `baseRound.ConfirmedIrreversibleBlockHeight = H - 100`

**Attack Sequence:**

1. **Malicious Miner Setup:** Modify node software to override `ImpliedIrreversibleBlockHeight` generation:
   - Instead of using `Context.CurrentHeight` (honest behavior at line 118 of GetConsensusBlockExtraData.cs)
   - Set `ImpliedIrreversibleBlockHeight = H + 10000` (far exceeding current height)

2. **Submit UpdateValue Transaction:** Miner produces block at height H+1 with manipulated consensus data:
   - `UpdateValueInput.ImpliedIrreversibleBlockHeight = H + 10000`
   - All other consensus data is valid (signature, outValue, etc.)

3. **Validation Passes:** `LibInformationValidationProvider` only checks backward regression:
   - Since `H + 10000 > previousValue`, validation passes at line 32
   - No upper bound check against current height exists

4. **State Corruption:** In `ProcessUpdateValue`:
   - Line 248 stores: `minerInRound.ImpliedIrreversibleBlockHeight = H + 10000`
   - In next round's LIB calculation, if 1/3+ miners collude, `libHeight` could be set to non-existent height
   - Line 279: `currentRound.ConfirmedIrreversibleBlockHeight` updated to invalid value
   - Line 275: `IrreversibleBlockFound` event fired with `IrreversibleBlockHeight = (invalid height)`

**Expected vs Actual Result:**
- **Expected:** Validation should reject `ImpliedIrreversibleBlockHeight > CurrentHeight` with error message
- **Actual:** Validation passes, invalid value stored in consensus state, corrupting LIB tracking

**Success Condition:**
Query `GetCurrentRoundInformation()` and observe `ConfirmedIrreversibleBlockHeight` contains a value exceeding the actual chain height, demonstrating successful state corruption through validation bypass.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L8-34)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L272-281)
```csharp
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-56)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = pubkey,
                    OutValue = minerInRound.OutValue,
                    Signature = minerInRound.Signature,
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    PreviousInValue = minerInRound.PreviousInValue,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
                    Order = minerInRound.Order,
                    IsExtraBlockProducer = minerInRound.IsExtraBlockProducer
                }
            }
        };
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }

        return round;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockFoundLogEventProcessor.cs (L63-65)
```csharp
            var libBlockHash = await _blockchainService.GetBlockHashByHeightAsync(chain,
                irreversibleBlockFound.IrreversibleBlockHeight, block.GetHash());
            if (libBlockHash == null) return;
```
