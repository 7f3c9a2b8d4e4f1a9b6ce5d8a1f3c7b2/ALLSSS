### Title
Integer Overflow DoS in Transaction Fee Calculation When BasicFee Set to Int64.MaxValue

### Summary
The `SetMethodFee()` function accepts `BasicFee` values up to `Int64.MaxValue` without upper bound validation. When such a fee is set and a transaction with any positive size fee is charged, the fee calculation throws an `OverflowException` at the arithmetic addition step, causing all transactions for that method to fail and creating a denial of service condition.

### Finding Description

The vulnerability exists across two contract files: [1](#0-0) 

The `AssertValidToken` validation only checks that the amount is non-negative, with no upper bound check to prevent values that will cause overflow in subsequent calculations. [2](#0-1) 

When fees are charged, the system first processes the base fee, then adds size-based fees. The critical overflow occurs in the `GenerateBill` method: [3](#0-2) 

When `symbolChargedForBaseFee == symbolToPayTxFee` (base fee and size fee use the same token), line 548 attempts to add the size fee charge to the existing base fee charge using checked arithmetic: [4](#0-3) 

The `Add()` extension method operates in a `checked` context, which throws `OverflowException` when the result exceeds `Int64.MaxValue`. If `BasicFee = Int64.MaxValue` and any size fee `> 0` must be added, the operation `Int64.MaxValue + sizeFee` triggers the exception, causing the transaction to fail.

### Impact Explanation

**Operational Impact - Method Denial of Service**: Once `BasicFee` is set to `Int64.MaxValue` (or sufficiently close to it), every transaction calling that method with a non-zero transaction size will fail with an `OverflowException`. This completely disables the method's functionality for all users.

**Scope**: Affects any contract method where governance sets an extremely high `BasicFee` value. Since the Parliament contract (and all ACS1 implementations) share this validation logic, the vulnerability is systemic across all fee-charging methods in the AElf ecosystem.

**Severity Justification**: While this requires governance action to set the problematic fee value, it represents a design flaw where the contract accepts input values that render the system inoperable. The contract should either reject such values or handle them gracefully. The DoS is complete and permanent until governance intervenes to reduce the fee.

### Likelihood Explanation

**Preconditions**: 
- The `MethodFeeController` (typically Parliament governance) must call `SetMethodFee()` with `BasicFee = Int64.MaxValue` or a value close enough that adding size fees causes overflow
- Any user attempts to call the affected method with a transaction size > 0

**Feasibility**: The scenario is realistic in several contexts:
1. **Configuration Error**: Governance accidentally sets an extremely high fee due to unit confusion or input error
2. **Extreme Deterrence**: Governance intentionally sets maximum fee to make a method prohibitively expensive, not realizing it breaks the system
3. **Upgrade Transition**: During contract migration, fee values might be set to maximum as temporary measure

**Attack Complexity**: Once the high fee is set (whether accidentally or intentionally), the DoS is automatic - every transaction with size > 0 fails without any additional attacker action.

**Detection**: The overflow exception would be immediately visible in failed transactions, making this issue detectable but still disruptive.

### Recommendation

**1. Add Upper Bound Validation in SetMethodFee**:

Modify the validation in `AssertValidToken` to reject fees that could cause overflow when combined with typical size fees:

```csharp
private void AssertValidToken(string symbol, long amount)
{
    Assert(amount >= 0, "Invalid amount.");
    // Reserve headroom for size fees (e.g., max transaction size * max size fee rate)
    // Assuming max reasonable fee is 10^18 tokens, reject values above this threshold
    Assert(amount <= 1_000_000_000_000_000_000L, "Basic fee exceeds maximum safe value.");
    
    if (State.TokenContract.Value == null)
        State.TokenContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
            
    Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
        $"Token {symbol} cannot set as method fee.");
}
```

**2. Add Overflow Protection in GenerateBill**:

Replace the arithmetic operation with overflow-safe logic:

```csharp
if (symbolChargedForBaseFee == symbolToPayTxFee)
{
    // Check for potential overflow before addition
    if (bill.FeesMap[symbolToPayTxFee] > 0 && chargeAmount > long.MaxValue - bill.FeesMap[symbolToPayTxFee])
    {
        // Cap at max value or charge only what fits
        bill.FeesMap[symbolToPayTxFee] = long.MaxValue;
    }
    else
    {
        bill.FeesMap[symbolToPayTxFee] = bill.FeesMap[symbolToPayTxFee].Add(chargeAmount);
    }
    // Similar logic for allowanceBill
}
```

**3. Add Test Cases**:
- Test setting `BasicFee = Int64.MaxValue` (should be rejected)
- Test setting `BasicFee = Int64.MaxValue - 1000` with size fee = 2000 (should handle gracefully)
- Test edge cases near overflow boundaries

### Proof of Concept

**Initial State**:
1. Parliament contract deployed and initialized
2. Default organization has authority over method fee controller

**Exploit Steps**:

**Step 1** - Set extreme BasicFee:
```
Method: ParliamentContract.SetMethodFee
Input: {
    MethodName: "CreateProposal",
    Fees: [{
        Symbol: "ELF",
        BasicFee: 9223372036854775807  // Int64.MaxValue
    }]
}
Sender: MethodFeeController.OwnerAddress
```
Expected: Transaction succeeds (fee is set)

**Step 2** - Attempt to use the method:
```
Method: ParliamentContract.CreateProposal
Input: { /* any valid proposal */ }
TransactionSize: 1000 bytes (non-zero)
```
Expected Result: Transaction succeeds
Actual Result: **Transaction fails with OverflowException** when `ChargeTransactionFees` attempts to calculate total fee at `GenerateBill` line 548

**Success Condition**: 
The vulnerability is confirmed if Step 1 succeeds but Step 2 fails with an overflow exception, demonstrating that the accepted fee value renders the method unusable.

**Additional Note**: There is a secondary vulnerability in the fee aggregation logic: [5](#0-4) 

The LINQ `Sum()` method operates in an unchecked context and can silently overflow if multiple `MethodFee` entries for the same symbol sum beyond `Int64.MaxValue`, wrapping to a negative value. This allows fee bypass if governance sets multiple fee entries whose sum overflows. The test suite confirms duplicate symbols are permitted: [6](#0-5)

### Citations

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L80-89)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L322-327)
```csharp
    private Dictionary<string, long> GetBaseFeeDictionary(MethodFees methodFees)
    {
        return methodFees.Fees.Where(f => !string.IsNullOrEmpty(f.Symbol))
            .GroupBy(f => f.Symbol, f => f.BasicFee)
            .ToDictionary(g => g.Key, g => g.Sum());
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L545-551)
```csharp
        if (symbolChargedForBaseFee == symbolToPayTxFee)
        {
            bill.FeesMap[symbolToPayTxFee] =
                bill.FeesMap[symbolToPayTxFee].Add(chargeAmount);
            allowanceBill.FreeFeeAllowancesMap[symbolToPayTxFee] =
                allowanceBill.FreeFeeAllowancesMap[symbolToPayTxFee].Add(chargeAllowanceAmount);
        }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L100-106)
```csharp
    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutePluginTransactionDirectlyTest.cs (L66-104)
```csharp
    public async Task Set_Repeat_Token_Test()
    {
        await IssueTokenToDefaultSenderAsync(NativeTokenSymbol, 100000_00000000);
        await SetPrimaryTokenSymbolAsync();
        var address = DefaultSender;
        var methodName = nameof(TokenContractContainer.TokenContractStub.Transfer);
        var basicMethodFee = 1000;
        var methodFee = new MethodFees
        {
            MethodName = methodName,
            Fees =
            {
                new MethodFee
                {
                    Symbol = NativeTokenSymbol,
                    BasicFee = basicMethodFee
                },
                new MethodFee
                {
                    Symbol = NativeTokenSymbol,
                    BasicFee = basicMethodFee
                }
            }
        };
        var sizeFee = 0;
        await TokenContractImplStub.SetMethodFee.SendAsync(methodFee);
        var beforeChargeBalance = await GetBalanceAsync(address, NativeTokenSymbol);
        var chargeTransactionFeesInput = new ChargeTransactionFeesInput
        {
            MethodName = methodName,
            ContractAddress = TokenContractAddress,
            TransactionSizeFee = sizeFee,
        };

        var chargeFeeRet = await TokenContractStub.ChargeTransactionFees.SendAsync(chargeTransactionFeesInput);
        chargeFeeRet.Output.Success.ShouldBeTrue();
        var afterChargeBalance = await GetBalanceAsync(address, NativeTokenSymbol);
        beforeChargeBalance.Sub(afterChargeBalance).ShouldBe(basicMethodFee.Add(basicMethodFee));
    }
```
