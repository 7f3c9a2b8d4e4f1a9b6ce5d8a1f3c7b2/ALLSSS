### Title
Manager Can Steal Profits via FixProfitDetail Period Manipulation After Distribution

### Summary
The `FixProfitDetail` function allows the scheme Manager or TokenHolder contract to arbitrarily modify beneficiary period ranges without proper validation or state consistency updates. By extending expired EndPeriods after profit distribution but before claiming, or by backdating StartPeriods, the Manager can inflate scheme.TotalShares in future distributions and claim profits from periods they weren't entitled to, directly stealing funds from legitimate beneficiaries.

### Finding Description

The vulnerability exists in the `FixProfitDetail` function which allows modifying a beneficiary's `StartPeriod` and `EndPeriod` without critical validations: [1](#0-0) 

**Root Cause:**

The function has four critical missing checks:

1. **No validation that modified periods don't conflict with already-distributed periods** - Unlike `AddBeneficiary` which enforces `input.EndPeriod >= scheme.CurrentPeriod`, `FixProfitDetail` has no such check. [2](#0-1) 

2. **No update to scheme.TotalShares when periods are extended** - When `AddBeneficiary` adds shares, it updates `scheme.TotalShares`. When `FixProfitDetail` extends periods, it does NOT update TotalShares. [3](#0-2) 

3. **No validation of period boundaries** - The function blindly accepts any StartPeriod/EndPeriod values including past periods already distributed. [4](#0-3) 

**How the Exploit Works:**

When `DistributeProfits` is called, it captures `scheme.TotalShares` at that moment and stores it in `distributedProfitsInformation.TotalShares` for that specific period: [5](#0-4) [6](#0-5) [7](#0-6) 

When beneficiaries claim profits and their `LastProfitPeriod > EndPeriod`, their shares are removed from `scheme.TotalShares`: [8](#0-7) 

**Attack Vector 1 - EndPeriod Extension to Inflate TotalShares:**

If the Manager uses `FixProfitDetail` to extend a beneficiary's `EndPeriod` AFTER distribution but BEFORE they claim, the shares won't be removed when they should be. This inflates `scheme.TotalShares` for future distributions, diluting all other beneficiaries' shares and allowing the attacker to claim from periods they weren't entitled to.

**Attack Vector 2 - StartPeriod Manipulation:**

By setting `StartPeriod` to an earlier period that was already distributed, the attacker can claim profits from past periods before other beneficiaries claim, stealing their allocated funds. [9](#0-8) 

### Impact Explanation

**Direct Fund Theft:**

Consider a scheme with:
- Beneficiary A: 100 shares, EndPeriod=1
- Beneficiary B: 900 shares, EndPeriod=10
- TotalShares=1000

**Normal Flow:**
- Period 1: Distribute 1000 ELF, TotalShares=1000
- A claims Period 1: gets 100 ELF, shares removed, TotalShares→900
- Period 2: Distribute 900 ELF, TotalShares=900
- B claims Period 2: gets 900 ELF ✓

**Attack Flow:**
- Period 1: Distribute 1000 ELF, TotalShares=1000
- Manager extends A's EndPeriod to 10
- A claims Period 1: gets 100 ELF, shares NOT removed (LastProfitPeriod=2 ≤ EndPeriod=10), TotalShares=1000
- Period 2: Distribute 900 ELF, **TotalShares=1000** (inflated!)
- B claims: (900/1000) × 900 = **810 ELF** (loses 90 ELF)
- A claims: (100/1000) × 900 = **90 ELF** (steals 90 ELF)

Over periods 2-10, A steals **810 ELF total** from B.

**Who is Affected:**
- All legitimate beneficiaries in the scheme suffer diluted distributions
- The economic model of profit distribution is fundamentally broken
- Multiple schemes across the ecosystem could be exploited simultaneously

### Likelihood Explanation

**Attacker Capabilities:**
- Requires Manager role (scheme creator) or compromised TokenHolder contract
- Manager is designed to be a trusted administrative role, but this level of post-distribution manipulation exceeds reasonable administrative powers

**Attack Complexity:**
- Trivial to execute: single `FixProfitDetail` transaction
- No complex contract interactions or timing requirements
- Can be automated and repeated across multiple periods

**Feasibility Conditions:**
- Entry point is the public `FixProfitDetail` method accessible to Manager [10](#0-9) 

- Preconditions are realistic: schemes exist with multiple beneficiaries and periodic distributions
- The Election contract already uses FixProfitDetail legitimately, showing the function is production-ready [11](#0-10) 

**Detection Constraints:**
- No on-chain event or audit trail for suspicious period modifications
- Silent state corruption that only manifests during subsequent claims
- No monitoring mechanism to detect inflated TotalShares

**Economic Rationality:**
- Zero cost to execute (only gas fees)
- Direct profit proportional to scheme size and number of periods
- For large schemes with substantial distributions, theft could be significant

### Recommendation

**Immediate Fix - Add Period Validation:**

Add validation in `FixProfitDetail` to prevent modification of periods that conflict with already-distributed profits:

```csharp
public override Empty FixProfitDetail(FixProfitDetailInput input)
{
    Assert(input.SchemeId != null, "Invalid scheme id.");
    var scheme = State.SchemeInfos[input.SchemeId];
    
    // Authorization check
    if (Context.Sender != scheme.Manager && Context.Sender !=
        Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
    {
        throw new AssertionException("Only manager or token holder contract can add beneficiary.");
    }
    
    // NEW: Validate period boundaries
    if (input.EndPeriod != 0)
    {
        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Cannot set EndPeriod to past period. EndPeriod: {input.EndPeriod}, CurrentPeriod: {scheme.CurrentPeriod}");
    }
    
    var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
    ProfitDetail fixingDetail = /* existing logic */;
    
    if (fixingDetail == null)
    {
        throw new AssertionException("Cannot find proper profit detail to fix.");
    }
    
    // NEW: Prevent backdating StartPeriod to already-distributed periods
    if (input.StartPeriod != 0)
    {
        Assert(input.StartPeriod >= fixingDetail.LastProfitPeriod || fixingDetail.LastProfitPeriod == 0,
            $"Cannot set StartPeriod before already-claimed periods. StartPeriod: {input.StartPeriod}, LastProfitPeriod: {fixingDetail.LastProfitPeriod}");
    }
    
    // Existing cloning logic...
}
```

**Additional Safeguards:**

1. **Emit Event for Audit Trail:**
   - Fire event when periods are modified showing old/new values
   - Enable off-chain monitoring for suspicious modifications

2. **Require Reason/Justification:**
   - Add optional memo field to document why periods are being modified
   - Support governance review of modifications

3. **Time-lock for Modifications:**
   - Implement delay between modification and when it takes effect
   - Allow beneficiaries to exit before modifications apply

### Proof of Concept

**Initial State:**
- Scheme created with Manager = Attacker
- Add Beneficiary A (Attacker): 100 shares, EndPeriod=1, StartPeriod=1
- Add Beneficiary B (Victim): 900 shares, EndPeriod=10, StartPeriod=1
- scheme.TotalShares = 1000

**Execution Steps:**

1. **Period 1 Distribution:**
   - Attacker calls `ContributeProfits` with 1000 ELF for Period 1
   - Attacker calls `DistributeProfits` for Period 1
   - Result: distributedProfitsInformation[Period1].TotalShares = 1000
   - scheme.CurrentPeriod = 2

2. **Attack Transaction:**
   - Attacker calls `FixProfitDetail`:
     - SchemeId: [scheme_id]
     - BeneficiaryShare: { Beneficiary: Attacker, Shares: 100 }
     - StartPeriod: 0 (keep original)
     - EndPeriod: 10 (extend from 1)
     - ProfitDetailId: [attacker's profit detail id]

3. **Claim Period 1:**
   - Attacker calls `ClaimProfits` for Period 1
   - Gets: (100/1000) × 1000 = 100 ELF
   - LastProfitPeriod = 2
   - **Expected:** shares removed, scheme.TotalShares → 900
   - **Actual:** shares NOT removed (2 ≤ 10), scheme.TotalShares = 1000 ✗

4. **Period 2 Distribution:**
   - Contribute 900 ELF for Period 2
   - Call `DistributeProfits` for Period 2
   - **Expected:** distributedProfitsInformation[Period2].TotalShares = 900
   - **Actual:** distributedProfitsInformation[Period2].TotalShares = 1000 ✗

5. **Claim Period 2:**
   - Victim calls `ClaimProfits` for Period 2
     - **Expected:** (900/900) × 900 = 900 ELF
     - **Actual:** (900/1000) × 900 = 810 ELF ✗
   - Attacker calls `ClaimProfits` for Period 2
     - **Expected:** 0 ELF (not entitled to Period 2)
     - **Actual:** (100/1000) × 900 = 90 ELF ✗

**Success Condition:**
- Attacker successfully claims 90 ELF from Period 2 they weren't entitled to
- Victim loses 90 ELF from their rightful share
- Attack can repeat for periods 3-10, stealing 810 ELF total

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L179-180)
```csharp
        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L182-184)
```csharp
        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);

        State.SchemeInfos[schemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-306)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }

        // Try to get profitDetails by Id
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
        ProfitDetail fixingDetail = null;
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }

        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L462-462)
```csharp
        var totalShares = scheme.TotalShares;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L490-490)
```csharp
        UpdateDistributedProfits(profitsMap, profitsReceivingVirtualAddress, totalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L567-567)
```csharp
        distributedProfitsInformation.TotalShares = totalShares;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-792)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L144-154)
```csharp
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
```
