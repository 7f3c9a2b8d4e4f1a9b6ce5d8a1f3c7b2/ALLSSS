### Title
Banned Candidates Can Be Selected As Active Miners Through Missing Ban Validation

### Summary
The `GetPreviousTermSnapshotWithNewestPubkey()` function replaces banned candidates with their newest pubkey without validating if the newest pubkey is also banned. This allows banned/evil nodes to become active miners when the consensus contract selects alternative candidates, directly violating the consensus integrity invariant that banned nodes cannot participate in block production.

### Finding Description
The vulnerability exists in a multi-step flow across the Election and Consensus contracts:

**Root Cause:** In `GetPreviousTermSnapshotWithNewestPubkey()`, when processing banned candidates from the election snapshot, the function retrieves the newest pubkey via `GetNewestPubkey()` but fails to validate if the newest pubkey itself is banned. [1](#0-0) 

The validation at line 153 only checks three conditions:
- `newestPubkey == null` 
- `newestPubkey == bannedCandidate`
- `snapshot.ElectionResult.ContainsKey(newestPubkey)`

**Missing:** No call to `IsPubkeyBanned(newestPubkey)` [2](#0-1) 

**Execution Path:**
1. The snapshot with a banned replacement pubkey is used by `GetMinerReplacementInformation()` [3](#0-2) 

2. Alternative candidates are selected from the snapshot WITHOUT checking if they are banned (lines 368-377)

3. The consensus contract receives these alternatives and directly adds them to the active miner list: [4](#0-3) 

At line 338, the banned pubkey is added to `currentRound.RealTimeMinersInformation` without any ban validation.

**Why Protections Fail:**
When a pubkey is replaced via `ReplaceCandidatePubkey()`, the old pubkey is banned: [5](#0-4) 

If the new pubkey is subsequently marked as evil via `UpdateCandidateInformation()`, it also becomes banned: [6](#0-5) 

However, the replacement mapping persists: [7](#0-6) 

When `GetNewestPubkey()` is called, it returns the banned replacement: [8](#0-7) 

### Impact Explanation
**Consensus Integrity Violation:** Banned/evil nodes can become active miners, allowing previously identified malicious actors to participate in block production and consensus. This directly violates Critical Invariant #2: "miner schedule integrity."

**Concrete Harm:**
- Banned miners can produce blocks and receive rewards
- Evil nodes continue participating after being identified and banned
- The security model's assumption that banned nodes are excluded from consensus is violated
- Potential for continued malicious behavior (e.g., censorship, double-spending attempts)

**Affected Parties:**
- All network participants relying on honest consensus
- The protocol's security guarantees
- Token holders whose assets depend on consensus integrity

**Severity Justification:** High - This is a direct bypass of a critical security control that allows banned entities to participate in consensus, undermining the entire ban mechanism.

### Likelihood Explanation
**Attacker Capabilities:** 
- Requires ability to announce election as a candidate (public operation)
- Requires admin permission to replace pubkey (legitimate for candidates)
- Requires the new pubkey to be marked as evil (happens through normal evil node detection)

**Attack Complexity:** Low to Medium
- All steps are legitimate contract operations
- No privilege escalation required beyond normal candidate operations
- Happens automatically during consensus round generation

**Feasibility Conditions:**
1. Candidate replaces pubkey A → B (A gets banned per normal replacement flow)
2. B is marked as evil through `UpdateCandidateInformation()` or `RemoveEvilNode()` (B gets banned)
3. A was in previous term's election snapshot with votes
4. Evil miner replacement occurs in consensus

**Execution Practicality:** 
- All operations are standard AElf contract calls
- No timing constraints or race conditions
- Triggered automatically by consensus contract during round generation

**Detection/Operational Constraints:** 
- Difficult to detect as it appears as normal miner replacement
- No alerts or checks would identify the banned status
- Operates within normal consensus flow

**Probability:** Medium-High - While requiring a specific sequence (replacement followed by ban), all steps are routine operations that can occur naturally or be deliberately orchestrated.

### Recommendation
**Immediate Fix:**
Add banned pubkey validation in `GetPreviousTermSnapshotWithNewestPubkey()` at line 153 in `ViewMethods.cs`:

```csharp
if (newestPubkey == null || newestPubkey == bannedCandidate ||
    snapshot.ElectionResult.ContainsKey(newestPubkey) || IsPubkeyBanned(newestPubkey)) 
    continue;
```

**Defense-in-Depth:**
Add a secondary check in `GetMinerReplacementInformation()` when filtering candidates at line 370-374:

```csharp
.Where(cs => !State.InitialMiners.Value.Value.Contains(
    ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
.Where(cs => !input.CurrentMinerList.Contains(cs.Key))
.Where(cs => !IsPubkeyBanned(cs.Key))  // Add this line
.OrderByDescending(s => s.Value).ToList();
```

**Test Cases:**
1. Test replacement chain where newest pubkey is banned
2. Test that banned replacements are not selected as alternatives
3. Test that `GetCurrentMinerList()` never contains banned pubkeys
4. Test circular replacement scenarios (A→B→A) if theoretically possible

### Proof of Concept

**Initial State:**
- Candidate with pubkey A has announced election
- A appears in previous term snapshot with votes
- `State.BannedPubkeyMap[A] = false`
- `State.BannedPubkeyMap[B] = false`

**Exploit Sequence:**

**Step 1:** Replace pubkey A with B
```
ReplaceCandidatePubkey({
    OldPubkey: "A",
    NewPubkey: "B"
})
```
Result: `State.BannedPubkeyMap[A] = true`, `State.InitialToNewestPubkeyMap[A] = "B"`

**Step 2:** Mark B as evil node
```
UpdateCandidateInformation({
    Pubkey: "B",
    IsEvilNode: true
})
```
Result: `State.BannedPubkeyMap[B] = true`

**Step 3:** Consensus generates next round (automatic during consensus)
```
GenerateNextRoundInformation() 
    → calls GetMinerReplacementInformation()
    → calls GetPreviousTermSnapshotWithNewestPubkey()
```

**Internal Execution:**
- Snapshot contains A (banned)
- `GetNewestPubkey("A")` returns "B"
- Check: B ≠ null ✓, B ≠ A ✓, B not in snapshot ✓
- **MISSING: IsPubkeyBanned(B) = true ✗**
- B replaces A in snapshot
- B selected as alternative candidate
- B added to `RealTimeMinersInformation`

**Expected Result (Secure):** B should be skipped due to banned status

**Actual Result (Vulnerable):** B is added to active miner list

**Success Condition:**
```
GetCurrentMinerList() contains "B"
AND State.BannedPubkeyMap["B"] == true
```
This violates the invariant that banned pubkeys cannot be active miners.

**Notes:**
- The question asks about "infinite replacement chains or circular bans." While the code does not create infinite loops (GetNewestPubkey simply returns a mapped value without recursion), the vulnerability allows a single-step banned replacement to bypass validation.
- The ban check is only performed when selecting from initial miners (line 389 in ViewMethods.cs) but not when selecting from the election snapshot.
- This issue does not require circular bans (A→B→A) to be exploitable; a simple linear chain (A→B where both are banned) is sufficient.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L149-158)
```csharp
        foreach (var bannedCandidate in bannedCandidates)
        {
            var newestPubkey = GetNewestPubkey(bannedCandidate);
            // If newest pubkey not exists or same as old pubkey (which is banned), skip.
            if (newestPubkey == null || newestPubkey == bannedCandidate ||
                snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
            if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L363-377)
```csharp
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L61-64)
```csharp
    private bool IsPubkeyBanned(string pubkey)
    {
        return State.BannedPubkeyMap[pubkey];
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-342)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L246-246)
```csharp
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L280-291)
```csharp
    private void PerformReplacement(string oldPubkey, string newPubkey)
    {
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```
