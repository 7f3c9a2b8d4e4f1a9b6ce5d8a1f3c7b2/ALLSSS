# Audit Report

## Title
Candidate Admin Separation Invariant Can Be Bypassed Through AnnounceElectionFor

## Summary
The Election contract enforces an invariant that "Candidate cannot be others' admin" through a validation check in `AnnounceElection`. However, this critical check is absent from `AnnounceElectionFor` and `SetCandidateAdmin`, allowing candidates to bypass the restriction and become admins for other candidates, violating the intended separation of roles and enabling centralization of control over multiple candidate slots.

## Finding Description

The Election contract maintains two related state mappings that track the relationship between candidates and their administrators: [1](#0-0) [2](#0-1) 

The `AnnounceElection` method explicitly enforces that a candidate cannot be an admin for other candidates through a validation check: [3](#0-2) 

This assertion verifies that when someone becomes a candidate, their address is not currently managing any other candidates. The error message "Candidate cannot be others' admin" explicitly states the intended invariant.

However, this critical validation is **completely missing** from the `AnnounceElectionFor` method, which provides an alternative path to register candidates: [4](#0-3) 

The `AnnounceElectionFor` method directly assigns the admin and adds the pubkey to the admin's managed list without checking whether the admin is already a candidate. Similarly, `SetCandidateAdmin` allows changing a candidate's admin without this validation: [5](#0-4) 

**Exploitation Path:**
1. Alice calls `AnnounceElection(Alice_address)` with herself as admin
   - The check at line 102 passes because Alice is not managing anyone else YET
   - Alice becomes a candidate and `ManagedCandidatePubkeysMap[Alice]` now contains Alice's pubkey
2. Alice calls `AnnounceElectionFor(Bob_pubkey, Alice_address)` 
   - No check validates whether Alice (the admin) is already a candidate
   - Bob is registered with Alice as admin
   - `ManagedCandidatePubkeysMap[Alice]` now contains BOTH Alice's and Bob's pubkeys
3. **Result:** Alice is a candidate AND manages another candidate (Bob), violating the stated invariant

The root cause is that the invariant check only prevents someone who is ALREADY managing other candidates from becoming a candidate. It does not prevent a candidate (who manages themselves) from later becoming an admin for others through `AnnounceElectionFor`.

## Impact Explanation

**Authorization Centralization:**
The candidate admin has privileged control over managed candidates. The Treasury contract explicitly checks admin permissions when setting profit receivers: [6](#0-5) 

This allows the candidate-admin to redirect profits from managed candidates to any address, including their own, effectively extracting rewards earned by infrastructure they don't operate.

Similarly, only the admin can quit election for managed candidates: [7](#0-6) 

And the admin can replace candidate pubkeys, giving them complete control over the candidate identity.

**Governance Integrity Impact:**
- **Centralization of Power:** A single entity can control multiple candidate slots while appearing as independent candidates, violating the decentralization principles of the election system
- **Sybil Attack Vector:** An attacker can register multiple candidates to increase election probability while maintaining control through a single admin address
- **Profit Manipulation:** The admin can unilaterally redirect profits from all managed candidates, extracting value without operating the corresponding infrastructure
- **Competitive Manipulation:** A candidate can control their competitors' operations, creating conflicts of interest

**Protocol Impact:**
This directly violates the explicitly stated design invariant with the error message "Candidate cannot be others' admin." The invariant exists to ensure fairness and prevent centralization in the miner election process, which is fundamental to the AEDPoS consensus security.

## Likelihood Explanation

**Reachability:** Both `AnnounceElection` and `AnnounceElectionFor` are public RPC methods callable by any user without special privileges.

**Attacker Capabilities:** Any user with sufficient tokens for candidate deposits can execute this attack. The cost is 2Ã— the candidate deposit (`ElectionContractConstants.LockTokenForElection` per candidate), which is the normal cost for registering two candidates.

**Execution Practicality:**
- Step 1: Call `AnnounceElection(own_address)` - standard operation, requires paying candidate deposit
- Step 2: Call `AnnounceElectionFor(target_pubkey, own_address)` - standard operation, requires paying another deposit
- Both operations execute in normal transaction flow with no timing constraints or complex state preconditions

**Economic Rationality:** The attack is economically viable when the attacker can extract value through profit manipulation or seeks to centralize mining power. The benefit of controlling multiple candidate slots and redirecting their profits outweighs the cost of candidate deposits, especially for long-term attackers.

**Detection:** The vulnerability can be detected by querying `GetManagedPubkeys` for candidate addresses: [8](#0-7) 

If a candidate address manages multiple pubkeys including non-self pubkeys, it indicates exploitation of this vulnerability.

**Probability:** HIGH - The bypass is straightforward with no special timing requirements, state dependencies, or race conditions. It can be executed immediately after becoming a candidate.

## Recommendation

Add the invariant check to both `AnnounceElectionFor` and `SetCandidateAdmin` methods:

**For `AnnounceElectionFor`**, add the check before assigning the admin (after line 126):
```csharp
Assert(State.ManagedCandidatePubkeysMap[admin] == null || 
       (State.ManagedCandidatePubkeysMap[admin].Value.Count == 1 && 
        State.ManagedCandidatePubkeysMap[admin].Value[0].ToHex() == GetCandidatePubkeyForAddress(admin)),
       "Admin is already a candidate managing others.");
```

**For `SetCandidateAdmin`**, add the check before updating the admin (after line 41):
```csharp
Assert(State.ManagedCandidatePubkeysMap[input.Admin] == null ||
       (State.ManagedCandidatePubkeysMap[input.Admin].Value.Count == 1 &&
        State.ManagedCandidatePubkeysMap[input.Admin].Value[0].ToHex() == GetCandidatePubkeyForAddress(input.Admin)),
       "New admin is already a candidate managing others.");
```

The check should allow self-management (admin managing only their own candidate pubkey) but prevent managing multiple candidates.

## Proof of Concept

```csharp
[Fact]
public async Task CanBypassCandidateAdminSeparationInvariant()
{
    // Setup: Get two keypairs - Alice will be the attacker, Bob will be the victim
    var aliceKeyPair = ValidationDataCenterKeyPairs[0];
    var bobKeyPair = ValidationDataCenterKeyPairs[1];
    
    var aliceAddress = Address.FromPublicKey(aliceKeyPair.PublicKey);
    var aliceElectionStub = GetElectionContractTester(aliceKeyPair);
    
    // Step 1: Alice announces election with herself as admin (normal operation)
    await aliceElectionStub.AnnounceElection.SendAsync(aliceAddress);
    
    // Verify Alice is now a candidate managing herself
    var aliceManagedBefore = await ElectionContractStub.GetManagedPubkeys.CallAsync(aliceAddress);
    aliceManagedBefore.Value.Count.ShouldBe(1);
    aliceManagedBefore.Value[0].ToHex().ShouldBe(aliceKeyPair.PublicKey.ToHex());
    
    // Step 2: Alice uses AnnounceElectionFor to register Bob with herself as admin
    // This should fail according to the invariant but currently succeeds
    await aliceElectionStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = bobKeyPair.PublicKey.ToHex(),
        Admin = aliceAddress
    });
    
    // Verify the invariant is violated: Alice now manages both herself and Bob
    var aliceManagedAfter = await ElectionContractStub.GetManagedPubkeys.CallAsync(aliceAddress);
    aliceManagedAfter.Value.Count.ShouldBe(2); // VIOLATION: Alice manages 2 candidates
    
    // Verify Alice is still a candidate herself
    var candidates = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
    candidates.Value.ShouldContain(ByteString.CopyFrom(aliceKeyPair.PublicKey));
    
    // Verify Alice can control Bob's profits (authorization impact)
    var bobAdmin = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = bobKeyPair.PublicKey.ToHex() });
    bobAdmin.ShouldBe(aliceAddress);
    
    // This proves Alice is a candidate AND manages another candidate, 
    // violating "Candidate cannot be others' admin"
}
```

This test demonstrates that Alice successfully becomes both a candidate and an admin for another candidate (Bob), directly violating the explicitly stated invariant at line 102 of `AnnounceElection`.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L68-68)
```csharp
    public MappedState<string, Address> CandidateAdmins { get; set; }
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L73-73)
```csharp
    public MappedState<Address, PubkeyList> ManagedCandidatePubkeysMap { get; set; }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-57)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;

        var pubkeyByteString = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey));

        var newAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[input.Admin] ?? new PubkeyList();
        if (!newAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            newAdminManagedPubkeys.Value.Add(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[input.Admin] = newAdminManagedPubkeys;

        var oldAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[Context.Sender] ?? new PubkeyList();
        if (oldAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            oldAdminManagedPubkeys.Value.Remove(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[Context.Sender] = oldAdminManagedPubkeys;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L102-102)
```csharp
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L608-609)
```csharp
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L427-430)
```csharp
    public override PubkeyList GetManagedPubkeys(Address input)
    {
        return State.ManagedCandidatePubkeysMap[input];
    }
```
