### Title
Solitary Miner Detection Bypass Allows Monopolization of First Three Rounds During Chain Bootstrap

### Summary
The `SolitaryMinerDetection()` function explicitly skips detection for rounds 1-3, allowing a single active miner among multiple configured initial miners to monopolize block production during the critical bootstrap phase. This creates a window where the consensus protection mechanism designed to prevent solitary mining is completely bypassed. [1](#0-0) 

### Finding Description
The `SolitaryMinerDetection()` method contains a hardcoded condition that prevents solitary miner detection from activating until round 4. When a miner requests a consensus command through `GetConsensusCommand()`, the solitary detection check is performed first, but returns false (allowing mining) when `currentRound.RoundNumber <= 3`. [2](#0-1) 

The detection mechanism is designed to prevent a single miner from mining alone for consecutive rounds by checking if only that miner produced blocks in the current and previous rounds. When triggered, it returns `InvalidConsensusCommand` which prevents further mining. [3](#0-2) 

However, during rounds 1-3, this protection is completely disabled. During chain bootstrap, if multiple initial miners are configured but only one comes online or starts mining first, that miner can produce all blocks in rounds 1-3 without being stopped, even though other miners are configured in the system. [4](#0-3) 

### Impact Explanation
A single initial miner can monopolize the first 3 rounds of block production, capturing all mining rewards and controlling the initial blockchain state during the critical bootstrap phase. While AElf recommends starting with 1-5 initial nodes, this vulnerability allows one miner to operate alone even when multiple miners are configured. [5](#0-4) 

The monopolizing miner gains:
- All mining rewards from the first 3 rounds
- Exclusive control over initial transaction ordering and state
- Potential advantages in early governance, economics, or token distribution

Other configured miners are marked as not having mined, with their `MissedTimeSlots` counters increased, but the active miner faces no consequences until round 4. [6](#0-5) 

### Likelihood Explanation
This vulnerability is exploitable during realistic chain bootstrap scenarios:

1. **Coordinated Launch Timing**: During mainnet/testnet launch, if initial miners don't come online simultaneously, the first miner can monopolize early rounds
2. **Network Connectivity Issues**: Temporary network problems during bootstrap could delay some miners while one continues mining
3. **Intentional Exploitation**: A malicious initial miner could deliberately start mining before coordinating with other initial miners

The attack requires no special privileges beyond being one of the configured initial miners. The execution is straightforward: simply start mining before other initial miners come online. The vulnerability window is limited to 3 rounds, but these are the most critical rounds for establishing initial blockchain state.

The bypass is intentional according to the code comment, likely designed to accommodate network synchronization during bootstrap. However, this creates a concrete vulnerability window where consensus integrity can be compromised. [7](#0-6) 

### Recommendation
Implement solitary miner detection from round 1 with adjusted thresholds for the bootstrap phase:

1. **Enable detection from round 2**: Check if a miner is mining alone starting from round 2 (after the initial round where synchronization is expected)
2. **Add bootstrap grace period**: Instead of completely skipping detection, reduce the consecutive-round requirement during early rounds (e.g., check only 1 previous round instead of 2 for rounds 2-4)
3. **Add minimum miner participation check**: Before allowing any miner to produce a block after round 1, verify that at least a threshold percentage of configured miners have come online (e.g., 51%)
4. **Log bootstrap anomalies**: Emit events when only one miner is active during early rounds to alert operators

Example mitigation:
```
if (currentRound.RoundNumber > 1 && currentRound.RealTimeMinersInformation.Count > 2)
{
    var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
    isAlone = minedMinersOfCurrentRound.Count == 0;
    
    // For rounds 2-4, only check 1 previous round
    if (currentRound.RoundNumber <= 4)
    {
        if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
        {
            var minedMiners = previousRound.GetMinedMiners();
            isAlone = minedMiners.Count == 1 && minedMiners.Select(m => m.Pubkey).Contains(pubkey);
        }
    }
    else
    {
        // Existing logic for rounds 5+
    }
}
```

Add test cases that verify miners cannot monopolize early rounds when multiple initial miners are configured.

### Proof of Concept
**Initial State:**
- Chain configured with 3 initial miners: MinerA, MinerB, MinerC
- All miners in `InitialMinerList` for genesis block
- Chain starts at round 1 [8](#0-7) 

**Attack Sequence:**
1. At genesis, only MinerA comes online and starts mining
2. **Round 1**: MinerA calls `GetConsensusCommand()` → `SolitaryMinerDetection()` returns false (round 1 <= 3) → MinerA mines all blocks
3. **Round 2**: MinerA calls `GetConsensusCommand()` → `SolitaryMinerDetection()` returns false (round 2 <= 3) → MinerA mines all blocks alone
4. **Round 3**: MinerA calls `GetConsensusCommand()` → `SolitaryMinerDetection()` returns false (round 3 <= 3) → MinerA mines all blocks alone
5. MinerB and MinerC have `MissedTimeSlots` incremented for each missed round
6. **Round 4**: If MinerB and MinerC still haven't come online, `SolitaryMinerDetection()` now returns true → MinerA gets `InvalidConsensusCommand` and must stop

**Expected Result**: Solitary miner detection should prevent any miner from monopolizing rounds even during bootstrap when multiple miners are configured

**Actual Result**: MinerA successfully monopolizes rounds 1-3, capturing all early mining rewards and controlling initial state without any protection mechanism

**Success Condition**: MinerA produces all blocks in rounds 1-3 despite multiple miners being configured in the system

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L23-24)
```csharp
        if (SolitaryMinerDetection(currentRound, pubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L66-96)
```csharp
    private bool SolitaryMinerDetection(Round currentRound, string pubkey)
    {
        var isAlone = false;
        // Skip this detection until 4th round.
        if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
        {
            // Not single node.

            var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
            isAlone = minedMinersOfCurrentRound.Count == 0;

            // If only this node mined during previous round, stop mining.
            if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
            {
                var minedMiners = previousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }

            // check one further round.
            if (isAlone && TryToGetRoundInformation(previousRound.RoundNumber.Sub(1),
                    out var previousPreviousRound))
            {
                var minedMiners = previousPreviousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }
        }

        return isAlone;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusCommandProvider.cs (L23-30)
```csharp
        public static ConsensusCommand InvalidConsensusCommand => new()
        {
            ArrangedMiningTime = new Timestamp { Seconds = int.MaxValue },
            Hint = ByteString.CopyFrom(new AElfConsensusHint
            {
                Behaviour = AElfConsensusBehaviour.Nothing
            }.ToByteArray())
        };
```

**File:** docs-sphinx/tutorials/boot-sequence.rst (L12-13)
```text
We need to start at least one or more initial nodes to start the AElf
Blockchain, and 1-5 initial nodes are recommended.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-135)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }

    private List<MinerInRound> GetNotMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound == 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L74-92)
```csharp
    public override Empty FirstRound(Round input)
    {
        /* Basic checks. */
        Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");

        /* Initial settings. */
        State.CurrentTermNumber.Value = 1;
        State.CurrentRoundNumber.Value = 1;
        State.FirstRoundNumberOfEachTerm[1] = 1;
        State.MiningInterval.Value = input.GetMiningInterval();
        SetMinerList(input.GetMinerList(), 1);

        AddRoundInformation(input);

        Context.LogDebug(() =>
            $"Initial Miners: {input.RealTimeMinersInformation.Keys.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");

        return new Empty();
    }
```
