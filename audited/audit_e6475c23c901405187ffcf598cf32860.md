### Title
Method Fee Controller Initialized with Invalid Empty Address Before Parliament Contract Initialization

### Summary
The Parliament contract's `RequiredMethodFeeControllerSet()` method can set `State.MethodFeeController.Value` to an AuthorityInfo with an empty `OwnerAddress` if called before `Initialize()` executes. This breaks the invariant that there's always a valid controller and permanently prevents method fee management since no sender can match an empty address for authorization.

### Finding Description

The vulnerability exists in the `RequiredMethodFeeControllerSet()` private method: [1](#0-0) 

This method directly reads `State.DefaultOrganizationAddress.Value` without checking if the Parliament contract has been initialized. The `State.DefaultOrganizationAddress.Value` is only set during the `Initialize()` method: [2](#0-1) 

If any of the three ACS1 methods (`SetMethodFee`, `ChangeMethodFeeController`, or `GetMethodFeeController`) is called before `Initialize()`: [3](#0-2) [4](#0-3) [5](#0-4) 

The `RequiredMethodFeeControllerSet()` will create an AuthorityInfo with an empty `OwnerAddress` (since `State.DefaultOrganizationAddress.Value` is null/empty), and permanently store this invalid controller.

**Unlike other contracts**, Parliament does not call `GetDefaultOrganizationAddress` (which has initialization checks), but directly accesses the state variable. Other contracts are protected because they call the Parliament contract's `GetDefaultOrganizationAddress` method which includes an initialization assertion: [6](#0-5) 

For comparison, here's how other contracts safely initialize their method fee controller by calling Parliament: [7](#0-6) 

### Impact Explanation

**Operational Impact - Permanent DoS of Method Fee Management:**

Once the controller is set to an invalid AuthorityInfo with empty `OwnerAddress`, the contract enters an unrecoverable state:

1. **SetMethodFee becomes unusable**: The authorization check requires `Context.Sender == State.MethodFeeController.Value.OwnerAddress`, which compares against an empty address. No legitimate transaction sender can match an empty address.

2. **ChangeMethodFeeController becomes unusable**: Similarly requires sender authorization against the empty address, making it impossible to update the controller to fix the issue.

3. **Method fees cannot be managed**: The Parliament contract permanently loses the ability to configure transaction fees for its methods, violating the ACS1 standard's core functionality.

This affects the Parliament contract's ability to participate in the economic system's fee governance, though it doesn't directly lead to fund theft or consensus disruption. The severity is MEDIUM due to the permanent operational disruption of a critical governance function.

### Likelihood Explanation

**Likelihood: LOW to MEDIUM**

**Reachable Entry Point**: The three public ACS1 methods are directly callable by any address.

**Feasible Preconditions**: 
- The Parliament contract must be deployed but not yet initialized
- In production environments, contracts are initialized atomically during genesis deployment via initialization providers: [8](#0-7) 

**Scenarios where this could occur**:
1. **Deployment error**: If the deployment process fails after contract deployment but before initialization completes
2. **Testing/development environments**: Where contracts may be deployed without proper initialization sequences
3. **Contract upgrades or redeployments**: If proper initialization is not enforced

**Execution Practicality**: Simply calling `GetMethodFeeController()` (a view method) before initialization would trigger the bug at no cost.

**Economic Rationality**: Zero cost to trigger (view method call), though the attacker gains no direct benefit.

The likelihood is reduced by robust deployment practices but remains a defense-in-depth concern since the contract doesn't protect itself against this scenario.

### Recommendation

Add an initialization check in `RequiredMethodFeeControllerSet()` before using `State.DefaultOrganizationAddress.Value`:

```csharp
private void RequiredMethodFeeControllerSet()
{
    if (State.MethodFeeController.Value != null) return;
    
    // Add initialization check
    Assert(State.Initialized.Value, "Parliament contract not initialized.");
    Assert(State.DefaultOrganizationAddress.Value != null, "Default organization not set.");

    var defaultAuthority = new AuthorityInfo
    {
        OwnerAddress = State.DefaultOrganizationAddress.Value,
        ContractAddress = Context.Self
    };

    State.MethodFeeController.Value = defaultAuthority;
}
```

Alternatively, call the `GetDefaultOrganizationAddress` method instead of directly accessing the state variable, to reuse the existing initialization check.

**Test cases to add**:
1. Test calling `GetMethodFeeController` before `Initialize` - should fail with clear error
2. Test calling `SetMethodFee` before `Initialize` - should fail with clear error
3. Test calling `ChangeMethodFeeController` before `Initialize` - should fail with clear error

### Proof of Concept

**Initial State**: Parliament contract deployed but `Initialize()` not yet called.

**Attack Steps**:
1. Call `ParliamentContract.GetMethodFeeController(Empty)` or any ACS1 method
2. `RequiredMethodFeeControllerSet()` executes
3. `State.DefaultOrganizationAddress.Value` is null/empty (not initialized)
4. `State.MethodFeeController.Value` is set to AuthorityInfo with empty `OwnerAddress`

**Expected Result**: Method should fail with "Not initialized" error.

**Actual Result**: Method succeeds but sets invalid controller. Subsequent calls to `SetMethodFee` or `ChangeMethodFeeController` fail with "Unauthorized" because no sender can match the empty address.

**Success Condition**: The contract is in a permanently broken state where method fee management is impossible, violating the controller uniqueness invariant that requires a valid controller at all times.

### Citations

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L46-50)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L62-73)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.DefaultOrganizationAddress.Value,
            ContractAddress = Context.Self
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L11-37)
```csharp
    public override Empty Initialize(InitializeInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        var proposerWhiteList = new ProposerWhiteList();

        if (input.PrivilegedProposer != null)
            proposerWhiteList.Proposers.Add(input.PrivilegedProposer);

        State.ProposerWhiteList.Value = proposerWhiteList;
        var organizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = DefaultOrganizationMinimalApprovalThreshold,
                MinimalVoteThreshold = DefaultOrganizationMinimalVoteThresholdThreshold,
                MaximalAbstentionThreshold = DefaultOrganizationMaximalAbstentionThreshold,
                MaximalRejectionThreshold = DefaultOrganizationMaximalRejectionThreshold
            },
            ProposerAuthorityRequired = input.ProposerAuthorityRequired,
            ParliamentMemberProposingAllowed = true
        };
        var defaultOrganizationAddress = CreateNewOrganization(organizationInput);
        State.DefaultOrganizationAddress.Value = defaultOrganizationAddress;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L250-254)
```csharp
    public override Address GetDefaultOrganizationAddress(Empty input)
    {
        Assert(State.Initialized.Value, "Not initialized.");
        return State.DefaultOrganizationAddress.Value;
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L50-63)
```csharp
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTestBase.cs (L64-77)
```csharp
        //deploy Parliament contract
        ParliamentContractAddress = AsyncHelper.RunSync(() =>
            DeploySystemSmartContract(
                KernelConstants.CodeCoverageRunnerCategory,
                ParliamentCode,
                ParliamentSmartContractAddressNameProvider.Name,
                DefaultSenderKeyPair
            ));
        ParliamentContractStub = GetParliamentContractTester(DefaultSenderKeyPair);
        AsyncHelper.RunSync(() => ParliamentContractStub.Initialize.SendAsync(new InitializeInput
        {
            ProposerAuthorityRequired = false,
            PrivilegedProposer = DefaultSender
        }));
```
