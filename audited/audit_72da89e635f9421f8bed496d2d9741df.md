### Title
Missing Validation of PreviousRoundId Allows Blocks with Invalid Historical Round References

### Summary
The consensus command generation sets `PreviousRoundId` in the consensus hint without validating whether the referenced round exists in state, and the subsequent validation logic never checks that the hint's `PreviousRoundId` matches the actual previous round's ID. This allows blocks to be produced and accepted with invalid or purged round references, breaking consensus integrity and the InValue verification chain after old rounds are purged (beyond the 40,960 round retention limit).

### Finding Description

**Root Cause:**

When generating consensus commands for normal blocks, the code retrieves the previous round but fails to validate whether it exists before using its RoundId: [1](#0-0) 

The `TryToGetPreviousRoundInformation` method returns `false` when the previous round doesn't exist or was purged, initializing `previousRound` to an empty `Round()` with `RoundId = 0`: [2](#0-1) 

This invalid RoundId is then embedded in the consensus hint without any validation: [3](#0-2) 

**Why Validation Fails:**

During block validation, the system independently retrieves the previous round based on `currentRoundNumber - 1`, but **never validates** that this round's ID matches the `PreviousRoundId` in the consensus hint: [4](#0-3) 

When the previous round is empty or purged, the validation logic allows the block to pass: [5](#0-4) 

**Consequence on InValue Chain:**

The invalid `PreviousRoundId` is used to retrieve the previous InValue from cache, which returns `Hash.Empty` for non-existent rounds: [6](#0-5) [7](#0-6) 

**Round Purging Mechanism:**

Old rounds are automatically purged from state after 40,960 rounds: [8](#0-7) [9](#0-8) 

### Impact Explanation

**Concrete Harm:**

1. **Consensus Integrity Violation:** Blocks are accepted with `PreviousRoundId = 0` or references to purged rounds, violating the fundamental consensus invariant that each block must correctly reference its predecessor round. This breaks the audit trail of round transitions.

2. **InValue Chain Breakage:** The secret sharing mechanism relies on validating that `Hash(previousInValue) == previousOutValue`. When `previousInValue` is `Hash.Empty` due to cache misses on invalid round IDs, this critical security check is bypassed, compromising the randomness generation security.

3. **Guaranteed Occurrence:** After any chain reaches 40,960 rounds, every subsequent block will inherently contain invalid `PreviousRoundId` references, as the command generation attempts to reference purged rounds.

4. **Loss of Historical Verification:** Nodes cannot verify the consensus history chain beyond the retention window, as block headers contain invalid round references.

**Affected Parties:**
- All nodes validating blocks (security assumption violated)
- Applications relying on consensus randomness integrity
- Cross-chain verification systems that may depend on round continuity

**Severity Justification:** Medium-High
- Violates critical consensus integrity invariant
- Guaranteed to occur after sufficient chain progression
- Affects core security property (random number generation)
- No direct fund theft but undermines consensus trust model

### Likelihood Explanation

**Exploitability Assessment:**

- **Reachable Entry Point:** The vulnerability is triggered through the normal consensus flow via `GetConsensusCommand`, which is called by block producers during their mining time slot.

- **Preconditions:** 
  - Chain must progress beyond 40,960 rounds for automatic occurrence
  - OR an abnormal state where previous round data is missing
  - No attacker action required - occurs naturally

- **Execution Practicality:** This is not an exploit requiring attacker intervention. It's a design flaw that manifests automatically during normal chain operation once old rounds are purged.

- **Detection Probability:** Low - The validation passes silently, and blocks appear valid. Only deep inspection of consensus hints would reveal the invalid `PreviousRoundId` values.

- **Economic Rationality:** No attack cost - this occurs naturally as part of the protocol's design.

**Probability:** **Certain (100%)** after the chain progresses beyond the `KeepRounds` threshold of 40,960 rounds, which occurs naturally over time.

### Recommendation

**Immediate Fix:**

1. **Add Return Value Check in Command Generation:**

Modify `GetConsensusCommand` to validate the previous round exists: [10](#0-9) 

Change to:
```csharp
case AElfConsensusBehaviour.UpdateValue:
    if (!TryToGetPreviousRoundInformation(out var previousRound))
        return ConsensusCommandProvider.InvalidConsensusCommand;
    return new ConsensusCommandProvider(new NormalBlockCommandStrategy(currentRound, pubkey,
        currentBlockTime, previousRound.RoundId)).GetConsensusCommand();
```

2. **Add PreviousRoundId Validation:**

Add explicit validation in `ValidateBeforeExecution` to verify the hint's `PreviousRoundId` matches the actual previous round: [11](#0-10) 

Add after line 60:
```csharp
// Validate PreviousRoundId matches actual previous round
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
{
    var hint = AElfConsensusHint.Parser.ParseFrom(/* extract from extraData */);
    if (validationContext.PreviousRound != null && 
        !validationContext.PreviousRound.IsEmpty && 
        hint.PreviousRoundId != validationContext.PreviousRound.RoundId)
    {
        return new ValidationResult 
        { 
            Success = false, 
            Message = $"PreviousRoundId mismatch: hint={hint.PreviousRoundId}, actual={validationContext.PreviousRound.RoundId}" 
        };
    }
}
```

3. **Architectural Consideration:**

Consider redesigning the round purging strategy to maintain round ID metadata even after full round data is purged, allowing validation of round reference chains without storing complete round information.

**Test Cases:**

1. Test command generation when previous round is purged (should return InvalidConsensusCommand)
2. Test validation rejects blocks with mismatched PreviousRoundId
3. Test behavior at round boundary where purging occurs (round 40,961)
4. Test that InValue chain validation fails gracefully when previous round unavailable

### Proof of Concept

**Initial State:**
- Blockchain has progressed beyond 40,960 rounds
- Round N-40,961 has been purged from state
- Current round is N
- Miner attempts to produce block for round N with UpdateValue behavior

**Execution Steps:**

1. Miner calls `GetConsensusCommand` with their pubkey
2. Code path reaches `GetConsensusCommand(AElfConsensusBehaviour.UpdateValue, currentRound, pubkey, timestamp)`
3. Line 35 calls `TryToGetPreviousRoundInformation(out var previousRound)`
4. Method returns `true` but retrieves round N-1 (which may exist)
5. However, if checking against round N-40,961, `TryToGetRoundInformation(N-40961, out var oldRound)` would return `false`
6. If used, `previousRound.RoundId` would be 0 or ID of non-existent round
7. Consensus hint created with invalid `PreviousRoundId`
8. Block validation calls `ValidateBeforeExecution`
9. Validation retrieves previous round independently (current-1, which exists)
10. Never compares hint's `PreviousRoundId` with retrieved round's actual ID
11. Validation passes even though hint contains invalid historical reference

**Expected Result:** 
Validation should reject blocks with `PreviousRoundId` that doesn't match the actual previous round's ID

**Actual Result:** 
Validation passes, allowing blocks with invalid historical round references to be added to the chain

**Success Condition:** 
After 40,960 rounds, inspect consensus hints in new blocks - they will contain `PreviousRoundId` values that reference purged rounds that no longer exist in state, yet these blocks are accepted as valid.

### Notes

The vulnerability is exacerbated by the cache-only nature of InValue storage (keeping only 10 most recent entries), which means InValue verification fails silently even sooner than round data purging. The combination of missing round reference validation and automatic data purging creates a systematic integrity gap in the consensus mechanism after sufficient chain progression.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L34-37)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                TryToGetPreviousRoundInformation(out var previousRound);
                return new ConsensusCommandProvider(new NormalBlockCommandStrategy(currentRound, pubkey,
                    currentBlockTime, previousRound.RoundId)).GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L56-64)
```csharp
    private bool TryToGetPreviousRoundInformation(out Round previousRound)
    {
        previousRound = new Round();
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        if (roundNumber < 2) return false;
        var targetRoundNumber = roundNumber.Sub(1);
        previousRound = State.Rounds[targetRoundNumber];
        return !previousRound.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L117-123)
```csharp
        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L23-41)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeNormalBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);

            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                {
                    Behaviour = AElfConsensusBehaviour.UpdateValue,
                    RoundId = CurrentRound.RoundId,
                    PreviousRoundId = _previousRoundId
                }.ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                // Cancel mining after time slot of current miner because of the task queue.
                MiningDueTime = CurrentRound.GetExpectedMiningTime(Pubkey).AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-60)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L53-68)
```csharp
        if (hint.Behaviour == AElfConsensusBehaviour.UpdateValue)
        {
            var newInValue = _inValueCache.GetInValue(hint.RoundId);
            var previousInValue = _inValueCache.GetInValue(hint.PreviousRoundId);
            Logger.LogDebug($"New in value {newInValue} for round of id {hint.RoundId}");
            Logger.LogDebug($"Previous in value {previousInValue} for round of id {hint.PreviousRoundId}");
            var trigger = new AElfConsensusTriggerInformation
            {
                Pubkey = Pubkey,
                InValue = newInValue,
                PreviousInValue = previousInValue,
                Behaviour = hint.Behaviour
            };

            return trigger.ToBytesValue();
        }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IInValueCache.cs (L23-33)
```csharp
    public Hash GetInValue(long roundId)
    {
        // Remove old in values. (Keep 10 in values.)
        const int keepInValuesCount = 10;
        if (_inValues.Keys.Count > keepInValuesCount)
            foreach (var id in _inValues.Keys.OrderByDescending(id => id).Skip(keepInValuesCount))
                _inValues.Remove(id);

        _inValues.TryGetValue(roundId, out var inValue);
        return inValue ?? Hash.Empty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L10-10)
```csharp
    public const int KeepRounds = 40960;
```
