### Title
Missing Validation Allows Zero or Negative MinimumLockMinutes Breaking Token Lock Invariant

### Summary
The `CreateScheme()` function in TokenHolderContract fails to validate that `MinimumLockMinutes` is positive, allowing scheme creators to set it to 0 or negative values. This completely bypasses the locking mechanism's core invariant, enabling users to withdraw tokens immediately after locking them, defeating the purpose of the TokenHolder profit-sharing system that requires users to commit tokens for a minimum time period.

### Finding Description

The vulnerability exists in the `CreateScheme()` function where `MinimumLockMinutes` is directly assigned from user input without validation: [1](#0-0) 

The `minimum_lock_minutes` field is defined as `int64` (signed integer), allowing negative values: [2](#0-1) 

The withdrawal validation in the `Withdraw()` function only checks if the lock timestamp plus the minimum lock duration is less than the current time: [3](#0-2) 

**Root Cause Analysis:**

1. No validation enforces that `MinimumLockMinutes > 0` during scheme creation
2. When `MinimumLockMinutes = 0`, the check becomes: `lockTimestamp.AddMinutes(0) < currentTime`, which evaluates to `lockTimestamp < currentTime` - this passes as soon as the blockchain advances to the next block
3. When `MinimumLockMinutes < 0`, the check becomes even weaker as it subtracts time from the lock timestamp

**Why Existing Protections Fail:**

Unlike the Election contract which validates lock duration with bounds checks: [4](#0-3) 

The TokenHolder contract has no corresponding validation in `CreateScheme()`.

### Impact Explanation

**Direct Operational Impact:**
- **Breaks Core Invariant**: The TokenHolder contract's fundamental purpose is to incentivize long-term token holding by requiring users to lock tokens for a minimum period before being eligible for profit distribution. Setting `MinimumLockMinutes = 0` completely negates this mechanism.

- **Gaming the System**: Users can:
  1. Register for profits by locking tokens
  2. Receive shares in the profit distribution scheme
  3. Immediately withdraw their locked tokens (same block or next block)
  4. Claim accumulated profits without honoring the intended lock commitment

- **Undermines Economic Model**: The profit-sharing model assumes participants lock tokens for meaningful periods, creating commitment and reducing circulating supply. Zero or negative lock times allow users to gain benefits without providing this commitment.

**Affected Parties:**
- Legitimate long-term token holders who honor lock commitments are diluted by opportunistic users
- Scheme managers who expect participants to maintain locked positions
- The broader ecosystem's token economics and governance mechanisms

**Severity Justification**: HIGH - This directly violates the contract's documented purpose ("minimum lock time before withdrawing") and allows systematic gaming of the profit distribution mechanism. [5](#0-4) 

### Likelihood Explanation

**Reachable Entry Point**: 
The `CreateScheme()` function is publicly accessible with no authorization checks: [6](#0-5) 

**Feasible Preconditions**: 
- Any user can create a scheme by calling `CreateScheme()`
- No special permissions or pre-existing state required
- Attacker becomes the scheme manager automatically

**Execution Practicality**: 
The existing test suite demonstrates this vulnerability - the `Withdraw_Test()` creates a scheme without specifying `MinimumLockMinutes` (defaults to 0), locks tokens, and immediately withdraws successfully: [7](#0-6) 

**Economic Rationality**: 
- Zero transaction cost beyond normal gas fees
- No risk to attacker - they control their own scheme
- Immediate benefit by gaming profit distributions

**Likelihood Assessment**: HIGH - The vulnerability is trivially exploitable, requires no special conditions, and is already demonstrated in the test suite (though unintentionally).

### Recommendation

**1. Add Input Validation in CreateScheme():**

Add an assertion after line 14 in `TokenHolderContract.cs`:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    Assert(input.MinimumLockMinutes > 0, "MinimumLockMinutes must be positive.");
    
    // ... rest of existing code
}
```

**2. Consider Additional Bounds:**

Optionally add maximum limits similar to the Election contract pattern to prevent unreasonably long lock periods:

```csharp
Assert(input.MinimumLockMinutes >= MIN_LOCK_MINUTES && 
       input.MinimumLockMinutes <= MAX_LOCK_MINUTES, 
       "MinimumLockMinutes out of valid range.");
```

**3. Regression Test:**

Add a test case that explicitly verifies rejection of invalid MinimumLockMinutes:

```csharp
[Fact]
public async Task CreateScheme_With_Invalid_MinimumLockMinutes_Should_Fail()
{
    // Test zero value
    var result = await TokenHolderContractStub.CreateScheme.SendWithExceptionAsync(
        new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "ELF",
            MinimumLockMinutes = 0
        });
    result.TransactionResult.Error.ShouldContain("MinimumLockMinutes must be positive");
    
    // Test negative value
    result = await TokenHolderContractStub.CreateScheme.SendWithExceptionAsync(
        new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "ELF",
            MinimumLockMinutes = -100
        });
    result.TransactionResult.Error.ShouldContain("MinimumLockMinutes must be positive");
}
```

### Proof of Concept

**Initial State:**
- TokenHolder contract deployed
- User has sufficient token balance (e.g., 1000 ELF)

**Attack Sequence:**

1. **Attacker creates scheme with zero lock time:**
   ```
   CreateScheme({
     Symbol: "ELF",
     MinimumLockMinutes: 0
   })
   ```
   - Scheme created with attacker as manager
   - No error thrown despite violating intended lock mechanism

2. **Attacker registers and locks tokens:**
   ```
   RegisterForProfits({
     SchemeManager: <attacker_address>,
     Amount: 1000
   })
   ```
   - Tokens locked at block time T
   - Attacker added as beneficiary with 1000 shares
   - LockTimestamp[lockId] = T

3. **Attacker immediately withdraws (next block):**
   ```
   Withdraw(<attacker_address>)
   ```
   - Current block time = T + δ (where δ is minimal time advance)
   - Check: `T.AddMinutes(0) < T + δ` → `T < T + δ` → **TRUE**
   - Tokens unlocked and returned to attacker
   - Attacker removed as beneficiary

**Expected vs Actual Result:**
- **Expected**: Withdraw should fail with "Cannot withdraw" error due to insufficient lock time
- **Actual**: Withdraw succeeds immediately, bypassing the lock mechanism entirely

**Success Condition:** 
Attacker successfully withdraws locked tokens without honoring any meaningful lock period, demonstrating complete bypass of the token locking invariant that is fundamental to the TokenHolder contract's design.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** protobuf/token_holder_contract.proto (L63-70)
```text
message CreateTokenHolderProfitSchemeInput {
    // The token symbol.
    string symbol = 1;
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 2;
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 3;
}
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L320-326)
```csharp
    private void AssertValidLockSeconds(long lockSeconds)
    {
        Assert(lockSeconds >= State.MinimumLockTime.Value,
            $"Invalid lock time. At least {State.MinimumLockTime.Value.Div(60).Div(60).Div(24)} days");
        Assert(lockSeconds <= State.MaximumLockTime.Value,
            $"Invalid lock time. At most {State.MaximumLockTime.Value.Div(60).Div(60).Div(24)} days");
    }
```

**File:** docs/resources/smart-contract-apis/token-holder.md (L15-18)
```markdown
**CreateTokenHolderProfitSchemeInput**:
- **symbol**: the token that will be used for locking and distributing profits.
- **minimum** lock time: minimum lock time before withdrawing.
- **automatic distribution threshold**: used when registering for profits (RegisterForProfits).
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L433-459)
```csharp
    [Fact]
    public async Task Withdraw_Test()
    {
        var amount = 1000L;
        var nativeTokenSymbol = TokenHolderContractTestConstants.NativeTokenSymbol;
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = nativeTokenSymbol
        });
        await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
        {
            Amount = amount,
            SchemeManager = Starter
        });
        var beforeUnLockBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = nativeTokenSymbol,
            Owner = Starter
        })).Balance;
        await TokenHolderContractStub.Withdraw.SendAsync(Starter);
        var afterUnLockBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = nativeTokenSymbol,
            Owner = Starter
        })).Balance;
        afterUnLockBalance.ShouldBe(beforeUnLockBalance.Add(amount));
    }
```
