# Audit Report

## Title
Regex Anchor Bypass Allows Invalid Token Symbols with Trailing Newlines

## Summary
The token symbol validation functions use the C# regex `$` anchor which matches before a trailing newline character, allowing attackers to create multiple tokens with visually identical symbols (e.g., `"ABC"` and `"ABC\n"`). This bypasses the symbol uniqueness invariant and enables symbol collision attacks where malicious tokens can impersonate legitimate ones.

## Finding Description

The vulnerability exists in three regex validation functions that all use the `$` anchor without proper end-of-string anchoring: [1](#0-0) [2](#0-1) [3](#0-2) 

In C#, without `RegexOptions.Multiline`, the `$` anchor matches at the end of the string **OR** before a trailing `\n` character. This means `Regex.IsMatch("ABC\n", "^[a-zA-Z0-9]+$")` returns TRUE when it should return FALSE.

The vulnerability is triggered through the public `Create` method: [4](#0-3) 

When a user calls `Create` with `input.Symbol = "ABC\n"`, the validation flow proceeds as:

1. **GetSymbolType validation**: [5](#0-4) 

The symbol is split by `-`, then `IsValidCreateSymbol("ABC\n")` is called which incorrectly passes due to the `$` anchor matching before the trailing newline.

2. **Token creation and registration**: [6](#0-5) 

3. **RegisterTokenInfo validation**: [7](#0-6) 

This also uses `IsValidSymbol` which has the same flaw, and then stores the token with the newline-containing symbol.

4. **Insufficient duplicate check**: [8](#0-7) 

The case-insensitive check uses `symbol.ToUpper()` which preserves the newline: `"ABC\n".ToUpper()` returns `"ABC\n"` (not `"ABC"`). Therefore, `"ABC"` and `"ABC\n"` are treated as distinct tokens despite being visually identical.

## Impact Explanation

**Protocol Invariant Violation**: The fundamental invariant that each token has a unique, visually distinguishable symbol is broken. Multiple tokens can exist with identical visual representations.

**Symbol Collision Attack**: Attackers can create tokens with symbols like `"USDT\n"`, `"USDT\r"`, `"USDT\n\r"` that all appear identical to the legitimate `"USDT"` token in user interfaces and blockchain explorers.

**User Confusion and Scams**: Users cannot distinguish between legitimate tokens and malicious duplicates. An attacker can exploit this by:
1. Waiting for a legitimate project to create a valuable token (e.g., "USDT")
2. Creating a duplicate with a trailing newline (e.g., "USDT\n")
3. Distributing the malicious token and convincing users it's the legitimate one
4. Scamming users who mistake the fake token for the real one

**State Pollution**: The contract state becomes polluted with invalid symbols containing non-printable control characters, potentially breaking external integrations and indexers that expect clean alphanumeric symbols.

The severity is **Medium** because while direct fund theft does not occur, the vulnerability enables significant social engineering attacks and violates a core protocol invariant that tokens must have unique, distinguishable identifiers.

## Likelihood Explanation

**Publicly Reachable**: The `Create` method is a public entry point accessible to any user who meets the standard token creation requirements (seed NFT ownership or whitelist membership).

**Feasible Preconditions**: The attacker needs to obtain a seed NFT or be added to the create whitelist. While this represents a moderate barrier, seed NFTs can be purchased or obtained through legitimate means, making the attack feasible for any motivated attacker.

**Simple Execution**: The exploit requires only passing a symbol string with a trailing newline character to the `Create` method. No complex state manipulation, timing requirements, or privilege escalation is needed.

**Difficult Detection**: Trailing newlines are invisible in most debugging outputs, logs, and UI displays. The vulnerability is subtle and unlikely to be caught through normal testing or monitoring.

**Deterministic and Reliable**: The exploit is reproducible and deterministic - it will succeed every time as the regex behavior is consistent.

The likelihood is **Medium** - the attack is practical, low-cost, and highly likely to succeed once the attacker obtains the necessary seed NFT.

## Recommendation

Replace the `$` anchor with `\z` in all three validation functions to ensure matching only at the absolute end of the string:

```csharp
private static bool IsValidSymbol(string symbol)
{
    return Regex.IsMatch(symbol, @"^[a-zA-Z0-9]+(-[0-9]+)?\z");
}

private bool IsValidItemId(string symbolItemId)
{
    return Regex.IsMatch(symbolItemId, @"^[0-9]+\z");
}

private bool IsValidCreateSymbol(string symbol)
{
    return Regex.IsMatch(symbol, @"^[a-zA-Z0-9]+\z");
}
```

The `\z` anchor matches only at the absolute end of the string and does not have the special behavior of matching before trailing newlines.

Additionally, consider adding explicit sanitization to trim whitespace and reject control characters from symbol inputs as a defense-in-depth measure.

## Proof of Concept

```csharp
[Fact]
public async Task Create_Token_With_Trailing_Newline_Should_Bypass_Validation()
{
    // Setup: Create a legitimate token "ABC"
    await CreateTokenAsync("ABC", "Legitimate Token", 1000000);
    
    // Attack: Create a token with trailing newline "ABC\n"
    var createInput = new CreateInput
    {
        Symbol = "ABC\n",  // Symbol with trailing newline
        TokenName = "Malicious Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultSender,
        IsBurnable = true,
        IssueChainId = ChainHelper.ConvertBase58ToChainId("AELF")
    };
    
    // The create should succeed due to regex $ anchor matching before \n
    var result = await TokenContractStub.Create.SendAsync(createInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify both tokens exist in state
    var token1 = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "ABC" });
    var token2 = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "ABC\n" });
    
    token1.Symbol.ShouldBe("ABC");
    token2.Symbol.ShouldBe("ABC\n");
    
    // Both tokens appear visually identical to users but are stored as separate tokens
    // This violates the symbol uniqueness invariant
}
```

This test demonstrates that both `"ABC"` and `"ABC\n"` can be created as distinct tokens despite being visually identical, confirming the vulnerability.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L18-21)
```csharp
    private static bool IsValidSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+(-[0-9]+)?$");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L23-26)
```csharp
    private bool IsValidItemId(string symbolItemId)
    {
        return Regex.IsMatch(symbolItemId, "^[0-9]+$");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L28-31)
```csharp
    private bool IsValidCreateSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+$");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L48-88)
```csharp
    private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
    {
        AssertValidCreateInput(input, symbolType);
        if (symbolType == SymbolType.Token || symbolType == SymbolType.NftCollection)
        {
            // can not call create on side chain
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
        }

        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };

        if (IsAliasSettingExists(tokenInfo))
        {
            Assert(symbolType == SymbolType.NftCollection, "Token alias can only be set for NFT Item.");
            SetTokenAlias(tokenInfo);
        }

        CheckTokenExists(tokenInfo.Symbol);
        RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```
