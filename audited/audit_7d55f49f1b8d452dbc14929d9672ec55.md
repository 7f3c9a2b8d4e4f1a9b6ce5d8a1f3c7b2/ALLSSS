### Title
Consensus OutValue Reuse Allows Miner Ordering Manipulation via Historical InValue Selection

### Summary
The `UpdateValueValidationProvider` validates that `OutValue` and `Signature` are properly filled but does not verify that the `OutValue` has not been used in previous rounds. This allows a malicious miner to strategically reuse historical `InValue` entries to optimize their position in the next round's mining order, giving them an unfair advantage over honest miners who generate fresh random values.

### Finding Description

The validation occurs in `NewConsensusInformationFilled()` which only checks presence of `OutValue` and `Signature`: [1](#0-0) 

The validation in `ValidatePreviousInValue()` only verifies that the `PreviousInValue` hashes to the previous round's `OutValue`, but does NOT check whether the current `OutValue` has been used before: [2](#0-1) 

Since `OutValue = hash(InValue)` is deterministic: [3](#0-2) 

A miner can reuse any historical `InValue` they previously used, which will produce the same `OutValue`. The next round's mining order is determined by the signature calculation: [4](#0-3) 

And converted to an order position: [5](#0-4) 

When processing the update, the `OutValue` is directly stored without uniqueness validation: [6](#0-5) 

All historical rounds are stored and accessible: [7](#0-6) 

However, there is no validation logic that checks the current `OutValue` against historical values stored in `State.Rounds`.

### Impact Explanation

**Consensus Integrity Compromise:**
A malicious miner with N historical blocks can try N different `InValue` options offline to calculate which one yields the most favorable mining position in the next round, while honest miners only get one random attempt. This violates the core randomness assumption of the AEDPoS consensus mechanism.

**Concrete Attack Advantage:**
- Honest miner: 1/M probability of getting position 1 (where M = miner count)
- Attacker with N historical blocks: Can test N values offline, significantly higher probability
- Example: With 100 historical blocks and 21 miners, attacker has ~79% chance vs honest miner's ~4.8%

**Cumulative Effect:**
The advantage compounds over time as miners accumulate more historical `InValue` entries to choose from. Long-term miners gain increasing power to manipulate their ordering.

**Transaction Ordering Exploitation:**
Better mining positions enable MEV-like exploitation through strategic transaction ordering, potentially extracting value from other users' transactions.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an active miner in the consensus set (reasonable precondition for consensus attacks)
- Needs to store historical `InValue` entries (trivial storage requirement)
- Requires offline computation to test historical values (computationally cheap)

**Attack Complexity:**
- **Low**: Simple algorithm - for each historical `InValue_i`, compute `signature_i = XOR(InValue_i, current_round_signatures)`, then `order_i = (signature_i % miner_count) + 1`, select minimum
- No special transactions or complex state manipulation required
- Attack is undetectable without implementing cross-round `OutValue` tracking

**Feasibility Conditions:**
- Entry point is the public `UpdateValue` method through normal block production
- No special permissions needed beyond being a miner
- Works within standard AElf execution model

**Economic Rationality:**
- Cost: Negligible (just offline computation and storage)
- Benefit: Better block production positions, potential MEV extraction
- Risk: Low detection probability without historical tracking

### Recommendation

**Code-Level Mitigation:**

Add historical `OutValue` uniqueness validation in `UpdateValueValidationProvider.cs`:

```csharp
private bool ValidateOutValueUniqueness(ConsensusValidationContext validationContext)
{
    var currentOutValue = validationContext.ProvidedRound
        .RealTimeMinersInformation[validationContext.SenderPubkey].OutValue;
    
    // Check last N rounds (e.g., 100 rounds for practical history depth)
    var startRound = Math.Max(1, validationContext.CurrentRoundNumber - 100);
    for (var i = startRound; i < validationContext.CurrentRoundNumber; i++)
    {
        var historicalRound = validationContext.GetRound(i); // Add method to retrieve historical rounds
        if (historicalRound?.RealTimeMinersInformation.ContainsKey(validationContext.SenderPubkey) == true)
        {
            var historicalOutValue = historicalRound.RealTimeMinersInformation[validationContext.SenderPubkey].OutValue;
            if (historicalOutValue != null && historicalOutValue.Equals(currentOutValue))
            {
                return false;
            }
        }
    }
    return true;
}
```

Add this check to `ValidateHeaderInformation()`:

```csharp
if (!ValidateOutValueUniqueness(validationContext))
    return new ValidationResult { Message = "OutValue reused from previous rounds." };
```

**Alternative Approach:**
Maintain a sliding window mapping of recent `OutValue` hashes per miner in state to enable O(1) lookups.

**Test Cases:**
1. Verify miner cannot reuse `OutValue` from previous round
2. Verify miner cannot reuse `OutValue` from 10 rounds ago
3. Verify different miners can use same `OutValue` (different pubkeys)
4. Verify validation passes with fresh `OutValue`

### Proof of Concept

**Initial State:**
- Miner "MinerA" is in the active consensus set
- MinerA has produced blocks in rounds 1-100
- Historical InValue/OutValue pairs stored: (InValue_1, OutValue_1), ..., (InValue_100, OutValue_100)
- Current round is 101

**Attack Steps:**

1. **Round 101 - Normal behavior:**
   - MinerA uses InValue_101, produces OutValue_101 = hash(InValue_101)
   - Gets mining order for round 102: order_101 = (sig_101 % miner_count) + 1
   - Assume order_101 = 15 (suboptimal position)

2. **Round 102 - Offline computation:**
   - Before producing block, MinerA computes offline for each historical i ∈ {1..100}:
     - sig_i = XOR(InValue_i, XOR(all_current_signatures_round_101))
     - order_i = (sig_i % 21) + 1
   - Finds InValue_47 gives order_47 = 1 (best position)

3. **Round 102 - Exploit:**
   - MinerA submits UpdateValue with InValue = InValue_47 (reused)
   - Produces OutValue_102 = hash(InValue_47) = OutValue_47 (reused!)
   - PreviousInValue = InValue_101
   - Validation passes: hash(InValue_101) == OutValue_101 ✓
   - No check for OutValue_102 == OutValue_47 ✗

4. **Round 103 - Benefit:**
   - MinerA gets order 1 in round 103 (first mining slot)
   - Can front-run all other transactions
   - Extracts MEV or gains block reward advantage

**Expected Result:** Validation should reject reused `OutValue`  
**Actual Result:** Validation passes, miner gains unfair ordering advantage

**Success Condition:** Block with reused `OutValue` is accepted into consensus, miner receives favorable position in subsequent round

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L67-67)
```csharp
        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L245-245)
```csharp
        minerInRound.OutValue = updateValueInput.OutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L26-26)
```csharp
    public MappedState<long, Round> Rounds { get; set; }
```
