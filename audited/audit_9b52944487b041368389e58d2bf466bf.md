### Title
Missing Validation of Other Miners' PreviousInValue Allows Mining Order Manipulation

### Summary
The `UpdateValueValidationProvider` only validates the sender's `PreviousInValue` against their previous round `OutValue`, but does not validate other miners' `PreviousInValue` values provided via `miners_previous_in_values` field. This allows a malicious miner to corrupt other miners' `PreviousInValue` in state, which is later used to calculate signatures and mining order for miners who miss their time slots, breaking consensus determinism.

### Finding Description

The vulnerability exists in the validation and processing flow for consensus updates: [1](#0-0) 

The `ValidatePreviousInValue` method only validates the **sender's** `PreviousInValue` (extracted at line 38 as `validationContext.SenderPubkey`), checking that `Hash(previousInValue) == previousOutValue` for the sender only. It does not validate other miners' `PreviousInValue` values.

However, when a miner submits an `UpdateValueInput`, they can provide `PreviousInValue` for **all miners** via the `miners_previous_in_values` map field: [2](#0-1) 

These unvalidated values are then unconditionally written to state: [3](#0-2) 

When miners miss their time slots and `SupplyCurrentRoundInformation` is called during round transitions, the corrupted `PreviousInValue` from state is used to calculate their signature: [4](#0-3) 

This signature directly determines the mining order for the next round: [5](#0-4) 

### Impact Explanation

This vulnerability allows a malicious miner to:

1. **Manipulate Mining Order**: By providing fake `PreviousInValue` for other miners who miss their time slots, the attacker can control their signature calculation, which determines their `SupposedOrderOfNextRound` via modulo operation on the signature.

2. **Break Consensus Determinism**: The mining order should be deterministically derived from each miner's actual `InValue`. This attack breaks that invariant by allowing arbitrary manipulation of the `PreviousInValue` used in calculations.

3. **Unfair Block Reward Distribution**: By manipulating mining order, an attacker could potentially increase their chance of producing more blocks or becoming the extra block producer, gaining unfair rewards.

The impact is limited to miners who actually miss their time slots, as miners who produce blocks provide and validate their own `PreviousInValue`. However, in a network with variable conditions, missed slots are a realistic occurrence, making this exploitable in practice.

### Likelihood Explanation

**Attacker Capabilities**: The attacker must be an authorized miner in the consensus set.

**Attack Complexity**: LOW to MODERATE
- The attacker waits for another miner to miss their time slot in a round
- When producing their own block, they submit `UpdateValueInput` with manipulated `miners_previous_in_values` for the victim
- No special privileges beyond being a miner are required

**Feasibility Conditions**:
- Secret sharing must be enabled (checked via `IsSecretSharingEnabled()`)
- At least one other miner must miss their time slot in the current round
- The attacker must produce a block after the victim misses their slot

**Detection Constraints**: The manipulation is not immediately detectable as the validation only checks the sender's `PreviousInValue`. The victim miner would need to detect that their state was corrupted by comparing their expected `PreviousInValue` with what's stored on-chain.

**Probability**: MODERATE - Missed time slots occur naturally due to network issues, node downtime, or high load, providing regular opportunities for exploitation.

### Recommendation

Add validation in `UpdateValueValidationProvider.ValidatePreviousInValue` to check **all miners'** `PreviousInValue` values in the provided round, not just the sender's:

```csharp
private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;
    
    // Validate sender's PreviousInValue (existing check)
    if (validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey))
    {
        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue != null)
        {
            var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
            var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
            if (previousInValue != Hash.Empty && 
                HashHelper.ComputeFrom(previousInValue) != previousOutValue)
                return false;
        }
    }
    
    // NEW: Validate all other miners' PreviousInValue
    foreach (var minerInfo in extraData.Round.RealTimeMinersInformation)
    {
        if (minerInfo.Key == publicKey) continue; // Already checked above
        
        var providedPreviousInValue = minerInfo.Value.PreviousInValue;
        if (providedPreviousInValue == null || providedPreviousInValue == Hash.Empty)
            continue;
            
        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(minerInfo.Key))
            continue;
            
        var expectedOutValue = validationContext.PreviousRound.RealTimeMinersInformation[minerInfo.Key].OutValue;
        if (HashHelper.ComputeFrom(providedPreviousInValue) != expectedOutValue)
            return false;
    }
    
    return true;
}
```

Add test cases that verify:
1. Validation rejects `UpdateValueInput` with incorrect `PreviousInValue` for any miner
2. Miners cannot manipulate other miners' mining order through `miners_previous_in_values`

### Proof of Concept

**Initial State**:
- Round N-1: Victim Miner V produced block with `OutValue_V = Hash(InValue_V)`
- Round N: V is scheduled to mine but misses their time slot
- Attacker Miner A is also in Round N miner set

**Attack Steps**:

1. Attacker produces block in Round N and submits `UpdateValueInput`:
   - `out_value`: Attacker's correct `OutValue_A`
   - `previous_in_value`: Attacker's correct `PreviousInValue_A` 
   - `miners_previous_in_values`: `{V: FakeInValue}` where `Hash(FakeInValue) ≠ OutValue_V`

2. Validation passes because:
   - `UpdateValueValidationProvider` only checks: `Hash(PreviousInValue_A) == OutValue_A_from_N-1` ✓
   - Does NOT check: `Hash(FakeInValue) == OutValue_V` ✗

3. `PerformSecretSharing` executes and corrupts state:
   - Sets `round.RealTimeMinersInformation[V].PreviousInValue = FakeInValue`

4. When `NextRound` is triggered:
   - `SupplyCurrentRoundInformation` detects V didn't mine
   - Reads `PreviousInValue = FakeInValue` from state
   - Calculates `signature_V = CalculateSignature(FakeInValue)` (WRONG)
   - Derives `SupposedOrderOfNextRound_V = (signature_V % miners_count) + 1`

**Expected Result**: V's mining order should be calculated from their real `InValue_V`

**Actual Result**: V's mining order is calculated from attacker-controlled `FakeInValue`, breaking consensus determinism and allowing the attacker to manipulate victim's mining position in Round N+1.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** protobuf/aedpos_contract.proto (L215-216)
```text
    // The InValue in the previous round, miner public key -> InValue.
    map<string, aelf.Hash> miners_previous_in_values = 11;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L186-199)
```csharp
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
