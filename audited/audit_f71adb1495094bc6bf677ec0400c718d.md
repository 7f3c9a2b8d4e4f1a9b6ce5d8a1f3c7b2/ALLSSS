### Title
Side Chain LIB Validation Lacks Parent Chain Indexed Height Verification

### Summary
The `LibInformationValidationProvider.ValidateHeaderInformation()` function on side chains only validates that the `ConfirmedIrreversibleBlockHeight` does not decrease compared to previous rounds, but fails to verify that this height does not exceed what the parent chain has actually indexed. This allows side chains to claim arbitrarily high irreversible block heights beyond the parent chain's knowledge, violating cross-chain consistency guarantees.

### Finding Description

The vulnerability exists in the LIB (Last Irreversible Block) validation logic for side chains: [1](#0-0) 

This validation only ensures the LIB height is non-decreasing (line 16: `baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight`), but contains no check against the parent chain's indexed height.

The `ConsensusValidationContext` used for validation does not include any parent chain indexed height information: [2](#0-1) 

The side chain calculates its `ConfirmedIrreversibleBlockHeight` purely based on local consensus: [3](#0-2) 

The AEDPoS contract state has no reference to the CrossChainContract to query parent chain indexed heights: [4](#0-3) 

While the parent chain tracks indexed side chain heights via `State.CurrentSideChainHeight`: [5](#0-4) 

This indexed height information is never consulted during side chain consensus validation.

### Impact Explanation

**Consensus/Cross-Chain Integrity Violation**: Side chains can claim blocks as irreversible (LIB) at heights far exceeding what the parent chain has indexed or verified. For example, a side chain could claim height 10,000 as irreversible while the parent chain has only indexed side chain blocks up to height 1,000.

**Cross-Chain Consistency Breakdown**: The fundamental cross-chain invariant that side chain state must be verifiable by the parent chain is violated. Cross-chain transactions and merkle proof verifications rely on the parent chain having indexed the relevant side chain blocks, but side chains can misrepresent their irreversibility status.

**Potential Attack Scenarios**:
- Side chains claiming premature finality for blocks not yet indexed by parent chain
- Cross-chain transfer exploits where side chain claims blocks are final before parent chain confirmation
- Inconsistent state views between parent and side chains affecting cross-chain operations

This violates the critical invariant: "LIB height rules, cross-chain proof verification and index heights" must be consistently maintained across chains.

### Likelihood Explanation

**Reachable Entry Point**: The validation is triggered automatically during block execution for every `UpdateValue` consensus behavior through the public consensus flow. [6](#0-5) 

**Feasible Preconditions**: 
- Requires a functioning side chain with active block production
- Side chain miners can produce blocks faster than parent chain indexes them
- No special privileges needed beyond normal miner capabilities

**Execution Practicality**: The exploit occurs naturally when:
1. Side chain produces blocks at its normal consensus rate
2. Parent chain indexing lags behind (due to network delays, transaction submission delays, or parent chain block time)
3. Side chain's local consensus calculates LIB based solely on its own block production pattern
4. No validation prevents claiming this LIB height even though parent chain hasn't indexed it

**Economic Rationality**: Zero attack cost - this is a natural consequence of normal operations under any indexing delay. The vulnerability manifests whenever side chain block production outpaces parent chain indexing.

### Recommendation

**Add Parent Chain Indexed Height Validation**:

1. Modify `ConsensusValidationContext` to include parent chain indexed height:
   - Add a `CrossChainContract` reference to `AEDPoSContractState` 
   - Query `GetSideChainHeight` from the parent chain's perspective (if available through cross-chain data)
   - Include this information in the validation context

2. Enhance `LibInformationValidationProvider.ValidateHeaderInformation()`:
   ```csharp
   // After existing checks, add:
   if (!isMainChain && parentChainIndexedHeight > 0)
   {
       if (providedRound.ConfirmedIrreversibleBlockHeight > parentChainIndexedHeight)
       {
           validationResult.Message = "LIB height exceeds parent chain indexed height.";
           return validationResult;
       }
   }
   ```

3. Alternatively, cap the side chain's LIB calculation to never exceed the parent chain's last indexed height stored locally from parent chain block data updates.

4. Add integration tests verifying:
   - Side chain cannot claim LIB beyond parent chain indexed height
   - Proper handling when parent chain indexing data is available
   - Graceful degradation when parent chain data is temporarily unavailable

### Proof of Concept

**Initial State**:
- Side chain is operational with active consensus
- Parent chain has indexed side chain blocks up to height 1,000 (State.CurrentSideChainHeight[sideChainId] = 1000)

**Attack Sequence**:
1. Side chain produces blocks rapidly from height 1,001 to 3,000
2. Side chain's consensus determines block 2,500 is irreversible based on local voting/confirmation patterns (2/3+ miners confirmed)
3. Miner produces UpdateValue transaction with `providedRound.ConfirmedIrreversibleBlockHeight = 2500`
4. `LibInformationValidationProvider.ValidateHeaderInformation()` validates only that 2,500 > previous LIB height
5. Validation passes - no check against parent chain indexed height of 1,000
6. Side chain now claims blocks 1,001-2,500 as irreversible
7. Parent chain still only knows about blocks up to 1,000

**Expected Result**: Validation should fail because 2,500 > 1,000 (parent chain indexed height)

**Actual Result**: Validation succeeds, side chain claims LIB height 2,500

**Success Condition**: Side chain successfully claims `ConfirmedIrreversibleBlockHeight` that exceeds parent chain's `CurrentSideChainHeight` for that chain, demonstrating the lack of cross-chain consistency validation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L8-41)
```csharp
public class ConsensusValidationContext
{
    public long CurrentTermNumber { get; set; }
    public long CurrentRoundNumber { get; set; }

    /// <summary>
    ///     We can trust this because we already validated the pubkey
    ///     during `AEDPoSExtraDataExtractor.ExtractConsensusExtraData`
    /// </summary>
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();

    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;

    /// <summary>
    ///     Previous round information fetch from StateDb.
    /// </summary>
    public Round PreviousRound { get; set; }

    /// <summary>
    ///     This filed is to prevent one miner produces too many continues blocks
    ///     (which may cause problems to other parts).
    /// </summary>
    public LatestPubkeyToTinyBlocksCount LatestPubkeyToTinyBlocksCount { get; set; }

    public AElfConsensusHeaderInformation ExtraData { get; set; }
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-282)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ContractsReferences.cs (L10-20)
```csharp
// ReSharper disable once InconsistentNaming
// ReSharper disable UnusedAutoPropertyAccessor.Global
public partial class AEDPoSContractState
{
    internal ElectionContractContainer.ElectionContractReferenceState ElectionContract { get; set; }
    internal TreasuryContractImplContainer.TreasuryContractImplReferenceState TreasuryContract { get; set; }
    internal TokenContractContainer.TokenContractReferenceState TokenContract { get; set; }
    internal TokenHolderContractContainer.TokenHolderContractReferenceState TokenHolderContract { get; set; }
    internal ParliamentContractContainer.ParliamentContractReferenceState ParliamentContract { get; set; }
    internal ConfigurationContainer.ConfigurationReferenceState ConfigurationContract { get; set; }
}
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L55-61)
```csharp
    public override Int64Value GetSideChainHeight(Int32Value input)
    {
        var info = State.SideChainInfo[input.Value];
        Assert(info != null, "Side chain not found.");
        var height = State.CurrentSideChainHeight[input.Value];
        return new Int64Value { Value = height };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```
