### Title
Null Reference Exception in Side Chain Consensus Due to Missing TokenHolder Scheme Validation

### Summary
The `GetScheme()` method in TokenHolderContract returns null when no scheme exists for a given address, but calling code in the AEDPoS consensus contract does not validate this null return before accessing properties. This causes a null reference exception during automatic consensus processing on side chains, potentially halting block production. The vulnerability is triggered when a side chain is deployed without the TokenHolder contract available, which is explicitly treated as a valid deployment scenario in the initialization code.

### Finding Description

The `GetScheme()` method directly returns state without null validation: [1](#0-0) 

This null return causes critical failures in three locations:

**1. Critical Consensus Path - AEDPoSContract.Release():**
The `Release()` method retrieves the scheme and immediately accesses its `Period` property without null checking: [2](#0-1) 

This method is automatically invoked during consensus processing on side chains: [3](#0-2) 

**2. View Method - GetSideChainDividendPoolScheme():** [4](#0-3) 

**3. View Method - GetProfitsMap():** [5](#0-4) 

**Root Cause:**
The initialization code explicitly handles TokenHolder contract absence as a valid scenario, silently returning without creating the scheme: [6](#0-5) 

This initialization is called during consensus contract setup: [7](#0-6) 

**Why Existing Protections Fail:**
The contract includes a private helper method `GetValidScheme()` that properly validates for null, but the public `GetScheme()` and its external callers don't follow this pattern: [8](#0-7) 

### Impact Explanation

**Critical Impact - Consensus Failure:**
When a side chain is deployed without the TokenHolder contract (valid per initialization logic), and consensus processing begins with round > 1, the automatic `Release()` call throws a null reference exception. This causes:
- Complete halt of consensus transaction processing
- Block production停止 (stops)
- Side chain becomes non-operational
- All dependent services and applications停止工作 (stop working)
- Requires contract redeployment or chain restart to recover

**Low Impact - View Method Failures:**
`GetProfitsMap()` and `GetUndistributedDividends()` throw exceptions when queried with non-existent schemes, breaking UI/tools but not affecting state.

**Affected Parties:**
- Side chain operators and validators
- All users and applications on affected side chains
- Cross-chain operations depending on side chain availability

### Likelihood Explanation

**Likelihood: MEDIUM**

**Preconditions (Realistic):**
1. Side chain deployed with `IsSideChain = true` flag
2. TokenHolder contract not deployed or initialization fails (explicitly handled as valid scenario)
3. Consensus reaches round 2 or higher (happens naturally during normal operation)

**Execution Path (Automatic):**
- No attacker action required
- Consensus automatically calls `Release()` during transaction processing
- Occurs deterministically once preconditions are met

**Feasibility:**
The initialization code's explicit handling of TokenHolder contract absence indicates this is an expected deployment scenario. The comment "No need to continue if Token Holder Contract didn't deployed" confirms this is not an error condition but a valid configuration.

**Detection/Prevention:**
- Silent initialization failure provides no warning
- No runtime checks prevent the null dereference
- Only becomes apparent when consensus processing triggers the exception

### Recommendation

**1. Add Null Validation in Release() Method:**
```csharp
public void Release()
{
    if (State.TokenHolderContract.Value == null) return;
    var scheme = State.TokenHolderContract.GetScheme.Call(Context.Self);
    if (scheme == null || scheme.SchemeId == null) 
    {
        Context.LogDebug(() => "Token holder scheme not found, skipping release.");
        return;
    }
    // ... rest of method
}
```

**2. Add Null Validation in GetSideChainDividendPoolScheme():**
```csharp
private Scheme GetSideChainDividendPoolScheme()
{
    if (State.SideChainDividendPoolSchemeId.Value == null)
    {
        var tokenHolderScheme = State.TokenHolderContract.GetScheme.Call(Context.Self);
        Assert(tokenHolderScheme != null && tokenHolderScheme.SchemeId != null, 
               "Token holder scheme not initialized.");
        State.SideChainDividendPoolSchemeId.Value = tokenHolderScheme.SchemeId;
    }
    // ... rest of method
}
```

**3. Add Null Validation in GetProfitsMap():**
```csharp
public override ReceivedProfitsMap GetProfitsMap(ClaimProfitsInput input)
{
    var scheme = State.TokenHolderProfitSchemes[input.SchemeManager];
    Assert(scheme != null, "Token holder profit scheme not found.");
    // ... rest of method
}
```

**4. Add Test Coverage:**
- Add side chain consensus tests with `IsSideChain = true` configuration
- Test Release() behavior when TokenHolder contract is not deployed
- Test GetProfitsMap() with non-existent scheme addresses

### Proof of Concept

**Initial State:**
1. Deploy side chain with AEDPoS contract initialized with `IsSideChain = true`
2. Do NOT deploy TokenHolder contract (or let it be unavailable during initialization)
3. `InitialProfitSchemeForSideChain()` returns early, no scheme created

**Exploitation Steps:**
1. Side chain starts consensus processing
2. First round completes normally (check at line 83 requires `roundNumber > 1`)
3. Second round begins, `ProcessConsensusInformation` is called
4. Line 83 condition satisfied: `!State.IsMainChain.Value && currentRound.RoundNumber > 1`
5. `Release()` method called automatically
6. `GetScheme.Call(Context.Self)` returns null (no scheme exists)
7. Access to `scheme.Period` on line 108 throws `NullReferenceException`
8. Consensus transaction fails
9. Block production halts

**Expected Result:**
Consensus continues normally with appropriate null handling

**Actual Result:**
`NullReferenceException` thrown, consensus transaction fails, side chain halts

**Success Condition:**
Side chain becomes unable to produce blocks after reaching round 2

### Notes

The existence of the `GetValidScheme()` helper method demonstrates that developers were aware of the need for null validation in this contract. However, the public `GetScheme()` method and several of its external callers do not follow this defensive pattern, creating a critical vulnerability in the consensus path for side chains.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L259-262)
```csharp
    public override TokenHolderProfitScheme GetScheme(Address input)
    {
        return State.TokenHolderProfitSchemes[input];
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L264-271)
```csharp
    public override ReceivedProfitsMap GetProfitsMap(ClaimProfitsInput input)
    {
        var scheme = State.TokenHolderProfitSchemes[input.SchemeManager];
        var profitsMap = State.ProfitContract.GetProfitsMap.Call(new Profit.ClaimProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary ?? Context.Sender
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-284)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L16-25)
```csharp
    private void InitialProfitSchemeForSideChain(long periodSeconds)
    {
        var tokenHolderContractAddress =
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName);
        // No need to continue if Token Holder Contract didn't deployed.
        if (tokenHolderContractAddress == null)
        {
            Context.LogDebug(() => "Token Holder Contract not found, so won't initial side chain dividends pool.");
            return;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L102-113)
```csharp
    public void Release()
    {
        if (State.TokenHolderContract.Value == null) return;
        var scheme = State.TokenHolderContract.GetScheme.Call(Context.Self);
        var isTimeToRelease =
            (Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.PeriodSeconds.Value) > scheme.Period - 1;
        Context.LogDebug(() => "ReleaseSideChainDividendsPool Information:\n" +
                               $"CurrentBlockTime: {Context.CurrentBlockTime}\n" +
                               $"BlockChainStartTime: {State.BlockchainStartTimestamp.Value}\n" +
                               $"PeriodSeconds: {State.PeriodSeconds.Value}\n" +
                               $"Scheme Period: {scheme.Period}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L163-169)
```csharp
    private Scheme GetSideChainDividendPoolScheme()
    {
        if (State.SideChainDividendPoolSchemeId.Value == null)
        {
            var tokenHolderScheme = State.TokenHolderContract.GetScheme.Call(Context.Self);
            State.SideChainDividendPoolSchemeId.Value = tokenHolderScheme.SchemeId;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L83-83)
```csharp
        if (!State.IsMainChain.Value && currentRound.RoundNumber > 1) Release();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L35-35)
```csharp
        if (input.IsSideChain) InitialProfitSchemeForSideChain(input.PeriodSeconds);
```
