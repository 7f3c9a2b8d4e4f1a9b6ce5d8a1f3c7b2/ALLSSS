### Title
Missing Miner List Validation Enables Permanent DoS of Cross-Chain Consensus Updates

### Summary
The `UpdateInformationFromCrossChain()` function accepts consensus information without validating that the miner list is non-empty. If an empty miner list is accepted and stored in `MainChainCurrentMinerList`, all subsequent calls to `UpdateInformationFromCrossChain()` will fail with a division-by-zero exception in `DistributeResourceTokensToPreviousMiners()`, permanently blocking cross-chain consensus synchronization on the side chain.

### Finding Description

The `UpdateInformationFromCrossChain()` function extracts miner public keys from cross-chain consensus information and stores them without validation: [1](#0-0) 

The function only validates that the round number is increasing and that the sender is the CrossChain contract, but does not check if `RealTimeMinersInformation.Keys` contains any miners: [2](#0-1) 

Before updating the miner list, the function calls `DistributeResourceTokensToPreviousMiners()` which reads the current (previous) miner list and distributes resource tokens: [3](#0-2) 

Inside `DistributeResourceTokensToPreviousMiners()`, the code divides the balance by the miner count without checking if the count is zero: [4](#0-3) 

The `Div()` method performs standard division which throws `DivideByZeroException` when the divisor is zero: [5](#0-4) 

The cross-chain contract passes consensus extra data directly to the consensus contract without validating miner list content: [6](#0-5) 

### Impact Explanation

**Harm**: Permanent denial of service of cross-chain consensus information synchronization. Once an empty miner list is accepted, all future attempts to update cross-chain consensus information will revert with a division-by-zero exception.

**Protocol Damage**: 
- Side chain cannot receive main chain miner list updates
- Resource token distribution to miners becomes permanently disabled
- Cross-chain consensus synchronization is broken until contract upgrade

**Affected Parties**: All side chains in the AElf ecosystem that rely on main chain consensus information updates.

**Severity**: High - Complete operational failure of a critical cross-chain mechanism. While it requires malformed parent chain data to trigger, the defense-in-depth principle requires the consensus contract to validate inputs rather than blindly trust cross-chain data.

### Likelihood Explanation

**Entry Point**: `UpdateInformationFromCrossChain()` is callable only by the CrossChain contract, which receives parent chain block data and extracts consensus information from block extra data.

**Attack Complexity**: Low - Requires parent chain block data to contain consensus information with an empty `RealTimeMinersInformation` dictionary, which could occur through:
- Bug in parent chain consensus contract generating invalid consensus data
- Corruption in cross-chain data transmission
- Malicious or compromised parent chain block producer

**Feasibility**: While a properly functioning parent chain should never produce empty miner lists, the consensus contract lacks defensive validation. The protobuf parser will successfully parse an empty `RealTimeMinersInformation` (valid repeated field with zero entries).

**Detection**: The DoS is immediate and obvious upon the second update after accepting an empty list. The transaction will revert with `DivideByZeroException`.

**Probability**: Medium - Relies on malformed parent chain data reaching the consensus contract, but the lack of validation violates defense-in-depth principles.

### Recommendation

Add validation to reject empty miner lists before updating `MainChainCurrentMinerList`:

```csharp
var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
Assert(minersKeys.Any(), "Miner list cannot be empty.");

State.MainChainCurrentMinerList.Value = new MinerList
{
    Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
};
```

Additional defensive check in `DistributeResourceTokensToPreviousMiners()`:

```csharp
var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
if (minerList.Count == 0)
{
    Context.LogDebug(() => "No miners to distribute tokens to.");
    return;
}
```

Add test case to verify rejection of empty miner lists:

```csharp
[Fact]
public async Task UpdateInformationFromCrossChain_EmptyMinerList_ShouldFail()
{
    var headerInformation = new AElfConsensusHeaderInformation
    {
        Round = new Round
        {
            RoundNumber = 2,
            RealTimeMinersInformation = { } // Empty
        }
    };
    
    var result = await ConsensusStub.UpdateInformationFromCrossChain.SendWithExceptionAsync(
        new BytesValue { Value = headerInformation.ToByteString() });
    result.TransactionResult.Error.ShouldContain("Miner list cannot be empty");
}
```

### Proof of Concept

**Initial State**:
- Side chain with valid `MainChainCurrentMinerList` containing 3 miners (pubkeys A, B, C)
- `MainChainRoundNumber` = 1

**Step 1**: Cross-chain contract receives parent chain block with malformed consensus data containing empty `RealTimeMinersInformation`

**Step 2**: Cross-chain contract calls `UpdateInformationFromCrossChain()` with:
```
consensusInformation.Round.RoundNumber = 2
consensusInformation.Round.RealTimeMinersInformation = {} (empty dictionary)
```

**Step 3**: Execution flow:
- Line 46 check passes (2 > 1)
- Line 53: `DistributeResourceTokensToPreviousMiners()` executes successfully (distributes to A, B, C)
- Lines 57-61: `MainChainCurrentMinerList` is set to empty list (no validation!)
- Transaction succeeds, `MainChainRoundNumber` = 2

**Step 4**: Cross-chain contract attempts next update (round 3, any miner list):

**Step 5**: Execution flow:
- Line 53: `DistributeResourceTokensToPreviousMiners()` called
- Line 72: `minerList = State.MainChainCurrentMinerList.Value.Pubkeys` (empty list, Count = 0)
- Line 81: `balance.Div(0)` â†’ **DivideByZeroException thrown**
- Transaction reverts

**Expected Result**: Transaction succeeds and updates consensus information

**Actual Result**: Transaction permanently reverts with `DivideByZeroException`, blocking all future cross-chain consensus updates

**Success Condition**: After Step 4, all calls to `UpdateInformationFromCrossChain()` fail, confirming permanent DoS.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L46-47)
```csharp
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L53-53)
```csharp
        DistributeResourceTokensToPreviousMiners();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L57-61)
```csharp
        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L72-81)
```csharp
        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
        foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
            var amount = balance.Div(minerList.Count);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L783-788)
```csharp
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }
```
