### Title
Governance Lock via Unreachable Method Fee Controller Thresholds

### Summary
The `ChangeMethodFeeController` method allows the current controller to set a new method fee controller without validating whether the target organization has reachable governance thresholds. An attacker controlling the current governance can change the controller to a Parliament organization requiring 100% approval, effectively making future controller changes impossible if any parliament member becomes unavailable. This creates a permanent governance lock with no recovery mechanism.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController` implementation [1](#0-0) 

The method performs only two validations:
1. Authorization check that sender is the current controller's owner address [2](#0-1) 
2. Organization existence check via `CheckOrganizationExist` [3](#0-2) 

However, `CheckOrganizationExist` only verifies that the organization exists in state storage, not whether it can execute proposals [4](#0-3) 

The Parliament contract's validation logic allows organizations with `MinimalApprovalThreshold` up to 10000 (representing 100% approval) [5](#0-4) 

Test cases confirm that organizations requiring 100% approval are valid and can be created successfully [6](#0-5) 

The ACS1 standard defines only `ChangeMethodFeeController` with no emergency override or recovery mechanism [7](#0-6) 

**Attack Execution Path**:
1. Current controller (default Parliament organization requiring ~67% approval) proposes controller change
2. Attacker creates a new Parliament organization with `MinimalApprovalThreshold = 10000` and `MinimalVoteThreshold = 10000`
3. Proposal passes through current governance (feasible with 67% threshold)
4. Controller is changed to the new organization [8](#0-7) 
5. Any future controller change now requires 100% of parliament members to approve
6. If even one member is offline, loses keys, or refuses to participate, governance is permanently locked

### Impact Explanation

**Direct Operational Impact**: Method fees for the Election contract (and all other ACS1 contracts) can no longer be adjusted. This prevents:
- Emergency fee reductions if fees become prohibitively expensive
- Fee increases to prevent spam attacks
- Adaptation to changing economic conditions

**Affected Contracts**: This vulnerability exists identically across all system contracts implementing ACS1 standard, including Token [9](#0-8) , Parliament [10](#0-9) , Treasury, Vote, and others.

**Permanence**: Once locked, there is no recovery mechanism. The controller cannot be changed back without meeting the impossible 100% threshold.

**Severity Justification**: HIGH - Creates permanent operational failure in critical governance functionality affecting multiple system contracts, with no recovery path.

### Likelihood Explanation

**Attacker Capabilities**: Requires control of current governance (default Parliament requiring 67% approval) to pass the malicious proposal. This is realistic for:
- Colluding majority of parliament members
- Compromised governance during low participation periods
- Malicious proposal disguised among legitimate governance actions

**Attack Complexity**: Low - Single proposal execution:
1. Create organization with extreme thresholds (1 transaction)
2. Create proposal to change controller (1 transaction)  
3. Gather votes from current parliament (standard governance flow)
4. Release proposal (1 transaction)

**Feasibility**: The attack uses standard governance mechanisms. The emergency response organization demonstrates that high thresholds (90%) are intentionally supported in the system [11](#0-10) , making 100% thresholds appear valid rather than suspicious.

**Detection**: Difficult to detect before execution, as creating organizations with various thresholds is normal governance activity. Once executed, the lock is immediately permanent.

**Probability**: MEDIUM-HIGH - Requires governance compromise but uses legitimate mechanisms, making it stealthy and executable.

### Recommendation

**Immediate Fix**: Add threshold reachability validation in `ChangeMethodFeeController`:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    // NEW: Validate threshold is reachable
    Assert(ValidateReachableThreshold(input), "Organization threshold unreachable.");
    
    State.MethodFeeController.Value = input;
    return new Empty();
}

private bool ValidateReachableThreshold(AuthorityInfo authorityInfo)
{
    // For Parliament: ensure MinimalApprovalThreshold <= 8000 (80%)
    // For Association: verify organization has sufficient active members
    // Call the governance contract to validate threshold safety
    return Context.Call<BoolValue>(
        authorityInfo.ContractAddress,
        "ValidateOrganizationThresholdReachable", 
        authorityInfo.OwnerAddress
    ).Value;
}
```

**Additional Protections**:
1. Implement maximum threshold cap (e.g., 8000 = 80%) for organizations used as controllers
2. Add a time-lock mechanism allowing a grace period to revert controller changes
3. Create an emergency override mechanism controlled by a separate high-threshold organization

**Test Cases**:
1. Test that `ChangeMethodFeeController` rejects organizations with 100% threshold
2. Test that `ChangeMethodFeeController` rejects organizations with 95%+ threshold
3. Test recovery scenarios for accidentally misconfigured controllers

### Proof of Concept

**Initial State**:
- Election contract deployed with default Parliament organization as method fee controller
- Default organization requires MinimalApprovalThreshold = 6667 (66.67%)
- 21 active parliament members (miners)

**Attack Steps**:

1. **Create malicious organization**:
   - Call `ParliamentContract.CreateOrganization` with:
     - `MinimalApprovalThreshold = 10000` (100%)
     - `MinimalVoteThreshold = 10000` (100%)
     - `MaximalAbstentionThreshold = 0`
     - `MaximalRejectionThreshold = 0`
   - Organization created successfully (validated by test case) [6](#0-5) 

2. **Submit controller change proposal**:
   - Create proposal through default Parliament organization
   - Target: `ElectionContract.ChangeMethodFeeController`
   - Parameters: New organization address with 100% threshold
   - Requires 67% approval (14 of 21 members)

3. **Execute proposal**:
   - Gather 14 approvals from parliament members
   - Release proposal
   - Controller successfully changed [12](#0-11) 

4. **Verify governance lock**:
   - Attempt to change controller back to default organization
   - Requires all 21 parliament members to approve (100% threshold)
   - If any member is offline/unavailable: proposal cannot pass
   - Controller permanently locked

**Expected Result**: Controller can be changed through normal governance

**Actual Result**: Controller is changed to organization with unreachable threshold, creating permanent governance lock

**Success Condition**: Method fee controller can no longer be changed, confirming permanent operational failure

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L314-330)
```csharp
    private void CreateEmergencyResponseOrganization()
    {
        var createOrganizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 9000,
                MinimalVoteThreshold = 9000,
                MaximalAbstentionThreshold = 1000,
                MaximalRejectionThreshold = 1000
            },
            ProposerAuthorityRequired = false,
            ParliamentMemberProposingAllowed = true
        };

        State.EmergencyResponseOrganizationAddress.Value = CreateOrganization(createOrganizationInput);
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L189-195)
```csharp
            createOrganizationInput.ProposalReleaseThreshold.MinimalApprovalThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MinimalVoteThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MaximalAbstentionThreshold = 0;
            createOrganizationInput.ProposalReleaseThreshold.MaximalRejectionThreshold = 0;
            var transactionResult =
                await minerParliamentContractStub.CreateOrganization.SendAsync(createOrganizationInput);
            transactionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
```

**File:** protobuf/acs1.proto (L25-27)
```text
    // Change the method fee controller, the default is parliament and default organization.
    rpc ChangeMethodFeeController (AuthorityInfo) returns (google.protobuf.Empty) {
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-24)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-21)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ACS1ImplTest.cs (L36-68)
```csharp
    public async Task ChangeMethodFeeController_Test()
    {
        var createOrganizationResult =
            await ParliamentContractStub.CreateOrganization.SendAsync(
                new CreateOrganizationInput
                {
                    ProposalReleaseThreshold = new ProposalReleaseThreshold
                    {
                        MinimalApprovalThreshold = 1000,
                        MinimalVoteThreshold = 1000
                    }
                });
        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.TransactionResult.ReturnValue);

        var methodFeeController = await ElectionContractStub.GetMethodFeeController.CallAsync(new Empty());
        var defaultOrganization = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
        methodFeeController.OwnerAddress.ShouldBe(defaultOrganization);

        const string proposalCreationMethodName = nameof(ElectionContractStub.ChangeMethodFeeController);
        var proposalId = await CreateProposalAsync(ElectionContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName, new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = ParliamentContractAddress
            });
        await ApproveWithMinersAsync(proposalId);
        var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId);
        releaseResult.TransactionResult.Error.ShouldBeNullOrEmpty();
        releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var newMethodFeeController = await ElectionContractStub.GetMethodFeeController.CallAsync(new Empty());
        newMethodFeeController.OwnerAddress.ShouldBe(organizationAddress);
    }
```
