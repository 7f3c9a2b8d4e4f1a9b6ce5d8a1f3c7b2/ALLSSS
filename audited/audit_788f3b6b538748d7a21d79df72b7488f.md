### Title
Denial of Service in TokenHolder AddBeneficiary Due to Invalid Single() Assumption on Multiple Profit Details

### Summary
The `AddBeneficiary()` function in TokenHolderContract assumes beneficiaries have exactly one profit detail by calling `Single()`, but beneficiaries can legitimately have multiple details after partial removals. This causes transaction failures that permanently lock beneficiaries from updating their shares, creating a denial of service condition. While the question asks about share duplication, shares cannot be duplicated because the transaction fails before reaching the duplication point.

### Finding Description

The vulnerability exists in the `AddBeneficiary()` function where it attempts to merge existing shares: [1](#0-0) 

On line 55, the code calls `detail.Details.Single().Shares`, which assumes exactly one profit detail exists. However, the underlying Profit contract allows and creates multiple `ProfitDetail` entries per beneficiary: [2](#0-1) 

Multiple details are created legitimately through partial removals in TokenHolder's `RemoveBeneficiary`: [3](#0-2) 

When a partial removal occurs (lines 85-95), the old detail is marked as ended and a new detail with reduced shares is added, resulting in two details. This is confirmed by the test case: [4](#0-3) 

The protobuf definition confirms that `ProfitDetails` contains a repeated field allowing multiple entries: [5](#0-4) 

### Impact Explanation

**Operational Impact - Permanent DOS:**
- Any beneficiary who undergoes a partial share removal will have 2+ profit details
- Subsequent calls to `AddBeneficiary` for that beneficiary will fail with `InvalidOperationException`
- The beneficiary cannot update their shares through normal TokenHolder operations
- The scheme manager cannot modify this beneficiary's shares
- `RemoveBeneficiary` also uses `Single()` on line 78, so removal is also blocked
- The beneficiary's shares are effectively frozen until manual intervention through the Profit contract directly

**No Share Duplication:**
Contrary to the question's premise, shares cannot be duplicated because C#'s `Single()` method throws an exception when called on a collection with multiple elements, causing the transaction to revert before any share operations occur.

**Affected Users:**
- Any TokenHolder scheme where beneficiaries use partial removal features
- All DApp creators using TokenHolder profit schemes with dynamic share adjustments
- Critical for election and staking systems that need flexible share management

### Likelihood Explanation

**High Likelihood:**
- **Reachable Entry Point**: `AddBeneficiary` is callable by scheme managers (line 39)
- **Feasible Preconditions**: Partial removal via `RemoveBeneficiary(amount > 0 && amount < total)` is a legitimate feature designed into the contract (lines 85-95)
- **Execution Practicality**: Any manager attempting to update a beneficiary's shares after a partial removal will trigger this
- **No Attack Required**: This is a design flaw triggered through normal operations, not malicious activity
- **Permanent Condition**: Once multiple details exist, the beneficiary is permanently locked from TokenHolder operations

The test suite demonstrates this is an expected state after partial removals, meaning the vulnerability affects normal contract usage patterns.

### Recommendation

**Immediate Fix:**
Replace `Single()` with logic to handle multiple details by summing all active shares:

```csharp
var shares = input.Shares;
if (detail.Details.Any())
{
    State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
    {
        SchemeId = scheme.SchemeId,
        Beneficiary = input.Beneficiary
    });
    // Sum all existing details instead of assuming single
    var totalExistingShares = detail.Details
        .Where(d => !d.IsWeightRemoved)
        .Sum(d => d.Shares);
    shares = shares.Add(totalExistingShares);
}
```

**Additional Checks:**
1. Add validation in `RemoveBeneficiary` (line 78) to handle multiple details similarly
2. Add integration tests for sequences: Add → Partial Remove → Add again
3. Consider adding a helper method to safely aggregate profit details

**Long-term Solution:**
Consider redesigning the partial removal feature to avoid creating multiple detail entries, or ensure TokenHolder contract explicitly handles the multi-detail pattern the Profit contract supports.

### Proof of Concept

**Initial State:**
- TokenHolder scheme created with any symbol
- Scheme manager = Alice
- Beneficiary = Bob

**Transaction Sequence:**

1. **Alice adds Bob with 1000 shares:**
```
TokenHolderContract.AddBeneficiary(Beneficiary: Bob, Shares: 1000)
→ Success: Bob has 1 detail with 1000 shares
```

2. **Alice partially removes 100 shares from Bob:**
```
TokenHolderContract.RemoveBeneficiary(Beneficiary: Bob, Amount: 100)
→ Success: Bob now has 2 details:
   - Detail[0]: 1000 shares, EndPeriod = 0 (ended)
   - Detail[1]: 900 shares (active)
```

3. **Alice attempts to add more shares to Bob:**
```
TokenHolderContract.AddBeneficiary(Beneficiary: Bob, Shares: 500)
→ FAILURE: InvalidOperationException from Single()
→ Transaction reverts
→ Bob permanently cannot update shares via TokenHolder
```

**Expected Result:** Bob's shares should merge to 1400 (900 existing + 500 new)

**Actual Result:** Transaction fails, Bob's shares are locked at 900, no further updates possible through TokenHolder contract

**Success Condition for Exploit:** After step 2, the beneficiary is in a DOS state where all AddBeneficiary calls fail.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-68)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }

        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = shares
            }
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L186-196)
```csharp
        afterRemoveScheme.TotalShares.ShouldBe(beforeRemoveScheme.TotalShares - amount);
        var profitAmount = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
        {
            Beneficiary = Starter,
            SchemeId = schemeId
        });
        profitAmount.Details.Count.ShouldBe(2);
        profitAmount.Details[0].Shares.ShouldBe(beforeRemoveScheme.TotalShares);
        profitAmount.Details[0].EndPeriod.ShouldBe(0);
        profitAmount.Details[1].Shares.ShouldBe(beforeRemoveScheme.TotalShares - amount);
    }
```

**File:** protobuf/profit_contract.proto (L233-250)
```text
message ProfitDetails {
    // The profit information.
    repeated ProfitDetail details = 1;
}

message ProfitDetail {
    // The start period number.
    int64 start_period = 1;
    // The end period number.
    int64 end_period = 2;
    // The weight of the proceeds on the current period of the scheme.
    int64 shares = 3;
    // The last period number that the beneficiary received the profit.
    int64 last_profit_period = 4;
    // Whether the weight has been removed.
    bool is_weight_removed = 5;
    aelf.Hash id = 6;
}
```
