### Title
Governance Security Downgrade via ChangeUserFeeController Allows Permanent Bypass of Multi-Tier Approval Requirements

### Summary
The `ChangeUserFeeController` function permits replacing a carefully designed multi-tier governance structure (requiring both Parliament and Referendum approval) with any arbitrary organization, without verifying that the new controller maintains equivalent security properties. A one-time collusion between Parliament and Referendum can permanently downgrade the governance model to a weak single-controller system, enabling future unilateral manipulation of critical user transaction fee coefficients.

### Finding Description

The vulnerability exists in the `ChangeUserFeeController` function [1](#0-0) 

**Root Cause:**

The function only validates organization existence via `CheckOrganizationExist(input)` at line 73, which internally calls `ValidateOrganizationExist` on the target governance contract [2](#0-1) 

This check merely confirms the organization exists in the registry but performs **no validation** of:
- Approval threshold requirements
- Member composition or count
- Proposer whitelist restrictions
- Any other security properties

**Original Multi-Tier Structure:**

During initialization, the UserFeeController is designed with a robust three-tier governance model [3](#0-2) 

The structure consists of:

1. **ReferendumController**: Requires token holder voting, with Parliament-only proposal rights [4](#0-3) 

2. **ParliamentController**: Represents block producer consensus (default Parliament organization)

3. **RootController**: An Association requiring **unanimous approval** from both Parliament AND Referendum organizations [5](#0-4) 

Note that lines 173-174 explicitly set `MinimalApprovalThreshold = proposers.Count` (which equals 2), requiring **both** Parliament and Referendum to approve any changes.

**Why Existing Protections Fail:**

When `ChangeUserFeeController` executes:
- Line 72: Authorization check passes (sender is current RootController - controlled jointly by Parliament and Referendum)
- Line 73: Organization existence check passes for ANY valid organization
- Line 74: RootController is **completely replaced** with the new organization
- Lines 75-76: ParliamentController and ReferendumController are **nullified**, destroying the multi-tier structure

The UserFeeController structure is defined as [6](#0-5) 

After the change, only `root_controller` remains populated; the other controllers are set to null, permanently eliminating the dual-approval requirement.

### Impact Explanation

**Critical Governance Authority Compromised:**

The UserFeeController governs the `UpdateCoefficientsForSender` function [7](#0-6) 

This function controls transaction fee calculation coefficients for the entire blockchain, specifically for `FeeTypeEnum.Tx` (user transaction fees). The initial coefficient structure defines complex piecewise polynomial formulas that determine fee costs based on transaction parameters [8](#0-7) 

**Concrete Harm:**

1. **Economic Manipulation**: A weak controller can arbitrarily modify fee coefficients, enabling:
   - Excessive fee increases that make the chain unusable for average users
   - Near-zero fees that undermine validator economics
   - Discriminatory fee structures benefiting specific parties

2. **Permanent Governance Downgrade**: The original checks-and-balances system requiring consensus between:
   - Parliament (representing block producers/infrastructure)
   - Referendum (representing token holder community)
   
   Is permanently replaced with potentially a single entity requiring only 1 approval.

3. **Loss of Democratic Oversight**: Token holders lose their governance voice over critical economic parameters that directly affect their transaction costs.

**Affected Parties:**
- All blockchain users (fee manipulation)
- Token holders (loss of governance rights)
- Validators (economic model integrity)
- Protocol security (centralization of critical controls)

**Severity Justification:** HIGH - Controls fundamental economic parameters of the entire chain with permanent, irreversible governance downgrade.

### Likelihood Explanation

**Attacker Capabilities Required:**

The attack requires a **one-time collusion** between Parliament and Referendum organizations. Since they jointly control the current RootController (as designed), they can propose and approve a call to `ChangeUserFeeController`. This is demonstrated in the test suite [9](#0-8) 

**Attack Complexity: LOW**

The exploit follows standard governance flows:
1. Create a weak replacement organization (e.g., single-member Association with `MinimalApprovalThreshold = 1`)
2. Create proposal to call `ChangeUserFeeController` with new organization address
3. Approve via Parliament organization
4. Vote and approve via Referendum organization
5. Release proposal through RootController
6. Weak controller is now permanently installed

**Feasibility Conditions:**

- Parliament and Referendum must collude ONCE
- After this single coordinated action, the governance downgrade is **permanent**
- The weak controller enables all future manipulations without further multi-party coordination
- No technical barriers exist; the validation at line 73 only checks organization existence

**Economic Rationality:**

If manipulating fee coefficients can:
- Generate revenue through excessive fees
- Enable DoS against competitors
- Provide unfair advantages to controlled addresses

Then the one-time collusion cost is easily justified by permanent control over critical economic parameters.

**Detection Constraints:**

The attack uses legitimate governance mechanisms. The only indicator would be monitoring `ChangeUserFeeController` calls and comparing the security properties of old vs. new controllers - which is not enforced by the contract itself.

**Probability Assessment:** MEDIUM-HIGH
- Requires coordination but within designed governance capabilities
- Single execution achieves permanent impact
- Clear financial incentives for malicious actors
- No technical impediments once collusion achieved

### Recommendation

**Immediate Mitigation:**

Add comprehensive validation in `ChangeUserFeeController` to enforce that the new controller maintains **equivalent or stronger** security properties:

```
public override Empty ChangeUserFeeController(AuthorityInfo input)
{
    AssertUserFeeController();
    Assert(CheckOrganizationExist(input), "Invalid authority input.");
    
    // NEW: Validate security properties of new controller
    ValidateControllerSecurityProperties(input);
    
    State.UserFeeController.Value.RootController = input;
    State.UserFeeController.Value.ParliamentController = null;
    State.UserFeeController.Value.ReferendumController = null;
    return new Empty();
}

private void ValidateControllerSecurityProperties(AuthorityInfo newController)
{
    // Query organization details from the governance contract
    var organizationInfo = GetOrganizationInfo(newController);
    
    // Enforce minimum threshold requirements
    Assert(organizationInfo.ProposalReleaseThreshold.MinimalApprovalThreshold >= 2, 
        "New controller must require at least 2 approvals");
    Assert(organizationInfo.ProposalReleaseThreshold.MinimalVoteThreshold >= 2,
        "New controller must require at least 2 votes");
    
    // Verify member count for multi-sig organizations
    if (newController.ContractAddress == State.AssociationContract.Value)
    {
        Assert(organizationInfo.OrganizationMemberList.OrganizationMembers.Count >= 2,
            "Association controller must have at least 2 members");
    }
    
    // Additional checks for proposer whitelist and other security properties
    Assert(organizationInfo.ProposerWhiteList?.Proposers.Count >= 1,
        "Controller must have defined proposer whitelist");
}
```

**Alternative Design:**

Consider making UserFeeController immutable or requiring even higher thresholds (e.g., supermajority or time-locked governance) for such critical changes, as this function fundamentally alters the security model of fee governance.

**Test Cases to Add:**

1. Attempt to change controller to single-member organization (should fail)
2. Attempt to change controller to organization with threshold < 2 (should fail)
3. Verify that only organizations with equivalent security properties can replace the controller
4. Test edge cases with maximum threshold values and member counts

### Proof of Concept

**Initial State:**
- UserFeeController initialized with multi-tier structure (Parliament + Referendum)
- RootController is Association requiring 2/2 approvals
- Both Parliament and Referendum have governance authority

**Attack Sequence:**

1. **Create Weak Organization:**
   ```
   // Create single-member Association with minimal threshold
   CreateOrganizationInput weakOrg = {
       OrganizationMemberList: { attackerAddress },
       ProposalReleaseThreshold: {
           MinimalApprovalThreshold: 1,
           MinimalVoteThreshold: 1
       }
   }
   // Calculate address and create organization
   weakControllerAddress = AssociationContract.CreateOrganization(weakOrg)
   ```

2. **Collude to Change Controller:**
   ```
   // Create proposal through current RootController
   proposalInput = {
       ContractMethodName: "ChangeUserFeeController",
       ToAddress: TokenContractAddress,
       Params: weakControllerAddress
   }
   
   // Parliament approves
   ParliamentContract.Approve(proposalId)
   
   // Referendum votes and approves (token holders)
   ReferendumContract.Vote(proposalId, approve: true)
   
   // Release through RootController
   AssociationContract.Release(proposalId)
   ```

3. **Verify Downgrade:**
   ```
   userFeeController = TokenContract.GetUserFeeController()
   // Expected: RootController = weakControllerAddress
   // Expected: ParliamentController = null
   // Expected: ReferendumController = null
   ```

4. **Exploit Permanent Control:**
   ```
   // Now attacker (single member of weak org) can unilaterally change fee coefficients
   TokenContract.UpdateCoefficientsForSender(maliciousCoefficients)
   // No Parliament or Referendum approval needed
   ```

**Success Condition:**
- Initial state requires 2 organizations to approve fee changes
- Final state requires only 1 entity to approve fee changes
- ParliamentController and ReferendumController are permanently nullified
- Attacker maintains permanent unilateral control over user fee coefficients

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L16-26)
```csharp
    public override Empty InitializeAuthorizedController(Empty input)
    {
        var defaultParliamentController = GetDefaultParliamentController();
        if (State.UserFeeController.Value == null)
        {
            var defaultUserFeeController = GetDefaultUserFeeController(defaultParliamentController);
            CreateReferendumControllerForUserFee(defaultParliamentController.OwnerAddress);
            CreateAssociationControllerForUserFee(defaultParliamentController.OwnerAddress,
                defaultUserFeeController.ReferendumController.OwnerAddress);
            State.UserFeeController.Value = defaultUserFeeController;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L70-78)
```csharp
    public override Empty ChangeUserFeeController(AuthorityInfo input)
    {
        AssertUserFeeController();
        Assert(CheckOrganizationExist(input), "Invalid authority input.");
        State.UserFeeController.Value.RootController = input;
        State.UserFeeController.Value.ParliamentController = null;
        State.UserFeeController.Value.ReferendumController = null;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L133-156)
```csharp
    private CreateOrganizationBySystemContractInput GetReferendumControllerCreateInputForUserFee(
        Address parliamentAddress)
    {
        var whiteList = new List<Address> { parliamentAddress };
        var tokenSymbol = GetPrimaryTokenSymbol(new Empty()).Value;
        return new CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new CreateOrganizationInput
            {
                TokenSymbol = tokenSymbol,
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1,
                    MinimalVoteThreshold = 1,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { whiteList }
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L158-184)
```csharp
    private Association.CreateOrganizationBySystemContractInput GetAssociationControllerCreateInputForUserFee(
        Address parliamentAddress, Address referendumAddress)
    {
        var proposers = new List<Address>
            { referendumAddress, parliamentAddress };
        return new Association.CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new Association.CreateOrganizationInput
            {
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { proposers }
                },
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = proposers.Count,
                    MinimalVoteThreshold = proposers.Count,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { proposers }
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** protobuf/token_contract_impl.proto (L313-320)
```text
message UserFeeController{
    // The association that governs the organization.
    AuthorityInfo root_controller = 1;
    // The parliament organization of members.
    AuthorityInfo parliament_controller = 2;
    // The referendum organization of members.
    AuthorityInfo referendum_controller = 3;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L25-32)
```csharp
    public override Empty UpdateCoefficientsForSender(UpdateCoefficientsInput input)
    {
        Assert(input.Coefficients != null, "Invalid input coefficients.");
        AssertUserFeeController();
        input.Coefficients.FeeTokenType = (int)FeeTypeEnum.Tx; // The only possible for now.
        UpdateCoefficients(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L274-312)
```csharp
    private CalculateFeeCoefficients GetTxFeeInitialCoefficient()
    {
        return new CalculateFeeCoefficients
        {
            FeeTokenType = (int)FeeTypeEnum.Tx,
            PieceCoefficientsList =
            {
                new CalculateFeePieceCoefficients
                {
                    // Interval [0, 1000000]: x / 800 + 1 / 10000
                    Value =
                    {
                        1000000,
                        1, 1, 800,
                        0, 1, 10000
                    }
                },
                new CalculateFeePieceCoefficients
                {
                    // Interval (1000000, 5000000): x / 80
                    Value =
                    {
                        5000000,
                        1, 1, 80
                    }
                },
                new CalculateFeePieceCoefficients
                {
                    // Interval (5000000, âˆž): x / 80 + x^2 / 100000
                    Value =
                    {
                        int.MaxValue,
                        1, 1, 80,
                        2, 1, 100000
                    }
                }
            }
        };
    }
```

**File:** test/AElf.Contracts.MultiTokenCrossChainTransfer.Tests/MultiTokenContractReferenceFeeTest.cs (L323-337)
```csharp
    public async Task ChangeUserFeeController_Success_Test()
    {
        var primaryTokenSymbol = await GetThePrimaryTokenAsync();
        await IssuePrimaryTokenToMainChainTesterAsync();
        var updateMethodName = nameof(TokenContractImplContainer.TokenContractImplStub.ChangeUserFeeController);
        var newAuthority = await CreateNewParliamentAddressAsync();

        var proposalId = await CreateToRootForUserFeeByTwoLayerAsync(newAuthority, updateMethodName);
        await ApproveToRootForUserFeeByTwoLayerAsync(proposalId);
        await VoteToReferendumAsync(proposalId, primaryTokenSymbol);
        await ReleaseToRootForUserFeeByTwoLayerAsync(proposalId);
        var userFeeController = await TokenContractStub.GetUserFeeController.CallAsync(new Empty());
        userFeeController.RootController.ContractAddress.ShouldBe(newAuthority.ContractAddress);
        userFeeController.RootController.OwnerAddress.ShouldBe(newAuthority.OwnerAddress);
    }
```
