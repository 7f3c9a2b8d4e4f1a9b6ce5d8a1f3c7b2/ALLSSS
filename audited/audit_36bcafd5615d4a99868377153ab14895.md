# Audit Report

## Title
Lexicographic Backup Selection Allows Malicious Miners to Persist Without Voting Support

## Summary
The `GetVictories()` method in the Election contract uses arbitrary lexicographic ordering to select backup miners when there are insufficient valid candidates. This allows attackers with crafted low-sorting public keys to guarantee selection as backup miners, and critically, allows banned miners to return to the consensus set. The method fails to check the `BannedPubkeyMap`, creating an inconsistency with similar functions that do enforce banned status checks.

## Finding Description

The vulnerability exists in the private `GetVictories(List<string> currentMiners)` method where backup miner selection occurs when valid candidates are insufficient to fill the required miner count. [1](#0-0) 

When the candidate shortage condition is triggered (`diff > 0`), the method creates a backup pool from current miners not in valid candidates plus initial miners, then sorts this pool using pure lexicographic ordering without any security checks: [2](#0-1) 

**Critical Security Flaws:**

1. **No Banned Pubkey Check:** The backup selection does not verify `State.BannedPubkeyMap`, allowing banned miners to be re-selected for consensus participation. This directly contradicts the contract's security model where banned miners are explicitly marked and should be excluded from all consensus activities. [3](#0-2) 

2. **Inconsistent Security Enforcement:** The `GetMinerReplacementInformation` method correctly checks banned status when selecting alternative miners, demonstrating that the protocol designers intended banned miners to be filtered. [4](#0-3) 

3. **Gameable Lexicographic Ordering:** The `OrderBy(p => p)` sorting uses hex string comparison, allowing attackers to generate vanity public keys with low lexicographic values (e.g., starting with "0000...") to guarantee priority selection. Finding such keys is computationally trivial.

4. **No Merit-Based Criteria:** Unlike the normal victory selection which orders candidates by vote count, the backup selection ignores all merit-based factors including voting support, performance history, or stake amounts.

**Execution Path:**

The consensus contract calls this method during term transitions via `TryToGetVictories()`: [5](#0-4) 

The returned miner list is used directly to generate the next term's consensus participants: [6](#0-5) 

**Valid Candidate Requirements:**

The threshold for being a "valid candidate" only requires `ObtainedActiveVotedVotesAmount > 0` with no minimum, making it trivial to drop below this threshold. [7](#0-6) 

## Impact Explanation

**HIGH Severity - Multiple Critical Security Guarantees Broken:**

1. **Banned Miner Bypass (Critical):** Miners marked as evil/malicious through `UpdateCandidateInformation` with `IsEvilNode=true` can return to the consensus set in the next term if a candidate shortage occurs. This completely undermines the security mechanism designed to remove malicious actors from consensus participation.

2. **Reward Misallocation:** Attackers continue earning block production rewards and transaction fees without maintaining community voting support. With a lock requirement of 100,000 ELF and the ability to persist across multiple terms through vanity key priority, the mining rewards can significantly exceed the initial investment. [8](#0-7) 

3. **Democratic Subversion:** The Election contract's fundamental purpose is implementing vote-based miner selection. This vulnerability allows miners to persist without any voting support, violating the core security invariant that miners must maintain community backing.

4. **Consensus Integrity Compromise:** Miners without community accountability can engage in censorship attacks, transaction filtering, or collude with other similarly-positioned miners to manipulate the consensus process.

5. **Legitimate Candidate Displacement:** Attackers with vanity keys are systematically prioritized over legitimate candidates with higher-sorting public keys who should be selected as backups based on merit.

## Likelihood Explanation

**MEDIUM to HIGH Likelihood:**

**Attacker Requirements:**
1. Generate vanity public key with low lexicographic value (computationally trivial - ~65,536 attempts for 4 leading zeros)
2. Lock 100,000 ELF and obtain initial election through legitimate or illegitimate means (vote buying, reputation building)
3. Wait for candidate shortage condition (`diff > 0`)

**Feasibility Conditions:**
- Candidate shortage scenarios are real and tested in the codebase, confirming they occur in practice: [9](#0-8) 
- More likely in new chains, low-participation ecosystems, or after mass candidate exodus
- Multiple colluding attackers with coordinated vanity keys amplify the attack

**Detection Difficulty:**
- No on-chain indicator distinguishes backup-selected miners from vote-selected miners
- Difficult to differentiate from legitimate backup selection
- Pattern only becomes apparent over multiple terms

The likelihood increases significantly in scenarios where:
- Persistent candidate shortages exist (common in nascent ecosystems)
- Initial election barrier can be overcome
- Banned miners actively exploit the re-entry path

## Recommendation

**Fix 1 - Add Banned Pubkey Check (Critical):**
```csharp
var backups = currentMiners.Where(k => !validCandidates.Contains(k) && !State.BannedPubkeyMap[k]).ToList();
if (State.InitialMiners.Value != null)
    backups.AddRange(
        State.InitialMiners.Value.Value.Select(k => k.ToHex())
            .Where(k => !backups.Contains(k) && !State.BannedPubkeyMap[k]));
```

**Fix 2 - Replace Lexicographic Ordering with Merit-Based Selection:**
Instead of `OrderBy(p => p)`, consider:
- Order by historical vote counts from previous terms
- Order by performance metrics (block production, reliability)
- Use weighted random selection based on remaining stake
- Order by candidate announcement timestamp (first-come-first-served)

**Fix 3 - Add Minimum Vote Threshold:**
Require valid candidates to maintain a meaningful minimum vote threshold rather than just `> 0`.

**Fix 4 - Implement Backup Selection Transparency:**
Emit events indicating when miners are selected via backup mechanism vs normal voting, enabling monitoring and detection of exploitation.

## Proof of Concept

The following test demonstrates the vulnerability where a miner with a low-sorting pubkey (starting with "00000...") is systematically selected as backup over a miner with higher-sorting pubkey, and critically, can be selected even when banned:

```csharp
[Fact]
public async Task GetVictories_BannedMinerSelectedAsBackup_Test()
{
    // Setup: Initialize with insufficient valid candidates to trigger backup selection
    await InitializeElectionContract();
    
    // Create two miners: one with low-sorting vanity key, one with normal key
    var vanityMiner = "00000abcdef123456789"; // Low lexicographic value
    var normalMiner = "zzzzz123456789abcdef"; // High lexicographic value
    
    // Both become current miners
    var currentMiners = new List<string> { vanityMiner, normalMiner };
    
    // Ban the vanity miner
    await BanMiner(vanityMiner);
    
    // Create candidate shortage (diff > 0) by having no valid candidates
    var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
    
    // VULNERABILITY: Banned vanity miner is selected as backup due to:
    // 1. No check for State.BannedPubkeyMap
    // 2. Lexicographic ordering prioritizes "00000..." over "zzzzz..."
    victories.Value.ShouldContain(ByteStringHelper.FromHexString(vanityMiner));
    
    // This violates the security invariant that banned miners should never participate
}
```

## Notes

- The test suite includes explicit tests for the candidate shortage scenario (`ElectionContract_GetVictories_ValidCandidatesNotEnough_Test`), confirming this is an expected operational condition, not an edge case.
- The inconsistency between `GetVictories` and `GetMinerReplacementInformation` regarding banned pubkey checks suggests this is an implementation oversight rather than intentional design.
- The vulnerability is exacerbated when multiple attackers coordinate with similarly low-sorting vanity keys, allowing them to dominate the backup selection.
- The 100,000 ELF lock requirement provides initial barrier but becomes negligible compared to mining rewards over multiple terms if the attack succeeds.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L86-95)
```csharp
    private List<string> GetValidCandidates()
    {
        if (State.Candidates.Value == null) return new List<string>();

        return State.Candidates.Value.Value
            .Where(c => State.CandidateVotes[c.ToHex()] != null &&
                        State.CandidateVotes[c.ToHex()].ObtainedActiveVotedVotesAmount > 0)
            .Select(p => p.ToHex())
            .ToList();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L386-392)
```csharp
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-280)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** test/AElf.Contracts.Election.Tests/GQL/ElectionTests.cs (L404-444)
```csharp
    public async Task<List<string>> ElectionContract_GetVictories_ValidCandidatesNotEnough_Test()
    {
        const int amount = 100;

        await NextRound(BootMinerKeyPair);

        foreach (var keyPair in ValidationDataCenterKeyPairs) await AnnounceElectionAsync(keyPair);

        var candidates = (await ElectionContractStub.GetCandidates.CallAsync(new Empty())).Value;
        foreach (var fullNodesKeyPair in ValidationDataCenterKeyPairs)
            candidates.ShouldContain(ByteString.CopyFrom(fullNodesKeyPair.PublicKey));

        var validCandidates = ValidationDataCenterKeyPairs
            .Take(EconomicContractsTestConstants.InitialCoreDataCenterCount - 1).ToList();
        foreach (var keyPair in validCandidates)
            await VoteToCandidateAsync(VoterKeyPairs[0], keyPair.PublicKey.ToHex(), 100 * 86400, amount);

        foreach (var votedFullNodeKeyPair in ValidationDataCenterKeyPairs.Take(EconomicContractsTestConstants
                     .InitialCoreDataCenterCount - 1))
        {
            var votes = await ElectionContractStub.GetCandidateVote.CallAsync(new StringValue
                { Value = votedFullNodeKeyPair.PublicKey.ToHex() });
            votes.ObtainedActiveVotedVotesAmount.ShouldBe(amount);
        }

        foreach (var votedFullNodeKeyPair in ValidationDataCenterKeyPairs.Skip(EconomicContractsTestConstants
                     .InitialCoreDataCenterCount - 1))
        {
            var votes = await ElectionContractStub.GetCandidateVote.CallAsync(new StringValue
                { Value = votedFullNodeKeyPair.PublicKey.ToHex() });
            votes.ObtainedActiveVotedVotesAmount.ShouldBe(0);
        }

        var victories = (await ElectionContractStub.GetVictories.CallAsync(new Empty())).Value
            .Select(p => p.ToHex()).ToList();

        // Victories should contain all valid candidates.
        foreach (var validCandidate in validCandidates) victories.ShouldContain(validCandidate.PublicKey.ToHex());

        return victories;
    }
```
