### Title
Incomplete Validation Allows Malicious Miners to Bypass Behavior-Specific Checks Using NOTHING Behavior

### Summary
The `ValidateBeforeExecution` method only adds behavior-specific validation providers for UpdateValue, NextRound, and NextTerm behaviors. A malicious miner can craft a block with `NOTHING` behavior to bypass these validators while still passing the three basic checks (mining permission, time slot, continuous blocks), allowing them to produce blocks without proper consensus state updates and delay round/term transitions.

### Finding Description

The validation logic in `ValidateBeforeExecution` applies three basic validators to all blocks, but only conditionally adds behavior-specific validators based on a switch statement: [1](#0-0) 

The `AElfConsensusBehaviour` enum defines five possible values, but the switch statement only handles three: [2](#0-1) 

For `NOTHING` behavior (enum value 3), no case exists in the switch statement, meaning only the three basic validators are applied. When a block with `NOTHING` behavior is processed, `GenerateTransactionListByExtraData` returns an empty transaction list: [3](#0-2) 

The attack works because:
1. A miner crafts a block with `extraData.Behaviour = NOTHING` and `extraData.Round` set to the unchanged current round
2. `ValidateBeforeExecution` only applies basic validators (no UpdateValueValidationProvider, LibInformationValidationProvider, NextRoundMiningOrderValidationProvider, or RoundTerminateValidationProvider)
3. Empty transaction list means no consensus state updates occur
4. `ValidateConsensusAfterExecution` compares round hashes and passes since the state didn't change: [4](#0-3) 

### Impact Explanation

**Consensus Integrity Violation:**
- Miners can bypass critical validation checks designed to ensure consensus correctness
- UpdateValueValidationProvider (ensures OutValue/Signature are properly filled) is bypassed
- LibInformationValidationProvider (prevents LIB height from decreasing) is bypassed
- RoundTerminateValidationProvider (validates round/term number increments) is bypassed

**Operational DoS:**
- When a miner should produce NextRound/NextTerm but uses NOTHING instead, round/term transitions are delayed by one block
- For NextTerm transitions, critical operations are delayed: rewards distribution, treasury releases, election snapshots, and miner list updates: [5](#0-4) 

- Repeated exploitation could significantly degrade consensus performance and delay time-sensitive economic operations

**Consensus State Corruption:**
- Miners' mining actions are not recorded when they bypass UpdateValue
- This affects randomness generation, LIB calculation, and round completion tracking

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be a legitimate miner in the current round's miner list
- Must be within their assigned time slot

**Attack Complexity:**
- Trivial to execute: simply craft block header with `Behaviour = NOTHING` and include unchanged round information
- No special cryptographic knowledge or complex exploit chain required
- Can be repeated every time the malicious miner has a time slot

**Feasibility:**
- Any miner can perform this attack during their turn with minimal cost
- The attack wastes the miner's time slot but allows them to bypass validation they might otherwise fail
- Detection is difficult without analyzing the full sequence of consensus behaviors vs. expected behaviors

**Economic Rationality:**
- Low cost: miner only loses one block production opportunity
- Potential strategic benefits: delaying term transitions, avoiding OutValue revelation, causing consensus degradation

### Recommendation

**Code-Level Mitigation:**
Add explicit handling for NOTHING behavior in the switch statement to reject it or apply appropriate validation:

```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        break;
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new RoundTerminateValidationProvider());
        break;
    case AElfConsensusBehaviour.Nothing:
        // NOTHING behavior should never result in a mined block
        return new ValidationResult 
        { 
            Success = false, 
            Message = "NOTHING behavior is not valid for block production." 
        };
    // TinyBlock intentionally uses only basic validators
}
```

**Invariant Enforcement:**
- Add validation to ensure consensus behavior matches the expected behavior determined by the consensus logic
- Verify that blocks always include appropriate consensus transactions based on their declared behavior

**Test Cases:**
- Test that blocks with NOTHING behavior are rejected during validation
- Test that miners cannot bypass UpdateValueValidationProvider checks
- Test that round/term transitions cannot be delayed by NOTHING blocks
- Test that attempting to produce a block when `InvalidConsensusCommand` was returned fails validation

### Proof of Concept

**Initial State:**
- Current round number: 100
- Malicious miner is in miner list with valid time slot
- Consensus logic determines miner should produce NextRound block to transition to round 101

**Attack Steps:**
1. Malicious miner queries consensus command and receives NextRound behavior instruction
2. Instead of following the instruction, miner crafts block with:
   - `extraData.Behaviour = AElfConsensusBehaviour.Nothing` (value 3)
   - `extraData.Round = currentRound` (round 100, unchanged)
   - `extraData.SenderPubkey = minerPubkey`
3. Miner includes empty transaction list (no NextRound transaction)
4. Block passes `ValidateConsensusBeforeExecution`:
   - MiningPermissionValidationProvider: Pass (miner in list)
   - TimeSlotValidationProvider: Pass (within time slot)
   - ContinuousBlocksValidationProvider: Pass (not too many continuous blocks)
   - No additional validators applied for NOTHING
5. Block executes with no consensus transactions
6. Block passes `ValidateConsensusAfterExecution`:
   - `headerInformation.Round.GetHash() == currentRound.GetHash()` (both are round 100)
7. Block is accepted into chain

**Expected Result:**
Block should be rejected for using invalid NOTHING behavior when NextRound is required

**Actual Result:**
Block is accepted, round transition to 101 is delayed until next miner produces NextRound block

**Success Condition:**
Round number remains 100 after malicious block instead of advancing to 101, demonstrating successful bypass of RoundTerminateValidationProvider checks

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-92)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** protobuf/aedpos_contract.proto (L321-327)
```text
enum AElfConsensusBehaviour {
    UPDATE_VALUE = 0;
    NEXT_ROUND = 1;
    NEXT_TERM = 2;
    NOTHING = 3;
    TINY_BLOCK = 4;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L135-182)
```csharp
        switch (behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                Context.LogDebug(() =>
                    $"Previous in value in extra data:{round.RealTimeMinersInformation[pubkey.ToHex()].PreviousInValue}");
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
                };
            case AElfConsensusBehaviour.TinyBlock:
                var minerInRound = round.RealTimeMinersInformation[pubkey.ToHex()];
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(UpdateTinyBlockInformation),
                            new TinyBlockInput
                            {
                                ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
                                ProducedBlocks = minerInRound.ProducedBlocks,
                                RoundId = round.RoundIdForValidation,
                                RandomNumber = randomNumber
                            })
                    }
                };
            case AElfConsensusBehaviour.NextRound:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextRound), NextRoundInput.Create(round,randomNumber))
                    }
                };
            case AElfConsensusBehaviour.NextTerm:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextTerm), NextTermInput.Create(round,randomNumber))
                    }
                };
            default:
                return new TransactionList();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```
