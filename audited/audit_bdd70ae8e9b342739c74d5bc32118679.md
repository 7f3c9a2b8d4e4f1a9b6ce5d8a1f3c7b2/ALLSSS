### Title
Round 1 Time Slot Ordering Bypass via Block Timestamp Manipulation

### Summary
The `IsTimeSlotPassed()` function in Round 1 calculates expected miner order based on elapsed time from the first miner's actual mining timestamp. A malicious first miner can set their block timestamp up to 4 seconds in the future (within `AllowedFutureBlockTimeSpan`), causing negative or minimal `runningTime` calculations for subsequent miners. This incorrectly prevents later miners' time slots from being marked as passed, breaking the time-slot ordering mechanism and allowing early miners to monopolize block production in Round 1.

### Finding Description

The vulnerability exists in the Round 1-specific logic of `IsTimeSlotPassed()`: [1](#0-0) 

When `RoundNumber == 1`, the function calculates `expectedOrder` by:
1. Retrieving `actualStartTime` from the first miner's recorded `ActualMiningTimes`
2. Computing `runningTime = currentBlockTime - actualStartTime`
3. Deriving `expectedOrder = floor(runningTime.Seconds / intervalSeconds) + 1`

**Root Cause**: The `actualStartTime` is recorded from a previous block's `BlockHeader.Time`, which the block producer controls. Block timestamps can be set up to 4 seconds in the future relative to real UTC time: [2](#0-1) [3](#0-2) 

When subsequent miners call `GetConsensusCommand`, the system sets `Context.CurrentBlockTime` to real UTC: [4](#0-3) 

However, during block execution, `ActualMiningTime` is recorded as `Context.CurrentBlockTime` from the block being produced: [5](#0-4) [6](#0-5) 

**Why Protections Fail**: The future time validation only ensures blocks aren't more than 4 seconds ahead of UTC. It doesn't prevent the `runningTime` calculation from becoming negative when comparing a future-dated `actualStartTime` against a current UTC-based `currentBlockTime`. There is no check for negative `runningTime` values.

**Execution Path**:
1. First miner produces block with `BlockHeader.Time = UTC + 4`
2. This timestamp is stored as their `ActualMiningTime` in state
3. Subsequent miners call `GetConsensusCommand` with `currentBlockTime = realUTC` (which may be < actualStartTime)
4. `runningTime` becomes negative or minimal, causing `expectedOrder` to be incorrectly low (0 or 1)
5. Miners whose slots should have passed (order >= 2) are not marked as passed
6. The behavior provider grants them `UpdateValue` or `TinyBlock` behavior instead of `Nothing`: [7](#0-6) [8](#0-7) 

### Impact Explanation

**Concrete Harm**:
- **Consensus Time-Slot Integrity Violation**: The ordered time-slot mechanism in Round 1 breaks down. Miners whose designated time slots have passed in real time are not correctly identified, violating the fundamental AEDPoS time-slot ordering invariant.
- **Block Production Monopolization**: Early miners (orders 1-2) can continue producing blocks beyond their allocated slots for up to 4 seconds of real time, as their slots won't be marked as passed.
- **Mining Opportunity Denial**: Later miners (orders 3+) may be denied their rightful mining opportunities during the affected window, as the system incorrectly determines their slots haven't arrived yet.

**Affected Parties**: All miners in Round 1 of any term are affected. Later-order miners lose mining opportunities and associated rewards, while early-order miners can produce additional blocks.

**Severity Justification**: While limited to Round 1, this is a **High severity** issue because:
1. It breaks a critical consensus invariant (time-slot ordering)
2. It's trivially exploitable by any first miner
3. Round 1 occurs at every term transition, making it repeatedly exploitable
4. It directly impacts mining rewards and consensus fairness

### Likelihood Explanation

**Attacker Capabilities**: Any miner selected as first miner in Round 1 can execute this attack. No special privileges or resources required beyond normal block production capabilities.

**Attack Complexity**: Trivial - the miner simply sets their `BlockHeader.Time` to the maximum allowed value (`UTC + 4 seconds`) when producing their block. This is a standard field they control during block production.

**Feasibility Conditions**:
- Attacker must be the first miner in Round 1
- Round 1 occurs at the start of each term
- No special network conditions or timing precision required

**Detection Constraints**: The manipulated timestamp is within valid bounds, making it indistinguishable from legitimate clock variations. The attack leaves no obvious on-chain signature beyond extended block production by early miners.

**Probability**: High - the attack opportunity occurs predictably at every term start, and execution is guaranteed to succeed given the lack of validation for negative `runningTime`.

### Recommendation

**Immediate Fix**: Add validation to ensure `actualStartTime` is not in the future relative to `currentBlockTime`:

```csharp
public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
{
    var miningInterval = GetMiningInterval();
    if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
    var minerInRound = RealTimeMinersInformation[publicKey];
    if (RoundNumber != 1)
        return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
               currentBlockTime;

    var actualStartTimes = FirstMiner().ActualMiningTimes;
    if (actualStartTimes.Count == 0) return false;

    var actualStartTime = actualStartTimes.First();
    var runningTime = currentBlockTime - actualStartTime;
    
    // NEW: Ensure actualStartTime is not in the future
    if (runningTime.Seconds < 0)
    {
        // If actualStartTime is in the future, no slots have passed yet
        return false;
    }
    
    var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
    return minerInRound.Order < expectedOrder;
}
```

**Invariant Checks to Add**:
1. Validate that `ActualMiningTime` values are not excessively ahead of consensus command generation time
2. Consider tightening `AllowedFutureBlockTimeSpan` or adding Round 1-specific timestamp validation
3. Add assertion that `runningTime >= 0` before expectedOrder calculation

**Test Cases**:
1. Test Round 1 with first miner setting maximum future timestamp
2. Verify subsequent miners' `IsTimeSlotPassed` correctly handles future `actualStartTime`
3. Test boundary: actualStartTime exactly at currentBlockTime
4. Test that expected order doesn't advance until real time catches up to manipulated timestamp

### Proof of Concept

**Initial State**:
- Round 1 with 4 miners (orders 1-4)
- Mining interval: 4000ms (4 seconds)
- Real UTC time: T seconds

**Attack Sequence**:

1. **T=100**: Miner 1 (order 1) produces block
   - Sets `BlockHeader.Time = 104` (T + 4 seconds, maximum allowed)
   - Block validated (within `AllowedFutureBlockTimeSpan`)
   - `ActualMiningTime[Miner1] = 104` stored in state

2. **T=101**: Miner 2 (order 2) calls `GetConsensusCommand`
   - `currentBlockTime = 101` (real UTC)
   - `actualStartTime = 104`
   - `runningTime = 101 - 104 = -3 seconds`
   - `expectedOrder = floor(-3 / 4) + 1 = 0 + 1 = 1` (or 0 depending on division behavior)
   - Check: `order(2) < expectedOrder(1)` → FALSE
   - **Result**: Miner 2's slot incorrectly NOT marked as passed
   - Miner 2 gets `UpdateValue` behavior and produces block

3. **T=104**: Miner 3 (order 3) calls `GetConsensusCommand`
   - `currentBlockTime = 104` (real UTC)
   - `actualStartTime = 104`
   - `runningTime = 0 seconds`
   - `expectedOrder = floor(0 / 4) + 1 = 1`
   - Check: `order(3) < expectedOrder(1)` → FALSE
   - **Result**: Miner 3's slot incorrectly NOT marked as passed

4. **T=108**: Real UTC catches up
   - `runningTime = 108 - 104 = 4 seconds`
   - `expectedOrder = floor(4 / 4) + 1 = 2`
   - Now only order 1 miners marked as passed

**Expected vs Actual**:
- **Expected**: At real time T=101, Miner 1's slot should be passed (order < 2); at T=105, orders 1-2 passed; at T=109, orders 1-3 passed
- **Actual**: Time slot progression delayed by ~4 seconds, allowing early miners to extend their mining window and denying later miners their opportunities

**Success Condition**: The attack succeeds when `IsTimeSlotPassed()` returns false for miners whose real-time slots have elapsed, provable by comparing `currentBlockTime` (real UTC) against expected slot boundaries versus the function's returned value.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L92-98)
```csharp
        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
```

**File:** src/AElf.Kernel.Types/KernelConstants.cs (L19-19)
```csharp
    public static Duration AllowedFutureBlockTimeSpan = new() { Seconds = 4 };
```

**File:** src/AElf.Kernel.Core/Blockchain/Application/IBlockValidationProvider.cs (L133-139)
```csharp
        if (block.Header.Height != AElfConstants.GenesisBlockHeight &&
            block.Header.Time.ToDateTime() - TimestampHelper.GetUtcNow().ToDateTime() >
            KernelConstants.AllowedFutureBlockTimeSpan.ToTimeSpan())
        {
            Logger.LogDebug("Future block received {Block}, {BlockTime}", block, block.Header.Time.ToDateTime());
            return Task.FromResult(false);
        }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L61-62)
```csharp
        var now = TimestampHelper.GetUtcNow();
        _blockTimeProvider.SetBlockTime(now, chainContext.BlockHash);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L62-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L66-66)
```csharp
                    CurrentBlockTime = transactionExecutingDto.BlockHeader.Time,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L57-62)
```csharp
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L114-114)
```csharp
            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
```
