### Title
Front-Running Attack on ProposeNewContract Enables Contract Deployment Denial-of-Service

### Summary
An attacker can predict the `proposedContractInputHash` for a legitimate contract deployment and front-run the proposal submission, effectively blocking the legitimate deployer from proposing the same contract for up to 3 days. The vulnerability arises because the hash is deterministically computed from public parameters, and the system allows only one active proposal per hash while restricting release rights to the original proposer.

### Finding Description

The vulnerability exists in the contract proposal workflow with the following components:

**1. Predictable Hash Calculation:**
The `proposedContractInputHash` is computed deterministically from the `ContractDeploymentInput` using `CalculateHashFromInput()`, which simply calls `HashHelper.ComputeFrom(input)`. [1](#0-0) [2](#0-1) 

The input contains only the contract category, bytecode, and optional contract operation - all of which can be known or predicted for public/standard contracts. [3](#0-2) 

**2. Duplicate Proposal Prevention:**
The `RegisterContractProposingData()` function prevents duplicate proposals for the same hash, but does NOT verify that the caller is authorized or that this is a legitimate first proposal. It only checks if a proposal already exists and hasn't expired: [4](#0-3) 

**3. Proposer-Locked Release:**
The `ReleaseApprovedContract()` function enforces that only the original proposer can release an approved contract, giving exclusive control to whoever submitted the proposal first: [5](#0-4) 

**4. No Authorization Check:**
The commented-out proposer authority check means anyone can call `ProposeNewContract()`: [6](#0-5) 

**5. Long Expiration Period:**
The default expiration is 259,200 seconds (72 hours), providing a substantial denial-of-service window: [7](#0-6) 

**Root Cause:** The system treats the contract deployment input hash as a unique identifier for a single proposal, but fails to prevent malicious actors from claiming that identifier first, even when they have no legitimate interest in deploying the contract.

### Impact Explanation

**Primary Impact:** Denial-of-Service on contract deployment for 3 days (default) per attack.

**Affected Parties:**
- Legitimate contract deployers attempting to deploy standard/public contracts
- Projects with predictable deployment schedules
- Open-source contracts being deployed by community members

**Attack Scenario:**
1. Attacker monitors mempool or predicts contract deployments (e.g., standard token contracts, public protocol upgrades)
2. Attacker front-runs by calling `ProposeNewContract()` with identical deployment parameters
3. Legitimate deployer's transaction reverts with "Already proposed."
4. Even if the deployment controller approves the proposal, only the attacker can call `ReleaseApprovedContract()`
5. If attacker abandons the proposal, deployment is blocked for 3 days

**Severity Justification:** Medium severity due to:
- Operational DoS impact blocking critical contract deployments
- Griefing potential against competitors or protocol launches
- No direct fund theft but significant business disruption
- Mitigated by optional `ContractOperation` signature, but not enforced

### Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to front-run transactions (standard blockchain capability)
- Knowledge of deployment parameters (feasible for public/standard contracts)
- Gas fees for proposal submission (low economic cost)

**Attack Complexity:** Low
- Single transaction to execute attack
- No complex setup or state manipulation required
- Deterministic hash calculation makes prediction trivial

**Feasibility Conditions:**
- Target contract code is known or predictable (public contracts, standard implementations)
- Contract deployment does NOT use `ContractOperation` with signature verification
- Attacker has mempool monitoring or advance knowledge of deployment timing

**Detection/Mitigation Constraints:**
- No on-chain mechanism to cancel malicious proposals before expiration
- No cleanup function for expired proposals (unlike Parliament/Association contracts)
- Legitimate deployer must wait full expiration period or use different deployment parameters

**Probability Assessment:** Medium-High for public contracts, Low for contracts using `ContractOperation` signatures. The attack is economically rational for competitors seeking to delay protocol launches or standard deployments.

### Recommendation

**Immediate Mitigations:**

1. **Add Proposer Whitelist Check:** Uncomment and implement the proposer authority check to restrict who can propose contracts: [6](#0-5) 

2. **Implement Proposal Cancellation:** Add a function allowing the deployment controller or proposer to cancel proposals, similar to the Parliament contract's `ClearProposal` mechanism.

3. **Add Multi-Proposer Support:** Modify the system to allow multiple independent proposals for the same contract hash, tracked by (hash, proposer) composite key instead of just hash.

4. **Enforce ContractOperation:** For non-system contracts, require `ContractOperation` with signature verification to prevent parameter replication: [8](#0-7) 

5. **Add Cleanup Function:** Implement a public function to remove expired proposals from `ContractProposingInputMap`:
```
public override Empty ClearExpiredProposal(Hash proposedContractInputHash)
{
    var proposalInfo = State.ContractProposingInputMap[proposedContractInputHash];
    Assert(proposalInfo != null && Context.CurrentBlockTime >= proposalInfo.ExpiredTime, 
        "Proposal not expired.");
    State.ContractProposingInputMap.Remove(proposedContractInputHash);
    return new Empty();
}
```

**Test Cases:**
- Verify two users cannot propose identical contract deployments simultaneously
- Test that expired proposals can be cleaned up
- Validate that proposer authority checks prevent unauthorized proposals
- Confirm that ContractOperation signatures prevent parameter replication

### Proof of Concept

**Initial State:**
- Genesis contract deployed and initialized
- Contract deployment controller configured
- Legitimate user prepares to deploy a standard ERC20-like token contract

**Attack Steps:**

1. **Attacker Monitors:** Attacker observes pending deployment transaction in mempool or predicts standard contract deployment

2. **Attacker Front-runs:** Attacker submits transaction calling `ProposeNewContract()` with:
   - `category`: 0 (C# contract)
   - `code`: [identical bytecode]
   - `contract_operation`: null (no signature)

3. **Attack Transaction Executes First:** Due to higher gas price or block position, attacker's proposal is processed first, creating entry in `State.ContractProposingInputMap[hash]` with attacker as proposer

4. **Legitimate User Transaction Fails:** Legitimate user's identical `ProposeNewContract()` call reverts at `RegisterContractProposingData()` with assertion: "Already proposed." [9](#0-8) 

5. **Deployment Blocked:** Even if deployment controller approves the proposal, only attacker can call `ReleaseApprovedContract()` due to proposer check: [10](#0-9) 

6. **DoS Persists:** If attacker abandons proposal, legitimate deployer must wait 259,200 seconds (3 days) for expiration before retrying

**Expected vs Actual Result:**
- **Expected:** Legitimate user successfully proposes contract deployment
- **Actual:** Legitimate user's transaction fails; deployment blocked for 3 days

**Success Condition:** Attacker successfully prevents legitimate contract deployment for the expiration period with minimal cost (gas fees only)

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L124-124)
```csharp
        // AssertDeploymentProposerAuthority(Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L127-127)
```csharp
        var proposedContractInputHash = CalculateHashFromInput(input);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L132-140)
```csharp
        if (input.ContractOperation != null)
        {
            ValidateContractOperation(input.ContractOperation, 0, codeHash);
            
            // Remove one time signer if exists. Signer is only needed for validating signature.
            RemoveOneTimeSigner(input.ContractOperation.Deployer);
            
            AssertContractAddressAvailable(input.ContractOperation.Deployer, input.ContractOperation.Salt);
        }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L277-290)
```csharp
    public override Empty ReleaseApprovedContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];
        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.Proposed &&
            contractProposingInput.Proposer == Context.Sender, "Invalid contract proposing status.");
        contractProposingInput.Status = ContractProposingInputStatus.Approved;
        State.ContractProposingInputMap[input.ProposedContractInputHash] = contractProposingInput;
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release),
            input.ProposalId.ToByteString());
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L175-178)
```csharp
    private Hash CalculateHashFromInput(IMessage input)
    {
        return HashHelper.ComputeFrom(input);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** protobuf/acs0.proto (L156-162)
```text
message ContractDeploymentInput {
    // The category of contract code(0: C#).
    sint32 category = 1;
    // The byte array of the contract code.
    bytes code = 2;
    ContractOperation contract_operation = 3;
}
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L5-5)
```csharp
    public const int ContractProposalExpirationTimePeriod = 259200; // 60 * 60 * 72
```
