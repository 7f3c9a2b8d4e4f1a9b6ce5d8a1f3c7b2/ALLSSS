### Title
Missing Amount Validation in Vote Contract Allows Negative Vote Manipulation in Delegated Voting

### Summary
The `Vote()` function in VoteContract.cs accepts a signed `int64` amount without validation, allowing negative values in delegated voting mode (IsLockToken=false). While token-locked voting is protected by the TokenContract's validation, delegated voting bypasses this check, enabling sponsors to manipulate vote totals downward and corrupt voting results.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:** At line 96, the Vote() function directly assigns `amount = input.Amount` for non-quadratic voting without validating that the amount is positive. The `input.Amount` field is defined as `int64` in the protobuf definition, which is a signed type that accepts negative values: [2](#0-1) 

**Why Existing Protections Fail:**

For token-locked voting (IsLockToken=true), the TokenContract.Lock call provides protection by validating `amount > 0`: [3](#0-2) 

However, for delegated voting (IsLockToken=false), no Lock call is made, bypassing this validation: [4](#0-3) 

The input validation function `AssertValidVoteInput` checks option validity and snapshot state but does NOT validate the amount: [5](#0-4) 

**Execution Path:**
1. Attacker registers a voting item with `IsLockToken=false`, becoming the Sponsor
2. In delegated mode, only the Sponsor can call Vote(): [6](#0-5) 
3. Sponsor calls Vote() with negative amount (e.g., -100)
4. UpdateVotingResult adds the negative amount to vote totals: [7](#0-6) 
5. Vote totals are reduced or become negative via SafeMath.Add() which accepts negative operands: [8](#0-7) 

### Impact Explanation

**Concrete Harm:**
- Vote totals for options can be artificially reduced or made negative
- VotesAmount and votersCount accounting becomes corrupted
- Voting records store negative amounts, causing withdrawal issues (Sub operation on negative values adds instead of subtracts): [9](#0-8) 

**Affected Parties:**
- Users who participate in or rely on manipulated voting items
- Contracts that query voting results for decision-making
- System integrity of the voting mechanism

**Severity:** Medium - While the attacker can only manipulate voting items they create as Sponsor, this corrupts vote result integrity and could mislead users or dependent contracts. The vulnerability doesn't affect existing legitimate voting items but undermines trust in the voting system.

### Likelihood Explanation

**Attacker Capabilities:**
- Any address can register a voting item and become its Sponsor
- Sponsor has unrestricted ability to call Vote() for delegated voting items
- No cost to execute beyond transaction fees

**Attack Complexity:** Low - Single transaction with negative amount parameter

**Feasibility Conditions:**
- Only works for delegated voting (IsLockToken=false)
- Attacker must be the Sponsor (achievable by creating own voting item)
- Other users must interact with the compromised voting item for meaningful impact

**Detection:** Vote manipulation would be visible in on-chain events and voting results, but may not be immediately obvious as malicious

**Probability:** Medium - Straightforward to execute but limited to self-created voting items, reducing real-world impact

### Recommendation

**Code-Level Mitigation:**
Add amount validation in the Vote() function before line 96:

```csharp
Assert(input.Amount > 0, "Invalid voting amount.");
```

Or add validation in AssertValidVoteInput for non-quadratic voting:

```csharp
if (!votingItem.IsQuadratic)
{
    Assert(input.Amount > 0, "Vote amount must be positive.");
}
```

**Invariant Checks:**
- Enforce `amount > 0` for all vote operations
- Ensure VotesAmount and vote totals cannot become negative
- Validate amounts consistently across Vote() and Withdraw() operations

**Test Cases:**
Add regression tests for negative amount rejection (currently no such tests exist): [10](#0-9) 

### Proof of Concept

**Initial State:**
- Attacker has an address with transaction fee tokens
- No existing voting items required

**Attack Steps:**
1. Attacker registers a delegated voting item (IsLockToken=false) via Register(), becoming the Sponsor
2. Attacker calls Vote() with VoteInput { VotingItemId, Voter: someAddress, VoteId: someHash, Amount: -100, Option: "A" }
3. Transaction succeeds (no validation rejects negative amount)
4. Query GetVotingResult shows Results["A"] has been reduced by 100
5. VotesAmount is reduced by 100 (potentially negative)

**Expected vs Actual:**
- Expected: Transaction should fail with "Invalid amount" error
- Actual: Transaction succeeds, vote totals manipulated downward

**Success Condition:** VotingResult.Results["A"] < initial value despite "voting" action, or VotingResult.VotesAmount becomes negative

### Notes

Token-locked voting (IsLockToken=true, the more common case) is protected by TokenContract.Lock's amount validation. Only delegated voting is vulnerable. The vulnerability stems from inconsistent validation between the two voting modes and reliance on external contract validation rather than input validation at the entry point.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L90-96)
```csharp
    public override Empty Vote(VoteInput input)
    {
        var votingItem = AssertValidVoteInput(input);
        var amount = 0L;
        if (!votingItem.IsQuadratic)
        {
            amount = input.Amount;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L122-130)
```csharp
        if (votingItem.IsLockToken)
            // Lock voted token.
            State.TokenContract.Lock.Send(new LockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                LockId = input.VoteId,
                Amount = amount
            });
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L214-220)
```csharp
        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** protobuf/vote_contract.proto (L135-148)
```text
message VoteInput {
    // The voting activity id.
    aelf.Hash voting_item_id = 1;
    // The address of voter.
    aelf.Address voter = 2;
    // The amount of vote.
    int64 amount = 3;
    // The option to vote.
    string option = 4;
    // The vote id.
    aelf.Hash vote_id = 5;
    // Whether vote others.
    bool is_change_target = 6;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L100-106)
```csharp
    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```

**File:** test/AElf.Contracts.Vote.Tests/VoteContractTestHelper.cs (L90-110)
```csharp
    private async Task<TransactionResult> Vote(ECKeyPair voterKeyPair, Hash votingItemId, string option,
        long amount)
    {
        return (await GetVoteContractTester(voterKeyPair).Vote.SendAsync(new VoteInput
        {
            VotingItemId = votingItemId,
            Option = option,
            Amount = amount
        })).TransactionResult;
    }

    private async Task<TransactionResult> VoteWithException(ECKeyPair voterKeyPair, Hash votingItemId, string option,
        long amount)
    {
        return (await GetVoteContractTester(voterKeyPair).Vote.SendWithExceptionAsync(new VoteInput
        {
            VotingItemId = votingItemId,
            Option = option,
            Amount = amount
        })).TransactionResult;
    }
```
