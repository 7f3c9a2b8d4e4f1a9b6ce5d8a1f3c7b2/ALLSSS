### Title
Stale Resource Path Cache Causes Incorrect Parallel Execution Grouping and Contract Blacklisting

### Summary
The `ResourceExtractionService` caches `GetResourceInfo` results using only the transaction hash as the cache key, without considering chain context or state versions. When the TokenContract's `GetResourceInfo` reads mutable state variables to determine resource paths, and these state values change between cache population and reuse, the cached paths become stale. This causes transactions to access state paths not declared in their cached ResourceInfo, triggering conflict detection that incorrectly marks the TokenContract as non-parallelizable, degrading system throughput.

### Finding Description

**Root Cause - State-Dependent Path Calculation Without State Versioning:**

The TokenContract's `GetResourceInfo` implementation reads mutable state to determine which resource paths to declare: [1](#0-0) 

Specifically:
1. Line 150 reads `State.TransactionFeeFreeAllowancesSymbolList.Value` to determine which symbols' paths to add
2. Lines 137-138 read `State.TransactionFeeDelegateInfoMap` and `State.TransactionFeeDelegateesMap` to determine delegatee paths
3. Line 87 reads the primary token symbol

These state variables can be modified by contract methods: [2](#0-1) [3](#0-2) 

**Caching Mechanism Without State Versioning:**

The `ResourceExtractionService` caches GetResourceInfo results using only the transaction hash: [4](#0-3) [5](#0-4) 

The cache is populated when transactions are accepted into the pool: [6](#0-5) 

**Cache Persistence Across State Changes:**

The cache persists until the transaction is included in a block or expires: [7](#0-6) 

During this time, state can change through governance operations, but the cached ResourceInfo remains unchanged.

**Conflict Detection Triggers Blacklisting:**

When a transaction executes with different state than when GetResourceInfo was called, it accesses paths not declared in the cached ResourceInfo. The conflict detection service identifies this mismatch: [8](#0-7) 

The contract is then marked as non-parallelizable: [9](#0-8) 

### Impact Explanation

**Operational DoS - Parallel Execution Degradation:**

1. **Direct Impact**: The TokenContract (and potentially other ACS2-compliant contracts with state-dependent path calculation) can be incorrectly marked as non-parallelizable, forcing all future transactions to execute sequentially instead of in parallel groups.

2. **System-Wide Throughput Loss**: The TokenContract handles critical operations (transfers, fee payments, staking). Sequential execution of all token transactions drastically reduces blockchain throughput from potentially hundreds of parallel transactions per block to a single sequential queue.

3. **Persistent Degradation**: Once marked non-parallelizable, the contract remains blacklisted for subsequent blocks until contract code changes, causing sustained performance degradation.

4. **Affected Parties**: All users attempting token operations experience slower transaction confirmation times. Validators and DApp operators see reduced system capacity.

**Severity Justification**: While this doesn't result in fund theft, the operational impact is severe - legitimate parallel execution capability is disabled through a race condition between cache population and state updates, requiring no attacker intervention beyond normal protocol operations.

### Likelihood Explanation

**High Likelihood - Natural Protocol Operations:**

1. **Reachable Entry Point**: The vulnerability is triggered through normal protocol flows:
   - Any user submitting a token transaction populates the cache
   - Governance/admin calling `ConfigTransactionFeeFreeAllowances` or `SetTransactionFeeDelegateInfos` modifies the state
   - Transaction remains in pool during state change

2. **Feasible Preconditions**: 
   - No attacker required - occurs naturally when:
     * Transaction is accepted into pool (automatic)
     * Governance updates fee-free allowances or delegation settings (routine operations)
     * Transaction processes in a later block (common with network congestion)
   - Time window: Transactions can persist in pool for multiple blocks before inclusion

3. **Execution Practicality**: 
   - Scenario executes under normal AElf semantics
   - No special privileges needed beyond governance authority for state updates (legitimate operations)
   - Cache mechanism operates as designed - the bug is in the design itself

4. **Economic Rationality**: Zero cost to trigger - happens incidentally through normal governance operations

5. **Detection Probability**: Low - appears as legitimate conflict detection; operators may not realize the root cause is stale cache

**Probability Assessment**: Medium-High. In active chains with regular governance operations updating fee configurations or delegation settings, this will occur periodically whenever such updates happen while token transactions are pending in the pool.

### Recommendation

**1. Include Chain Context in Cache Key:**

Modify the cache key to include block hash or block height:

```csharp
// In ResourceExtractionService.cs
private readonly ConcurrentDictionary<(Hash txHash, Hash blockHash), TransactionResourceCache> _resourceCache;

// Update cache lookups to include chainContext.BlockHash
if (_resourceCache.TryGetValue((transaction.GetHash(), chainContext.BlockHash), out var resourceCache))
```

**2. Invalidate Cache on State Changes:**

Publish events when `TransactionFeeFreeAllowancesSymbolList`, `TransactionFeeDelegateInfoMap`, or `TransactionFeeDelegateesMap` are modified, and clear affected transaction caches.

**3. Add State Version to ResourceInfo:**

Include a state version or merkle root in the ResourceInfo structure to detect when cached paths are stale:

```csharp
public class TransactionResourceInfo {
    // ... existing fields
    public Hash StateVersion { get; set; }  // State root when paths were calculated
}
```

**4. Test Cases:**

Add integration tests verifying:
- Transaction cached at block N with state S1
- State modified at block N+1 to S2
- Transaction grouped at block N+1 uses S2, not cached S1 paths
- No false conflict detection occurs

### Proof of Concept

**Initial State:**
- Block height: 1000
- `State.TransactionFeeFreeAllowancesSymbolList.Value.Symbols` = ["ELF"]
- Token transaction TX1 (Transfer 100 ELF) in mempool

**Attack Sequence:**

1. **Block 1000 - Transaction Acceptance:**
   - TX1 is validated and accepted into transaction pool
   - `TransactionAcceptedEvent` fires
   - `HandleTransactionAcceptedEvent` executes GetResourceInfo with chainContext (height=1000, hash=block999)
   - `AddPathForTransactionFeeFreeAllowance` reads `TransactionFeeFreeAllowancesSymbolList` containing ["ELF"]
   - ResourceInfo declares paths only for "ELF" fee-free allowances
   - Result cached with key = TX1.Hash

2. **Block 1001 - State Update:**
   - Governance transaction calls `ConfigTransactionFeeFreeAllowances` adding "USDT" to the list
   - `State.TransactionFeeFreeAllowancesSymbolList.Value.Symbols` = ["ELF", "USDT"]
   - TX1 remains in mempool

3. **Block 1002 - Transaction Grouping:**
   - Block producer begins building block 1002
   - `TransactionGrouper.GroupAsync` called with chainContext (height=1002, hash=block1001)
   - `GetResourcesForOneAsync` invoked for TX1
   - Cache hit at line 155-158 returns stale ResourceInfo from block 1000
   - TX1 grouped based on paths declared at height 1000 (ELF only)

4. **Block 1002 - Transaction Execution:**
   - TX1 executes with chainContext (height=1002)
   - `AddPathForTransactionFeeFreeAllowance` reads current `TransactionFeeFreeAllowancesSymbolList` containing ["ELF", "USDT"]
   - Adds paths for both "ELF" and "USDT" to WritePaths
   - Actual state accesses include USDT-related paths not declared in cached ResourceInfo

5. **Conflict Detection:**
   - `ConflictingTransactionIdentificationService.IdentifyConflictingTransactionsAsync` compares:
     * Extracted (cached): paths for ELF only
     * Actual: paths for ELF + USDT
   - `actual.ExceptWith(extracted)` leaves non-empty set (USDT paths)
   - TX1 marked as having wrong resource declarations
   - TokenContract marked non-parallelizable in `SetNonparallelContractCodeAsync`

**Expected Result:** TX1 should execute successfully with correct path declarations

**Actual Result:** TX1 triggers conflict detection, and TokenContract is blacklisted from parallel execution

**Success Condition:** Verify that `_nonparallelContractCodeProvider` contains TokenContract address after this sequence, confirming the contract has been incorrectly marked non-parallelizable due to stale cache.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L148-167)
```csharp
    private void AddPathForTransactionFeeFreeAllowance(ResourceInfo resourceInfo, Address from)
    {
        var symbols = State.TransactionFeeFreeAllowancesSymbolList.Value?.Symbols;
        if (symbols != null)
        {
            foreach (var symbol in symbols)
            {
                resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.TransactionFeeFreeAllowances),
                    from.ToBase58(), symbol));
                resourceInfo.WritePaths.Add(GetPath(
                    nameof(TokenContractState.TransactionFeeFreeAllowancesLastRefreshTimes), from.ToBase58(), symbol));

                var path = GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesConfigMap), symbol);
                if (!resourceInfo.ReadPaths.Contains(path))
                {
                    resourceInfo.ReadPaths.Add(path);
                }
            }
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1259-1262)
```csharp
            if (!State.TransactionFeeFreeAllowancesSymbolList.Value.Symbols.Contains(allowances.Symbol))
            {
                State.TransactionFeeFreeAllowancesSymbolList.Value.Symbols.Add(allowances.Symbol);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L244-245)
```csharp
            State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
                [delegateInfo.MethodName] = existDelegateeInfoList;
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/ResourceExtractionService.cs (L101-110)
```csharp
        if (_resourceCache.TryGetValue(transaction.GetHash(), out var resourceCache))
            if (contractResourceInfoCache.TryGetValue(transaction.To, out var contractResourceInfo))
                if (resourceCache.ResourceInfo.ContractHash == contractResourceInfo.CodeHash &&
                    resourceCache.ResourceInfo.IsNonparallelContractCode ==
                    contractResourceInfo.IsNonparallelContractCode)
                    return new TransactionWithResourceInfo
                    {
                        Transaction = transaction,
                        TransactionResourceInfo = resourceCache.ResourceInfo
                    };
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/ResourceExtractionService.cs (L155-158)
```csharp
            if (_resourceCache.TryGetValue(transaction.GetHash(), out var resourceCache) &&
                executive.ContractHash == resourceCache.ResourceInfo.ContractHash &&
                resourceCache.ResourceInfo.IsNonparallelContractCode == false)
                return resourceCache.ResourceInfo;
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/ResourceExtractionService.cs (L218-227)
```csharp
    public async Task HandleTransactionAcceptedEvent(TransactionAcceptedEvent eventData)
    {
        var chainContext = await GetChainContextAsync();
        var transaction = eventData.Transaction;

        var resourceInfo = await GetResourcesForOneAsync(chainContext, transaction, CancellationToken.None);
        _resourceCache.TryAdd(transaction.GetHash(),
            new TransactionResourceCache(resourceInfo, transaction.To,
                eventData.Transaction.GetExpiryBlockNumber()));
    }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/ResourceExtractionService.cs (L246-251)
```csharp
    public async Task HandleBlockAcceptedAsync(BlockAcceptedEvent eventData)
    {
        ClearResourceCache(eventData.Block.TransactionIds);

        await Task.CompletedTask;
    }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/ConflictingTransactionIdentificationService.cs (L63-70)
```csharp
            var extracted = new HashSet<string>(txnWithResource.TransactionResourceInfo.WritePaths
                .Concat(txnWithResource.TransactionResourceInfo.ReadPaths).Select(p => p.ToStateKey()));
            extracted.ExceptWith(readOnlyKeys);
            var actual = GetKeys(returnSetLookup[txnWithResource.Transaction.GetHash()]);
            actual.ExceptWith(extracted);
            if (actual.Count == 0) continue;
            Logger.LogDebug($"Conflict keys:{string.Join(";", actual)}");
            wrongTxnWithResources.Add(txnWithResource);
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Application/ConflictingTransactionsFoundInParallelGroupsEventHandler.cs (L39-49)
```csharp
        var dic = wrongTxWithResources.GroupBy(t => t.Transaction.To)
            .ToDictionary(g => g.Key, g => new NonparallelContractCode
            {
                CodeHash = g.First().TransactionResourceInfo.ContractHash
            });

        await _nonparallelContractCodeProvider.SetNonparallelContractCodeAsync(new BlockIndex
        {
            BlockHash = eventData.BlockHeader.GetHash(),
            BlockHeight = eventData.BlockHeader.Height
        }, dic);
```
