# Audit Report

## Title
Unauthorized Manager Assignment in CreateScheme Enables Unbounded List Growth DoS Attack

## Summary
The `CreateScheme` function in the Profit contract lacks authorization validation when accepting a manager parameter, allowing any attacker to create unlimited profit schemes with an arbitrary victim address as the manager. This causes unbounded growth of the victim's `ManagingSchemeIds` list, resulting in gas exhaustion DoS on critical operations like `ResetManager` and view function failures on `GetManagingSchemeIds`.

## Finding Description

The root cause is the absence of authorization validation in the `CreateScheme` function. The function accepts any address as the scheme manager without verifying that the caller (`Context.Sender`) has permission from the specified manager address. [1](#0-0) 

The manager parameter is either taken from the input or defaults to `Context.Sender`, but there is no check to ensure `Context.Sender` has authorization to assign schemes to `input.Manager` when it differs from the caller's address.

Each created scheme ID is unconditionally added to the manager's scheme list: [2](#0-1) 

The only validation performed is a duplicate scheme ID check, which an attacker can trivially bypass by providing unique `Token` values in the input. When a token is provided, the scheme ID generation becomes deterministic based on that token: [3](#0-2) 

The protobuf definition confirms the `Token` parameter exists specifically for scheme ID generation: [4](#0-3) 

**Attack Execution Path:**
1. Attacker calls `CreateScheme` with `Manager = VictimAddress` and unique `Token` values
2. Each call generates a unique scheme ID via `GenerateSchemeId` 
3. Each scheme ID is appended to `State.ManagingSchemeIds[VictimAddress]`
4. No maximum limit exists on list size
5. List grows unbounded until victim operations fail with gas exhaustion

## Impact Explanation

**Primary DoS - ResetManager Failure:**

The `ResetManager` function performs an O(n) `Remove` operation on the scheme ID list: [5](#0-4) 

With a protobuf repeated field containing millions of entries, the `Remove` operation must scan the entire list to find and remove the target element. The subsequent state write operation will exceed gas limits, permanently preventing the victim from transferring management of their legitimate schemes.

**Secondary DoS - View Function Failure:**

The `GetManagingSchemeIds` view function returns the entire list without pagination: [6](#0-5) 

Large lists will exceed response size limits or timeout, preventing the victim from querying their schemes and breaking off-chain systems that rely on this data for profit distribution management.

**Tertiary DoS - Scheme Creation Degradation:**

Legitimate scheme creation by the victim becomes increasingly expensive due to read-modify-write operations on the inflated list.

**Affected Parties:**
- System contracts (Treasury, TokenHolder) that manage profit schemes
- DApp developers who rely on profit distribution mechanisms  
- Economic actors who need to manage profit scheme configurations

## Likelihood Explanation

**Attacker Capabilities:** Any user with a standard account can execute this attack. No special permissions, staked tokens, or trusted role compromise is required.

**Attack Complexity:** Trivial. The attacker simply calls `CreateScheme` in a loop with incrementing `Token` values, each generating a unique scheme ID for the victim address.

**Economic Feasibility:** The attack cost is `CreateScheme` gas cost Ã— number of schemes. To cause permanent DoS, approximately 10,000-100,000 schemes would suffice depending on gas limits, making this economically viable for targeted attacks against high-value system contracts.

**Detection:** While the attack leaves clear on-chain evidence (many schemes with the same manager from the same attacker address), by the time it's detected, the victim's list is already corrupted. No rate limiting or preventive mechanism exists.

**Probability:** HIGH - The entry point is public, the vulnerability is straightforward to exploit, and there are no technical barriers to execution.

## Recommendation

Add authorization validation in `CreateScheme` to verify the caller has permission when specifying a manager different from themselves:

```csharp
public override Hash CreateScheme(CreateSchemeInput input)
{
    ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);
    
    // Add authorization check
    if (input.Manager != null && input.Manager != Context.Sender)
    {
        Assert(false, "Only the manager can create schemes for themselves.");
    }
    
    var manager = input.Manager ?? Context.Sender;
    // ... rest of the function
}
```

Alternatively, simply remove the ability to specify a manager in the input and always use `Context.Sender`:

```csharp
var manager = Context.Sender; // Always use the caller as manager
```

Additionally, consider implementing pagination for `GetManagingSchemeIds` to handle large lists gracefully.

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_UnauthorizedManagerAssignment_DoS_Test()
{
    var attacker = Normal[0]; // Any unprivileged user
    var victim = Creators[0]; // Target victim
    var victimAddress = Address.FromPublicKey(CreatorKeyPair[0].PublicKey);
    
    // Attacker creates multiple schemes with victim as manager
    for (int i = 0; i < 1000; i++)
    {
        var token = HashHelper.ComputeFrom(i);
        await attacker.CreateScheme.SendAsync(new CreateSchemeInput
        {
            Manager = victimAddress, // Unauthorized - attacker assigns victim as manager
            Token = token, // Unique token generates unique scheme ID
            ProfitReceivingDuePeriodCount = 100
        });
    }
    
    // Verify victim's managing schemes list is inflated
    var victimSchemes = await victim.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
    {
        Manager = victimAddress
    });
    
    victimSchemes.SchemeIds.Count.ShouldBeGreaterThanOrEqualTo(1000);
    
    // Victim cannot reset manager due to gas exhaustion on Remove operation
    // This demonstrates the DoS impact on ResetManager
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L57-57)
```csharp
        var manager = input.Manager ?? Context.Sender;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L733-735)
```csharp
        var oldManagerSchemeIds = State.ManagingSchemeIds[scheme.Manager];
        oldManagerSchemeIds.SchemeIds.Remove(input.SchemeId);
        State.ManagingSchemeIds[scheme.Manager] = oldManagerSchemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```

**File:** protobuf/profit_contract.proto (L131-132)
```text
    // Use to generate scheme id.
    aelf.Hash token = 6;
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L12-15)
```csharp
    public override CreatedSchemeIds GetManagingSchemeIds(GetManagingSchemeIdsInput input)
    {
        return State.ManagingSchemeIds[input.Manager];
    }
```
