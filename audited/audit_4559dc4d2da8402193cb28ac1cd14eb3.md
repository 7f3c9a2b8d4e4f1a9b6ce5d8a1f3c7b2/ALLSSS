### Title
Mining Order Manipulation via Self-Inclusion in TuneOrderInformation

### Summary
A malicious miner can manipulate their own mining order for the next round by including their public key in `TuneOrderInformation` with an arbitrary order value. The vulnerability exists because `ProcessUpdateValue` applies `TuneOrderInformation` after setting the miner's correct `FinalOrderOfNextRound`, allowing self-modification, and no validation prevents miners from tuning their own order.

### Finding Description

**Root Cause:**

The vulnerability occurs in the consensus update flow where a miner can manipulate the Round object in the consensus block header before calling `ExtractInformationToUpdateConsensus`. [1](#0-0) 

This function extracts all miners where `FinalOrderOfNextRound != SupposedOrderOfNextRound` into `tuneOrderInformation`, without excluding the calling miner themselves.

**Execution Path:**

1. When generating consensus transactions, the system calls `GenerateTransactionListByExtraData` which uses the Round object from the consensus header: [2](#0-1) 

2. A malicious miner can manipulate the Round object to set their own `FinalOrderOfNextRound` to a different value before it reaches `ExtractInformationToUpdateConsensus`, causing their own pubkey to be included in `TuneOrderInformation`.

3. In `ProcessUpdateValue`, the code first correctly sets the miner's order: [3](#0-2) 

4. However, immediately after, `TuneOrderInformation` is applied without checking if it contains the miner's own pubkey: [4](#0-3) 

This overwrites the correct value with the malicious one.

**Why Protections Fail:**

The `UpdateValueValidationProvider` only validates OutValue and PreviousInValue: [5](#0-4) 

It does not validate `TuneOrderInformation` entries or prevent self-inclusion.

The `RecoverFromUpdateValue` method used in validation blindly copies all `FinalOrderOfNextRound` values from the provided round: [6](#0-5) 

This makes the validation pass even when malicious values are present.

**Impact on Next Round Generation:**

When the next round is generated, miners are ordered by their `FinalOrderOfNextRound`: [7](#0-6) 

The malicious `FinalOrderOfNextRound` value directly determines the miner's position in the next round.

### Impact Explanation

**Consensus Integrity Violation:**
- A malicious miner can arbitrarily choose their mining position in the next round (e.g., position 1 to mine first)
- This breaks the fairness guarantee of the AEDPoS consensus mechanism where mining order should be deterministically calculated from cryptographic signatures

**Concrete Harms:**
1. **Front-running advantage**: Mining first in a round allows front-running other miners' transactions and consensus data
2. **Random number manipulation**: The extra block producer order calculation uses the first miner's signature, allowing influence over which miner becomes the extra block producer
3. **LIB calculation manipulation**: Mining order affects irreversible block height calculations, potentially delaying finality
4. **Reward manipulation**: Earlier miners may have advantages in reward distribution timing
5. **Long-term position fixing**: A miner can repeatedly manipulate their position to maintain a favorable mining slot

**Affected Parties:**
- All honest miners lose fair ordering guarantees
- The entire network's consensus security is compromised
- Users relying on fair transaction ordering

**Severity Justification:**
This is a **High severity** vulnerability because it directly compromises a critical invariant: "Correct round transitions and miner schedule integrity." Any active miner can exploit this without special permissions, and it fundamentally breaks the consensus fairness mechanism.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an active miner in the consensus set
- Attacker must control their node software to manipulate the Round object in consensus block headers
- No special privileges beyond being a miner are required

**Attack Complexity:**
- **Low to Medium**: The attacker needs to:
  1. Intercept the Round object after `ApplyNormalConsensusData` but before block header generation
  2. Modify their own `FinalOrderOfNextRound` field to desired position
  3. Submit the block with this manipulated consensus information

**Feasibility Conditions:**
- The attack is feasible for any miner running modified node software
- No cryptographic barriers prevent this manipulation
- The validation system does not detect this type of manipulation

**Detection Constraints:**
- The manipulation appears as legitimate `TuneOrderInformation` which is a normal consensus feature
- Other nodes cannot easily distinguish malicious self-tuning from legitimate conflict resolution
- No monitoring exists for miners including themselves in `TuneOrderInformation`

**Probability:**
High - Any rational miner seeking advantage would be incentivized to exploit this, especially for:
- MEV extraction opportunities
- Influence over extra block producer selection
- Strategic positioning for term transitions

### Recommendation

**Immediate Fix:**

Add validation in `ProcessUpdateValue` to prevent miners from including their own pubkey in `TuneOrderInformation`:

```csharp
// In AEDPoSContract_ProcessConsensusInformation.cs, before line 259:
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    Assert(tuneOrder.Key != _processingBlockMinerPubkey, 
        "Miner cannot tune their own order.");
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}
```

**Additional Validations:**

1. Add validation in `UpdateValueValidationProvider` to check `TuneOrderInformation`:
   - Ensure no entry has `Key == SenderPubkey`
   - Validate all tuned orders are within valid range [1, miner_count]
   - Ensure no duplicate final orders across all miners

2. Validate `SupposedOrderOfNextRound` matches the calculation from the signature:
   - Recalculate order from `updateValueInput.Signature`
   - Assert it matches `updateValueInput.SupposedOrderOfNextRound`

**Test Cases:**

Create test cases to verify:
1. A miner including their own pubkey in `TuneOrderInformation` is rejected
2. `SupposedOrderOfNextRound` mismatching signature calculation is rejected
3. Legitimate conflict resolution via `TuneOrderInformation` still works for OTHER miners
4. Mining order in next round correctly reflects only legitimate tuning

### Proof of Concept

**Initial State:**
- 5 miners in consensus: M1, M2, M3, M4, M5
- M3 is the malicious miner
- Current round: round N

**Attack Steps:**

1. **M3 prepares to mine in round N:**
   - M3's node calls `GetConsensusBlockExtraData` which creates Round object via `ApplyNormalConsensusData`
   - Normal calculation: M3's signature â†’ `SupposedOrderOfNextRound = 4`
   - Normal: `FinalOrderOfNextRound = 4` (line 44 of Round_ApplyNormalConsensusData.cs)

2. **M3 manipulates the Round object:**
   - Before including in block header, M3 modifies: `Round.RealTimeMinersInformation["M3"].FinalOrderOfNextRound = 1`
   - Now `FinalOrderOfNextRound != SupposedOrderOfNextRound` for M3

3. **Transaction generation:**
   - `ExtractInformationToUpdateConsensus` executes (line 22-24)
   - Finds M3 has `FinalOrderOfNextRound (1) != SupposedOrderOfNextRound (4)`
   - Includes in result: `TuneOrderInformation = { "M3": 1 }`

4. **Block execution:**
   - `ProcessUpdateValue` executes
   - Line 247: Sets `M3.FinalOrderOfNextRound = 4` (correct value)
   - Line 260: Overwrites with `M3.FinalOrderOfNextRound = 1` (malicious value from TuneOrderInformation)

5. **Next round generation:**
   - `GenerateNextRoundInformation` orders miners by `FinalOrderOfNextRound`
   - M3 gets `Order = 1` in round N+1 (mines first)

**Expected Result:**
M3 should get order 4 in next round based on their signature

**Actual Result:**
M3 gets order 1 in next round, allowing them to mine first and gain front-running advantage

**Success Condition:**
M3 successfully manipulates their mining position from 4 to 1 in the next round without any validation failure.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L130-147)
```csharp
    private TransactionList GenerateTransactionListByExtraData(AElfConsensusHeaderInformation consensusInformation,
        ByteString pubkey, ByteString randomNumber)
    {
        var round = consensusInformation.Round;
        var behaviour = consensusInformation.Behaviour;
        switch (behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                Context.LogDebug(() =>
                    $"Previous in value in extra data:{round.RealTimeMinersInformation[pubkey.ToHex()].PreviousInValue}");
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
