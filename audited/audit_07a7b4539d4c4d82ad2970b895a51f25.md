### Title
Any Miner Can Terminate Round Early Without Authorization Check for Extra Block Producer Role

### Summary
The consensus validation does not verify that the sender of a NextRound/NextTerm block is the designated extra block producer. Any miner whose time slot has passed can produce a round-terminating block and claim the extra block reward, stealing the opportunity from the designated extra block producer. This breaks consensus fairness and reward distribution.

### Finding Description

The function selection between `ArrangeNormalBlockMiningTime` and `ArrangeExtraBlockMiningTime` is determined by the behaviour returned from `GetConsensusBehaviour()`, not by miner choice. However, a critical vulnerability exists in the authorization logic. [1](#0-0) 

The behaviour selection occurs in `ConsensusBehaviourProviderBase.GetConsensusBehaviour()`, which returns `NextRound`/`NextTerm` behaviour to ANY miner whose time slot has passed: [2](#0-1) 

When a miner produces a NextRound/NextTerm block, the `ValidateBeforeExecution` method runs multiple validators: [3](#0-2) 

However, NONE of these validators check if the sender is the designated extra block producer:

1. `MiningPermissionValidationProvider` only checks if the miner is in the miner list: [4](#0-3) 

2. `TimeSlotValidationProvider` only validates the new round's time slot consistency, not WHO produced it: [5](#0-4) 

3. `RoundTerminateValidationProvider` only validates round number correctness: [6](#0-5) 

4. The `PreCheck` method in `ProcessConsensusInformation` only verifies miner list membership: [7](#0-6) 

Notably, the `IsCurrentMiner` method DOES check if a miner is the extra block producer: [8](#0-7) 

But this method is **never called during consensus validation**.

### Impact Explanation

**Consensus Integrity Violation**: Any miner can terminate the round as soon as their normal time slot passes, bypassing the intended extra block producer role.

**Reward Misallocation**: The attacker gains the extra block's mining reward that should belong to the designated extra block producer: [9](#0-8) 

**Fairness Breach**: The extra block producer is pseudo-randomly selected to distribute this opportunity fairly across miners. Allowing any miner to steal this role undermines the fairness mechanism: [10](#0-9) 

**Quantified Impact**: For each stolen extra block, the attacker gains one additional block reward (currently determined by Treasury's mining reward per block), while the designated producer loses the same amount. In a round with N miners, this represents a 1/N increase in the attacker's rewards at another miner's expense.

### Likelihood Explanation

**Attacker Capabilities**: Any active miner in the consensus (no special privileges required).

**Attack Complexity**: LOW
1. Miner waits for their normal time slot to pass
2. Requests consensus command (receives NextRound/NextTerm behaviour automatically)
3. Produces the NextRound/NextTerm block immediately
4. Block passes all validations despite miner not being the extra block producer

**Feasibility Conditions**: 
- Attacker must be an active miner in current round
- Attacker's normal time slot must have passed
- No additional preconditions required

**Economic Rationality**: Attacker gains extra block reward with zero additional cost beyond normal mining operations.

**Detection Constraints**: Other nodes accept the block as valid since validation passes. No on-chain detection mechanism exists.

**Probability**: HIGH - Any miner can execute this every round after their time slot passes.

### Recommendation

Add explicit validation that only the designated extra block producer can produce NextRound/NextTerm blocks:

1. In `AEDPoSContract_Validation.cs`, add a new validation provider for NextRound/NextTerm behaviours:
```csharp
public class ExtraBlockProducerValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var extraBlockProducer = validationContext.BaseRound.RealTimeMinersInformation
            .FirstOrDefault(m => m.Value.IsExtraBlockProducer).Key;
        
        if (extraBlockProducer != validationContext.SenderPubkey)
        {
            return new ValidationResult 
            { 
                Message = $"Only designated extra block producer {extraBlockProducer} can terminate round, not {validationContext.SenderPubkey}" 
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

2. Add this validator to the switch statement in `ValidateBeforeExecution`: [11](#0-10) 

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new ExtraBlockProducerValidationProvider()); // ADD THIS
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new ExtraBlockProducerValidationProvider()); // ADD THIS
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

3. Add test cases verifying that non-extra-block-producers cannot produce NextRound/NextTerm blocks.

### Proof of Concept

**Initial State**:
- Round N with miners A, B, C, D (in order)
- Miner D is designated as extra block producer (IsExtraBlockProducer = true)
- Current time: Miner B's time slot has just ended

**Attack Steps**:
1. Miner B (attacker) calls `GetConsensusCommand` with their pubkey
2. Contract returns NextRound behaviour (since B's time slot passed)
3. Miner B produces NextRound block with Round N+1 information
4. Block enters validation:
   - MiningPermissionValidationProvider: PASS (B is in miner list)
   - TimeSlotValidationProvider: PASS (new round time slots are consistent)
   - NextRoundMiningOrderValidationProvider: PASS (mining order correctly set)
   - RoundTerminateValidationProvider: PASS (round number = N+1)
5. Block accepted by network
6. `ProcessNextRound` executes, Miner B's produced block count increments [12](#0-11) 

**Expected Result**: Validation should reject block because Miner B is not the extra block producer.

**Actual Result**: Block accepted, Miner B gains extra block reward, Miner D loses opportunity to produce the extra block.

**Success Condition**: Miner B's `ProducedBlocks` count increases by 1 for the stolen extra block, and Round N+1 begins with Miner B recorded as the round terminator instead of designated producer Miner D.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MiningTimeArrangingService.cs (L17-25)
```csharp
        public static Timestamp ArrangeNormalBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
        {
            return TimestampExtensions.Max(round.GetExpectedMiningTime(pubkey), currentBlockTime);
        }

        public static Timestamp ArrangeExtraBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
        {
            return round.ArrangeAbnormalMiningTime(pubkey, currentBlockTime);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L62-92)
```csharp
        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L10-47)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) return ValidationForNextRound(validationContext);

        if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) return ValidationForNextTerm(validationContext);

        validationResult.Success = true;
        return validationResult;
    }

    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-252)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```
