# Audit Report

## Title
Evil Miners Can Produce Blocks Despite Exceeding Missed Time Slots Threshold

## Summary
The `MiningPermissionValidationProvider` performs only dictionary key existence validation without checking the `MissedTimeSlots` counter. This allows miners who have exceeded the `TolerableMissedTimeSlotsCount` threshold (4320 slots = 3 days) to continue producing blocks and earning rewards until they are detected post-execution in `ProcessNextRound`. This creates an exploitation window where unreliable miners can earn rewards despite violating the protocol's availability requirements.

## Finding Description

The AEDPoS consensus protocol defines a tolerance threshold for miner inactivity: miners who miss 4320 time slots (3 days of continuous absence) should be marked as "evil" and excluded from block production. However, the pre-execution validation does not enforce this constraint.

**Root Cause:**

The `MiningPermissionValidationProvider.ValidateHeaderInformation` method only verifies that a miner's public key exists in the `RealTimeMinersInformation` dictionary: [1](#0-0) 

The comment explicitly states "Simply check keys of RealTimeMinersInformation should be enough," but this is insufficient. The method does not validate the `MissedTimeSlots` field against the threshold defined as: [2](#0-1) 

**Execution Flow Creating the Vulnerability Window:**

1. During `ValidateBeforeExecution`, the `MiningPermissionValidationProvider` is added to the validation chain: [3](#0-2) 

2. This validation occurs BEFORE block execution via `ValidateConsensusBeforeExecution`: [4](#0-3) 

3. Evil miner detection only happens AFTER block execution in `ProcessNextRound`: [5](#0-4) 

4. The detection method properly checks the `MissedTimeSlots` threshold: [6](#0-5) 

5. The `MissedTimeSlots` counter is incremented for miners who miss their slots: [7](#0-6) 

6. Evil miners remain in `RealTimeMinersInformation` for the current round and are only excluded when the Election contract generates a new miner list for the next term.

**The Critical Gap:**

A miner with `MissedTimeSlots >= 4320` remains in the `RealTimeMinersInformation` dictionary. When their assigned time slot arrives, they can produce blocks that pass validation (since only key existence is checked), execute successfully, and increment their `ProducedBlocks` counter: [8](#0-7) 

## Impact Explanation

**High Severity - Consensus Economic Integrity Violation**

Miners who have demonstrated sustained unreliability (3 days of missed time slots) can continue to:

1. **Earn Mining Rewards:** When blocks are produced, the total reward is calculated as: [9](#0-8) 

The reward per block starts at 12,500,000 tokens and each block produced by an evil miner increases the reward pool they're eligible for.

2. **Impact Honest Miners:** The mining reward distribution is based on `ProducedBlocks` counts, as shown when updating candidate information: [10](#0-9) 

Evil miners dilute the reward pool that should go exclusively to reliable miners.

3. **Violate Protocol Invariants:** The AEDPoS protocol's economic design assumes that miners crossing the 4320 missed slots threshold are immediately prevented from earning further rewards. This delay in enforcement breaks that fundamental assumption.

**Affected Parties:**
- Honest miners lose potential rewards to miners who should be excluded
- Token holders experience inflationary pressure from rewards paid to undeserving participants  
- Network consensus quality is degraded by allowing unreliable miners to participate

## Likelihood Explanation

**High Likelihood**

**Preconditions:**
1. Attacker must be an active miner in the current consensus round
2. Attacker accumulates `MissedTimeSlots >= 4320` (achievable through 3 days of downtime or deliberate absence)
3. Attacker's time slot must arrive before the `NextRound` or `NextTerm` transition that would trigger detection

**Attack Execution:**
1. Miner intentionally or accidentally misses time slots across multiple rounds
2. `MissedTimeSlots` counter increments each round the miner fails to produce blocks
3. After crossing the 4320 threshold, miner remains in `RealTimeMinersInformation`
4. When miner's assigned time slot arrives, miner comes back online
5. Miner produces blocks that pass validation (only key existence is checked)
6. Miner's `ProducedBlocks` counter increases, earning them reward eligibility
7. Only during the subsequent `ProcessNextRound` call is the miner detected and marked as evil

**Feasibility Assessment:**
- **Current System Behavior:** This is not an edge case but the actual implementation. The validation explicitly states it only checks keys.
- **No Special Privileges Required:** Any miner can experience this scenario through network issues or deliberate manipulation.
- **Economically Rational:** The cost is being offline for 3 days, but miners can still earn rewards for any blocks produced before detection.
- **Observable in Code:** The comment in `MiningPermissionValidationProvider` confirms the insufficient validation is intentional but flawed.

## Recommendation

Add `MissedTimeSlots` validation to the `MiningPermissionValidationProvider`:

```csharp
public class MiningPermissionValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
        
        // Add MissedTimeSlots validation
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        if (minerInRound.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
        {
            validationResult.Message = $"Miner {validationContext.SenderPubkey} has exceeded tolerable missed time slots ({minerInRound.MissedTimeSlots} >= {AEDPoSContractConstants.TolerableMissedTimeSlotsCount}).";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
}
```

This ensures that miners exceeding the missed time slots threshold are prevented from producing blocks at the validation stage, before any rewards can be earned.

## Proof of Concept

```csharp
[Fact]
public async Task EvilMiner_CanProduceBlocks_WithExceededMissedTimeSlots()
{
    // Setup: Initialize consensus with a miner
    var minerKeyPair = SampleECKeyPairs.KeyPairs[0];
    var minerPubkey = minerKeyPair.PublicKey.ToHex();
    
    // Create initial round with the miner
    var initialRound = GenerateFirstRound(new[] { minerPubkey });
    await InitializeAEDPoSContract(initialRound);
    
    // Simulate miner missing time slots over multiple rounds to exceed threshold
    var currentRound = initialRound;
    for (int i = 0; i < 4321; i++) // Exceed TolerableMissedTimeSlotsCount (4320)
    {
        currentRound = GenerateNextRound(currentRound, minerDidNotMine: true);
        // This increments MissedTimeSlots in Round_Generation.cs:54
    }
    
    // Verify MissedTimeSlots exceeds threshold
    var minerInfo = currentRound.RealTimeMinersInformation[minerPubkey];
    Assert.True(minerInfo.MissedTimeSlots >= 4320);
    
    // Verify miner is still in RealTimeMinersInformation (key exists)
    Assert.True(currentRound.RealTimeMinersInformation.ContainsKey(minerPubkey));
    
    // Attempt to produce a block with this evil miner
    var consensusCommand = await GetConsensusCommandAsync(minerPubkey);
    
    // VULNERABILITY: Validation passes despite exceeded MissedTimeSlots
    // MiningPermissionValidationProvider only checks key existence
    var validationResult = await ValidateConsensusBeforeExecutionAsync(consensusCommand);
    Assert.True(validationResult.Success); // Should fail but passes!
    
    // Evil miner successfully produces block and earns rewards
    var blockResult = await ProduceBlockAsync(minerKeyPair, consensusCommand);
    Assert.True(blockResult.Success);
    
    // Verify ProducedBlocks counter increased (earning reward eligibility)
    var updatedRound = await GetCurrentRoundInformationAsync();
    var updatedMinerInfo = updatedRound.RealTimeMinersInformation[minerPubkey];
    Assert.True(updatedMinerInfo.ProducedBlocks > minerInfo.ProducedBlocks);
    
    // Evil miner is only detected AFTER execution in ProcessNextRound
    // At this point, they've already earned the reward for this block
}
```

**Notes**

This vulnerability represents a timing gap in the consensus validation layer. While the protocol correctly identifies and marks evil miners post-execution, the lack of pre-execution `MissedTimeSlots` validation allows a window of exploitation. The fix is straightforward: extend the `MiningPermissionValidationProvider` to check not just miner list membership, but also compliance with the missed time slots threshold. This brings validation enforcement in line with the protocol's intended economic design.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-24)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-75)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-253)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L39-56)
```csharp
        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L37-51)
```csharp
    private void UpdateCurrentMinerInformationToElectionContract(Round previousRound)
    {
        State.ElectionContract.UpdateMultipleCandidateInformation.Send(new UpdateMultipleCandidateInformationInput
        {
            Value =
            {
                previousRound.RealTimeMinersInformation.Select(i => new UpdateCandidateInformationInput
                {
                    Pubkey = i.Key,
                    RecentlyProducedBlocks = i.Value.ProducedBlocks,
                    RecentlyMissedTimeSlots = i.Value.MissedTimeSlots
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```
