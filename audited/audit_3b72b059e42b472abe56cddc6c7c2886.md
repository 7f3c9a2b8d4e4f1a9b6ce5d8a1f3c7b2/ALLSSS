### Title
Permanent Lock of Native Tokens Due to Burnable/Transferable SHARE and VOTE Tokens

### Summary
The SHARE and VOTE election tokens are created as burnable and freely transferable, but users must retain them to withdraw their votes and unlock their native ELF tokens. Users who burn, transfer, or lock these tokens in external schemes (such as side chain profit distribution) will be unable to withdraw, permanently locking their native tokens in the Election Contract.

### Finding Description

The Election Contract issues SHARE and VOTE tokens to voters as receipts representing their voting power. Both tokens are created with `IsBurnable = true` in the Economic Contract's initialization: [1](#0-0) 

When users vote, they receive equal amounts of SHARE and VOTE tokens via `TransferTokensToVoter()`: [2](#0-1) 

When withdrawing, the Election Contract attempts to retrieve these tokens back using `RetrieveTokensFromVoter()`: [3](#0-2) 

The `TransferFrom` operation eventually calls `DoTransferFrom`, which uses `DoTransfer` and `ModifyBalance` to check the user's balance: [4](#0-3) 

Even though the Election Contract is in the whitelist (bypassing allowance checks), the balance check in `ModifyBalance` still applies: [5](#0-4) 

**Root Cause**: SHARE and VOTE tokens have no transfer restrictions despite being critical for vote withdrawal. Users can:
1. **Burn tokens** - Both are burnable, allowing users to destroy them: [6](#0-5) 

2. **Transfer tokens** - Standard transfer operations work without restriction: [7](#0-6) 

3. **Lock in external schemes** - The SHARE token symbol matches the side chain profit distribution token, potentially confusing users: [8](#0-7) 

Once tokens are removed from the user's balance, the withdrawal transaction fails with "Insufficient balance" when `ModifyBalance` attempts to deduct the tokens.

### Impact Explanation

**Direct Fund Impact**: Users' native ELF tokens become permanently locked in the Election Contract with no recovery mechanism. For example, a user voting with 10,000 ELF tokens who burns their SHARE/VOTE tokens cannot withdraw, losing access to their entire locked amount.

**Affected Users**: Any voter who accidentally or intentionally transfers, burns, or locks SHARE/VOTE tokens outside the Election Contract. The ambiguous purpose of SHARE tokens (mentioned in the audit question) increases the likelihood of users attempting to use them in side chain profit schemes.

**Severity Justification**: While this is a self-inflicted issue, it represents a critical design flaw where:
- No documentation warns users to retain these tokens
- The token name "SHARE" suggests profit-sharing usage
- There are no transfer restrictions to prevent misuse
- The impact is permanent and irreversible fund loss

### Likelihood Explanation

**Attacker Capabilities**: This is a user error scenario requiring only:
- Standard voting operation (public `Vote()` method)
- Standard token operations (burn/transfer) available to all token holders

**Attack Complexity**: Minimal - users simply need to vote and then burn or transfer their SHARE/VOTE tokens.

**Feasibility Conditions**:
1. User votes for a candidate, locking native ELF tokens
2. User receives SHARE and VOTE tokens
3. User burns/transfers tokens (thinking they can use SHARE for profits or not understanding their purpose)
4. Lock period expires
5. User attempts withdrawal, transaction reverts with "Insufficient balance"

**Probability Reasoning**: MEDIUM-LOW likelihood because:
- Requires active user action (not automatic)
- The audit question itself notes "purpose ambiguity" and lack of documentation
- SHARE token name matching side chain profit symbol (`SideChainShareProfitsTokenSymbol`) creates confusion
- Users might reasonably expect to use SHARE tokens in TokenHolder profit schemes
- No warnings or UI safeguards prevent token disposal

### Recommendation

**1. Restrict Token Transfers**: Make SHARE and VOTE tokens non-transferable except to/from the Election Contract:
- Add a transfer restriction in token creation that only allows Election Contract to transfer
- Set `IsBurnable = false` for both tokens
- Implement a whitelist check that blocks regular user transfers

**2. Add Balance Validation**: Before users can withdraw, check they still hold the required SHARE and VOTE tokens:
- In `Withdraw()` method, verify `GetBalance(voter, "SHARE") >= amount` and `GetBalance(voter, "VOTE") >= amount`
- Provide clear error message: "Cannot withdraw: missing SHARE/VOTE tokens required for withdrawal"

**3. Documentation**: Add clear documentation that:
- SHARE and VOTE tokens are voting receipts, not tradeable assets
- These tokens must be retained until withdrawal
- Burning or transferring these tokens will prevent vote withdrawal

**4. Test Cases**:
- Test withdrawal fails gracefully when SHARE tokens are burned
- Test withdrawal fails gracefully when VOTE tokens are transferred
- Test withdrawal succeeds only when both tokens are available in full amount

### Proof of Concept

**Initial State**:
- User has 10,000 ELF tokens
- Candidate exists and accepts votes
- Election Contract is initialized with SHARE and VOTE tokens

**Transaction Steps**:
1. User calls `Vote(candidatePubkey, amount=10000, endTimestamp=now+90days)`
   - User's ELF balance: 0 (locked)
   - User receives 10,000 SHARE tokens
   - User receives 10,000 VOTE tokens

2. User calls `Burn(symbol="SHARE", amount=10000)` on MultiToken contract
   - User's SHARE balance: 0
   - User's VOTE balance: 10,000

3. After 90 days, user calls `Withdraw(voteId)`
   - Election Contract calls `RetrieveTokensFromVoter(10000)`
   - `TransferFrom(voter, ElectionContract, "SHARE", 10000)` is attempted
   - `ModifyBalance(voter, "SHARE", -10000)` checks balance
   - User has 0 SHARE, needs 10,000
   - Transaction reverts: "Insufficient balance of SHARE. Need balance: 10000; Current balance: 0"

**Expected Result**: User can withdraw their vote and unlock their 10,000 ELF tokens

**Actual Result**: Transaction fails, user's 10,000 ELF tokens remain permanently locked in Election Contract with no recovery mechanism

**Success Condition**: User is unable to call `Withdraw()` successfully, demonstrating permanent fund lock.

### Citations

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L114-136)
```csharp
        foreach (var symbol in new List<string>
                     { EconomicContractConstants.ElectionTokenSymbol, EconomicContractConstants.ShareTokenSymbol })
        {
            State.TokenContract.Create.Send(new CreateInput
            {
                Symbol = symbol,
                TokenName = $"{symbol} Token",
                TotalSupply = EconomicContractConstants.ElectionTokenTotalSupply,
                Decimals = EconomicContractConstants.ElectionTokenDecimals,
                Issuer = Context.Self,
                IsBurnable = true,
                LockWhiteList = { lockWhiteList },
                Owner = Context.Self
            });
            State.TokenContract.Issue.Send(new IssueInput
            {
                Symbol = symbol,
                Amount = EconomicContractConstants.ElectionTokenTotalSupply,
                To = Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName),
                Memo = "Issue all election tokens to Election Contract."
            });
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L282-294)
```csharp
    private void RetrieveTokensFromVoter(long amount, Address voterAddress = null)
    {
        foreach (var symbol in new List<string>
                     { ElectionContractConstants.ShareSymbol, ElectionContractConstants.VoteSymbol })
            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = voterAddress ?? Context.Sender,
                To = Context.Self,
                Amount = amount,
                Symbol = symbol,
                Memo = $"Return {symbol} tokens."
            });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L344-355)
```csharp
    private void TransferTokensToVoter(long amount)
    {
        foreach (var symbol in new List<string>
                     { ElectionContractConstants.ShareSymbol, ElectionContractConstants.VoteSymbol })
            State.TokenContract.Transfer.Send(new TransferInput
            {
                Symbol = symbol,
                To = Context.Sender,
                Amount = amount,
                Memo = $"Transfer {symbol}."
            });
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L116-125)
```csharp
    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L323-337)
```csharp
    private Empty Burn(Address address, string symbol, long amount)
    {
        var tokenInfo = AssertValidToken(symbol, amount);
        Assert(tokenInfo.IsBurnable, "The token is not burnable.");
        ModifyBalance(address, symbol, -amount);
        tokenInfo.Supply = tokenInfo.Supply.Sub(amount);

        Context.Fire(new Burned
        {
            Burner = address,
            Symbol = symbol,
            Amount = amount
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L12-12)
```csharp
    public const string SideChainShareProfitsTokenSymbol = "SHARE";
```
