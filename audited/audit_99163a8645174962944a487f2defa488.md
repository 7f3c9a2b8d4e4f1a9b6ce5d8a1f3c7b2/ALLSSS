### Title
Cross-Chain Token Creation Bypasses Case-Insensitive Duplicate Check, Enabling Phishing Token Creation

### Summary
The `CrossChainCreateToken` function fails to check the case-insensitive token existence mapping (`State.InsensitiveTokenExisting`) before registering tokens from other chains. This allows an attacker to create case-variant tokens (e.g., "TOKEN" and "token") on the same chain by bringing them from different source chains, enabling phishing attacks that exploit case-insensitive user interfaces.

### Finding Description

The MultiToken contract implements case-insensitive duplicate prevention for the normal token creation path. The `CheckTokenExists` function properly validates against the uppercase version of token symbols: [1](#0-0) 

When tokens are created normally via the `Create` function, `CheckTokenExists` is called before `RegisterTokenInfo`: [2](#0-1) 

The `RegisterTokenInfo` function stores both the exact symbol and sets the case-insensitive flag: [3](#0-2) 

**However, the `CrossChainCreateToken` function bypasses this protection.** It only checks if the exact symbol exists in `State.TokenInfos`, without verifying the case-insensitive mapping: [4](#0-3) 

This creates an inconsistent security model where:
- Direct creation on a chain prevents "TOKEN" and "token" from coexisting
- Cross-chain creation allows both to exist if brought from different source chains

### Impact Explanation

**Direct Fund Impact:**
- Users interacting with case-insensitive UIs/wallets may confuse "TOKEN" with "token", leading to transfers of funds to the wrong token
- Legitimate "TOKEN" holders could accidentally transfer or approve allowances for phishing "token"
- dApps that perform case-insensitive symbol lookups will exhibit unpredictable behavior

**Operational Impact:**
- Token confusion can lead to incorrect pricing in DEXs and other DeFi protocols
- Smart contracts that interact with tokens using case-insensitive matching may operate on wrong tokens
- Loss of user trust if phishing tokens can exist alongside legitimate ones

The severity is **Medium to High** because:
1. Direct financial loss is possible through user confusion
2. The attack undermines the fundamental token uniqueness guarantee
3. Many blockchain explorers and wallets display tokens case-insensitively

### Likelihood Explanation

**Attack Complexity: Medium**

Prerequisites for exploitation:
1. Legitimate token "TOKEN" exists on Chain A (target chain)
2. Attacker creates phishing token "token" on Chain B (requires seed NFT or whitelist access on Chain B)
3. Attacker uses `CrossChainCreateToken` with valid cross-chain proof to bring "token" from Chain B to Chain A

**Feasibility Assessment:**
- **Reachable Entry Point**: `CrossChainCreateToken` is a public method (✓)
- **Feasible Preconditions**: Attacker needs control over token creation on at least one chain, which requires either:
  - Seed NFT possession (can be purchased/obtained)
  - Whitelist access (less common but possible)
- **Execution Practicality**: Cross-chain proofs can be generated legitimately; the exploit follows normal cross-chain token creation flow (✓)
- **Economic Rationality**: Cost is primarily the seed NFT price plus transaction fees on two chains; potential gain from phishing could exceed costs (✓)

**Detection/Prevention Limitations:**
- The exploit uses legitimate cross-chain mechanisms, making it hard to detect
- No on-chain alarm triggers since both token creations are "valid"
- Users must manually verify exact symbol capitalization, which is error-prone

Likelihood is **Medium** - the attack requires cross-chain setup and some initial investment, but is definitely feasible for motivated attackers targeting high-value tokens.

### Recommendation

**Code-Level Mitigation:**

Modify the `CrossChainCreateToken` function to check case-insensitive token existence before calling `RegisterTokenInfo`. Add the same check used in `CheckTokenExists`:

```csharp
// In CrossChainCreateToken, before line 506:
Assert(!State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()], 
    "Token with case-insensitive symbol already exists.");
```

**Alternative: Strengthen RegisterTokenInfo**

Modify `RegisterTokenInfo` to assert the case-insensitive slot is available:

```csharp
// In RegisterTokenInfo, before line 233:
Assert(!State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()], 
    "Token with case-insensitive symbol already exists.");
State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
```

**Test Cases to Prevent Regression:**

1. Test cross-chain token creation with exact symbol match (should succeed or skip)
2. Test cross-chain token creation with case-variant symbol (should fail)
3. Test sequence: Create "TOKEN" locally → CrossChainCreate "token" → Assert failure
4. Test sequence: CrossChainCreate "TOKEN" → Create "token" locally → Assert failure

### Proof of Concept

**Initial State:**
- Chain A (Main Chain): Token "TOKEN" exists with legitimate issuer
- Chain B (Side Chain): Token "token" created by attacker using seed NFT

**Attack Sequence:**

1. **On Chain A**: Legitimate token "TOKEN" is created via normal `Create` function
   - `State.TokenInfos["TOKEN"]` = TokenInfo{...}
   - `State.InsensitiveTokenExisting["TOKEN"]` = true

2. **On Chain B**: Attacker creates phishing token "token"
   - Uses seed NFT or whitelist access
   - `State.TokenInfos["token"]` = TokenInfo{...}
   - `State.InsensitiveTokenExisting["TOKEN"]` = true (on Chain B only)

3. **On Chain A**: Attacker calls `CrossChainCreateToken` with:
   - Valid cross-chain proof for "token" creation on Chain B
   - `ValidateTokenInfoExists` transaction from Chain B
   - Merkle path proof

4. **Vulnerability Trigger**: At line 506 in `CrossChainCreateToken`:
   - Check: `State.TokenInfos["token"] == null` → **TRUE** (lowercase "token" doesn't exist)
   - Calls `RegisterTokenInfo(tokenInfo)` 
   - Sets `State.TokenInfos["token"]` = TokenInfo{...}
   - Sets `State.InsensitiveTokenExisting["TOKEN"]` = true (overwrites existing value)

**Expected Result:** Transaction should fail with "Token already exists" error

**Actual Result:** Transaction succeeds, and Chain A now has both "TOKEN" and "token" as distinct tokens

**Success Condition:** 
```
GetTokenInfo("TOKEN") != null
GetTokenInfo("token") != null
GetTokenInfo("TOKEN") != GetTokenInfo("token")
```

Both tokens coexist on Chain A with different TokenInfo objects, enabling phishing attacks against users who don't carefully verify exact symbol capitalization.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L87-88)
```csharp
        CheckTokenExists(tokenInfo.Symbol);
        RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-508)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```
