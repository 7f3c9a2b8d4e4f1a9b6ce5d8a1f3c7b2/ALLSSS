# Audit Report

## Title
Empty Miner List Acceptance Causes Permanent Side Chain Consensus DoS via Division by Zero

## Summary
The `UpdateInformationFromCrossChain()` function in the AEDPoS consensus contract fails to validate that the parent chain's miner list is non-empty before storing it in state. When an empty miner list is stored, all subsequent consensus updates fail with a `DivideByZeroException` during resource token distribution, permanently breaking the side chain's ability to synchronize with the parent chain.

## Finding Description

The vulnerability exists in the cross-chain consensus update mechanism where side chains receive miner list information from their parent chain.

**Root Cause:**

The function extracts miner keys without validation [1](#0-0)  and commits them directly to state. The only validation checks are for null/empty input and round number comparison [2](#0-1) , but there is no check ensuring `RealTimeMinersInformation` contains at least one miner.

**Attack Execution:**

1. **First malicious call**: Parent chain data containing empty `RealTimeMinersInformation` is indexed. The empty miner list bypasses all validation checks and gets stored in `State.MainChainCurrentMinerList.Value`.

2. **Subsequent calls**: When the next consensus update occurs, `DistributeResourceTokensToPreviousMiners()` is invoked before the new miner list update [3](#0-2) .

3. **Division by zero**: The function retrieves the empty miner list from state [4](#0-3)  and attempts to calculate token distribution per miner [5](#0-4) .

4. **Exception thrown**: The `Div` method performs standard division [6](#0-5)  which throws `DivideByZeroException` when the miner count is zero, as confirmed by test cases [7](#0-6) .

5. **Permanent failure**: The guard checking `amount <= 0` at line 83 comes AFTER the division, so it cannot prevent the exception. All subsequent calls to `UpdateInformationFromCrossChain` fail at the same point.

**Why Protections Fail:**

- The cross-chain contract passes consensus data without content validation [8](#0-7) 
- The `IsMainChainMinerListChanged` check returns false for empty lists [9](#0-8) , preventing usage but not storage
- Parent chain block data validation only checks structural properties (height, merkle root) [10](#0-9) , not consensus data content

## Impact Explanation

**Critical Consensus Integrity Violation:**

- The side chain permanently loses its ability to receive miner list updates from the parent chain
- All subsequent `UpdateInformationFromCrossChain` transactions revert with an unrecoverable exception
- If the empty miner list is used in round generation, no blocks can be produced
- The consensus system becomes non-functional, requiring a hard fork or chain restart

**Operational Impact:**

- Complete halt of all side chain operations (transactions, smart contracts, cross-chain communications)
- Economic damage from extended downtime and loss of user confidence  
- Manual intervention required (hard fork) with significant coordination costs
- Affects the entire side chain ecosystem, not just consensus operations

The severity is **Critical** because it causes permanent DoS of core consensus functionality with no automated recovery mechanism.

## Likelihood Explanation

**Reachable Entry Point:**

The function can be triggered through the normal cross-chain indexing flow. When miners propose and release parent chain block data containing consensus information [11](#0-10) , that data is processed and forwarded to the consensus contract [12](#0-11) .

**Attack Vectors:**

1. **Parent chain bug**: A bug in the parent chain's consensus contract generates an invalid Round with empty `RealTimeMinersInformation`
2. **Malicious parent chain**: If operating a private parent-side chain pair, the parent chain could intentionally send malicious data
3. **Edge case scenario**: During parent chain maintenance or migration, empty miner data could be inadvertently propagated

**Execution Practicality:**

- Single malicious cross-chain consensus update triggers the vulnerability
- No complex preconditions required beyond the malformed data being indexed
- Attack persists permanently after a single successful execution
- No economic cost barrier if parent chain data is compromised

The likelihood is **Medium to High** - while it requires malformed parent chain data (uncommon in normal operation), the impact is so severe and permanent that even a low probability event represents critical risk. From a defense-in-depth perspective, the side chain should validate all external data, including parent chain consensus information.

## Recommendation

Add validation to ensure the miner list is non-empty before storing it:

```csharp
public override Empty UpdateInformationFromCrossChain(BytesValue input)
{
    // ... existing checks ...
    
    var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);
    
    // check round number of shared consensus, not term number
    if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
        return new Empty();
    
    // ADD THIS VALIDATION
    var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
    Assert(minersKeys.Any(), "Miner list cannot be empty.");
    
    DistributeResourceTokensToPreviousMiners();
    
    State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;
    State.MainChainCurrentMinerList.Value = new MinerList
    {
        Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
    };
    
    return new Empty();
}
```

Additionally, consider adding a defensive check in `DistributeResourceTokensToPreviousMiners`:

```csharp
private void DistributeResourceTokensToPreviousMiners()
{
    if (State.TokenContract.Value == null)
        State.TokenContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
    
    var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
    
    // ADD THIS DEFENSIVE CHECK
    if (minerList.Count == 0)
    {
        Context.LogDebug(() => "No miners to distribute to, skipping distribution.");
        return;
    }
    
    // ... rest of distribution logic ...
}
```

## Proof of Concept

```csharp
[Fact]
public async Task UpdateInformationFromCrossChain_EmptyMinerList_CausesDivisionByZero()
{
    // Setup: Initialize side chain with valid miner list
    var sideChainConsensus = GetSideChainConsensusContract();
    
    // Create consensus information with EMPTY RealTimeMinersInformation
    var emptyConsensusInfo = new AElfConsensusHeaderInformation
    {
        Round = new Round
        {
            RoundNumber = 2, // Higher than current
            RealTimeMinersInformation = { } // EMPTY!
        }
    };
    
    // First call: Store empty miner list (succeeds)
    var result1 = await sideChainConsensus.UpdateInformationFromCrossChain.SendAsync(
        new BytesValue { Value = emptyConsensusInfo.ToByteString() }
    );
    result1.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify empty list was stored
    var minerList = await sideChainConsensus.GetMainChainCurrentMinerList.CallAsync(new Empty());
    minerList.Pubkeys.Count.ShouldBe(0); // Empty!
    
    // Create another consensus update to trigger distribution
    var nextConsensusInfo = new AElfConsensusHeaderInformation
    {
        Round = new Round
        {
            RoundNumber = 3,
            RealTimeMinersInformation = { ["pubkey1"] = new MinerInRound() }
        }
    };
    
    // Second call: DivideByZeroException thrown in DistributeResourceTokensToPreviousMiners
    var result2 = await sideChainConsensus.UpdateInformationFromCrossChain.SendAsync(
        new BytesValue { Value = nextConsensusInfo.ToByteString() }
    );
    
    // Transaction fails with division by zero
    result2.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result2.TransactionResult.Error.ShouldContain("DivideByZeroException");
    
    // All subsequent calls fail permanently - side chain consensus is broken
}
```

## Notes

This vulnerability represents a critical failure in input validation for cross-chain data. While the parent chain is typically expected to provide valid data, defense-in-depth principles require the side chain to validate all external inputs, especially for consensus-critical data like the miner list. The permanent nature of the DoS (no recovery without hard fork) elevates this from a typical availability issue to a critical consensus integrity violation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L41-47)
```csharp
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L53-53)
```csharp
        DistributeResourceTokensToPreviousMiners();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L57-61)
```csharp
        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L72-72)
```csharp
        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L81-81)
```csharp
            var amount = balance.Div(minerList.Count);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L50-51)
```csharp
        Should.Throw<DivideByZeroException>(() => { number1.Div(0); });
        Should.Throw<DivideByZeroException>(() => { number2.Div(0); });
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L227-234)
```csharp
    private void UpdateConsensusInformation(ByteString bytes)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        Context.SendInline(State.CrossChainInteractionContract.Value,
            nameof(State.CrossChainInteractionContract.UpdateInformationFromCrossChain),
            new BytesValue { Value = bytes });
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L720-743)
```csharp
    private bool ValidateParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData,
        out Dictionary<int, List<ParentChainBlockData>> validatedParentChainBlockData)
    {
        var parentChainId = State.ParentChainId.Value;
        var currentHeight = State.CurrentParentChainHeight.Value;
        validatedParentChainBlockData = new Dictionary<int, List<ParentChainBlockData>>();
        foreach (var blockData in parentChainBlockData)
        {
            if (parentChainId != blockData.ChainId || currentHeight + 1 != blockData.Height ||
                blockData.TransactionStatusMerkleTreeRoot == null)
                return false;
            if (blockData.IndexedMerklePath.Any(indexedBlockInfo =>
                    State.ChildHeightToParentChainHeight[indexedBlockInfo.Key] != 0 ||
                    State.TxRootMerklePathInParentChain[indexedBlockInfo.Key] != null))
                return false;

            currentHeight += 1;
        }

        if (parentChainBlockData.Count > 0)
            validatedParentChainBlockData[parentChainId] = parentChainBlockData.ToList();

        return true;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L783-788)
```csharp
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L349-354)
```csharp
    private bool IsMainChainMinerListChanged(Round currentRound)
    {
        return State.MainChainCurrentMinerList.Value.Pubkeys.Any() &&
               GetMinerListHash(currentRound.RealTimeMinersInformation.Keys) !=
               GetMinerListHash(State.MainChainCurrentMinerList.Value.Pubkeys.Select(p => p.ToHex()));
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```
