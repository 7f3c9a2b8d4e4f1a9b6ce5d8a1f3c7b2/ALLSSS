### Title
UTF-16/UTF-8 Encoding Mismatch Allows Bypass of Description Length Limits in Governance Contracts

### Summary
The Parliament, Association, and Referendum contracts validate proposal description length using C# `string.Length`, which counts UTF-16 code units rather than actual storage bytes. An attacker can submit descriptions containing Unicode supplementary plane characters (requiring surrogate pairs) to consume up to 2x the intended storage while passing validation, leading to state bloat and ineffective resource limits.

### Finding Description

**Location:** [1](#0-0) 

The validation uses: `Assert(input.Description.Length <= ParliamentConstants.MaxLengthForDescription, "Description is too long.");`

Where `MaxLengthForDescription = 10200`: [2](#0-1) 

**Root Cause:**

In C#, `string.Length` returns the number of UTF-16 code units (Char objects), not Unicode code points or storage bytes. Characters from Unicode Supplementary Planes (U+10000 to U+10FFFF) require surrogate pairsâ€”two UTF-16 code units per character.

However, when `ProposalInfo` is serialized and stored, strings are encoded as UTF-8: [3](#0-2) 

Characters requiring surrogate pairs in UTF-16 encode to 4 bytes in UTF-8. State size validation occurs after serialization: [4](#0-3) 

**Execution Path:**
1. `CreateProposal()` called with description containing 5,100 emoji/supplementary plane characters [5](#0-4) 

2. Validation checks UTF-16 code units: 5,100 characters Ã— 2 = 10,200 code units â‰¤ 10,200 âœ“ [6](#0-5) 

3. Proposal stored with actual UTF-8 size: 5,100 characters Ã— 4 bytes = 20,400 bytes [7](#0-6) 

**Why Existing Protections Fail:**

The codebase correctly validates memo fields using UTF-8 byte counts: [8](#0-7) 

But governance contracts use the incorrect `.Length` approach. The same vulnerability exists in Association and Referendum contracts: [9](#0-8) [10](#0-9) 

### Impact Explanation

**Concrete Harm:**
- **State Bloat:** Proposals consume up to 20,400 bytes instead of the intended 10,200 byte limit (2x inflation)
- **Resource Exhaustion:** Multiple such proposals accelerate consumption of contract state storage
- **Ineffective Limits:** The MaxLengthForDescription constant fails to enforce its intended purpose of limiting storage consumption

**Who is Affected:**
- All chains running Parliament, Association, and Referendum contracts
- Validators bearing storage costs
- The blockchain network suffering from inflated state size

**Severity Justification (Medium):**
- No direct fund theft or governance bypass
- Storage fees are still paid correctly (based on actual transaction size)
- But allows systematic evasion of intended resource limits
- Operational impact through state bloat and potential DoS contribution
- Easy to exploit by authorized proposers

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an authorized proposer (standard requirement for creating proposals)
- No special privileges beyond normal proposer authorization required

**Attack Complexity:**
- Low: Simply include emoji or other supplementary plane characters in description
- Common characters like ðŸ˜€ðŸŽ‰ðŸš€ are readily available and require surrogate pairs
- No complex transaction sequencing needed

**Feasibility Conditions:**
- Proposer authorization already granted (normal operational state)
- No unusual blockchain state required
- Works on any governance contract deployment

**Detection Constraints:**
- Difficult to distinguish malicious from legitimate use of emoji/special characters
- Appears as valid proposal within length limits from validation perspective
- Only detectable by examining actual UTF-8 byte size vs. UTF-16 code unit count

**Probability:** High for authorized proposers with intent to maximize description space or bloat state.

### Recommendation

**Code-Level Mitigation:**

Replace UTF-16 code unit validation with UTF-8 byte count validation in all three governance contracts:

```csharp
// In Parliament_Helper.cs, Association_Helper.cs, Referendum_Helper.cs
private void CheckCreateProposalInput(CreateProposalInput input)
{
    Assert(Encoding.UTF8.GetByteCount(input.Title) <= ParliamentConstants.MaxLengthForTitle, 
        "Title is too long.");
    Assert(Encoding.UTF8.GetByteCount(input.Description) <= ParliamentConstants.MaxLengthForDescription, 
        "Description is too long.");
    Assert(Encoding.UTF8.GetByteCount(input.ProposalDescriptionUrl) <= ParliamentConstants.MaxLengthForProposalDescriptionUrl,
        "Description url is too long.");
}
```

**Invariant Checks:**
- Ensure all string length validations measure UTF-8 bytes, not UTF-16 code units
- Add explicit checks that serialized ProposalInfo size doesn't exceed expected bounds

**Test Cases:**
- Test proposal creation with 5,100 surrogate pair characters (should fail after fix)
- Test with 10,200 ASCII characters (should still pass)
- Test with 2,550 surrogate pair characters (should pass, ~10,200 bytes in UTF-8)
- Verify same fix across Parliament, Association, and Referendum contracts

### Proof of Concept

**Initial State:**
- Parliament contract deployed and initialized
- Attacker has proposer authorization for an organization

**Attack Sequence:**

1. Construct description with 5,100 emoji characters (e.g., 5,100 Ã— "ðŸ˜€"):
   - UTF-16 representation: 10,200 code units
   - UTF-8 representation: 20,400 bytes

2. Call `CreateProposal()` with this description:
   ```
   CreateProposalInput {
       OrganizationAddress: <valid_org>,
       Description: "ðŸ˜€ðŸ˜€ðŸ˜€..." (5,100 emoji),
       Title: "Test",
       ... other fields ...
   }
   ```

3. **Expected Result (Current):** 
   - Validation passes: `input.Description.Length (10,200) <= MaxLengthForDescription (10,200)` âœ“
   - Proposal created successfully
   - Actual storage consumed: 20,400 bytes

4. **Expected Result (After Fix):**
   - Validation fails: `Encoding.UTF8.GetByteCount(input.Description) (20,400) > MaxLengthForDescription (10,200)` âœ—
   - Transaction reverts with "Description is too long"

**Success Condition:** 
Attacker successfully creates proposal with description consuming 20,400 bytes while passing a 10,200 unit validation limit, demonstrating 2x storage consumption bypass.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L227-227)
```csharp
        CheckCreateProposalInput(input);
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L244-244)
```csharp
        State.Proposals[proposalId] = proposal;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L260-260)
```csharp
        Assert(input.Description.Length <= ParliamentConstants.MaxLengthForDescription, "Description is too long.");
```

**File:** contract/AElf.Contracts.Parliament/ParliamentConstants.cs (L6-6)
```csharp
    public const int MaxLengthForDescription = 10200;
```

**File:** src/AElf.Types/Helper/SerializationHelper.cs (L75-75)
```csharp
            if (type == typeof(string)) return Encoding.UTF8.GetBytes((string)value);
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L156-156)
```csharp
        var size = SerializationHelper.Serialize(obj).Length;
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-66)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L88-92)
```csharp
    private void AssertValidMemo(string memo)
    {
        Assert(memo == null || Encoding.UTF8.GetByteCount(memo) <= TokenContractConstants.MemoMaxLength,
            "Invalid memo size.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L180-180)
```csharp
        Assert(input.Description.Length <= AssociationConstants.MaxLengthForDescription, "Description is too long.");
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L194-194)
```csharp
        Assert(input.Description.Length <= ReferendumConstants.MaxLengthForDescription, "Description is too long.");
```
