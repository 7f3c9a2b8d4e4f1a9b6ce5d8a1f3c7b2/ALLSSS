### Title
Unvalidated Options Array Clone in Voting Registration Creates Resource-Based DoS Vector

### Summary
The `GetHash` extension method clones the entire `VotingRegisterInput` structure including a potentially large `options` array before validation, then immediately discards the options data. An attacker can submit a `Register` transaction with options arrays approaching the 5MB transaction limit, causing expensive memory allocation and copying operations that execute before any input validation, enabling resource exhaustion attacks on the voting system.

### Finding Description

The vulnerability exists in the vote registration flow where hash computation occurs before input validation. [1](#0-0) 

The `GetHash` method performs a full `Clone()` operation on the input object, which includes the `options` repeated string field that can contain numerous long strings. The protobuf definition shows this field is unbounded: [2](#0-1) 

In the `Register` method, `GetHash` is called immediately through `AssertValidNewVotingItem` before any validation on the options: [3](#0-2) [4](#0-3) 

The validation constants `MaximumOptionsCount` (64) and `OptionLengthLimit` (1024) exist but are only enforced in `AddOption`, `AddOptions`, and voting operations - NOT during initial registration: [5](#0-4) [6](#0-5) 

The transaction size limit of 5MB provides an upper bound but still allows substantial attack payloads: [7](#0-6) 

### Impact Explanation

An attacker can craft `Register` transactions with `VotingRegisterInput` containing:
- Hundreds to thousands of options (no count validation before `GetHash`)
- Each option string of several thousand characters (no length validation before `GetHash`)  
- Total payload approaching 5MB transaction limit

The `Clone()` operation duplicates this entire structure in memory, doubling the memory footprint temporarily. This wasted computation happens before any validation checks. Multiple concurrent such transactions could:
- Exhaust node memory resources
- Slow down transaction processing
- Increase costs for legitimate voting registration
- Create network congestion as nodes process invalid transactions

The attack doesn't steal funds but degrades voting system availability and operational efficiency. Severity is Medium due to operational impact on a core governance component.

### Likelihood Explanation

**Attacker Capabilities:** Any address can call the public `Register` method without special permissions.

**Attack Complexity:** Low - attacker simply constructs a `VotingRegisterInput` with a large options array and submits it.

**Economic Feasibility:** While transaction fees apply, the attack requires no token lock-up (unlike voting itself) and a single malicious registration can consume significant resources. The attacker pays transaction fees but causes disproportionate resource consumption.

**Detection:** The transactions would fail validation eventually, but resource consumption occurs first. Repeated attempts from multiple addresses could sustain the attack.

**Probability:** Medium - the attack is straightforward to execute and economically viable for motivated attackers seeking to disrupt governance processes.

### Recommendation

Add validation in `AssertValidNewVotingItem` before calling `GetHash`:

```csharp
private Hash AssertValidNewVotingItem(VotingRegisterInput input)
{
    // Validate options BEFORE calling GetHash
    Assert(input.Options.Count <= VoteContractConstants.MaximumOptionsCount, 
        $"The count of options can't be greater than {VoteContractConstants.MaximumOptionsCount}");
    
    foreach (var option in input.Options)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, 
            "Option length exceeds limit.");
    }
    
    // Use input without options and sender's address to calculate voting item id.
    var votingItemId = input.GetHash(Context.Sender);
    // ... rest of existing validation
}
```

Alternatively, optimize `GetHash` to avoid cloning options entirely:

```csharp
public static Hash GetHash(this VotingRegisterInput votingItemInput, Address sponsorAddress)
{
    var input = new VotingRegisterInput
    {
        StartTimestamp = votingItemInput.StartTimestamp,
        EndTimestamp = votingItemInput.EndTimestamp,
        AcceptedCurrency = votingItemInput.AcceptedCurrency,
        IsLockToken = votingItemInput.IsLockToken,
        TotalSnapshotNumber = votingItemInput.TotalSnapshotNumber,
        IsQuadratic = votingItemInput.IsQuadratic,
        TicketCost = votingItemInput.TicketCost
        // Explicitly omit Options field
    };
    return HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(input), HashHelper.ComputeFrom(sponsorAddress));
}
```

Add test cases validating rejection of oversized options during registration.

### Proof of Concept

**Initial State:** Attacker has an address with sufficient balance to pay transaction fees.

**Attack Steps:**

1. Construct malicious `VotingRegisterInput`:
   - Create options array with 1000 strings
   - Each string contains 5000 characters (total ~5MB payload)
   - Set valid timestamps and other required fields

2. Submit `Register` transaction with this input

3. During execution:
   - `AssertValidNewVotingItem` is called (line 22)
   - `GetHash` is invoked (line 354)
   - `Clone()` duplicates entire 5MB structure including all options (line 9)
   - Memory allocation and copying occurs
   - `Options.Clear()` discards the cloned options (line 10)
   - Only then does execution continue with validation

**Expected Result:** Transaction should reject oversized options before expensive operations.

**Actual Result:** Expensive clone operation executes first, consuming resources before validation occurs. Transaction eventually fails but resource damage is done.

**Success Condition:** Attacker can repeatedly submit such transactions, each causing temporary memory doubling and wasted computation cycles, degrading node performance and voting system availability.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteExtensions.cs (L7-12)
```csharp
    public static Hash GetHash(this VotingRegisterInput votingItemInput, Address sponsorAddress)
    {
        var input = votingItemInput.Clone();
        input.Options.Clear();
        return HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(input), HashHelper.ComputeFrom(sponsorAddress));
    }
```

**File:** protobuf/vote_contract.proto (L87-104)
```text
message VotingRegisterInput {
    // The start time of the voting.
    google.protobuf.Timestamp start_timestamp = 1;
    // The end time of the voting.
    google.protobuf.Timestamp end_timestamp = 2;
    // The token symbol which will be accepted.
    string accepted_currency = 3;
    // Whether the vote will lock token.
    bool is_lock_token = 4;
    // The total number of snapshots of the vote.
    int64 total_snapshot_number = 5;
    // The list of options.
    repeated string options = 6;
    // Is quadratic voting.
    bool is_quadratic = 7;
    // Quadratic voting item ticket cost.
    int64 ticket_cost = 8;
}
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-22)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L280-290)
```csharp
    public override Empty AddOption(AddOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        AssertOption(votingItem, input.Option);
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        votingItem.Options.Add(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L3-7)
```csharp
public static class VoteContractConstants
{
    public const int MaximumOptionsCount = 64;
    public const int OptionLengthLimit = 1024;
}
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L3-6)
```csharp
public class TransactionPoolConsts
{
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
}
```
