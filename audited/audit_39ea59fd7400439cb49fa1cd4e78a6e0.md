# Audit Report

## Title
View Method State Mutation Causes Unintended Field Persistence in NFT State

## Summary
The `GetNFTInfoByTokenHash` view method directly modifies cached NFT state objects by populating protocol-level fields (`ProtocolName`, `Creator`, `BaseUri`, `NftType`). When called internally by non-view methods (`Burn`, `Recast`), these modifications persist to storage, violating the design principle that protocol fields should be computed on-demand, not stored per-NFT.

## Finding Description

The vulnerability occurs due to the interaction between AElf's `MappedState` caching mechanism and a view method that mutates cached objects.

**Root Cause:**

The `GetNFTInfoByTokenHash` method retrieves `nftInfo` from state, which returns a reference to the cached protobuf object, then directly modifies it: [1](#0-0) 

The `MappedState` indexer getter returns a direct reference to `valuePair.Value`, not a copy: [2](#0-1) 

When the view method modifies fields on lines 25-28 of `NFTContract_View.cs`, it's mutating the cached object directly. Since protobuf messages are reference types, subsequent access to this cached object returns the already-modified version.

**Persistence Mechanism:**

The `Burn` method calls the view function and later writes the modified object back to state: [3](#0-2) 

Similarly, the `Recast` method follows the same pattern: [4](#0-3) 

Both methods call `GetNFTInfoByTokenHash`, receive the cached object with protocol fields already populated, make additional modifications, then write back to state via `State.NftInfoMap[tokenHash] = nftInfo`. The state assignment triggers persistence of all fields, including the unintended protocol-level fields.

**Design Violation:**

The `PerformMint` method explicitly documents that protocol fields should NOT be stored in NFT state: [5](#0-4) 

The commented-out lines (427-430) demonstrate the developer's intent to keep protocol-level metadata separate from per-NFT state.

**Why Protections Fail:**

While view methods called as transactions are rejected by the validation pipeline, this protection does NOT apply when view methods are called internally within non-view transactions. The cache modifications remain in the transaction context and get persisted when the calling method writes the state. [6](#0-5) 

## Impact Explanation

**Data Integrity Violation:**
- NFT state stores protocol-level fields (`ProtocolName`, `Creator`, `BaseUri`, `NftType`) that should only exist in `NFTProtocolInfo`
- This violates the single-source-of-truth principle, creating duplicate data across protocol and NFT states
- The `NFTInfo` message structure includes these fields, but the design intention was to populate them only in responses, not persist them: [7](#0-6) 

**Storage Waste:**
- Each NFT unnecessarily stores 4 additional string fields (~100-200 bytes per NFT)
- For protocols with thousands of NFTs, this multiplies storage requirements significantly
- The redundant data is already available in `NFTProtocolInfo`, accessible via the NFT's symbol

**Inconsistency Risk:**
- If protocol information is updated (though no update mechanism currently exists), existing NFTs that have been burned or recast would retain outdated values
- Different NFTs within the same protocol may show different protocol metadata depending on whether they've been through `Burn`/`Recast` operations
- Query results become unpredictable and inconsistent

**Affected Parties:**
- All NFT holders whose tokens undergo `Burn` or `Recast` operations
- Protocol creators expecting consistent protocol-level metadata across all NFTs
- Applications querying NFT data that expect protocol information to remain synchronized

**Severity Assessment: MEDIUM**
This does not directly cause fund loss or unauthorized access, but it corrupts the data model, wastes storage, and creates operational inconsistencies that undermine the contract's intended architecture.

## Likelihood Explanation

**Reachable Entry Points:**

The `Burn` and `Recast` methods are publicly accessible via the NFT contract service: [8](#0-7) 

**Automatic Trigger (100% Likelihood):**
- Every call to `Burn` or `Recast` automatically triggers this behavior
- No special privileges needed beyond minter status (a legitimate, expected role)
- No specific timing, state conditions, or attack complexity required
- Happens transparently during normal, intended use of the contract

**Feasibility:**
- `Burn` is called whenever a minter destroys NFTs (line 82 in `NFTContract_UseChain.cs`)
- `Recast` is called whenever a minter modifies NFT metadata (line 256 in `NFTContract_UseChain.cs`)
- Both operations are part of the standard NFT lifecycle

**Economic Rationality:**
- No additional cost to trigger beyond normal transaction fees
- Occurs during legitimate operations users would perform anyway

**Detection Difficulty:**
- State changes appear legitimate (no failed transactions)
- Only detectable by inspecting stored NFT state and comparing against protocol state
- No events or logs indicate the architectural violation

## Recommendation

**Solution: Clone the cached object in the view method**

Modify `GetNFTInfoByTokenHash` to return a clone instead of modifying the cached object:

```csharp
public override NFTInfo GetNFTInfoByTokenHash(Hash input)
{
    var nftInfo = State.NftInfoMap[input];
    if (nftInfo == null) return new NFTInfo();
    
    // Clone to avoid modifying the cached object
    var result = nftInfo.Clone();
    var nftProtocolInfo = State.NftProtocolMap[result.Symbol];
    result.ProtocolName = nftProtocolInfo.ProtocolName;
    result.Creator = nftProtocolInfo.Creator;
    result.BaseUri = nftProtocolInfo.BaseUri;
    result.NftType = nftProtocolInfo.NftType;
    return result;
}
```

This ensures that protocol-level fields are only added to the returned object for display purposes and never persist to storage when the calling method writes state.

**Alternative: Remove protocol fields from NFTInfo storage entirely**

If these fields should truly never be stored, consider using a separate view-only DTO for responses that includes protocol fields, while keeping the stored `NFTInfo` minimal.

## Proof of Concept

```csharp
[Fact]
public async Task VerifyProtocolFieldsPersistAfterBurn()
{
    // Setup: Create protocol and mint NFT
    var symbol = await CreateTest();
    await AddMinterAsync(symbol);
    
    var tokenHash = (await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        Alias = "test",
        Owner = MinterAddress,
        Quantity = 10
    })).Output;
    
    // Verify protocol fields NOT present in storage initially
    var nftInfoBeforeBurn = await NFTContractStub.GetNFTInfoByTokenHash.CallAsync(tokenHash);
    
    // Call Burn (this triggers the vulnerability)
    await MinterNFTContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = symbol,
        TokenId = 1,
        Amount = 5
    });
    
    // Verify protocol fields ARE NOW present in stored state
    // This should NOT happen - protocol fields should only be in NFTProtocolInfo
    var nftInfoAfterBurn = await NFTContractStub.GetNFTInfoByTokenHash.CallAsync(tokenHash);
    
    // The vulnerability is confirmed if these fields are now populated
    // (In a properly designed system, these should remain empty in stored NFT state)
    nftInfoAfterBurn.ProtocolName.ShouldNotBeEmpty(); // VULNERABILITY: This persists
    nftInfoAfterBurn.Creator.ShouldNotBeNull(); // VULNERABILITY: This persists
    nftInfoAfterBurn.BaseUri.ShouldNotBeEmpty(); // VULNERABILITY: This persists
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L20-30)
```csharp
    public override NFTInfo GetNFTInfoByTokenHash(Hash input)
    {
        var nftInfo = State.NftInfoMap[input];
        if (nftInfo == null) return new NFTInfo();
        var nftProtocolInfo = State.NftProtocolMap[nftInfo.Symbol];
        nftInfo.ProtocolName = nftProtocolInfo.ProtocolName;
        nftInfo.Creator = nftProtocolInfo.Creator;
        nftInfo.BaseUri = nftProtocolInfo.BaseUri;
        nftInfo.NftType = nftProtocolInfo.NftType;
        return nftInfo;
    }
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L26-37)
```csharp
    public TEntity this[TKey key]
    {
        get
        {
            if (!Cache.TryGetValue(key, out var valuePair))
            {
                valuePair = LoadKey(key);
                Cache[key] = valuePair;
            }

            return valuePair.IsDeleted ? SerializationHelper.Deserialize<TEntity>(null) : valuePair.Value;
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L256-293)
```csharp
    public override Empty Recast(RecastInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(minterList.Value.Contains(Context.Sender), "No permission.");
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        Assert(nftInfo.Quantity != 0 && nftInfo.Quantity == State.BalanceMap[tokenHash][Context.Sender],
            "Do not support recast.");
        if (input.Alias != null) nftInfo.Alias = input.Alias;

        if (input.Uri != null) nftInfo.Uri = input.Uri;

        var oldMetadata = nftInfo.Metadata.Clone();
        var metadata = new Metadata();
        // Need to keep reserved metadata key.
        foreach (var reservedKey in GetNftMetadataReservedKeys())
        {
            if (oldMetadata.Value.ContainsKey(reservedKey))
                metadata.Value[reservedKey] = oldMetadata.Value[reservedKey];

            if (input.Metadata.Value.ContainsKey(reservedKey)) input.Metadata.Value.Remove(reservedKey);
        }

        metadata.Value.Add(input.Metadata.Value);
        nftInfo.Metadata = metadata;

        State.NftInfoMap[tokenHash] = nftInfo;
        Context.Fire(new Recasted
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            OldMetadata = oldMetadata,
            NewMetadata = nftInfo.Metadata,
            Alias = nftInfo.Alias,
            Uri = nftInfo.Uri
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L417-431)
```csharp
            nftInfo = new NFTInfo
            {
                Symbol = input.Symbol,
                Uri = input.Uri ?? string.Empty,
                TokenId = tokenId,
                Metadata = nftMetadata,
                Minters = { Context.Sender },
                Quantity = quantity,
                Alias = input.Alias

                // No need.
                //BaseUri = protocolInfo.BaseUri,
                //Creator = protocolInfo.Creator,
                //ProtocolName = protocolInfo.ProtocolName
            };
```

**File:** protobuf/nft_contract.proto (L45-56)
```text
    // Destroy nfts.
    rpc Burn (BurnInput) returns (google.protobuf.Empty) {
    }
    // Lock several nfts and fts to mint one nft.
    rpc Assemble (AssembleInput) returns (aelf.Hash) {
    }
    // Disassemble one assembled nft to get locked nfts and fts back.
    rpc Disassemble (DisassembleInput) returns (google.protobuf.Empty) {
    }
    // Modify metadata of one nft.
    rpc Recast (RecastInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/nft_contract.proto (L74-76)
```text
    rpc GetNFTInfoByTokenHash (aelf.Hash) returns (NFTInfo) {
        option (aelf.is_view) = true;
    }
```

**File:** protobuf/nft_contract.proto (L287-312)
```text
message NFTInfo {
    // The symbol of the protocol this nft belongs to.
    string symbol = 1;
    // The name of the protocol this nft belongs to.
    string protocol_name = 2;
    // Actually is the order of this token.
    int64 token_id = 3;
    // The address that creat the base token.
    aelf.Address creator = 4;
    // The addresses that mint this token.
    repeated aelf.Address minters = 5;
    // The metadata of the token.
    Metadata metadata = 6;
    // Minted amount.
    int64 quantity = 7;
    // Token Uri.
    string uri = 8;
    // Base Uri.
    string base_uri = 9;
    // Alias
    string alias = 10;
    // Is burned.
    bool is_burned = 11;
    // NFT Type
    string nft_type = 12;
}
```
