### Title
LIB Index Calculation Violates Byzantine Fault Tolerance Threshold

### Summary
The Last Irreversible Block (LIB) height calculation in `LastIrreversibleBlockHeightCalculator.Deconstruct()` uses an incorrect index formula `(Count-1)/3` that fails to ensure the required 2/3+1 consensus threshold. When exactly `MinersCountOfConsent` miners participate, the algorithm selects a height where only `MinersCountOfConsent-1` miners have confirmed, violating the Byzantine Fault Tolerance requirement and allowing manipulation through selective miner participation. [1](#0-0) 

### Finding Description
The LIB calculation retrieves miners who mined in the current round and their `ImpliedIrreversibleBlockHeight` values from the previous round, sorts them in ascending order, and selects the height at index `(Count-1)/3`. [2](#0-1) 

The algorithm checks that `Count >= MinersCountOfConsent` where `MinersCountOfConsent = (TotalMiners * 2/3) + 1`. [3](#0-2) 

**Root Cause**: In a sorted ascending array, selecting index `i` means `(Count - i)` miners have reported this height or higher. For proper BFT consensus requiring at least `MinersCountOfConsent` confirmations, the correct formula should be `i = Count - MinersCountOfConsent` to ensure `Count - i >= MinersCountOfConsent`.

**Mathematical Proof of Failure**:
- For 7 total miners: `MinersCountOfConsent = 5`
- When exactly 5 miners participate (minimum threshold):
  - Current formula: `Index = (5-1)/3 = 1`
  - Miners at or above selected height: `5-1 = 4`
  - **Required**: 5 miners, **Actual**: 4 miners (VIOLATION!)

The existing check on line 26 only validates that enough miners participated, but doesn't ensure the selected index maintains the consensus threshold. [4](#0-3) 

### Impact Explanation
**Consensus Integrity Violation**: The LIB can be set to a height where fewer than 2/3+1 miners have confirmed, breaking the fundamental Byzantine Fault Tolerance guarantee. This compromises chain finality.

**Manipulation Attack**: An attacker controlling network resources can selectively prevent specific miners (particularly those reporting higher LIB heights) from mining through DoS attacks. By reducing the participant count from 7→6→5, the index calculation shifts, potentially selecting a significantly lower LIB height.

**Concrete Example**:
- 7 miners with heights `[100, 110, 120, 130, 140, 150, 160]`
- Normal case (all 7 mine): Index=2, LIB=120, 5 miners confirm (71%)
- Attack case (5 mine after DoS): Index=1, LIB=110, only 4 miners confirm (57% < 67%)

**Chain Security Impact**: A lower-than-correct LIB means blocks that should be irreversible remain reversible longer, enabling:
- Extended reorganization attack windows
- Double-spend vulnerability windows
- Cross-chain message rollback risks (as LIB is used for cross-chain indexing)

The severity is **Medium** as it requires sustained DoS capability but directly undermines consensus finality guarantees.

### Likelihood Explanation
**Attack Prerequisites**:
1. Identify miners reporting higher LIB heights (observable from previous round chain data)
2. Launch DoS attacks against specific miners to prevent their block production
3. Maintain attack during critical LIB calculation windows

**Feasibility**: Network-level DoS against known miner IPs is realistic for well-resourced attackers. The AElf consensus uses public miner lists, making targeting feasible. [5](#0-4) 

**Attack Complexity**: Moderate - requires:
- Network infrastructure for targeted DoS
- Chain monitoring to identify victim miners
- Timing to coincide with LIB calculation (occurs on each `UpdateValue` call) [6](#0-5) 

**Detection**: The attack leaves observable patterns (specific miners consistently missing slots while others mine normally), but may be attributed to network issues rather than malicious activity.

**Economic Rationality**: For an attacker attempting double-spends or cross-chain exploits worth more than DoS costs, the attack is economically viable.

### Recommendation
**Fix the Index Calculation**:
Replace line 32 with the mathematically correct formula:
```csharp
libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count - _currentRound.MinersCountOfConsent];
```

This ensures that exactly `MinersCountOfConsent` miners are at or above the selected LIB height, maintaining the 2/3+1 BFT requirement.

**Add Validation Assertion**:
```csharp
var selectedIndex = impliedIrreversibleHeights.Count - _currentRound.MinersCountOfConsent;
Assert(selectedIndex >= 0 && selectedIndex < impliedIrreversibleHeights.Count, 
    "Invalid LIB index calculation");
Assert(impliedIrreversibleHeights.Count - selectedIndex >= _currentRound.MinersCountOfConsent,
    "LIB selection violates consensus threshold");
libHeight = impliedIrreversibleHeights[selectedIndex];
```

**Test Cases**:
1. Verify with exactly `MinersCountOfConsent` miners that selected height has all participants confirming
2. Test edge cases: Count = MinersCountOfConsent, Count = MinersCountOfConsent+1, Count = TotalMiners
3. Verify that removing high-height reporters doesn't inappropriately lower LIB

### Proof of Concept
**Initial State**:
- Blockchain with 7 miners in current round
- Previous round recorded: Miner A=100, B=110, C=120, D=130, E=140, F=150, G=160
- `MinersCountOfConsent = (7*2/3)+1 = 5`

**Attack Sequence**:
1. Attacker monitors previous round and identifies Miners F and G reported highest LIB (150, 160)
2. During current round, attacker launches DoS against Miners F and G
3. Only Miners A, B, C, D, E successfully mine (Count=5)
4. LIB calculation executes in `ProcessUpdateValue`:
   - `impliedIrreversibleHeights = [100, 110, 120, 130, 140]` (sorted)
   - Check: `5 >= 5` ✓ (passes minimum threshold)
   - Index: `(5-1)/3 = 1`
   - Selected LIB: `110` (at index 1)
   - Miners confirming 110 or above: indices 1,2,3,4 = **4 miners only**

**Expected vs Actual**:
- **Expected**: LIB should be 100 (index 0) where all 5 miners confirm
- **Actual**: LIB is 110 (index 1) where only 4 miners confirm
- **Violation**: Only 4/7 (57%) miners confirm, below 5/7 (71%) BFT threshold

**Success Condition**: The vulnerability is confirmed when the LIB calculation with Count=MinersCountOfConsent produces a result where `(Count - Index) < MinersCountOfConsent`, violating the consensus invariant.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L223-236)
```csharp
    private void RecordMinedMinerListOfCurrentRound()
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        State.MinedMinerListMap.Set(currentRound.RoundNumber, new MinerList
        {
            Pubkeys = { currentRound.GetMinedMiners().Select(m => ByteStringHelper.FromHexString(m.Pubkey)) }
        });

        // Remove information out of date.
        var removeTargetRoundNumber = currentRound.RoundNumber.Sub(3);
        if (removeTargetRoundNumber > 0 && State.MinedMinerListMap[removeTargetRoundNumber] != null)
            State.MinedMinerListMap.Remove(removeTargetRoundNumber);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```
