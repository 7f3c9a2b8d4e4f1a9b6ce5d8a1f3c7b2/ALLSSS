### Title
Association Proposal Validation Allows Zero Address Leading to Permanent Proposal Failure

### Summary
The `Validate(ProposalInfo)` function in Association_Helper.cs only checks if `proposal.ToAddress` is null, but does not validate whether it is a zero address (all bytes 0x00). A zero address can be created as a valid non-null Address object, pass validation, get approved, but will always fail during release when attempting to execute the inline transaction, leaving the proposal permanently stuck in an approved but unreleasable state.

### Finding Description
The validation logic at line 85 of `Association_Helper.cs` performs only a null reference check: [1](#0-0) 

In AElf, Address is a reference type (class) that wraps a ByteString value. An address with all zero bytes can be created using `Address.FromBytes(new byte[32])`, which produces a non-null Address object that passes the null check. [2](#0-1) 

When a proposal with a zero address is released, the Release method creates an inline transaction to that address: [3](#0-2) 

During execution, the system attempts to retrieve the contract executive for the zero address. This calls `GetSmartContractRegistrationAsync` which eventually queries the zero contract for the registration: [4](#0-3) 

Since no contract exists at the zero address (contract addresses are computed from hashes and a result of all zeros is virtually impossible), the inline transaction fails. In AElf, inline transaction failures cause the parent transaction to fail and roll back: [5](#0-4) 

The proposal removal on line 198 never executes, leaving the proposal permanently in state.

### Impact Explanation
**Operational Impact - Medium Severity:**
- **Stuck Proposals**: Approved proposals with zero addresses cannot be released, permanently occupying state storage until expiration (line 286-288 cleanup).
- **Gas Wastage**: Each failed Release attempt consumes transaction gas with no possibility of success.
- **Organization DoS**: Multiple such proposals can clog an organization's governance process, especially if the proposer whitelist is compromised or contains malicious members.
- **Resource Lock**: The proposal ID and state entry remain locked until `ClearProposal` is called after expiration.

The severity is Medium rather than High because:
- Only whitelisted proposers can create proposals (trusted role).
- No direct fund theft or unauthorized state changes occur.
- Proposals eventually expire and can be cleared.

### Likelihood Explanation
**Likelihood: Medium**

**Attacker Capabilities Required:**
- Must be in the organization's proposer whitelist (requires trust or compromise).
- Can construct proposals with arbitrary ToAddress values.

**Attack Complexity: Low**
Creating a zero address is trivial: `Address.FromBytes(new byte[32])`. The attack requires no special knowledge or complex setup.

**Feasibility Conditions:**
- Attacker has proposer whitelist access (trusted insider or compromised account).
- Can submit CreateProposal transactions.
- Organization members approve the proposal (social engineering or legitimate-looking proposal).

**Economic Rationality:**
- Low cost to proposer (only CreateProposal gas).
- High cost to organization (repeated Release attempts, governance disruption).
- Viable for disgruntled insiders or compromised accounts.

**Detection Constraints:**
The zero address would be visible in proposal details, but may not be immediately recognized as invalid by reviewers if disguised with legitimate-looking method names and parameters.

### Recommendation

**Immediate Fix:**
Add explicit zero address validation in the `Validate(ProposalInfo)` function:

```csharp
private bool Validate(ProposalInfo proposal)
{
    if (proposal.ToAddress == null || proposal.ToAddress.Value.IsNullOrEmpty() ||
        string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
        !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
        return false;

    return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
}
```

**Additional Validation (Stronger):**
Follow the pattern used in TokenContract for address validation: [6](#0-5) 

Apply this pattern to check if ToAddress points to a valid contract by verifying it against the contract registry, similar to how other contracts validate system contract addresses.

**Test Cases to Add:**
1. Test proposal creation with `Address.FromBytes(new byte[32])` - should fail validation.
2. Test proposal creation with null ToAddress - should fail validation (existing behavior).
3. Test proposal creation with empty ByteString ToAddress - should fail validation.
4. Test Release with non-existent contract address - should fail gracefully with clear error message.

### Proof of Concept

**Required Initial State:**
1. Association organization created with proposer whitelist containing malicious/compromised address.
2. Organization has approval threshold of N members.

**Transaction Steps:**

```csharp
// Step 1: Malicious proposer creates proposal with zero address
var zeroAddress = Address.FromBytes(new byte[32]);
var createProposalInput = new CreateProposalInput
{
    ToAddress = zeroAddress,  // All zeros - not null but invalid
    ContractMethodName = "SomeMethod",
    Params = ByteString.Empty,
    ExpiredTime = blockTime.AddDays(1),
    OrganizationAddress = organizationAddress
};
var proposalId = await AssociationContractStub.CreateProposal.SendAsync(createProposalInput);
// ACTUAL: Succeeds, proposal created

// Step 2: Organization members approve (N approvals reached)
for (int i = 0; i < N; i++)
{
    await GetAssociationContractTester(reviewerKeyPairs[i])
        .Approve.SendAsync(proposalId.Output);
}
// ACTUAL: Succeeds, proposal approved

// Step 3: Proposer attempts to release
var releaseResult = await AssociationContractStub.Release.SendAsync(proposalId.Output);
// EXPECTED: Success, proposal executed and removed from state
// ACTUAL: TransactionResultStatus.Failed with error "failed to find registration from zero contract"
// Proposal remains in state, can never be released

// Step 4: Verify proposal still exists
var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId.Output);
// ACTUAL: Proposal still exists with ToBeReleased = true
// Gas wasted, governance blocked until expiration
```

**Success Condition for Attack:**
Proposal passes validation, gets approved, but Release permanently fails, demonstrating the vulnerability.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L85-86)
```csharp
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
```

**File:** src/AElf.Types/Types/Address.cs (L49-58)
```csharp
        public static Address FromBytes(byte[] bytes)
        {
            if (bytes.Length != AElfConstants.AddressHashLength)
                throw new ArgumentException("Invalid bytes.", nameof(bytes));

            return new Address
            {
                Value = ByteString.CopyFrom(bytes)
            };
        }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L189-191)
```csharp
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L198-198)
```csharp
        State.Proposals.Remove(input);
```

**File:** src/AElf.Kernel.SmartContract/Application/SmartContractExecutiveService.cs (L196-197)
```csharp
        throw new SmartContractFindRegistrationException(
            $"failed to find registration from zero contract {txContext.Trace.Error}");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```
