# Audit Report

## Title
Missing Resource Amount Validation for Non-Exclusive Side Chains Allows Rental Fee Evasion

## Summary
The CrossChain contract's validation logic for side chain creation contains a critical bypass that allows non-exclusive side chains to evade resource rental fees. When `IsPrivilegePreserved` is set to `false`, the validation returns early without checking that all required resource symbols are present in `InitialResourceAmount`, enabling side chains to be initialized with incomplete resource allocations that result in zero rental charges.

## Finding Description

The vulnerability exists in the side chain creation validation flow in `AssertValidSideChainCreationRequest`. When a side chain is created with `IsPrivilegePreserved = false` (non-exclusive side chain), the validation method returns early with the comment "there is no restriction for non-exclusive side chain creation". [1](#0-0) 

This early return bypasses the call to `AssertValidResourceTokenAmount`, which is responsible for ensuring all symbols from `PayRentalSymbolListName` are present in `InitialResourceAmount` with values greater than zero. [2](#0-1)  The validation method itself iterates over all required resource symbols and asserts their presence. [3](#0-2) 

The unvalidated `InitialResourceAmount` is then included in the `ChainInitializationData` that is passed to the side chain during initialization. [4](#0-3) 

On the side chain, the `InitializeFromParentChain` method in the token contract directly sets `State.ResourceAmount` for each provided symbol without any validation of completeness. [5](#0-4) 

This creates a critical mismatch in the rental fee calculation system. The `GetResourceUsage` method iterates over symbols from `PayRentalSymbolListName` and reads from `State.ResourceAmount`, returning zero (the default value) for any missing symbols. [6](#0-5) 

Most critically, the `PayRental` method calculates rental fees using the formula: `rental = duration × State.ResourceAmount[symbol] × State.Rental[symbol]`. [7](#0-6)  For missing symbols where `State.ResourceAmount[symbol]` is zero, this results in zero rental charges regardless of duration or unit price.

## Impact Explanation

This vulnerability allows malicious actors to create non-exclusive side chains with incomplete resource allocations (e.g., providing only `{"CPU": 1}` instead of the required `{"CPU": 1, "RAM": 1, "DISK": 1, "NET": 1}`). The missing resource symbols will:

1. **Report zero usage** through `GetResourceUsage()`, hiding actual resource allocations from accounting systems
2. **Never incur rental charges** through `PayRental()`, as the calculation multiplies by zero
3. **Provide unlimited free resources** to the side chain for the lifetime of the chain (or until governance manually intervenes via `UpdateRentedResources`)

This directly violates the protocol's economic model where all side chains must pay rental fees for allocated resources. The parent chain loses rental fee revenue, and resource allocation accounting becomes inconsistent across the system. Exclusive side chains with `IsPrivilegePreserved = true` have proper validation enforced, creating an unfair economic advantage for non-exclusive chains that exploit this bypass.

The impact is compounded because while `UpdateRentedResources` can fix the resource amounts post-deployment, this requires explicit governance action and provides no guarantee of timely correction. During the interim period (which could be indefinite), the side chain enjoys completely free resource consumption.

## Likelihood Explanation

The vulnerability is highly likely to be exploited because:

- **Public access**: `RequestSideChainCreation` is a publicly callable method with no special authorization requirements beyond token allowance
- **Low barriers**: The attacker only needs sufficient locked tokens (a standard requirement for side chain creation) and to set `IsPrivilegePreserved = false`
- **Simple execution**: Single transaction to create the proposal, followed by standard governance approval flow that doesn't re-validate resource amounts
- **Automatic bypass**: The vulnerability is in validation logic that automatically triggers based on the `IsPrivilegePreserved` flag
- **Detection difficulty**: The missing validation is not visible at runtime and requires code-level review to identify
- **Supported feature**: Non-exclusive side chains are explicitly supported (test code defaults to `isPrivilegePreserved = false`), making this a legitimate configuration that won't raise immediate suspicion

The economic cost of side chain creation (locked tokens) is a necessary business expense for legitimate side chains, making the exploitation cost reasonable relative to the potential savings from avoided rental fees over the chain's lifetime.

## Recommendation

Add resource amount validation for non-exclusive side chains by modifying the `AssertValidSideChainCreationRequest` method to always call `AssertValidResourceTokenAmount`, regardless of the `IsPrivilegePreserved` flag:

```csharp
private void AssertValidSideChainCreationRequest(SideChainCreationRequest sideChainCreationRequest,
    Address proposer)
{
    // ... existing allowance and locked token checks ...

    // Always validate resource token amounts for all side chains
    AssertValidResourceTokenAmount(sideChainCreationRequest);

    if (!sideChainCreationRequest.IsPrivilegePreserved)
        return; // Non-exclusive chains don't need primary token validation

    // Primary token validation for exclusive chains only
    if (!IsPrimaryTokenNeeded(sideChainCreationRequest))
        return;

    AssertValidSideChainTokenInfo(sideChainCreationRequest.SideChainTokenCreationRequest);
    Assert(sideChainCreationRequest.SideChainTokenInitialIssueList.Count > 0 &&
           sideChainCreationRequest.SideChainTokenInitialIssueList.All(issue => issue.Amount > 0),
        "Invalid side chain token initial issue list.");
}
```

This ensures that all side chains, regardless of privilege preservation status, must provide valid resource amounts for all required resource symbols (CPU, RAM, DISK, NET) before the side chain can be created.

## Proof of Concept

```csharp
[Fact]
public async Task CreateNonExclusiveSideChain_WithPartialResources_EvadeRentalFees()
{
    await InitializeCrossChainContractAsync();
    
    // Approve sufficient allowance
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = CrossChainContractAddress,
        Symbol = "ELF",
        Amount = 100_000_000
    });

    // Create non-exclusive side chain with only CPU resource (missing RAM, DISK, NET)
    var incompleteResourceAmount = new Dictionary<string, int> { { "CPU", 1 } };
    var sideChainCreationRequest = new SideChainCreationRequest
    {
        IndexingPrice = 1,
        LockedTokenAmount = 100_000,
        IsPrivilegePreserved = false, // Non-exclusive side chain
        InitialResourceAmount = { incompleteResourceAmount }, // Missing required resources
        SideChainTokenCreationRequest = new SideChainTokenCreationRequest(),
        SideChainTokenInitialIssueList = { }
    };

    // This should fail but succeeds due to validation bypass
    var result = await CrossChainContractStub.RequestSideChainCreation.SendAsync(sideChainCreationRequest);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Vulnerability: succeeds

    // After side chain is approved and initialized, PayRental will charge 0 for RAM, DISK, NET
    // because State.ResourceAmount["RAM"], State.ResourceAmount["DISK"], State.ResourceAmount["NET"] are all 0
    // Rental calculation: rental = duration × 0 × Rental = 0 (free resources forever)
}
```

## Notes

The comment "there is no restriction for non-exclusive side chain creation" appears to be a misunderstanding of the design intent. While non-exclusive side chains don't require their own primary token creation, they still must pay resource rental fees for CPU, RAM, DISK, and NET consumption. The rental fee mechanism applies to all side chains via the `PayRental` method, which checks for `State.SideChainCreator.Value` rather than privilege preservation status. Resource rental and primary token creation are separate economic mechanisms that should be validated independently.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L124-125)
```csharp
        if (!sideChainCreationRequest.IsPrivilegePreserved)
            return; // there is no restriction for non-exclusive side chain creation
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L127-127)
```csharp
        AssertValidResourceTokenAmount(sideChainCreationRequest);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L139-145)
```csharp
    private void AssertValidResourceTokenAmount(SideChainCreationRequest sideChainCreationRequest)
    {
        var resourceTokenMap = sideChainCreationRequest.InitialResourceAmount;
        foreach (var resourceTokenSymbol in Context.Variables.GetStringArray(PayRentalSymbolListName))
            Assert(resourceTokenMap.ContainsKey(resourceTokenSymbol) && resourceTokenMap[resourceTokenSymbol] > 0,
                "Invalid side chain resource token request.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L538-542)
```csharp
        res.ResourceTokenInfo = new ResourceTokenInfo
        {
            ResourceTokenListData = resourceTokenInformation,
            InitialResourceAmount = { sideChainCreationRequest.InitialResourceAmount }
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L19-19)
```csharp
        foreach (var pair in input.ResourceAmount) State.ResourceAmount[pair.Key] = pair.Value;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L179-186)
```csharp
    public override ResourceUsage GetResourceUsage(Empty input)
    {
        var usage = new ResourceUsage();
        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName))
            usage.Value.Add(symbol, State.ResourceAmount[symbol]);

        return usage;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1061-1061)
```csharp
            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
```
