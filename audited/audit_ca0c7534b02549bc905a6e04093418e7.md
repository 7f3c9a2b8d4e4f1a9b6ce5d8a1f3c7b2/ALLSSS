### Title
Decimal Overflow in Vote Weight Calculation Causes Voting System Denial of Service

### Summary
The `Pow()` function in the Election contract uses binary exponentiation with repeated squaring of decimal values without overflow protection. When governance configures interest rates through `SetVoteWeightInterest()`, even moderate values (e.g., 10-20% daily interest) combined with maximum lock periods (1080 days) cause decimal overflow exceptions, rendering the voting system unusable and preventing validator elections.

### Finding Description

The vulnerability exists in the vote weight calculation pipeline: [1](#0-0) 

The `Pow()` function implements binary exponentiation where line 605 repeatedly squares the accumulator `a`. This function is invoked during vote weight calculation: [2](#0-1) 

The interest base is computed as `initBase = 1 + (decimal)instMap.Interest / instMap.Capital` and then raised to the power of `lockDays` (up to 1080 days maximum based on system configuration): [3](#0-2) 

The root cause is missing upper bound validation in `SetVoteWeightInterest()`: [4](#0-3) 

The function only validates that Interest, Capital, and Day are positive, with no upper bounds. This allows governance to set values like Interest=10, Capital=100 (10% daily rate), which when raised to power 1080 yields approximately 10^44, far exceeding C# decimal's maximum value of ~7.9×10^28.

### Impact Explanation

When decimal overflow occurs during vote weight calculation, C# throws `System.OverflowException`, causing the `Vote()` transaction to fail: [5](#0-4) 

**Concrete Impact:**
- Users cannot vote for validator candidates with long lock periods
- Validator election system becomes non-functional
- Network governance is disrupted as validators cannot be elected
- All users attempting to vote with lock times triggering overflow are affected
- The system remains broken until governance reconfigures safe interest values

**Severity:** High - This is a complete DoS of the core election mechanism that secures the network's consensus and governance.

### Likelihood Explanation

**Attack Complexity:** Low to Medium
- Governance controls interest configuration through `SetVoteWeightInterest()`: [6](#0-5) 

The default controller is the Parliament contract, meaning this requires governance approval but no malicious intent. Governance could legitimately set:
- Interest = 10, Capital = 100 → base = 1.1 → 1.1^1080 ≈ 10^44 (OVERFLOW)
- Interest = 5, Capital = 100 → base = 1.05 → 1.05^1080 ≈ 10^23 (approaching limits)
- Interest = 20, Capital = 100 → base = 1.2 → 1.2^1080 ≈ 10^85 (massive OVERFLOW)

**Feasibility:** High
- Governance might reasonably set 5-20% daily interest rates to incentivize long-term staking
- No warnings or validation prevent this configuration
- Once set, all subsequent long-term votes fail immediately

**Detection:** The issue only manifests when users vote, not when interest rates are configured, making it difficult to detect proactively.

### Recommendation

**1. Add Upper Bound Validation in SetVoteWeightInterest():**

Add maximum bounds checking to prevent overflow-inducing configurations:

```csharp
public override Empty SetVoteWeightInterest(VoteWeightInterestList input)
{
    AssertPerformedByVoteWeightInterestController();
    Assert(input.VoteWeightInterestInfos.Count > 0, "invalid input");
    
    foreach (var info in input.VoteWeightInterestInfos)
    {
        Assert(info.Capital > 0, "invalid input");
        Assert(info.Day > 0, "invalid input");
        Assert(info.Interest > 0, "invalid input");
        
        // NEW: Validate that base value won't cause overflow
        var baseValue = 1 + (decimal)info.Interest / info.Capital;
        var maxLockDays = State.MaximumLockTime.Value / DaySec;
        
        // Ensure base^maxLockDays < decimal.MaxValue / safety_margin
        // For safety, limit base such that base^maxLockDays < 10^20
        var maxSafeBase = Math.Pow(10.0, 20.0 / maxLockDays);
        Assert((double)baseValue < maxSafeBase, 
            $"Interest rate too high: base {baseValue} exceeds safe limit {maxSafeBase}");
    }
    
    // ... rest of function
}
```

**2. Add Overflow Protection in Pow():**

Implement checked arithmetic or pre-calculation validation:

```csharp
private static decimal Pow(decimal x, uint y)
{
    if (y == 1) return x;
    if (y == 0) return 1m;
    
    // Pre-check: if x^y would overflow, return max safe value or fail gracefully
    if (x > 1 && y > 100) // heuristic check
    {
        var logResult = (double)y * Math.Log((double)x);
        if (logResult > 65) // log(10^28) ≈ 65
        {
            Assert(false, "Vote weight calculation would overflow");
        }
    }
    
    // ... existing binary exponentiation
}
```

**3. Add Integration Tests:**

Create test cases that validate:
- Maximum safe interest configurations don't cause overflow
- Overflow-inducing configurations are rejected
- Vote weight calculations complete successfully for all valid lock periods

### Proof of Concept

**Initial State:**
- Election contract initialized with MaximumLockTime = 1080 days (93,312,000 seconds)
- Default interest configuration in place

**Attack Sequence:**

1. **Governance configures high interest rate** (transaction succeeds):
   ```
   Call: SetVoteWeightInterest({
     VoteWeightInterestInfos: [{
       Day: 365,
       Interest: 10,
       Capital: 100
     }]
   })
   ```
   This sets daily interest base = 1 + 10/100 = 1.1

2. **User attempts to vote with long lock time** (transaction FAILS with OverflowException):
   ```
   Call: Vote({
     CandidatePubkey: "<valid_candidate>",
     Amount: 1000_00000000,
     EndTimestamp: CurrentBlockTime + 1080 days
   })
   ```

**Expected Result:** Vote transaction succeeds, user's vote is recorded

**Actual Result:** Transaction throws `System.OverflowException` at line 605 during `a *= a` when computing 1.1^1080 ≈ 10^44, which exceeds decimal.MaxValue ≈ 7.9×10^28

**Success Condition:** The OverflowException prevents the vote from being recorded, rendering the election system unusable for all long-term votes.

### Notes

This vulnerability demonstrates a critical gap in input validation where mathematical properties (exponential growth) interact with type system limitations (decimal bounds). While governance control is required to trigger the issue, even well-intentioned configurations can inadvertently break the system. The lack of defensive bounds checking on interest rates represents a systemic risk to the election mechanism's availability and reliability.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L189-208)
```csharp
    public override Empty SetVoteWeightInterest(VoteWeightInterestList input)
    {
        AssertPerformedByVoteWeightInterestController();
        Assert(input.VoteWeightInterestInfos.Count > 0, "invalid input");
        // ReSharper disable once PossibleNullReferenceException
        foreach (var info in input.VoteWeightInterestInfos)
        {
            Assert(info.Capital > 0, "invalid input");
            Assert(info.Day > 0, "invalid input");
            Assert(info.Interest > 0, "invalid input");
        }

        Assert(input.VoteWeightInterestInfos.GroupBy(x => x.Day).Count() == input.VoteWeightInterestInfos.Count,
            "repeat day input");
        var orderList = input.VoteWeightInterestInfos.OrderBy(x => x.Day).ToArray();
        input.VoteWeightInterestInfos.Clear();
        input.VoteWeightInterestInfos.AddRange(orderList);
        State.VoteWeightInterestList.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L385-391)
```csharp
    private void AssertPerformedByVoteWeightInterestController()
    {
        if (State.VoteWeightInterestController.Value == null)
            State.VoteWeightInterestController.Value = GetDefaultVoteWeightInterestController();

        Assert(Context.Sender == State.VoteWeightInterestController.Value.OwnerAddress, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L421-467)
```csharp
    public override Hash Vote(VoteMinerInput input)
    {
        // Check candidate information map instead of candidates. 
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);

        var electorPubkey = Context.RecoverPublicKey();

        var lockSeconds = (input.EndTimestamp - Context.CurrentBlockTime).Seconds;
        AssertValidLockSeconds(lockSeconds);

        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;

        UpdateElectorInformation(electorPubkey, input.Amount, voteId);

        var candidateVotesAmount = UpdateCandidateInformation(input.CandidatePubkey, input.Amount, voteId);

        LockTokensOfVoter(input.Amount, voteId);
        TransferTokensToVoter(input.Amount);
        CallVoteContractVote(input.Amount, input.CandidatePubkey, voteId);
        AddBeneficiaryToVoter(GetVotesWeight(input.Amount, lockSeconds), lockSeconds, voteId);

        var rankingList = State.DataCentersRankingList.Value;
        if (rankingList.DataCenters.ContainsKey(input.CandidatePubkey))
        {
            rankingList.DataCenters[input.CandidatePubkey] =
                rankingList.DataCenters[input.CandidatePubkey].Add(input.Amount);
            State.DataCentersRankingList.Value = rankingList;
        }
        else
        {
            if (rankingList.DataCenters.Count < GetValidationDataCenterCount())
            {
                State.DataCentersRankingList.Value.DataCenters.Add(input.CandidatePubkey,
                    candidateVotesAmount);
                AddBeneficiary(input.CandidatePubkey);
            }
            else
            {
                TryToBecomeAValidationDataCenter(input, candidateVotesAmount, rankingList);
            }
        }

        return voteId;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L594-610)
```csharp
    private static decimal Pow(decimal x, uint y)
    {
        if (y == 1)
            return (long)x;
        var a = 1m;
        if (y == 0)
            return a;
        var e = new BitArray(y.ToBytes(false));
        var t = e.Count;
        for (var i = t - 1; i >= 0; --i)
        {
            a *= a;
            if (e[i]) a *= x;
        }

        return a;
    }
```

**File:** src/AElf.OS.Core/EconomicOptions.cs (L15-16)
```csharp
    public long MaximumLockTime { get; set; } = 1080 * 86400;
    public long MinimumLockTime { get; set; } = 90 * 86400;
```
