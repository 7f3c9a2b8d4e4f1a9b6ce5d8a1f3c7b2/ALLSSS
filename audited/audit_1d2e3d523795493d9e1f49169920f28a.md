### Title
IsUserContract Flag Manipulation via Incorrect Update Path Bypasses ACS Requirements

### Summary
User contract authors can permanently bypass required ACS (AElf Contract Standard) security validations by updating their contracts through the non-user contract update path (`ProposeUpdateContract` → `UpdateSmartContract`). This flips the `IsUserContract` flag to false, exempting the contract from user contract code validation requirements in all future updates.

### Finding Description

The private `UpdateSmartContract()` method unconditionally sets the `IsUserContract` flag from its caller-supplied parameter: [1](#0-0) 

Two distinct public update paths exist that call this private method with hardcoded flag values:

1. **Non-user contract path**: `UpdateSmartContract` (public) always passes `isUserContract = false` [2](#0-1) 

2. **User contract path**: `PerformUpdateUserSmartContract` always passes `isUserContract = true` [3](#0-2) 

**Root Cause**: No validation exists to prevent using the wrong update path based on a contract's current `IsUserContract` status. The `ProposeUpdateContract` method only checks that the sender is the contract author or Genesis contract: [4](#0-3) 

When `ProposeUpdateContract` creates the code check proposal, it fires a `CodeCheckRequired` event that **omits** the `IsUserContract` field, causing it to default to `false`: [5](#0-4) 

The code check service uses this flag to determine whether to enforce user contract ACS requirements: [6](#0-5) 

**Execution Path**:
1. User contract author calls `ProposeUpdateContract` instead of `UpdateUserSmartContract`
2. Authorization check passes (contract author is allowed) [7](#0-6) 
3. Proposal goes through Parliament governance approval
4. `ProposeContractCodeCheck` fires `CodeCheckRequired` with `IsUserContract` unset (defaults to false)
5. Code check bypasses user contract ACS requirements
6. `UpdateSmartContract` executes, permanently setting `info.IsUserContract = false`
7. All future updates continue to bypass user contract protections

### Impact Explanation

**Security Model Violation**: User contracts are designed with stricter ACS validation requirements than regular contracts. The `IsUserContract` flag controls whether these requirements are enforced during code auditing. By flipping this flag, a user contract permanently escapes its intended security constraints.

**Concrete Harm**:
- User contracts can deploy code that violates required ACS standards (e.g., ACS12 User Contract Standard)
- Malicious or vulnerable code can be introduced without proper validation
- The bypass is permanent—all subsequent updates continue without user contract checks
- Undermines trust in the user contract security model
- Affects all users interacting with the compromised contract

**Who Is Affected**: Any user or system interacting with user contracts whose authors exploit this path, either intentionally to deploy malicious code or accidentally through misuse of update methods.

**Severity Justification**: High severity due to permanent bypass of critical security validation mechanisms designed specifically for user contracts.

### Likelihood Explanation

**Attacker Capabilities Required**:
- Must be the contract author (stored in `ContractInfo.Author`)
- Must obtain Parliament governance approval for the update proposal

**Attack Complexity**: Medium
- The attack path uses legitimate contract update methods
- Requires understanding of two different update paths and their effects
- Parliament approval is required but governance might not detect the flag manipulation in routine update reviews

**Feasibility Conditions**:
- Contract author has valid reasons to update their contract (normal maintenance)
- Governance reviews proposal as standard contract update without noticing the `CodeCheckReleaseMethod` uses `UpdateSmartContract` instead of `PerformUpdateUserSmartContract`
- No UI warnings or documentation clearly distinguishes when each update path should be used

**Detection Constraints**: The flag flip is not immediately visible in the proposal parameters. Governance would need to understand the internal implementation to detect that `ProposeUpdateContract` will change the contract type.

**Probability Assessment**: Medium likelihood. This could occur through:
1. **Accidental misuse**: Contract authors using the wrong update method without understanding the distinction
2. **Intentional exploit**: Authors deliberately using this path to bypass future ACS checks
3. **Social engineering**: Presenting the update as routine maintenance while knowing it flips the flag

### Recommendation

**Code-Level Mitigation**: Add validation in both update paths to ensure the correct method is used based on the contract's current `IsUserContract` flag:

In `ProposeUpdateContract`, add before line 184:
```csharp
Assert(!info.IsUserContract, "User contracts must be updated via UpdateUserSmartContract.");
```

In `UpdateUserSmartContract`, add after line 450:
```csharp
Assert(info.IsUserContract, "Non-user contracts cannot be updated via this method.");
```

**Invariant Checks**: 
- The `IsUserContract` flag must be immutable after deployment
- Contract type (user vs non-user) determines the only valid update path

**Test Cases to Add**:
1. Test that `ProposeUpdateContract` fails when called on a user contract (IsUserContract=true)
2. Test that `UpdateUserSmartContract` fails when called on a non-user contract (IsUserContract=false)
3. Verify flag remains unchanged after failed attempts to use wrong update path
4. Confirm ACS requirements are consistently enforced across all updates for user contracts

### Proof of Concept

**Initial State**:
- User contract deployed via `DeployUserSmartContract` with `IsUserContract = true`
- Contract has specific author address stored in `ContractInfo.Author`
- Contract initially passes user contract ACS requirements

**Attack Steps**:

1. **Contract author calls `ProposeUpdateContract`** with new code for the user contract
   - Authorization passes: `AssertAuthorityByContractInfo` allows contract author
   - Proposal created with `CodeCheckReleaseMethod = nameof(UpdateSmartContract)`

2. **Parliament governance approves the proposal**
   - Appears as routine contract update
   - Governance unaware that update path will flip `IsUserContract` flag

3. **`ProposeContractCodeCheck` executes upon approval**
   - Fires `CodeCheckRequired` event with `IsUserContract` field unset (defaults to `false`)
   - Code check service receives `isUserContract = false`

4. **Code check performs validation**
   - `requiredAcs` remains empty (line 37-40 condition is false)
   - User contract ACS requirements are bypassed
   - Code passes check despite potentially violating user contract standards

5. **`UpdateSmartContract` executes after code check passes**
   - Line 334: calls private method with `isUserContract = false`
   - Line 110 in Helper: `info.IsUserContract = isUserContract;` sets flag to `false`
   - Contract state permanently updated

**Expected vs Actual Result**:
- **Expected**: User contract maintains `IsUserContract = true`, all updates enforce user contract ACS requirements
- **Actual**: User contract now has `IsUserContract = false`, all future updates bypass user contract ACS validation

**Success Condition**: Query `GetContractInfo` for the contract address—`IsUserContract` field will be `false` instead of `true`, and future updates no longer enforce user contract ACS standards.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L98-144)
```csharp
    private void UpdateSmartContract(Address contractAddress, byte[] code, Address author, bool isUserContract)
    {
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        Assert(author == info.Author, "No permission.");

        var oldCodeHash = info.CodeHash;
        var newCodeHash = HashHelper.ComputeFrom(code);
        Assert(oldCodeHash != newCodeHash, "Code is not changed.");
        AssertContractNotExists(newCodeHash);

        info.CodeHash = newCodeHash;
        info.IsUserContract = isUserContract;
        info.Version++;

        var reg = new SmartContractRegistration
        {
            Category = info.Category,
            Code = ByteString.CopyFrom(code),
            CodeHash = newCodeHash,
            IsSystemContract = info.IsSystemContract,
            Version = info.Version,
            ContractAddress = contractAddress,
            IsUserContract = isUserContract
        };

        var contractInfo = Context.UpdateSmartContract(contractAddress, reg, null, info.ContractVersion);
        Assert(contractInfo.IsSubsequentVersion,
            $"The version to be deployed is lower than the effective version({info.ContractVersion}), please correct the version number.");

        info.ContractVersion = contractInfo.ContractVersion;
        reg.ContractVersion = info.ContractVersion;

        State.ContractInfos[contractAddress] = info;
        State.SmartContractRegistrations[reg.CodeHash] = reg;

        Context.Fire(new CodeUpdated
        {
            Address = contractAddress,
            OldCodeHash = oldCodeHash,
            NewCodeHash = newCodeHash,
            Version = info.Version,
            ContractVersion = info.ContractVersion
        });

        Context.LogDebug(() => "BasicContractZero - update success: " + contractAddress.ToBase58());
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-183)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L265-272)
```csharp
        // Fire event to trigger BPs checking contract code
        Context.Fire(new CodeCheckRequired
        {
            Code = ExtractCodeFromContractCodeCheckInput(input),
            ProposedContractInputHash = proposedContractInputHash,
            Category = input.Category,
            IsSystemContract = input.IsSystemContract
        });
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L324-337)
```csharp
    public override Address UpdateSmartContract(ContractUpdateInput input)
    {
        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        var inputHash = CalculateHashFromInput(input);

        if (!TryClearContractProposingData(inputHash, out _))
            Assert(Context.Sender == info.Author, "No permission.");

        UpdateSmartContract(contractAddress, input.Code.ToByteArray(), info.Author, false);

        return contractAddress;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L507-517)
```csharp
    public override Empty PerformUpdateUserSmartContract(UserContractUpdateInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value.OwnerAddress);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var proposingInput);

        UpdateSmartContract(input.Address, input.Code.ToByteArray(), proposingInput.Author, true);

        return new Empty();
    }
```

**File:** src/AElf.Kernel.CodeCheck/Application/CodeCheckService.cs (L37-40)
```csharp
        if (isUserContract)
        {
            requiredAcs = await _requiredAcsProvider.GetRequiredAcsInContractsAsync(blockHash, blockHeight);
        }
```
