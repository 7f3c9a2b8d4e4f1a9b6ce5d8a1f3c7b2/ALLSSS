### Title
Token Dust Accumulation from Integer Division in Resource Token Distribution

### Summary
The `DistributeResourceTokensToPreviousMiners` method uses integer division to calculate token distribution amounts, causing remainder tokens to be permanently locked in the consensus contract. On side chains, resource tokens (READ, WRITE, STORAGE, TRAFFIC) accumulate in the consensus contract and should be distributed to miners during cross-chain updates, but any remainder from the division is never distributed and cannot be recovered, leading to gradual token loss over time.

### Finding Description

The vulnerability exists in the `DistributeResourceTokensToPreviousMiners` method [1](#0-0) , specifically at the integer division operation [2](#0-1) .

**Root Cause:**
The `Div` extension method performs standard integer division without handling remainders [3](#0-2) . When the consensus contract's token balance is divided by the miner count, any remainder is truncated and never distributed.

**Execution Path:**
1. On side chains, resource tokens are accumulated in the consensus contract through the `DonateResourceToken` mechanism [4](#0-3) 
2. When `UpdateInformationFromCrossChain` is called by the CrossChain contract [5](#0-4) , it invokes `DistributeResourceTokensToPreviousMiners` [6](#0-5) 
3. For each resource token symbol, the balance is divided equally among miners [7](#0-6) 
4. The remainder stays locked in the consensus contract forever

**Example:**
- Balance: 1,000,000,000 tokens (10 tokens with 8 decimals)
- Miners: 3
- Amount per miner: 1,000,000,000 / 3 = 333,333,333 (integer division)
- Total distributed: 333,333,333 × 3 = 999,999,999
- Remainder locked: 1 token unit

### Impact Explanation

**Direct Fund Impact:**
Resource tokens (READ, WRITE, STORAGE, TRAFFIC) that should be distributed to miners are permanently locked in the consensus contract with no recovery mechanism. The impact compounds over time as:
- Remainder accumulates on every cross-chain update
- Affects multiple token symbols simultaneously
- No administrative function exists to withdraw locked tokens

**Quantified Impact:**
For each update where balance is not evenly divisible by miner count, the remainder (balance % minerCount) is locked. With frequent cross-chain updates and multiple resource token types, this can accumulate to significant amounts. For example, with 5 miners and typical resource token balances, approximately 1-4 token units per symbol per update are lost.

**Who is Affected:**
- Miners on side chains receive less compensation than intended
- Side chain resource token economics are distorted over time
- The consensus contract becomes an unintended token sink

**Severity:** MEDIUM - While individual losses per update are small, the cumulative effect over time can be significant, and there is no recovery mechanism.

### Likelihood Explanation

**Reachable Entry Point:**
The entry point is `UpdateInformationFromCrossChain`, which is called by the CrossChain system contract during normal cross-chain consensus synchronization [8](#0-7) .

**Feasible Preconditions:**
The vulnerability triggers whenever the consensus contract's token balance for any resource token is not evenly divisible by the miner count. This is extremely common since:
- Token balances vary based on contract resource consumption
- Miner counts are typically not factors of common balance amounts
- No special attacker capabilities required

**Execution Practicality:**
This occurs automatically during normal side chain operations. Every time the main chain miner list is updated and synchronized to side chains, the token distribution executes with integer division.

**Probability:** HIGH - This occurs on every cross-chain update where remainder exists, which is the majority of cases given typical token amounts and miner counts.

### Recommendation

**Code-Level Mitigation:**
1. Track and distribute the remainder in subsequent distributions:
   ```
   // Before the miner loop, calculate remainder
   var totalAmount = amount.Mul(minerList.Count);
   var remainder = balance.Sub(totalAmount);
   
   // Distribute remainder to first miner or track for next distribution
   ```

2. Alternatively, use a more sophisticated distribution that ensures all tokens are distributed:
   ```
   var baseAmount = balance.Div(minerList.Count);
   var remainder = balance.Sub(baseAmount.Mul(minerList.Count));
   
   // First 'remainder' miners get baseAmount + 1
   // Remaining miners get baseAmount
   ```

**Invariant Checks:**
Add validation to ensure no tokens are left behind:
```
var balanceBefore = State.TokenContract.GetBalance(Context.Self, symbol);
// ... distribution logic ...
var balanceAfter = State.TokenContract.GetBalance(Context.Self, symbol);
Assert(balanceAfter == 0, "All tokens must be distributed");
```

**Test Cases:**
Add regression tests covering:
- Distribution with prime number of miners (e.g., 7, 11)
- Token amounts that don't divide evenly
- Multiple token symbols with different remainders
- Verification that consensus contract balance reaches zero after distribution

### Proof of Concept

**Initial State:**
- Side chain consensus contract has accumulated 10 READ tokens (1,000,000,000 units with 8 decimals) from resource fees
- Main chain has 3 active miners
- Previous `MainChainCurrentMinerList` contains 5 miner public keys

**Transaction Steps:**
1. CrossChain contract calls `UpdateInformationFromCrossChain` with new main chain consensus information containing 3 miners
2. `DistributeResourceTokensToPreviousMiners` is invoked
3. For READ token:
   - Balance retrieved: 1,000,000,000 units
   - Miner count: 5 (previous list)
   - Amount per miner: 1,000,000,000 / 5 = 200,000,000 units
   - Total transferred: 200,000,000 × 5 = 1,000,000,000 units ✓
   
   However, with 3 miners in previous list:
   - Amount per miner: 1,000,000,000 / 3 = 333,333,333 units
   - Total transferred: 333,333,333 × 3 = 999,999,999 units
   - **Remainder locked: 1 unit**

**Expected vs Actual Result:**
- Expected: All 1,000,000,000 units distributed to miners
- Actual: 999,999,999 units distributed, 1 unit permanently locked in consensus contract

**Success Condition:**
After multiple updates, query `State.TokenContract.GetBalance(ConsensusContractAddress, "READ")` and observe accumulated dust that cannot be withdrawn.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-64)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L66-96)
```csharp
    private void DistributeResourceTokensToPreviousMiners()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
        foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
            var amount = balance.Div(minerList.Count);
            Context.LogDebug(() => $"Consensus Contract {symbol} balance: {balance}. Every miner can get {amount}");
            if (amount <= 0) continue;
            foreach (var pubkey in minerList)
            {
                var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
                Context.LogDebug(() => $"Will send {amount} {symbol}s to {pubkey}");
                State.TokenContract.Transfer.Send(new TransferInput
                {
                    To = address,
                    Amount = amount,
                    Symbol = symbol
                });
            }
        }
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L999-1006)
```csharp
                    else
                    {
                        Context.LogDebug(() => $"Adding {amount} of {symbol}s to consensus address account.");
                        // Side Chain
                        receiver =
                            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
                        ModifyBalance(receiver, symbol, amount);
                    }
```
