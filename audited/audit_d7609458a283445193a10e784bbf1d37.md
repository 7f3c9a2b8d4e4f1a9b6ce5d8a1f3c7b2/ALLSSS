### Title
Vote Target Change Without Profit Extension Commitment via Lock Period Manipulation

### Summary
Voters can bypass the intended profit extension penalty when changing vote targets by manipulating `State.LockTimeMap` to be less than `TimeEachTerm`, causing `ExtendVoterWelfareProfits()` to return early at the `lockPeriod == 0` check. This allows voters to switch vote targets without extending their time commitment, undermining the election system's fairness and enabling coordinated governance attacks.

### Finding Description

The vulnerability exists in the `ExtendVoterWelfareProfits()` function where an early return occurs when `lockPeriod` equals zero: [1](#0-0) 

The root cause is that `lockPeriod` is calculated as `lockTime.Div(State.TimeEachTerm.Value)` using integer division. When `lockTime` is less than `TimeEachTerm` (7 days = 604,800 seconds), `lockPeriod` becomes 0, triggering the early return without extending the profit `endPeriod`.

An attacker can manipulate `State.LockTimeMap` through the following sequence in `ChangeVotingOption()`: [2](#0-1) 

**Attack Path:**

1. **Initial Vote**: Voter votes with `MinimumLockTime` (90 days in production, 7 days in tests)
   - `State.LockTimeMap[voteId]` = 90 days = 7,776,000 seconds (production)
   - Profit `endPeriod` = currentPeriod + 12 (since 90 days / 7 days = 12.86 periods)

2. **First Change (Near Expiration)**: After 83.5 days, change vote with `IsResetVotingTime=false`
   - At line 42: `State.LockTimeMap[voteId] = 7,776,000 - 7,214,400 = 561,600` seconds (6.5 days)
   - Profit `endPeriod` remains unchanged

3. **Second Change (Immediate)**: Change vote again with `IsResetVotingTime=true`
   - `lockTime` = 561,600 seconds (from Step 2)
   - `lockPeriod` = 561,600 / 604,800 = 0 (integer division)
   - Early return at line 136 - **profit `endPeriod` NOT extended**
   - Vote target successfully changed without commitment extension

The production configuration confirms this is exploitable: [3](#0-2) [4](#0-3) 

With `MinimumLockTime` (90 days) >> `TimeEachTerm` (7 days), any vote with remaining time < 7 days can trigger the bypass.

### Impact Explanation

**Direct Governance Impact:**
- Voters can change vote targets without extending their commitment period, avoiding the intended penalty mechanism
- In normal operation, using `IsResetVotingTime=true` should extend profit `endPeriod` by the original lock period (e.g., another 12 periods from current time), requiring token lock for the extended duration
- With the exploit, voters withdraw tokens at the original unlock time (90 days) instead of the extended time (173.5 days in the example)

**Coordinated Attack Vector:**
- Multiple voters can coordinate to temporarily boost a candidate without long-term commitment
- Attack sequence: Vote for Candidate A → Wait until near expiration → Switch to Candidate B using exploit → Candidate B gains votes without extended voter commitment
- Manipulates candidate rankings and validation data center selection as tracked in `State.DataCentersRankingList` [5](#0-4) 

**System Integrity Violation:**
The intended design requires voters who reset their voting time to commit to another full lock period, as documented in code comments: [6](#0-5) 

The exploit circumvents this fundamental fairness mechanism, allowing vote manipulation without corresponding commitment.

### Likelihood Explanation

**Reachable Entry Point:**
`ChangeVotingOption()` is a public method callable by any voter with an active vote: [7](#0-6) 

**Attack Feasibility:**
- **Preconditions**: Voter must have an active vote with remaining lock time
- **Execution**: Two sequential `ChangeVotingOption()` transactions within seconds
- **Cost**: Only standard gas fees for two transactions
- **Detection**: Difficult to detect as both operations are legitimate function calls
- **Timing**: Can be executed anytime when `actualLockedSeconds` approaches `MinimumLockTime`

**Economic Rationality:**
- No token cost beyond gas fees
- Benefit: Reduce lock commitment by up to original lock period duration (83.5 days savings in example)
- Can be executed by any voter, including coordinated groups
- Repeatable across multiple voting cycles

**Test Configuration Confirms Vulnerability:** [8](#0-7) [9](#0-8) 

Even in test environment where `MinimumLockTime` equals `TimeEachTerm` (both 7 days), the attack works by reducing `State.LockTimeMap` below `TimeEachTerm` before the second change.

### Recommendation

**Code-Level Mitigation:**

Modify `ExtendVoterWelfareProfits()` to enforce minimum profit extension or prevent extension bypass:

```csharp
private void ExtendVoterWelfareProfits(Hash voteId)
{
    var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
    var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);

    var lockTime = State.LockTimeMap[voteId];
    var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
    
    // FIX: Use original lock time if current lock time is too short
    if (lockPeriod == 0)
    {
        // Retrieve original lock time from profit detail or enforce minimum extension
        var originalLockSeconds = State.MinimumLockTime.Value; // Or track original per vote
        lockPeriod = originalLockSeconds.Div(State.TimeEachTerm.Value);
        Assert(lockPeriod > 0, "Cannot extend profit with invalid lock period.");
    }

    var endPeriod = lockPeriod.Add(treasury.CurrentPeriod);
    // ... rest of function
}
```

**Alternative: Prevent State.LockTimeMap Manipulation**

Add validation in `ChangeVotingOption()` to prevent reducing `State.LockTimeMap` below a minimum threshold when subsequent reset is intended:

```csharp
if (!input.IsResetVotingTime)
{
    var remainingTime = State.LockTimeMap[input.VoteId].Sub(actualLockedSeconds);
    Assert(remainingTime >= State.TimeEachTerm.Value, 
        "Cannot reduce lock time below one term period. Use IsResetVotingTime=true instead.");
    State.LockTimeMap[input.VoteId] = remainingTime;
}
```

**Invariant Checks:**
- Ensure `lockPeriod >= 1` when extending profits
- Validate that profit extension always occurs when `IsResetVotingTime=true`
- Track original lock time separately from remaining lock time

**Test Cases:**
1. Test that changing vote with remaining time < `TimeEachTerm` and `IsResetVotingTime=true` properly extends profit `endPeriod`
2. Test that sequential changes (`IsResetVotingTime=false` then `true`) cannot bypass profit extension
3. Verify that manipulated `State.LockTimeMap` values below `TimeEachTerm` still trigger proper profit extension

### Proof of Concept

**Initial State:**
- `MinimumLockTime` = 90 days = 7,776,000 seconds
- `TimeEachTerm` = 7 days = 604,800 seconds
- Current treasury period = 100

**Step 1: Initial Vote at Block Time T0**
```
Transaction: Vote(candidateA, amount=1000, lockTime=90 days)
Result: 
- State.LockTimeMap[voteId] = 7,776,000 seconds
- Profit endPeriod = 100 + 12 = 112
- VoteTimestamp = T0
```

**Step 2: First Change at T0 + 83.5 days**
```
Transaction: ChangeVotingOption(voteId, candidateA, IsResetVotingTime=false)
Result:
- actualLockedSeconds = 7,214,400 seconds
- State.LockTimeMap[voteId] = 7,776,000 - 7,214,400 = 561,600 seconds (6.5 days)
- Profit endPeriod = 112 (unchanged)
- New VoteTimestamp = T0 + 83.5 days
```

**Step 3: Second Change at T0 + 83.5 days + 10 seconds**
```
Transaction: ChangeVotingOption(voteId, candidateB, IsResetVotingTime=true)
Expected: Profit endPeriod extended to ~220 (current + 12 periods)
Actual Result:
- lockTime = 561,600 seconds (from Step 2)
- lockPeriod = 561,600 / 604,800 = 0
- Early return - NO profit extension
- Profit endPeriod = 112 (still unchanged)
- Vote switched to candidateB
```

**Step 4: Withdrawal at T0 + 90 days**
```
Transaction: Withdraw(voteId)
Result: SUCCESS - tokens unlocked
- Voter successfully changed from candidateA to candidateB
- Avoided extending commitment period from 90 days to 173.5 days
- Manipulated election without proper time commitment
```

**Success Condition:** Voter changes vote target with `IsResetVotingTime=true` but profit `endPeriod` is not extended, allowing withdrawal at original unlock time instead of extended time.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L23-31)
```csharp
    public override Empty ChangeVotingOption(ChangeVotingOptionInput input)
    {
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input.VoteId);
        Assert(Context.Sender == votingRecord.Voter, "No permission to change current vote's option.");
        var actualLockedSeconds = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockingSeconds = State.LockTimeMap[input.VoteId];
        Assert(actualLockedSeconds < claimedLockingSeconds, "This vote already expired.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L33-43)
```csharp
        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
        }
        else
        {
            // false, no change for EndPeroid
            State.LockTimeMap[input.VoteId] = State.LockTimeMap[input.VoteId].Sub(actualLockedSeconds);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L96-123)
```csharp
        var dataCenterList = State.DataCentersRankingList.Value;
        if (dataCenterList.DataCenters.ContainsKey(input.CandidatePubkey))
        {
            dataCenterList.DataCenters[input.CandidatePubkey] =
                dataCenterList.DataCenters[input.CandidatePubkey].Add(votingRecord.Amount);
        }
        else if (dataCenterList.DataCenters.Count < GetValidationDataCenterCount())
        {
            // add data center
            dataCenterList.DataCenters.Add(input.CandidatePubkey,
                State.CandidateVotes[input.CandidatePubkey].ObtainedActiveVotedVotesAmount);

            AddBeneficiary(input.CandidatePubkey);
        }
        else
        {
            CandidateReplaceMemberInDataCenter(dataCenterList, input.CandidatePubkey, voteAmountOfNewCandidate);
        }

        if (dataCenterList.DataCenters.ContainsKey(oldVoteOptionPublicKey))
        {
            dataCenterList.DataCenters[oldVoteOptionPublicKey] =
                dataCenterList.DataCenters[oldVoteOptionPublicKey].Sub(votingRecord.Amount);
            UpdateDataCenterAfterMemberVoteAmountChanged(dataCenterList, oldVoteOptionPublicKey);
        }

        State.DataCentersRankingList.Value = dataCenterList;
        return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L126-137)
```csharp
    private void ExtendVoterWelfareProfits(Hash voteId)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);

        // Extend endPeriod from now no, so the lockTime will *NOT* be changed.
        var lockTime = State.LockTimeMap[voteId];
        var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
        if (lockPeriod == 0)
        {
            return;
        }
```

**File:** src/AElf.OS.Core/EconomicOptions.cs (L15-16)
```csharp
    public long MaximumLockTime { get; set; } = 1080 * 86400;
    public long MinimumLockTime { get; set; } = 90 * 86400;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/ConsensusOptions.cs (L12-12)
```csharp
    public long PeriodSeconds { get; set; } = 604800;
```

**File:** test/AElf.Contracts.Economic.TestBase/EconomicContractsTestConstants.cs (L19-19)
```csharp
    public const long PeriodSeconds = 604800;
```

**File:** test/AElf.Contracts.Economic.TestBase/ContractsPreparation.cs (L375-376)
```csharp
            MinimumLockTime = 7 * 86400,
            TimeEachTerm = EconomicContractsTestConstants.PeriodSeconds,
```
