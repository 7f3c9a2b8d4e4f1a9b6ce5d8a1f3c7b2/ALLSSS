### Title
Cross-Chain Desynchronization of NFT IsTokenIdReuse Flag Enables Inconsistent Token ID Reuse Behavior Across Chains

### Summary
The `IsTokenIdReuse` flag can differ between chains when an NFT protocol token is created via `CrossChainCreateToken` from multiple parent/sibling chains. When a token already exists on a sidechain, `CrossChainCreateToken` only updates the alias field in ExternalInfo, leaving other critical metadata like `NftTokenIdReuseMetadataKey` unchanged. This causes the sidechain's NFT protocol to read stale/incorrect values, resulting in fundamentally different token ID reuse behavior across chains despite representing the same NFT protocol.

### Finding Description

**Root Cause Location:** [1](#0-0) 

When `CrossChainCreateToken` is called and the token already exists on the destination chain, the else branch only updates the `TokenAliasExternalInfoKey` in ExternalInfo. It does not update other critical keys like `NftTokenIdReuseMetadataKey`.

**NFT Protocol Creation Flow:**

On mainchain, NFT protocol creation stores the `IsTokenIdReuse` flag in token ExternalInfo: [2](#0-1) 

On sidechain, `CrossChainCreate` reads this flag from the sidechain's token ExternalInfo: [3](#0-2) 

And stores it in the NFT protocol state: [4](#0-3) 

**Why Existing Protections Fail:**

The `CrossChainCreateToken` method validates token info correctness via cross-chain merkle proofs but does not validate that existing tokens have matching ExternalInfo: [5](#0-4) 

Sidechains can register multiple chains in their `CrossChainTransferWhiteList`, allowing tokens to be crossed from different sources: [6](#0-5) 

### Impact Explanation

**Direct Protocol Integrity Violation:**

The `IsTokenIdReuse` flag controls whether token IDs can be re-minted after burning. In the `Burn` method: [7](#0-6) 

When `IsTokenIdReuse = false`, burned token IDs are permanently marked as `IsBurned = true` and cannot be re-minted.

In the `PerformMint` method: [8](#0-7) 

When `IsTokenIdReuse = false`, attempting to mint an existing token ID throws an assertion error.

**Concrete Harm:**
- **Chain A (mainchain):** NFT protocol with `IsTokenIdReuse = false` - token IDs are unique and cannot be reused
- **Chain B (sidechain):** Same NFT protocol with `IsTokenIdReuse = true` - token IDs can be re-minted after burning
- **Result:** The same NFT protocol exhibits fundamentally different behavior regarding asset uniqueness
- **Affected Parties:** NFT holders, marketplaces, bridges, dApps expecting consistent protocol behavior
- **Value Impact:** Breaks uniqueness guarantees that may be critical for high-value collectibles; enables double-minting scenarios on sidechain while mainchain enforces uniqueness

**Severity Justification:** HIGH - Violates critical NFT protocol invariant (token uniqueness) across chains, undermining trust in cross-chain NFT integrity.

### Likelihood Explanation

**Attack Prerequisites:**
1. AElf multi-chain environment with cross-chain operations enabled (standard configuration)
2. Sidechain registered with multiple parent/sibling chains via `RegisterCrossChainTokenContractAddress`
3. Same NFT token symbol created on different chains with different `IsTokenIdReuse` values

**Attack Complexity:** Medium
- Requires coordination across multiple chains
- Uses standard cross-chain operations (no privilege escalation needed)
- Timing: Token must be crossed from Chain A before being crossed from Chain B

**Execution Practicality:**
- All steps use public methods: `Create`, `CrossChainCreateToken`, `CrossChainCreate`
- No special permissions required beyond normal NFT protocol creation
- Cross-chain infrastructure is designed to support multiple chain registrations
- Token symbol collisions across chains are possible and not prevented

**Detection Constraints:**
- Desync is silent - no errors or warnings generated
- Only detectable by comparing protocol behavior across chains
- May go unnoticed until conflicting mint/burn operations occur

**Economic Rationality:**
- No direct token cost beyond transaction fees
- Potential profit from exploiting uniqueness assumptions in cross-chain NFT markets
- Could be accidental (unintentional token symbol collision) rather than malicious

**Probability:** Medium-High in multi-chain deployments where same token symbols are used across different chains.

### Recommendation

**Immediate Fix:**

Modify `CrossChainCreateToken` to validate and update all critical ExternalInfo fields when token already exists: [1](#0-0) 

Add validation logic:
```csharp
else
{
    // Validate critical ExternalInfo fields match
    var existingTokenInfo = State.TokenInfos[tokenInfo.Symbol];
    
    // Check NFT-specific metadata keys
    if (existingTokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.NftTokenIdReuseMetadataKey, out var existingReuse))
    {
        if (validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.NftTokenIdReuseMetadataKey, out var newReuse))
        {
            Assert(existingReuse == newReuse, 
                $"Token {tokenInfo.Symbol} already exists with different IsTokenIdReuse value. Cannot update critical NFT metadata.");
        }
    }
    
    // Update alias if needed
    if (isSymbolAliasSet && validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey, out var tokenAliasSetting))
    {
        State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value.Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
    }
}
```

**Additional Validation in NFT Contract:**

Add validation in `CrossChainCreate` to verify ExternalInfo consistency: [9](#0-8) 

Before line 88, add:
```csharp
// Verify this is the authoritative chain for this NFT protocol
Assert(tokenInfo.IssueChainId == Context.ChainId || 
       State.AuthorizedParentChain.Value == input.FromChainId,
       "NFT protocol can only be created from issue chain or authorized parent chain.");
```

**Test Cases:**

1. Test that `CrossChainCreateToken` rejects tokens with conflicting ExternalInfo
2. Test that NFT protocol creation from multiple chains enforces consistency
3. Test that `IsTokenIdReuse` behavior is identical across all chains for same protocol
4. Add integration test simulating multi-chain scenario with symbol collision

### Proof of Concept

**Initial State:**
- Chain A (parent chain) operational
- Chain B (mainchain/primary) operational  
- Chain C (sidechain) operational with both Chain A and Chain B registered in CrossChainTransferWhiteList

**Attack Sequence:**

**Step 1 - Chain A:** Create NFT protocol with reuse enabled
```
Call: NFT.Create({
    NftType: "MY",
    ProtocolName: "MyNFT",
    IsTokenIdReuse: true,
    ...
})
Result: Token "MYNFT-0" created with ExternalInfo[aelf_nft_token_id_reuse] = "True"
```

**Step 2 - Chain C:** Cross-chain create from Chain A
```
Call: TokenContract.CrossChainCreateToken({
    FromChainId: ChainA,
    TransactionBytes: <ValidateTokenInfoExists transaction>,
    MerklePath: <proof>
})
Result: Token "MYNFT-0" created on Chain C with IsTokenIdReuse = "True"
```

**Step 3 - Chain B:** Create NFT protocol with reuse disabled
```
Call: NFT.Create({
    NftType: "MY", 
    ProtocolName: "MyNFT",
    IsTokenIdReuse: false,
    ...
})
Result: Token "MYNFT-0" created with ExternalInfo[aelf_nft_token_id_reuse] = "False"
```

**Step 4 - Chain C:** Cross-chain create from Chain B
```
Call: TokenContract.CrossChainCreateToken({
    FromChainId: ChainB,
    TransactionBytes: <ValidateTokenInfoExists transaction>,
    MerklePath: <proof>
})
Result: Token "MYNFT-0" already exists on Chain C
→ Else branch executed (line 522)
→ Only alias updated, IsTokenIdReuse remains "True"
```

**Step 5 - Chain C:** Create NFT protocol
```
Call: NFT.CrossChainCreate({Symbol: "MYNFT-0"})
→ Line 88 reads: tokenInfo.ExternalInfo.Value[aelf_nft_token_id_reuse] = "True"
→ NFTProtocolInfo.IsTokenIdReuse = true
```

**Expected vs Actual Result:**

**Expected:** Chain C should have `IsTokenIdReuse = false` matching Chain B (the authoritative mainchain)

**Actual:** Chain C has `IsTokenIdReuse = true` from Chain A's initial cross-chain creation

**Verification:**

Chain B behavior:
```
Mint tokenId=1, Burn tokenId=1
→ IsBurned=true set (line 99)
Attempt Mint tokenId=1 again
→ Assert fails: "Token id 1 already exists" (line 396)
```

Chain C behavior:
```
Mint tokenId=1, Burn tokenId=1  
→ IsBurned NOT set (IsTokenIdReuse=true, line 99 condition false)
Mint tokenId=1 again
→ Success! Token re-minted
```

**Success Condition:** Same token ID (tokenId=1) can be re-minted on Chain C but not on Chain B, demonstrating cross-chain protocol desynchronization.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L480-482)
```csharp
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-521)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L522-531)
```csharp
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-129)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;

        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = input.Symbol,
            Creator = nftProtocolInfo.Creator,
            IsBurnable = nftProtocolInfo.IsBurnable,
            IssueChainId = nftProtocolInfo.IssueChainId,
            ProtocolName = nftProtocolInfo.ProtocolName,
            TotalSupply = nftProtocolInfo.TotalSupply,
            Metadata = nftProtocolInfo.Metadata,
            BaseUri = nftProtocolInfo.BaseUri,
            IsTokenIdReuse = isTokenIdReuse,
            NftType = nftProtocolInfo.NftType
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L196-200)
```csharp
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
        // Add Uri to external info.
        tokenExternalInfo.Value[NftBaseUriMetadataKey] = input.BaseUri;
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
        return tokenExternalInfo;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L99-99)
```csharp
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```
