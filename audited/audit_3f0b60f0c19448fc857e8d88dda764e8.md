### Title
Permanent Initialization DOS in TokenHolder Contract Method Fee Controller

### Summary
The `RequiredMethodFeeControllerSet` method in the TokenHolder contract lacks proper error handling when retrieving the Parliament contract address or calling its `GetDefaultOrganizationAddress` method. If either of these calls fail (e.g., Parliament not deployed or not initialized), the `MethodFeeController` remains permanently uninitialized with no recovery mechanism, causing a permanent DOS of all method fee management functionality.

### Finding Description

The vulnerability exists in the `RequiredMethodFeeControllerSet` private method: [1](#0-0) 

**Root Cause:**

The method performs two potentially failing operations without error handling:

1. **Line 54-55**: `Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName)` can return `null` if the Parliament contract is not registered in the Genesis contract's name-to-address mapping.

2. **Line 59**: `State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty())` will throw an assertion exception if the Parliament contract exists but is not initialized, as shown in the Parliament contract implementation: [2](#0-1) 

**Why Protections Fail:**

Unlike the MultiToken contract which includes defensive null checks: [3](#0-2) 

The TokenHolder contract (and other contracts like Association and Configuration) directly access these values without null checks, causing transaction reversion when either call fails.

**No Recovery Mechanism:**

The TokenHolder contract has no Initialize method: [4](#0-3) 

The only ways to set `MethodFeeController` are:
1. Through `RequiredMethodFeeControllerSet` itself (line 63)
2. Through `ChangeMethodFeeController` - which calls `RequiredMethodFeeControllerSet` first (line 24), creating a circular dependency [5](#0-4) 

**Affected Methods:**

All three methods that depend on the fee controller become permanently non-functional: [6](#0-5) [7](#0-6) 

### Impact Explanation

**What Harm Occurs:**
- Permanent DOS of all method fee management functionality in the TokenHolder contract
- Unable to set transaction fees for contract methods
- Unable to change the fee controller authority
- Unable to query the current fee controller (even the view method fails)

**Scope of Damage:**
The vulnerability only affects ACS1 method fee management functionality. Core TokenHolder operations remain functional: [8](#0-7) 

All profit scheme, locking, and distribution functionality continues to work normally.

**Who is Affected:**
- Chain operators unable to configure method fees for the TokenHolder contract
- Governance participants unable to modify fee controller authority
- The vulnerability is systemic, affecting multiple contracts with identical patterns (Association, Configuration, Treasury, Vote, Referendum, etc.)

**Severity Justification:**
MEDIUM-HIGH severity due to:
- Permanent DOS with no recovery path
- Affects governance functionality (method fee management)
- However, core contract functionality remains operational
- Method fee management is typically configured once and rarely changed

### Likelihood Explanation

**Feasibility Conditions:**

The vulnerability manifests when `RequiredMethodFeeControllerSet` is first invoked while:
1. Parliament contract is not deployed/registered, OR
2. Parliament contract is deployed but not initialized

**In Production Deployment:**
LIKELIHOOD: **LOW**

The standard deployment order shows Parliament deployed before TokenHolder: [9](#0-8) 

Parliament is deployed at position 5 (line 24) and TokenHolder at position 13 (line 32), with Parliament's Initialize method called during deployment: [10](#0-9) [11](#0-10) 

**In Abnormal Scenarios:**
LIKELIHOOD: **MEDIUM-HIGH**

Risk increases in:
- Manual contract deployment without proper initialization sequence
- Side chain deployments with different deployment patterns
- Test environments with incomplete contract setup
- Contract upgrade scenarios where Parliament initialization state is corrupted
- Recovery from deployment failures

**Attack Complexity:**
None - this is a natural failure scenario, not requiring attacker intervention. Simply deploying contracts in the wrong order or calling fee management methods before Parliament initialization triggers the DOS.

**Detection/Operational Constraints:**
The issue would be detected immediately upon first attempt to use method fee management functions, but by then the damage is permanent with no recovery path.

### Recommendation

**Immediate Fix:**
Add null checks and error handling similar to the MultiToken implementation. Modify `RequiredMethodFeeControllerSet`:

```csharp
private void RequiredMethodFeeControllerSet()
{
    if (State.MethodFeeController.Value != null) return;
    if (State.ParliamentContract.Value == null)
        State.ParliamentContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

    var defaultAuthority = new AuthorityInfo();
    
    // Parliament contract may not be deployed or initialized
    if (State.ParliamentContract.Value != null)
    {
        try
        {
            defaultAuthority.OwnerAddress = 
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
            defaultAuthority.ContractAddress = State.ParliamentContract.Value;
        }
        catch
        {
            // Parliament not initialized - set empty authority
        }
    }

    State.MethodFeeController.Value = defaultAuthority;
}
```

**Alternative Fix:**
Add an Initialize method that allows setting the MethodFeeController directly, callable only once by the contract deployer.

**Systemic Fix:**
Apply the same fix to all affected contracts: Association, Configuration, Treasury, Vote, Referendum, Economic, Consensus, CrossChain, Genesis, Profit, and TokenConverter contracts with identical patterns.

**Invariant Checks:**
- Add assertions that Parliament contract is deployed and initialized before TokenHolder deployment in deployment scripts
- Add deployment validation tests that verify fee controller can be set successfully

**Test Cases:**
1. Test TokenHolder deployment when Parliament is not deployed
2. Test TokenHolder deployment when Parliament is deployed but not initialized
3. Test recovery scenarios after failed initialization attempts
4. Test that core functionality works even when fee controller initialization fails

### Proof of Concept

**Required Initial State:**
1. Genesis contract deployed and operational
2. TokenHolder contract deployed WITHOUT Parliament contract deployed/initialized

**Transaction Steps:**

Step 1: Deploy TokenHolder contract (Parliament not yet deployed)
```
Genesis.DeploySystemSmartContract(TokenHolder)
// State.MethodFeeController.Value = null
```

Step 2: Attempt to call GetMethodFeeController
```
TokenHolder.GetMethodFeeController(Empty)
// Calls RequiredMethodFeeControllerSet() at line 42
// Line 54-55: GetContractAddressByName returns null
// Line 59: Attempts State.ParliamentContract.GetDefaultOrganizationAddress.Call()
// NULL REFERENCE or similar error
// Transaction REVERTS
// State.MethodFeeController.Value remains null
```

Step 3: Deploy and initialize Parliament
```
Genesis.DeploySystemSmartContract(Parliament)
Parliament.Initialize(...)
// Parliament now functional
```

Step 4: Attempt to call GetMethodFeeController again
```
TokenHolder.GetMethodFeeController(Empty)
// Calls RequiredMethodFeeControllerSet() at line 42
// Line 52: State.MethodFeeController.Value still null (not set from Step 2)
// Line 54-55: GetContractAddressByName NOW succeeds, returns Parliament address
// Line 59: GetDefaultOrganizationAddress.Call() succeeds
// Line 63: Sets State.MethodFeeController.Value
// SUCCESS - but only if Step 2 failure didn't corrupt state
```

**Expected vs Actual Result:**

Expected: TokenHolder can recover once Parliament is available
Actual: If Parliament is not available during first call, permanent DOS occurs with no recovery path

**Success Condition:**
The vulnerability is confirmed if calling any method fee management function before Parliament initialization leaves the contract permanently unable to manage method fees, even after Parliament becomes available.

**Notes:**
- This vulnerability was verified in the codebase by comparing with the safer MultiToken implementation
- Multiple system contracts share this vulnerable pattern
- The issue is particularly critical for contracts deployed before Parliament in non-standard deployment sequences
- While core TokenHolder functionality remains operational, the permanent loss of governance control over method fees represents a significant operational and security risk

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L40-44)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L50-64)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L250-254)
```csharp
    public override Address GetDefaultOrganizationAddress(Empty input)
    {
        Assert(State.Initialized.Value, "Not initialized.");
        return State.DefaultOrganizationAddress.Value;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L91-109)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo();

        // Parliament Auth Contract maybe not deployed.
        if (State.ParliamentContract.Value != null)
        {
            defaultAuthority.OwnerAddress =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
            defaultAuthority.ContractAddress = State.ParliamentContract.Value;
        }

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** src/AElf.EconomicSystem/TokenHolderContractInitializationProvider.cs (L13-16)
```csharp
    public List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        return new List<ContractInitializationMethodCall>();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** src/AElf.ContractTestBase/MainChainContractDeploymentListProvider.cs (L16-35)
```csharp
    public List<Hash> GetDeployContractNameList()
    {
        return new List<Hash>
        {
            VoteSmartContractAddressNameProvider.Name,
            ProfitSmartContractAddressNameProvider.Name,
            ElectionSmartContractAddressNameProvider.Name,
            TreasurySmartContractAddressNameProvider.Name,
            ParliamentSmartContractAddressNameProvider.Name,
            AssociationSmartContractAddressNameProvider.Name,
            ReferendumSmartContractAddressNameProvider.Name,
            TokenSmartContractAddressNameProvider.Name,
            CrossChainSmartContractAddressNameProvider.Name,
            ConfigurationSmartContractAddressNameProvider.Name,
            ConsensusSmartContractAddressNameProvider.Name,
            TokenConverterSmartContractAddressNameProvider.Name,
            TokenHolderSmartContractAddressNameProvider.Name,
            EconomicSmartContractAddressNameProvider.Name
        };
    }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderContractTestBase.cs (L95-104)
```csharp
        ParliamentContractAddress = AsyncHelper.RunSync(() => GetContractZeroTester(StarterKeyPair)
            .DeploySystemSmartContract.SendAsync(
                new SystemContractDeploymentInput
                {
                    Category = KernelConstants.CodeCoverageRunnerCategory,
                    Code = ByteString.CopyFrom(File.ReadAllBytes(typeof(ParliamentContract).Assembly.Location)),
                    Name = ParliamentSmartContractAddressNameProvider.Name,
                    TransactionMethodCallList = GenerateParliamentInitializationCallList()
                })).Output;
        ParliamentContractStub = GetParliamentContractTester(StarterKeyPair);
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderContractTestBase.cs (L335-346)
```csharp
    private SystemContractDeploymentInput.Types.SystemTransactionMethodCallList
        GenerateParliamentInitializationCallList()
    {
        var parliamentContractCallList = new SystemContractDeploymentInput.Types.SystemTransactionMethodCallList();
        parliamentContractCallList.Add(nameof(ParliamentContractStub.Initialize), new Parliament.InitializeInput
        {
            PrivilegedProposer = Starter,
            ProposerAuthorityRequired = true
        });

        return parliamentContractCallList;
    }
```
