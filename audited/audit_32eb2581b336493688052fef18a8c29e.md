### Title
Cross-Chain NFT Type Inconsistency via ShortName Remapping

### Summary
The NFT contract allows Parliament to remove and re-add NFT type mappings with the same ShortName but different FullName. When this occurs, the `CrossChainCreate` function incorrectly derives the NFT type from the current mapping instead of reading it from the token's immutable external info, causing permanent cross-chain data inconsistency for all existing NFT protocols using that ShortName.

### Finding Description

The vulnerability exists in the interaction between three functions:

1. **AddNFTType** validates that a ShortName doesn't currently exist before adding it: [1](#0-0) 

2. **RemoveNFTType** allows Parliament to remove existing mappings, clearing both bidirectional mappings: [2](#0-1) 

3. **CrossChainCreate** incorrectly derives the NFT type from the current short name mapping rather than reading it from the token's external info: [3](#0-2) 

The root cause is that while the NFT type is correctly stored in the token's external info during creation: [4](#0-3) 

The `CrossChainCreate` function reads other metadata (baseUri, isTokenIdReuse) from the token's external info but derives the NFT type from the symbol's short name prefix using the current mapping: [5](#0-4) 

This creates a critical inconsistency when a ShortName is remapped to a different FullName after NFT protocols are already created.

### Impact Explanation

**Concrete Harm:**
- NFT protocols created with the original mapping will have their NFT type incorrectly recorded on sidechains
- The mainchain NFTProtocolInfo will store the original FullName (e.g., "Alpha"), but the sidechain will store the new FullName (e.g., "Beta") for the same symbol
- This breaks the fundamental cross-chain invariant that NFT protocol metadata must be identical across chains

**Protocol Damage:**
- All NFT protocols using the remapped ShortName are permanently affected
- No recovery mechanism exists without contract upgrade
- NFT marketplaces filtering by type will show inconsistent results across chains
- Cross-chain NFT applications relying on type consistency will malfunction
- The NFT type is part of the protocol's identity and categorization system

**Affected Parties:**
- NFT protocol creators whose symbols start with the remapped ShortName
- NFT holders expecting consistent metadata across chains
- Applications and marketplaces using NFT type for categorization
- Cross-chain indexers and explorers

**Severity Justification:**
Medium - While requiring Parliament governance action, the impact is permanent cross-chain data inconsistency affecting core NFT protocol integrity and breaking critical invariants.

### Likelihood Explanation

**Attacker Capabilities:**
Requires Parliament default organization approval, not a direct attacker action. However, the scenario is realistic:
- Correcting typos in NFT type full names
- Repurposing short names for different categories
- Human error during governance operations
- Intentional policy changes

**Attack Complexity:**
Low - Simple two-step governance process:
1. Call `RemoveNFTType` with the ShortName
2. Call `AddNFTType` with same ShortName but different FullName

**Feasibility Conditions:**
- Parliament governance control (trusted role)
- Existing NFT protocols with symbols using the target ShortName
- Subsequent cross-chain creation attempts

**Operational Constraints:**
- The vulnerability manifests automatically once the remapping occurs
- No detection mechanism exists
- Affects all future CrossChainCreate operations for affected symbols

**Probability Reasoning:**
While Parliament is trusted, the operation itself is legitimate for fixing naming issues. Once executed, the impact is unavoidable and affects all existing protocols permanently. The likelihood is Medium because it depends on governance action but serves plausible operational needs.

### Recommendation

**Code-Level Mitigation:**
Modify the `CrossChainCreate` function to read the NFT type from the token's external info instead of deriving it from the short name mapping:

```csharp
// In CrossChainCreate, replace lines 89-93 with:
var nftTypeFullName = tokenInfo.ExternalInfo.Value[NftTypeMetadataKey];
if (string.IsNullOrEmpty(nftTypeFullName))
    throw new AssertionException($"NFT type not found in token external info for {input.Symbol}");
```

This ensures the NFT type on sidechains matches exactly what was set during the original protocol creation on mainchain, regardless of subsequent mapping changes.

**Invariant Checks:**
- Add validation that NFT type retrieved from external info matches an existing type mapping (for consistency checks, not derivation)
- Consider making NFT type mappings immutable once NFT protocols are created using them

**Test Cases:**
1. Create NFT protocol with type "Alpha" using short name "AB"
2. Remove and re-add "AB" mapping with type "Beta"
3. Perform CrossChainCreate for the original protocol
4. Assert that sidechain NFT type equals "Alpha" (from external info), not "Beta" (from current mapping)

### Proof of Concept

**Initial State:**
- NFT type mapping exists: "AB" -> "Alpha"

**Step 1: Create NFT Protocol on Mainchain**
- Parliament calls `AddNFTType` with ShortName="AB", FullName="Alpha"
- User calls `Create` with NftType="Alpha"
- Symbol generated: "AB1234567"
- Token external info stores: `NftTypeMetadataKey: "Alpha"`
- NFTProtocolInfo stores: `NftType = "Alpha"`

**Step 2: Remap ShortName**
- Parliament calls `RemoveNFTType` with ShortName="AB"
- State.NFTTypeFullNameMap["AB"] becomes null
- State.NFTTypeShortNameMap["Alpha"] becomes null
- Parliament calls `AddNFTType` with ShortName="AB", FullName="Beta"
- State.NFTTypeFullNameMap["AB"] = "Beta"
- State.NFTTypeShortNameMap["Beta"] = "AB"

**Step 3: Cross-Chain Creation**
- Sidechain calls `CrossChainCreate` with Symbol="AB1234567"
- Function extracts short name: "AB"
- Function looks up: State.NFTTypeFullNameMap["AB"] returns "Beta"
- Sidechain NFTProtocolInfo stores: `NftType = "Beta"`

**Expected Result:**
Both chains should have `NftType = "Alpha"`

**Actual Result:**
- Mainchain has `NftType = "Alpha"`
- Sidechain has `NftType = "Beta"`
- Cross-chain inconsistency confirmed

**Success Condition:**
Query NFTProtocolInfo on both chains for symbol "AB1234567" and observe different NftType values, proving the vulnerability exists.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L87-93)
```csharp
        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L137-137)
```csharp
        Assert(State.NFTTypeFullNameMap[input.ShortName] == null, $"Short name {input.ShortName} already exists.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L159-160)
```csharp
        State.NFTTypeFullNameMap.Remove(input.Value);
        State.NFTTypeShortNameMap.Remove(fullName);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L196-196)
```csharp
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
```
