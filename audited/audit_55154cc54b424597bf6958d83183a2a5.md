### Title
Solitary Miner Detection Bypass Through Alternating Collusion Pattern Enables Consensus Monopoly

### Summary
The `SolitaryMinerDetection()` function can be bypassed by two colluding miners who alternate between solo mining (one miner) and dual mining (both miners) every other round. This allows them to maintain indefinite control over block production while evading the protection mechanism designed to prevent single-miner dominance. The vulnerability violates the consensus decentralization invariant and allows attackers to exclude all other legitimate validators from participation.

### Finding Description

The vulnerability exists in the `SolitaryMinerDetection()` function which performs a three-stage check to detect if a miner has been producing blocks alone: [1](#0-0) 

The detection logic requires ALL three conditions to be true simultaneously:
1. **Line 74-75**: Current round has zero miners who have produced blocks yet
2. **Line 78-83**: Previous round (N-1) had only this single miner produce blocks  
3. **Line 86-91**: Round N-2 also had only this single miner produce blocks

The root cause is at lines 86-91 where the function checks round N-2 only if `isAlone` is still true after checking N-1. By employing an alternating pattern, attackers ensure that either N-1 or N-2 always has two miners, preventing all three conditions from being simultaneously satisfied.

**Attack Pattern:**
- Round N: Only Attacker A mines → `GetMinedMiners().Count = 1`
- Round N+1: Both A and colluder B mine → `GetMinedMiners().Count = 2`
- Round N+2: Only Attacker A mines → `GetMinedMiners().Count = 1`
- Round N+3: Both A and B mine → `GetMinedMiners().Count = 2`

When A attempts to mine at round N+2:
- Line 74: `isAlone = true` (current round empty)
- Line 81-82: Previous round (N+1) has 2 miners, so `isAlone = false`
- Line 86: Check for N-2 is never executed due to short-circuit logic
- Function returns `false`, allowing A to mine

The `GetMinedMiners()` method identifies miners who successfully produced blocks by checking for non-zero `SupposedOrderOfNextRound` values: [2](#0-1) 

This value is set when a miner produces a block via `ApplyNormalConsensusData`: [3](#0-2) 

The function is called from `GetConsensusCommand` as a self-check mechanism: [4](#0-3) 

### Impact Explanation

**Consensus Centralization Attack:**
- Two colluding miners can maintain indefinite monopoly over block production
- All other legitimate validators (N-2 miners) are effectively excluded from consensus participation
- The blockchain's decentralization guarantee is violated, reducing security to a 2-party system

**Violation of Critical Invariants:**
- **Miner Schedule Integrity**: Only 2 of N miners control the chain despite all N being elected validators
- **Round Transition Validity**: Legitimate miners cannot produce blocks even during their assigned time slots if prevented by network attacks

**Concrete Harm:**
- In a system with 21 validators, attackers controlling only 2 nodes can monopolize consensus
- Legitimate miners accumulate `MissedTimeSlots` penalties despite being online and functional
- Attackers can censor transactions and control block ordering indefinitely
- The network appears to function normally (blocks continue) while being controlled by 2 entities

**Affected Parties:**
- Legitimate validator nodes excluded from participation
- Token holders whose stake is delegated to excluded validators
- Network participants depending on decentralization guarantees
- Applications requiring censorship resistance

### Likelihood Explanation

**Attacker Capabilities Required:**
- Control or collusion between 2 out of N validator nodes (realistic threshold)
- Ability to DoS or network-partition remaining N-2 validators (achievable via network-layer attacks)
- No special permissions or governance authority required beyond being elected validators

**Attack Complexity:** 
- **Low**: Simple alternating pattern between solo and dual mining
- Execution requires no sophisticated cryptographic attacks or economic manipulation
- Pattern is deterministic and easy to coordinate between two parties

**Feasibility Conditions:**
- Attacker must be among elected validators (public entry point)
- Requires sustained network disruption of other validators OR natural offline period
- No consensus rule violations - blocks are validly produced and signed
- Attack is invisible to external observers initially (appears as legitimate mining)

**Detection Constraints:**
- Alternating pattern mimics legitimate behavior where miners take turns
- No obvious on-chain indicators distinguishing attack from normal operation with some offline nodes
- `SolitaryMinerDetection` is a client-side voluntary check, not enforced by consensus rules

**Economic Rationality:**
- Cost: Stake for 2 validator positions + network attack infrastructure
- Benefit: Complete control over transaction inclusion, MEV extraction, censorship power
- Attack becomes profitable if exclusive block production rewards exceed attack costs

**Probability Assessment:** HIGH
- Preconditions are realistic in adversarial network environments
- Attack path is straightforward without complex timing or race conditions
- No cryptographic hardness assumptions protect against this pattern

### Recommendation

**Code-Level Mitigation:**

Modify the `SolitaryMinerDetection()` function to detect patterns of low miner diversity across recent rounds rather than requiring strict solo mining:

```csharp
private bool SolitaryMinerDetection(Round currentRound, string pubkey)
{
    var isAlone = false;
    if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
    {
        var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
        isAlone = minedMinersOfCurrentRound.Count == 0;

        if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
        {
            // Check last N rounds for insufficient miner diversity
            const int LOOKBACK_ROUNDS = 4;
            var uniqueMiners = new HashSet<string>();
            var totalMinersRequired = currentRound.RealTimeMinersInformation.Count;
            
            for (int i = 0; i < LOOKBACK_ROUNDS; i++)
            {
                var round = (i == 0) ? previousRound : 
                    TryToGetRoundInformation(previousRound.RoundNumber.Sub(i), out var r) ? r : null;
                
                if (round == null) break;
                
                foreach (var miner in round.GetMinedMiners())
                {
                    uniqueMiners.Add(miner.Pubkey);
                }
            }
            
            // If less than 2/3 of expected miners participated across recent rounds, stop mining
            isAlone = uniqueMiners.Count < (totalMinersRequired * 2 / 3);
        }
    }
    return isAlone;
}
```

**Invariant Checks to Add:**
1. Track unique miner participation over rolling window (4-6 rounds)
2. Enforce minimum diversity threshold (e.g., ≥66% of registered miners must participate)
3. Add exponential backoff when diversity falls below threshold

**Test Cases:**
1. **Test alternating attack pattern**: Verify detection triggers with 2-miner alternating pattern
2. **Test legitimate sparse participation**: Ensure false positives don't occur when 2/3+ miners active
3. **Test rapid recovery**: Verify quick resumption when diversity threshold restored
4. **Test byzantine resistance**: Confirm attack cannot extend by adding more colluding miners in rotation

### Proof of Concept

**Initial State:**
- Network has 5 elected validators: A (attacker), B (colluder), C, D, E
- All validators are in `RealTimeMinersInformation` for the current round
- Current round number > 3 to pass initial checks
- Validators C, D, E are network-partitioned or DoS'd

**Attack Sequence:**

**Round 10:** 
- Only A produces block and calls `UpdateValue`
- A's `SupposedOrderOfNextRound` is set to non-zero via `ApplyNormalConsensusData`
- Round 10 state: `GetMinedMiners() = [A]` (count = 1)

**Round 11:**
- Both A and B produce blocks and call `UpdateValue`
- Both have non-zero `SupposedOrderOfNextRound`
- Round 11 state: `GetMinedMiners() = [A, B]` (count = 2)

**Round 12:**
- A calls `GetConsensusCommand` to attempt mining
- `SolitaryMinerDetection` executes:
  - Line 74: `currentRound(12).GetMinedMiners().Count == 0` → `isAlone = true`
  - Line 78-83: `previousRound(11).GetMinedMiners().Count == 2` → `isAlone = false`
  - Line 86: Condition `isAlone` is false, so round 10 check is skipped
  - Returns `false` → **A receives valid ConsensusCommand and mines**
- Round 12 state: `GetMinedMiners() = [A]` (count = 1)

**Round 13:**
- Both A and B mine
- Round 13 state: `GetMinedMiners() = [A, B]` (count = 2)

**Round 14:**
- A calls `GetConsensusCommand` to attempt mining
- `SolitaryMinerDetection` executes:
  - Current round 14: count = 0 → `isAlone = true`
  - Previous round 13: count = 2 → `isAlone = false`
  - Returns `false` → **A mines successfully again**

**Expected vs Actual Result:**
- **Expected:** After 2+ rounds of low miner diversity, detection should trigger and force A to wait
- **Actual:** Detection never triggers; A and B maintain indefinite control while C, D, E are excluded

**Success Condition:**
The attack succeeds if A can continuously call `GetConsensusCommand` and receive valid (non-invalid) consensus commands across 10+ rounds while maintaining the alternating pattern, demonstrating indefinite bypass of the solitary miner protection.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L23-24)
```csharp
        if (SolitaryMinerDetection(currentRound, pubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L66-96)
```csharp
    private bool SolitaryMinerDetection(Round currentRound, string pubkey)
    {
        var isAlone = false;
        // Skip this detection until 4th round.
        if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
        {
            // Not single node.

            var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
            isAlone = minedMinersOfCurrentRound.Count == 0;

            // If only this node mined during previous round, stop mining.
            if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
            {
                var minedMiners = previousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }

            // check one further round.
            if (isAlone && TryToGetRoundInformation(previousRound.RoundNumber.Sub(1),
                    out var previousPreviousRound))
            {
                var minedMiners = previousPreviousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }
        }

        return isAlone;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```
