### Title
Term Boundary Violation in NextRound Consensus Command Generation Leading to Mining Reward Misallocation

### Summary
The `ArrangeExtraBlockMiningTime` method can calculate mining times that exceed the current term's end time when `_isNewTerm=false`, causing blocks to be mined in the next term's time period but recorded under the previous term's number. This violates the critical invariant that term numbers must align with their designated time periods, leading to mining reward misallocation and governance desynchronization.

### Finding Description

**Root Cause:**

In `TerminateRoundCommandStrategy.GetAEDPoSConsensusCommand()`, when `_isNewTerm=false` (indicating a `NextRound` behavior rather than `NextTerm`), the method calls `ArrangeExtraBlockMiningTime` to determine the mining time: [1](#0-0) 

This delegates to `Round.ArrangeAbnormalMiningTime`, which calculates the arranged time based purely on round timing without any term boundary validation: [2](#0-1) 

The calculation computes how many rounds have been missed and projects the future round start time by adding `(missedRoundsCount + 1) * totalMilliseconds` to the current round start time, then adding the miner's order-based offset. **Critically, this calculation never checks if the resulting time exceeds the current term's end time.**

**Why Protections Fail:**

The term end time is defined as: [3](#0-2) 

However, the decision between `NextRound` and `NextTerm` behavior is made by `MainChainConsensusBehaviourProvider`, which only checks if 2/3 of miners have already mined past the term boundary: [4](#0-3) 

This creates a timing window where:
1. Current time is near/past the term end time
2. Less than 2/3 of miners have crossed the boundary yet
3. `NeedToChangeTerm()` returns false → behavior is `NextRound` → `_isNewTerm=false`
4. But `ArrangeAbnormalMiningTime` calculates a time beyond the term boundary

**Validation Gaps:**

The `RoundTerminateValidationProvider` only validates round number increments and that InValues are null for `NextRound` behavior, but does **not** validate term boundary alignment: [5](#0-4) 

Similarly, `TimeSlotValidationProvider` only checks time slot correctness within the round, not term boundaries: [6](#0-5) 

When `NextRound` is executed with a block timestamp beyond the term boundary, the new round maintains the same term number: [7](#0-6) 

### Impact Explanation

**Mining Reward Misallocation:**

Mining rewards are calculated based on blocks mined within a term number, not time period. `GetCurrentTermMiningReward` and `DonateMiningReward` count all blocks in rounds with a given term number: [8](#0-7) [9](#0-8) 

When blocks are mined in Term N+1's time period but recorded with Term N's term number, they inflate Term N's rewards. This causes:
- **Incorrect reward distribution** to miners, voters, and Treasury
- **Financial loss** to the protocol as rewards meant for Term N+1 are paid out in Term N
- **Election incentive distortion** as vote weights and miner rewards become misaligned with actual time periods

**Term Boundary Invariant Violation:**

The system assumes a strict mapping between term numbers and time periods for:
- Election timing and miner selection
- Governance action execution
- Economic distribution periods

Breaking this invariant can cause governance actions to execute under the wrong term context, affecting voting weights and proposal outcomes.

**Severity:** HIGH - Direct financial impact through reward misallocation and violation of core consensus invariants.

### Likelihood Explanation

**Attack Complexity:** LOW - This occurs naturally during normal consensus operation, no attacker action required.

**Preconditions:**
1. Blockchain time is within the last ~1 round duration before term end
2. Current block time approaches or exceeds the term boundary
3. Less than 2/3 of miners (MinersCountOfConsent) have mined blocks past the boundary yet
4. A miner attempts to terminate the current round

**Feasibility:** HIGH - These conditions occur naturally at the end of every term period. The 2/3 threshold check creates a race condition where some miners will inevitably be generating commands when conditions 1-3 are met.

**Detection:** The issue manifests as blocks with inconsistent term numbers and timestamps, which can be detected through monitoring but only after the damage is done.

**Probability:** This will occur at least once per term transition period (every `PeriodSeconds`, typically 7 days), making it a recurring issue rather than a rare edge case.

### Recommendation

**Code-Level Mitigation:**

Add term boundary validation in `ArrangeAbnormalMiningTime`:

```csharp
public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
    Timestamp termEndTime = null, bool mustExceededCurrentRound = false)
{
    // ... existing logic ...
    
    var arrangedTime = futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
    
    // Ensure arranged time does not exceed term boundary when provided
    if (termEndTime != null && arrangedTime > termEndTime)
    {
        // Cap at term end time minus safety margin
        arrangedTime = termEndTime.AddMilliseconds(-miningInterval);
    }
    
    return arrangedTime;
}
```

Modify `TerminateRoundCommandStrategy.GetAEDPoSConsensusCommand()` to pass term end time when `_isNewTerm=false`:

```csharp
public override ConsensusCommand GetAEDPoSConsensusCommand()
{
    Timestamp termEndTime = null;
    if (!_isNewTerm)
    {
        // Calculate and pass term end time for NextRound behavior
        termEndTime = CalculateCurrentTermEndTime();
    }
    
    var arrangedMiningTime = MiningTimeArrangingService.ArrangeExtraBlockMiningTime(
        CurrentRound, Pubkey, CurrentBlockTime, termEndTime);
    // ... rest of method
}
```

**Invariant Check:**

Add validation in `RoundTerminateValidationProvider.ValidationForNextRound()`:

```csharp
// For NextRound, ensure block time is within current term
if (blockchainStartTimestamp != null && periodSeconds > 0)
{
    var termEndTime = CalculateTermEndTime(validationContext.BaseRound.TermNumber, 
        blockchainStartTimestamp, periodSeconds);
    if (validationContext.BlockTime > termEndTime)
    {
        return new ValidationResult { 
            Message = "Cannot use NextRound behavior beyond term boundary. Use NextTerm instead." 
        };
    }
}
```

**Test Cases:**

1. Test arranging mining time when current time is 1 minute before term end
2. Test consensus command generation during term transition window
3. Test that validation rejects NextRound blocks mined after term boundary
4. Test reward calculation includes only blocks within correct term time period

### Proof of Concept

**Initial State:**
- Term 1 started at timestamp T
- `PeriodSeconds` = 604800 (7 days)
- Term 1 end time = T + 604800
- Current round started at T + 604500 (5 minutes before term end)
- Round duration (TotalMilliseconds) = 300 seconds (5 minutes)
- Mining interval = 60 seconds
- Current block time = T + 604700 (1 minute and 40 seconds before term end)
- Only 3 out of 7 miners (< 2/3) have mined blocks past term boundary

**Execution Steps:**

1. Miner calls `GetConsensusCommand()` at time T + 604700
2. `MainChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()` evaluates:
   - `CurrentRound.NeedToChangeTerm()` returns false (only 3/7 miners past boundary, need 5/7)
   - Returns `AElfConsensusBehaviour.NextRound`
3. `TerminateRoundCommandStrategy` created with `_isNewTerm=false`
4. `ArrangeAbnormalMiningTime` calculates:
   - `distanceToRoundStartTime` = 604700 - 604500 = 200 seconds
   - `missedRoundsCount` = 200 / 300 = 0
   - `futureRoundStartTime` = 604500 + (0 + 1) * 300 = 604800 (exactly at term end)
   - `arrangedMiningTime` = 604800 + (miner order 5) * 60 = **604800 + 300 = 605100** (5 minutes into Term 2!)
5. Consensus command created with hint `NextRound` and mining time 605100
6. Miner mines block at time 605100 and calls `NextRound()`
7. Validation passes (only checks round number increments)
8. New round created with `TermNumber = 1` (unchanged)
9. Block with timestamp 605100 (in Term 2) recorded as Term 1 block

**Expected vs Actual:**
- **Expected:** Block mined at T + 605100 should have `TermNumber = 2` or should not be allowed with `NextRound` behavior
- **Actual:** Block mined at T + 605100 has `TermNumber = 1`, violating term boundaries

**Success Condition:**
Query `GetCurrentTermMiningReward()` for Term 1 after this block - it will include the block mined at T + 605100, even though that timestamp is in Term 2's period, proving the reward misallocation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L25-26)
```csharp
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L33-36)
```csharp
        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L393-399)
```csharp
    public override Int64Value GetCurrentTermMiningReward(Empty input)
    {
        if (TryToGetCurrentRoundInformation(out var currentRound))
            return new Int64Value
                { Value = currentRound.GetMinedBlocks().Mul(GetMiningRewardPerBlock()) };

        return new Int64Value { Value = 0 };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L436-437)
```csharp
        var currentTermEndTime = currentTermStartTime.AddSeconds(State.PeriodSeconds.Value);
        return new Int64Value { Value = (currentTermEndTime - Context.CurrentBlockTime).Seconds };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L30-35)
```csharp
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L21-22)
```csharp
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L118-120)
```csharp
        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
```
