### Title
Silent Failure on Empty Consensus Data Causes Permanent Side Chain Consensus Desynchronization

### Summary
The `UpdateInformationFromCrossChain` function returns early without error when `input.Value` is empty, creating a silent failure condition. [1](#0-0)  When parent chain block data with empty consensus information is indexed, the side chain's view of the main chain miner list and round number remains permanently outdated, as the consumed parent chain height cannot be re-indexed with correct data.

### Finding Description

The vulnerability exists in the `UpdateInformationFromCrossChain` function which handles consensus synchronization between main and side chains. [2](#0-1) 

When the CrossChain contract indexes parent chain blocks, it extracts consensus data from the last block's `ExtraData` map and calls `UpdateConsensusInformation`. [3](#0-2)  If the consensus data key exists but contains an empty `ByteString`, the `TryGetValue` succeeds and passes the empty value to the consensus contract.

The validation logic in `ValidateParentChainBlockData` only checks structural properties (chainId, height, merkle root) but does NOT validate the content or presence of consensus data in the `ExtraData` field. [4](#0-3) 

Once indexing completes, the `CurrentParentChainHeight` advances permanently. [5](#0-4)  Since validation requires sequential heights, the same height cannot be re-indexed with correct data. [6](#0-5) 

Meanwhile, the consensus contract's `MainChainRoundNumber` and `MainChainCurrentMinerList` remain at their previous values indefinitely. [7](#0-6) 

### Impact Explanation

The permanent desynchronization affects multiple critical aspects:

1. **Consensus Integrity**: The side chain uses `IsMainChainMinerListChanged` to detect when the main chain miner list changes and trigger new term generation. [8](#0-7)  With stale main chain miner information, this check fails to detect actual changes, preventing proper consensus synchronization. [9](#0-8) 

2. **Token Distribution**: Resource tokens accumulated by the consensus contract are distributed to miners from the (now stale) `MainChainCurrentMinerList`. [10](#0-9)  Legitimate current miners on the main chain do not receive their entitled rewards, while outdated miners may receive undeserved distributions.

3. **No Recovery Path**: The `CurrentParentChainHeight` is only set during initialization and during indexing with no rollback mechanism. [11](#0-10)  Once a height is consumed with empty consensus data, recovery is impossible without contract upgrade or redeployment.

4. **Silent Failure**: No error, event, or log is emitted when empty data is encountered, making diagnosis and detection extremely difficult.

### Likelihood Explanation

The vulnerability requires parent chain block data with empty consensus information to be proposed and approved by governance, which has MEDIUM likelihood:

**Attack Path**: A side chain miner proposes parent chain block data via `ProposeCrossChainIndexing`. [12](#0-11)  The data must be approved by the `CrossChainIndexingController` organization before indexing. [13](#0-12) 

**Feasibility Conditions**:
- Parent chain block data collection has a bug that produces empty consensus data
- The `CrossChainResponseService` adds consensus data to `ExtraData` even if empty (explicitly allowed by comment in `BlockExtraDataService`). [14](#0-13) 
- Governance approval occurs due to: misconfiguration, lack of content validation, or honest error
- No cryptographic verification of parent chain block data authenticity exists during proposal validation

**Constraints**: Requires governance approval rather than single-actor exploit, but represents a systemic resilience failure that can occur through operational error or edge cases in cross-chain data collection.

### Recommendation

1. **Add Explicit Validation**: Distinguish between missing consensus data (acceptable) and empty consensus data (error). Modify line 41 to assert that if consensus data is provided, it must be non-empty:

```csharp
if (input == null || input.Value.IsEmpty) 
{
    Assert(input == null, "Empty consensus data not allowed.");
    return new Empty();
}
```

2. **Add Validation in CrossChain Contract**: Enhance `ValidateParentChainBlockData` to verify that if consensus data exists in `ExtraData`, it is non-empty and parseable. [4](#0-3) 

3. **Emit Event on Failure**: Log when consensus update is skipped, including the reason:

```csharp
if (input == null || input.Value.IsEmpty) 
{
    Context.Fire(new ConsensusUpdateFailedEvent { Reason = "Empty input" });
    Assert(false, "Invalid consensus data.");
}
```

4. **Add Test Case**: Create regression test for empty consensus data scenario similar to existing `UpdateInformationFromCrossChainTest_LowRoundNumber` test. [15](#0-14) 

### Proof of Concept

**Initial State**: Side chain is running with `MainChainRoundNumber = 100` and valid `MainChainCurrentMinerList`.

**Step 1**: Malicious/buggy proposer creates parent chain block data with:
- Valid `ChainId`, `Height`, and `TransactionStatusMerkleTreeRoot`
- `ExtraData["Consensus"]` = empty `ByteString`

**Step 2**: Data is proposed via `ProposeCrossChainIndexing`. Validation passes because `ValidateParentChainBlockData` doesn't check `ExtraData` content. [16](#0-15) 

**Step 3**: Governance approves the proposal (due to bug/misconfiguration).

**Step 4**: `ReleaseCrossChainIndexingProposal` calls `RecordCrossChainData`, which calls `IndexParentChainBlockData`. [17](#0-16) 

**Step 5**: At line 784, `TryGetValue` succeeds (key exists), `UpdateConsensusInformation` is called with empty bytes. [18](#0-17) 

**Step 6**: `UpdateInformationFromCrossChain` returns early at line 41. `MainChainRoundNumber` remains 100, `MainChainCurrentMinerList` unchanged.

**Step 7**: `CurrentParentChainHeight` advances to next height. [19](#0-18) 

**Expected Result**: Side chain's main chain miner list and round number should be updated.

**Actual Result**: Side chain consensus information permanently frozen at old state. Future indexing attempts for the same height fail validation. No error or event indicates the failure.

**Success Condition**: Query `GetMainChainCurrentMinerList` returns stale miner list despite main chain having new miners. [20](#0-19)

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-64)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L66-96)
```csharp
    private void DistributeResourceTokensToPreviousMiners()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
        foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
            var amount = balance.Div(minerList.Count);
            Context.LogDebug(() => $"Consensus Contract {symbol} balance: {balance}. Every miner can get {amount}");
            if (amount <= 0) continue;
            foreach (var pubkey in minerList)
            {
                var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
                Context.LogDebug(() => $"Will send {amount} {symbol}s to {pubkey}");
                State.TokenContract.Transfer.Send(new TransferInput
                {
                    To = address,
                    Amount = amount,
                    Symbol = symbol
                });
            }
        }
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L455-463)
```csharp
    private void HandleIndexingProposal(Hash proposalId)
    {
        var crossChainIndexingController = GetCrossChainIndexingController();
        var proposal = GetCrossChainProposal(crossChainIndexingController, proposalId);
        Assert(proposal.ToBeReleased, "Not approved cross chain indexing proposal.");
        Context.SendInline(crossChainIndexingController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release),
            proposal.ProposalId); // release if ready
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L465-481)
```csharp
    private CrossChainDataDto ValidateCrossChainDataBeforeIndexing(CrossChainBlockData crossChainBlockData)
    {
        Assert(
            crossChainBlockData.ParentChainBlockDataList.Count > 0 ||
            crossChainBlockData.SideChainBlockDataList.Count > 0,
            "Empty cross chain data proposed.");
        var validatedParentChainBlockData = new Dictionary<int, List<ParentChainBlockData>>();
        var validationResult = ValidateSideChainBlockData(crossChainBlockData.SideChainBlockDataList,
                                   out var validatedSideChainBlockData) &&
                               ValidateParentChainBlockData(crossChainBlockData.ParentChainBlockDataList,
                                   out validatedParentChainBlockData);
        Assert(validationResult, "Invalid cross chain data to be indexed.");
        var crossChainDataDto = new CrossChainDataDto(validatedSideChainBlockData, validatedParentChainBlockData);

        Assert(crossChainDataDto.GetChainIdList().Count > 0, "Empty cross chain data not allowed.");
        return crossChainDataDto;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L720-743)
```csharp
    private bool ValidateParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData,
        out Dictionary<int, List<ParentChainBlockData>> validatedParentChainBlockData)
    {
        var parentChainId = State.ParentChainId.Value;
        var currentHeight = State.CurrentParentChainHeight.Value;
        validatedParentChainBlockData = new Dictionary<int, List<ParentChainBlockData>>();
        foreach (var blockData in parentChainBlockData)
        {
            if (parentChainId != blockData.ChainId || currentHeight + 1 != blockData.Height ||
                blockData.TransactionStatusMerkleTreeRoot == null)
                return false;
            if (blockData.IndexedMerklePath.Any(indexedBlockInfo =>
                    State.ChildHeightToParentChainHeight[indexedBlockInfo.Key] != 0 ||
                    State.TxRootMerklePathInParentChain[indexedBlockInfo.Key] != null))
                return false;

            currentHeight += 1;
        }

        if (parentChainBlockData.Count > 0)
            validatedParentChainBlockData[parentChainId] = parentChainBlockData.ToList();

        return true;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L782-788)
```csharp
            // send consensus data shared from main chain  
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L798-804)
```csharp
        State.CurrentParentChainHeight.Value = currentHeight;
        
        Context.Fire(new ParentChainIndexed
        {
            ChainId = parentChainId,
            IndexedHeight = currentHeight
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-294)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L349-354)
```csharp
    private bool IsMainChainMinerListChanged(Round currentRound)
    {
        return State.MainChainCurrentMinerList.Value.Pubkeys.Any() &&
               GetMinerListHash(currentRound.RealTimeMinersInformation.Keys) !=
               GetMinerListHash(State.MainChainCurrentMinerList.Value.Pubkeys.Select(p => p.ToHex()));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L459-462)
```csharp
    public override MinerList GetMainChainCurrentMinerList(Empty input)
    {
        return State.MainChainCurrentMinerList.Value;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L18-18)
```csharp
        State.CurrentParentChainHeight.Value = input.CreationHeightOnParentChain - 1;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-291)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-301)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
```

**File:** src/AElf.Kernel.Core/Blockchain/Application/BlockExtraDataService.cs (L19-22)
```csharp
            if (extraData != null)
                // Actually extraData cannot be NULL if it is mining processing, as the index in BlockExtraData is fixed.
                // So it can be ByteString.Empty but not NULL.
                blockHeader.ExtraData.Add(blockExtraDataProvider.BlockHeaderExtraDataKey, extraData);
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainConsensusInformationTest.cs (L127-160)
```csharp
    [Fact]
    public async Task UpdateInformationFromCrossChainTest_LowRoundNumber()
    {
        SetToSideChain();
        InitialContracts();
        var mockedCrossChain = SampleAccount.Accounts.Last();
        var mockedCrossChainStub =
            GetTester<AEDPoSContractImplContainer.AEDPoSContractImplStub>(
                ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
                mockedCrossChain.KeyPair);

        var headerInformation = new AElfConsensusHeaderInformation
        {
            Round = new Round
            {
                RoundNumber = 0,
                RealTimeMinersInformation =
                {
                    { Accounts[0].KeyPair.PublicKey.ToHex(), new MinerInRound() },
                    { Accounts[1].KeyPair.PublicKey.ToHex(), new MinerInRound() },
                    { Accounts[2].KeyPair.PublicKey.ToHex(), new MinerInRound() }
                }
            }
        };

        await mockedCrossChainStub.UpdateInformationFromCrossChain.SendAsync(new BytesValue
        {
            Value = headerInformation.ToByteString()
        });

        var minerList = await ConsensusStub.GetMainChainCurrentMinerList.CallAsync(new Empty());
        minerList.Pubkeys.Select(m => m.ToHex())
            .ShouldNotBe(headerInformation.Round.RealTimeMinersInformation.Keys);
    }
```
