### Title
Missing Signature Validation Allows Consensus Schedule Manipulation

### Summary
The `NewConsensusInformationFilled()` validation function only verifies that the Signature field exists and is non-empty, without validating that it was correctly calculated as `previousRound.CalculateSignature(previousInValue)`. This allows malicious miners to provide arbitrary signature values, manipulating their mining order in the next round and potentially controlling extra block producer selection, thereby compromising consensus fairness and randomness.

### Finding Description

The vulnerability exists in the `UpdateValueValidationProvider.NewConsensusInformationFilled()` method which only performs existence checks on the Signature field: [1](#0-0) 

The Signature field is documented in the protobuf specification as being "Calculated from current in value and signatures of previous round": [2](#0-1) 

The correct signature calculation is defined in `Round.CalculateSignature()` which XORs the InValue with all miners' signatures from the current round: [3](#0-2) 

During legitimate block production in `GetConsensusExtraDataToPublishOutValue()`, the signature is properly calculated using this method: [4](#0-3) 

However, when processing the `UpdateValue` transaction, the signature from user input is directly assigned without any validation that it matches the expected calculation: [5](#0-4) 

The signature directly determines the miner's order in the next round via `ApplyNormalConsensusData()`: [6](#0-5) 

Additionally, if the attacker is the first miner in the current round, their signature determines who becomes the extra block producer in the next round: [7](#0-6) 

The after-execution validation only checks that the round hash matches, which doesn't catch this issue since the invalid signature has already been stored: [8](#0-7) 

### Impact Explanation

**Consensus Schedule Manipulation**: A malicious miner can arbitrarily choose their signature value to obtain a desired mining order in the next round. Since order is calculated as `GetAbsModulus(signature.ToInt64(), minersCount) + 1`, the attacker can try different signature values to achieve orders from 1 to minersCount, allowing them to mine earlier or later as desired.

**Extra Block Producer Control**: If the attacker is positioned as the first miner (order 1) in the current round and successfully mines, their manipulated signature directly determines which miner becomes the extra block producer in the next round. The extra block producer receives additional block rewards, creating a direct financial incentive.

**Consensus Randomness Violation**: The signature mechanism is designed to provide cryptographic randomness in determining mining schedules. By allowing arbitrary signatures, this randomness is completely compromised, undermining the fairness guarantees of the AEDPoS consensus protocol.

**Multi-Miner Collusion**: If multiple malicious miners coordinate their signature manipulation, they could potentially dominate the mining schedule across multiple rounds, significantly disrupting the consensus mechanism and concentrating rewards.

This is a **HIGH severity** vulnerability affecting consensus integrity, a critical invariant of the blockchain.

### Likelihood Explanation

**Reachable Entry Point**: The `UpdateValue` method is the standard entry point called by all miners during normal block production, making this vulnerability trivially reachable.

**Feasible Preconditions**: The attacker only needs to be a valid miner in the current validator set, which is a normal operational state. Miners regularly participate in consensus, so this precondition is always met during normal operations.

**Execution Practicality**: The exploit is extremely simple - when generating their `UpdateValueInput`, instead of calling `previousRound.CalculateSignature(previousInValue)` as intended, the attacker simply provides any arbitrary Hash value of their choosing. No complex timing, transaction ordering, or state manipulation is required.

**Economic Rationality**: The attack has zero cost (just changing a hash value) but provides direct benefits through favorable mining positions and potential extra block producer selection. The attacker maintains all normal mining rewards while gaining scheduling advantages.

**Detection Constraints**: The attack is completely undetectable since there is no validation comparing the provided signature against the expected value. The signature appears valid to all network participants.

**Probability**: **CERTAIN** - Any miner can execute this attack at any time with 100% success rate due to the complete absence of signature validation.

### Recommendation

**Immediate Fix**: Add signature validation in `UpdateValueValidationProvider` to verify the provided signature matches the expected calculation:

1. In `NewConsensusInformationFilled()` or a new validation method, add:
   - Retrieve the previous round information
   - Calculate the expected signature using `previousRound.CalculateSignature(minerInRound.PreviousInValue)`
   - Compare the calculated signature with `minerInRound.Signature`
   - Return validation failure if they don't match

2. Handle edge cases:
   - First round of a term may not have previous round information
   - Miners who are appearing for the first time (replacements)
   - Use the same fallback logic as in `GetConsensusExtraDataToPublishOutValue()` for these cases

3. The validation should occur in `ValidatePreviousInValue()` or a new method `ValidateSignature()` within `UpdateValueValidationProvider`:
   ```
   private bool ValidateSignature(ConsensusValidationContext validationContext)
   {
       if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(validationContext.SenderPubkey))
           return true; // First time miner or edge case
       
       var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
       var previousInValue = minerInRound.PreviousInValue;
       
       if (previousInValue == null || previousInValue == Hash.Empty)
           return true; // Handle gracefully
       
       var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
       return minerInRound.Signature == expectedSignature;
   }
   ```

4. Add comprehensive test cases covering:
   - Normal signature validation
   - Detection of manipulated signatures
   - Edge cases (first round, new miners, term transitions)
   - Verification that validation failures properly reject blocks

### Proof of Concept

**Required Initial State**:
- Attacker is a valid miner in the current round (normal operational state)
- Current round number > 1 (previous round exists)
- Attacker has valid `previousInValue` from the previous round

**Attack Steps**:

1. Attacker's node generates consensus trigger information with their legitimate `previousInValue`

2. Instead of calculating signature as:
   ```
   signature = previousRound.CalculateSignature(previousInValue)
   ```
   
   Attacker calculates a manipulated signature to achieve desired order:
   ```
   desiredOrder = 1  // Want to mine first in next round
   minersCount = currentRound.RealTimeMinersInformation.Count
   // Try different signatures until finding one that gives desired order
   manipulatedSignature = FindSignatureForOrder(desiredOrder, minersCount)
   ```

3. Attacker submits `UpdateValue` transaction with:
   - Correct `OutValue` = Hash(InValue)
   - Correct `PreviousInValue`
   - **Manipulated `Signature`** instead of correctly calculated one

4. Validation only checks signature exists (not correctness), so transaction succeeds

5. The manipulated signature is stored in round state

6. When next round is generated, attacker's order is calculated from their manipulated signature, giving them their desired mining position

**Expected Result**: Transaction should be rejected due to invalid signature

**Actual Result**: Transaction succeeds, attacker gains manipulated mining order in next round, potentially becomes extra block producer

**Success Condition**: Attacker successfully mines at their chosen position in the next round, demonstrating consensus schedule manipulation

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** protobuf/aedpos_contract.proto (L198-198)
```text
    aelf.Hash signature = 2;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-244)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```
