### Title
Off-By-One Error Allows Miner to Produce 9 Continuous Blocks Instead of Intended 8-Block Limit

### Summary
A miner can produce 9 continuous blocks before being forced to NextRound, exceeding the intended maximum of 8 blocks defined by `MaximumTinyBlocksCount`. The root cause is an off-by-one error in the initialization and validation logic of `BlocksCount`, where the first block bypasses the limit check, effectively granting one extra block production opportunity.

### Finding Description

The vulnerability exists in the continuous block production limit enforcement mechanism across multiple files: [1](#0-0) 

The intended maximum is 8 continuous blocks. However, the enforcement logic has an off-by-one error: [2](#0-1) 

The root cause is in `ResetLatestProviderToTinyBlocksCount`:

1. **First block production**: When `BlocksCount` is `null`, the check at line 31 of `GetConsensusCommand` passes because the condition `State.LatestPubkeyToTinyBlocksCount.Value != null` evaluates to false. After this block executes, `BlocksCount` is initialized to `MaximumTinyBlocksCount - 1 = 7` (line 345). [3](#0-2) 

2. **Subsequent blocks**: The miner can continue producing blocks while `BlocksCount` is 7, 6, 5, 4, 3, 2, 1, and 0 (8 more blocks). Each block decrements `BlocksCount` by 1 (line 356).

3. **Final valid block**: When `BlocksCount = 0`, the check `0 < 0` is false, allowing one more block. After this 9th block, `BlocksCount` becomes -1.

4. **Forced NextRound**: Only when `BlocksCount = -1` does the check `BlocksCount < 0` evaluate to true, forcing NextRound behavior.

The validation logic has the same flaw: [4](#0-3) 

The validation reads the current state before block execution (line 58 of validation context), meaning it checks the pre-execution `BlocksCount` value, which allows the 9th block when `BlocksCount = 0`. [5](#0-4) 

**Why protections fail:**
- The check `BlocksCount < 0` should be `BlocksCount <= 0` OR
- The initial value should be `MaximumTinyBlocksCount - 2` instead of `MaximumTinyBlocksCount - 1` OR  
- The first block should also count against the limit

### Impact Explanation

**Concrete harm:**
1. A miner can monopolize block production for 12.5% longer than intended (9 blocks vs 8 blocks)
2. This allows concentration of transaction fees for an extra block (potentially significant revenue on a busy network)
3. Other miners' transactions are delayed by one additional block time
4. Reduces consensus fairness and increases centralization risk

**Who is affected:**
- Other miners lose one time slot worth of block production opportunity
- Users experience delayed transaction finalization
- The consensus mechanism's fairness guarantees are violated

**Severity justification:**
Medium severity because:
- Violates a critical consensus invariant (miner schedule integrity)
- Provides measurable unfair advantage (12.5% extra blocks)
- No special privileges required (any miner can exploit)
- Impact is per-round but recurring across all rounds

### Likelihood Explanation

**Attacker capabilities:**
- Any active miner in the consensus can exploit this
- No special permissions or governance control required
- Exploitation happens automatically through normal block production

**Attack complexity:**
- Trivial - occurs naturally when a miner produces their maximum continuous blocks
- No special transactions or timing manipulation needed
- Just produce blocks normally until forced to NextRound

**Feasibility conditions:**
- Miner must be in the current miner list (normal consensus participation)
- Miner must have their time slot (standard consensus flow)
- No additional preconditions required

**Probability:**
HIGH - This occurs every time any miner produces the maximum continuous blocks. It's not an "attack" but a systematic flaw affecting all miners equally in the protocol's favor of allowing more blocks than intended.

### Recommendation

**Fix Option 1** (Recommended): Change the comparison operator to include the boundary case:

In `AEDPoSContract_ACS4_ConsensusInformationProvider.cs` line 33 and `ContinuousBlocksValidationProvider.cs` line 19:
```csharp
// Change from:
State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0

// To:
State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount <= 0
```

**Fix Option 2**: Adjust the initial value to account for the first block:

In `AEDPoSContract_ProcessConsensusInformation.cs` line 345:
```csharp
// Change from:
BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)

// To:
BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(2)
```

**Invariant checks to add:**
- Add assertion: Total continuous blocks by same miner <= MaximumTinyBlocksCount
- Add unit test: Verify miner cannot produce more than 8 continuous TinyBlock/UpdateValue blocks
- Add integration test: Simulate full round with max block production and verify counts

### Proof of Concept

**Initial state:**
- Miner A is in the current miner list
- It's Miner A's time slot
- `State.LatestPubkeyToTinyBlocksCount.Value = null`

**Transaction sequence:**

1. **Block 1**: Miner A calls `GetConsensusCommand` → BlocksCount is null, check passes → Produces UpdateValue block → `BlocksCount = 7`

2. **Block 2**: `BlocksCount = 7`, check `7 < 0` = false → Produces TinyBlock → `BlocksCount = 6`

3. **Block 3-8**: Continue pattern (BlocksCount: 6→5, 5→4, 4→3, 3→2, 2→1, 1→0)

4. **Block 9** (The extra block): `BlocksCount = 0`, check `0 < 0` = false → Produces TinyBlock → `BlocksCount = -1`

5. **Block 10**: `BlocksCount = -1`, check `-1 < 0` = true → FORCED to NextRound

**Expected result:** Miner A should only produce 8 continuous blocks

**Actual result:** Miner A produces 9 continuous blocks (TinyBlock/UpdateValue behaviors)

**Success condition:** Count of continuous TinyBlock/UpdateValue blocks by Miner A = 9, which exceeds `MaximumTinyBlocksCount = 8`

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```
