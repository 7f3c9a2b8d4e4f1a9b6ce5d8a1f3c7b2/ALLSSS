### Title
Malicious Contract Address Bypass in Governance Controller Validation

### Summary
The `CheckOrganizationExist()` function accepts an arbitrary contract address without validating it belongs to a legitimate authorization contract (Parliament, Association, or Referendum). An attacker who controls the current governance controller can deploy a malicious contract that always returns true for organization validation, then change the controller to this malicious address, permanently bypassing all governance requirements for contract deployments and updates.

### Finding Description

The vulnerability exists in the `CheckOrganizationExist()` helper function: [1](#0-0) 

This function calls `ValidateOrganizationExist` on `authorityInfo.ContractAddress` without any validation that this address is one of the three legitimate governance contracts. The function is used in two critical controller change operations: [2](#0-1) [3](#0-2) 

While both functions check that the sender is the current controller owner, they rely solely on `CheckOrganizationExist()` to validate the new controller's legitimacy. The `AuthorityInfo` structure contains only two fields with no inherent validation: [4](#0-3) 

Legitimate authorization contracts implement `ValidateOrganizationExist` by checking if the organization exists in their state: [5](#0-4) 

However, nothing prevents an attacker from deploying a malicious contract with a fake implementation that always returns true.

### Impact Explanation

**Governance System Compromise**: Once the controller is changed to a malicious contract address, all contract deployment and update proposals are sent to that malicious contract: [6](#0-5) [7](#0-6) [8](#0-7) 

The malicious contract can auto-approve all proposals, allowing the attacker to:
- Deploy arbitrary smart contracts without multi-sig approval
- Update existing contracts without governance oversight
- Bypass all proposal voting and threshold requirements
- Permanently control the blockchain's contract deployment infrastructure

This completely undermines the governance invariant that "Organization thresholds, proposer whitelist checks, proposal lifetime/expiration, correct organization hash resolution" must be maintained. The entire contract deployment security model is broken.

**Affected Parties**: All blockchain participants, as malicious contracts can be deployed that steal funds, manipulate consensus, or break cross-chain operations.

### Likelihood Explanation

**Attacker Capabilities**: The attacker must first be the current `ContractDeploymentController` or `CodeCheckController` owner. This could occur through:
- Legitimate governance participation where the attacker gains control temporarily
- Social engineering or compromise of governance participants
- Insider threat from authorized administrators

**Attack Complexity**: Low once the prerequisite is met:
1. Deploy malicious contract with fake `ValidateOrganizationExist` method (uses standard deployment flow)
2. Call `ChangeContractDeploymentController` with malicious contract address (single transaction)
3. Exploit is permanent - all future governance is bypassed

**Feasibility**: Highly feasible. The attack requires no special timing, no race conditions, and no complex multi-step coordination. The contract deployment mechanism: [9](#0-8) 

allows the controller owner to deploy contracts through the normal proposal process they already control.

**Detection**: The attack is difficult to detect until used, as changing a controller appears legitimate. Test cases expect organization validation to work: [10](#0-9) 

However, these tests only validate against legitimate Parliament addresses, not malicious contract addresses.

### Recommendation

**Immediate Fix**: Implement whitelist validation for authorization contract addresses in `CheckOrganizationExist()`:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a legitimate authorization contract
    var parliamentAddress = State.ParliamentContract.Value ?? 
        Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    var associationAddress = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    var referendumAddress = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress ||
        authorityInfo.ContractAddress == associationAddress ||
        authorityInfo.ContractAddress == referendumAddress,
        "Invalid authorization contract address.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Additional Protections**:
- Add events when controllers are changed to enable monitoring
- Implement time-locks or multi-step confirmation for controller changes
- Add comprehensive test cases that attempt to use non-whitelisted contract addresses

**Test Cases**: Create tests that verify:
1. Controller change fails with arbitrary contract addresses
2. Controller change fails with user-deployed contracts
3. Controller change succeeds only with legitimate Parliament/Association/Referendum addresses

### Proof of Concept

**Initial State**: Attacker has legitimately obtained `ContractDeploymentController` ownership through governance.

**Attack Steps**:

1. **Deploy Malicious Contract**:
   - Attacker proposes contract deployment through normal governance process
   - Contract code includes:
   ```csharp
   public BoolValue ValidateOrganizationExist(Address input) {
       return new BoolValue { Value = true };
   }
   ```
   - Since attacker controls governance, proposal is approved and contract deployed at address `MALICIOUS_ADDR`

2. **Change Controller**:
   - Attacker calls `ChangeContractDeploymentController` with:
     - `input.ContractAddress = MALICIOUS_ADDR`
     - `input.OwnerAddress = ATTACKER_ADDRESS` (or any address)
   - Authorization check passes (attacker is current owner)
   - `CheckOrganizationExist()` calls `MALICIOUS_ADDR.ValidateOrganizationExist()` which returns true
   - Controller updated to malicious configuration

3. **Exploit Governance Bypass**:
   - Any user proposes contract deployment via `ProposeNewContract`
   - Proposal sent to `MALICIOUS_ADDR` instead of legitimate Parliament
   - Malicious contract auto-approves proposal
   - Attacker deploys any contract without real governance approval

**Expected Result**: Controller change should fail with "Invalid authorization contract address"

**Actual Result**: Controller change succeeds, governance permanently bypassed

**Success Condition**: Attacker can deploy arbitrary contracts without multi-sig approval or voting requirements.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L163-165)
```csharp
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput.ToByteString());
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L222-224)
```csharp
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L261-263)
```csharp
        Context.SendInline(codeCheckController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L309-322)
```csharp
    public override Address DeploySmartContract(ContractDeploymentInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        // AssertDeploymentProposerAuthority(Context.Origin);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address =
            DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
                DecideNonSystemContractAuthor(contractProposingInput?.Proposer, Context.Sender), false,
                input.ContractOperation?.Deployer, input.ContractOperation?.Salt);
        return address;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L366-373)
```csharp
    public override Empty ChangeContractDeploymentController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.ContractDeploymentController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L375-382)
```csharp
    public override Empty ChangeCodeCheckController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.CodeCheckController.Value.OwnerAddress);
        Assert(CheckOrganizationExist(input),
            "Invalid authority input.");
        State.CodeCheckController.Value = input;
        return new Empty();
    }
```

**File:** protobuf/authority_info.proto (L5-10)
```text
message AuthorityInfo {
    // The contract address of the controller.
    aelf.Address contract_address = 1;
    // The address of the owner of the contract.
    aelf.Address owner_address = 2;
}
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L732-748)
```csharp
    public async Task ChangeContractZeroOwner_Test_Invalid_Address()
    {
        var address = Tester.GetCallOwnerAddress();
        var contractDeploymentController = await GetContractDeploymentController(Tester, BasicContractZeroAddress);
        const string proposalCreationMethodName =
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ChangeContractDeploymentController);
        var proposalId = await CreateProposalAsync(Tester, contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposalCreationMethodName,
            new AuthorityInfo
            {
                ContractAddress = contractDeploymentController.ContractAddress,
                OwnerAddress = address
            });
        await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);
        var txResult2 = await ReleaseProposalAsync(Tester, ParliamentAddress, proposalId);
        txResult2.Status.ShouldBe(TransactionResultStatus.Failed);
    }
```
