### Title
Double-Counting Vulnerability in RemoveBeneficiary Allows Artificial Deflation of TotalShares

### Summary
The `RemoveBeneficiary` function contains a logic flaw that allows the same profit detail to be processed multiple times when called with the same `ProfitDetailId`, causing shares to be subtracted from `TotalShares` repeatedly. This violates the critical invariant that each beneficiary's shares should only be counted once during removal, leading to artificial deflation of `TotalShares` and inflated profit distributions to remaining beneficiaries.

### Finding Description [1](#0-0) 

The `TryAdd()` method itself correctly accumulates values for the same period key within a single invocation, which is the intended behavior. However, the vulnerability exists in how `RemoveProfitDetails` is called across multiple `RemoveBeneficiary` invocations. [2](#0-1) 

The root cause is at lines 333-338, where the code adds a profit detail with a specific `profitDetailId` to `detailsCanBeRemoved` **without checking** if the detail has already been marked as `IsWeightRemoved = true`. This bypasses the protection mechanism that prevents double-counting. [3](#0-2) 

The primary protection against double-counting is the `!d.IsWeightRemoved` filter at lines 321-324. However, the code at lines 333-338 explicitly circumvents this check. [4](#0-3) 

When a detail is processed, `IsWeightRemoved = true` is set (line 345), but if the detail doesn't meet the removal conditions at lines 346-356 (specifically when `LastProfitPeriod < CurrentPeriod`), it remains in the list. On a subsequent call with the same `profitDetailId`, lines 333-338 re-add this already-processed detail, and line 358 adds its shares to `removedDetails` again. [5](#0-4) 

Finally, at line 260, `TotalShares` is decremented by the sum of all removed shares, causing the same shares to be subtracted multiple times across separate invocations.

### Impact Explanation

**Direct Fund Impact - Reward Misallocation:**

When `TotalShares` is artificially deflated through repeated removal of the same profit detail:
- Remaining beneficiaries receive **larger profit percentages** than entitled (their shares / artificially_reduced_total)
- Profit distribution calculations become incorrect
- The scheme's economic balance is compromised

**Quantified Example:**
- Initial `TotalShares`: 10,000
- Beneficiary A has 1,000 shares to be removed
- After legitimate removal: `TotalShares` = 9,000 (correct)
- After malicious second removal: `TotalShares` = 8,000 (incorrect, 11.1% deviation)
- Remaining beneficiaries now receive 12.5% more profit than they should (9000/8000 = 1.125x)

**Affected Parties:**
- Legitimate beneficiaries who should receive correct profit shares
- The integrity of the entire profit distribution scheme
- Any sub-schemes relying on accurate total share calculations

### Likelihood Explanation

**Attacker Capabilities:** [6](#0-5) 

The attacker must be either the scheme manager or control the TokenHolder contract. This requires privileged access.

**Attack Complexity:**
1. Attacker creates or controls a profit scheme
2. Adds beneficiaries with specific `ProfitDetailId` values
3. Calls `RemoveBeneficiary` with a `ProfitDetailId` where the detail's `LastProfitPeriod < CurrentPeriod`
4. Calls `RemoveBeneficiary` again with the same `ProfitDetailId`
5. Shares are subtracted from `TotalShares` twice

**Feasibility Conditions:**
- The profit detail must remain in the list after first removal (occurs when `LastProfitPeriod < CurrentPeriod`, which is the common case)
- No additional validation prevents duplicate removal requests
- The exploit is deterministic and requires only 2 transactions

**Detection/Operational Constraints:**
- No on-chain events distinguish legitimate from duplicate removals
- Off-chain monitoring would need to track all `RemoveBeneficiary` calls and their `ProfitDetailId` parameters
- The error could also occur **accidentally** if a manager mistakenly submits the same removal transaction twice

**Probability:** MEDIUM-HIGH for compromised/malicious managers; LOW-MEDIUM for accidental occurrence

### Recommendation

**Code-Level Mitigation:**

Add an `IsWeightRemoved` check before re-adding a specific profit detail:

```csharp
// In RemoveProfitDetails method, replace lines 333-338:
if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
    detailsCanBeRemoved.All(d => d.Id != profitDetailId))
{
    var targetDetail = profitDetails.Details.Single(d => d.Id == profitDetailId);
    // ADD THIS CHECK:
    if (!targetDetail.IsWeightRemoved)
    {
        detailsCanBeRemoved.Add(targetDetail);
    }
}
```

**Invariant Check:** [7](#0-6) 

Add validation before state persistence at lines 376-383 to assert no detail is processed multiple times within the same transaction or across transactions.

**Test Cases to Add:**
1. Test calling `RemoveBeneficiary` twice with the same `ProfitDetailId` - should only subtract shares once
2. Test that `TotalShares` remains accurate after multiple removal attempts
3. Test the `IsWeightRemoved` flag is respected in all code paths
4. Verify profit distributions remain correct after attempted duplicate removals

### Proof of Concept

**Required Initial State:**
- Profit scheme exists with `SchemeId = SCHEME_1`
- Scheme has `TotalShares = 10000`
- Beneficiary B has a profit detail with:
  - `Id = DETAIL_123`
  - `Shares = 1000`
  - `LastProfitPeriod = 5`
  - `EndPeriod = 15`
- Current period = 10

**Transaction Steps:**

1. **Transaction 1:** Manager calls `RemoveBeneficiary(SCHEME_1, B, DETAIL_123)`
   - Line 345: `IsWeightRemoved = true`
   - Line 346: `LastProfitPeriod(5) >= CurrentPeriod(10)` → FALSE
   - Line 351: `EndPeriod(15) >= CurrentPeriod(10)` → TRUE
   - Line 355: `EndPeriod` set to 9
   - Detail remains in list with `IsWeightRemoved = true`
   - Line 358: `removedDetails.TryAdd(10, 1000)`
   - Line 260: `TotalShares = 10000 - 1000 = 9000` ✓

2. **Transaction 2:** Manager calls `RemoveBeneficiary(SCHEME_1, B, DETAIL_123)` again
   - Line 322/324: Detail NOT in filtered list (has `IsWeightRemoved = true`)
   - Line 334-335: Detail exists AND not in `detailsCanBeRemoved` → TRUE
   - Line 337: Detail **re-added** to `detailsCanBeRemoved`
   - Line 358: `removedDetails.TryAdd(10, 1000)` **AGAIN**
   - Line 260: `TotalShares = 9000 - 1000 = 8000` ✗ **WRONG**

**Expected Result:** `TotalShares = 9000` after both transactions
**Actual Result:** `TotalShares = 8000` (1000 shares over-subtracted)

**Success Condition:** `TotalShares` is decremented by 2000 instead of 1000, confirming double-counting vulnerability.

### Citations

**File:** contract/AElf.Contracts.Profit/Models/RemovedDetails.cs (L8-18)
```csharp
        public void TryAdd(long key, long value)
        {
            if (ContainsKey(key))
            {
                this[key] = this[key].Add(value);
            }
            else
            {
                this[key] = value;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L237-239)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L260-260)
```csharp
        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L333-338)
```csharp
        // remove the profitDetail with the profitDetailId, and de-duplicate it before involving.
        if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
            detailsCanBeRemoved.All(d => d.Id != profitDetailId))
        {
            detailsCanBeRemoved.Add(profitDetails.Details.Single(d => d.Id == profitDetailId));
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L342-358)
```csharp
            foreach (var profitDetail in detailsCanBeRemoved)
            {
                // set remove sign
                profitDetail.IsWeightRemoved = true;
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }

                removedDetails.TryAdd(scheme.CurrentPeriod, profitDetail.Shares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L376-383)
```csharp
        if (profitDetails.Details.Count != 0)
        {
            State.ProfitDetailsMap[scheme.SchemeId][beneficiary] = profitDetails;
        }
        else
        {
            State.ProfitDetailsMap[scheme.SchemeId].Remove(beneficiary);
        }
```
