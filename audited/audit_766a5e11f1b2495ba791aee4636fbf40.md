# Audit Report

## Title
Integer Overflow in GetBaseFeeDictionary Allows Complete Transaction Fee Bypass via LINQ Sum() Wrapping

## Summary
When multiple `MethodFee` entries with the same symbol are configured via `SetMethodFee`, the `GetBaseFeeDictionary` method sums their `BasicFee` values using LINQ's `Sum()` method, which performs unchecked arithmetic. If two entries each have `BasicFee = Int64.MaxValue`, their sum overflows to -2. This negative fee amount bypasses all fee charging logic, allowing transactions to execute with zero fees charged, breaking the protocol's economic model.

## Finding Description

The vulnerability exists in the method fee calculation and charging flow:

**1. Duplicate Symbol Acceptance**

`SetMethodFee` accepts a `MethodFees` object containing a repeated list of `MethodFee` entries. While each individual `BasicFee` is validated to be positive, there is no validation preventing multiple entries with the same symbol. [1](#0-0) 

The protobuf definition explicitly allows repeated fees with no uniqueness constraint. [2](#0-1) 

**2. Unchecked LINQ Sum() Causing Overflow**

When fees are retrieved for charging, `GetBaseFeeDictionary` groups fees by symbol and sums their `BasicFee` values using LINQ's `Sum()` method. [3](#0-2) 

This LINQ operation uses unchecked arithmetic. When two `BasicFee` values of `Int64.MaxValue` are summed, the result wraps to -2.

**3. SafeMath Patcher Limitation**

The SafeMath IL patcher only patches methods within the contract module itself, not framework assemblies like `System.Linq.Enumerable`. [4](#0-3) 

**4. Negative Amount Bypasses Fee Checks**

The negative fee amount (-2) passes validation in `TryToChargeUserBaseFee` because the condition `existingAllowance >= amount` evaluates to `0 >= -2`, which is TRUE. [5](#0-4) 

**5. Zero Fee Added to Bill**

In `ChargeBaseFee`, when `existingAllowance > amountToChargeBaseFee` (i.e., `0 > -2`), the code adds zero to the fee bill instead of the actual fee. [6](#0-5) 

**6. Charging Skipped**

Finally, `ModifyBalance` skips processing when `amount <= 0`, so no fees are actually deducted from the user's balance. [7](#0-6) 

## Impact Explanation

**Severity: HIGH**

This vulnerability enables complete bypass of transaction fees, breaking a critical protocol invariant:

- **Complete Fee Bypass**: Any method configured with overflowing fees can be called with ZERO transaction fees charged
- **System-Wide Revenue Loss**: If applied to high-volume methods like `Transfer` or `Approve`, the blockchain loses ALL transaction fee revenue for those methods
- **Economic Model Breakdown**: Transaction fees are essential for:
  - Funding consensus rewards to validators
  - Treasury funding for network development
  - Token supply management (fees offset inflation)
  
- **Affected Parties**:
  - Network validators lose expected fee rewards
  - Treasury loses fee-based funding stream
  - Token economics broken (inflation not offset by fee burn)

The vulnerability directly breaks the ACS1 transaction fee standard's guarantee that configured fees will be charged.

## Likelihood Explanation

**Likelihood: MEDIUM**

**Required Capabilities:**
- Authority to call `SetMethodFee`, which requires sender to be the method fee controller
- The default controller is Parliament's default organization requiring 2/3 Block Producer approval [8](#0-7) 
- Parliament default organization has MinimalApprovalThreshold of 6667 (66.67%) [9](#0-8) 

**Attack Scenarios:**
1. **Governance Compromise**: Compromised or colluding Block Producer supermajority (requires 2/3 BPs)
2. **Initial Deployment**: Malicious deployer sets overflowing fees before transferring control to Parliament
3. **Side Chain Attack**: Side chains may have weaker governance security assumptions

**Execution Complexity:** LOW
- Simply create two `MethodFee` entries: `{ Symbol = "ELF", BasicFee = 9223372036854775807 }` (twice)
- The sum overflows to -2 automatically
- No additional exploitation steps needed

**Detection Difficulty:** HIGH
- Fees appear correctly "set" in contract state
- Only manifests during actual transaction execution
- Transaction logs show success but zero fees in `TransactionFeeCharged` events
- Requires event analysis to detect anomaly

## Recommendation

**Fix 1: Validate Unique Symbols in SetMethodFee**

Add validation to prevent duplicate symbols in the fees list. Modify `SetMethodFee` to check for duplicates before storing.

**Fix 2: Use Checked Arithmetic for Sum**

Replace LINQ `Sum()` with explicit checked arithmetic in `GetBaseFeeDictionary` to throw on overflow rather than wrapping.

**Fix 3: Validate Non-Negative Fees**

Add validation in the fee charging path to assert that calculated fees are non-negative before proceeding.

**Fix 4: Aggregate During SetMethodFee**

Aggregate fees by symbol during `SetMethodFee` validation, using checked arithmetic, and store only the pre-aggregated values.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task IntegerOverflow_FeeBypass_Test()
{
    // 1. Setup: Parliament sets malicious fees with duplicate symbols
    var methodFees = new MethodFees
    {
        MethodName = "Transfer",
        Fees =
        {
            new MethodFee { Symbol = "ELF", BasicFee = long.MaxValue },
            new MethodFee { Symbol = "ELF", BasicFee = long.MaxValue }
        }
    };
    
    // Parliament approves and executes SetMethodFee
    await ParliamentContractStub.SetMethodFee.SendAsync(methodFees);
    
    // 2. User calls Transfer
    var balanceBefore = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = UserAddress, Symbol = "ELF" });
    
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = RecipientAddress,
        Symbol = "ELF",
        Amount = 100,
        Memo = "test"
    });
    
    var balanceAfter = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = UserAddress, Symbol = "ELF" });
    
    // 3. Assert: Transfer succeeded but NO fees were charged
    // Expected: balanceAfter = balanceBefore - 100 - fee
    // Actual: balanceAfter = balanceBefore - 100 (NO FEE)
    balanceAfter.Balance.ShouldBe(balanceBefore.Balance - 100);
    
    // Verify TransactionFeeCharged event shows ZERO fees
    var feeEvents = TransactionResult.Logs
        .Where(l => l.Name == nameof(TransactionFeeCharged))
        .Select(l => TransactionFeeCharged.Parser.ParseFrom(l.NonIndexed))
        .ToList();
    
    feeEvents.Sum(e => e.Amount).ShouldBe(0); // ZERO fees charged!
}
```

## Notes

This vulnerability demonstrates a gap between the SafeMath IL patcher's scope (contract module only) and framework methods (LINQ). While the protocol enforces checked arithmetic for contract code, LINQ operations in `System.Linq.Enumerable` remain unchecked and can overflow. The fee charging logic also lacks defensive validation against negative amounts, assuming all fees will be positive after individual validation during `SetMethodFee`.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L91-109)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo();

        // Parliament Auth Contract maybe not deployed.
        if (State.ParliamentContract.Value != null)
        {
            defaultAuthority.OwnerAddress =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
            defaultAuthority.ContractAddress = State.ParliamentContract.Value;
        }

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** protobuf/acs1.proto (L40-53)
```text
message MethodFees {
    // The name of the method to be charged.
    string method_name = 1;
    // List of fees to be charged.
    repeated MethodFee fees = 2;
    bool is_size_fee_free = 3;// Optional based on the implementation of SetMethodFee method.
}

message MethodFee {
    // The token symbol of the method fee.
    string symbol = 1;
    // The amount of fees to be charged.
    int64 basic_fee = 2;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L237-255)
```csharp
    private void ModifyBalance(Address fromAddress, TransactionFeeBill bill,
        TransactionFreeFeeAllowanceBill allowanceBill)
    {
        Assert(!IsInTransferBlackListInternal(fromAddress), "Charge fee address is in transfer blacklist.");
        SetOrRefreshTransactionFeeFreeAllowances(fromAddress);
        var freeAllowancesMap = CalculateTransactionFeeFreeAllowances(fromAddress);

        // Update balances and allowances
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            ModifyBalance(fromAddress, symbol, -amount);
            Context.Fire(new TransactionFeeCharged
            {
                Symbol = symbol,
                Amount = amount,
                ChargingAddress = fromAddress
            });
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L322-327)
```csharp
    private Dictionary<string, long> GetBaseFeeDictionary(MethodFees methodFees)
    {
        return methodFees.Fees.Where(f => !string.IsNullOrEmpty(f.Symbol))
            .GroupBy(f => f.Symbol, f => f.BasicFee)
            .ToDictionary(g => g.Key, g => g.Sum());
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L336-373)
```csharp
    private bool ChargeBaseFee(Dictionary<string, long> methodFeeMap, Address fromAddress, ref TransactionFeeBill bill,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap,
        ref TransactionFreeFeeAllowanceBill allowanceBill,
        TransactionFeeDelegations delegations = null)
    {
        Context.LogDebug(() => "ChargeBaseFee Start");
        // Fail to charge
        if (!ChargeFirstSufficientToken(methodFeeMap, fromAddress, out var symbolToChargeBaseFee,
                out var amountToChargeBaseFee, out var existingBalance, out var existingAllowance,
                transactionFeeFreeAllowancesMap,
                delegations))
        {
            Context.LogDebug(() => "Failed to charge first sufficient token.");
            if (symbolToChargeBaseFee != null)
            {
                bill.FeesMap.Add(symbolToChargeBaseFee, existingBalance);
                allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, existingAllowance);
            } // If symbol == 

            return false;
        }

        // Succeed to charge, freeAllowance first.
        if (existingAllowance > amountToChargeBaseFee)
        {
            allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, amountToChargeBaseFee);
            // free fee allowance has covered fee, add 0 for size fee
            bill.FeesMap.Add(symbolToChargeBaseFee, 0);
        }
        else
        {
            allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, existingAllowance);
            bill.FeesMap.Add(symbolToChargeBaseFee, amountToChargeBaseFee.Sub(existingAllowance));
        }

        Context.LogDebug(() => "ChargeBaseFee End");
        return true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L747-777)
```csharp
    private bool TryToChargeUserBaseFee(Dictionary<string, long> symbolToAmountMap, Address fromAddress,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, out long amount,
        out string symbolOfValidBalance, out long existingBalance, out long existingAllowance)
    {
        // priority: enough allowance -> symbolWithEnoughBalancePlusAllowance -> symbolWithEnoughBalance -> symbolWithAnything
        symbolOfValidBalance = null;
        string symbolWithAnything = null;
        string symbolWithEnoughBalance = null;
        string symbolWithEnoughBalancePlusAllowance = null;

        amount = 0;
        existingBalance = 0;
        existingAllowance = 0;
        //For user
        //Find the token that satisfies the balance of the fee,if there is no token that satisfies the balance of the fee, find the token that balance > 0
        foreach (var (symbol, value) in symbolToAmountMap)
        {
            // current token symbol
            amount = value;
            existingBalance = GetBalance(fromAddress, symbol);
            existingAllowance = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbol);

            var existingBalancePlusAllowance = existingBalance.Add(existingAllowance);

            
            // allowance is enough to cover the base fee
            if (existingAllowance >= amount)
            {
                symbolOfValidBalance = symbol;
                return true;
            }
```

**File:** src/AElf.CSharp.CodeOps/Patchers/Module/SafeMath/Patcher.cs (L24-30)
```csharp
    public void Patch(ModuleDefinition module)
    {
        foreach (var method in module.GetAllTypes().SelectMany(t => t.Methods))
        {
            PatchMethod(method);
        }
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L1-10)
```csharp
namespace AElf.Contracts.Parliament;

public partial class ParliamentContract
{
    private const int DefaultOrganizationMinimalApprovalThreshold = 6667;
    private const int DefaultOrganizationMaximalAbstentionThreshold = 2000;
    private const int DefaultOrganizationMaximalRejectionThreshold = 2000;
    private const int DefaultOrganizationMinimalVoteThresholdThreshold = 7500;
    private const int AbstractVoteTotal = 10000;
}
```
