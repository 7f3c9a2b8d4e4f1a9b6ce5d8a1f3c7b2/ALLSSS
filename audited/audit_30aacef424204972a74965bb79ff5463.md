### Title
Malicious Miner Can Overwrite Other Miners' PreviousInValue Without Cryptographic Validation

### Summary
The `PerformSecretSharing()` function allows any miner to overwrite other miners' `PreviousInValue` fields by including arbitrary values in `input.MinersPreviousInValues`, without validating these values against the cryptographic commitments (OutValue) from the previous round. This breaks the core consensus invariant that a miner's revealed `PreviousInValue` must hash to their previously committed `OutValue`, enabling manipulation of random number generation and miner ordering.

### Finding Description

In `PerformSecretSharing()`, the code directly assigns values from `input.MinersPreviousInValues` to the round state without any cryptographic validation: [1](#0-0) 

This assignment occurs during `ProcessUpdateValue()` when secret sharing is enabled: [2](#0-1) 

The validation in `UpdateValueValidationProvider` only checks the **sender's own** `PreviousInValue`, not the values for other miners in `MinersPreviousInValues`: [3](#0-2) 

Notice line 38 explicitly limits validation to `SenderPubkey` only. The malicious values for other miners pass through unchecked.

The attack path is:
1. Miner A legitimately reveals `PreviousInValue = X` where `hash(X) == OutValue_A` from the previous round
2. This gets written to state via the normal flow at line 263-264: [4](#0-3) 

3. Miner B then calls `UpdateValue` with `MinersPreviousInValues[A] = Y` where `Y ≠ X` and `hash(Y) ≠ OutValue_A`
4. Line 296 overwrites: `round.RealTimeMinersInformation[A].PreviousInValue = Y`
5. State is persisted with the invalid value: [5](#0-4) 

The `UpdateValueInput` protobuf definition shows `miners_previous_in_values` is a miner-controlled input: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Violation**: The AEDPoS consensus relies on a commitment scheme where miners commit to `OutValue = hash(InValue)` in round N, then reveal `InValue` as `PreviousInValue` in round N+1. This vulnerability allows attackers to violate this invariant by substituting fake `PreviousInValue` that don't hash to the committed `OutValue`.

**Random Number Manipulation**: The corrupted `PreviousInValue` is used to calculate signatures for random number generation. When a miner misses a slot, the system retrieves their `PreviousInValue` from state and uses it to calculate their signature: [7](#0-6) 

The signature calculation uses the (now corrupted) `PreviousInValue`: [8](#0-7) 

**Miner Ordering Manipulation**: According to the consensus documentation, signatures determine the miner ordering in subsequent rounds. By controlling other miners' `PreviousInValue`, an attacker can influence the signature calculation and potentially manipulate who mines in what order, affecting block production fairness and predictability.

**Secret Sharing Compromise**: The corrupted `PreviousInValue` persists in state and could be used in secret sharing reconstruction, potentially causing reconstruction failures or incorrect values: [9](#0-8) 

All miners are affected as any miner can have their legitimately revealed `PreviousInValue` overwritten by any other miner.

### Likelihood Explanation

**High Likelihood**: 
- **Reachable Entry Point**: Any miner can call the public `UpdateValue` method with arbitrary `MinersPreviousInValues` data
- **No Special Privileges Required**: Attack requires only miner status, which is the normal operating role
- **Low Complexity**: Attacker simply includes target miner's pubkey in `MinersPreviousInValues` with any value they choose
- **No Cost Barrier**: Standard transaction fee only
- **No Detection Mechanism**: The malicious value is written to state without any validation or logging that would reveal the attack
- **Timing Window**: Attacker can execute after victim reveals their legitimate value but before it's used in calculations

The `ExtractInformationToUpdateConsensus` method shows the intended design was to copy existing `PreviousInValue` from state: [10](#0-9) 

However, since this happens off-chain with no on-chain validation, a malicious miner can modify these values before submitting the transaction.

### Recommendation

**Immediate Fix**: Add cryptographic validation in `PerformSecretSharing()` to verify each `PreviousInValue` in `MinersPreviousInValues` hashes to the corresponding miner's `OutValue` from the previous round:

```csharp
private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
    string publicKey, Round previousRound)
{
    minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
    foreach (var decryptedPreviousInValue in input.DecryptedPieces)
        round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
            .Add(publicKey, decryptedPreviousInValue.Value);

    foreach (var previousInValue in input.MinersPreviousInValues)
    {
        // CRITICAL: Validate the previous in value hashes to the out value
        if (previousRound != null && 
            previousRound.RealTimeMinersInformation.ContainsKey(previousInValue.Key))
        {
            var expectedOutValue = previousRound.RealTimeMinersInformation[previousInValue.Key].OutValue;
            var actualHash = HashHelper.ComputeFrom(previousInValue.Value);
            Assert(actualHash == expectedOutValue, 
                $"Invalid PreviousInValue for miner {previousInValue.Key}");
        }
        
        // Only set if not already set, or if setting to a validated value
        if (round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue == null ||
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue == Hash.Empty)
        {
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
        }
    }
}
```

**Additional Protections**:
1. Prevent overwriting an already-set `PreviousInValue` unless the new value is validated
2. Add event logging when `PreviousInValue` is set for forensic analysis
3. Add test cases that verify malicious `MinersPreviousInValues` are rejected

### Proof of Concept

**Initial State**:
- Round N completed with Miner A having `OutValue_A = hash("legitimate_secret")`
- Round N+1 begins

**Attack Sequence**:

1. **Block 1 (Height H)**: Miner A calls `UpdateValue` with:
   - `previous_in_value = "legitimate_secret"`
   - Validation passes: `hash("legitimate_secret") == OutValue_A` ✓
   - State updated: `Round[N+1].RealTimeMinersInformation[A].PreviousInValue = "legitimate_secret"`

2. **Block 2 (Height H+1)**: Miner B (attacker) calls `UpdateValue` with:
   - `previous_in_value = "miner_b_secret"` (Miner B's own legitimate value)
   - `miners_previous_in_values[A] = "fake_value"` where `hash("fake_value") ≠ OutValue_A`
   - Validation passes: Only checks `hash("miner_b_secret") == OutValue_B` ✓
   - Does NOT check `hash("fake_value") == OutValue_A`
   - `PerformSecretSharing` executes line 296: overwrites with `"fake_value"`
   - State updated: `Round[N+1].RealTimeMinersInformation[A].PreviousInValue = "fake_value"`

**Expected Result**: State should reject invalid `PreviousInValue` that doesn't hash to `OutValue_A`

**Actual Result**: State contains `"fake_value"` for Miner A's `PreviousInValue`, breaking the cryptographic commitment and enabling subsequent consensus manipulation when this value is used for signature calculation or secret sharing reconstruction.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L263-264)
```csharp
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** protobuf/aedpos_contract.proto (L215-216)
```text
    // The InValue in the previous round, miner public key -> InValue.
    map<string, aelf.Hash> miners_previous_in_values = 11;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```
