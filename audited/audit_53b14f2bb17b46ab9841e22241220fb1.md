# Audit Report

## Title
Token Deposit Loss Through Pubkey Replacement in Election Contract

## Summary
When a candidate self-registers via `AnnounceElection` and subsequently has their public key replaced via `ReplaceCandidatePubkey`, the 100,000 ELF deposit refund is incorrectly sent to an address derived from the NEW public key upon calling `QuitElection`, rather than being returned to the original depositor. This results in permanent loss of the candidate's deposit.

## Finding Description

The vulnerability exists in a critical discrepancy between how `AnnounceElection` and `AnnounceElectionFor` handle sponsor tracking, combined with flawed refund logic in `QuitElection`.

**Root Cause - Missing Sponsor Tracking:**

When a candidate self-registers through `AnnounceElection`, the function locks a 100,000 ELF deposit from `Context.Sender` but critically fails to record the sponsor in `State.CandidateSponsorMap`. [1](#0-0) 

In contrast, `AnnounceElectionFor` properly records the sponsor: [2](#0-1) 

The deposit locking mechanism is identical in both cases, transferring from `Context.Sender`: [3](#0-2) 

**Sponsor Map Transfer During Pubkey Replacement:**

When `ReplaceCandidatePubkey` is called, it transfers the sponsor map entry from old to new pubkey, preserving null values: [4](#0-3) 

Since `State.CandidateSponsorMap[oldPubkey]` is null for candidates who used `AnnounceElection`, the new pubkey also gets a null sponsor value.

**Failure Point - Incorrect Refund Address:**

In `QuitElection`, the refund logic uses a fallback that derives the recipient address from the NEW pubkey parameter: [5](#0-4) 

The critical flaw is that `pubkeyBytes` (line 231) is derived from `input.Value` which represents the current (NEW) pubkey after replacement. Since `State.CandidateSponsorMap[input.Value]` is null, the fallback `Address.FromPublicKey(pubkeyBytes)` uses the NEW pubkey to determine the recipient, not the original depositor's address.

The deposit amount is defined as 100,000 ELF: [6](#0-5) 

## Impact Explanation

**Direct Financial Loss:**
- The original candidate loses their entire 100,000 ELF deposit permanently
- The funds are transferred to an address derived from the replacement pubkey, which may be:
  - Controlled by a different party (in malicious admin scenarios)
  - Completely inaccessible (if the replacement pubkey was generated for a different purpose without corresponding private key control)

**Affected Scenarios:**
1. **Legitimate Key Rotation**: Honest candidates who perform legitimate key rotation for security reasons will lose their deposit upon withdrawal
2. **Malicious Admin Attack**: An admin can deliberately replace a candidate's pubkey to one they control, then call `QuitElection` to redirect the 100,000 ELF deposit to themselves

**Severity Justification:**
This is a CRITICAL vulnerability because:
- It causes complete and permanent loss of substantial funds (100,000 ELF per candidate)
- It affects a core governance mechanism (election candidate management)
- It triggers through normal, documented operational flows (key rotation + withdrawal)
- No recovery mechanism exists once funds are sent to the wrong address
- It violates the fundamental protocol invariant that deposits should be refunded to the original payer

## Likelihood Explanation

**High Likelihood - Normal Operations Trigger the Bug:**

The vulnerability manifests through standard contract operations without requiring any special conditions:

1. Candidate calls `AnnounceElection` (common self-registration path)
2. Candidate or their admin calls `ReplaceCandidatePubkey` (documented feature for key rotation)
3. Admin calls `QuitElection` (standard withdrawal mechanism)

**No Complex Preconditions:**
- No timing requirements or race conditions
- No special state manipulation needed
- No coordination with external contracts
- Pubkey replacement is a documented and intentionally supported feature for operational key management [7](#0-6) 

**Attack Vectors:**
- **Accidental Loss**: Even with honest participants, legitimate key rotation followed by election withdrawal results in fund loss
- **Malicious Admin**: An admin (intentionally granted by candidate) can exploit this to steal the deposit by replacing the pubkey to one they control

**Current Test Coverage Gap:**

Existing tests verify that `QuitElection` works after `ReplaceCandidatePubkey`, but do not verify WHERE the deposit is sent: [8](#0-7) 

## Recommendation

**Fix 1: Track Original Depositor**
Store the original depositor address when locking the deposit, similar to how `AnnounceElectionFor` works:

```csharp
public override Empty AnnounceElection(Address input)
{
    var recoveredPublicKey = Context.RecoverPublicKey();
    AnnounceElection(recoveredPublicKey);

    var pubkey = recoveredPublicKey.ToHex();
    var address = Address.FromPublicKey(recoveredPublicKey);

    Assert(input.Value.Any(), "Admin is needed while announcing election.");
    Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
    State.CandidateAdmins[pubkey] = input;
    var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
    managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
    State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

    LockCandidateNativeToken();
    
    // FIX: Record the sponsor (depositor)
    State.CandidateSponsorMap[pubkey] = Context.Sender;

    AddCandidateAsOption(pubkey);

    if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
    {
        State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
        RegisterCandidateToSubsidyProfitScheme(pubkey);
    }

    return new Empty();
}
```

**Fix 2: Alternative - Use Initial Pubkey for Refund**
Modify `QuitElection` to always refund to the address derived from the initial pubkey:

```csharp
public override Empty QuitElection(StringValue input)
{
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
    QuitElection(pubkeyBytes);
    var pubkey = input.Value;

    var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
    Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
    var candidateInformation = State.CandidateInformationMap[pubkey];

    // Unlock candidate's native token.
    var lockId = candidateInformation.AnnouncementTransactionId;
    var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
    
    // FIX: Use initialPubkey for address derivation
    var initialPubkeyBytes = ByteArrayHelper.HexStringToByteArray(initialPubkey);
    State.TokenContract.TransferFrom.Send(new TransferFromInput
    {
        From = lockVirtualAddress,
        To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(initialPubkeyBytes),
        Symbol = Context.Variables.NativeSymbol,
        Amount = ElectionContractConstants.LockTokenForElection,
        Memo = "Quit election."
    });

    // ... rest of the function
}
```

**Recommended Approach:** Implement Fix 1 as it provides consistent sponsor tracking across both registration methods and maintains clear audit trails.

## Proof of Concept

```csharp
[Fact]
public async Task AnnounceElection_ReplacePubkey_QuitElection_DepositLoss_Test()
{
    // Setup: Get keypairs for original candidate, replacement pubkey, and admin
    var originalCandidateKeyPair = ValidationDataCenterKeyPairs.First();
    var replacementKeyPair = ValidationDataCenterKeyPairs.Skip(1).First();
    var adminKeyPair = ValidationDataCenterKeyPairs.Last();
    var adminAddress = Address.FromPublicKey(adminKeyPair.PublicKey);
    
    // Get original candidate's address (who will pay the deposit)
    var originalCandidateAddress = Address.FromPublicKey(originalCandidateKeyPair.PublicKey);
    
    // Get the address derived from replacement pubkey (where funds will incorrectly go)
    var replacementAddress = Address.FromPublicKey(replacementKeyPair.PublicKey);
    
    // Record balances before announcing election
    var originalBalanceBefore = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = originalCandidateAddress,
        Symbol = "ELF"
    });
    
    var replacementBalanceBefore = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = replacementAddress,
        Symbol = "ELF"
    });
    
    // Step 1: Original candidate announces election (locks 100,000 ELF from originalCandidateAddress)
    await AnnounceElectionAsync(originalCandidateKeyPair, adminAddress);
    
    // Verify deposit was locked from original candidate
    var originalBalanceAfterAnnounce = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = originalCandidateAddress,
        Symbol = "ELF"
    });
    originalBalanceAfterAnnounce.Balance.ShouldBe(
        originalBalanceBefore.Balance - ElectionContractConstants.LockTokenForElection);
    
    // Step 2: Admin replaces candidate's pubkey
    var adminStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, adminKeyPair);
    await adminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = originalCandidateKeyPair.PublicKey.ToHex(),
        NewPubkey = replacementKeyPair.PublicKey.ToHex()
    });
    
    // Step 3: Admin quits election with the NEW pubkey
    await adminStub.QuitElection.SendAsync(new StringValue 
    { 
        Value = replacementKeyPair.PublicKey.ToHex() 
    });
    
    // Verify the vulnerability: funds went to WRONG address
    var originalBalanceAfterQuit = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = originalCandidateAddress,
        Symbol = "ELF"
    });
    
    var replacementBalanceAfterQuit = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = replacementAddress,
        Symbol = "ELF"
    });
    
    // VULNERABILITY PROOF: Original candidate did NOT receive their deposit back
    originalBalanceAfterQuit.Balance.ShouldBe(originalBalanceAfterAnnounce.Balance);
    
    // VULNERABILITY PROOF: Replacement address received the deposit instead
    replacementBalanceAfterQuit.Balance.ShouldBe(
        replacementBalanceBefore.Balance + ElectionContractConstants.LockTokenForElection);
    
    // This proves the 100,000 ELF deposit was sent to the WRONG address
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-249)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-257)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);

        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));

        //     Remove origin pubkey from Candidates, DataCentersRankingList and InitialMiners; then add new pubkey.
        var candidates = State.Candidates.Value;
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }

        var rankingList = State.DataCentersRankingList.Value;
        //the profit receiver is not exist but candidate in the data center ranking list
        if (rankingList.DataCenters.ContainsKey(input.OldPubkey))
        {
            rankingList.DataCenters.Add(input.NewPubkey, rankingList.DataCenters[input.OldPubkey]);
            rankingList.DataCenters.Remove(input.OldPubkey);
            State.DataCentersRankingList.Value = rankingList;

            // Notify Profit Contract to update backup subsidy profiting item.
            if (State.ProfitContract.Value == null)
                State.ProfitContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            
            var oldProfitReceiver = GetProfitsReceiverOrDefault(input.OldPubkey);
            var profitReceiver = oldProfitReceiver.Value.Any()
                ? oldProfitReceiver
                : null;
            RemoveBeneficiary(input.OldPubkey);
            AddBeneficiary(input.NewPubkey, profitReceiver);
        }

        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }

        //     For CandidateVotes and CandidateInformation, just replace value of origin pubkey.
        var candidateVotes = State.CandidateVotes[input.OldPubkey];
        if (candidateVotes != null)
        {
            candidateVotes.Pubkey = newPubkeyBytes;
            State.CandidateVotes[input.NewPubkey] = candidateVotes;
            State.CandidateVotes.Remove(input.OldPubkey);
        }

        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
        }

        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;

        ReplaceCandidateProfitsReceiver(input.OldPubkey, input.NewPubkey);
        
        Context.Fire(new CandidatePubkeyReplaced
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L320-321)
```csharp
        State.CandidateSponsorMap[newPubkey] = State.CandidateSponsorMap[oldPubkey];
        State.CandidateSponsorMap.Remove(oldPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ReplaceCandidateTests.cs (L77-85)
```csharp
        // Only admin can quit election.
        {
            await candidateAdminStub.QuitElection.SendAsync(new StringValue
            {
                Value = newKeyPair.PublicKey.ToHex()
            });
            var candidates = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
            candidates.Value.ShouldNotContain(ByteString.CopyFrom(newKeyPair.PublicKey));
        }
```
