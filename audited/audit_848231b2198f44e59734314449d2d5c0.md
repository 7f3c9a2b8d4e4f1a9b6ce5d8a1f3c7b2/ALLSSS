### Title
Consensus Permanent Halt Due to Empty Miner List and Flawed Election Backup Logic

### Summary
A critical logic flaw in the Election contract's `GetVictories` backup mechanism combined with insufficient validation in the consensus contract's term transition logic can cause permanent consensus halt. When the current miner list becomes empty and Election returns empty victories, the assertion protecting term transition fails, preventing any miner from producing the next term block and permanently freezing the blockchain.

### Finding Description

**Root Cause - Election Contract Backup Logic Flaw:**

The Election contract's `GetVictories` method has a critical bug in its backup miner selection logic. When there are insufficient valid candidates, it attempts to use current miners and initial miners as backups. However, the backup selection is incorrectly limited by `currentMiners.Count`: [1](#0-0) 

When `currentMiners.Count = 0`, the `.Take(Math.Min(diff, 0))` operation returns zero backups, even when `backups` list contains `initialMiners`. This causes `GetVictories` to return an empty list.

**Consensus Contract Vulnerability Chain:**

1. The `TryToGetVictories` method calls Election's `GetVictories` and checks if the result is empty: [2](#0-1) 

2. When Election returns empty victories, `TryToGetVictories` returns `false`, triggering the fallback in `GenerateFirstRoundOfNextTerm`: [3](#0-2) 

3. The fallback creates a miner list from `currentRound.RealTimeMinersInformation.Keys`, which is also empty, resulting in a `Round` with no miners.

4. When a `Round` has no miners, its `RoundId` is computed as zero: [4](#0-3) 

The sum of an empty collection's `ExpectedMiningTime.Seconds` is zero.

5. The assertion in `GetConsensusExtraDataForNextTerm` fails with `RoundId = 0`: [5](#0-4) 

**Why Protections Fail:**

The fallback mechanism assumes that if Election fails, the current round will have miners. However, if the current round is empty (due to failed miner replacements, state corruption, or edge cases in round management), both the primary path and fallback path produce empty miner lists. The assertion catches this but causes consensus to halt rather than recover.

### Impact Explanation

**Operational Impact - Permanent Consensus Halt:**

When this vulnerability is triggered, the blockchain enters an unrecoverable state:
- No miner can produce the next term block (assertion always fails)
- All block production stops permanently
- The entire blockchain is frozen until manual intervention
- Requires emergency hard fork or state recovery to resolve

**Who Is Affected:**
- All network participants (miners, users, applications)
- All pending transactions cannot be processed
- All smart contract operations halt

**Severity Justification:**
This is a **CRITICAL** vulnerability because it causes complete network unavailability with no automated recovery mechanism. Unlike temporary DoS that resolves after conditions change, this creates a permanent deadlock where the assertion prevents any valid term transition block from being produced.

### Likelihood Explanation

**Feasible Preconditions:**

This vulnerability can be triggered when:
1. The current round's miner list becomes empty due to:
   - All miners being replaced via evil node detection but replacement logic failing
   - State corruption affecting `RealTimeMinersInformation`
   - Edge cases in miner list management during abnormal conditions
2. A term transition is attempted (happens regularly based on `PeriodSeconds`)

**Attacker Capabilities:**

While this is not directly exploitable by an attacker, it can occur through:
- Natural consensus operation hitting edge cases
- State inconsistencies from prior bugs
- Failed miner replacement operations

A previous-round miner (who is still authorized per `PreCheck` logic) would attempt the NextTerm transition and trigger the vulnerability: [6](#0-5) 

**Execution Practicality:**

Once the current round has no miners:
1. Election's `GetCurrentMinerList` returns empty to Election contract
2. Election's backup logic fails due to the `.Take(Math.Min(diff, 0))` bug
3. Empty victories are returned
4. Consensus fallback also produces empty miner list
5. Assertion fails automatically on any NextTerm attempt

**Probability Assessment:**

While the exact precondition (empty current round) is unusual, it is realistic in:
- Long-running production systems with miner replacement logic
- Networks recovering from catastrophic failures
- Edge cases in the evil miner detection and replacement flow

The consequence (permanent halt) is deterministic once conditions are met.

### Recommendation

**Fix 1 - Correct Election Backup Logic:**

Modify the backup selection in `GetVictories` to use the size of the `backups` list rather than `currentMiners.Count`:

```csharp
// In contract/AElf.Contracts.Election/ViewMethods.cs line 71-74
victories.AddRange(backups.OrderBy(p => p)
    .Take(Math.Min(diff, backups.Count)) // Changed from currentMiners.Count
    .Select(v => ByteStringHelper.FromHexString(v)));
```

Or simply remove the limit since `diff` already bounds the selection:

```csharp
victories.AddRange(backups.OrderBy(p => p)
    .Take(diff)
    .Select(v => ByteStringHelper.FromHexString(v)));
```

**Fix 2 - Add Validation in GenerateFirstRoundOfNextTerm:**

Add explicit validation before returning the new round:

```csharp
// In contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs after line 242
Assert(miners.Pubkeys.Count > 0, 
    "Failed to determine miners for next term - both Election and current round are empty.");
```

**Fix 3 - Improve Fallback with InitialMiners:**

When both Election and current round fail, use `State.InitialMiners` as a last resort:

```csharp
// After line 241, before line 243
if (miners.Pubkeys.Count == 0 && State.InitialMiners.Value != null)
{
    miners.Pubkeys.AddRange(State.InitialMiners.Value.Pubkeys);
}
```

**Test Cases:**

1. Test Election's `GetVictories` with empty `currentMiners` but valid `initialMiners`
2. Test term transition when current round has no miners
3. Test fallback chain: Election fails → current round empty → initialMiners used
4. Verify assertion provides clear error message rather than silent failure

### Proof of Concept

**Required Initial State:**
1. Blockchain initialized with valid initial miners
2. System progressed through multiple terms
3. Current round's `RealTimeMinersInformation` is empty (simulated via state corruption or failed miner replacement)
4. Previous round has at least one miner who can call NextTerm

**Transaction Steps:**

1. **Setup:** Current round reaches end of term, triggering NextTerm behavior
2. **Trigger:** A previous-round miner calls `NextTerm` method
3. **Execution Flow:**
   - `GetConsensusExtraDataForNextTerm` is invoked during block production
   - Calls `GenerateFirstRoundOfNextTerm`
   - `TryToGetVictories` calls Election's `GetVictories`
   - Election's `GetCurrentMinerList` returns empty list
   - Election's backup logic: `backups` contains initial miners but `.Take(Math.Min(diff, 0))` returns zero items
   - Election returns empty `PubkeyList`
   - `TryToGetVictories` returns `false`
   - Fallback: `currentRound.RealTimeMinersInformation.Keys` is empty
   - `GenerateFirstRoundOfNewTerm` creates Round with zero miners
   - Round's `RoundId` computed as 0 (sum of empty collection)
   - Assertion fails: `Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.")`
   - Transaction reverts

**Expected vs Actual Result:**

- **Expected:** System should use initial miners as backup and successfully transition to next term
- **Actual:** Assertion fails, transaction reverts, no miner can produce next term block, consensus permanently halts

**Success Condition:**
The vulnerability is confirmed when attempting NextTerm with empty current round causes assertion failure and prevents all subsequent term transition attempts, effectively freezing the blockchain.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L66-74)
```csharp
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-242)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L209-210)
```csharp
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```
