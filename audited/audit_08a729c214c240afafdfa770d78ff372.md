### Title
Division by Zero Vulnerability in Miner Increase Interval Configuration

### Summary
The `SetMinerIncreaseInterval()` function allows setting `MinerIncreaseInterval` to zero through insufficient input validation, which causes division by zero errors in critical consensus operations. This vulnerability can permanently break consensus functionality including term transitions, miner count calculations, and view methods.

### Finding Description

**Root Cause:**

The `SetMinerIncreaseInterval()` function contains an assertion that only validates the new value is not greater than the current value, but does not enforce a minimum bound greater than zero. [1](#0-0) 

This assertion allows `input.Value = 0` to pass when `State.MinerIncreaseInterval.Value` is already set to a positive value (initially set to 31536000 seconds during contract initialization). [2](#0-1) 

**Vulnerable Division Operations:**

After setting the value to zero, multiple critical functions perform division by `State.MinerIncreaseInterval.Value` without checking if it's zero:

1. The public view method `GetAutoIncreasedMinersCount()` performs division: [3](#0-2) 

2. The private helper `GetMinersCount(Round input)` also performs the same division: [4](#0-3) 

**Failure Points:**

The division by zero error will occur when:

- Anyone calls the public view method `GetMaximumMinersCount()`, which internally calls `GetAutoIncreasedMinersCount()`: [5](#0-4) 

- Governance attempts to update maximum miners count via `SetMaximumMinersCount()`: [6](#0-5) 

- Consensus processes term transitions in `UpdateMinersCountToElectionContract()`: [7](#0-6) 

- First round initialization processes consensus information: [8](#0-7) 

### Impact Explanation

**Operational Impact - CRITICAL:**

Setting `MinerIncreaseInterval` to zero causes a complete breakdown of critical consensus operations:

1. **View Method DoS**: The public `GetMaximumMinersCount()` view method becomes unusable, throwing division by zero exceptions for any caller.

2. **Governance Operations Break**: The `SetMaximumMinersCount()` governance function fails when attempting to update the election contract with the calculated miner count.

3. **Consensus Halts**: Term transitions fail in `UpdateMinersCountToElectionContract()`, preventing the consensus mechanism from advancing to new terms.

4. **Chain Initialization Fails**: New chains or first-round processing becomes impossible.

5. **Irreversible State**: Once set to zero, the value cannot be increased back to a valid positive value because the assertion requires `input.Value <= State.MinerIncreaseInterval.Value`, making any positive value invalid.

This affects all users, node operators, and the entire blockchain network by halting consensus progression and preventing dynamic miner count adjustments.

### Likelihood Explanation

**Feasibility - HIGH:**

- **Entry Point**: `SetMinerIncreaseInterval()` is a public method callable by the MaximumMinersCountController (typically the Parliament default organization). [9](#0-8) 

- **Preconditions**: Requires governance approval, but this is a standard configuration change, not a security breach. The vulnerability can be triggered through:
  - Accidental misconfiguration (governance might assume 0 means "disable auto-increase")
  - Malicious governance proposal
  - Misunderstanding of parameter semantics

- **Execution Complexity**: Simple - single transaction with `input.Value = 0` passes the validation and sets the state.

- **Detection**: The issue would only be detected after the transaction succeeds, when subsequent operations fail with division by zero errors.

### Recommendation

**Code-Level Mitigation:**

Add a minimum value check in `SetMinerIncreaseInterval()` to enforce that the interval must be greater than zero:

```csharp
Assert(input.Value > 0, "Miner increase interval must be greater than zero.");
```

This check should be added before line 61 in the function.

**Additional Safeguards:**

1. Consider adding a maximum reasonable bound to prevent extremely small intervals that could cause frequent auto-increments.

2. Add defensive checks in division operations to handle edge cases:
```csharp
if (State.MinerIncreaseInterval.Value == 0) 
    return AEDPoSContractConstants.SupposedMinersCount;
```

3. Add unit tests specifically for boundary conditions:
   - Test that `SetMinerIncreaseInterval()` rejects zero
   - Test that `SetMinerIncreaseInterval()` rejects negative values
   - Test that division operations handle unexpected zero values gracefully

### Proof of Concept

**Initial State:**
- Contract initialized with `State.MinerIncreaseInterval.Value = 31536000` (default 1 year)

**Attack Sequence:**

1. **Step 1**: MaximumMinersCountController (Parliament) submits proposal to call `SetMinerIncreaseInterval(Int64Value{Value = 0})`

2. **Step 2**: Proposal passes governance approval and executes
   - Assertion `input.Value <= State.MinerIncreaseInterval.Value` evaluates to `0 <= 31536000` → TRUE (passes)
   - State updated: `State.MinerIncreaseInterval.Value = 0`

3. **Step 3**: Any subsequent call to `GetMaximumMinersCount()` fails:
   - Method calls `GetAutoIncreasedMinersCount()`
   - Calculation reaches `.Div(State.MinerIncreaseInterval.Value)` → `.Div(0)`
   - **Result**: Division by zero exception, transaction reverts

4. **Step 4**: Term transition attempts to execute:
   - Calls `GetMinersCount(round)` 
   - Calculation reaches `.Div(State.MinerIncreaseInterval.Value)` → `.Div(0)`
   - **Result**: Consensus halts, cannot advance to next term

**Expected vs Actual Result:**

- **Expected**: Setting miner increase interval should validate input and maintain consensus operations
- **Actual**: Zero value passes validation, breaks all miner count calculations, halts consensus permanently

**Success Condition**: The vulnerability is successfully exploited when `State.MinerIncreaseInterval.Value` becomes zero and subsequent division operations fail with runtime exceptions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L25-25)
```csharp
            MinersCount = GetMinersCount(round)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L59-60)
```csharp
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L61-61)
```csharp
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L76-76)
```csharp
            Value = Math.Min(GetAutoIncreasedMinersCount(), State.MaximumMinersCount.Value)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L93-94)
```csharp
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L31-31)
```csharp
        State.MinerIncreaseInterval.Value = input.MinerIncreaseInterval;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L389-390)
```csharp
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L55-55)
```csharp
        var minersCount = GetMinersCount(input);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L128-128)
```csharp
                var minersCount = GetMinersCount(nextRound);
```
