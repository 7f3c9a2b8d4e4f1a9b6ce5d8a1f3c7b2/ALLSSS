### Title
Double Share Allocation Vulnerability: AddBeneficiary and RegisterForProfits Interaction Allows Uncollateralized Profit Claims

### Summary
A critical vulnerability exists in the TokenHolder contract where a user added via `AddBeneficiary` can subsequently call `RegisterForProfits`, resulting in duplicate profit share allocations. The user receives shares from both methods simultaneously, allowing them to claim profits based on inflated share counts without corresponding token collateral, while also breaking manager control over beneficiary updates.

### Finding Description

**Root Cause:**
The `RegisterForProfits` method only validates whether a user has an existing lock ID, but fails to check if the user is already a beneficiary in the underlying Profit contract. [1](#0-0) 

The Profit contract's `AddBeneficiary` implementation allows multiple `ProfitDetail` entries per beneficiary by appending to a list rather than enforcing uniqueness. [2](#0-1) 

**Exploitation Path - Scenario 1 (AddBeneficiary → RegisterForProfits):**

1. Manager calls `AddBeneficiary` for userX with 100 shares. The Profit contract creates a ProfitDetail with 100 shares and increments TotalShares by 100. No lock ID is created. [3](#0-2) 

2. UserX calls `RegisterForProfits` with 50 tokens. The assertion passes because no lock ID exists yet, despite userX already being a beneficiary. [1](#0-0) 

3. The method locks 50 tokens, sets the lock ID, then calls Profit contract's `AddBeneficiary` with 50 shares. [4](#0-3) 

4. The Profit contract appends a second ProfitDetail (50 shares) to the existing list, incrementing TotalShares by another 50. [5](#0-4) 

5. UserX now has TWO profit details totaling 150 shares, but only 50 tokens locked.

**Critical Breakage:**
When the manager attempts to update this beneficiary using `AddBeneficiary` or `RemoveBeneficiary`, the code expects exactly one profit detail and calls `.Single()` on the details collection, which throws an exception when multiple details exist. [6](#0-5) [7](#0-6) 

**Profit Calculation:**
When claiming profits, the system iterates over all profit details for a beneficiary and sums their contributions. [8](#0-7)  UserX receives profits proportional to 150 shares despite only having 50 tokens locked.

**Withdrawal Impact:**
When userX calls `Withdraw`, the method removes the beneficiary from the Profit contract, which removes ALL profit details. [9](#0-8)  The user loses access to both profit streams (including the 100 shares that required no lock).

### Impact Explanation

**Direct Fund Impact:**
- **Reward Misallocation**: Users receive profit distributions based on inflated share counts (150 shares) while only providing collateral for a fraction (50 tokens). In a scheme with 1000 total shares distributed over 1000 ELF tokens, a legitimately locked user with 100 tokens should receive 10% (100 ELF). However, an exploiting user with only 50 tokens locked but 150 shares allocated receives 15% (150 ELF), stealing 50 ELF from other legitimate beneficiaries.

- **Uncollateralized Claims**: The 100 shares added via `AddBeneficiary` require no token lock but grant full profit rights equal to locked positions. This violates the fundamental invariant that profit shares should be backed by locked tokens.

**Operational Impact:**
- **Manager Control Loss**: After a user triggers this scenario, the manager's `AddBeneficiary` and `RemoveBeneficiary` functions become permanently inoperable for that beneficiary due to `.Single()` exceptions. This is a complete DoS of critical administrative functions.

- **Share Calculation Corruption**: The scheme's TotalShares becomes inflated relative to actually locked tokens, causing permanent distortion in all subsequent profit distribution calculations for all participants.

**Affected Parties:**
- Legitimate beneficiaries who receive diluted profit shares
- Scheme managers who lose the ability to update beneficiary allocations
- The protocol's profit distribution integrity

### Likelihood Explanation

**Reachable Entry Point:**
Both `AddBeneficiary` (manager-callable) and `RegisterForProfits` (user-callable) are public methods with standard access controls. [10](#0-9) [11](#0-10) 

**Attack Complexity:**
- **Trivial Execution**: Requires only two sequential transactions with no special timing or state manipulation
- **No Special Privileges**: Any user can be added by a manager and can subsequently call `RegisterForProfits`
- **Undetectable Prerequisites**: The vulnerability state (multiple profit details) is not visible to managers before they attempt updates

**Feasibility Conditions:**
- **Accidental Trigger**: Can occur unintentionally when a manager adds a user who later independently decides to register for profits, unaware of their existing beneficiary status
- **Intentional Exploitation**: A malicious user who knows they've been added by the manager can deliberately call `RegisterForProfits` to double their shares while only locking minimal tokens
- **No Economic Barrier**: The attack requires only minimal token holdings (e.g., 50 tokens) to lock, while gaining shares equivalent to much larger amounts

**Detection Constraints:**
The vulnerability leaves no obvious on-chain indicators until:
1. Manager attempts to update the beneficiary and encounters exceptions
2. Profit distribution shows unexplained share inflation
3. User withdraws and loses unexpectedly large share allocations

**Probability Assessment:**
HIGH - Given the common workflow where managers pre-allocate beneficiaries and users later engage with the system, this scenario will occur with regularity in normal operations.

### Recommendation

**Immediate Fix:**
Add a beneficiary existence check in `RegisterForProfits` before the lock ID assertion:

```solidity
// In RegisterForProfits, after line 151
var existingDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
{
    SchemeId = scheme.SchemeId,
    Beneficiary = Context.Sender
});
Assert(existingDetails == null || !existingDetails.Details.Any(), 
    "User is already a beneficiary. Cannot register for profits.");
```

**Alternative Approach:**
Modify `RegisterForProfits` to handle existing beneficiaries by:
1. Checking for existing profit details
2. If found, remove them first (similar to AddBeneficiary's logic)
3. Add back with combined shares and set the lock ID
4. Ensure `AddBeneficiary` also checks for lock IDs and handles locked users appropriately

**Invariant Enforcement:**
- Add constraint: Each user can be a beneficiary through EITHER `AddBeneficiary` OR `RegisterForProfits`, never both simultaneously
- Add constraint: Users with lock IDs must have exactly one profit detail
- Add constraint: `AddBeneficiary` should fail if the user has an active lock ID

**Test Cases:**
1. Test: AddBeneficiary → RegisterForProfits → verify transaction reverts
2. Test: RegisterForProfits → AddBeneficiary → verify proper share consolidation
3. Test: Manager updates after RegisterForProfits → verify no `.Single()` exceptions
4. Test: Profit calculations with multiple details → verify correct share counting

### Proof of Concept

**Initial State:**
- TokenHolder scheme exists with manager M
- User U has 100 tokens, 50 are available for locking
- Scheme has 1000 total shares from other beneficiaries
- Scheme holds 1000 ELF in profits ready to distribute

**Attack Sequence:**

1. **Manager adds beneficiary:**
   - M calls `AddBeneficiary(U, 100 shares)`
   - State: U has 100 shares, no tokens locked
   - TotalShares = 1100

2. **User registers for profits:**
   - U calls `RegisterForProfits(50 amount)`
   - Assertion passes (no lock ID exists)
   - 50 tokens locked
   - State: U now has TWO profit details (100 + 50 = 150 shares)
   - TotalShares = 1150

3. **Expected Result:**
   - U should have either 100 shares (from manager) OR 50 shares (from locking), not both
   
4. **Actual Result:**
   - U has 150 shares total (150/1150 = 13.04% of scheme)
   - U claims 130.4 ELF from the 1000 ELF distribution
   - U only has 50 tokens locked (should receive ~43.5 ELF if properly proportional)
   - **Excess profit claimed: ~87 ELF stolen from other beneficiaries**

5. **Manager DoS Verification:**
   - M attempts `AddBeneficiary(U, newShares)` or `RemoveBeneficiary(U)`
   - Transaction fails with exception on `.Single()` call
   - M has permanently lost control over user U's allocation

**Success Condition:**
User U successfully claims 130.4 ELF based on 150 shares while only locking 50 tokens worth of collateral, demonstrating the share calculation error and fund misallocation.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-68)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }

        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = shares
            }
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L78-78)
```csharp
        }).Details.Single();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-149)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L151-151)
```csharp
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L157-176)
```csharp
        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L239-243)
```csharp
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L113-135)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod < scheme.CurrentPeriod && (d.LastProfitPeriod == 0
                ? d.EndPeriod >= d.StartPeriod
                : d.EndPeriod >= d.LastProfitPeriod)
        ).ToList();
        
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, availableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);

        var allProfitsDict = new Dictionary<string, long>();
        var claimableProfitsDict = new Dictionary<string, long>();
        for (var i = 0; i < availableDetails.Count; i++)
        {
            var profitDetail = availableDetails[i];
            if (profitDetail.LastProfitPeriod == 0) profitDetail.LastProfitPeriod = profitDetail.StartPeriod;
            
            var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod),true, symbol);
            AddProfitToDict(allProfitsDict, totalProfitsDictForEachProfitDetail);
            if(i >= profitableDetailCount) continue;
            var claimableProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount,true, symbol);
            AddProfitToDict(claimableProfitsDict, claimableProfitsDictForEachProfitDetail);
        }
```
