# Audit Report

## Title
Consensus Takeover via Unvalidated NextTerm Miner List - State Poisoning Leading to Complete Consensus Breach

## Summary
The AEDPoS consensus contract's `NextTerm` method accepts arbitrary miner lists without validating them against the Election contract's authoritative results. A malicious current miner can submit a `NextTerm` transaction with a custom miner list, which gets persisted to StateDb and used for all subsequent mining permission validation, enabling complete consensus takeover.

## Finding Description

The vulnerability exists in the validation and execution pipeline for `NextTerm` consensus transactions.

**Validation Gap:**

When a NextTerm transaction is validated, the system only adds `RoundTerminateValidationProvider` to the validation chain. [1](#0-0) 

This provider only validates that round and term numbers increment correctly, not the miner list contents. [2](#0-1) 

**Execution Without Verification:**

The `ProcessNextTerm` method directly converts the input to a Round object and extracts the miner list from it without any Election contract verification. [3](#0-2) 

The miner list is created directly from `nextRound.RealTimeMinersInformation.Keys` and stored to state. [4](#0-3) 

**Proper Generation Bypassed:**

While `GenerateFirstRoundOfNextTerm` correctly queries the Election contract's `GetVictories` to obtain legitimate elected miners, this is only used for generating the intended input structure, not for validation. [5](#0-4) 

The Election contract call that retrieves authoritative victories is never invoked during validation. [6](#0-5) 

**Post-Execution Validation Insufficient:**

The `ValidateConsensusAfterExecution` method compares header information against state, but after execution both contain the same malicious miner list, so the comparison passes. [7](#0-6) 

**Future Impact on Mining Permission:**

Subsequent blocks validate mining permission by checking if the miner exists in `BaseRound.RealTimeMinersInformation`, which is loaded from the now-poisoned StateDb. [8](#0-7) 

**Attack Prerequisites:**

The attacker must be a current miner to pass the `PreCheck` authorization. [9](#0-8) 

## Impact Explanation

**Critical Consensus Compromise:**

1. **Complete Takeover**: An attacker replaces the legitimate elected miner list with arbitrary addresses, gaining control over block production for the entire term.

2. **Democracy Nullification**: Election results from token holder votes are ignored. The Election contract maintains the correct winners, but the consensus contract uses the attacker's list.

3. **Legitimate Miner DoS**: Properly elected miners cannot produce blocks because `MiningPermissionValidationProvider` checks against the corrupted `BaseRound`, which doesn't contain their pubkeys.

4. **Persistent State Poisoning**: The corrupted miner list remains in StateDb (`State.MinerListMap[termNumber]` and `State.MainChainCurrentMinerList`) for the entire term, affecting all subsequent blocks.

5. **Censorship & MEV**: Attacker-controlled miners can censor transactions, reorder blocks for MEV extraction, and manipulate consensus behavior.

This breaks the fundamental security invariant that only elected miners can participate in consensus, compromising the entire blockchain's integrity.

## Likelihood Explanation

**High Feasibility:**

1. **Attacker Pool**: Any current miner can attempt the attack. With typical configurations of 5-21 miners, multiple potential attackers exist.

2. **Opportunity Window**: Attackers get a chance at every term boundary (typically every few days based on `periodSeconds` configuration).

3. **Probability**: Attacker has ~1/N chance of producing the NextTerm block where N is the number of current miners. With N=17, that's ~6% per term.

4. **Multiple Attempts**: Failed attempts don't expose the attacker. They can retry at the next term transition.

5. **No Special Resources**: Attack requires only:
   - Being a current miner (legitimate but malicious)
   - Standard transaction crafting capability
   - Ability to modify `RealTimeMinersInformation` in the NextTermInput

6. **Low Complexity**: No cryptographic breaks, race conditions, or timing attacks required. Simple message modification.

7. **Collusion Amplification**: Multiple malicious miners can coordinate to increase success probability.

## Recommendation

Add validation in `RoundTerminateValidationProvider.ValidationForNextTerm` or create a new validation provider specifically for NextTerm that:

1. Calls `State.ElectionContract.GetVictories.Call(new Empty())` to retrieve authoritative elected miners
2. Compares the provided `extraData.Round.RealTimeMinersInformation.Keys` against the victories
3. Rejects the transaction if miner lists don't match (allowing only for legitimate miner pubkey updates)

Example fix location:
```
In RoundTerminateValidationProvider.ValidationForNextTerm:
- After validating round/term numbers
- Before returning success
- Add: Verify extraData.Round miner list matches Election contract GetVictories result
```

Alternatively, add a `NextTermMinerListValidationProvider` that performs this check and include it in the validation chain for NextTerm behavior.

## Proof of Concept

```csharp
// This test demonstrates the vulnerability
// Setup: Deploy consensus and election contracts, initialize first term with legitimate miners
// Attack: Current miner submits NextTerm with custom miner list
// Verify: Unauthorized miner can now produce blocks, legitimate miners are blocked

[Fact]
public async Task ConsensusAttack_NextTermMinerListNotValidated()
{
    // 1. Initialize with legitimate miners from election
    var legitimateMiners = new[] { "miner1_pubkey", "miner2_pubkey", "miner3_pubkey" };
    await ElectionContract.InitializeAsync(legitimateMiners);
    
    // 2. Attacker (current miner1) crafts malicious NextTerm
    var attackerAddress = "attacker_pubkey";  
    var maliciousNextTermInput = new NextTermInput
    {
        TermNumber = 2,
        RoundNumber = 1, 
        RealTimeMinersInformation = {
            { attackerAddress, new MinerInRound { Order = 1, ... } }
            // Attacker's list - excludes legitimate miners
        }
    };
    
    // 3. Submit malicious NextTerm transaction
    await ConsensusContract.NextTermAsync(maliciousNextTermInput);
    
    // 4. Verify attack succeeded
    var currentRound = await ConsensusContract.GetCurrentRoundInformationAsync();
    Assert.True(currentRound.RealTimeMinersInformation.ContainsKey(attackerAddress));
    Assert.False(currentRound.RealTimeMinersInformation.ContainsKey("miner2_pubkey"));
    
    // 5. Verify legitimate miner is now blocked
    var validationResult = await ConsensusContract.ValidateConsensusBeforeExecutionAsync(
        legitimateMiner2Block);
    Assert.False(validationResult.Success); // Fails MiningPermissionValidationProvider
    Assert.Contains("not a miner", validationResult.Message);
    
    // 6. Verify attacker can produce blocks
    var attackerBlockResult = await ConsensusContract.ValidateConsensusBeforeExecutionAsync(
        attackerBlock);
    Assert.True(attackerBlockResult.Success); // Passes all validation
}
```

**Notes:**

This vulnerability represents a fundamental flaw in the AEDPoS consensus validation architecture. The separation between input generation (which correctly queries Election contract) and input validation (which does not) creates an exploitable gap. Any current miner can leverage this to perform a consensus takeover, completely subverting the democratic election process and compromising blockchain integrity for an entire term.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-46)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L274-282)
```csharp
        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L99-124)
```csharp
            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-24)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
```
