### Title
Subsidy Profit Scheme Share Multiplication Through Quit/Rejoin Cycles

### Summary
Candidates can accumulate multiple shares in the subsidy profit scheme by repeatedly quitting and rejoining election when the validation data center count condition allows. The `QuitElection` function fails to remove beneficiaries from the subsidy scheme, while `RegisterCandidateToSubsidyProfitScheme` adds them again on re-announcement, resulting in multiplied profit shares and subsidy fund drainage.

### Finding Description

The vulnerability exists in the election candidate announcement and quit flow:

**Registration to Subsidy Scheme:**
When a candidate announces election via `AnnounceElection` or `AnnounceElectionFor`, if the total candidate count is less than or equal to the validation data center count (miners × 5), they are registered to the subsidy profit scheme through `RegisterCandidateToSubsidyProfitScheme`. [1](#0-0) [2](#0-1) 

This calls `AddBeneficiary` which registers them to the subsidy scheme with 1 share: [3](#0-2) [4](#0-3) 

**Missing Cleanup on Quit:**
When a candidate quits election through `QuitElection`, the function removes them from the candidate list, updates their data center ranking to 0, and sets `IsCurrentCandidate = false`, but crucially **does NOT call `RemoveBeneficiary`** to remove them from the subsidy profit scheme: [5](#0-4) 

**Duplicate Registration Mechanism:**
The Profit contract's `AddBeneficiary` function does not prevent duplicate registrations. When a beneficiary already has profit details, it simply adds another detail to their list: [6](#0-5) 

**Re-announcement Allowed:**
Since `IsCurrentCandidate` is set to false on quit, the candidate can successfully re-announce election as the check passes: [7](#0-6) 

**Multiplied Profit Claims:**
When claiming profits, the contract iterates through ALL profit details for a beneficiary and calculates profits for each one independently, effectively multiplying their rewards: [8](#0-7) 

### Impact Explanation

**Direct Fund Theft:**
- Attackers can accumulate N profit details, each with 1 share, giving them effectively N shares of the subsidy pool
- Each quit/rejoin cycle when `candidateCount ≤ validationDataCenterCount` multiplies their subsidy allocation
- This directly drains the subsidy funds intended for legitimate backup candidates

**Reward Misallocation:**
- Total shares in the scheme increase artificially as duplicate beneficiaries are added
- Honest candidates receive proportionally less subsidy rewards as the exploiter accumulates more shares
- The subsidy distribution becomes unfair and undermines the economic security model

**System Integrity:**
- The subsidy scheme's `TotalShares` increases but doesn't reflect actual unique beneficiaries
- Treasury calculations for subsidy allocation become incorrect
- Long-term exploitation could deplete subsidy reserves entirely

**Quantified Damage:**
If 10 candidates exploit this 5 times each (50 quit/rejoin cycles), the subsidy scheme would have 50+ extra profit details, multiplying the exploiter group's share by 5x while honest candidates' rewards are diluted to ~16.7% of intended values.

### Likelihood Explanation

**Reachable Entry Points:**
- `AnnounceElection` and `AnnounceElectionFor` are public methods callable by anyone meeting basic candidate requirements
- `QuitElection` is callable by the candidate's admin
- No special privileges beyond candidate status required

**Feasible Preconditions:**
- Requires `candidateCount ≤ validationDataCenterCount` (miners × 5) during re-announcement
- In networks with 5 miners, this means ≤25 candidates needed
- Early-stage networks or periods of low candidate participation easily meet this
- Attackers can coordinate: quit when count is high, rejoin when count drops below threshold

**Execution Practicality:**
- Simple transaction sequence: announce → wait → quit → wait for low count → re-announce → repeat
- No complex timing requirements or race conditions
- Token lock cost for announcement is recovered on quit, making repeated cycles economically viable
- Attack scales: multiple actors can each perform quit/rejoin cycles

**Economic Rationality:**
- Lock cost: `ElectionContractConstants.LockTokenForElection` is returned on quit
- Net cost per cycle: only transaction fees
- Benefit: multiplied subsidy rewards distributed over time
- ROI: Highly positive for candidates who would qualify for subsidy anyway

**Detection Constraints:**
- No on-chain mechanism tracks duplicate beneficiary registrations
- Appears as normal candidate behavior (quit/rejoin is legitimate)
- Only analysis of ProfitDetails per beneficiary would reveal the exploit

### Recommendation

**Immediate Fix - Add Beneficiary Removal on Quit:**

Modify the `QuitElection` function in `ElectionContract_Candidate.cs` to call `RemoveBeneficiary` when a candidate was in the data center list:

```csharp
var dataCenterList = State.DataCentersRankingList.Value;
if (dataCenterList.DataCenters.ContainsKey(pubkey))
{
    dataCenterList.DataCenters[pubkey] = 0;
    UpdateDataCenterAfterMemberVoteAmountChanged(dataCenterList, pubkey, true);
    State.DataCentersRankingList.Value = dataCenterList;
    
    // ADD THIS: Remove from subsidy scheme
    RemoveBeneficiary(pubkey);
}
```

**Additional Protection - Prevent Duplicate Beneficiary Registration:**

Add a check in `RegisterCandidateToSubsidyProfitScheme` or `AddBeneficiary` to verify the candidate is not already a beneficiary before adding:

```csharp
private void RegisterCandidateToSubsidyProfitScheme(string candidatePubkey)
{
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
    
    // Check if already registered
    var beneficiaryAddress = GetBeneficiaryAddress(candidatePubkey, null);
    var existingDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
    {
        SchemeId = State.SubsidyHash.Value,
        Beneficiary = beneficiaryAddress
    });
    
    if (existingDetails == null || existingDetails.Details.Count == 0)
    {
        AddBeneficiary(candidatePubkey);
    }
}
```

**Invariant Checks:**
- Assert one-to-one mapping between active data center candidates and subsidy beneficiaries
- Track and limit the number of ProfitDetails per beneficiary address
- Validate TotalShares matches expected active data center count

**Regression Tests:**
1. Test quit/rejoin cycle: verify beneficiary removed on quit, only one detail on rejoin
2. Test multiple quit/rejoin cycles: verify shares don't accumulate
3. Test profit claiming after quit/rejoin: verify rewards match single share allocation

### Proof of Concept

**Initial State:**
- Network has 5 miners (validationDataCenterCount = 25)
- 20 candidates currently announced
- Attacker announces as candidate #21

**Exploitation Steps:**

1. **First Registration (T0):**
   - Attacker calls `AnnounceElection(adminAddress)`
   - Count: 21 ≤ 25 → condition met
   - `RegisterCandidateToSubsidyProfitScheme` called
   - `AddBeneficiary` adds attacker with 1 share
   - State: Attacker has 1 ProfitDetail with 1 share

2. **Quit Election (T1):**
   - Attacker calls `QuitElection`
   - `IsCurrentCandidate` set to false
   - Removed from candidate list (count now 20)
   - Data center ranking set to 0
   - **Beneficiary NOT removed from subsidy scheme**
   - State: Attacker still has 1 ProfitDetail with 1 share

3. **Wait for Low Count (T2):**
   - 5 other candidates quit naturally
   - Count drops to 15 candidates

4. **Second Registration (T3):**
   - Attacker calls `AnnounceElection` again
   - `IsCurrentCandidate` check passes (was false)
   - Count: 16 ≤ 25 → condition met again
   - `RegisterCandidateToSubsidyProfitScheme` called again
   - `AddBeneficiary` adds ANOTHER ProfitDetail with 1 share
   - State: Attacker now has 2 ProfitDetails, each with 1 share (effective 2x shares)

5. **Repeat Cycles (T4-TN):**
   - Attacker repeats quit/rejoin 3 more times
   - Final State: Attacker has 5 ProfitDetails, each with 1 share (effective 5x shares)

**Expected vs Actual Result:**
- **Expected:** Attacker has 1 share in subsidy scheme (1x rewards)
- **Actual:** Attacker has 5 ProfitDetails × 1 share each = 5x subsidy rewards
- **Impact:** If subsidy distributes 1000 ELF per term to 25 data centers:
  - Honest candidate receives: 1000/30 = 33.33 ELF (30 = 25 honest + 5 attacker shares)
  - Attacker receives: 5 × 33.33 = 166.65 ELF (5x multiplier)
  - Attacker steals ~133.32 ELF per term from honest candidates

**Success Condition:**
Query `State.ProfitDetailsMap[subsidySchemeId][attackerAddress]` shows multiple ProfitDetail entries with cumulative shares exceeding 1, while attacker only holds one active candidate position.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L112-116)
```csharp
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L134-138)
```csharp
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L154-157)
```csharp
        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L211-218)
```csharp
    private void RegisterCandidateToSubsidyProfitScheme(string candidatePubkey)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        AddBeneficiary(candidatePubkey);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-279)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });

        // Update candidate information.
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;

        // Remove candidate public key from the Voting Item options.
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
        var dataCenterList = State.DataCentersRankingList.Value;
        if (dataCenterList.DataCenters.ContainsKey(pubkey))
        {
            dataCenterList.DataCenters[pubkey] = 0;
            UpdateDataCenterAfterMemberVoteAmountChanged(dataCenterList, pubkey, true);
            State.DataCentersRankingList.Value = dataCenterList;
        }

        var managedCandidatePubkey = State.ManagedCandidatePubkeysMap[Context.Sender];
        managedCandidatePubkey.Value.Remove(ByteString.CopyFrom(pubkeyBytes));
        if (managedCandidatePubkey.Value.Any())
            State.ManagedCandidatePubkeysMap[Context.Sender] = managedCandidatePubkey;
        else
            State.ManagedCandidatePubkeysMap.Remove(Context.Sender);

        State.CandidateSponsorMap.Remove(pubkey);

        return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L781-795)
```csharp
    private void AddBeneficiary(string candidatePubkey, Address profitsReceiver = null)
    {
        var beneficiaryAddress = GetBeneficiaryAddress(candidatePubkey, profitsReceiver);
        var subsidyId = GenerateSubsidyId(candidatePubkey, beneficiaryAddress);
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = beneficiaryAddress,
                Shares = 1,
            },
            ProfitDetailId = subsidyId
        });
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-785)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
        var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();

        Context.LogDebug(() =>
            $"Profitable details: {profitableDetails.Aggregate("\n", (profit1, profit2) => profit1.ToString() + "\n" + profit2)}");

        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
        // Only can get profit from last profit period to actual last period (profit.CurrentPeriod - 1),
        // because current period not released yet.
        for (var i = 0; i < profitableDetailCount; i++)
        {
            var profitDetail = profitableDetails[i];
            if (profitDetail.LastProfitPeriod == 0)
                // This detail never performed profit before.
                profitDetail.LastProfitPeriod = profitDetail.StartPeriod;

            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
        }
```
