# Audit Report

## Title
ArrangeAbnormalMiningTime Allows Single Miner to Claim Multiple Saving Time Slots and Inflate ProducedBlocks Counter

## Summary
The `ArrangeAbnormalMiningTime` function calculates saving time slots using a stateless formula based solely on elapsed time, without verifying whether a miner has already produced blocks in the current round. This allows a single miner to exploit multiple non-overlapping saving slots as time progresses, repeatedly calling `UpdateValue` to inflate their `ProducedBlocks` counter, which directly impacts mining reward distribution and consensus reputation.

## Finding Description

The vulnerability exists in the saving slot validation logic within the `IsCurrentMiner` method. The saving slot check calculates a time window but fails to verify whether the miner has already participated in the current round. [1](#0-0) 

The `ArrangeAbnormalMiningTime` function uses a stateless time-based calculation where `missedRoundsCount = (currentTime - roundStartTime) / totalRoundTime`. As time advances without `NextRound` being called, `missedRoundsCount` increases, creating new saving slots at regular intervals of `totalRoundTime`. [2](#0-1) 

**Why existing protections fail:**

1. **No state verification in saving slot logic**: The saving slot check does not examine `ActualMiningTimes` or `OutValue` to determine if the miner has already produced blocks.

2. **TimeSlotValidationProvider only validates normal slots**: The time slot validator only checks against `ExpectedMiningTime` (normal mining slots), not the dynamically calculated saving slots. [3](#0-2) 

3. **EnsureTransactionOnlyExecutedOnceInOneBlock permits cross-block exploitation**: This protection only prevents multiple consensus transactions within a single block height, not across multiple blocks. [4](#0-3) 

4. **ProcessUpdateValue unconditionally increments ProducedBlocks**: Each `UpdateValue` call increments the counter without checking whether the miner has already contributed to the round. [5](#0-4) 

## Impact Explanation

**Direct Impact on Reward Distribution:**

Mining rewards are calculated based on `ProducedBlocks` counters. The `GetMinedBlocks` method sums all miners' `ProducedBlocks` to determine total mining rewards. [6](#0-5) 

These rewards are then donated to the Treasury contract for distribution. [7](#0-6) 

The Treasury contract calculates individual miner shares using their `ProducedBlocks` counts, where higher counts yield proportionally larger rewards through the `CalculateShares` function. [8](#0-7) 

**Consensus Reputation Impact:**

The `ProducedBlocks` counter is propagated to the Election contract via `UpdateCandidateInformation`, directly affecting miner rankings and term selection. [9](#0-8) 

**Quantified Damage:**
- With 17 miners and 4000ms intervals: `totalRoundTime = 72000ms`
- In a 10-minute stalled round: attacker gets ~8 saving slots
- Result: 8x inflated `ProducedBlocks` = 8x mining rewards
- If base reward is 100 ELF per block, attacker steals 700 ELF from honest miners

**Affected Parties:**
- Honest miners receive diluted rewards
- Token holders face disproportionate emissions to malicious actors
- Election integrity is compromised by inflated reputation metrics

## Likelihood Explanation

**Attack Requirements:**
- Attacker must be an active miner in the current round (feasible for any current consensus participant)
- Round must remain un-terminated (no `NextRound` call) for extended periods
- Attacker must produce blocks at multiple saving slot intervals

**Feasibility:**
The saving slot mechanism is explicitly designed to handle stalled rounds where miners miss their normal time slots. Such scenarios naturally occur during:
- Network coordination failures
- Consensus delays
- Temporary miner unavailability

The behavior determination logic shows that once a miner has produced blocks (`OutValue != null`), they should proceed to round termination rather than additional mining. However, the saving slot check bypasses this logic. [10](#0-9) 

**Attack Complexity:**
Low - the attacker simply waits for saving slot windows to open and calls `UpdateValue` at each interval. No cryptographic attacks or complex exploit chains are required.

**Detection:**
While multiple `ActualMiningTimes` entries for a single miner in one round are visible on-chain, the protocol currently treats this as valid behavior with no automated detection or penalty mechanisms.

## Recommendation

Add state verification to the saving slot check in `IsCurrentMiner`:

```csharp
// Check saving extra block time slot.
var nextArrangeMiningTime =
    currentRound.ArrangeAbnormalMiningTime(pubkey, Context.CurrentBlockTime, true);
var actualArrangedMiningTime = nextArrangeMiningTime.AddMilliseconds(-currentRound.TotalMilliseconds());

// ADD THIS CHECK:
if (minerInRound.OutValue != null || minerInRound.ActualMiningTimes.Any())
{
    // Miner has already produced blocks in this round
    Context.LogDebug(() => "[CURRENT MINER]ALREADY MINED");
    return false;
}

if (actualArrangedMiningTime <= Context.CurrentBlockTime &&
    Context.CurrentBlockTime <= actualArrangedMiningTime.AddMilliseconds(miningInterval))
{
    Context.LogDebug(() => "[CURRENT MINER]SAVING");
    return true;
}
```

Additionally, add validation in `UpdateValueValidationProvider` to check the base round state:

```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    var minerInRound =
        validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    
    // Check base round to ensure miner hasn't already produced blocks
    if (validationContext.BaseRound.RealTimeMinersInformation.ContainsKey(validationContext.SenderPubkey))
    {
        var baseMiner = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        if (baseMiner.OutValue != null)
            return false; // Miner already produced blocks this round
    }
    
    return minerInRound.OutValue != null && minerInRound.Signature != null &&
           minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ExploitMultipleSavingSlots_InflatesProducedBlocks()
{
    // Setup: Initialize consensus with 17 miners, 4000ms intervals
    await InitializeConsensus();
    var maliciousMiner = GetMinerAtOrder(5); // Order 5 miner
    
    // Round starts at T0, totalRoundTime = 72000ms
    var roundStartTime = GetCurrentRoundStartTime();
    
    // Advance time to first saving slot (e.g., T0 + 20000ms)
    SetCurrentBlockTime(roundStartTime.AddMilliseconds(20000));
    
    // Verify IsCurrentMiner returns true for first saving slot
    var isCurrentMiner1 = await ConsensusContract.IsCurrentMiner.CallAsync(maliciousMiner);
    isCurrentMiner1.Value.ShouldBeTrue();
    
    // Exploit: Call UpdateValue at first saving slot
    await MineBlock(maliciousMiner);
    var round1 = await GetCurrentRoundInformation();
    round1.RealTimeMinersInformation[maliciousMiner.ToHex()].ProducedBlocks.ShouldBe(1);
    
    // Advance time by totalRoundTime to second saving slot (T0 + 92000ms)
    SetCurrentBlockTime(roundStartTime.AddMilliseconds(92000));
    
    // Verify IsCurrentMiner STILL returns true (vulnerability!)
    var isCurrentMiner2 = await ConsensusContract.IsCurrentMiner.CallAsync(maliciousMiner);
    isCurrentMiner2.Value.ShouldBeTrue(); // Should be false, but returns true
    
    // Exploit: Call UpdateValue again at second saving slot
    await MineBlock(maliciousMiner);
    var round2 = await GetCurrentRoundInformation();
    round2.RealTimeMinersInformation[maliciousMiner.ToHex()].ProducedBlocks.ShouldBe(2); // Inflated!
    
    // Repeat for third saving slot (T0 + 164000ms)
    SetCurrentBlockTime(roundStartTime.AddMilliseconds(164000));
    await MineBlock(maliciousMiner);
    var round3 = await GetCurrentRoundInformation();
    round3.RealTimeMinersInformation[maliciousMiner.ToHex()].ProducedBlocks.ShouldBe(3); // Further inflated!
    
    // Verify: Same miner has 3 ProducedBlocks in one round
    // This gives them 3x the mining rewards of honest miners who produced 1 block
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L180-189)
```csharp
        // Check saving extra block time slot.
        var nextArrangeMiningTime =
            currentRound.ArrangeAbnormalMiningTime(pubkey, Context.CurrentBlockTime, true);
        var actualArrangedMiningTime = nextArrangeMiningTime.AddMilliseconds(-currentRound.TotalMilliseconds());
        if (actualArrangedMiningTime <= Context.CurrentBlockTime &&
            Context.CurrentBlockTime <= actualArrangedMiningTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]SAVING");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L19-37)
```csharp
    public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
        bool mustExceededCurrentRound = false)
    {
        var miningInterval = GetMiningInterval();

        var minerInRound = RealTimeMinersInformation[pubkey];

        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }

        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-253)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L124-127)
```csharp
    public long GetMinedBlocks()
    {
        return RealTimeMinersInformation.Values.Sum(minerInRound => minerInRound.ProducedBlocks);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L37-50)
```csharp
    private void UpdateCurrentMinerInformationToElectionContract(Round previousRound)
    {
        State.ElectionContract.UpdateMultipleCandidateInformation.Send(new UpdateMultipleCandidateInformationInput
        {
            Value =
            {
                previousRound.RealTimeMinersInformation.Select(i => new UpdateCandidateInformationInput
                {
                    Pubkey = i.Key,
                    RecentlyProducedBlocks = i.Value.ProducedBlocks,
                    RecentlyMissedTimeSlots = i.Value.MissedTimeSlots
                })
            }
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L118-121)
```csharp
        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L789-846)
```csharp
        var averageProducedBlocksCount = CalculateAverage(previousTermInformation.Last().RealTimeMinersInformation
            .Values
            .Select(i => i.ProducedBlocks).ToList());
        // Manage weights of `MinerBasicReward`
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
    }

    /// <summary>
    ///     Just to make sure not using double type.
    /// </summary>
    /// <param name="list"></param>
    /// <returns></returns>
    private long CalculateAverage(List<long> list)
    {
        var sum = list.Sum();
        return sum.Div(list.Count);
    }

    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```
