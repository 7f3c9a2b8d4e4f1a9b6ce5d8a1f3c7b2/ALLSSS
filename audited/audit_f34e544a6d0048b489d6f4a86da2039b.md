# Audit Report

## Title
Initial Miner Pubkey Collision Allows Voting System DOS via Incorrect RemoveOption/AddOption Invocation

## Summary
The `PerformReplacement()` function fails to validate whether the NEW pubkey is already an initial miner before calling `RemoveOption`/`AddOption` on the Vote contract. This allows an attacker to replace their candidate with an existing initial miner's pubkey, creating an inconsistent state where the initial miner exists in both `InitialMiners` and `Candidates` lists with a voting option, permanently breaking the voting system's integrity.

## Finding Description

The vulnerability exists in the replacement validation logic. The `ReplaceCandidatePubkey()` method only verifies that the new pubkey is not already in the `Candidates` list, but critically fails to check against `InitialMiners`: [1](#0-0) 

The `PerformReplacement()` function conditionally calls `RemoveOption`/`AddOption` based solely on whether the OLD pubkey is an initial miner: [2](#0-1) 

This creates an exploitable gap. When a regular candidate (not in `InitialMiners`) is replaced with a pubkey that IS in `InitialMiners`, the check at line 306 evaluates to true (since the old candidate is not an initial miner), causing `RemoveOption` and `AddOption` to be invoked for the initial miner's pubkey.

The code then updates the `Candidates` list to include the new pubkey: [3](#0-2) 

And checks if the old pubkey was in `InitialMiners` to update that list: [4](#0-3) 

Since the old pubkey is NOT in `InitialMiners`, this block is skipped, leaving the initial miner in `InitialMiners` while also being added to `Candidates`. This violates the core design invariant that initial miners should never have voting options, as explicitly enforced here: [5](#0-4) 

When the corrupted initial miner is subsequently replaced, the check correctly identifies it as an initial miner and skips `RemoveOption`/`AddOption`, leaving the voting option from the first replacement orphaned.

## Impact Explanation

**Critical Consensus Integrity Violation:**

1. **Voting System Corruption**: The replacement candidate cannot receive votes despite being in the `Candidates` list because no voting option exists. Users attempting to vote will fail since the Vote contract validates option existence: [6](#0-5) 

2. **Phantom Voting Options**: The replaced initial miner retains its voting option, allowing votes to accumulate for a non-existent candidate position, corrupting election results.

3. **Election Result Manipulation**: The `GetVictories()` function relies on `CandidateVotes` to select miners: [7](#0-6) 

Phantom votes could influence miner selection while legitimate candidates cannot receive votes.

4. **Irreversible State**: The Vote contract enforces that options must exist before removal: [8](#0-7) 

This means the broken state cannot be easily recovered without contract upgrades.

5. **Multi-Target Attack**: The attacker can repeat this attack for multiple initial miners, systematically breaking the voting system.

This breaks the core consensus mechanism (miner election) integrity without requiring privileged access, affecting all network participants.

## Likelihood Explanation

**High Likelihood - Easily Exploitable:**

The attack entry point is the public `ReplaceCandidatePubkey()` method: [9](#0-8) 

**Attacker Requirements:**
1. Announce election to create a candidate (requires standard token lock)
2. Control candidate admin (automatic during announcement)
3. Know initial miner pubkeys (publicly visible in state)

The initial miners list is a public state variable that can be queried: [10](#0-9) 

**Attack Execution:**
- Cost: Only the standard candidate announcement lock amount
- Complexity: Two simple transactions (announce + replace)
- Detection: Difficult to detect before damage occurs
- Economic rationality: Minimal cost for maximum disruption

All preconditions are easily satisfied in normal network operation with no special timing or privileged access required.

## Recommendation

Add a validation check in `ReplaceCandidatePubkey()` to prevent replacing with an initial miner's pubkey:

```csharp
// After line 191 in ElectionContract_Maintainence.cs
Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");

// Add this check:
var newPubkeyByteString = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));
Assert(!State.InitialMiners.Value.Value.Contains(newPubkeyByteString), 
    "Cannot replace with an initial miner pubkey.");
```

This ensures the invariant that initial miners never receive voting options is properly enforced throughout the replacement flow.

## Proof of Concept

```csharp
[Fact]
public async Task ReplaceCandidatePubkey_WithInitialMiner_ShouldCreateInconsistentState()
{
    // Step 1: Announce election for a regular candidate
    var attackerKeyPair = ValidationDataCenterKeyPairs.First();
    var attackerAdmin = ValidationDataCenterKeyPairs.Last();
    var attackerAdminAddress = Address.FromPublicKey(attackerAdmin.PublicKey);
    await AnnounceElectionAsync(attackerKeyPair, attackerAdminAddress);
    
    // Step 2: Get an initial miner pubkey (these are set during initialization)
    var initialMiners = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
    var targetInitialMinerPubkey = InitialCoreDataCenterKeyPairs.First().PublicKey.ToHex();
    
    // Step 3: Replace attacker's candidate with initial miner's pubkey
    var attackerAdminStub = GetElectionContractTester(attackerAdmin);
    await attackerAdminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = attackerKeyPair.PublicKey.ToHex(),
        NewPubkey = targetInitialMinerPubkey
    });
    
    // Verify: Initial miner now has a voting option (VIOLATION!)
    var votingItem = await VoteContractStub.GetVotingItem.CallAsync(MinerElectionVotingItemId);
    votingItem.Options.ShouldContain(targetInitialMinerPubkey);
    
    // Verify: Initial miner exists in Candidates list (VIOLATION!)
    var candidates = await ElectionContractStub.GetCandidates.CallAsync(new Empty());
    var targetPubkeyBytes = ByteString.CopyFrom(
        ByteArrayHelper.HexStringToByteArray(targetInitialMinerPubkey));
    candidates.Value.ShouldContain(targetPubkeyBytes);
    
    // Step 4: Replace the initial miner with another pubkey
    var newKeyPair = ValidationDataCenterKeyPairs.Skip(2).First();
    await attackerAdminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = targetInitialMinerPubkey,
        NewPubkey = newKeyPair.PublicKey.ToHex()
    });
    
    // Verify: Orphaned voting option for initial miner still exists (DOS!)
    votingItem = await VoteContractStub.GetVotingItem.CallAsync(MinerElectionVotingItemId);
    votingItem.Options.ShouldContain(targetInitialMinerPubkey);
    
    // Verify: New replacement candidate has NO voting option (DOS!)
    votingItem.Options.ShouldNotContain(newKeyPair.PublicKey.ToHex());
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L34-38)
```csharp
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-173)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L191-191)
```csharp
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L192-196)
```csharp
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L306-318)
```csharp
        if (!State.InitialMiners.Value.Value.Contains(oldPubkeyByteString))
        {
            State.VoteContract.RemoveOption.Send(new RemoveOptionInput
            {
                VotingItemId = State.MinerElectionVotingItemId.Value,
                Option = oldPubkey
            });
            State.VoteContract.AddOption.Send(new AddOptionInput
            {
                VotingItemId = State.MinerElectionVotingItemId.Value,
                Option = newPubkey
            });
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L149-150)
```csharp
        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L308-308)
```csharp
        Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L381-381)
```csharp
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-83)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
```
