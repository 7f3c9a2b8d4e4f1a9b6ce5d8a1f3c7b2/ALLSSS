### Title
Insufficient Precision in Natural Logarithm Series Causes Transaction Failures and Pricing Errors for Large Token Purchases

### Summary
The `Ln()` function in `BancorHelper.cs` uses a Taylor series with only 20 iterations, which converges slowly when the input approaches the boundary values. This creates two distinct issues: (1) transactions fail with an exception when users attempt to buy ≥50% of the connector balance in a single transaction, and (2) purchases in the 40-50% range suffer from ~1-2% pricing precision errors due to insufficient series convergence.

### Finding Description

The `Ln()` function implements natural logarithm using the Taylor series expansion: `ln(a) = -x - x²/2 - x³/3 - ...` where `x = 1-a`. [1](#0-0) 

The function enforces a constraint that `|x| < 1`, meaning the input must satisfy `0 < a < 2`. [2](#0-1) 

**Issue 1: Hard Failure at 50% Threshold**

In `GetAmountToPayFromReturn()` (used by the `Buy` function), the code calculates `x = bt / (bt - a)` where `bt` is the to-connector balance and `a` is the amount to receive. [3](#0-2) 

When `a ≥ bt/2`, then `x ≥ 2`, which violates the `Ln()` constraint. This causes the transaction to fail with "must be 0 < a < 2" exception.

The `Buy()` function in `TokenConverterContract` directly calls `GetAmountToPayFromReturn()` without checking if the requested amount exceeds half the connector balance. [4](#0-3) 

**Issue 2: Precision Loss for Large Purchases**

With `_LOOPS = 20`, the Taylor series error after n terms is approximately `|x^(n+1)/(n+1)|`. [5](#0-4) 

For large purchases approaching the 50% threshold:
- When buying 49% of balance: `x ≈ 1.96`, giving series argument `|1-x| ≈ 0.96`
- Error ≈ `(0.96)^21/21 ≈ 0.022` (approximately 2.2% relative error)

This error propagates through the Bancor pricing formula used in both `GetReturnFromPaid()` and `GetAmountToPayFromReturn()`, resulting in users paying or receiving 1-2% different amounts than mathematically correct. [6](#0-5) 

The connector balance calculation includes virtual balance, which can amplify this issue when virtual balances are enabled. [7](#0-6) 

### Impact Explanation

**Transaction Failure Impact (≥50% purchases):**
- Users attempting to buy ≥50% of connector balance in a single transaction will experience transaction failure
- This creates a denial-of-service condition for legitimate large purchases
- The connector balance includes virtual balance, so the 50% threshold may be triggered even when sufficient real tokens exist

**Pricing Precision Impact (40-50% purchases):**
- Users buying 40-49% of connector balance will receive or pay ~1-2% incorrect amounts
- For a 1,000,000 token purchase at 45% of balance, the error could be ±10,000-20,000 tokens
- This affects both buyers (overpaying) and sellers (receiving less), violating the Bancor pricing invariant

**Affected Parties:**
- Large institutional buyers/sellers attempting significant single transactions
- Users relying on virtual balance configurations that inflate effective balance
- Protocol treasury when converting large amounts

**Severity Justification (LOW):**
- Error is bounded and predictable (~1-2% maximum)
- No direct fund theft mechanism
- Workaround exists: split large transactions into multiple smaller ones
- Natural economic incentives likely prevent extreme cases (buying 40%+ in single transaction is rare)
- Failure mode is explicit (exception) rather than silent corruption

### Likelihood Explanation

**Attacker Capabilities Required:**
- Sufficient funds to purchase 40-50% of connector balance in a single transaction
- No special privileges or access required
- Direct call to public `Buy()` function

**Attack Complexity:**
- Low technical complexity: straightforward transaction with large `Amount` parameter
- Economic barrier: requires substantial capital to trigger (must have funds for 40%+ purchase)

**Feasibility Conditions:**
- Connector must have sufficient liquidity to make large purchase economically viable
- User must not be aware of 50% limit or precision issues
- Market conditions must make such large single purchase desirable

**Probability Assessment:**
- **Issue 1 (≥50% failure):** Low probability - most users will split large orders naturally for slippage reasons
- **Issue 2 (40-50% precision loss):** Very low probability - requires specific circumstances where user wants exactly 40-49% in single transaction
- Natural market dynamics (slippage, price impact) discourage single large transactions
- Protocol likely operates with transaction sizes well below 40% threshold in normal conditions

### Recommendation

**Short-term Mitigation:**
1. Add explicit validation in `Buy()` and `Sell()` functions to reject purchases exceeding 40% of connector balance with a clear error message:
```
Assert(input.Amount < GetSelfBalance(toConnector) * 4 / 10, 
       "Cannot buy more than 40% of connector balance in single transaction");
```

2. Document the limitation in the API documentation and user interface.

**Long-term Fix:**
1. Increase `_LOOPS` from 20 to 50 to achieve better precision (error < 0.1% even at x=0.98): [5](#0-4) 

2. Implement alternative logarithm calculation using range reduction techniques to improve convergence for values near boundaries.

3. Add pre-computation or lookup table for common weight ratios to avoid repeated expensive calculations.

**Test Cases to Add:**
1. Test buying exactly 50% of connector balance - should fail gracefully with clear message
2. Test buying 49% of connector balance - verify pricing precision within acceptable tolerance
3. Test series of smaller purchases totaling >50% - should succeed
4. Fuzz testing with various connector balance ratios and purchase amounts
5. Test with virtual balance enabled to ensure constraint checking uses effective balance

### Proof of Concept

**Initial State:**
- TokenConverter initialized with connector pair
- Base connector (deposit account) with virtual balance: 1,000,000 tokens
- Resource connector with 1,000,000 tokens in contract
- Both connectors have weight 0.5
- User has sufficient base tokens (e.g., 2,000,000)

**Exploitation Steps:**

**Scenario 1: Transaction Failure (≥50%)**
1. User approves TokenConverter to spend base tokens
2. User calls `Buy()` with:
   - `Symbol`: resource token symbol
   - `Amount`: 500,000 (exactly 50% of connector balance)
   - `PayLimit`: 2,000,000
3. `GetAmountToPayFromReturn()` calculates: `x = 1,000,000 / (1,000,000 - 500,000) = 2`
4. `Ln(2)` called but fails check: `|1-2| = 1 >= 1`
5. Transaction reverts with "must be 0 < a < 2"

**Scenario 2: Pricing Precision Loss (49%)**
1. User calls `Buy()` with `Amount`: 490,000 (49% of balance)
2. `GetAmountToPayFromReturn()` calculates: `x = 1,000,000 / 510,000 ≈ 1.961`
3. `Ln(1.961)` computed with ~2% error due to slow convergence
4. Final price calculation compounds this error
5. User pays approximately 1-2% more or less than correct Bancor price

**Expected vs Actual:**
- **Expected:** Smooth price curve for all purchase sizes < 100% of balance
- **Actual:** Hard failure at ≥50%, precision degradation at 40-50%

**Success Condition:**
- Scenario 1 reproduces transaction failure at 50% threshold
- Scenario 2 shows measurable price deviation from reference implementation with higher precision

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L98-98)
```csharp
    private const int _LOOPS = 20; // Max = 20
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L124-143)
```csharp
    private static decimal Ln(decimal a)
    {
        /*
        ln(a) = log(1-x) = - x - x^2/2 - x^3/3 - ...   (where |x| < 1)
            x: a = 1-x    =>   x = 1-a = 1 - 1.004 = -.004
        */
        var x = 1 - a;
        if (Math.Abs(x) >= 1)
            throw new InvalidValueException("must be 0 < a < 2");

        decimal result = 0;
        uint iteration = _LOOPS;
        while (iteration > 0)
        {
            result -= Pow(x, iteration) / iteration;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```
