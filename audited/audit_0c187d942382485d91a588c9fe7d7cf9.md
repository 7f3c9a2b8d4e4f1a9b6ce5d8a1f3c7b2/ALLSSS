### Title
Missing Input Validation in SetContractProposalExpirationTimePeriod Enables Permanent DoS of Contract Governance

### Summary
The `SetContractProposalExpirationTimePeriod` function lacks input validation to prevent setting extremely low expiration periods, unlike its sister function `SetCodeCheckProposalExpirationTimePeriod`. Setting the expiration period to 1 second (or any small positive value) causes all subsequent contract deployment and update proposals to expire instantly, creating an unrecoverable denial of service. Note that setting it to 0 does NOT cause DoS as the system falls back to the default 259200-second period.

### Finding Description

**Exact Location:** [1](#0-0) 

**Root Cause:**
The function directly assigns `input.ExpirationTimePeriod` to state without any bounds checking or validation. When the value is retrieved, the helper function only checks if it's exactly 0 to use the default: [2](#0-1) 

**Why Protections Fail:**
The governance contracts only validate that `ExpiredTime > CurrentBlockTime` when creating proposals, with no minimum duration requirement: [3](#0-2) 

When proposals are approved or released, they must pass the same expiration check: [4](#0-3) 

**Execution Path:**
1. Contract deployment/update proposals call `GetCurrentContractProposalExpirationTimePeriod()` to calculate `ExpiredTime`: [5](#0-4) [6](#0-5) 

2. If expiration period is 1 second, proposals expire before the next block (~4 seconds in AElf consensus): [7](#0-6) 

3. All approval/release attempts fail with "Invalid proposal."

**Inconsistency:**
The related function `SetCodeCheckProposalExpirationTimePeriod` includes proper validation: [8](#0-7) 

### Impact Explanation

**Harm:**
- **Complete DoS** of all contract deployments via `ProposeNewContract`
- **Complete DoS** of all contract updates via `ProposeUpdateContract`
- **Permanent deadlock**: Any governance proposal to fix the configuration would itself expire instantly, making recovery impossible without chain halt/fork

**Who Is Affected:**
- All contract developers unable to deploy or update contracts
- The entire AElf governance system for contract management
- Chain operations requiring contract updates (security patches, feature upgrades)

**Severity Justification:**
**CRITICAL** - This creates an unrecoverable DoS of critical governance infrastructure. Unlike temporary DoS scenarios, the deadlock nature (cannot fix via governance because fix proposals also expire) makes this a permanent system failure requiring extraordinary measures to resolve.

### Likelihood Explanation

**Preconditions:**
- Requires authorization from `ContractDeploymentController` (typically Parliament governance) [9](#0-8) 

**Attack Complexity:**
- Single governance proposal with one malicious/erroneous parameter
- Could occur through:
  1. Accidental typo (intended 86400 for 1 day, typed 1)
  2. Unit confusion (meant 1 day in seconds, used 1)
  3. Malicious proposal if governance is partially compromised
  4. Social engineering attack targeting governance participants

**Feasibility:**
Test evidence shows the function accepts any value without validation: [10](#0-9) 

**Detection/Operational Constraints:**
- No on-chain detection mechanism for dangerous configuration values
- Impact is immediate and irreversible upon proposal release
- No recovery path without chain-level intervention

**Probability Reasoning:**
While requiring governance action reduces likelihood compared to untrusted user exploits, the lack of basic input validation for a critical parameter represents a significant configuration vulnerability. The inconsistency with the validated sister function suggests this is an oversight rather than intentional design.

### Recommendation

**Code-Level Mitigation:**
Add input validation identical to `SetCodeCheckProposalExpirationTimePeriod`:

```csharp
public override Empty SetContractProposalExpirationTimePeriod(SetContractProposalExpirationTimePeriodInput input)
{
    AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
    Assert(input.ExpirationTimePeriod > 0, "Invalid expiration time period.");
    State.ContractProposalExpirationTimePeriod.Value = input.ExpirationTimePeriod;
    return new Empty();
}
```

**Additional Safeguards:**
1. Add minimum threshold validation (e.g., `input.ExpirationTimePeriod >= 3600` for at least 1 hour)
2. Add maximum threshold to prevent indefinite proposals
3. Consider implementing a time-delay mechanism for critical governance parameter changes

**Test Cases:**
1. Test rejection of `ExpirationTimePeriod = 0` (should fail with new validation)
2. Test rejection of `ExpirationTimePeriod = 1` (should fail)
3. Test acceptance of reasonable values (e.g., 3600, 86400, 259200)
4. Test that default fallback still works if needed

### Proof of Concept

**Initial State:**
- Genesis contract deployed and initialized
- Parliament governance configured as ContractDeploymentController
- Default `ContractProposalExpirationTimePeriod` is 259200 seconds (72 hours) [11](#0-10) 

**Attack Sequence:**

**Step 1:** Create governance proposal to set expiration to 1 second
```
CreateProposal(
  ToAddress: BasicContractZero,
  Method: "SetContractProposalExpirationTimePeriod",
  Params: { ExpirationTimePeriod: 1 }
)
```

**Step 2:** Governance approves and releases the malicious/erroneous proposal

**Step 3:** Attempt to deploy a new contract
```
ProposeNewContract(
  Code: <contract_bytecode>,
  Category: 0
)
// Proposal created with ExpiredTime = CurrentBlockTime + 1 second
```

**Step 4:** Wait for next block (~4 seconds later per AElf consensus)

**Step 5:** Attempt to approve the deployment proposal
```
Approve(proposalId)
// FAILS with "Invalid proposal." - proposal already expired
```

**Expected vs Actual:**
- **Expected:** Proposal should remain valid for reasonable duration (default 72 hours) allowing governance to review and approve
- **Actual:** Proposal expires in 1 second, before any approval is possible

**Success Condition:**
The attack succeeds when all subsequent contract deployment/update proposals immediately expire and cannot be approved, with no recovery path through governance (as recovery proposals also expire instantly).

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L130-130)
```csharp
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L159-159)
```csharp
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L218-218)
```csharp
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L394-399)
```csharp
    public override Empty SetContractProposalExpirationTimePeriod(SetContractProposalExpirationTimePeriodInput input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        State.ContractProposalExpirationTimePeriod.Value = input.ExpirationTimePeriod;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L401-407)
```csharp
    public override Empty SetCodeCheckProposalExpirationTimePeriod(Int32Value input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        Assert(input.Value > 0, "Invalid expiration time period.");
        State.CodeCheckProposalExpirationTimePeriod.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L282-287)
```csharp
    private int GetCurrentContractProposalExpirationTimePeriod()
    {
        return State.ContractProposalExpirationTimePeriod.Value == 0
            ? ContractProposalExpirationTimePeriod
            : State.ContractProposalExpirationTimePeriod.Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L177-180)
```csharp
    private bool CheckProposalNotExpired(ProposalInfo proposal)
    {
        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L182-188)
```csharp
    private ProposalInfo GetValidProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        Assert(proposal != null, "Proposal not found.");
        Assert(Validate(proposal), "Invalid proposal.");
        return proposal;
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L1467-1482)
```csharp
                new SetContractProposalExpirationTimePeriodInput
                {
                    ExpirationTimePeriod = 86400
                });
            await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);
            var txResult = await ReleaseProposalAsync(Tester, ParliamentAddress, proposalId);
            txResult.Status.ShouldBe(TransactionResultStatus.Failed);
            txResult.Error.ShouldContain("Unauthorized behavior.");
        }
        {
            var proposalId = await CreateProposalAsync(Tester, ParliamentAddress,
                contractDeploymentController.OwnerAddress, methodName,
                new SetContractProposalExpirationTimePeriodInput
                {
                    ExpirationTimePeriod = 86400
                });
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L5-5)
```csharp
    public const int ContractProposalExpirationTimePeriod = 259200; // 60 * 60 * 72
```
