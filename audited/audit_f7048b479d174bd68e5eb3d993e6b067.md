### Title
Retroactive Miner Count Calculation Causes Sudden Jumps When MinerIncreaseInterval is Modified

### Summary
The `SetMinerIncreaseInterval()` function allows decreasing the miner increase interval, but the `GetAutoIncreasedMinersCount()` calculation retroactively applies the new interval to the entire blockchain history. This causes sudden, unintended jumps in the allowed miner count at the next term transition, disrupting consensus dynamics and violating the intended gradual growth model.

### Finding Description

**Root Cause:**

The `GetAutoIncreasedMinersCount()` function calculates the auto-increased miner count using a formula that divides the entire elapsed time by the current `MinerIncreaseInterval`: [1](#0-0) 

When `SetMinerIncreaseInterval()` decreases the interval value, the calculation becomes retroactive because it uses the ENTIRE time span `(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value)` divided by the NEW (smaller) interval: [2](#0-1) 

The function only validates that the new interval is less than or equal to the current value (line 61), allowing unlimited decreases but no historical tracking of when intervals changed or accumulated miner increases.

**Execution Path:**

1. Governance calls `SetMinerIncreaseInterval()` with a smaller interval value
2. At the next term transition, `ProcessNextTerm()` calls `UpdateMinersCountToElectionContract()`: [3](#0-2) 

3. This invokes `GetMinersCount()` which uses the same retroactive formula: [4](#0-3) 

4. The suddenly increased count is sent to the Election contract: [5](#0-4) 

5. Election contract updates `State.MinersCount.Value` and uses it in `GetVictories()` to select miners for the next term: [6](#0-5) 

6. The new miner count determines how many candidates become miners: [7](#0-6) 

### Impact Explanation

**Consensus Disruption:**

A concrete example: If the blockchain has been running for 3 years (94,608,000 seconds) with the default interval of 31,536,000 seconds (1 year), the current miner count would be: `17 + (94,608,000 / 31,536,000) * 2 = 23 miners`.

If governance decreases the interval to 3,153,600 seconds (about 36.5 days), the calculation suddenly becomes: `17 + (94,608,000 / 3,153,600) * 2 = 77 miners` - a jump of 54 miners in a single term transition.

**Affected Parties:**
- **Consensus Network**: Sudden 3x increase in miner count disrupts consensus algorithm performance and block production coordination
- **Existing Miners**: Reward dilution as mining rewards are split among 77 instead of 23 miners
- **Candidates**: 54 candidates who should not yet qualify suddenly become miners, bypassing the intended gradual admission process
- **Data Center Operators**: `ValidDataCenterCount` jumps from 115 to 385, allowing 270 additional data centers into the subsidy scheme: [8](#0-7) 

**Economic Impact:**
- Mining reward per miner drops by approximately 70% (from 1/23 to 1/77 of the reward pool)
- Subsidy distribution is diluted across 270 additional data centers
- Violates stakeholder expectations based on the gradual growth model

### Likelihood Explanation

**Attacker Capabilities:**
Requires governance control (MaximumMinersCountController, typically Parliament contract), which is a realistic scenario as governance changes are a normal part of protocol evolution.

**Attack Complexity:**
Low - single transaction calling `SetMinerIncreaseInterval()` with a decreased value. No complex state manipulation or timing requirements beyond waiting for the next term transition.

**Feasibility:**
The vulnerability is immediately exploitable once governance approval is obtained. The calculation executes automatically during the next term transition via `ProcessNextTerm()`, which occurs regularly as part of normal consensus operation.

**Detection:**
The effect is visible but may not be detected until after the term transition completes, as the miner count change happens atomically during consensus processing. By then, the new miner set is already selected and active.

### Recommendation

**Code-Level Mitigation:**

1. **Track Historical Miner Count Growth**: Store the accumulated miner count increases separately rather than recalculating retroactively:
```
State.AccumulatedMinerIncreases.Value += (elapsed_since_last_update / old_interval) * 2;
State.LastIntervalUpdateTime.Value = Context.CurrentBlockTime;
```

2. **Add Maximum Decrease Limit**: Restrict how much the interval can be decreased in a single update:
```csharp
Assert(input.Value >= State.MinerIncreaseInterval.Value.Mul(50).Div(100), 
       "Cannot decrease interval by more than 50% at once");
```

3. **Add Gradual Transition Period**: When interval changes, phase in the new rate over multiple terms rather than applying retroactively.

**Invariant Checks:**
- Add assertion that miner count changes between terms do not exceed a reasonable threshold (e.g., +10%)
- Emit warning event when miner count increase is abnormally large

**Test Cases:**
- Test decreasing interval by various amounts and verify miner count changes are gradual
- Test that historical growth is preserved when interval changes
- Test maximum allowed decrease limit
- Test that miner count never jumps more than expected based on term duration

### Proof of Concept

**Initial State:**
- Blockchain start timestamp: `T0`
- Current time: `T0 + 94,608,000 seconds` (3 years later)
- `State.MinerIncreaseInterval.Value = 31,536,000` (1 year)
- Current auto-increased count: `17 + (94,608,000 / 31,536,000) * 2 = 23 miners`
- Current term: 37

**Attack Steps:**
1. Parliament governance proposes and approves `SetMinerIncreaseInterval(3,153,600)` (decrease to ~36.5 days)
2. Transaction executes successfully, updating `State.MinerIncreaseInterval.Value = 3,153,600`
3. Wait for next term transition (term 38 begins)
4. `ProcessNextTerm()` calls `UpdateMinersCountToElectionContract()`
5. `GetMinersCount()` calculates: `17 + (94,608,000 / 3,153,600) * 2 = 77 miners`

**Expected vs Actual Result:**
- **Expected**: Miner count should remain at 23, or increase gradually by 2 miners per new interval period going forward
- **Actual**: Miner count suddenly jumps to 77 (54 additional miners immediately)
- `GetVictories()` now selects top 77 candidates instead of 23
- 54 candidates who were not previously miners suddenly join the active miner set

**Success Condition:**
Query `GetMaximumMinersCount()` after term transition completes - returns 77 instead of the expected ~23-25, confirming the sudden retroactive jump.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L176-176)
```csharp
        UpdateMinersCountToElectionContract(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L406-409)
```csharp
    private int GetValidationDataCenterCount()
    {
        return GetMinersCount(new Empty()).Value.Mul(5);
    }
```
