### Title
Parliament Contract State Bloat DOS via Immediate-Expiration Proposals

### Summary
The Parliament contract's `CreateProposal()` function lacks minimum expiration time validation, allowing authorized proposers to spam proposals that expire within seconds. This causes state bloat in the `State.Proposals` mapping, requiring manual cleanup via `ClearProposal()` calls that must be executed one-by-one, creating an asymmetric attack-defense cost ratio.

### Finding Description

The vulnerability exists in the proposal validation flow: [1](#0-0) 

The `CreateProposal()` function calls `CreateNewProposal()` which validates proposals: [2](#0-1) 

The validation function checks proposal expiration: [3](#0-2) 

The critical flaw is in `CheckProposalNotExpired()`: [4](#0-3) 

This only verifies `Context.CurrentBlockTime < proposal.ExpiredTime` without enforcing a minimum duration. An attacker can set `ExpiredTime = CurrentBlockTime + 1 second`, passing validation but expiring almost immediately.

**Why Protection Fails:**

1. **No Minimum Duration**: The validation at lines 177-180 allows any future timestamp, including those just 1 second away
2. **Manual Cleanup Only**: Expired proposals must be removed individually via `ClearProposal()`: [5](#0-4) 

3. **No Rate Limiting**: No limits exist on proposal creation frequency or concurrent proposals per proposer
4. **Storage Impact**: Each proposal stores 200-11,000 bytes in `State.Proposals` mapping: [6](#0-5) 

With string limits enforced at: [7](#0-6) [8](#0-7) 

### Impact Explanation

**Harm Occurs:**
- Uncontrolled growth of `State.Proposals` mapping through accumulation of expired proposals
- Each malicious proposal consumes minimum ~200 bytes storage (Hash + addresses + minimal strings)
- Maximum ~11,000 bytes per proposal if attacker uses full string limits (255 + 10,200 + 255 bytes)
- Degraded contract read/write performance due to state bloat
- Increased node storage requirements and synchronization costs
- Asymmetric defense cost: attacker batches many `CreateProposal()` calls, defender must call `ClearProposal()` once per proposal

**Who is Affected:**
- Organizations with `ProposerAuthorityRequired=false` (anyone can propose)
- Organizations where attacker is a parliament member and `ParliamentMemberProposingAllowed=true`
- All network participants experience degraded performance from state bloat

**Severity Justification (Medium):**
- Attack requires specific preconditions (organization configuration or parliament member status)
- Transaction fees via ACS1 can increase attack cost: [9](#0-8) 

- Manual cleanup mechanism exists but is inefficient
- Does not directly steal funds or break consensus, but degrades operational capabilities

### Likelihood Explanation

**Attacker Capabilities:**
- Must be authorized proposer: either in whitelist, parliament member, or targeting organization with `ProposerAuthorityRequired=false`: [10](#0-9) 

- Can create unlimited proposals if transaction fees are low/unconfigured
- Can batch multiple `CreateProposal()` transactions efficiently

**Attack Complexity:**
- Low: Simply call `CreateProposal()` repeatedly with `ExpiredTime = Context.CurrentBlockTime + 1`
- Validation will pass since `CurrentBlockTime < ExpiredTime` holds true
- Proposals expire within seconds but remain in state until manually cleared

**Feasibility Conditions:**
- Organization exists with `ProposerAuthorityRequired=false`, OR
- Attacker is parliament member and `ParliamentMemberProposingAllowed=true`
- Transaction fees for `CreateProposal()` are not prohibitively high
- Cleanup is slower than creation rate

**Detection/Operational Constraints:**
- Attack is detectable (high volume of expired proposals)
- Defenders can call `ClearProposal()` but must do so one-by-one
- If fees are properly configured, attack becomes expensive

**Probability:** Medium - depends on organization configuration and fee settings

### Recommendation

**Code-Level Mitigation:**

1. **Enforce Minimum Expiration Duration** in `CheckProposalNotExpired()`:

```csharp
private bool CheckProposalNotExpired(ProposalInfo proposal)
{
    const long MinimumProposalDurationSeconds = 3600; // 1 hour minimum
    return proposal.ExpiredTime != null && 
           Context.CurrentBlockTime < proposal.ExpiredTime &&
           proposal.ExpiredTime.Seconds >= Context.CurrentBlockTime.Seconds + MinimumProposalDurationSeconds;
}
```

2. **Add Rate Limiting** - Track proposals per proposer:

```csharp
// In ParliamentState.cs
public MappedState<Address, int> ActiveProposalCount { get; set; }

// In CreateNewProposal
Assert(State.ActiveProposalCount[Context.Sender] < MaxActiveProposalsPerProposer, 
       "Too many active proposals.");
State.ActiveProposalCount[Context.Sender] = State.ActiveProposalCount[Context.Sender] + 1;
```

3. **Auto-Cleanup in Release** - Remove expired proposals when accessed:

```csharp
// In GetValidProposal and other read paths
if (!CheckProposalNotExpired(proposal)) {
    State.Proposals.Remove(proposalId);
    return null;
}
```

4. **Configure Method Fees** - Ensure `CreateProposal()` has meaningful transaction fee to prevent spam

**Test Cases:**
- Test proposal creation with `ExpiredTime = CurrentBlockTime + 1` should fail
- Test proposal creation with `ExpiredTime = CurrentBlockTime + 3601` should succeed
- Test rate limiting prevents creating more than N active proposals per proposer
- Test auto-cleanup removes expired proposals on read operations

### Proof of Concept

**Required Initial State:**
- Parliament contract initialized
- Organization exists with `ProposerAuthorityRequired=false` OR attacker is parliament member
- Transaction fees for `CreateProposal()` are zero or minimal

**Transaction Steps:**

1. Attacker calls `CreateProposal()` with:
   - `OrganizationAddress`: target organization address
   - `ExpiredTime`: `Context.CurrentBlockTime.AddSeconds(1)`
   - `ContractMethodName`, `ToAddress`, `Params`: any valid values
   - `Title`, `Description`, `ProposalDescriptionUrl`: minimal strings

2. Repeat step 1 in rapid succession (e.g., 1000 times in one block)

3. Wait 2 seconds for proposals to expire

4. Query `State.Proposals` - all 1000 proposals still exist in storage despite being expired

5. Defender must call `ClearProposal(proposalId)` 1000 times to cleanup, each consuming gas

**Expected vs Actual Result:**
- **Expected**: Proposals rejected due to insufficient expiration duration OR automatic cleanup occurs
- **Actual**: All proposals accepted and stored, remaining in state until manually cleared one-by-one

**Success Condition:** 
- Attacker creates N proposals with minimal cost
- State grows by N * 200-11,000 bytes
- Defender must execute N transactions to cleanup
- If creation rate > cleanup rate, state bloat persists and grows

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-66)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L179-186)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L22-34)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        // It is a valid proposer if
        // authority check is disable,
        // or sender is in proposer white list,
        // or sender is one of miners when member proposing allowed.
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L157-166)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = CheckProposalNotExpired(proposal);
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L177-180)
```csharp
    private bool CheckProposalNotExpired(ProposalInfo proposal)
    {
        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L225-253)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId, 
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L255-264)
```csharp
    private void CheckCreateProposalInput(CreateProposalInput input)
    {
        // Check the length of title
        Assert(input.Title.Length <= ParliamentConstants.MaxLengthForTitle, "Title is too long.");
        // Check the length of description
        Assert(input.Description.Length <= ParliamentConstants.MaxLengthForDescription, "Description is too long.");
        // Check the length of description url
        Assert(input.ProposalDescriptionUrl.Length <= ParliamentConstants.MaxLengthForProposalDescriptionUrl,
            "Description url is too long.");
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentState.cs (L22-22)
```csharp
    public MappedState<Hash, ProposalInfo> Proposals { get; set; }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentConstants.cs (L5-7)
```csharp
    public const int MaxLengthForTitle = 255;
    public const int MaxLengthForDescription = 10200;
    public const int MaxLengthForProposalDescriptionUrl = 255;
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```
