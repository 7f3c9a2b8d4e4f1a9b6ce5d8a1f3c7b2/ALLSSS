# Audit Report

## Title
Insufficient Validation of Other Miners' PreviousInValue Allows Consensus State Corruption

## Summary
The `ValidatePreviousInValue()` function only validates the block producer's own `PreviousInValue` against the previous round's `OutValue`, but does not validate `PreviousInValue` for other miners. During block execution, the `PerformSecretSharing()` function writes `PreviousInValue` for multiple miners to state based on unvalidated data from the block header, allowing a malicious miner to inject arbitrary `PreviousInValue` data for other miners and corrupt the consensus state.

## Finding Description

**Root Cause - Insufficient Validation:**

The validation only checks the sender's `PreviousInValue`. [1](#0-0) 

The critical issue is that `publicKey` is set to `validationContext.SenderPubkey`, meaning only the block producer's own `PreviousInValue` is validated against the previous round's `OutValue`.

**Attack Vector - Unvalidated RevealedInValues:**

During block generation in `UpdateLatestSecretPieces()`, miners can set `PreviousInValue` for other miners through the `RevealedInValues` mechanism without any on-chain validation. [2](#0-1) 

This data gets included in the block header's Round information and is NOT validated for other miners.

**State Corruption During Execution:**

The transaction input is constructed by extracting ALL miners' `PreviousInValue` from the Round. [3](#0-2) 

Then during execution, these unvalidated values are unconditionally written to state. [4](#0-3) 

**Why Protections Fail:**

The validation providers list only includes `UpdateValueValidationProvider` for UpdateValue behavior. [5](#0-4) 

No validator checks the integrity of other miners' `PreviousInValue` fields.

The `RecoverFromUpdateValue` method copies `PreviousInValue` for all miners from the provided round to the base round during validation. [6](#0-5) 

However, this recovered data is not validated against the previous round's state for miners other than the sender.

## Impact Explanation

**Consensus State Corruption:**
The attacker can write arbitrary `PreviousInValue` for victim miners, permanently corrupting the consensus round state stored on-chain. This breaks the fundamental integrity guarantee of the AEDPoS consensus mechanism.

**Secret Sharing Protocol Breach:**
The `PreviousInValue` is part of the cryptographic secret sharing mechanism designed to ensure randomness and prevent manipulation. By injecting fake values, the attacker bypasses the Shamir Secret Sharing protocol that should prevent any single miner from controlling these values.

**Affected Consensus Integrity:**
While the direct impact on mining order manipulation is limited (since each miner calculates their own signature from their own PreviousInValue during block production), the corruption of on-chain consensus state undermines the entire protocol's trustworthiness and could have cascading effects on systems that read this state.

**Network-Wide Impact:**
All honest miners whose `PreviousInValue` can be corrupted are affected. Any systems depending on the integrity of the consensus state (including monitoring tools, explorers, and verification systems) will observe corrupted data.

## Likelihood Explanation

**Attacker Capabilities:**
- Must be an active miner (authorized to produce blocks)
- No additional permissions required beyond normal mining rights
- Can exploit on every block they produce

**Attack Complexity - LOW:**
The attacker simply needs to provide fake `RevealedInValues` in the trigger information when producing a block. This is a direct manipulation of block header data with no complex timing or coordination required.

**Execution Practicality:**
- Entry point is the standard block production flow through `GetConsensusExtraData`
- Fully compatible with AElf contract execution model  
- No special state pre-conditions needed beyond being an active miner
- Attack can be executed by running modified node software that bypasses the off-chain checks in `SecretSharingService`

**Detection Difficulty:**
The fake values appear as legitimate "revealed" in-values. The after-execution validation compares the corrupted header against the corrupted state, so they match and validation passes.

**Probability - HIGH:**
Any malicious miner can execute this attack repeatedly on every block they produce with no economic cost or disincentive.

## Recommendation

Implement validation for ALL miners' `PreviousInValue` fields, not just the sender's:

1. **Extend UpdateValueValidationProvider** to validate `PreviousInValue` for all miners in `MinersPreviousInValues`:
   - For each miner with a non-null `PreviousInValue` in the provided round
   - Verify that `Hash(PreviousInValue) == OutValue` from the previous round
   - Only allow setting `PreviousInValue` for miners who actually have an `OutValue` in the previous round

2. **Add integrity checks** in `UpdateLatestSecretPieces()` to verify that revealed in-values are cryptographically valid reconstructions from the secret sharing pieces, not arbitrary values.

3. **Implement state consistency validation** that ensures miners cannot overwrite existing valid `PreviousInValue` entries with different values.

## Proof of Concept

```csharp
// Test demonstrates that a malicious miner can inject fake PreviousInValue for other miners
[Fact]
public async Task MaliciousMiner_CanCorruptOtherMinersPreviousInValue()
{
    // Setup: Initialize consensus with multiple miners
    var miners = await InitializeConsensusWithMultipleMinersAsync();
    var maliciousMiner = miners[0];
    var victimMiner = miners[1];
    
    // Round N: Victim produces block with OutValue
    var victimOutValue = await ProduceBlockWithVictim(victimMiner);
    
    // Round N+1: Malicious miner produces block
    // Construct fake RevealedInValues for victim
    var fakeVictimPreviousInValue = HashHelper.ComputeFrom("fake_data");
    var triggerInfo = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteString.CopyFrom(maliciousMiner.PublicKey),
        RevealedInValues = {
            { victimMiner.PublicKey.ToHex(), fakeVictimPreviousInValue }
        }
    };
    
    // Generate block with fake data
    var extraData = await ConsensusContract.GetConsensusExtraData(
        new BytesValue { Value = triggerInfo.ToByteString() }
    );
    
    // Execute the block
    await MineBlockAsync(extraData);
    
    // Verify: The fake PreviousInValue is stored on-chain
    var currentRound = await ConsensusContract.GetCurrentRoundInformation(new Empty());
    var storedPreviousInValue = currentRound.RealTimeMinersInformation[victimMiner.PublicKey.ToHex()].PreviousInValue;
    
    // VULNERABILITY: Fake value is stored instead of the real one
    storedPreviousInValue.ShouldBe(fakeVictimPreviousInValue);
    
    // Verify it doesn't match the victim's actual OutValue from previous round
    HashHelper.ComputeFrom(storedPreviousInValue).ShouldNotBe(victimOutValue);
}
```

## Notes

The vulnerability exists in the asymmetry between what is validated (only sender's `PreviousInValue`) and what is written to state (all miners' `PreviousInValue` via `MinersPreviousInValues`). While the off-chain `SecretSharingService` has proper checks to reconstruct values using Shamir Secret Sharing, a malicious miner can bypass these checks by running modified node software, and the on-chain contract has no defense against this.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-29)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
```
