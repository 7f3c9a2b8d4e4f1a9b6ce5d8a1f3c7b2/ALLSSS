### Title
ActualMiningTime Can Be Manipulated to Bypass Time Slot Enforcement

### Summary
Miners can manipulate the `ActualMiningTime` field in consensus data to claim they produced blocks at times different from the actual block timestamp, bypassing time slot validation. The system validates that `ActualMiningTime` falls within the miner's expected time slot but never verifies that it matches the block header timestamp, allowing miners to extend their effective mining window and falsify consensus timing records.

### Finding Description

The vulnerability exists in the consensus validation flow where `ActualMiningTime` (the claimed block production time) is not cross-validated against `BlockHeader.Time` (the actual block timestamp). [1](#0-0) 

The `TimeSlotValidationProvider.CheckMinerTimeSlot()` method retrieves `ActualMiningTimes` from the base round (after recovery from provided data) and validates only that the latest `ActualMiningTime` is within the miner's expected time slot window. It does not compare this claimed time against the block header timestamp or current validation time. [2](#0-1) 

During validation, the base round is recovered with data from the provided consensus extra data, which includes the miner's claimed `ActualMiningTime`: [3](#0-2) 

When processing the consensus transaction, this unvalidated `ActualMiningTime` is directly added to the state: [4](#0-3) 

The only block header time validation checks if the timestamp is not more than 4 seconds in the future: [5](#0-4) 

**Root Cause:** The consensus extra data containing `ActualMiningTime` is generated with the planned mining time, but miners can modify this data before including it in the block header. The signature only proves the miner signed the block header (including the extra data), not that the extra data was generated correctly. No validation cross-checks the claimed `ActualMiningTime` against the actual `BlockHeader.Time`.

### Impact Explanation

**Consensus Integrity Compromise:**
- Miners can produce blocks outside their designated time slots while claiming compliance
- Consensus timing records stored in `ActualMiningTimes` are falsified, corrupting historical data
- Term transition logic depends on checking `ActualMiningTimes` against term duration thresholds, allowing manipulation of term changes [6](#0-5) 

**Time Slot Calculation Corruption:**
- First round miner validation uses `ActualMiningTime` to calculate passed slots, which would yield incorrect results with manipulated timestamps [7](#0-6) 

**Unfair Mining Advantage:**
- Attackers gain extended effective mining windows by claiming earlier `ActualMiningTime` values while producing blocks later
- This allows miners to gather more transactions or wait for better network conditions while maintaining time slot compliance

### Likelihood Explanation

**Attacker Capabilities Required:**
- Any current miner with normal mining permissions can execute this attack
- No special privileges beyond being in the active miner list

**Attack Complexity:**
- Low: Miner generates consensus extra data via standard call to `GetConsensusExtraData` [8](#0-7) 

- Parses the `AElfConsensusHeaderInformation` protobuf message
- Modifies the `ActualMiningTime` field in `UpdateValueInput` or `TinyBlockInput` to desired timestamp within their time slot [9](#0-8) 

- Re-serializes and includes modified data in block header
- Signs the block normally

**Detection Difficulty:**
- The manipulation is undetectable through current validation logic
- The only validation extracts and checks that the sender pubkey matches the signer pubkey, not the timestamp accuracy [10](#0-9) 

**Feasibility:**
- High: Every miner can exploit this every block they produce
- No preconditions beyond normal mining operations
- Works within existing protocol semantics

### Recommendation

**Immediate Fix:**
Add validation in `TimeSlotValidationProvider` or a new validation provider to ensure `ActualMiningTime` is close to the block header timestamp:

1. In `TimeSlotValidationProvider.ValidateHeaderInformation()`, add a check comparing the latest `ActualMiningTime` from the provided round against the validation context's current time or implement access to the block header time
2. Enforce that `|ActualMiningTime - BlockHeaderTime| â‰¤ tolerance` where tolerance is a small value (e.g., 1-2 seconds) to account for minor clock skew
3. Add a new validation provider specifically for timestamp correlation that has access to both the block header and consensus extra data

**Code-Level Changes:**
```
In TimeSlotValidationProvider or new validator:
- Obtain BlockHeader.Time from validation context
- Extract ActualMiningTime from providedRound
- Assert: Math.Abs((ActualMiningTime - BlockHeader.Time).Seconds) <= ALLOWED_TIMESTAMP_DRIFT
- Where ALLOWED_TIMESTAMP_DRIFT = 2 seconds
```

**Test Cases:**
- Test block with ActualMiningTime = BlockHeader.Time (should pass)
- Test block with ActualMiningTime = BlockHeader.Time + 1 second (should pass)
- Test block with ActualMiningTime = BlockHeader.Time - 3 seconds (should fail)
- Test block with ActualMiningTime within slot but BlockHeader.Time outside slot (should fail)

### Proof of Concept

**Initial State:**
- Miner M has time slot from T1 to T1+4000ms (assuming 4 second mining interval)
- Current time is T1+4500ms (past M's time slot)
- M's `ExpectedMiningTime` = T1

**Attack Steps:**
1. At T1+4500ms, miner M calls `GetConsensusCommand` to check if they can mine
2. The check would fail since time slot passed, but M proceeds anyway
3. M calls `GetConsensusExtraData` which generates consensus data with `ActualMiningTime` = T1+4500ms
4. M parses the `AElfConsensusHeaderInformation` and modifies the `ActualMiningTime` in the embedded `UpdateValueInput` to T1+2000ms (within their slot)
5. M creates block with `BlockHeader.Time` = T1+4500ms and modified consensus extra data
6. M signs and broadcasts the block

**Expected Result (Current System):**
- Block validation passes because:
  - `BlockHeader.Time` = T1+4500ms is not more than 4 seconds in future (passes future block check)
  - `ActualMiningTime` = T1+2000ms is within [T1, T1+4000ms] (passes time slot check)
- No validation catches the discrepancy between T1+2000ms and T1+4500ms
- M successfully produces block outside their time slot

**Expected Result (With Fix):**
- Block validation fails with "ActualMiningTime does not match BlockHeader.Time" 
- Attack is detected and prevented

### Notes

The vulnerability is confirmed by the complete absence of any validation logic comparing `ActualMiningTime` with `BlockHeader.Time` or validation time. The block header time validation and time slot validation operate independently without cross-validation, creating an exploitable gap that allows miners to falsify their block production timestamps while satisfying both checks individually.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-21)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-249)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

```

**File:** src/AElf.Kernel.Core/Blockchain/Application/IBlockValidationProvider.cs (L133-139)
```csharp
        if (block.Header.Height != AElfConstants.GenesisBlockHeight &&
            block.Header.Time.ToDateTime() - TimestampHelper.GetUtcNow().ToDateTime() >
            KernelConstants.AllowedFutureBlockTimeSpan.ToTimeSpan())
        {
            Logger.LogDebug("Future block received {Block}, {BlockTime}", block, block.Header.Time.ToDateTime());
            return Task.FromResult(false);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L206-214)
```csharp
                var passedSlotsCount =
                    (Context.CurrentBlockTime - latestMinedSlotLastActualMiningTime).Milliseconds()
                    .Div(miningInterval);
                if (passedSlotsCount == currentMinerOrder.Sub(latestMinedOrder).Add(1).Add(minersCount) ||
                    passedSlotsCount == currentMinerOrder.Sub(latestMinedOrder).Add(minersCount))
                {
                    Context.LogDebug(() => "[CURRENT MINER]FIRST ROUND");
                    return true;
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L55-64)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataToPublishOutValue(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

```

**File:** protobuf/aedpos_contract.proto (L194-204)
```text
message UpdateValueInput {
    // Calculated from current in value.
    aelf.Hash out_value = 1;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 2;
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
    // Publish previous in value for validation previous signature and previous out value.
    aelf.Hash previous_in_value = 4;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    google.protobuf.Timestamp actual_mining_time = 5;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L21-33)
```csharp
    public ByteString ExtractConsensusExtraData(BlockHeader header)
    {
        var consensusExtraData =
            _blockExtraDataService.GetExtraDataFromBlockHeader(_consensusExtraDataProvider.BlockHeaderExtraDataKey,
                header);
        if (consensusExtraData == null)
            return null;

        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
    }
```
