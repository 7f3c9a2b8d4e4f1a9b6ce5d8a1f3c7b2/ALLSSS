### Title
Insufficient Contract Type Validation in ChangeMaximumMinersCountController Enables Governance Bypass

### Summary
The `ChangeMaximumMinersCountController()` function does not verify that the new controller's `ContractAddress` is a legitimate governance contract (Parliament, Association, or Referendum). An attacker controlling the current governance can deploy a malicious contract implementing `ValidateOrganizationExist` to always return true, then set their personal address as the controller, achieving permanent governance bypass for critical consensus parameters.

### Finding Description

The vulnerability exists in `ChangeMaximumMinersCountController()` which validates the new controller using `CheckOrganizationExist()`: [1](#0-0) 

The `CheckOrganizationExist()` method performs a cross-contract call to `ValidateOrganizationExist` on the provided `ContractAddress` without any type validation: [2](#0-1) 

Only three legitimate governance contracts implement `ValidateOrganizationExist`: [3](#0-2) [4](#0-3) [5](#0-4) 

The `ValidateOrganizationExist` method is defined as part of the ACS3 interface: [6](#0-5) 

However, **any deployed contract can implement a method with this signature**. An attacker can deploy a malicious contract with a `ValidateOrganizationExist` method that always returns true, bypassing the validation entirely.

The controller change requires only that the sender is the current controller's `OwnerAddress`: [7](#0-6) 

Once changed, the new controller has **exclusive and permanent control** over `SetMaximumMinersCount` and `SetMinerIncreaseInterval`: [8](#0-7) [9](#0-8) 

### Impact Explanation

**Governance Bypass**: An attacker who temporarily controls governance can establish **permanent, unilateral control** over maximum miners count and miner increase interval parameters, completely bypassing all future governance processes.

**Irreversible Control**: There is no recovery mechanism. The controller can only be changed by the current controller's `OwnerAddress`, creating an irrevocable lock-in if set to an attacker-controlled address.

**Consensus Manipulation**: The attacker can arbitrarily manipulate:
- Maximum miners count (affecting validator set size and network security)
- Miner increase interval (affecting consensus evolution and decentralization)

**Affected Parties**: 
- All network participants (compromised consensus integrity)
- Legitimate governance organizations (permanent loss of control)
- Protocol security (manipulable validator parameters)

**Severity**: MEDIUM-HIGH - While requiring initial governance control, the attack provides persistent authority even after losing governance majority, with no remediation path.

### Likelihood Explanation

**Attacker Capabilities Required**:
1. Control of current governance controller (Parliament by default) - can be achieved through majority miner votes or election manipulation
2. Ability to deploy a malicious contract through governance approval

**Attack Complexity**: MEDIUM
- Requires 2 governance proposals: (1) deploy malicious contract, (2) change controller
- Both are straightforward and don't require sophisticated techniques
- No special timing or race conditions needed

**Feasibility Conditions**:
- Attacker must win governance control (e.g., 51% of Parliament votes)
- Standard contract deployment process (no special privileges needed)
- The attack is entirely on-chain and deterministic

**Detection Constraints**:
- Controller change appears legitimate (looks like switching to another "organization")
- No obvious red flags in the transaction itself
- Only detailed contract analysis reveals the fake organization

**Economic Rationality**: The cost is limited to governance campaign costs plus contract deployment fees, while the benefit is **permanent control** over critical consensus parameters. For a sophisticated attacker, this cost-benefit ratio is highly favorable.

**Probability**: MEDIUM - Requires temporary governance control but provides permanent benefits, making it attractive for patient attackers who achieve governance majority.

### Recommendation

**Immediate Fix**: Add explicit contract address validation to restrict controller changes to known governance contracts only. Follow the secure pattern used in `CrossChainContract`: [10](#0-9) 

**Recommended Code Change** in `ChangeMaximumMinersCountController()`:

```csharp
public override Empty ChangeMaximumMinersCountController(AuthorityInfo input)
{
    RequiredMaximumMinersCountControllerSet();
    AssertSenderAddressWith(State.MaximumMinersCountController.Value.OwnerAddress);
    
    // Add explicit contract type validation
    EnsureParliamentContractAddressSet();
    Assert(
        input.ContractAddress == State.ParliamentContract.Value ||
        input.ContractAddress == State.AssociationContract.Value ||
        input.ContractAddress == State.ReferendumContract.Value,
        "Controller contract must be Parliament, Association, or Referendum.");
    
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");

    State.MaximumMinersCountController.Value = input;
    return new Empty();
}
```

**Additional Safeguards**:
1. Add regression test validating rejection of non-governance contracts
2. Consider adding an emergency override mechanism controlled by a separate authority
3. Emit event logging controller changes for monitoring
4. Document the security requirement that only governance contracts are valid controllers

### Proof of Concept

**Initial State**:
- MaximumMinersCountController = Parliament default organization
- Attacker controls Parliament (e.g., 51% of validator votes)

**Attack Steps**:

1. **Deploy Malicious Contract** via Parliament proposal:
```csharp
public class FakeGovernanceContract : ContractBase
{
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = true };  // Always returns true
    }
}
```

2. **Create Parliament Proposal** to change controller:
```csharp
CreateProposal(
    ToAddress: ConsensusContract,
    MethodName: "ChangeMaximumMinersCountController",
    Params: new AuthorityInfo {
        ContractAddress: FakeGovernanceContractAddress,
        OwnerAddress: AttackerPersonalAddress  // Attacker's EOA
    }
)
```

3. **Approve and Release** proposal through Parliament

4. **Verify Bypass**:
```csharp
// Controller is now attacker's personal address
GetMaximumMinersCountController() 
// Returns: { OwnerAddress: AttackerPersonalAddress, ContractAddress: FakeGovernanceContractAddress }

// Attacker can now call directly without governance:
SetMaximumMinersCount(1)  // Succeeds - no proposal needed
SetMinerIncreaseInterval(1)  // Succeeds - no proposal needed
```

**Expected Result**: Calls to `SetMaximumMinersCount` and `SetMinerIncreaseInterval` should require governance proposals

**Actual Result**: Attacker can call these methods directly using their personal address, permanently bypassing governance

**Success Condition**: Attacker maintains control of consensus parameters even after losing Parliament majority, with no mechanism for legitimate governance to recover control.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L16-18)
```csharp
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L45-54)
```csharp
    public override Empty ChangeMaximumMinersCountController(AuthorityInfo input)
    {
        RequiredMaximumMinersCountControllerSet();
        AssertSenderAddressWith(State.MaximumMinersCountController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MaximumMinersCountController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L58-60)
```csharp
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L83-88)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L218-218)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
```

**File:** protobuf/acs3.proto (L67-70)
```text
    // Check the existence of an organization.
    rpc ValidateOrganizationExist(aelf.Address) returns (google.protobuf.BoolValue){
        option (aelf.is_view) = true;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L61-74)
```csharp
    public override Empty ChangeCrossChainIndexingController(AuthorityInfo input)
    {
        AssertCrossChainIndexingControllerAuthority(Context.Sender);
        SetContractStateRequired(State.ParliamentContract, SmartContractConstants.ParliamentContractSystemName);
        Assert(
            input.ContractAddress == State.ParliamentContract.Value &&
            ValidateParliamentOrganization(input.OwnerAddress), "Invalid authority input.");
        State.CrossChainIndexingController.Value = input;
        Context.Fire(new CrossChainIndexingControllerChanged
        {
            AuthorityInfo = input
        });
        return new Empty();
    }
```
