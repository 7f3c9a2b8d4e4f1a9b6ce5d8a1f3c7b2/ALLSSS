### Title
Case-Insensitive Token Uniqueness Bypass via CrossChainCreateToken

### Summary
The `CrossChainCreateToken` function uses case-sensitive existence checks instead of the case-insensitive mechanism employed by normal token creation, allowing attackers to create duplicate tokens with different casing (e.g., "ABC-0" and "abc-0") through cross-chain operations. This violates the fundamental token uniqueness invariant and can lead to supply fragmentation, user confusion, and potential double-counting in token aggregations.

### Finding Description

The MultiToken contract implements case-insensitive token uniqueness through the `State.InsensitiveTokenExisting` mapping, which stores symbols in uppercase. [1](#0-0) 

In the normal token creation flow via `CreateToken`, the `CheckTokenExists` function properly validates case-insensitive uniqueness: [2](#0-1) 

However, the `CrossChainCreateToken` function bypasses this protection by using only a case-sensitive check: [3](#0-2) 

This check verifies only `State.TokenInfos[tokenInfo.Symbol] == null`, which uses exact case matching, rather than checking `State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()]`. When the check passes, `RegisterTokenInfo` is called, which creates a separate entry in `State.TokenInfos` with the different casing while overwriting the same uppercase key in `State.InsensitiveTokenExisting`.

The `GetSymbolType` function mentioned in the question does not normalize case: [4](#0-3) 

This is not inherently problematic, but the lack of case-insensitive validation in `CrossChainCreateToken` creates the vulnerability.

### Impact Explanation

**Token Uniqueness Violation**: The protocol's fundamental invariant that token symbols are case-insensitively unique is broken. If token "ABC-0" exists, an attacker can create "abc-0" as a completely separate token with its own:
- Token info (issuer, owner, supply, decimals)
- Balance mappings
- Allowance mappings
- Lock whitelist entries

**User Confusion & Misrouting**: Users and dApps expecting case-insensitive token identification will interact with the wrong token. Since `GetTokenInfo` uses exact case matching: [5](#0-4) 

A user searching for "ABC-0" will not find "abc-0" and vice versa.

**Supply Fragmentation**: For NFT collections, this creates parallel namespaces. Both "ABC-0" and "abc-0" can issue their own NFT items (ABC-1, ABC-2 vs abc-1, abc-2), fragmenting what should be a single collection.

**Cross-Chain Integration Impact**: Cross-chain transfers and validations expecting unique symbols will fail or create inconsistencies when multiple case variants exist on different chains.

**Affected Parties**: All token holders, NFT creators, dApps performing token aggregations, and cross-chain bridges.

### Likelihood Explanation

**Reachable Entry Point**: `CrossChainCreateToken` is a public method accessible to any caller with valid cross-chain proof.

**Attack Prerequisites**:
1. Token contract must be registered for a parent/side chain in `State.CrossChainTransferWhiteList`: [6](#0-5) 
2. Valid merkle proof and cross-chain verification required: [7](#0-6) 
3. Original transaction must be from registered token contract

**Feasibility**:
- **High** if attacker controls another chain in the multi-chain ecosystem
- **Medium** if attacker can exploit vulnerabilities on another chain to create tokens with desired symbols
- **Medium-Low** if attacker must compromise cross-chain merkle proofs

**Execution Practicality**: In a legitimate multi-chain environment where parent/side chains are properly registered, the attack is straightforward once prerequisites are met. The attacker simply creates a token with case-variant symbol on chain A, then submits `CrossChainCreateToken` on chain B with valid proof.

**Economic Rationality**: Cost is primarily the cross-chain transaction fees and token creation costs on the source chain. The impact (namespace pollution, user confusion, potential for targeted attacks on specific NFT collections) can be significant.

### Recommendation

**Primary Fix**: Modify `CrossChainCreateToken` to use case-insensitive existence checking before calling `RegisterTokenInfo`:

```csharp
// Before line 506 in TokenContract_Actions.cs
if (State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()])
{
    Assert(State.TokenInfos[tokenInfo.Symbol] != null, 
           "Token with case-variant symbol already exists.");
}

if (State.TokenInfos[tokenInfo.Symbol] == null)
{
    RegisterTokenInfo(tokenInfo);
    // ...
}
```

**Alternative**: Call `CheckTokenExists(tokenInfo.Symbol)` before the null check to reuse existing validation logic.

**Additional Safeguard**: Add assertion in `RegisterTokenInfo` to prevent overwriting existing case-insensitive entries:
```csharp
private void RegisterTokenInfo(TokenInfo tokenInfo)
{
    // ... existing validations ...
    Assert(!State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()], 
           "Token with case-variant symbol already exists.");
    State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
    State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
}
```

**Test Cases**: Add regression tests verifying:
1. CrossChainCreateToken rejects tokens differing only in case from existing tokens
2. Case-insensitive uniqueness holds across all token creation paths
3. Specific test: Create "ABC-0" normally, attempt CrossChainCreateToken with "abc-0", verify rejection

### Proof of Concept

**Initial State**:
- Chain A (current chain) has token "ABC-0" created via normal `Create()` flow
- `State.TokenInfos["ABC-0"]` = {symbol: "ABC-0", ...}
- `State.InsensitiveTokenExisting["ABC-0"]` = true
- Chain B (parent/side chain) is registered in `CrossChainTransferWhiteList`

**Attack Sequence**:

1. **On Chain B**: Attacker creates token "abc-0" (different casing) via normal creation flow
   - This is valid on Chain B if "ABC-0" doesn't exist there

2. **On Chain B**: Attacker calls `ValidateTokenInfoExists` for "abc-0"
   - Generates transaction TX_B with symbol "abc-0"

3. **On Chain A**: Attacker calls `CrossChainCreateToken` with:
   - `input.TransactionBytes` = TX_B (contains symbol "abc-0")
   - `input.FromChainId` = Chain B's ID
   - `input.MerklePath` = valid merkle proof for TX_B
   - `input.ParentChainHeight` = appropriate height

4. **Execution on Chain A**:
   - Line 488: CrossChainVerify passes (valid proof)
   - Line 489: Parse input, symbol = "abc-0"
   - Line 506: Check `State.TokenInfos["abc-0"] == null` â†’ **TRUE** (only "ABC-0" exists)
   - Line 508: RegisterTokenInfo creates:
     - `State.TokenInfos["abc-0"]` = {symbol: "abc-0", ...}
     - `State.InsensitiveTokenExisting["ABC-0"]` = true (overwrites)

**Expected Result**: CrossChainCreateToken should reject "abc-0" because case-variant "ABC-0" exists.

**Actual Result**: Both `State.TokenInfos["ABC-0"]` and `State.TokenInfos["abc-0"]` exist as separate tokens, violating uniqueness invariant.

**Success Condition**: Attacker successfully creates duplicate token with different casing, confirmed by querying both `GetTokenInfo("ABC-0")` and `GetTokenInfo("abc-0")` returning different TokenInfo objects.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L480-482)
```csharp
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L486-488)
```csharp
        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-508)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```
