### Title
ArrangeAbnormalMiningTime Allows Single Miner to Claim Multiple Saving Time Slots and Inflate ProducedBlocks Counter

### Summary
The `ArrangeAbnormalMiningTime` function calculates saving time slots based purely on elapsed time without checking whether a miner has already produced blocks in the current round. This allows a single miner to claim multiple non-overlapping saving slots as time progresses, repeatedly calling `UpdateValue` and inflating their `ProducedBlocks` counter, which affects mining rewards and consensus reputation.

### Finding Description

The vulnerability exists in the saving slot validation logic within `IsCurrentMiner`: [1](#0-0) 

The `ArrangeAbnormalMiningTime` function calculates saving slots using a stateless formula: [2](#0-1) 

The calculation is: `actualArrangedMiningTime = roundStartTime + missedRoundsCount * totalRoundTime + order * miningInterval`, where `missedRoundsCount = (currentTime - roundStartTime) / totalRoundTime`.

As time advances without `NextRound` being called, `missedRoundsCount` increases, creating new saving slots for the same miner at intervals of `totalRoundTime` (e.g., every 72 seconds for 17 miners with 4-second intervals). Each saving slot is a 4-second window where `IsCurrentMiner` returns true.

**Why protections fail:**

1. **No state check in saving slot logic**: The saving slot check (lines 181-189) does not verify whether the miner has already produced blocks via `ActualMiningTimes` or has a non-null `OutValue`.

2. **TimeSlotValidationProvider only checks normal slots**: The validation in `TimeSlotValidationProvider` only validates against `ExpectedMiningTime` (normal slots), not dynamically calculated saving slots: [3](#0-2) 

3. **EnsureTransactionOnlyExecutedOnceInOneBlock allows cross-block exploitation**: This protection only prevents multiple consensus transactions within a single block, not across multiple blocks: [4](#0-3) 

4. **ProcessUpdateValue unconditionally increments ProducedBlocks**: Each call to `UpdateValue` increments the counter without checking if the miner already mined: [5](#0-4) 

**Regarding "different pubkeys"**: Each pubkey must be in the round's `RealTimeMinersInformation` (line 158 of ViewMethods, line 24 of ArrangeAbnormalMiningTime) and has a unique `Order`. Different pubkeys get non-overlapping saving slots at any given time. However, this doesn't prevent the vulnerability because each individual miner can accumulate multiple saving slots over time with their own pubkey.

### Impact Explanation

**Direct Impact:**
1. **Reward Misallocation**: Miners who exploit multiple saving slots accumulate inflated `ProducedBlocks` counters, which directly affect mining reward distribution. A miner producing 10 blocks in one round (via repeated saving slots) would receive 10x rewards compared to honest miners who produced 1 block.

2. **Consensus Reputation Manipulation**: The `ProducedBlocks` counter is used by the Election contract to track miner performance: [6](#0-5) 

Inflated counts give malicious miners unfair advantages in election rankings and term selection.

3. **Transaction Fee Claims**: While `ClaimTransactionFees` is limited to once per block height, a miner with multiple saving slots across many blocks gets proportionally more opportunities to claim fees: [7](#0-6) 

**Quantified Damage:**
- With 17 miners and 4000ms intervals, `totalRoundTime = 72000ms`
- In a 10-minute (600,000ms) stalled round, a miner gets ~8 saving slots
- Exploiting all slots yields 8x normal `ProducedBlocks`, translating to 8x mining rewards
- If mining rewards are 100 ELF per block, the attacker steals 700 ELF from honest miners

**Affected Parties:**
- Honest miners receive diluted rewards
- Token holders suffer from disproportionate token emissions to malicious miners
- Election integrity is compromised

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an existing miner in the current round (feasible for colluding miners or compromised nodes)
- Requires ability to withhold `NextRound` calls, achievable through:
  - Network partitioning
  - Colluding with the designated round terminator
  - Exploiting stalled round conditions

**Attack Complexity:**
- Low: Simply wait for saving slots and repeatedly call `UpdateValue`
- No sophisticated cryptographic attacks required
- Exploitation is passive once a stalled round condition exists

**Feasibility Conditions:**
- Round must be stalled (miners miss normal slots)
- `NextRound` not called for extended period
- This naturally occurs during network issues or coordination failures
- Becomes more likely as the network grows and coordination becomes harder

**Detection Constraints:**
- Multiple `ActualMiningTimes` entries for the same miner in one round are visible on-chain
- However, the protocol currently treats this as valid behavior
- No automated detection or alerting mechanisms exist

**Economic Rationality:**
- Costs: Block production resources (computational overhead minimal)
- Benefits: Multiples of normal mining rewards
- Risk: Potential reputation damage if detected, but no protocol-level penalties
- Clearly profitable for rational attackers

**Probability Assessment:**
Given that stalled rounds are a design consideration (hence the saving slot mechanism), and that network issues are inevitable, this vulnerability is **highly likely** to be exploited when stalled conditions occur.

### Recommendation

**Code-Level Mitigation:**

Add a state check in the saving slot logic to prevent miners who have already mined from claiming additional saving slots:

```solidity
// In IsCurrentMiner, replace lines 181-189 with:
var minerInRound = currentRound.RealTimeMinersInformation[pubkey];

// Check if miner already produced a block this round via normal or saving slot
if (minerInRound.ActualMiningTimes.Any(t => t >= currentRound.GetRoundStartTime()))
{
    Context.LogDebug(() => "[CURRENT MINER]ALREADY MINED THIS ROUND");
    return false;
}

var nextArrangeMiningTime =
    currentRound.ArrangeAbnormalMiningTime(pubkey, Context.CurrentBlockTime, true);
var actualArrangedMiningTime = nextArrangeMiningTime.AddMilliseconds(-currentRound.TotalMilliseconds());
if (actualArrangedMiningTime <= Context.CurrentBlockTime &&
    Context.CurrentBlockTime <= actualArrangedMiningTime.AddMilliseconds(miningInterval))
{
    Context.LogDebug(() => "[CURRENT MINER]SAVING");
    return true;
}
```

**Invariant Checks:**
1. Assert in `ProcessUpdateValue` that `ActualMiningTimes.Count` for the current round ≤ `maximumBlocksCount`
2. Add validation that a miner's `ActualMiningTimes` entries within a round don't exceed expected limits
3. Implement round timeout mechanism that forces `NextRound` after a maximum duration

**Test Cases:**
1. Simulate stalled round with time advancing past multiple `totalRoundTime` intervals
2. Attempt multiple `UpdateValue` calls from the same miner across different saving slots
3. Verify that after first successful mining, subsequent saving slot attempts are rejected
4. Confirm `ProducedBlocks` counter only increments once per round per miner (excluding legitimate tiny blocks)

### Proof of Concept

**Initial State:**
- Round 100 started at timestamp 0
- 17 miners with 4000ms mining intervals
- `totalRoundTime = 72000ms`
- Miner "Alice" (Order=5) has normal slot at [20000ms, 24000ms]
- Current blockchain time: 92000ms (past first round duration)

**Attack Steps:**

1. **T=92000ms**: Alice's first saving slot
   - `missedRoundsCount = 92000 / 72000 = 1`
   - `actualArrangedMiningTime = 0 + 1*72000 + 5*4000 = 92000ms`
   - Slot: [92000ms, 96000ms] ✓
   - Alice calls `UpdateValue` → `ProducedBlocks` becomes 1
   - `ActualMiningTimes` = [92000ms]

2. **T=164000ms**: Alice's second saving slot
   - `missedRoundsCount = 164000 / 72000 = 2`
   - `actualArrangedMiningTime = 0 + 2*72000 + 5*4000 = 164000ms`
   - Slot: [164000ms, 168000ms] ✓
   - Alice calls `UpdateValue` again → `ProducedBlocks` becomes 2
   - `ActualMiningTimes` = [92000ms, 164000ms]

3. **T=236000ms**: Alice's third saving slot
   - `missedRoundsCount = 236000 / 72000 = 3`
   - `actualArrangedMiningTime = 0 + 3*72000 + 5*4000 = 236000ms`
   - Slot: [236000ms, 240000ms] ✓
   - Alice calls `UpdateValue` again → `ProducedBlocks` becomes 3
   - `ActualMiningTimes` = [92000ms, 164000ms, 236000ms]

**Expected Result:** Alice should only be allowed to mine once per round.

**Actual Result:** Alice successfully mines 3 times in round 100, accumulating 3x `ProducedBlocks` and claiming 3x rewards.

**Success Condition:** Query `State.Rounds[100].RealTimeMinersInformation["Alice"].ProducedBlocks` returns 3, and `ActualMiningTimes.Count` returns 3, confirming the exploit succeeded.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L181-189)
```csharp
        var nextArrangeMiningTime =
            currentRound.ArrangeAbnormalMiningTime(pubkey, Context.CurrentBlockTime, true);
        var actualArrangedMiningTime = nextArrangeMiningTime.AddMilliseconds(-currentRound.TotalMilliseconds());
        if (actualArrangedMiningTime <= Context.CurrentBlockTime &&
            Context.CurrentBlockTime <= actualArrangedMiningTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]SAVING");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L33-36)
```csharp
        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L40-50)
```csharp
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L242-252)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L367-379)
```csharp

```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L867-874)
```csharp
    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
        var claimTransactionExecuteHeight = State.ClaimTransactionFeeExecuteHeight.Value;

        Assert(claimTransactionExecuteHeight < Context.CurrentHeight,
            $"This method already executed in height {State.ClaimTransactionFeeExecuteHeight.Value}");
        State.ClaimTransactionFeeExecuteHeight.Value = Context.CurrentHeight;
```
