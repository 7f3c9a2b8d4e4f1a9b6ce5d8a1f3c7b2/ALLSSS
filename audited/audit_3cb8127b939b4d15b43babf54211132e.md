### Title
Incomplete Validation of FinalOrderOfNextRound Allows Duplicate Mining Orders in Next Round

### Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` method uses `.Distinct()` on `MinerInRound` objects instead of on `FinalOrderOfNextRound` integer values, failing to detect duplicate order assignments. This allows a malicious miner to craft NextRound consensus data where multiple miners share the same order value, breaking the next round's mining schedule integrity and causing consensus failures.

### Finding Description

The validation logic in `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` attempts to verify that miners who determined their next round order match those who mined blocks: [1](#0-0) 

The root cause is that `.Distinct()` operates on full `MinerInRound` objects. Since protobuf-generated classes use field-by-field equality comparison, two different miners (with different pubkeys, signatures, etc.) will never be considered equal, even if they have identical `FinalOrderOfNextRound` values. This means the validation always counts all miners with `FinalOrderOfNextRound > 0`, regardless of whether those order values are unique.

**Why existing protections fail:**

The code should validate that `FinalOrderOfNextRound` values themselves are distinct, but instead validates that `MinerInRound` objects are distinct. The current logic is equivalent to:
```
distinctCount = minersWithOrder.Count  // Distinct() does nothing useful here
```

When `GenerateNextRoundInformation()` processes the malicious round data, it orders miners by `FinalOrderOfNextRound` and assigns that value as each miner's `Order` in the next round: [2](#0-1) 

If two miners have `FinalOrderOfNextRound = 5`, both will be assigned `Order = 5` in the next round. This violates the invariant that each miner must have a unique order within a round.

**Execution path:**
1. Attacker (current miner) creates `NextRoundInput` with duplicate `FinalOrderOfNextRound` values
2. Validation at `ValidateBeforeExecution` checks using `NextRoundMiningOrderValidationProvider`
3. Validation incorrectly passes because `.Distinct()` doesn't detect order value duplicates
4. `ProcessNextRound` calls `GenerateNextRoundInformation` 
5. Multiple miners get assigned identical `Order` values in next round
6. Round logic breaks when querying miners by order [3](#0-2) 

### Impact Explanation

**Consensus Integrity Failure:**

When multiple miners share the same `Order` in a round, consensus logic that assumes unique orders will fail. For example, extra block producer selection queries by order: [4](#0-3) 

If two miners have the same order, `FirstOrDefault` returns an arbitrary miner, potentially selecting the wrong extra block producer.

Similarly, the `BreakContinuousMining` function queries miners by specific order values: [5](#0-4) 

With duplicate orders, `First(i => i.Order == 1)` could throw an exception (if LINQ detects multiple matches in some contexts) or return an arbitrary miner, breaking the continuous mining prevention logic.

**Affected parties:**
- Entire blockchain consensus system
- All miners who cannot produce blocks correctly in the corrupted round
- Users experiencing transaction confirmation delays or failures

**Severity justification:** HIGH - This directly compromises consensus integrity, a critical invariant. The corrupted round cannot proceed normally, effectively causing a consensus DoS until manual intervention or the round expires.

### Likelihood Explanation

**Attacker capabilities:**
- Must be an active miner in the current round
- Must have mined at least one block (to have `OutValue != null`)
- Must be eligible to trigger `NextRound` behavior (typically the designated miner for round transition)

**Attack complexity:** LOW
- Attacker simply crafts a `NextRoundInput` with duplicate `FinalOrderOfNextRound` values
- No cryptographic operations needed beyond normal mining
- Single transaction execution

**Feasibility conditions:**
- Validation provider is used during `NextRound` behavior processing
- No additional checks exist to verify order uniqueness
- The conflict resolution logic in `ApplyNormalConsensusData` prevents duplicates during normal consensus but doesn't apply to externally provided NextRound data [6](#0-5) 

**Detection:** The attack would be immediately visible when the next round fails to proceed correctly, but by then the corrupted round data is already committed to state.

**Probability assessment:** MEDIUM - Requires attacker to be a current miner and properly timed to trigger NextRound, but no other barriers exist.

### Recommendation

**Code-level mitigation:**

Replace the validation logic to check for distinct `FinalOrderOfNextRound` values:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var providedRound = validationContext.ProvidedRound;
    
    var minersWithOrder = providedRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0)
        .ToList();
    
    var distinctOrderCount = minersWithOrder
        .Select(m => m.FinalOrderOfNextRound)
        .Distinct()
        .Count();
    
    var minersWhoMined = providedRound.RealTimeMinersInformation.Values
        .Count(m => m.OutValue != null);
    
    // Check both that orders are unique AND match miners who mined
    if (distinctOrderCount != minersWithOrder.Count || 
        distinctOrderCount != minersWhoMined)
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound: duplicate orders or count mismatch.";
        return validationResult;
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

**Invariant checks to add:**
1. Verify `distinctOrderCount == minersWithOrder.Count` (no duplicate orders)
2. Verify `distinctOrderCount == minersWhoMined` (matches miners who participated)
3. Optionally verify order values are in valid range `[1, minersCount]`

**Test cases to prevent regression:**
1. Test with two miners having same `FinalOrderOfNextRound` - should fail validation
2. Test with correct unique orders - should pass validation  
3. Test with order count not matching mined miners - should fail validation

### Proof of Concept

**Required initial state:**
- 5 active miners in current round (pubkeys: A, B, C, D, E)
- Miners A, B, C have mined blocks (have `OutValue != null`)
- Miner A is eligible to trigger NextRound

**Transaction steps:**

1. Attacker (Miner A) creates malicious `NextRoundInput`:
   ```
   Round with RealTimeMinersInformation:
   - Miner A: FinalOrderOfNextRound = 1, OutValue = Hash("A")
   - Miner B: FinalOrderOfNextRound = 2, OutValue = Hash("B")  
   - Miner C: FinalOrderOfNextRound = 2, OutValue = Hash("C")  // DUPLICATE order
   - Miner D: FinalOrderOfNextRound = 0, OutValue = null
   - Miner E: FinalOrderOfNextRound = 0, OutValue = null
   ```

2. Submit NextRound transaction with malicious round data

3. Validation executes:
   ```
   distinctCount = [MinerA, MinerB, MinerC].Distinct().Count() = 3
   minersWhoMined = 3
   Validation passes (3 == 3) âŒ INCORRECT - should detect duplicate order value 2
   ```

4. `GenerateNextRoundInformation` processes the data:
   - Miner B and Miner C both get `Order = 2` in next round
   - Both assigned `ExpectedMiningTime` for position 2

**Expected vs actual result:**

Expected: Validation should reject the round data with error "Invalid FinalOrderOfNextRound: duplicate orders"

Actual: Validation passes, next round created with Miners B and C both having `Order = 2`

**Success condition:** 
Next round queries like `FirstOrDefault(m => m.Order == 2)` return arbitrary results, and consensus logic breaks when trying to enforce unique order-based scheduling.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L61-65)
```csharp
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-90)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-40)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```
