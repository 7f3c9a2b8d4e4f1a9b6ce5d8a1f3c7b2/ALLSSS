### Title
Malicious Contract Address Bypass in ChangeMethodFeeController Enables Permanent Governance Takeover

### Summary
The `ChangeMethodFeeController` function validates the input `AuthorityInfo` by calling `ValidateOrganizationExist` on a user-controlled contract address. An attacker can deploy a malicious contract that always returns `true` for this validation, bypass the organization existence check, and establish permanent unilateral control over method fees without proper multi-signature governance oversight.

### Finding Description

The vulnerability exists in the `CheckOrganizationExist` method which is called during `ChangeMethodFeeController` execution: [1](#0-0) 

The root cause is that `authorityInfo.ContractAddress` is user-controlled input, yet the code blindly trusts it to provide honest validation. The method calls `Context.Call` on this address without verifying it's a legitimate system contract (Parliament, Association, or Referendum).

**Attack Execution Path:**

1. **Initial Authorization**: The function requires the sender to be the current `MethodFeeController.OwnerAddress`: [2](#0-1) 

2. **Validation Bypass**: When a Parliament proposal calls this function with malicious input:
   - `input.ContractAddress` = attacker's deployed malicious contract
   - `input.OwnerAddress` = attacker's controlled address
   
   The validation at line 26-27 calls the malicious contract which returns `true`, bypassing the intended organization existence check.

3. **Permanent Control**: Once the malicious `AuthorityInfo` is stored, the attacker gains permanent control because `SetMethodFee` only checks: [3](#0-2) 

**Why Existing Protections Fail:**

Legitimate authorization contracts implement `ValidateOrganizationExist` by checking state storage: [4](#0-3) 

However, there is no validation that `input.ContractAddress` is actually a legitimate system contract. An attacker can deploy a contract with a `ValidateOrganizationExist` method that simply returns `new BoolValue { Value = true }` regardless of input.

### Impact Explanation

**Governance Destruction:**
- After one successful malicious proposal, the attacker establishes **permanent unilateral control** over all method fees
- No multi-signature governance required for subsequent fee changes
- Violates the critical invariant that "method-fee provider authority" must follow proper organizational governance

**Economic Manipulation:**
- Attacker can set method fees to `0`, breaking the economic model and enabling spam attacks
- Attacker can set fees to maximum values (e.g., `long.MaxValue`), creating a DoS condition where legitimate users cannot afford transactions
- Fee revenue meant for the protocol is subverted

**No Recovery Mechanism:**
- The malicious controller can call `ChangeMethodFeeController` to prevent replacement: [2](#0-1) 
- Only the current `MethodFeeController.OwnerAddress` can change the controller
- Once set to the attacker's address, governance is permanently lost

**Affected Parties:**
- All users of the Vote contract who must pay method fees
- The protocol's economic integrity
- Governance participants whose multi-sig approvals are circumvented

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Deploy a malicious contract (standard user capability on AElf)
2. Craft and submit a Parliament proposal (requires proposal deposit)
3. Social engineer or compromise Parliament to pass one malicious proposal

**Attack Complexity:**
- Low technical complexity: malicious contract is trivial (single method returning `true`)
- Medium social complexity: requires passing one Parliament proposal
- High impact-to-effort ratio: one proposal grants permanent control

**Feasibility Conditions:**
- Parliament governance can be compromised through:
  - Social engineering of parliament members
  - Compromise of member accounts
  - Disguising malicious parameters in complex proposals
  - Exploiting parliament member inattention during routine proposals

**Detection/Operational Constraints:**
- No on-chain mechanism to detect malicious controller contracts
- The malicious `AuthorityInfo` appears valid until analyzed
- Post-exploitation, the attacker's control is legitimate from the contract's perspective

**Probability Assessment:**
While requiring Parliament compromise is significant, the validation is meant to be **defense-in-depth** against exactly this scenario. The check exists to prevent invalid controllers even when governance is compromised. Once exploited, the impact is permanent and unrecoverable, making this a critical security boundary failure.

### Recommendation

**Immediate Fix:**

Add whitelist validation to ensure `ContractAddress` is a legitimate system contract:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a known system contract
    Assert(
        authorityInfo.ContractAddress == State.ParliamentContract.Value ||
        authorityInfo.ContractAddress == Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName) ||
        authorityInfo.ContractAddress == Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName),
        "Invalid authority contract address."
    );
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Additional Invariant Checks:**

1. Add a view function to verify current controller integrity:
```csharp
public override BoolValue ValidateMethodFeeController(Empty input)
{
    var controller = State.MethodFeeController.Value;
    return new BoolValue { Value = CheckOrganizationExist(controller) };
}
```

2. Add event emission when controller changes for monitoring:
```csharp
Context.Fire(new MethodFeeControllerChanged
{
    OldController = State.MethodFeeController.Value,
    NewController = input
});
```

**Test Cases to Prevent Regression:**

1. Test that `ChangeMethodFeeController` rejects non-system contract addresses
2. Test that only Parliament/Association/Referendum contracts are accepted
3. Test that malicious contracts cannot bypass validation
4. Integration test verifying controller change requires valid organization

### Proof of Concept

**Required Initial State:**
- Vote contract deployed with default Parliament controller
- Attacker has deployed malicious contract `MaliciousValidator` at address `0xMALICIOUS`

**Malicious Contract Code:**
```csharp
public class MaliciousValidator : ContractBase
{
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = true }; // Always returns true
    }
}
```

**Attack Transaction Steps:**

1. **Create Parliament Proposal:**
   ```
   Parliament.CreateProposal({
     ToAddress: VoteContract,
     MethodName: "ChangeMethodFeeController",
     Params: AuthorityInfo {
       ContractAddress: 0xMALICIOUS,
       OwnerAddress: 0xATTACKER
     }
   })
   ```

2. **Parliament Approves Proposal** (via social engineering/compromise)

3. **Release Proposal:**
   ```
   Parliament.Release(proposalId)
   ```

4. **Verify Malicious Controller Set:**
   ```
   VoteContract.GetMethodFeeController() 
   // Returns: { ContractAddress: 0xMALICIOUS, OwnerAddress: 0xATTACKER }
   ```

5. **Attacker Directly Sets Arbitrary Fees:**
   ```
   From: 0xATTACKER
   VoteContract.SetMethodFee({
     MethodName: "Register",
     Fees: [{ Symbol: "ELF", BasicFee: 0 }]
   })
   // SUCCESS - No governance approval needed
   ```

**Expected vs Actual Result:**
- **Expected**: `ChangeMethodFeeController` should reject malicious contract address with "Invalid authority input"
- **Actual**: Malicious `AuthorityInfo` is accepted; attacker gains permanent control

**Success Condition:** 
Attacker can call `SetMethodFee` directly without Parliament approval, and fees are permanently controllable by attacker's address while legitimate governance is locked out.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L92-97)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```
