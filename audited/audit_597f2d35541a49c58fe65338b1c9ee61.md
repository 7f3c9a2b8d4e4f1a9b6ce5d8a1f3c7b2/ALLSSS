### Title
Evil Miner Detection Bypass via Unvalidated MissedTimeSlots Manipulation in NextRound Transaction

### Summary
The `ProcessNextRound()` function stores the `NextRoundInput` data directly to state without validating the correctness of `MissedTimeSlots` values. A malicious miner acting as extra block producer can manipulate their own `MissedTimeSlots` counter in the submitted `NextRoundInput`, causing the manipulated data to be stored and later used for evil miner detection, allowing them to bypass the threshold check and avoid being marked as an evil node.

### Finding Description

The vulnerability exists in the round transition flow where evil miner detection occurs: [1](#0-0) 

**Root Cause:**

The `ProcessNextRound()` function retrieves `currentRound` from state at line 114 and performs evil miner detection at line 140. However, the `nextRound` (derived from the user-provided `NextRoundInput` at line 110) is stored to state at line 156 WITHOUT validating that the `MissedTimeSlots` values are correct. [2](#0-1) 

The detection logic simply checks if `MissedTimeSlots >= TolerableMissedTimeSlotsCount` (4320): [3](#0-2) 

**Why Protections Fail:**

1. **Validation Before Execution:** The `ValidateBeforeExecution` function adds validation providers for NextRound behavior: [4](#0-3) 

However, `NextRoundMiningOrderValidationProvider` only validates `FinalOrderOfNextRound`: [5](#0-4) 

And `RoundTerminateValidationProvider` only validates round number and InValue fields: [6](#0-5) 

Neither validates `MissedTimeSlots` correctness.

2. **Validation After Execution:** The `ValidateConsensusAfterExecution` compares the round hash from the header with the round hash from state after execution: [7](#0-6) 

However, since `ProcessNextRound` already stored the manipulated round to state, both the header round and state round contain the same manipulated data, causing the hashes to match.

3. **Data Structure:** The `NextRoundInput` includes full `RealTimeMinersInformation` containing all `MissedTimeSlots`: [8](#0-7) [9](#0-8) 

**Relevant Execution Path:**

1. Miner calls `GenerateConsensusTransactions` (off-chain view) to generate the correct NextRound transaction: [10](#0-9) 

2. The correct `NextRoundInput` is generated via `GenerateNextRoundInformation`, which correctly increments `MissedTimeSlots` for miners who didn't mine: [11](#0-10) 

3. Malicious miner modifies the `NextRoundInput.RealTimeMinersInformation[their_pubkey].missed_time_slots` to a lower value before submitting the transaction.

4. Transaction passes validation and executes, storing manipulated data to state.

5. In the next round transition, evil detection checks the manipulated `currentRound` and fails to detect the evil miner.

### Impact Explanation

**Concrete Impact:**
- Evil miners with accumulated `MissedTimeSlots` approaching the threshold (4320) can reset or reduce their counter, delaying or completely avoiding being marked as evil nodes.
- The evil node flag triggers updates to the Election Contract: [12](#0-11) 

- By avoiding this flag, malicious miners can continue participating in consensus, producing blocks, and earning rewards despite consistently poor performance (missing time slots).

**Who Is Affected:**
- The entire network suffers from reduced consensus reliability
- Honest miners bear increased burden when evil miners fail to produce blocks
- Token holders experience degraded network performance

**Severity Justification:**
- **HIGH**: Violates critical consensus integrity invariant. Allows miners who should be removed to continue participating in block production, directly undermining the consensus mechanism's ability to maintain a reliable miner set. The 3-day tolerance window (4320 time slots) is completely bypassed.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a current miner with accumulated high `MissedTimeSlots`
- Must be selected as extra block producer (determined by signature-based randomness, not MissedTimeSlots) [13](#0-12) 

**Attack Complexity:**
- LOW: Attacker simply modifies a single field in the transaction data before submission
- No complex timing or race conditions required
- No need to compromise other components

**Feasibility Conditions:**
- Attacker must eventually become extra block producer (probability increases with time)
- Can be executed repeatedly each time they become extra block producer
- No economic cost beyond normal transaction fees

**Detection/Operational Constraints:**
- Manipulation occurs in transaction data, not easily detectable without comparing expected vs actual values
- Once stored to state, becomes the canonical source of truth
- No audit trail to reveal the discrepancy

**Probability:**
- **MEDIUM-HIGH**: While requiring the attacker to be selected as extra block producer, this will eventually occur given sufficient time. The manipulation itself is trivial and undetectable.

### Recommendation

**Exact Code-Level Mitigation:**

Add a new validation provider `MissedTimeSlotsValidationProvider` to the validation chain:

```csharp
// In AEDPoSContract_Validation.cs, line 84-88
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new MissedTimeSlotsValidationProvider()); // NEW
    break;
```

**Invariant Check to Add:**

Create `MissedTimeSlotsValidationProvider.cs`:
```csharp
public class MissedTimeSlotsValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var baseRound = validationContext.BaseRound;
        var nextRound = validationContext.ExtraData.Round;
        
        // For each miner in next round, validate MissedTimeSlots
        foreach (var minerInNextRound in nextRound.RealTimeMinersInformation)
        {
            var pubkey = minerInNextRound.Key;
            if (!baseRound.RealTimeMinersInformation.ContainsKey(pubkey))
                continue; // New miner, skip validation
                
            var currentMiner = baseRound.RealTimeMinersInformation[pubkey];
            var nextMiner = minerInNextRound.Value;
            
            // If miner produced blocks in current round (OutValue != null), 
            // MissedTimeSlots should remain the same
            // Otherwise, it should increment by 1
            var expectedMissedTimeSlots = currentMiner.OutValue != null 
                ? currentMiner.MissedTimeSlots 
                : currentMiner.MissedTimeSlots + 1;
                
            if (nextMiner.MissedTimeSlots != expectedMissedTimeSlots)
            {
                return new ValidationResult 
                { 
                    Message = $"Invalid MissedTimeSlots for miner {pubkey}. " +
                              $"Expected: {expectedMissedTimeSlots}, Got: {nextMiner.MissedTimeSlots}" 
                };
            }
        }
        
        return new ValidationResult { Success = true };
    }
}
```

**Test Cases to Prevent Regression:**

1. Test that NextRound transaction with manipulated MissedTimeSlots is rejected
2. Test that correct MissedTimeSlots increment for miners who didn't mine
3. Test that MissedTimeSlots remains unchanged for miners who mined
4. Test that new miners (replacements) are handled correctly

### Proof of Concept

**Required Initial State:**
- Evil miner is in the current miner list with `MissedTimeSlots = 4000` (approaching threshold 4320)
- Evil miner is selected as extra block producer for current round
- Round transition from round N to round N+1 is triggered

**Transaction Steps:**

1. **Legitimate Flow (Expected):**
   - Evil miner calls `GetConsensusExtraData` to generate correct NextRoundInput
   - Correct NextRoundInput has evil miner's `MissedTimeSlots = 4001` (incremented because they didn't mine consistently)
   - Submit transaction → Evil detection in future rounds catches threshold

2. **Attack Flow (Actual):**
   - Evil miner calls `GetConsensusExtraData` to generate NextRoundInput
   - Evil miner modifies `NextRoundInput.RealTimeMinersInformation["evil_miner_pubkey"].missed_time_slots = 3000`
   - Evil miner submits modified NextRound transaction
   - `ValidateConsensusBeforeExecution` passes (no MissedTimeSlots validation)
   - `ProcessNextRound` executes:
     - Line 114: Gets round N from state (with real MissedTimeSlots = 4000)
     - Line 140: Checks if 4000 >= 4320 → FALSE, not detected
     - Line 156: Stores manipulated round N+1 with MissedTimeSlots = 3000
   - `ValidateConsensusAfterExecution` passes (both header and state have same manipulated data)
   - Round N+1 becomes current with manipulated MissedTimeSlots = 3000

3. **Subsequent Rounds:**
   - Round N+1 → N+2 transition checks round N+1
   - Evil detection evaluates: MissedTimeSlots = 3000 < 4320 → NOT DETECTED
   - Evil miner continues participating, having bypassed 1000+ time slots worth of detection

**Success Condition:**
Evil miner with legitimately high `MissedTimeSlots` (≥4000) successfully resets their counter to below 4000, avoiding immediate evil node detection and extending their participation window by hundreds or thousands of additional time slots.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-127)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L130-183)
```csharp
    private TransactionList GenerateTransactionListByExtraData(AElfConsensusHeaderInformation consensusInformation,
        ByteString pubkey, ByteString randomNumber)
    {
        var round = consensusInformation.Round;
        var behaviour = consensusInformation.Behaviour;
        switch (behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                Context.LogDebug(() =>
                    $"Previous in value in extra data:{round.RealTimeMinersInformation[pubkey.ToHex()].PreviousInValue}");
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
                };
            case AElfConsensusBehaviour.TinyBlock:
                var minerInRound = round.RealTimeMinersInformation[pubkey.ToHex()];
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(UpdateTinyBlockInformation),
                            new TinyBlockInput
                            {
                                ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
                                ProducedBlocks = minerInRound.ProducedBlocks,
                                RoundId = round.RoundIdForValidation,
                                RandomNumber = randomNumber
                            })
                    }
                };
            case AElfConsensusBehaviour.NextRound:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextRound), NextRoundInput.Create(round,randomNumber))
                    }
                };
            case AElfConsensusBehaviour.NextTerm:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextTerm), NextTermInput.Create(round,randomNumber))
                    }
                };
            default:
                return new TransactionList();
        }
    }
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** protobuf/aedpos_contract.proto (L458-481)
```text
message NextRoundInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producers’ expecting time (second).
    int64 round_id_for_validation = 10;
    // The random number.
    bytes random_number = 11;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L39-56)
```csharp
        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```
