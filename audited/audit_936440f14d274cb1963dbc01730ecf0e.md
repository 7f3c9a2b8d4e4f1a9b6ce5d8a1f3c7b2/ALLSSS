# Audit Report

## Title
Quadratic Voting Cost Progression Broken for Locked Token Voting

## Summary
The Vote contract's quadratic voting implementation fails to enforce progressive cost increases when `IsLockToken` is true. Each vote generates a unique `VoteId` based on the accumulating `VotesAmount`, causing the `QuadraticVotesCountMap` tracking to always start at zero for each vote. This results in constant cost (`TicketCost * 1`) instead of the intended quadratic progression (`TicketCost * 1, 2, 3...`), completely defeating quadratic voting's vote-buying resistance.

## Finding Description

The vulnerability exists in the interaction between VoteId generation and quadratic cost tracking:

**Root Cause:**

For locked token voting (`IsLockToken=true`), the `VoteId` is generated using the current `VotesAmount` from the voting result: [1](#0-0) 

Since `VotesAmount` increases with each vote, every vote generates a unique `VoteId`. The quadratic cost calculation uses this `VoteId` as the key in `QuadraticVotesCountMap`: [2](#0-1) 

The map structure is: [3](#0-2) 

**Execution Flow:**

1. **First vote by voter A:**
   - `votingResult.VotesAmount = 0` (initial)
   - `VoteId = GenerateId(Self, 0.ToBytes())` → UniqueID_1
   - `QuadraticVotesCountMap[UniqueID_1]` defaults to 0
   - `currentVotesCount = 0 + 1 = 1`
   - `amount = TicketCost * 1`
   - `votingResult.VotesAmount` updated to `TicketCost`

2. **Second vote by voter A:**
   - `votingResult.VotesAmount = TicketCost` (from first vote)
   - `VoteId = GenerateId(Self, TicketCost.ToBytes())` → UniqueID_2 (DIFFERENT!)
   - `QuadraticVotesCountMap[UniqueID_2]` defaults to 0 (NEW KEY!)
   - `currentVotesCount = 0 + 1 = 1` (SAME AS FIRST!)
   - `amount = TicketCost * 1` (NO INCREASE!)

3. **Subsequent votes:** Pattern continues - each vote costs `TicketCost * 1`

**Why Protections Fail:**

The `Register` method accepts both `IsQuadratic` and `IsLockToken` flags without validation: [4](#0-3) 

The validation function `AssertValidNewVotingItem` does not check for incompatible flag combinations: [5](#0-4) 

**Contrast with Delegated Voting:**

For delegated voting (`IsLockToken=false`), the sponsor provides the `VoteId` in the input, allowing potential reuse: [6](#0-5) 

However, this still requires sponsor cooperation and lacks proper per-voter tracking.

## Impact Explanation

**Token Economics Manipulation:**
- Voters acquire unlimited votes at constant cost (`TicketCost` per vote) instead of quadratic cost
- Expected total cost for N votes: `TicketCost * (1+2+...+N) = TicketCost * N(N+1)/2` ≈ O(N²)
- Actual cost: `TicketCost * N` = O(N)

**Quantified Damage:**
For a voter acquiring 100 votes with `TicketCost=1000` tokens:
- **Intended cost:** 1000 × 5050 = 5,050,000 tokens
- **Actual cost:** 1000 × 100 = 100,000 tokens  
- **Savings:** 4,950,000 tokens (98% discount!)

**Governance Integrity Compromise:**
- Wealthy actors can cheaply dominate any voting item created with both flags enabled
- Nullifies quadratic voting's vote-buying resistance
- Honest voters who vote few times pay proportional cost while attackers exploit constant cost

**Protocol Design Violation:**
The feature is labeled "quadratic" but provides no quadratic cost progression, breaking the fundamental security guarantee.

**Severity:** HIGH - Breaks core security property, enables voting manipulation, no special permissions required.

## Likelihood Explanation

**Attacker Capabilities:**
- Any address can call `Register` to create a voting item (public method)
- Any address can call `Vote` to participate (public method)
- No special permissions required

**Attack Complexity:**
- **Trivial:** Two simple transactions:
  1. `Register(IsQuadratic=true, IsLockToken=true, TicketCost=X, ...)`
  2. `Vote(...)` multiple times with same voter
- No sophisticated contract interactions needed
- Attacker controls `TicketCost` parameter

**Feasibility Conditions:**
- ✅ Public methods accessible to all
- ✅ No validation prevents the flag combination  
- ✅ No economic barriers
- ✅ Works in current contract state without preconditions

**Detection:**
- Not easily detectable without analyzing `QuadraticVotesCountMap` state
- Appears as legitimate voting activity
- No on-chain alerts for constant-cost voting in "quadratic" items

**Probability:** VERY HIGH - The vulnerability is exploitable in every voting item where both flags are true. Even unaware sponsors can inadvertently create exploitable voting items.

## Recommendation

**Fix Option 1: Proper Voter Tracking**

Modify the quadratic cost tracking to use voter address instead of VoteId as the key:

```csharp
// In VoteContractState.cs, change:
public MappedState<Hash, Hash, long> QuadraticVotesCountMap { get; set; }
// First Hash = VotingItemId, Second Hash = Voter Address Hash

// In Vote method:
if (votingItem.IsQuadratic)
{
    var voterKey = HashHelper.ComputeFrom(input.Voter);
    var itemVoterKey = HashHelper.ConcatAndCompute(input.VotingItemId, voterKey);
    var currentVotesCount = State.QuadraticVotesCountMap[itemVoterKey].Add(1);
    State.QuadraticVotesCountMap[itemVoterKey] = currentVotesCount;
    amount = votingItem.TicketCost.Mul(currentVotesCount);
}
```

**Fix Option 2: Validation**

Add validation to prevent incompatible flag combinations:

```csharp
// In AssertValidNewVotingItem:
if (input.IsQuadratic && input.IsLockToken)
{
    throw new AssertionException("Quadratic voting with locked tokens is not supported. Use delegated voting (IsLockToken=false) for quadratic voting.");
}
```

**Fix Option 3: Combined Approach**

Implement proper voter tracking (Option 1) for `IsLockToken=true` scenarios, ensuring quadratic cost progression works correctly regardless of VoteId generation method.

## Proof of Concept

```csharp
[Fact]
public async Task QuadraticVoting_LockedToken_ConstantCost_Vulnerability()
{
    // Register a quadratic voting item with locked tokens
    var startTime = TimestampHelper.GetUtcNow();
    var ticketCost = 1000L;
    
    var input = new VotingRegisterInput
    {
        TotalSnapshotNumber = 1,
        EndTimestamp = startTime.AddDays(100),
        StartTimestamp = startTime,
        Options = { "Option1", "Option2" },
        AcceptedCurrency = TestTokenSymbol,
        IsLockToken = true,      // Locked token voting
        IsQuadratic = true,      // Quadratic voting enabled
        TicketCost = ticketCost
    };
    
    var registerResult = await VoteContractStub.Register.SendAsync(input);
    registerResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    input.Options.Clear();
    var votingItemId = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(input), 
        HashHelper.ComputeFrom(DefaultSender)
    );
    
    var voter = Accounts[1];
    
    // First vote - should cost TicketCost * 1 = 1000
    var vote1Result = await Vote(voter.KeyPair, votingItemId, "Option1", 0);
    vote1Result.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var voteIds1 = await GetVoteIds(voter.KeyPair, votingItemId);
    var voteRecord1 = await GetVotingRecord(voteIds1.ActiveVotes.First());
    voteRecord1.Amount.ShouldBe(1000L); // Cost = 1000
    
    // Second vote - should cost TicketCost * 2 = 2000, but actually costs 1000!
    var vote2Result = await Vote(voter.KeyPair, votingItemId, "Option1", 0);
    vote2Result.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var voteIds2 = await GetVoteIds(voter.KeyPair, votingItemId);
    var voteRecord2 = await GetVotingRecord(voteIds2.ActiveVotes.Last());
    
    // VULNERABILITY: Second vote also costs 1000 instead of 2000
    voteRecord2.Amount.ShouldBe(1000L); // BUG: Still 1000, should be 2000!
    
    // Third vote - should cost TicketCost * 3 = 3000, but actually costs 1000!
    var vote3Result = await Vote(voter.KeyPair, votingItemId, "Option1", 0);
    vote3Result.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var voteIds3 = await GetVoteIds(voter.KeyPair, votingItemId);
    var voteRecord3 = await GetVotingRecord(voteIds3.ActiveVotes.Last());
    
    // VULNERABILITY: Third vote also costs 1000 instead of 3000
    voteRecord3.Amount.ShouldBe(1000L); // BUG: Still 1000, should be 3000!
    
    // Total cost for 3 votes: 3000 tokens
    // Expected quadratic cost: 1000 + 2000 + 3000 = 6000 tokens
    // Savings: 3000 tokens (50% discount for just 3 votes)
}
```

**Notes:**
- This vulnerability affects the core economic mechanism of quadratic voting in the AElf Vote contract
- The issue arises from using an accumulating value (`VotesAmount`) to generate unique VoteIds, which breaks the per-voter cost tracking
- The vulnerability is immediately exploitable on any voting item created with both `IsQuadratic=true` and `IsLockToken=true`
- The fix requires either proper voter-level tracking or explicit validation to prevent the incompatible flag combination

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L42-51)
```csharp
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L98-103)
```csharp
        else
        {
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-365)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L390-398)
```csharp
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L30-33)
```csharp
    /// <summary>
    ///     Vote Id -> Votes Count
    /// </summary>
    public MappedState<Hash, long> QuadraticVotesCountMap { get; set; }
```
