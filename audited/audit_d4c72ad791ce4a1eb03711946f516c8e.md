# Audit Report

## Title
RemoveSubScheme Fails to Update CachedDelayTotalShares, Causing Profit Dilution in Delayed Distribution Schemes

## Summary
The `RemoveSubScheme` function in the Profit contract fails to update `CachedDelayTotalShares` when removing sub-schemes from schemes with delayed distribution enabled (`DelayDistributePeriodCount > 0`), unlike `RemoveBeneficiary` which correctly handles both `TotalShares` and `CachedDelayTotalShares`. This causes future profit distributions to use inflated share counts, permanently diluting rewards for all legitimate beneficiaries.

## Finding Description
When a profit scheme has delayed distribution enabled, the system caches total shares for future periods to ensure distribution fairness. The vulnerability arises from an implementation inconsistency between two removal functions:

**RemoveSubScheme Implementation** (missing cache update): [1](#0-0) 

The function reduces `TotalShares` at line 152 but does NOT update the `CachedDelayTotalShares` map that stores share counts for future delayed distribution periods.

**RemoveBeneficiary Implementation** (correct cache update): [2](#0-1) 

In contrast, `RemoveBeneficiary` properly iterates through all cached delay periods and subtracts the removed shares from `CachedDelayTotalShares`.

**Delayed Distribution Mechanism:** [3](#0-2) 

When distributing profits with delay enabled, line 466 caches the current `TotalShares` for a future period. Lines 467-475 then use the cached value for the current period's distribution if available.

**Attack Scenario:**
1. A scheme is created with `DelayDistributePeriodCount = D`
2. A sub-scheme is added via `AddSubScheme`, increasing `TotalShares` from T to T+N
3. `DistributeProfits` is called at period P, caching `CachedDelayTotalShares[P+D] = T+N`
4. `RemoveSubScheme` is called, reducing `TotalShares` back to T, but leaving `CachedDelayTotalShares[P+D] = T+N`
5. `DistributeProfits` is called at period P+D, using the stale cached value T+N instead of T
6. All beneficiaries receive `amount * shares / (T+N)` instead of `amount * shares / T`, a ~N/(T+N) dilution

## Impact Explanation
This vulnerability causes **permanent loss of entitled profits** for all legitimate beneficiaries in affected schemes:

**Direct Fund Impact:** When distributing profits in delayed periods, the inflated denominator causes each beneficiary to receive less than their fair share. For example, if `TotalShares = 1000` and a sub-scheme with 500 shares is removed, but `CachedDelayTotalShares` remains 1500, each beneficiary receives only 66.7% (1000/1500) of their entitled amount. The remaining 33.3% stays permanently locked in the scheme's virtual address.

**Production Impact:** The Treasury contract, a critical system component, is directly affected: [4](#0-3) 

The "Welfare" scheme (index 3) is created with `DelayDistributePeriodCount = 1`, and `RemoveSubScheme` is actively called in production code: [5](#0-4) [6](#0-5) 

These operations in `UpdateWelcomeRewardWeights` and `UpdateFlexibleRewardWeights` trigger the vulnerability during normal Treasury operations.

**Affected Parties:** All voters, miners, and citizens entitled to Treasury rewards, as well as any other schemes using delayed distribution with dynamic sub-scheme management.

## Likelihood Explanation
**Likelihood: HIGH**

**Operational Trigger:** This is not a malicious attack scenario but a bug triggered by normal operational behavior. Treasury administrators routinely adjust reward weights using the `ResetWeight` function: [7](#0-6) 

Every weight adjustment that involves removing and re-adding sub-schemes triggers this vulnerability.

**No Special Privileges Required:** The vulnerability only requires scheme manager privileges, which are intended for normal scheme administration. It occurs during legitimate operational activities without requiring any attack or privilege escalation.

**Real-world Frequency:** The Treasury contract adjusts weights through governance proposals in response to changing economic conditions, making this a recurring operational pattern. Each adjustment to schemes with delayed distribution triggers the bug.

**Detection Difficulty:** The bug manifests as subtle profit shortfalls in future periods, making it difficult to detect without careful comparison of expected vs. actual distributions. The "missing" profits accumulate silently in virtual addresses.

## Recommendation
Update the `RemoveSubScheme` function to mirror the `RemoveBeneficiary` implementation by adding the same cache update logic. After line 152 where `TotalShares` is reduced, add:

```csharp
// Update cached delay total shares (mirror RemoveBeneficiary logic)
if (scheme.DelayDistributePeriodCount > 0)
{
    var removedShares = shares.Shares;
    var currentPeriod = scheme.CurrentPeriod;
    
    for (var removedPeriod = currentPeriod;
         removedPeriod < currentPeriod.Add(scheme.DelayDistributePeriodCount);
         removedPeriod++)
    {
        if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
        {
            scheme.CachedDelayTotalShares[removedPeriod] =
                scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
        }
    }
}
```

This ensures that when a sub-scheme is removed, all cached future periods are adjusted to reflect the reduced share count, maintaining consistency with the `RemoveBeneficiary` behavior.

## Proof of Concept
The following test demonstrates the vulnerability by showing that `CachedDelayTotalShares` is not updated when `RemoveSubScheme` is called:

```csharp
[Fact]
public async Task RemoveSubScheme_WithDelayDistribution_FailsToUpdateCachedShares_Test()
{
    const int delayDistributePeriodCount = 2;
    const int subSchemeShares = 500;
    const int contributeAmount = 100_000;
    
    var creator = Creators[0];
    var creatorAddress = Address.FromPublicKey(CreatorKeyPair[0].PublicKey);

    // Create parent scheme with delay distribution
    await creator.CreateScheme.SendAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true,
        DelayDistributePeriodCount = delayDistributePeriodCount,
        ProfitReceivingDuePeriodCount = 100
    });

    var parentSchemeId = (await creator.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = creatorAddress })).SchemeIds.First();

    // Create sub-scheme
    var subSchemeId = await CreateSchemeAsync(1);

    // Add sub-scheme
    await creator.AddSubScheme.SendAsync(new AddSubSchemeInput
    {
        SchemeId = parentSchemeId,
        SubSchemeId = subSchemeId,
        SubSchemeShares = subSchemeShares
    });

    // Initial state: TotalShares = 500
    var schemeBeforeDistribute = await creator.GetScheme.CallAsync(parentSchemeId);
    schemeBeforeDistribute.TotalShares.ShouldBe(subSchemeShares);

    // Distribute at period 1 - this caches shares for period 3
    await ContributeAndDistribute(creator, contributeAmount, 1);

    var schemeAfterDistribute = await creator.GetScheme.CallAsync(parentSchemeId);
    // Cached value for period 3 should be 500
    schemeAfterDistribute.CachedDelayTotalShares[3].ShouldBe(subSchemeShares);

    // Remove sub-scheme - THIS IS THE BUG
    await creator.RemoveSubScheme.SendAsync(new RemoveSubSchemeInput
    {
        SchemeId = parentSchemeId,
        SubSchemeId = subSchemeId
    });

    var schemeAfterRemove = await creator.GetScheme.CallAsync(parentSchemeId);
    
    // TotalShares is correctly updated to 0
    schemeAfterRemove.TotalShares.ShouldBe(0);
    
    // BUG: CachedDelayTotalShares[3] should also be 0, but remains 500
    // This will fail, proving the vulnerability:
    schemeAfterRemove.CachedDelayTotalShares[3].ShouldBe(0); // FAILS - actually 500
    
    // This proves that future distributions at period 3 will use
    // the inflated share count of 500 instead of 0, diluting all profits
}
```

This test proves that after removing a sub-scheme, `TotalShares` is correctly reduced to 0, but `CachedDelayTotalShares[3]` incorrectly remains at 500, causing future period 3 distributions to use an inflated denominator.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L131-156)
```csharp
    public override Empty RemoveSubScheme(RemoveSubSchemeInput input)
    {
        Assert(input.SchemeId != input.SubSchemeId, "Two schemes cannot be same.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only manager can remove sub-scheme.");

        var shares = scheme.SubSchemes.SingleOrDefault(d => d.SchemeId == input.SubSchemeId);
        if (shares == null) return new Empty();

        var subSchemeId = input.SubSchemeId;
        var subScheme = State.SchemeInfos[subSchemeId];
        Assert(subScheme != null, "Sub scheme not found.");

        var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
        // Remove profit details
        State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
        scheme.SubSchemes.Remove(shares);
        scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L243-258)
```csharp
        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L64-64)
```csharp
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L520-540)
```csharp
    private void ResetWeight(Hash parentSchemeId, Hash subSchemeId, int oldWeight,
        int newWeight)
    {
        if (oldWeight == newWeight)
            return;

        // old weight equals 0 indicates the subScheme has not been registered
        if (oldWeight > 0)
            State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
            {
                SchemeId = parentSchemeId,
                SubSchemeId = subSchemeId
            });

        State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
        {
            SchemeId = parentSchemeId,
            SubSchemeId = subSchemeId,
            SubSchemeShares = newWeight
        });
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L858-862)
```csharp
        State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            SubSchemeId = State.BasicRewardHash.Value
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L895-904)
```csharp
        State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
        {
            SchemeId = State.ReElectionRewardHash.Value,
            SubSchemeId = State.WelfareHash.Value
        });
        State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
        {
            SchemeId = State.ReElectionRewardHash.Value,
            SubSchemeId = State.BasicRewardHash.Value
        });
```
