# Audit Report

## Title
Round 1 ActualMiningTime Manipulation Allows Consensus Time Slot Bypass

## Summary
A malicious first miner in Round 1 can manipulate the consensus time reference by providing a fabricated `ActualMiningTime` in their `UpdateValue` transaction that differs from the block header's `Context.CurrentBlockTime`. This manipulation bypasses validation and affects subsequent miners' time slot calculations, enabling out-of-order block production.

## Finding Description

The AEDPoS consensus contract maintains two separate sources for `ActualMiningTime` values that are never validated against each other:

1. **Block Header ActualMiningTime**: Generated during consensus extra data creation, set to `Context.CurrentBlockTime` [1](#0-0) 

2. **Transaction ActualMiningTime**: Provided as a field in `UpdateValueInput` and directly stored to state [2](#0-1) 

The expected flow is that transactions are generated via `ExtractInformationToUpdateConsensus`, which extracts `ActualMiningTime` from the header's Round [3](#0-2) . However, since `UpdateValue` is a public method [4](#0-3) , malicious miners can manually craft transactions with arbitrary `ActualMiningTime` values.

**Validation Gaps:**

The vulnerability exploits multiple validation bypasses specific to Round 1:

1. **Time slot validation disabled**: `CheckMinerTimeSlot` returns `true` immediately for the first round of any term [5](#0-4) 

2. **ActualMiningTimes excluded from integrity checks**: The round hash calculation explicitly clears `ActualMiningTimes` before computing the hash [6](#0-5) , so post-execution validation cannot detect the discrepancy [7](#0-6) 

3. **No cross-validation**: No code path validates that the transaction's `ActualMiningTime` matches the header's `Context.CurrentBlockTime`

**Attack Propagation:**

In Round 1, `IsTimeSlotPassed()` relies exclusively on the first miner's `ActualMiningTimes` to calculate which mining orders should be active [8](#0-7) . This manipulated timestamp directly affects consensus behavior decisions via `ConsensusBehaviourProviderBase`, determining whether miners can produce `TinyBlock`s or should terminate [9](#0-8)  and [10](#0-9)  and [11](#0-10) .

## Impact Explanation

**HIGH Severity - Consensus Integrity Violation**

This vulnerability breaks the fundamental consensus invariant of sequential, time-based block production:

1. **Premature Time Slot Activation**: Setting `ActualMiningTime` 300 seconds earlier causes the calculation `expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1)` to return inflated values, making higher-order miners believe their slots have passed prematurely and produce blocks out of sequence.

2. **Blockchain Start Timestamp Corruption**: The blockchain start timestamp is derived from the first miner's `ActualMiningTime` during `ProcessNextRound` [12](#0-11) , meaning manipulation affects all subsequent term timing calculations and consensus schedules.

3. **Delayed Time Slot Activation**: Conversely, setting a later timestamp prevents legitimate miners from recognizing their turns, causing missed blocks and chain availability issues.

The impact is consensus-level manipulation affecting all miners in Round 1, with cascading effects on term timing.

## Likelihood Explanation

**HIGH Likelihood**

**Attacker Requirements:**
- Must be the first miner (Order == 1) in Round 1 of any term
- Requires only standard miner permissions

**Attack Complexity:** LOW
1. Generate block with legitimate header containing honest `Context.CurrentBlockTime`
2. Craft `UpdateValue` transaction with manipulated `ActualMiningTime` (e.g., `Context.CurrentBlockTime - 300 seconds`)
3. Include transaction in block

**No Protections:**
- Round 1 time slot validation bypassed by design
- No validation that transaction `ActualMiningTime` matches header timestamp
- `ActualMiningTimes` excluded from post-execution hash verification
- Public entry point accessible to all miners

**Attack Surface:** Every term initialization (Round 1 of each term) presents an opportunity for exploitation.

## Recommendation

Add explicit validation in `ProcessUpdateValue` to ensure the transaction's `ActualMiningTime` matches `Context.CurrentBlockTime`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // Validate ActualMiningTime matches block time
    Assert(updateValueInput.ActualMiningTime == Context.CurrentBlockTime,
        "ActualMiningTime must match block timestamp.");
    
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
    // ... rest of method
}
```

Additionally, consider including `ActualMiningTimes` in the round hash calculation for Round 1, or implement special validation for the first miner's initial timestamp.

## Proof of Concept

```csharp
[Fact]
public async Task Round1_ActualMiningTimeManipulation_Test()
{
    // Setup: Initialize consensus with first round
    var initialMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensusAsync(initialMiners);
    
    // Attacker: First miner in Round 1
    var firstMiner = initialMiners[0];
    var currentTime = TimestampHelper.GetUtcNow();
    
    // Step 1: Generate block header with honest Context.CurrentBlockTime
    var consensusExtraData = await GetConsensusExtraDataAsync(firstMiner, currentTime);
    
    // Step 2: Craft malicious UpdateValue transaction with manipulated timestamp
    var manipulatedTime = currentTime.AddSeconds(-300); // 300 seconds earlier
    var maliciousUpdateInput = new UpdateValueInput
    {
        ActualMiningTime = manipulatedTime, // Manipulated!
        OutValue = consensusExtraData.OutValue,
        Signature = consensusExtraData.Signature,
        // ... other fields
    };
    
    // Step 3: Submit malicious transaction (should succeed due to Round 1 bypass)
    var result = await ExecuteUpdateValueAsync(firstMiner, maliciousUpdateInput);
    result.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 4: Verify manipulation affected consensus state
    var round = await GetCurrentRoundAsync();
    var storedTime = round.RealTimeMinersInformation[firstMiner].ActualMiningTimes.Last();
    storedTime.ShouldBe(manipulatedTime); // Manipulated time stored!
    storedTime.ShouldNotBe(currentTime); // Does not match actual block time!
    
    // Step 5: Verify IsTimeSlotPassed uses manipulated time
    var miner2Order = round.RealTimeMinersInformation[initialMiners[1]].Order;
    var isSlotPassed = round.IsTimeSlotPassed(initialMiners[1], currentTime);
    
    // Due to manipulated timestamp, miner2's slot appears passed prematurely
    isSlotPassed.ShouldBeTrue(); // Vulnerability: Out-of-order mining enabled
}
```

**Notes:**
- This vulnerability is specific to Round 1 where time slot validation is intentionally disabled
- The lack of cross-validation between block header timestamps and transaction timestamps creates a trust boundary violation
- The exclusion of `ActualMiningTimes` from round hash validation prevents detection during post-execution checks
- Impact is amplified by the fact that Round 1 establishes the blockchain start timestamp used for all subsequent consensus timing

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L62-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L120-123)
```csharp
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L42-42)
```csharp
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-98)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L39-39)
```csharp
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L92-98)
```csharp
        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L193-193)
```csharp
            checkableMinerInRound.ActualMiningTimes.Clear();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L35-35)
```csharp
            _isTimeSlotPassed = CurrentRound.IsTimeSlotPassed(_pubkey, _currentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L57-57)
```csharp
            else if (!_isTimeSlotPassed
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L114-114)
```csharp
            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
```
