# Audit Report

## Title
Missing Future Height Validation in Cross-Chain Parent Height Binding Allows Permanent DoS of Cross-Chain Indexing

## Summary
The cross-chain indexing validation logic in `ValidateParentChainBlockData()` and `BindParentChainHeight()` fails to verify that child chain heights in `IndexedMerklePath` are at or below the current block height. This missing validation allows future heights to be pre-bound with arbitrary merkle paths, permanently blocking legitimate cross-chain indexing when those heights are reached.

## Finding Description

The vulnerability exists in the cross-chain indexing flow where parent chain block data is proposed and indexed on the side chain. The `BindParentChainHeight()` function only checks if a binding already exists but never validates that the child height is not in the future. [1](#0-0) 

The validation function `ValidateParentChainBlockData()` checks if heights in `IndexedMerklePath` are already bound but does not validate that these heights represent actual existing blocks on the child chain (i.e., that they are â‰¤ `Context.CurrentHeight`). [2](#0-1) 

When `IndexParentChainBlockData()` processes the data, it iterates through `IndexedMerklePath` and calls `BindParentChainHeight()` for each height without any future height validation. [3](#0-2) 

**Attack Flow:**
1. A miner calls `ProposeCrossChainIndexing()` with `ParentChainBlockData` containing future heights (e.g., height 10000 when current height is 100) in `IndexedMerklePath` [4](#0-3) 
2. The validation passes because it only checks if heights are already bound, not if they're in the future
3. A proposal is created and governance (CrossChainIndexingController) approves it
4. The miner calls `ReleaseCrossChainIndexingProposal()` which triggers `RecordCrossChainData()` [5](#0-4) 
5. The future heights are successfully bound with fake merkle paths
6. When the chain reaches those heights, legitimate cross-chain data fails validation because the heights are already bound

This is a **mis-scoped privilege issue** - the contract should automatically validate that heights are not in the future using `Context.CurrentHeight`, rather than implicitly relying on governance to detect this. Governance is expected to verify parent chain data authenticity, not to check for temporal inconsistencies that the contract can validate itself.

## Impact Explanation

**HIGH Severity - Permanent Cross-Chain Infrastructure Corruption:**

1. **Permanent DoS of Legitimate Indexing**: When the child chain reaches a pre-bound future height, any legitimate parent chain block data containing that height will fail validation because the check in `ValidateParentChainBlockData()` returns false when it finds the height already bound. [2](#0-1)  This permanently blocks cross-chain indexing for those heights with no recovery mechanism.

2. **Cross-Chain Verification Corruption**: The fake merkle path stored at the future height corrupts the cross-chain verification system. When `GetBoundParentChainHeightAndMerklePathByHeight()` is called for that height, it returns the malicious binding. [6](#0-5)  This affects all cross-chain transaction verifications relying on that height data.

3. **No Unbinding Mechanism**: The `BindParentChainHeight()` function strictly asserts that heights cannot be rebound once set, making the corruption irreversible without state migration. [7](#0-6) 

The impact is severe because it permanently corrupts critical cross-chain infrastructure, blocks legitimate operations indefinitely, and compromises the integrity of cross-chain transaction verification.

## Likelihood Explanation

**MEDIUM Likelihood - Mis-Scoped Validation Responsibility:**

While the attack requires both miner permission and governance approval, this is fundamentally a **contract design flaw** rather than a pure governance compromise scenario:

1. **Contract-Level Validation Missing**: The contract has access to `Context.CurrentHeight` and should automatically reject future heights as invalid input. This is a simple bounds check that should not require governance review.

2. **Governance Scope Confusion**: The CrossChainIndexingController is expected to verify that the parent chain data is authentic (matches actual parent chain blocks), not to validate temporal consistency against the current child chain state. Governance could reasonably assume the contract already validates this basic invariant.

3. **Social Engineering Vulnerability**: Even honest governance could be tricked if the proposal is presented as legitimate parent chain data, especially if they lack visibility into which child heights are being bound.

4. **Detection Difficulty**: The malicious bindings are not easily detectable until the chain reaches those heights and legitimate indexing fails, at which point recovery is extremely difficult.

This represents a mis-scoped privilege where validation logic that should be automatic in the contract is implicitly delegated to governance, creating an exploitable gap.

## Recommendation

Add explicit validation to check that child heights in `IndexedMerklePath` are not in the future:

**In `ValidateParentChainBlockData()`**, add a check after line 730:

```csharp
foreach (var blockData in parentChainBlockData)
{
    if (parentChainId != blockData.ChainId || currentHeight + 1 != blockData.Height ||
        blockData.TransactionStatusMerkleTreeRoot == null)
        return false;
    
    // Add this validation:
    if (blockData.IndexedMerklePath.Any(indexedBlockInfo => indexedBlockInfo.Key > Context.CurrentHeight))
        return false;
    
    if (blockData.IndexedMerklePath.Any(indexedBlockInfo =>
            State.ChildHeightToParentChainHeight[indexedBlockInfo.Key] != 0 ||
            State.TxRootMerklePathInParentChain[indexedBlockInfo.Key] != null))
        return false;

    currentHeight += 1;
}
```

Alternatively, add the check directly in `BindParentChainHeight()`:

```csharp
private void BindParentChainHeight(long childHeight, long parentHeight)
{
    Assert(childHeight <= Context.CurrentHeight, 
        "Cannot bind future height - child height must not exceed current block height");
    Assert(State.ChildHeightToParentChainHeight[childHeight] == 0,
        $"Already bound at height {childHeight} with parent chain");
    State.ChildHeightToParentChainHeight[childHeight] = parentHeight;
}
```

This ensures the contract automatically rejects invalid future heights before any proposal is created, eliminating the vulnerability entirely.

## Proof of Concept

The POC would demonstrate:

1. Current chain at height 100
2. Miner proposes `ParentChainBlockData` with `IndexedMerklePath[10000] = FakeMerklePath`
3. `ValidateParentChainBlockData()` returns true (no future height check)
4. After governance approval and release, height 10000 is bound
5. When chain reaches height 10000, legitimate data with height 10000 fails validation
6. `State.ChildHeightToParentChainHeight[10000]` is permanently set and cannot be updated

The vulnerability is confirmed by the absence of any `Context.CurrentHeight` comparison in the validation logic [8](#0-7)  and binding function [1](#0-0) , despite `Context.CurrentHeight` being available and used elsewhere in the contract [9](#0-8) .

## Notes

This vulnerability represents a critical gap in cross-chain indexing validation where the contract fails to enforce basic temporal consistency constraints. The fix is straightforward and should be implemented as a defense-in-depth measure, ensuring that even with governance approval, only valid (non-future) heights can be bound. This aligns with the principle that contract-level invariants should be enforced by the contract itself, not delegated to governance review.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L27-32)
```csharp
    private void BindParentChainHeight(long childHeight, long parentHeight)
    {
        Assert(State.ChildHeightToParentChainHeight[childHeight] == 0,
            $"Already bound at height {childHeight} with parent chain");
        State.ChildHeightToParentChainHeight[childHeight] = parentHeight;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L720-743)
```csharp
    private bool ValidateParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData,
        out Dictionary<int, List<ParentChainBlockData>> validatedParentChainBlockData)
    {
        var parentChainId = State.ParentChainId.Value;
        var currentHeight = State.CurrentParentChainHeight.Value;
        validatedParentChainBlockData = new Dictionary<int, List<ParentChainBlockData>>();
        foreach (var blockData in parentChainBlockData)
        {
            if (parentChainId != blockData.ChainId || currentHeight + 1 != blockData.Height ||
                blockData.TransactionStatusMerkleTreeRoot == null)
                return false;
            if (blockData.IndexedMerklePath.Any(indexedBlockInfo =>
                    State.ChildHeightToParentChainHeight[indexedBlockInfo.Key] != 0 ||
                    State.TxRootMerklePathInParentChain[indexedBlockInfo.Key] != null))
                return false;

            currentHeight += 1;
        }

        if (parentChainBlockData.Count > 0)
            validatedParentChainBlockData[parentChainId] = parentChainBlockData.ToList();

        return true;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L767-767)
```csharp
            LocalChainHeight = Context.CurrentHeight
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L776-780)
```csharp
            foreach (var indexedBlockInfo in blockInfo.IndexedMerklePath)
            {
                BindParentChainHeight(indexedBlockInfo.Key, parentChainHeight);
                AddIndexedTxRootMerklePathInParentChain(indexedBlockInfo.Key, indexedBlockInfo.Value);
            }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-290)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-301)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L19-30)
```csharp
    public override CrossChainMerkleProofContext GetBoundParentChainHeightAndMerklePathByHeight(Int64Value input)
    {
        var boundParentChainHeight = State.ChildHeightToParentChainHeight[input.Value];
        Assert(boundParentChainHeight != 0);
        var merklePath = State.TxRootMerklePathInParentChain[input.Value];
        Assert(merklePath != null);
        return new CrossChainMerkleProofContext
        {
            MerklePathFromParentChain = merklePath,
            BoundParentChainHeight = boundParentChainHeight
        };
    }
```
