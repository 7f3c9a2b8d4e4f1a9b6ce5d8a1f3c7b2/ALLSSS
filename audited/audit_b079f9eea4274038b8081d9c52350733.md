### Title
Proposal Hash Squatting via Expired Entry Overwrite Enables Denial-of-Service and Authorship Hijacking

### Summary
The `RegisterContractProposingData` function allows any address to overwrite an expired proposal entry without verifying they are the original proposer, enabling an attacker to squat on proposal hashes indefinitely. This prevents legitimate proposers from re-submitting expired proposals and enables potential authorship hijacking if the attacker's duplicate proposal succeeds through governance.

### Finding Description

The vulnerability exists in the `RegisterContractProposingData` function [1](#0-0) , which is called during contract deployment and update proposals [2](#0-1) [3](#0-2) .

The root cause is the insufficient validation at the expiration check. The function only verifies that either no entry exists OR the current time has passed the expiration time [4](#0-3) , but then unconditionally overwrites the entry with the new caller as the proposer [5](#0-4) .

The proposal hash is deterministically computed from the contract deployment/update input parameters [6](#0-5) . Once an entry expires (default 72 hours [7](#0-6) ), any address can re-register with the same hash, resetting the expiration time and becoming the new proposer.

The proposer identity is critical because `ReleaseApprovedContract` validates that only the registered proposer can progress the proposal through its lifecycle [8](#0-7) . When the contract is eventually deployed, the proposer becomes the contract author (if whitelisted) [9](#0-8) [10](#0-9) .

### Impact Explanation

**Denial-of-Service Impact**: When a legitimate proposer's entry expires (due to governance delays or timing issues), an attacker can immediately re-register the same proposal hash with themselves as the proposer. The original proposer cannot re-submit their proposal with the same parameters for another 72 hours, as the assertion `"Already proposed."` will fail. For deterministic contract deployments requiring specific salts to achieve particular addresses [11](#0-10) , this prevents the legitimate use case entirely.

**Authorship Hijacking Impact**: If the attacker's duplicate proposal passes through the governance process (Parliament approval and code check), the attacker becomes the contract author instead of the legitimate designer. The author has special privileges including the ability to update the contract [12](#0-11)  and transfer authorship [13](#0-12) .

**Repeated Attack**: An attacker can maintain indefinite control over a proposal hash by re-registering it every 72 hours before it expires again, effectively squatting on the hash permanently with minimal cost (only gas fees).

This violates the critical invariant that "proposal lifetime/expiration" must be correctly managed to ensure legitimate governance processes.

### Likelihood Explanation

**Attack Complexity**: Low. The attacker needs to:
1. Monitor the chain for expired proposal entries (trivially automated)
2. Obtain the input parameters that generated the target hash (publicly available from the original proposal transaction)
3. Call `ProposeNewContract` or `ProposeUpdateContract` with the same input immediately after expiration

**Economic Barriers**: Minimal. No explicit fees or stakes are required for proposal registration beyond standard gas costs. The attacker doesn't need to complete the full governance process to cause denial-of-service; merely registering the hash is sufficient to block the legitimate proposer.

**Entry Point**: The attack uses the public `ProposeNewContract` [14](#0-13)  and `ProposeUpdateContract` [15](#0-14)  methods, which are accessible to any address.

**Detection**: While the attack is visible on-chain, there is no automatic prevention mechanism. The governance system would need manual intervention to identify and reject duplicate proposals, which may not occur if the attacker's proposal appears legitimate.

### Recommendation

Modify `RegisterContractProposingData` to prevent unauthorized re-registration of expired entries:

**Option 1 - Preserve Original Proposer**: When an entry exists but is expired, only allow the original proposer to re-register:
```csharp
private void RegisterContractProposingData(Hash proposedContractInputHash)
{
    var registered = State.ContractProposingInputMap[proposedContractInputHash];
    if (registered != null)
    {
        Assert(Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        Assert(registered.Proposer == Context.Sender, "Only original proposer can re-register expired proposal.");
    }
    var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
    State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
    {
        Proposer = Context.Sender,
        Status = ContractProposingInputStatus.Proposed,
        ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
    };
}
```

**Option 2 - Clear Expired Entries**: Remove expired entries completely before allowing re-registration, with a cooldown period:
```csharp
private void RegisterContractProposingData(Hash proposedContractInputHash)
{
    var registered = State.ContractProposingInputMap[proposedContractInputHash];
    if (registered != null)
    {
        if (Context.CurrentBlockTime >= registered.ExpiredTime)
        {
            // Add cooldown period after expiration before hash becomes available
            var cooldownPeriod = 86400; // 24 hours
            Assert(Context.CurrentBlockTime >= registered.ExpiredTime.AddSeconds(cooldownPeriod), 
                "Hash is in cooldown period after expiration.");
            State.ContractProposingInputMap.Remove(proposedContractInputHash);
        }
        else
        {
            Assert(false, "Already proposed.");
        }
    }
    // Continue with registration...
}
```

**Test Cases**: Add tests for:
- Expired entry re-registration by different address (should fail)
- Expired entry re-registration by original proposer (should succeed)
- Multiple sequential squatting attempts (should fail)

### Proof of Concept

**Initial State**:
- Alice wants to deploy a contract with specific parameters (code, category, salt)
- Default expiration period is 259,200 seconds (72 hours)
- Bob (attacker) monitors the blockchain for proposal activity

**Attack Sequence**:

1. **T=0 hours**: Alice calls `ProposeNewContract` with her contract parameters
   - Hash H = HashHelper.ComputeFrom(input) is calculated
   - `State.ContractProposingInputMap[H]` = {Proposer: Alice, Status: Proposed, ExpiredTime: T+72h}
   - Governance proposal P1 is created in Parliament contract

2. **T=10 hours**: Parliament members vote and approve proposal P1
   - P1 meets approval threshold but Alice hasn't called `ReleaseApprovedContract` yet

3. **T=72 hours + 1 second**: Both the registration entry and Parliament proposal expire
   - Alice's governance proposal P1 can no longer be released [16](#0-15) 
   - The registration entry remains in storage but is now expired

4. **T=72 hours + 2 seconds**: Bob calls `ProposeNewContract` with Alice's exact input parameters
   - The check `Context.CurrentBlockTime >= registered.ExpiredTime` passes
   - `State.ContractProposingInputMap[H]` is overwritten with {Proposer: Bob, Status: Proposed, ExpiredTime: T+144h}
   - A new governance proposal P2 is created for Bob

5. **T=72 hours + 3 seconds**: Alice attempts to re-propose her contract with the same parameters
   - The check at line 207 evaluates: registered != null && CurrentBlockTime (T+72h+3s) < registered.ExpiredTime (T+144h)
   - The assertion fails with "Already proposed."
   - Alice is blocked from re-proposing for another ~72 hours

**Expected vs Actual Result**:
- **Expected**: Alice should be able to re-propose her own contract after her proposal expires, or the system should clear expired entries to free up the hash
- **Actual**: Bob can squat on Alice's proposal hash indefinitely by re-registering before each expiration, and Alice cannot re-submit her proposal with the required parameters

**Success Condition**: Bob successfully prevents Alice from proposing her contract, and if Bob's proposal passes governance, Bob becomes the author of Alice's contract design.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L98-102)
```csharp
    private void UpdateSmartContract(Address contractAddress, byte[] code, Address author, bool isUserContract)
    {
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        Assert(author == info.Author, "No permission.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L175-178)
```csharp
    private Hash CalculateHashFromInput(IMessage input)
    {
        return HashHelper.ComputeFrom(input);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L257-266)
```csharp
    private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
    {
        if (!State.ContractDeploymentAuthorityRequired.Value)
            return sender;

        var contractDeploymentController = State.ContractDeploymentController.Value;
        var isProposerInWhiteList = ValidateProposerAuthority(contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposer);
        return isProposerInWhiteList ? proposer : Context.Self;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L122-173)
```csharp
    public override Hash ProposeNewContract(ContractDeploymentInput input)
    {
        // AssertDeploymentProposerAuthority(Context.Sender);
        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        AssertContractNotExists(codeHash);
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();

        if (input.ContractOperation != null)
        {
            ValidateContractOperation(input.ContractOperation, 0, codeHash);
            
            // Remove one time signer if exists. Signer is only needed for validating signature.
            RemoveOneTimeSigner(input.ContractOperation.Deployer);
            
            AssertContractAddressAvailable(input.ContractOperation.Deployer, input.ContractOperation.Salt);
        }

        // Create proposal for deployment
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName =
                    nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.ProposeContractCodeCheck),
                Params = new ContractCodeCheckInput
                {
                    ContractInput = input.ToByteString(),
                    CodeCheckReleaseMethod = nameof(DeploySmartContract),
                    ProposedContractInputHash = proposedContractInputHash,
                    Category = input.Category,
                    IsSystemContract = false
                }.ToByteString(),
                OrganizationAddress = State.ContractDeploymentController.Value.OwnerAddress,
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
            },
            OriginProposer = Context.Sender
        };
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput.ToByteString());

        Context.Fire(new ContractProposed
        {
            ProposedContractInputHash = proposedContractInputHash
        });

        return proposedContractInputHash;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-232)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
        AssertContractVersion(info.ContractVersion, input.Code, info.Category);

        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        AssertContractNotExists(codeHash);

        Assert((input.Address == Context.Self || info.SerialNumber > 0) && input.ContractOperation == null ||
               info.SerialNumber == 0 && input.ContractOperation != null, "Not compatible.");

        if (input.ContractOperation != null)
        {
            ValidateContractOperation(input.ContractOperation, info.Version, codeHash);
            RemoveOneTimeSigner(input.ContractOperation.Deployer);
            AssertSameDeployer(input.Address, input.ContractOperation.Deployer);
        }

        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();

        // Create proposal for contract update
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName =
                    nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.ProposeContractCodeCheck),
                Params = new ContractCodeCheckInput
                {
                    ContractInput = input.ToByteString(),
                    CodeCheckReleaseMethod = nameof(UpdateSmartContract),
                    ProposedContractInputHash = proposedContractInputHash,
                    Category = info.Category,
                    IsSystemContract = info.IsSystemContract
                }.ToByteString(),
                OrganizationAddress = State.ContractDeploymentController.Value.OwnerAddress,
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
            },
            OriginProposer = Context.Sender
        };
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput);

        Context.Fire(new ContractProposed
        {
            ProposedContractInputHash = proposedContractInputHash
        });

        return proposedContractInputHash;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L277-283)
```csharp
    public override Empty ReleaseApprovedContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];
        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.Proposed &&
            contractProposingInput.Proposer == Context.Sender, "Invalid contract proposing status.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L317-320)
```csharp
        var address =
            DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
                DecideNonSystemContractAuthor(contractProposingInput?.Proposer, Context.Sender), false,
                input.ContractOperation?.Deployer, input.ContractOperation?.Salt);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L519-535)
```csharp
    public override Empty SetContractAuthor(SetContractAuthorInput input)
    {
        var info = State.ContractInfos[input.ContractAddress];
        Assert(info != null, "Contract not found.");
        var oldAuthor = info.Author;
        Assert(Context.Sender == info.Author, "No permission.");
        info.Author = input.NewAuthor;
        State.ContractInfos[input.ContractAddress] = info;
        Context.Fire(new AuthorUpdated()
        {
            Address = input.ContractAddress,
            OldAuthor = oldAuthor,
            NewAuthor = input.NewAuthor
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L5-5)
```csharp
    public const int ContractProposalExpirationTimePeriod = 259200; // 60 * 60 * 72
```

**File:** protobuf/acs0.proto (L319-326)
```text
message ContractOperation{
    int32 chain_id = 1;
    aelf.Hash code_hash = 2;
    aelf.Address deployer = 3;
    aelf.Hash salt = 4;
    int32 version = 5;
    bytes signature = 10000;
}
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L177-180)
```csharp
    private bool CheckProposalNotExpired(ProposalInfo proposal)
    {
        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```
