### Title
Unvalidated ActualMiningTimes in RecoverFromTinyBlock Enables Term Change Manipulation and Consensus Corruption

### Summary
The `RecoverFromTinyBlock()` function blindly adds miner-provided `ActualMiningTimes` timestamps without validating they match the actual block time (`Context.CurrentBlockTime`). Since `ActualMiningTimes` is excluded from round hash verification and used in critical consensus decisions like term changes, malicious miners can provide arbitrary timestamps to manipulate consensus behavior and corrupt the blockchain's temporal integrity.

### Finding Description

**Root Cause Location:** [1](#0-0) 

This line adds provided timestamps without any validation against `Context.CurrentBlockTime`.

**Why Protections Fail:**

1. **Hash Validation Excludes ActualMiningTimes:** The round integrity check clears `ActualMiningTimes` before computing hashes, meaning manipulated timestamps bypass integrity verification: [2](#0-1) 

2. **Validation Uses Corrupted Data:** During `ValidateBeforeExecution`, `RecoverFromTinyBlock` is called BEFORE validation providers run, meaning validators check against already-corrupted data: [3](#0-2) 

The modified `baseRound` is then passed to validators: [4](#0-3) 

3. **No Timestamp Verification in ProcessTinyBlock:** During execution, the provided timestamp is persisted to state without comparing it to the actual block time: [5](#0-4) 

4. **Post-Execution Validation Also Uses Recovered Data:** Even after execution, the validation recovers the round with the fake timestamps before comparing hashes: [6](#0-5) 

### Impact Explanation

**Critical Consensus Corruption:**

1. **Term Change Manipulation:** The `NeedToChangeTerm` function uses `ActualMiningTimes.Last()` to determine when to trigger term changes: [7](#0-6) 

This directly controls the decision between `NextRound` and `NextTerm` behaviors: [8](#0-7) 

Attackers can:
- **Delay term changes** by providing past timestamps, keeping themselves in power longer and delaying election updates and treasury releases
- **Advance term changes** by providing future timestamps, triggering premature elections and disrupting governance

2. **Time Slot Validation Bypass:** Validation checks use the corrupted timestamps: [9](#0-8) 

Miners can extend their mining windows by providing timestamps within their allocated slot even when the actual block time exceeds it.

3. **Consensus Behavior Corruption:** Future consensus command generation relies on the count and values of `ActualMiningTimes`: [10](#0-9) 

Manipulated timestamps corrupt these calculations, affecting block production schedules and tiny block limits.

**Affected Parties:** All blockchain participants suffer from consensus instability, miners gain unfair advantages, governance processes are disrupted, and treasury releases are mistimed.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an active miner in the current miner list
- Must have the ability to produce TinyBlocks (normal miner operation)
- Can modify consensus header data before block production (standard block producer capability)

**Attack Complexity:** LOW
1. Miner requests consensus command for TinyBlock behavior
2. System generates consensus extra data with legitimate `Context.CurrentBlockTime`: [11](#0-10) 

3. Attacker modifies the `ActualMiningTimes` in the generated `Round` object before including it in the block header
4. Block passes all validations because `ActualMiningTimes` is excluded from hash checks and validation uses the corrupted data
5. Fake timestamps are permanently persisted to blockchain state

**Feasibility:** HIGH - No cryptographic barriers exist. The miner controls the consensus header content and no signature or timestamp verification occurs.

**Detection:** Difficult - Observers see only the final persisted timestamps and cannot easily distinguish legitimate delays from malicious manipulation without comparing against actual block times.

### Recommendation

**Immediate Fix:** Add explicit validation in `ProcessTinyBlock` to ensure the provided `ActualMiningTime` matches the actual block time within acceptable bounds:

```csharp
private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    
    // CRITICAL: Validate ActualMiningTime matches actual block time
    var timeDifference = (Context.CurrentBlockTime - tinyBlockInput.ActualMiningTime).Seconds;
    Assert(Math.Abs(timeDifference) <= AEDPoSContractConstants.MaximumTimestampDeviationSeconds, 
           "Provided ActualMiningTime deviates too much from actual block time.");
    
    minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
    minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
    minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);
    
    Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
}
```

**Additional Protections:**
1. Include `ActualMiningTimes` in hash validation or add separate timestamp verification
2. Remove `RecoverFromTinyBlock` call before validation, only use it for post-execution state updates
3. Add monitoring to detect significant deviations between provided timestamps and block times

**Test Cases:**
- Verify rejection of timestamps deviating more than acceptable threshold from `Context.CurrentBlockTime`
- Test term change decisions are not manipulable by fake timestamps
- Ensure time slot validation cannot be bypassed with crafted timestamps

### Proof of Concept

**Initial State:**
- Attacker is an active miner in round N
- Current term should change in 2 hours based on legitimate timestamps
- Attacker is within their allocated time slot

**Attack Steps:**

1. Attacker's node calls `GetConsensusCommand` which returns `TinyBlock` behavior
2. Attacker's node calls `GetConsensusExtraData` which generates a `Round` object with `ActualMiningTimes` containing `Context.CurrentBlockTime` (current time)
3. **ATTACK:** Before producing the block, attacker modifies the `Round` object in the consensus header, replacing `ActualMiningTimes` with a timestamp 3 hours in the future
4. Attacker produces and broadcasts the block with manipulated consensus data
5. During validation, `RecoverFromTinyBlock` adds the future timestamp to `baseRound`
6. `TimeSlotValidationProvider` validates using the modified `baseRound` - if the fake timestamp is within the time slot bounds, validation passes
7. `ProcessTinyBlock` persists the fake timestamp to state without checking against `Context.CurrentBlockTime`
8. In subsequent blocks, `NeedToChangeTerm` evaluates using the fake future timestamp, incorrectly determining it's time to change term immediately instead of in 2 hours

**Expected Result:** Block should be rejected due to timestamp mismatch with `Context.CurrentBlockTime`

**Actual Result:** Block is accepted, fake timestamp is persisted, term change is triggered prematurely, disrupting consensus schedule and governance timeline

**Success Condition:** Attacker successfully manipulates when term changes occur, gains extended mining privileges, or disrupts election and treasury schedules through timestamp manipulation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L44-44)
```csharp
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L193-193)
```csharp
            checkableMinerInRound.ActualMiningTimes.Clear();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-223)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L49-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L304-304)
```csharp
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L94-97)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L31-35)
```csharp
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L41-50)
```csharp
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-79)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L162-163)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```
