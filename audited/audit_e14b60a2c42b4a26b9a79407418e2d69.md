# Audit Report

## Title
Byzantine Minority Can Prevent Term Transitions by Coordinated Mining Abstention

## Summary
A minority coalition of miners (≥40% but <67%) can indefinitely prevent term transitions in the AEDPoS consensus by strategically abstaining from mining during rounds that cross term boundaries. This causes the consensus to use `NextRound` instead of `NextTerm`, preventing newly elected miners from joining and breaking the governance-based miner rotation mechanism.

## Finding Description

The vulnerability exists in the term transition decision logic that determines whether to terminate a round with `NextRound` or `NextTerm` behavior. [1](#0-0) 

The decision relies on `NeedToChangeTerm()`, which counts how many miners have `ActualMiningTimes` timestamps that cross the term boundary and compares this to `MinersCountOfConsent`: [2](#0-1) 

The threshold `MinersCountOfConsent` is calculated as two-thirds plus one: [3](#0-2) 

**Root Cause**: The vulnerability stems from a timing issue where the extra block producer's `ActualMiningTime` is added to the NEXT round, not the current round being evaluated: [4](#0-3) 

At line 195-196, the extra block producer's timestamp is added to the NEXT round. This means when `GetConsensusBehaviourToTerminateCurrentRound()` evaluates `NeedToChangeTerm()`, it examines the current round state WITHOUT the extra block producer's contribution.

**Attack Scenario**: With 10 miners where `MinersCountOfConsent = 7`:
1. Four miners (40%) coordinate to abstain from mining after the term boundary timestamp
2. Six honest miners continue mining normally
3. When the extra block producer requests consensus behavior, only 5 honest miners have already recorded `ActualMiningTimes` crossing the boundary (the 6th being the extra block producer who hasn't mined yet)
4. Since `5 < 7`, `NeedToChangeTerm()` returns false
5. The extra block producer uses `NextRound` instead of `NextTerm`
6. Same miners continue; newly elected miners never join

**Why Detection Fails**: The evil miner detection threshold is 4,320 missed time slots (approximately 3 days): [5](#0-4) 

Colluding miners only need to abstain strategically at each term boundary (e.g., missing a few rounds every 7 days), staying far below this detection threshold.

## Impact Explanation

This vulnerability breaks the fundamental governance mechanism that connects elections to validator rotation.

When `NextTerm` is properly triggered, it calls `GenerateFirstRoundOfNextTerm()` which fetches newly elected miners from the Election Contract: [6](#0-5) 

At lines 228-232, `TryToGetVictories()` retrieves the winners from the election: [7](#0-6) 

Without term transitions, this entire mechanism is bypassed. The impact includes:

**Critical Governance Failure**:
- User votes in elections become meaningless
- Newly elected validators can never join consensus
- Incumbent miners maintain permanent control

**Economic Impact**:
- Mining rewards continue to incumbent miners instead of elected validators
- Initial reward of ~12.5 tokens per block (with periodic halving) is misallocated

**Centralization Risk**:
- A minority coalition (≥40%) can override the majority's governance decisions
- Violates the core AEDPoS principle that 2/3+ consensus is required for safety

**Protocol Integrity**:
- Breaks the social contract between voters and the consensus mechanism
- Undermines trust in the governance system

## Likelihood Explanation

**HIGH Likelihood** - The attack is practical and economically rational:

**Technical Feasibility**:
- Miners control their own nodes and can choose when to produce blocks
- Term boundaries are predictable from the public `PeriodSeconds` configuration
- No special privileges or on-chain transactions required (passive attack via abstention)
- Off-chain coordination between miners is trivial (messaging, forums, etc.)

**Economic Incentives**:
- Miners facing replacement have strong motivation to collude
- Continued mining rewards (initially ~12.5 tokens per block)
- Preservation of validator status and reputation
- Protection of infrastructure investments

**Attack Sustainability**:
- Only requires strategic abstention at term boundaries (e.g., every 7 days)
- Far below the 4,320 time slot evil detection threshold
- Can be sustained indefinitely with minimal operational cost
- Appears as normal network variance until pattern recognition

**Threshold Analysis**:
- Only 40% collusion needed (achievable when multiple miners face replacement)
- Lower than the 67% Byzantine threshold typically assumed secure
- Example: With 10 miners, only 4 need to coordinate

## Recommendation

**Immediate Fix**: Modify `NeedToChangeTerm()` to check whether the blockchain time has crossed the term boundary, rather than requiring 2/3+ of miners to have actually mined after the boundary.

The time-based term transition check already exists in `IsTimeToChangeTerm()`. The fix should:

1. Check if `(current_blocktime - blockchain_start) / period_seconds` indicates a term change is due
2. If the time threshold is crossed, return `NextTerm` regardless of how many miners have actually participated
3. Only fall back to counting miner participation if additional safety checks are needed

**Alternative Fix**: Count the extra block producer's expected mining time toward the threshold when they are the ones evaluating the term transition, since they will mine immediately after.

**Additional Hardening**:
- Add monitoring for patterns of miners consistently missing slots around term boundaries
- Implement stricter penalties for coordinated abstention patterns
- Consider reducing the term period to limit the duration of successful attacks

## Proof of Concept

```csharp
// Test setup: Configure 10 miners with term period of 604800 seconds (7 days)
// MinersCountOfConsent = (10 * 2 / 3) + 1 = 7

[Fact]
public async Task Byzantine_Minority_Prevents_Term_Transition()
{
    // Arrange: Set up 10 initial miners
    var initialMiners = GenerateMinerList(10);
    await InitializeConsensusWithMiners(initialMiners);
    
    // Simulate election of NEW miners for next term
    var newlyElectedMiners = GenerateMinerList(10, seed: 42);
    await SetupElectionWinners(newlyElectedMiners);
    
    // Advance time to cross term boundary
    await AdvanceTimeToTermBoundary();
    
    // Act: 4 miners (40%) coordinate to abstain from mining after term boundary
    var colludingMiners = initialMiners.Take(4).ToList();
    var honestMiners = initialMiners.Skip(4).ToList();
    
    // Honest miners (6) produce blocks normally
    foreach (var miner in honestMiners.Take(5)) // 5 mine before extra block producer
    {
        await ProduceBlockAs(miner);
    }
    
    // Extra block producer (6th honest miner) terminates round
    var extraBlockProducer = honestMiners[5];
    var consensusCommand = await GetConsensusCommandAs(extraBlockProducer);
    
    // Assert: Behavior should be NextTerm but is NextRound due to attack
    Assert.Equal(AElfConsensusBehaviour.NextRound, consensusCommand.Behaviour); // VULNERABILITY!
    
    // Produce the extra block
    await ProduceBlockAs(extraBlockProducer);
    
    // Verify: Newly elected miners did NOT join consensus
    var currentMinerList = await GetCurrentMinerList();
    Assert.Equal(initialMiners, currentMinerList); // Still old miners
    Assert.DoesNotContain(newlyElectedMiners, m => currentMinerList.Contains(m)); // New miners excluded
    
    // Verify: Term number did NOT increment
    var currentTerm = await GetCurrentTermNumber();
    var expectedTerm = await GetExpectedTermNumber(); // Based on time
    Assert.NotEqual(expectedTerm, currentTerm); // Term stuck!
}
```

## Notes

This vulnerability is particularly insidious because:

1. **Silent Failure**: The attack doesn't cause obvious errors or crashes—the blockchain continues producing blocks normally
2. **Gradual Harm**: The full impact only becomes apparent when elections consistently fail to take effect
3. **Coordination Advantage**: Incumbent miners have natural communication channels and shared interests
4. **Minimal Risk**: Attackers accumulate missed slots slowly, staying below detection thresholds

The fix must ensure that time-based term transitions cannot be blocked by minority abstention, as the current implementation inadvertently allows.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```
