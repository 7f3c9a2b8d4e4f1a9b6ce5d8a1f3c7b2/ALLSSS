### Title
Voluntary Key Replacement Exploited to Bypass Mining Reward Penalties

### Summary
The `IsReplacedEvilMiner` flag mechanism is inverted: it is set for voluntary key replacements but NOT for actual evil miner replacements. This allows underperforming miners to voluntarily replace their keys mid-term to bypass the `CalculateShares` penalty function, receiving up to 33%+ more rewards than deserved. The developers intended this exemption for legitimate evil miner replacements where backup miners join mid-term, but the implementation provides the advantage to voluntary replacements instead.

### Finding Description

The vulnerability exists in the reward calculation logic in `UpdateBasicMinerRewardWeights()`: [1](#0-0) 

When `IsReplacedEvilMiner[i.Pubkey]` is true, miners receive full shares equal to `producedBlocks` without penalty. Otherwise, shares are calculated via `CalculateShares()` which applies quadratic penalties for underperformance: [2](#0-1) 

**Root Cause:** The `IsReplacedEvilMiner` flag is ONLY set through `RecordMinerReplacement`: [3](#0-2) 

However, `RecordMinerReplacement` is called ONLY for voluntary replacements via `RecordCandidateReplacement`: [4](#0-3) 

For actual evil miner replacements during `GenerateNextRoundInformation`, the replacement happens in-memory with NO call to `RecordMinerReplacement`: [5](#0-4) 

When a voluntary replacement occurs, the new key inherits all stats from the old key: [6](#0-5) 

Voluntary replacements are accessible to any candidate admin via `ReplaceCandidatePubkey`: [7](#0-6) 

### Impact Explanation

**Concrete Reward Theft:**
- If a miner produces 750 blocks when average is 1000 blocks (75% of average):
  - **Without gaming:** shares = 750² / 1000 = 562 shares
  - **With gaming:** shares = 750 shares (full credit)
  - **Stolen value:** 188 additional shares = 33% reward inflation

**Who is Affected:**
- Honest miners lose relative share of rewards as underperformers game the system
- Treasury profit distribution becomes unfair, violating the critical invariant for share calculation accuracy

**Severity Justification:** Medium severity due to direct fund impact (reward misallocation), though limited to miners who control candidate admin keys and are willing to permanently ban their old key.

### Likelihood Explanation

**Reachable Entry Point:** `ReplaceCandidatePubkey` is a public method with no fee or cooldown restrictions.

**Attacker Capabilities:** Any candidate who controls their admin key can execute this. The only requirement is permission check: [8](#0-7) 

**Feasibility:** 
- No economic cost beyond permanent banning of old key
- Can be executed mid-term when underperformance is detected
- Stats fully transfer to new key, making the replacement seamless

**Detection Constraints:** The replacement appears legitimate via `CandidatePubkeyReplaced` event, making it difficult to distinguish from genuine key rotation.

### Recommendation

**1. Distinguish replacement types explicitly:**
- Add separate tracking for voluntary vs. evil miner replacements
- Only exempt actual evil miner replacements from penalties
- Modify `RecordMinerReplacement` to accept and properly utilize the `is_old_pubkey_evil` parameter

**2. Set the flag correctly for evil miner replacements:**
In `GenerateNextRoundInformation`, after replacing evil miners, call:
```
State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
{
    OldPubkey = evilMinerPubkey,
    NewPubkey = alternativeCandidatePubkey,
    CurrentTermNumber = currentRound.TermNumber,
    IsOldPubkeyEvil = true  // Explicitly set for evil miner replacements
});
```

**3. Enforce penalty for voluntary replacements:**
In `UpdateBasicMinerRewardWeights`, only exempt from penalty if the replacement was for an evil miner:
```csharp
if (State.IsReplacedEvilMiner[i.Pubkey]) {
    shares = i.ProducedBlocks;  // Only for actual evil miner replacements
    State.IsReplacedEvilMiner.Remove(i.Pubkey);
} else {
    shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
}
```

**4. Add test cases:**
- Test that voluntary replacements DO get penalized
- Test that evil miner replacements do NOT get penalized
- Test mid-term replacement gaming scenario to ensure it's prevented

### Proof of Concept

**Initial State:**
- Term in progress with 5 miners
- Average blocks per miner = 1000
- MinerA has produced 700 blocks by mid-term (underperforming)
- MinerA projects finishing with ~750 blocks total (below 800 threshold)

**Attack Steps:**

1. MinerA (as candidate admin) calls `ReplaceCandidatePubkey`:
   - Input: `{ OldPubkey: "MinerA", NewPubkey: "MinerA_New" }`
   - This triggers `RecordCandidateReplacement` → `RecordMinerReplacement`
   - Result: `IsReplacedEvilMiner["MinerA_New"] = true`

2. MinerA_New inherits 700 blocks and continues mining:
   - Produces 50 more blocks
   - Total: 750 blocks

3. Term ends, `Release()` called, `UpdateBasicMinerRewardWeights()` executes:
   - For MinerA_New: checks `IsReplacedEvilMiner["MinerA_New"]` = true
   - Calculates: shares = 750 (no penalty)
   
4. Normal underperforming miner with 750 blocks:
   - Calculates: shares = CalculateShares(750, 1000) = 750² / 1000 = 562

**Expected vs Actual:**
- **Expected:** MinerA_New gets penalized like other underperformers (562 shares)
- **Actual:** MinerA_New gets full shares (750 shares)
- **Success Condition:** MinerA_New receives 33% more rewards (188 extra shares) than deserved

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L596-596)
```csharp
        State.IsReplacedEvilMiner[input.NewPubkey] = true;
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L802-812)
```csharp
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-342)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```
