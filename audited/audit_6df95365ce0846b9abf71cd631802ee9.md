# Audit Report

## Title
Broken Mining Order Validation Allows Consensus Failure Through Duplicate FinalOrderOfNextRound Values

## Summary
The `NextRoundMiningOrderValidationProvider` contains two critical flaws that make it completely ineffective at detecting duplicate mining orders: it applies `Distinct()` to entire miner objects rather than order values, and it validates the wrong round data. This allows malicious miners to inject duplicate `FinalOrderOfNextRound` values that break consensus when the next round begins, causing multiple miners to compete for the same time slot and potentially halting block production.

## Finding Description

**Root Cause 1 - Incorrect Distinct() Usage:**

The validation logic applies `Distinct()` to entire `MinerInRound` objects [1](#0-0) , which uses protobuf structural equality. Since each `MinerInRound` has a unique `Pubkey` field [2](#0-1) , all miners are considered distinct even if they have identical `FinalOrderOfNextRound` values. The validation should extract and check uniqueness of the order values themselves, not the miner objects.

**Root Cause 2 - Wrong Round Checked:**

The validator checks `validationContext.ProvidedRound` [3](#0-2) , which is the newly generated next round from block header extra data [4](#0-3) . When the next round is generated, only basic fields like `Order`, `ExpectedMiningTime`, `ProducedBlocks`, and `MissedTimeSlots` are set [5](#0-4) . Neither `FinalOrderOfNextRound` nor `OutValue` are populated, causing both counts in the validation to be 0, making the check always pass (0 == 0). The validator should check `BaseRound` where miners have already set these fields during UpdateValue blocks.

**Exploitation Path:**

During UpdateValue processing, `ApplyNormalConsensusData` performs conflict resolution [6](#0-5)  on the local node when preparing block header data [7](#0-6) . However, this conflict resolution is NOT enforced during validation. The `UpdateValueValidationProvider` only validates that `OutValue` and `Signature` are filled and checks previous in values [8](#0-7)  - it does NOT check for duplicate orders in `TuneOrderInformation`.

A malicious miner can:
1. Modify their node software to bypass `ApplyNormalConsensusData` conflict resolution
2. Craft malicious `TuneOrderInformation` with duplicate `FinalOrderOfNextRound` values
3. Submit UpdateValue transaction - validation passes with no duplicate order checks
4. `ProcessUpdateValue` directly applies the malicious `TuneOrderInformation` to state [9](#0-8) 
5. When NextRound executes, `GenerateNextRoundInformation` directly assigns `FinalOrderOfNextRound` to the `Order` field in the next round [10](#0-9) , propagating duplicate orders

The NextRound validation is registered only for `AElfConsensusBehaviour.NextRound` [11](#0-10) , but due to the two root causes, it fails to detect the duplicate orders that were injected during UpdateValue blocks.

## Impact Explanation

**Consensus Integrity Violation (Critical):**

Multiple miners assigned identical `Order` values in a round violates the fundamental AEDPoS consensus invariant that each miner has a unique mining time slot. The `Order` field directly determines `ExpectedMiningTime` [12](#0-11) , so miners with duplicate orders will attempt block production at exactly the same time, causing:

- Competing blocks at the same blockchain height
- Consensus confusion and potential chain forks  
- Deadlock where neither miner's block can be accepted
- Complete halt of block production requiring manual intervention

**Scope:** Affects the entire blockchain. Once duplicate orders persist in state, the next round cannot function correctly. All validators and the network's liveness are compromised. Recovery requires emergency consensus reset or manual state correction.

**Severity:** HIGH - Breaks core consensus assumptions, causes operational failure, and compromises blockchain availability.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an active miner in the current validator set (can produce UpdateValue blocks)
- Requires modified node software to bypass local `ApplyNormalConsensusData` conflict resolution
- Can craft malicious `TuneOrderInformation` in block headers

**Attack Complexity:** MEDIUM
- No economic cost beyond existing validator stake
- Requires understanding of AEDPoS round mechanics and block header structure
- Single malicious miner can execute independently without coordination
- Difficult to detect - invalid state persists in contract storage with no revert

**Feasibility Analysis:**

The validation system provides NO effective protection:
- `UpdateValueValidationProvider` does not check `TuneOrderInformation` for duplicate orders [8](#0-7) 
- `NextRoundMiningOrderValidationProvider` is non-functional due to both root causes [13](#0-12) 
- `ProcessUpdateValue` has no duplicate order invariant checks [14](#0-13) 

**Likelihood Assessment:** HIGH - Given the complete absence of validation barriers and relatively low attack prerequisites.

## Recommendation

**Fix 1 - Correct the Distinct() Logic:**

Change the validation to extract and check uniqueness of order values:

```csharp
var distinctOrderCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Extract order values
    .Distinct()
    .Count();
```

**Fix 2 - Validate the Correct Round:**

Check `BaseRound` instead of `ProvidedRound` to validate orders set during the current round:

```csharp
var baseRound = validationContext.BaseRound;
var distinctOrderCount = baseRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
if (distinctOrderCount != baseRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
{
    validationResult.Message = "Invalid FinalOrderOfNextRound - duplicate orders detected.";
    return validationResult;
}
```

**Fix 3 - Add UpdateValue Validation:**

Add duplicate order checking in `UpdateValueValidationProvider` or create a dedicated validator that checks `TuneOrderInformation` for duplicates against existing `FinalOrderOfNextRound` values in `BaseRound`.

## Proof of Concept

```csharp
[Fact]
public async Task DuplicateOrderAttack_BreaksConsensus()
{
    // Setup: Initialize consensus with multiple miners
    await InitializeCandidates(3);
    var firstRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Miners produce UpdateValue blocks normally
    foreach (var minerInRound in firstRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order))
    {
        var keyPair = GetKeyPairForMiner(minerInRound.Pubkey);
        KeyPairProvider.SetKeyPair(keyPair);
        BlockTimeProvider.SetBlockTime(minerInRound.ExpectedMiningTime);
        
        var tester = GetAEDPoSContractStub(keyPair);
        var updateInput = CreateUpdateValueInput(minerInRound.Pubkey);
        
        // Malicious miner injects duplicate orders via TuneOrderInformation
        if (minerInRound.Order == 2)
        {
            // Set Miner 3's FinalOrderOfNextRound to same as Miner 1's
            updateInput.TuneOrderInformation[GetMiner3Pubkey()] = 1;
        }
        
        // UpdateValue succeeds - no duplicate validation
        await tester.UpdateValue.SendAsync(updateInput);
    }
    
    // Trigger NextRound
    var nextRoundMiner = GetLastMiner(firstRound);
    KeyPairProvider.SetKeyPair(nextRoundMiner);
    BlockTimeProvider.SetBlockTime(GetNextRoundTime());
    
    var nextRoundInput = CreateNextRoundInput();
    await AEDPoSContractStub.NextRound.SendAsync(nextRoundInput);
    
    // Verify: Next round has duplicate orders
    var secondRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var orders = secondRound.RealTimeMinersInformation.Values.Select(m => m.Order).ToList();
    
    // VULNERABILITY: Multiple miners have Order = 1
    orders.Count(o => o == 1).ShouldBeGreaterThan(1);
    
    // IMPACT: Miners with duplicate orders have identical ExpectedMiningTime
    var miner1Time = secondRound.RealTimeMinersInformation.Values.First(m => m.Order == 1).ExpectedMiningTime;
    var duplicates = secondRound.RealTimeMinersInformation.Values.Where(m => m.Order == 1).ToList();
    duplicates.Should().AllSatisfy(m => m.ExpectedMiningTime.ShouldBe(miner1Time));
    
    // Consensus is broken - multiple miners will compete for the same time slot
}
```

## Notes

This vulnerability represents a fundamental failure in consensus validation logic. The two root causes compound to create a complete validation bypass: even if one flaw were fixed, the other would still allow the attack. Both must be addressed to restore consensus integrity. The attack requires validator-level access but no additional privileges beyond normal block production, making it feasible for any malicious validator to execute independently.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** protobuf/aedpos_contract.proto (L284-284)
```text
    string pubkey = 9;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L23-27)
```csharp

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-40)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```
