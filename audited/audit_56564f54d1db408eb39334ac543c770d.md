# Audit Report

## Title
NFT Type Inconsistency via Unchecked CrossChainCreate Symbol Format

## Summary
The `NFTContract.CrossChainCreate` method extracts NFT type from the first 2 characters of any symbol without validating symbol format or checking consistency with the token's metadata. Attackers can create tokens via `MultiToken.Create` with arbitrary symbols and NFT metadata, then call `CrossChainCreate` to register NFT protocols with mismatched type information, creating data integrity violations.

## Finding Description

The vulnerability arises from three interconnected flaws:

**1. CrossChainCreate blindly extracts NFT type from symbol prefix** [1](#0-0) 

The method assumes the first 2 characters represent a valid NFT type and maps them directly without validation. The extracted type becomes the authoritative `NftType` field in the protocol: [2](#0-1) 

**2. MultiToken.Create accepts arbitrary NFT metadata keys**

The MultiToken contract's reserved keys list excludes NFT-specific metadata keys: [3](#0-2) 

This list does NOT include the NFT metadata keys defined in the NFT contract: [4](#0-3) 

When creating tokens, the MultiToken contract directly accepts input ExternalInfo without validating NFT keys: [5](#0-4) 

**3. No access control on CrossChainCreate**

The method has no sender validation, allowing anyone to call it: [6](#0-5) 

**Attack Execution:**

1. Attacker creates token via `MultiToken.Create` with symbol "BA123456789" and ExternalInfo: `{"aelf_nft_type": "Art", "aelf_nft_base_uri": "...", "aelf_nft_token_id_reuse": "false"}`
2. Token is created successfully with metadata claiming type "Art"
3. Attacker calls `NFTContract.CrossChainCreate` with symbol "BA123456789"
4. CrossChainCreate extracts "BA" and maps it to "Badges" via the type mapping: [7](#0-6) 

5. NFTProtocolInfo is created with `NftType = "Badges"` while the token's metadata contains `"aelf_nft_type": "Art"`, creating an inconsistency

## Impact Explanation

This vulnerability violates the fundamental invariant that NFT type information must be consistent across all data sources. The impact manifests as:

**Data Integrity Violation:**
- NFT protocols contain contradictory type information: `NFTProtocolInfo.NftType` (derived from symbol) differs from `NFTProtocolInfo.Metadata["aelf_nft_type"]` (from token ExternalInfo)
- Applications querying `GetNFTProtocolInfo` receive incorrect type classification based on which field they trust

**Ecosystem-Wide Effects:**
- **NFT Marketplaces:** Incorrect filtering and categorization when using the `NftType` field for organization
- **DApps and Explorers:** Display wrong NFT categories, confusing users
- **Type-Based Logic:** Any future contract or application logic that depends on NFT type classification will behave incorrectly
- **User Trust:** Undermines confidence in the NFT classification system when metadata sources disagree

**Severity: Medium** - While this does not directly cause fund loss or privilege escalation, it creates significant data integrity issues that mislead users, break ecosystem applications, and could enable bypasses of any future type-specific policies.

## Likelihood Explanation

**Attack Prerequisites:**
- Attacker needs a SEED NFT to create arbitrary tokens (standard, publicly obtainable requirement)
- No special privileges, compromised keys, or whitelisting needed

**Execution Complexity:**
- Simple two-step attack: call `MultiToken.Create` then `NFTContract.CrossChainCreate`
- No timing constraints, race conditions, or complex state manipulation
- Both methods are public with minimal access restrictions

**Economic Feasibility:**
- Cost: Gas fees + SEED NFT price (economically reasonable for the potential impact)
- Detection: Creates valid tokens and protocols, appears as normal contract usage
- No anomalous behavior to trigger monitoring alerts

**Probability: High** - The attack path is straightforward, requires only standard resources (SEED NFT), and has no technical barriers preventing execution.

## Recommendation

Implement the following defenses:

**1. Add NFT metadata key validation in MultiToken.Create:**

Extend the reserved keys list to include NFT-specific keys and validate during token creation:

```csharp
// In TokenContractConstants.cs
public const string NftTypeMetadataKey = "aelf_nft_type";
public const string NftBaseUriMetadataKey = "aelf_nft_base_uri";
public const string NftTokenIdReuseMetadataKey = "aelf_nft_token_id_reuse";

// In TokenContract_Views.cs GetReservedExternalInfoKeyList
TokenContractConstants.NftTypeMetadataKey,
TokenContractConstants.NftBaseUriMetadataKey,
TokenContractConstants.NftTokenIdReuseMetadataKey
```

**2. Validate metadata consistency in CrossChainCreate:**

```csharp
// In NFTContract_Create.cs CrossChainCreate method, after line 90
var nftTypeShortName = input.Symbol.Substring(0, 2);
var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];

// Add validation
if (tokenInfo.ExternalInfo.Value.TryGetValue(NftTypeMetadataKey, out var metadataType))
{
    Assert(metadataType == nftTypeFullName, 
        $"NFT type mismatch: symbol prefix indicates {nftTypeFullName} but metadata contains {metadataType}");
}
```

**3. Add symbol format validation:**

```csharp
// Validate symbol follows expected format: 2-char prefix + numeric suffix
Assert(input.Symbol.Length >= 11, "Invalid NFT symbol format");
Assert(IsNumeric(input.Symbol.Substring(2)), "NFT symbol must have numeric suffix");
```

## Proof of Concept

```csharp
[Fact]
public async Task NFTTypeInconsistency_CrossChainCreate()
{
    // Setup: Attacker has SEED NFT
    var attacker = SampleAccount.Accounts[0];
    await PrepareForTokenCreation(attacker.Address, "BA123456789");
    
    // Step 1: Create token with symbol starting with "BA" but metadata claiming "Art"
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "BA123456789",
        TokenName = "Malicious NFT",
        TotalSupply = 1000,
        Decimals = 0,
        Issuer = attacker.Address,
        IsBurnable = true,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                ["aelf_nft_type"] = "Art",  // Claims to be Art
                ["aelf_nft_base_uri"] = "https://example.com",
                ["aelf_nft_token_id_reuse"] = "false"
            }
        }
    });
    
    // Step 2: Call CrossChainCreate
    await NFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
    {
        Symbol = "BA123456789"
    });
    
    // Verify inconsistency
    var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue 
    { 
        Value = "BA123456789" 
    });
    
    // NftType field says "Badges" (from "BA" prefix)
    protocolInfo.NftType.ShouldBe("Badges");
    
    // But metadata says "Art"
    protocolInfo.Metadata.Value["aelf_nft_type"].ShouldBe("Art");
    
    // Inconsistency confirmed!
}
```

## Notes

The legitimate `Create` method enforces proper symbol format and metadata consistency: [8](#0-7) [9](#0-8) 

However, `CrossChainCreate` bypasses these protections by assuming all symbols follow the legitimate format without validation. The method appears designed for cross-chain scenarios where tokens already exist, but lacks safeguards against malformed or inconsistent inputs.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-79)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L89-90)
```csharp
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L95-107)
```csharp
        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L184-201)
```csharp
    private ExternalInfo GetTokenExternalInfo(CreateInput input)
    {
        if (input.Metadata != null) AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var tokenExternalInfo = input.Metadata == null
            ? new ExternalInfo()
            : new ExternalInfo
            {
                Value = { input.Metadata.Value }
            };

        // Add NFT Type to external info.
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
        // Add Uri to external info.
        tokenExternalInfo.Value[NftBaseUriMetadataKey] = input.BaseUri;
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
        return tokenExternalInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L238-249)
```csharp
    public override StringList GetReservedExternalInfoKeyList(Empty input)
    {
        return new StringList
        {
            Value =
            {
                TokenContractConstants.LockCallbackExternalInfoKey,
                TokenContractConstants.LogEventExternalInfoKey,
                TokenContractConstants.TransferCallbackExternalInfoKey,
                TokenContractConstants.UnlockCallbackExternalInfoKey
            }
        };
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L7-9)
```csharp
    private const string NftTypeMetadataKey = "aelf_nft_type";
    private const string NftBaseUriMetadataKey = "aelf_nft_base_uri";
    private const string NftTokenIdReuseMetadataKey = "aelf_nft_token_id_reuse";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-36)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L53-53)
```csharp
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
```
