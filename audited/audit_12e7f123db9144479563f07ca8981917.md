# Audit Report

## Title
Inconsistent Vote Counting Allows Governance Manipulation Through Member Removal

## Summary
The Association contract contains a critical inconsistency in its vote counting logic: approval, rejection, and abstention counts are filtered by current membership, while the total vote count includes all historical votes. This allows organizations to retroactively convert rejected proposals into releasable proposals by removing dissenting members, fundamentally undermining governance integrity.

## Finding Description

The vulnerability exists in the threshold validation logic within the Association contract's helper methods. The contract enforces governance thresholds inconsistently when checking if a proposal can be released.

**The Inconsistency:**

When checking approval counts, the contract filters by current membership: [1](#0-0) 

When checking rejection counts, the contract also filters by current membership: [2](#0-1) 

When checking abstention counts, the contract also filters by current membership: [3](#0-2) 

However, when checking total votes, the contract counts ALL historical votes WITHOUT filtering: [4](#0-3) 

**The Exploitation Mechanism:**

The `RemoveMember()` function removes addresses from the organization's member list but does NOT clear their historical votes from proposals: [5](#0-4) 

**Attack Flow:**

1. A proposal receives votes that cause it to be rejected (e.g., 4 rejections exceeding a maximal rejection threshold of 3)
2. The `IsProposalRejected()` check returns true because rejection count exceeds threshold: [6](#0-5) 

3. The organization passes a separate proposal to remove dissenting members
4. After removal, the same proposal is rechecked:
   - Filtered rejection count drops (removed members' votes no longer count)
   - Filtered approval count stays the same (approving members still present)
   - Unfiltered total vote count stays the same (historical votes preserved)
5. The proposal that was previously rejected now passes all thresholds and becomes releasable

The release mechanism validates thresholds here: [7](#0-6) 

And is enforced during proposal release: [8](#0-7) 

## Impact Explanation

**Critical Governance Integrity Violation:**

This vulnerability breaks the fundamental democratic guarantee that a properly rejected proposal remains rejected. Organizations can manipulate governance outcomes by:

1. **Retroactive Legitimization**: Converting legitimately rejected proposals into executable actions
2. **Threshold Circumvention**: Bypassing maximal rejection thresholds designed to protect minority rights
3. **Consensus Invalidation**: Executing proposals that failed to achieve required democratic consensus

**Concrete Attack Scenario:**
- Organization: 10 members (A-J)
- Thresholds: `minimal_approval=4`, `maximal_rejection=3`, `minimal_vote=7`
- Proposal P1: 4 approve (A,B,C,D), 4 reject (E,F,G,H)
- Initial status: 4 rejections > 3 threshold → **REJECTED**
- Action: Pass proposal P2 to remove members E and F
- New status: approvals=4 (≥4✓), rejections=2 (≤3✓), total_votes=8 (≥7✓) → **RELEASABLE**

The severity is Critical because it undermines the core governance mechanism that organizations rely on for decentralized decision-making.

## Likelihood Explanation

**Medium-High Likelihood:**

**Attack Complexity:** Medium - Requires coordinating two proposals:
1. The target proposal that gets rejected
2. A member removal proposal to eliminate dissenters

**Feasibility:** High - The attack uses only standard, legitimate contract functions:
- `RemoveMember()` is an intended governance function
- No special privileges beyond normal proposal approval are required
- All steps are executable within standard AElf contract semantics

**Realistic Scenarios:**

1. **Deliberate Manipulation**: A majority coalition can intentionally manipulate governance by removing opposition
2. **Accidental Exploitation**: Organizations naturally remove inactive or malicious members, unintentionally causing old rejected proposals to become valid
3. **Systematic Abuse**: Attackers can systematically bypass rejection thresholds across multiple proposals

**Detection Difficulty:** The behavior appears as normal governance operations with no explicit indicators of exploitation, making it difficult to detect or prevent.

## Recommendation

**Fix the inconsistency by applying membership filtering consistently to all vote counts:**

Modify `CheckEnoughVoteAndApprovals()` to filter the total vote count by current membership:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough = approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter all vote counts by current membership
    var totalVoteCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
                         proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
                         proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
    
    var isVoteThresholdReached = totalVoteCount >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

**Alternative Solution:** Clear historical votes from proposals when members are removed:

```csharp
public override Empty RemoveMember(Address input)
{
    var organization = State.Organizations[Context.Sender];
    Assert(organization != null, "Organization not found.");
    var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
    Assert(removeResult, "Remove member failed.");
    
    // Clear the removed member's votes from all active proposals
    ClearMemberVotesFromProposals(Context.Sender, input);
    
    Assert(Validate(organization), "Invalid organization.");
    State.Organizations[Context.Sender] = organization;
    Context.Fire(new MemberRemoved { OrganizationAddress = Context.Sender, Member = input });
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public void VoteCountingInconsistency_AllowsGovernanceManipulation()
{
    // Setup: Create organization with 10 members and specific thresholds
    var members = new[] { "A", "B", "C", "D", "E", "F", "G", "H", "I", "J" }
        .Select(x => Address.FromPublicKey(Encoding.UTF8.GetBytes(x))).ToList();
    
    var organizationAddress = CreateOrganizationWithMembers(members, 
        minimalApproval: 4, maximalRejection: 3, minimalVote: 7);
    
    // Step 1: Create proposal P1
    var proposalId = CreateProposal(organizationAddress, members[0]);
    
    // Step 2: Vote on P1 - 4 approve, 4 reject (should be rejected)
    ApproveAsMembers(proposalId, members.Take(4)); // A,B,C,D approve
    RejectAsMembers(proposalId, members.Skip(4).Take(4)); // E,F,G,H reject
    
    // Step 3: Verify P1 is rejected (4 rejections > 3 threshold)
    var proposal1Status = GetProposal(proposalId);
    Assert.False(proposal1Status.ToBeReleased); // Should NOT be releasable
    
    // Step 4: Remove dissenting members E and F
    RemoveMembersViaProposal(organizationAddress, new[] { members[4], members[5] }); // Remove E, F
    
    // Step 5: Check P1 again - it should STILL be rejected but now becomes releasable
    var proposal1StatusAfterRemoval = GetProposal(proposalId);
    
    // VULNERABILITY: Proposal is now releasable despite being initially rejected
    Assert.True(proposal1StatusAfterRemoval.ToBeReleased); 
    
    // The proposal can now be released by the proposer
    ReleaseProposal(proposalId, members[0]);
    
    // Assertion: This proves the vulnerability - a rejected proposal became executable
}
```

**Notes:**

The vulnerability fundamentally breaks the governance invariant that rejection thresholds provide permanent protection against unwanted proposals. While the attack requires majority support to remove members, this is precisely the scenario the rejection threshold is designed to prevent - majority tyranny over dissenting minorities. The inconsistency between filtered individual vote categories and unfiltered total vote count creates a loophole that undermines the democratic guarantees the threshold system was meant to provide.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
