### Title
Integer Overflow DoS in NFT Protocol Number Generation Due to Incorrect Type Inference

### Summary
The `GetCurrentNumberLength()` function uses an `int` type for the local variable `protocolNumber` when calculating powers of 10, but the calculation requires values up to 10^10 that exceed `int.MaxValue` (2,147,483,647). When `CurrentSymbolNumberLength` reaches 11, the checked multiplication throws an `OverflowException`, causing permanent denial-of-service for all NFT protocol creation operations.

### Finding Description

The vulnerability exists in the `GetCurrentNumberLength()` function at two locations where `protocolNumber` is calculated: [1](#0-0) [2](#0-1) 

The root cause is a type inference issue. The local variable `protocolNumber` is initialized with the integer literal `1`, causing C# to infer it as `int` (32-bit) rather than `long` (64-bit). The loop calculates `10^(CurrentSymbolNumberLength - 1)` through repeated multiplication by 10. [3](#0-2) 

Starting from `NumberMinLength = 9`, the system tracks a protocol number flag that grows as more NFT protocols are created: [4](#0-3) 

When `CurrentSymbolNumberLength` reaches 11, the calculation attempts to compute 10^10 = 10,000,000,000, which exceeds `int.MaxValue` (2,147,483,647). The SafeMath multiplication implementation uses checked arithmetic: [5](#0-4) 

This correctly throws an `OverflowException` to prevent silent integer wraparound, but causes the entire transaction to fail. The state variables are properly typed to handle large values: [6](#0-5) 

However, the local variable calculation fails before the value can be stored.

### Impact Explanation

**Operational DoS of Core Functionality**: Once `CurrentSymbolNumberLength` reaches 11, all calls to `Create()` will fail permanently with an `OverflowException`. The NFT protocol creation functionality becomes completely unusable: [7](#0-6) [8](#0-7) 

**Affected Parties**: All users attempting to create new NFT protocols on the platform will be unable to do so. This impacts:
- NFT creators who cannot deploy new collections
- Platform operations that rely on NFT protocol creation
- The entire NFT ecosystem on the chain

**Severity Justification**: This is a High severity issue because:
1. It causes permanent, unrecoverable DoS of a core contract function
2. No administrative action can restore functionality without contract upgrade
3. The threshold (length 11) is reachable through normal protocol usage
4. Once triggered, the impact is immediate and total

### Likelihood Explanation

**Natural Occurrence**: The vulnerability will trigger through normal platform growth:
- Starting at length 9, the system can generate up to 10^9 - 10^8 = 900,000,000 unique protocols
- As more protocols are created, the flag grows and eventually triggers the length increment
- Once length 10 is reached, another ~9 billion protocols can be created before hitting length 11
- At length 11, overflow occurs immediately

**Attack Acceleration**: An attacker can deliberately accelerate reaching this threshold by:
1. Creating multiple NFT protocols (each call to `Create()` increments usage counters)
2. Each creation costs gas fees but is otherwise unrestricted
3. Attack complexity: Low - simply call `Create()` repeatedly with valid inputs
4. Detection: Difficult - appears as legitimate protocol creation until overflow occurs

**Execution Practicality**: 
- Entry point is the public `Create()` method - no special permissions required
- No preconditions beyond standard transaction fees
- Attack is executable under normal AElf contract execution model
- Economic cost is reasonable for an attacker seeking to DoS the protocol

**Probability**: Medium to High
- Will definitely occur given sufficient protocol growth
- Can be accelerated by malicious actors
- No protective mechanisms exist to prevent reaching the overflow threshold

### Recommendation

**Immediate Fix**: Change the type inference from `int` to `long` by using the long literal suffix:

Replace lines 96 and 108 from:
```csharp
var protocolNumber = 1;
```

To:
```csharp
var protocolNumber = 1L;
```

This ensures the variable is typed as `long` (64-bit), allowing calculations up to 10^18 before overflow, which is practically unlimited for this use case.

**Additional Safeguards**:
1. Add an assertion to validate `CurrentSymbolNumberLength` stays within safe bounds (e.g., `< 18`)
2. Add unit tests that verify the calculation succeeds for length values up to at least 15
3. Consider adding explicit type declarations rather than relying on type inference for critical numeric calculations

**Test Cases**:
```csharp
// Test that protocolNumber calculation succeeds for high length values
[Fact]
public void GetCurrentNumberLength_Should_Handle_Large_Lengths()
{
    // Test lengths 9 through 15
    for (int length = 9; length <= 15; length++)
    {
        var result = CalculateProtocolNumber(length);
        Assert.True(result > 0);
        Assert.Equal(Math.Pow(10, length - 1), result);
    }
}
```

### Proof of Concept

**Initial State**:
- Contract deployed with `NumberMinLength = 9`
- `CurrentSymbolNumberLength.Value = 0` (will be initialized to 9)
- `NftProtocolNumberFlag.Value = 0`

**Transaction Sequence**:

1. **First Creation** - Call `Create()`:
   - `GetCurrentNumberLength()` initializes `CurrentSymbolNumberLength = 9`
   - Calculates `protocolNumber = 10^8 = 100,000,000` ✓ Success
   - Stores flag and creates protocol

2. **Continued Growth** - Create protocols until length increment:
   - Through normal usage, flag grows
   - When `flag * 2` exceeds 9 digits, increment to length 10
   - Next call calculates `protocolNumber = 10^9 = 1,000,000,000` ✓ Success

3. **Critical Threshold** - Continue until next increment:
   - When `flag * 2` exceeds 10 digits, attempt increment to length 11
   - Calculation attempts: `protocolNumber = 10^10 = 10,000,000,000`
   - `10,000,000,000 > int.MaxValue (2,147,483,647)`
   - SafeMath.Mul() throws `OverflowException` ✗ Transaction fails

4. **Permanent DoS** - All subsequent `Create()` calls:
   - `CurrentSymbolNumberLength.Value = 11` (stored in previous call)
   - Every call attempts to calculate `10^10` with int arithmetic
   - Every call fails with `OverflowException`
   - NFT creation is permanently disabled

**Expected Result**: Protocol number calculated successfully and protocol created

**Actual Result**: `OverflowException` thrown, transaction reverted, contract functionality permanently disabled

**Success Condition**: The overflow exception occurs when `CurrentSymbolNumberLength = 11`, demonstrating the vulnerability is real and exploitable through normal contract usage.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-67)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L96-97)
```csharp
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L103-107)
```csharp
        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L108-109)
```csharp
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L13-19)
```csharp
    public static int Mul(this int a, int b)
    {
        checked
        {
            return a * b;
        }
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L8-9)
```csharp
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```
