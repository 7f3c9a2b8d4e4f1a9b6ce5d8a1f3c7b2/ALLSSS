### Title
Insufficient Validation in SetMinerIncreaseInterval Allows Zero or Negative Values Causing Division by Zero and Consensus Disruption

### Summary
The `SetMinerIncreaseInterval` function fails to validate that the input interval is positive, only checking that it's less than or equal to the current value. This allows a malicious or compromised governance authority to set the interval to zero (causing division by zero exceptions) or negative values (causing incorrect miner count calculations that decrease over time), leading to consensus halt or system instability.

### Finding Description

The vulnerability exists in the `SetMinerIncreaseInterval` function which accepts an `Int64Value` parameter but performs inadequate validation: [1](#0-0) 

The only validation performed is checking that `input.Value <= State.MinerIncreaseInterval.Value`, which allows:
- **Zero values**: `0 <= 31536000` passes validation
- **Negative values**: `-1000000 <= 31536000` passes validation

The `MinerIncreaseInterval` value is subsequently used in division operations in two critical consensus calculation functions: [2](#0-1) [3](#0-2) 

The division operation uses the `SafeMath.Div` extension method for `long`, which does not protect against division by zero: [4](#0-3) 

This simple division operator will throw a `DivideByZeroException` when the denominator is zero.

The `GetMinersCount` function is called during critical consensus operations:
- During round transitions in `ProcessConsensusInformation`
- When updating miners count to the Election contract in `UpdateMinersCountToElectionContract`
- When setting maximum miners count [5](#0-4) [6](#0-5) 

### Impact Explanation

**Division by Zero Scenario (Critical Impact):**
If `MinerIncreaseInterval` is set to zero, any subsequent call to `GetMinersCount` or `GetAutoIncreasedMinersCount` will throw a `DivideByZeroException`. Since these functions are called during:
- Consensus round transitions (every round change)
- Term transitions (every term change) 
- Setting maximum miners count
- Public view method `GetMaximumMinersCount`

The result is a **complete consensus halt** - miners cannot produce blocks because the consensus information processing fails with an unhandled exception.

**Negative Value Scenario (High Impact):**
If `MinerIncreaseInterval` is set to a negative value (e.g., -31,536,000), the miner count calculation becomes:
```
MinersCount = 17 + (elapsed_seconds / negative_interval) * 2
```

This causes the miner count to **decrease over time** instead of increase:
- After 1 year with interval = -31,536,000: `17 + (-1) * 2 = 15` miners
- After 10 years: `17 + (-10) * 2 = -3` miners (negative!)

A negative miner count would cause undefined behavior in consensus logic, potentially leading to system crashes or inability to form valid mining schedules.

**Affected Parties:**
- All network participants: block production stops
- Validators: cannot perform consensus duties
- Users: transactions cannot be processed
- The entire blockchain halts

### Likelihood Explanation

**Attacker Capabilities Required:**
The attacker must control the `MaximumMinersCountController`, which by default is the Parliament default organization: [7](#0-6) 

This means the attack requires:
- Compromised governance (Parliament votes to approve malicious proposal), OR
- Malicious majority of Parliament members, OR  
- Exploitation of separate governance vulnerabilities

**Attack Complexity:**
Once governance control is achieved, the attack is trivial:
1. Create Parliament proposal to call `SetMinerIncreaseInterval(0)` or `SetMinerIncreaseInterval(-1000000)`
2. Get proposal approved through normal governance process
3. Execute the proposal
4. Wait for next consensus operation (happens automatically with every block/round)

**Feasibility Assessment:**
- Entry point is public and reachable: `SetMinerIncreaseInterval` is a standard governance-controlled function
- Preconditions are realistic: governance compromise scenarios exist in practice
- Execution is guaranteed: the validation logic definitively allows zero and negative values
- Impact is immediate: next consensus operation will fail

**Detection Constraints:**
The malicious parameter change would be visible on-chain in the transaction executing the governance proposal, but by the time it's detected, the damage is done - consensus halts immediately upon the next calculation.

**Probability Reasoning:**
While governance compromise is a non-trivial prerequisite, this vulnerability represents a critical failure of input validation that violates basic security principles. The function should enforce domain constraints (positive values) regardless of access control assumptions. The Medium severity rating in the original question is justified given the governance prerequisite, but the impact is Critical once exploited.

### Recommendation

Add explicit positive value validation in the `SetMinerIncreaseInterval` function:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Miner increase interval must be positive.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

**Additional Safeguards:**
1. Add a minimum threshold check (e.g., `input.Value >= 86400` for at least 1 day) to prevent unreasonably small intervals that could cause arithmetic issues
2. Consider adding a maximum decrease limit per update (e.g., cannot reduce by more than 50% at once) to prevent drastic changes
3. Add test cases covering:
   - Rejection of zero value
   - Rejection of negative values
   - Rejection of values exceeding current interval
   - Successful update with valid positive value less than current

### Proof of Concept

**Initial State:**
- AEDPoS contract initialized with `MinerIncreaseInterval = 31536000` (1 year in seconds)
- Parliament contract controls `MaximumMinersCountController`
- Consensus is operating normally

**Attack Steps:**

1. **Parliament creates malicious proposal:**
   ```
   CreateProposal(
     ToAddress: ConsensusContract,
     Method: "SetMinerIncreaseInterval",
     Params: Int64Value { Value = 0 },
     OrganizationAddress: ParliamentDefaultOrg
   )
   ```

2. **Proposal gets approved and executed:**
   - Parliament members vote and approve
   - Proposal is released and executed
   - `State.MinerIncreaseInterval.Value` is now `0`

3. **Next block production triggers consensus calculation:**
   - Miner produces block, calls `UpdateValue` or `NextRound`
   - Consensus processing calls `GetMinersCount(round)`
   - Line 390 executes: `.Div(State.MinerIncreaseInterval.Value)` = `.Div(0)`
   - `SafeMath.Div` performs `a / 0`
   - `DivideByZeroException` is thrown

4. **Expected Result:** Transaction succeeds, state is updated
5. **Actual Result:** Unhandled exception crashes consensus processing, block production fails, entire chain halts

**Success Condition:** 
The vulnerability is confirmed if:
- `SetMinerIncreaseInterval(0)` transaction succeeds without revert
- Subsequent consensus operations throw `DivideByZeroException`
- Block production ceases

The test suite currently validates the "decrease is allowed" case but never tests zero or negative values: [8](#0-7)

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L31-43)
```csharp
    private void RequiredMaximumMinersCountControllerSet()
    {
        if (State.MaximumMinersCountController.Value != null) return;
        EnsureParliamentContractAddressSet();

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MaximumMinersCountController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L115-137)
```csharp

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L108-147)
```csharp
    [Fact]
    public async Task SetMinerIncreaseIntervalTest()
    {
        InitialContracts();
        await BlockMiningService.MineBlockToNextTermAsync();

        InitialAcs3Stubs();
        await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput());
        var minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
        
        var defaultOrganizationAddress =
            await ParliamentStubs.First().GetDefaultOrganizationAddress.CallAsync(new Empty());

        var transactionResult = await ParliamentReachAnAgreementWithExceptionAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = minerIncreaseInterval.Value + 1
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        transactionResult.Error.ShouldContain("Invalid interval");
        var newMinerIncreaseInterval = minerIncreaseInterval.Value - 1;
        await ParliamentReachAnAgreementAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = newMinerIncreaseInterval
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
        minerIncreaseInterval.Value.ShouldBe(newMinerIncreaseInterval);
    }
```
