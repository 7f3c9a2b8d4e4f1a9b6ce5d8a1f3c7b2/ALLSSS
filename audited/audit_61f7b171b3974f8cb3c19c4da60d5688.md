### Title
Method Fee Controller Can Be Permanently Locked via Malicious Contract Address Validation

### Summary
The `ChangeMethodFeeController()` function in VoteContract validates organization existence by calling `ValidateOrganizationExist` on the user-provided `input.ContractAddress`, without verifying that this contract address is a legitimate governance contract (Parliament/Association/Referendum). An attacker controlling the current governance organization can pass a proposal with a malicious contract as `ContractAddress` that falsely validates an empty/zero `OwnerAddress`, permanently locking method fee control since `Context.Sender` can never equal an empty address.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController()` function: [1](#0-0) 

The validation flow calls `CheckOrganizationExist(input)`: [2](#0-1) 

**Root Cause**: The function performs a cross-contract call to `input.ContractAddress` without validating that it's a legitimate governance system contract. It trusts whatever boolean value the target contract returns.

When `input.ContractAddress` points to a legitimate governance contract (Parliament/Association/Referendum), the validation works correctly because these contracts check `State.Organizations[input] != null`: [3](#0-2) 

However, an attacker can deploy a malicious contract that always returns `true` for `ValidateOrganizationExist`, allowing an empty address to pass validation. Once set, line 25's authorization check `Context.Sender == State.MethodFeeController.Value.OwnerAddress` can never succeed since `Context.Sender` cannot be an empty address in normal operation.

### Impact Explanation

**Operational Impact - Critical**: Permanent denial of service for method fee management.

Once the `MethodFeeController.OwnerAddress` is set to an empty address:
- All future calls to `SetMethodFee()` fail at authorization check [4](#0-3) 

- All future calls to `ChangeMethodFeeController()` fail at line 25 since `Context.Sender` can never equal an empty address
- Method fees become permanently frozen at current values
- No governance mechanism can recover control

This affects all users of the Vote contract who must pay transaction fees, as fees cannot be adjusted for changing economic conditions or disabled for critical operations.

### Likelihood Explanation

**Likelihood: Medium-High given governance compromise**

**Attacker Capabilities Required**:
- Control of current MethodFeeController governance organization (typically Parliament default organization, requiring approval from 2/3 of block producers)
- Ability to deploy a malicious contract
- Ability to craft and pass a governance proposal

**Attack Complexity**: Low once governance control is achieved
1. Deploy malicious contract that returns `true` for any `ValidateOrganizationExist` call
2. Create proposal to call `ChangeMethodFeeController` with `{ContractAddress: maliciousContract, OwnerAddress: new Address()}`
3. Pass proposal through governance
4. Release proposal to execute the lock

**Detection Constraints**: The malicious ContractAddress in the proposal may not be immediately obvious to voters who might assume it's a legitimate governance contract address.

**Feasibility**: The attack is executable under AElf contract semantics. While it requires governance compromise, the lack of input validation creates a permanent damage vector that's worse than other governance attacks (which might be reversible).

### Recommendation

Add validation to ensure `input.ContractAddress` is a recognized governance system contract:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    
    // Add validation that ContractAddress is a legitimate governance contract
    var validGovernanceContracts = new[] {
        Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName),
        Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName),
        Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName)
    };
    Assert(validGovernanceContracts.Contains(input.ContractAddress), 
        "ContractAddress must be a recognized governance contract.");
    
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    State.MethodFeeController.Value = input;
    return new Empty();
}
```

Additionally, add explicit validation that `OwnerAddress` is not empty:
```csharp
Assert(input.OwnerAddress != null && !input.OwnerAddress.Value.IsNullOrEmpty(), 
    "OwnerAddress cannot be empty.");
```

**Test Cases**:
1. Test rejection when ContractAddress is not a governance system contract
2. Test rejection when OwnerAddress is empty/null
3. Test successful change with valid Parliament/Association/Referendum organizations

### Proof of Concept

**Initial State**:
- Vote contract deployed with default MethodFeeController = Parliament default organization

**Attack Steps**:
1. Attacker controls Parliament default organization (has 2/3 BP approval)
2. Attacker deploys `MaliciousValidator` contract:
   ```csharp
   public override BoolValue ValidateOrganizationExist(Address input) {
       return new BoolValue { Value = true }; // Always returns true
   }
   ```
3. Create Parliament proposal to call `VoteContract.ChangeMethodFeeController`:
   - Input: `{ContractAddress: MaliciousValidator, OwnerAddress: new Address()}`
4. Approve and release proposal
5. Proposal executes successfully (validation passes via malicious contract)

**Expected Result**: Transaction should fail with "ContractAddress must be a recognized governance contract"

**Actual Result**: Transaction succeeds, `MethodFeeController.OwnerAddress` = empty address

**Success Condition Verification**:
- Call `GetMethodFeeController()` returns `OwnerAddress` with empty value
- Subsequent calls to `SetMethodFee()` or `ChangeMethodFeeController()` from any address fail with authorization error
- Controller is permanently locked

**Notes**:
The same vulnerability pattern exists in other ACS1-implementing contracts that use identical validation logic without verifying the ContractAddress field, including MultiToken, Parliament, Association, and other system contracts that manage method fee controllers.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L92-97)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```
