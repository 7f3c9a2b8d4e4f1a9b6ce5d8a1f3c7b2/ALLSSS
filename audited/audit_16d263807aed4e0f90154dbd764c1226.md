# Audit Report

## Title
Member Removal Invalidates Previously Approved Proposals Due to Retroactive Vote Counting

## Summary
The Association contract's `RemoveMember` function allows removal of organization members after they have voted on proposals. The vote counting logic only considers votes from current members, causing previously approved proposals to become permanently unreleasable when voting members are removed, breaking the fundamental governance invariant that approved proposals remain executable.

## Finding Description

The vulnerability exists in the interaction between member removal and vote counting mechanisms in the Association contract.

**Vote Counting Logic:** The proposal release threshold check filters votes by current membership. The `CheckEnoughVoteAndApprovals` method counts approvals only from addresses currently in the organization member list [1](#0-0) , and similarly for rejections [2](#0-1)  and abstentions [3](#0-2) .

**Member Removal Function:** The `RemoveMember` function removes members from the organization and validates only structural organization constraints [4](#0-3) . It does not check whether the removed member has voted on any active proposals, nor does it clean up their votes from existing proposals.

**Insufficient Validation:** The `Validate` method checks structural constraints between thresholds and member count [5](#0-4)  but does not prevent removal of members who have voted on active proposals.

**Root Cause:** Proposals store voter addresses permanently in their approval/rejection/abstention lists (added via `Approve`, `Reject`, `Abstain` methods [6](#0-5) ). However, the counting logic filters these lists by current membership using `organization.OrganizationMemberList.Contains()`. When a member who has voted is removed, their vote disappears from all threshold calculations retroactively, despite still being in the proposal's vote lists.

## Impact Explanation

**Governance Deadlock:** Proposals that had achieved the required approval threshold become permanently stuck and unreleasable after voting members are removed. The proposal remains valid (not expired) but can never reach the threshold again if enough voting members are removed.

**Concrete Example:**
- Organization: 5 members [A, B, C, D, E]
- Thresholds: MinimalApprovalThreshold=3, MaximalRejectionThreshold=1
- Proposal receives 3 approvals from A, B, C (meets threshold, ready to release)
- Member A is removed via governance action
- New member count: 4 members [B, C, D, E]
- Validation passes: MaximalRejectionThreshold + MinimalApprovalThreshold = 1 + 3 = 4 ≤ 4 ✓
- Approval count recalculated by `CheckEnoughVoteAndApprovals`: only 2 (B, C counted) - A's vote no longer counts
- Proposal now fails threshold check: 2 < 3 (permanently unreleasable)

**Who is Affected:** All Association organizations, particularly those with active proposals during member transitions. This affects critical governance operations including treasury management, parameter changes, and cross-contract calls.

**Severity Justification:** HIGH - This breaks a fundamental governance invariant (approved proposals remain approved) and can lead to permanent loss of governance capability for critical operations.

## Likelihood Explanation

**Reachable Entry Point:** The `RemoveMember` function is a public method callable through the organization's own governance process [7](#0-6) . It uses `Context.Sender` as the organization address, meaning it must be called via the organization's virtual address through a governance proposal.

**Feasible Preconditions:**
- Organization exists with active proposals (normal state)
- Members vote on proposals (intended functionality)
- Organization needs to remove members (normal operation for member turnover, departures, or security reasons)

**Execution Practicality:** 
1. Organization creates and votes on proposal X (reaches approval threshold)
2. Organization creates proposal Y to remove a member who voted on X
3. Proposal Y is approved and released via the normal `Release` method [8](#0-7) 
4. Member is removed via `RemoveMember`
5. Proposal X becomes unreleasable despite having previously met threshold

**Attack Complexity:** Low - Can occur accidentally during normal operations or be exploited maliciously. An organization member could vote to approve a critical proposal, then propose and execute their own removal to block the critical proposal from ever executing.

**Economic Rationality:** Removing members costs only governance proposal execution fees. The damage (blocked proposals) far exceeds the cost, making this economically rational for malicious actors.

## Recommendation

Add validation in `RemoveMember` to prevent removal of members who have voted on active (non-expired, non-released) proposals. 

Recommended fix:
```csharp
public override Empty RemoveMember(Address input)
{
    var organization = State.Organizations[Context.Sender];
    Assert(organization != null, "Organization not found.");
    
    // Check if member has voted on any active proposals
    Assert(!HasActiveVotes(input, Context.Sender), 
        "Cannot remove member with votes on active proposals.");
    
    var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
    Assert(removeResult, "Remove member failed.");
    Assert(Validate(organization), "Invalid organization.");
    State.Organizations[Context.Sender] = organization;
    Context.Fire(new MemberRemoved
    {
        OrganizationAddress = Context.Sender,
        Member = input
    });
    return new Empty();
}

private bool HasActiveVotes(Address member, Address organizationAddress)
{
    // Iterate through active proposals for this organization
    // Check if member appears in any approval/rejection/abstention lists
    // Return true if found, false otherwise
}
```

Alternative approach: Snapshot the member list at proposal creation time and use that snapshot for vote counting instead of the current member list.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveMember_InvalidatesPreviouslyApprovedProposal_Test()
{
    // Setup: Create organization with 5 members, threshold requires 3 approvals
    var minimalApprovalThreshold = 3;
    var minimalVoteThreshold = 3;
    var maximalAbstentionThreshold = 0;
    var maximalRejectionThreshold = 1;
    
    var member4 = Accounts[4].Address;
    var member5 = Accounts[5].Address;
    
    var createOrganizationInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { Reviewer1, Reviewer2, Reviewer3, member4, member5 }
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = minimalApprovalThreshold,
            MinimalVoteThreshold = minimalVoteThreshold,
            MaximalAbstentionThreshold = maximalAbstentionThreshold,
            MaximalRejectionThreshold = maximalRejectionThreshold
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { Reviewer1 }
        }
    };
    var organizationAddress = await AssociationContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    
    // Create proposal and get 3 approvals (meets threshold)
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress.Output);
    await ApproveAsync(Reviewer1KeyPair, proposalId);
    await ApproveAsync(Reviewer2KeyPair, proposalId);
    await ApproveAsync(Reviewer3KeyPair, proposalId);
    
    // Verify proposal is ready to release
    var proposal1 = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal1.ToBeReleased.ShouldBeTrue();
    proposal1.ApprovalCount.ShouldBe(3);
    
    // Remove one of the voting members via governance
    var removeMemberProposal = await CreateAssociationProposalAsync(
        Reviewer1KeyPair, 
        Reviewer1, 
        nameof(AssociationContractStub.RemoveMember),
        organizationAddress.Output);
    
    await ApproveAsync(Reviewer2KeyPair, removeMemberProposal);
    await ApproveAsync(Reviewer3KeyPair, removeMemberProposal);
    await ApproveAsync(member4KeyPair, removeMemberProposal);
    
    var associationContractStub = GetAssociationContractTester(Reviewer1KeyPair);
    await associationContractStub.Release.SendAsync(removeMemberProposal);
    
    // Verify original proposal is NOW unreleasable despite having 3 approval votes stored
    var proposal2 = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal2.ApprovalCount.ShouldBe(3); // Still shows 3 votes stored
    proposal2.ToBeReleased.ShouldBeFalse(); // But NO LONGER releasable!
    
    // Attempting to release fails
    var releaseResult = await associationContractStub.Release.SendWithExceptionAsync(proposalId);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved.");
}
```

## Notes

This vulnerability is particularly insidious because:

1. **Silent Failure**: The proposal's stored vote counts don't change (ApprovalCount still shows 3), but the release threshold calculation silently excludes removed members' votes.

2. **No Audit Trail**: There's no event or state change on the proposal when a voter is removed, making it difficult to detect the issue.

3. **Permanent Deadlock**: Unlike expired proposals which can be cleared, these proposals remain permanently stuck in a valid-but-unreleasable state.

4. **Systemic Risk**: This affects the Association contract which is used throughout the AElf ecosystem for governance of critical system parameters and treasury operations.

5. **Design Intent Violation**: The proposal approval mechanism is designed to be immutable once votes are cast (enforced by the "Sender already voted" check [9](#0-8) ), but member removal creates a backdoor to retroactively invalidate votes.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L37-37)
```csharp
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-181)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }

    public override Empty Reject(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Rejections.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Reject),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }

    public override Empty Abstain(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Abstentions.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Abstain),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
