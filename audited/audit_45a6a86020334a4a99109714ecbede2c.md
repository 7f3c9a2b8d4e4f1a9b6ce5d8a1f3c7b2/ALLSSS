# Audit Report

## Title
Large ByteString DoS via Unconstrained OutValue and Signature Fields in Consensus Validation

## Summary
The `NewConsensusInformationFilled` validation method in the AEDPoS consensus contract only verifies that `OutValue` and `Signature` ByteStrings are non-empty using `.Any()`, without enforcing the expected 32-byte hash size. A malicious elected miner can produce blocks with arbitrarily large ByteStrings (up to the 100MB network limit) that pass validation but cause resource exhaustion during protobuf deserialization across all validating nodes.

## Finding Description

The vulnerability exists in the consensus validation pipeline where `OutValue` and `Signature` fields are validated. The `NewConsensusInformationFilled` method performs only a minimal existence check instead of validating the expected hash size. [1](#0-0) 

The validation only checks if the ByteStrings contain at least one byte, not that they are exactly 32 bytes as required for SHA256 hashes. The `Hash` protobuf type itself has no size constraint: [2](#0-1) 

While `Hash.LoadFromByteArray()` enforces 32-byte validation, this method is never called during the validation flow: [3](#0-2) 

Legitimate values are always 32-byte hashes generated via `HashHelper.ComputeFrom`: [4](#0-3) [5](#0-4) 

**Attack Execution Path:**

1. Entry point: `ValidateConsensusBeforeExecution` parses consensus data via protobuf deserialization [6](#0-5) 

2. The validation pipeline invokes `UpdateValueValidationProvider` for `UpdateValue` behavior [7](#0-6) 

3. `RecoverFromUpdateValue` directly assigns oversized values without size validation [8](#0-7) 

4. If block execution proceeds, `ProcessUpdateValue` persists oversized values to state [9](#0-8) [10](#0-9) 

The network layer permits messages up to 100MB: [11](#0-10) 

## Impact Explanation

**Medium Severity - Consensus Resource Exhaustion DoS**

This vulnerability enables a resource consumption denial-of-service attack against the consensus layer:

1. **Memory Exhaustion**: Protobuf parsing allocates memory proportional to ByteString size. A malicious miner could embed 10-20MB in each field within the 100MB gRPC limit, causing significant memory consumption.

2. **CPU Waste**: Expensive deserialization operations occur during `Parser.ParseFrom()` and subsequent `ToByteArray()` calls when computing round hashes. These operations scale with data size.

3. **Network Amplification**: The malicious block propagates to all validators via P2P gossip. Each validator independently parses and processes the same oversized data, multiplying resource consumption across the entire network.

4. **Potential State Bloat**: If validation passes and the block executes, oversized values are permanently stored in `State.Rounds`, causing long-term state storage bloat.

The severity is Medium rather than High because:
- The attack requires a compromised elected miner (not an arbitrary attacker)
- Impact is limited to resource consumption, not fund theft or state corruption
- Rate-limited by the malicious miner's block production schedule
- Eventually detectable through validation failures

However, this represents a genuine DoS vector that violates the principle that validation should be cheap and fail fast on invalid input.

## Likelihood Explanation

**Medium Likelihood**

**Attacker Capabilities Required:**
- Must be an elected block producer through the AElf election mechanism [12](#0-11) 

Miners are elected participants, not trusted system roles. They could become malicious through:
- Key compromise
- Malicious intent after legitimate election
- Coordination among multiple elected miners

**Attack Complexity:**
Once miner access is achieved, execution is straightforward:
1. Generate valid consensus trigger information
2. Modify `OutValue.Value` and `Signature.Value` ByteStrings to oversized values (e.g., 10MB each)
3. Produce and propagate the block

The `.Any()` check passes for any non-empty ByteString regardless of size, providing no protection against this attack.

**Detection:**
The block may eventually fail post-execution validation due to state inconsistencies, but resource consumption occurs before rejection across all validating nodes.

**Probability Assessment:** Medium - Requires elected miner compromise but attack execution is trivial once access is obtained.

## Recommendation

Add explicit size validation in the `NewConsensusInformationFilled` method to enforce the 32-byte hash constraint:

```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    var minerInRound =
        validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    
    // Enforce 32-byte hash size constraint
    const int expectedHashSize = 32; // AElfConstants.HashByteArrayLength
    
    return minerInRound.OutValue != null && 
           minerInRound.Signature != null &&
           minerInRound.OutValue.Value.Length == expectedHashSize && 
           minerInRound.Signature.Value.Length == expectedHashSize;
}
```

This ensures that oversized ByteStrings are rejected immediately during validation without expensive processing, preventing both the resource consumption DoS and potential state bloat.

Alternative/additional protections:
1. Add protobuf field validators at the message definition level
2. Implement size checks during initial parsing before validation
3. Add overall block consensus data size limits

## Proof of Concept

```csharp
[Fact]
public async Task OversizedOutValueAndSignature_ShouldFailValidation()
{
    // Setup: Get a valid miner with block production permission
    var miner = GetValidMinerKeyPair();
    var currentRound = await GetCurrentRoundAsync();
    
    // Create malicious consensus data with oversized OutValue and Signature
    var maliciousConsensusData = new AElfConsensusHeaderInformation
    {
        SenderPubkey = ByteString.CopyFrom(miner.PublicKey),
        Behaviour = AElfConsensusBehaviour.UpdateValue,
        Round = new Round
        {
            RoundNumber = currentRound.RoundNumber,
            RealTimeMinersInformation =
            {
                [miner.PublicKey.ToHex()] = new MinerInRound
                {
                    Pubkey = miner.PublicKey.ToHex(),
                    OutValue = new Hash { Value = ByteString.CopyFrom(new byte[10_000_000]) }, // 10MB
                    Signature = new Hash { Value = ByteString.CopyFrom(new byte[10_000_000]) }, // 10MB
                    // ... other required fields
                }
            }
        }
    };
    
    // Act: Validate the malicious block
    var result = await ConsensusStub.ValidateConsensusBeforeExecution.CallAsync(
        new BytesValue { Value = maliciousConsensusData.ToByteString() }
    );
    
    // Assert: Validation should fail but currently passes due to .Any() check
    // After fix, this should return Success = false
    result.Success.ShouldBeFalse(); // This will FAIL with current code
    result.Message.ShouldContain("Incorrect new Out Value");
}
```

**Notes:**
- Miners in AElf are elected participants through voting, not system-level trusted roles
- The validation gap allows expensive processing before rejection
- The fix should enforce the 32-byte constraint that legitimate values always satisfy

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** protobuf/aelf/core.proto (L140-143)
```text
message Hash
{
    bytes value = 1;
}
```

**File:** src/AElf.Types/Types/Hash.cs (L49-58)
```csharp
        public static Hash LoadFromByteArray(byte[] bytes)
        {
            if (bytes.Length != AElfConstants.HashByteArrayLength)
                throw new ArgumentException("Invalid bytes.", nameof(bytes));

            return new Hash
            {
                Value = ByteString.CopyFrom(bytes)
            };
        }
```

**File:** src/AElf.Types/Helper/HashHelper.cs (L15-18)
```csharp
        public static Hash ComputeFrom(byte[] bytes)
        {
            return Hash.LoadFromByteArray(bytes.ComputeHash());
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L67-69)
```csharp
        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L16-17)
```csharp
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-245)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L126-132)
```csharp
    private bool TryToUpdateRoundInformation(Round round)
    {
        var ri = State.Rounds[round.RoundNumber];
        if (ri == null) return false;
        State.Rounds[round.RoundNumber] = round;
        return true;
    }
```

**File:** src/AElf.OS.Network.Grpc/GrpcConstants.cs (L28-29)
```csharp
    public const int DefaultMaxReceiveMessageLength = 100 * 1024 * 1024;
    public const int DefaultMaxSendMessageLength = 100 * 1024 * 1024;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
