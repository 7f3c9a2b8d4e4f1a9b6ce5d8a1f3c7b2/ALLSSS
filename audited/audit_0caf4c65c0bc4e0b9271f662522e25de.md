### Title
Parliament Organization Governance Deadlock via Extreme Threshold Configuration

### Summary
The `ChangeOrganizationThreshold` function allows organizations to set threshold values that create permanent governance deadlock. Specifically, an organization can set `MinimalApprovalThreshold = 10000` (100%) with `MaximalRejectionThreshold = 0` and `MaximalAbstentionThreshold = 0`, which passes validation but makes it practically impossible to release any future proposals, including proposals to fix the thresholds. This results in permanent loss of governance capability for affected organizations, including the critical default organization.

### Finding Description

The vulnerability exists in the threshold validation logic and the `ChangeOrganizationThreshold` function. [1](#0-0) 

The `ChangeOrganizationThreshold` function accepts new threshold values and validates them using the `Validate(Organization organization)` method: [2](#0-1) 

The validation logic allows the following extreme configuration:
- `MinimalApprovalThreshold = 10000` (requires 100% miner approval)
- `MinimalVoteThreshold = 10000` (requires 100% miner participation)
- `MaximalRejectionThreshold = 0` (allows zero rejections)
- `MaximalAbstentionThreshold = 0` (allows zero abstentions)

This configuration is mathematically valid according to the validation rules, as confirmed by existing test cases: [3](#0-2) 

However, this creates a deadlock in the proposal release logic. The `IsReleaseThresholdReached` function checks rejection, abstention, and approval thresholds: [4](#0-3) 

With `MaximalRejectionThreshold = 0`, even a single rejection blocks the proposal: [5](#0-4) 

Similarly, with `MaximalAbstentionThreshold = 0`, a single abstention blocks the proposal: [6](#0-5) 

And with `MinimalApprovalThreshold = 10000`, all miners must approve: [7](#0-6) 

The `AbstractVoteTotal` constant is defined as 10000 (representing 100%): [8](#0-7) 

### Impact Explanation

**Governance Deadlock**: Once an organization sets these extreme thresholds, no future proposals can be released because:
- ALL current miners must vote (100% participation)
- ALL current miners must approve (unanimous consent)
- ZERO miners can reject or abstain

In a decentralized governance system, this is practically impossible due to:
- Miners going offline or becoming unavailable
- Legitimate disagreements requiring some miners to vote against
- The dynamic nature of the miner set changing over time

**No Recovery Path**: The organization cannot recover because only the organization itself (via `Context.Sender`) can call `ChangeOrganizationThreshold`, which requires releasing a proposal under the impossible thresholds.

**Critical Systems at Risk**: The default organization created during initialization is used for critical system governance decisions. If it becomes deadlocked, the entire blockchain governance system fails. [9](#0-8) 

### Likelihood Explanation

**Reachable Entry Point**: Any authorized proposer can create a proposal to call `ChangeOrganizationThreshold` for their organization.

**Attack Complexity**: Low - The attack only requires creating and passing a single malicious proposal that changes thresholds to extreme values. The validation explicitly allows these values.

**Feasibility**: High - The values pass validation checks and can be set through the normal proposal mechanism. No special privileges beyond standard proposal creation are needed.

**Scenarios**:
1. **Malicious attack**: An adversary who can propose or influence proposals intentionally locks the organization
2. **Accidental misconfiguration**: An administrator misunderstands the threshold semantics and sets values thinking they're reasonable
3. **Griefing**: A disgruntled miner with proposal rights intentionally deadlocks governance

The existing test suite validates that these threshold values are accepted, confirming the vulnerability is not theoretical but actually allowed by design.

### Recommendation

**Immediate Fix**: Add stricter validation to prevent threshold configurations that create practical deadlocks:

```csharp
private bool Validate(Organization organization)
{
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    
    // Existing validations...
    var basicValidation = proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
           proposalReleaseThreshold.MaximalRejectionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    
    if (!basicValidation) return false;
    
    // NEW: Prevent deadlock configurations
    // If MinimalApprovalThreshold is above a high threshold (e.g., 9000 = 90%),
    // ensure there's tolerance for rejections and abstentions
    if (proposalReleaseThreshold.MinimalApprovalThreshold >= 9000)
    {
        // Require at least 1% tolerance for rejections or abstentions
        // to avoid impossible unanimous vote requirements
        var minToleranceRequired = 100; // 1% of 10000
        return proposalReleaseThreshold.MaximalRejectionThreshold >= minToleranceRequired ||
               proposalReleaseThreshold.MaximalAbstentionThreshold >= minToleranceRequired;
    }
    
    return true;
}
```

**Alternatively**: Set maximum bounds for `MinimalApprovalThreshold` (e.g., ≤ 9500 = 95%) to ensure some tolerance for non-unanimous votes.

**Test Cases**: Add regression tests to verify:
1. Setting `MinimalApprovalThreshold = 10000` with zero rejection/abstention tolerance is rejected
2. Organizations cannot be created with deadlock-prone configurations
3. Proposals to change thresholds to impossible values fail validation

### Proof of Concept

**Initial State**:
- Organization exists with reasonable thresholds (e.g., 66.67% approval, 75% vote threshold)
- 10 miners in the current consensus

**Attack Steps**:

1. **Create malicious proposal**: Proposer creates a proposal to call `ChangeOrganizationThreshold` with parameters:
   ```
   MinimalApprovalThreshold = 10000
   MinimalVoteThreshold = 10000  
   MaximalRejectionThreshold = 0
   MaximalAbstentionThreshold = 0
   ```

2. **Approval under current thresholds**: The proposal gets approved under the EXISTING (reasonable) thresholds and is released

3. **Thresholds updated**: `ChangeOrganizationThreshold` executes successfully (validation passes), permanently changing the organization's thresholds

4. **Governance deadlock**: Any subsequent proposal now requires:
   - All 10 miners must vote (100% participation)
   - All 10 miners must approve (unanimous)
   - If even 1 miner rejects: `1 * 10000 > 0 * 10` → proposal rejected
   - If even 1 miner abstains: `1 * 10000 > 0 * 10` → proposal abstained

5. **No recovery**: To fix the thresholds, a proposal must be created and released, but this requires meeting the impossible thresholds, creating permanent deadlock

**Expected vs Actual**:
- **Expected**: Validation should reject threshold configurations that make governance impossible
- **Actual**: Validation accepts these values, allowing permanent governance deadlock

**Success Condition**: After step 3, no proposals can be released for the organization, including proposals to fix the thresholds, confirming permanent governance loss.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L11-37)
```csharp
    public override Empty Initialize(InitializeInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        var proposerWhiteList = new ProposerWhiteList();

        if (input.PrivilegedProposer != null)
            proposerWhiteList.Proposers.Add(input.PrivilegedProposer);

        State.ProposerWhiteList.Value = proposerWhiteList;
        var organizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = DefaultOrganizationMinimalApprovalThreshold,
                MinimalVoteThreshold = DefaultOrganizationMinimalVoteThresholdThreshold,
                MaximalAbstentionThreshold = DefaultOrganizationMaximalAbstentionThreshold,
                MaximalRejectionThreshold = DefaultOrganizationMaximalRejectionThreshold
            },
            ProposerAuthorityRequired = input.ProposerAuthorityRequired,
            ParliamentMemberProposingAllowed = true
        };
        var defaultOrganizationAddress = CreateNewOrganization(organizationInput);
        State.DefaultOrganizationAddress.Value = defaultOrganizationAddress;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L147-160)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L36-48)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var parliamentMembers = GetCurrentMinerList();
        var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
        if (isAbstained)
            return false;

        return CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-70)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L72-78)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(parliamentMembers.Contains);
        return abstentionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L187-196)
```csharp
        {
            createOrganizationInput.ProposalReleaseThreshold = proposalReleaseThreshold;
            createOrganizationInput.ProposalReleaseThreshold.MinimalApprovalThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MinimalVoteThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MaximalAbstentionThreshold = 0;
            createOrganizationInput.ProposalReleaseThreshold.MaximalRejectionThreshold = 0;
            var transactionResult =
                await minerParliamentContractStub.CreateOrganization.SendAsync(createOrganizationInput);
            transactionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```
