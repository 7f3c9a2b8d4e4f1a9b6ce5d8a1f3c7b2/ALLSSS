### Title
Secret Sharing Information Leakage Through Round Object String Interpolation in Validation Error Messages

### Summary
The consensus validation code directly interpolates `Round` objects into error messages without sanitizing sensitive secret-sharing data. When validation fails, error messages expose encrypted_pieces and decrypted_pieces fields through the protobuf default ToString() implementation, leaking miners' secret shares in ValidationResult messages and debug logs.

### Finding Description

The vulnerability exists in how `Round` objects are serialized in validation error messages: [1](#0-0) [2](#0-1) [3](#0-2) 

The `Round` protobuf message contains sensitive secret-sharing information: [4](#0-3) 

The `Round` class implements `IFormattable`, but when string interpolation uses default formatting (format "G"), it delegates to the base protobuf ToString(): [5](#0-4) 

The protobuf's default ToString() serializes ALL fields including the sensitive maps. While `GetLogs()` method excludes these fields when called with a pubkey parameter, direct string interpolation like `{currentRound}` or `{this}` triggers the default ToString() path that includes encrypted_pieces and decrypted_pieces.

The codebase does have a `DeleteSecretSharingInformation()` method to clear these fields, but it's only called before returning consensus extra data: [6](#0-5) [7](#0-6) 

However, Round objects retrieved from State for validation purposes still contain these sensitive fields and are not sanitized before being interpolated into error messages.

### Impact Explanation

**Information Leakage:**
- Decrypted secret shares (decrypted_pieces) can be observed in error messages and debug logs, revealing the decrypted pieces used in Shamir's Secret Sharing scheme
- Encrypted pieces (encrypted_pieces) expose the structure and recipients of secret sharing
- This information appears in ValidationResult.Message fields returned to callers and in Context.LogDebug() output: [8](#0-7) 

**Who Is Affected:**
- Miners whose secret shares are exposed in the Round objects during validation failures
- The consensus protocol's randomness mechanism which relies on secret sharing

**Severity Justification (Low):**
- No direct financial loss or consensus break
- Requires triggering specific validation errors (not always trivial)
- Encrypted pieces are already protected by encryption
- Decrypted pieces exposure is limited to error scenarios
- InValues are already committed via OutValues, limiting predictability impact
- Information is leaked through logs/error messages rather than direct query endpoints

### Likelihood Explanation

**Attacker Capabilities:**
An attacker (potentially a malicious miner) can craft invalid consensus data to trigger validation errors:
- Submit consensus header information with mismatched round data
- Provide incorrect mining time slots
- Trigger term/round transition validation failures

**Attack Complexity:**
- Medium complexity - requires understanding of consensus validation logic
- Attacker needs to be able to produce blocks or submit consensus data
- Error messages are returned in ValidationResult objects and logged

**Feasibility Conditions:**
- Validation methods are called during block validation (ValidateConsensusBeforeExecution, ValidateConsensusAfterExecution)
- Round objects retrieved from State contain populated encrypted_pieces and decrypted_pieces during active secret sharing
- Error messages are accessible through node logs and potentially transaction receipts

**Detection:**
- Validation failures are logged, making the exploitation detectable
- However, the sensitive data is already leaked once the error occurs

### Recommendation

**Immediate Fix:**
Override the parameterless `ToString()` method in the `Round` partial class to always use the sanitized `GetLogs()` format or create a safe default:

```csharp
// In Round.cs or Round_GetLogs.cs
public override string ToString()
{
    return GetLogs(string.Empty); // Returns safe formatted output
}
```

**Alternative Fix:**
Explicitly sanitize Round objects before including them in error messages:

```csharp
// Create a helper method
private string GetSafeRoundString(Round round)
{
    var safeCopy = round.Clone();
    safeCopy.DeleteSecretSharingInformation();
    return safeCopy.ToString();
}

// Use in error messages:
Message = $"Current round information is different with consensus extra data.\n" +
          $"New block header consensus information:\n{GetSafeRoundString(headerInformation.Round)}" +
          $"Stated block header consensus information:\n{GetSafeRoundString(currentRound)}"
```

**Invariant Checks:**
- Add code review checklist: Never directly interpolate Round objects without sanitization
- Add unit tests verifying Round.ToString() doesn't include encrypted_pieces or decrypted_pieces

**Test Cases:**
- Verify that validation error messages don't contain "encrypted_pieces" or "decrypted_pieces" strings
- Test Round.ToString() output to ensure sensitive fields are excluded
- Integration test triggering validation errors and checking log output

### Proof of Concept

**Required Initial State:**
1. Active AEDPoS consensus with secret sharing enabled
2. Multiple miners in the current round with populated encrypted_pieces and decrypted_pieces
3. Attacker has ability to submit consensus data (e.g., is a miner or can craft block headers)

**Transaction Steps:**
1. Retrieve current round information from State (contains full Round with secret shares)
2. Craft a block with consensus header information that differs from expected round state:
   - Modify miner list or round number slightly to trigger validation mismatch
   - Ensure the difference isn't due to legitimate miner replacement
3. Submit the block for validation

**Expected vs Actual Result:**
- **Expected (Secure):** Error message states "Current round information is different with consensus extra data" with sanitized round information showing only public fields (round number, term, miner orders, timestamps)
- **Actual (Vulnerable):** Error message includes complete protobuf serialization of Round objects with maps like `encrypted_pieces: {"pubkey1": "0x...", "pubkey2": "0x..."}` and `decrypted_pieces: {"pubkey3": "0x...", "pubkey4": "0x..."}` visible in the ValidationResult.Message and debug logs

**Success Condition:**
The ValidationResult.Message or debug log output contains byte strings representing encrypted_pieces or decrypted_pieces map entries from the Round objects, exposing secret-sharing information that should remain internal to the consensus protocol.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L107-113)
```csharp
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L41-41)
```csharp
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L46-47)
```csharp
        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```

**File:** protobuf/aedpos_contract.proto (L293-296)
```text
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_GetLogs.cs (L9-22)
```csharp
    public string ToString(string format, IFormatProvider formatProvider = null)
    {
        if (string.IsNullOrEmpty(format)) format = "G";

        switch (format)
        {
            case "G": return ToString();
            case "M":
                // Return formatted miner list.
                return RealTimeMinersInformation.Keys.Aggregate("\n", (key1, key2) => key1 + "\n" + key2);
        }

        return GetLogs(format);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_GetLighterRound.cs (L7-14)
```csharp
    public void DeleteSecretSharingInformation()
    {
        var encryptedPieces = RealTimeMinersInformation.Values.Select(i => i.EncryptedPieces);
        foreach (var encryptedPiece in encryptedPieces) encryptedPiece.Clear();

        var decryptedPieces = RealTimeMinersInformation.Values.Select(i => i.DecryptedPieces);
        foreach (var decryptedPiece in decryptedPieces) decryptedPiece.Clear();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L50-50)
```csharp
        if (!isGeneratingTransactions) information.Round.DeleteSecretSharingInformation();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L98-101)
```csharp
        var validationResult = service.ValidateInformation(validationContext);

        if (validationResult.Success == false)
            Context.LogDebug(() => $"Consensus Validation before execution failed : {validationResult.Message}");
```
