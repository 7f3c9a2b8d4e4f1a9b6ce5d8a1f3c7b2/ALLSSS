### Title
Duplicate Initial Miners Can Cause Consensus DoS During Term Transition

### Summary
The `GenerateFirstRoundOfNewTerm` method in the AEDPoS contract lacks duplicate pubkey filtering before creating a dictionary, unlike its kernel counterpart. When the Election contract's initial miner list contains duplicates (due to missing validation during initialization), and these duplicates are used during term transition fallback, the `ToDictionary` operation throws an `ArgumentException`, causing consensus to halt.

### Finding Description

**Vulnerable Code Location:**

The contract implementation of `GenerateFirstRoundOfNewTerm` performs a `ToDictionary` operation without deduplication: [1](#0-0) 

In contrast, the kernel extension version includes `.Distinct()` for protection: [2](#0-1) 

**Root Cause:**

The Election contract's initialization accepts miner lists without duplicate validation: [3](#0-2) 

When `State.InitialMiners.Value` contains duplicate `ByteString` entries, the `GetVictories` fallback path fails to deduplicate them: [4](#0-3) 

The `Where(k => !backups.Contains(k))` filter at line 69 only prevents duplicates between initial miners and existing backups, but does NOT remove duplicates within the initial miners list itself. If `State.InitialMiners.Value.Value` contains `[ByteString("A"), ByteString("A"), ByteString("B")]`, both "A" entries pass the filter if "A" is not in backups, resulting in duplicate "A" entries being added to victories.

**Execution Path:**

During term transition, `GetConsensusExtraDataForNextTerm` calls `GenerateFirstRoundOfNextTerm`: [5](#0-4) 

Which retrieves victories from the Election contract: [6](#0-5) 

The Election contract's `GetVictories` returns the contaminated miner list: [7](#0-6) 

### Impact Explanation

**Operational Impact - Consensus DoS:**
- When duplicate pubkeys exist in the `MinerList.Pubkeys` collection, the `ToDictionary` operation throws `ArgumentException`
- Term generation fails completely, preventing consensus from advancing to the next term
- Blockchain halts as no new blocks can be produced after the current term expires
- All network participants are affected until governance intervention or chain recovery

**Severity Justification:**
- **High severity** due to complete consensus failure
- Affects the entire blockchain network's liveness
- No automatic recovery mechanism exists
- Requires emergency intervention to resolve

### Likelihood Explanation

**Feasible Preconditions:**
1. **Configuration Error Path**: During chain initialization or governance update, the initial miners list is set with duplicate entries (no validation prevents this)
2. **Natural Trigger**: Term transition occurs when valid election candidates are insufficient, causing fallback to initial miners

**Attack Complexity:**
- **Low** - Only requires malicious/incorrect initialization data during contract deployment
- No special privileges needed after initialization if duplicates already exist
- Natural occurrence possible in election scenarios with low candidate participation

**Feasibility:**
- Entry point is the public `InitialElectionContract` method (requires appropriate authorization during genesis, but no duplicate validation)
- Trigger is automatic during normal term transitions when candidate count is low
- No economic cost to attacker if duplicates are injected during initialization
- Detection is difficult until the DoS actually occurs

**Probability Assessment:**
- **Medium to High** if initial configuration contains duplicates (either malicious or accidental)
- **Low to Medium** probability of accidental duplicates during legitimate initialization
- Natural trigger condition (insufficient candidates) is plausible in early chain stages or low-participation scenarios

### Recommendation

**Immediate Mitigation:**

1. Add `.Distinct()` call before `ToDictionary` in the contract implementation: [1](#0-0) 

Change line 16 to match the kernel extension pattern:
```csharp
from obj in Pubkeys.Distinct()
    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
```

2. Add duplicate validation during Election contract initialization: [8](#0-7) 

Add validation before line 34:
```csharp
Assert(input.MinerList.Count == input.MinerList.Distinct().Count(), 
    "Duplicate miners detected in initialization input.");
```

3. Add deduplication in `GetVictories` fallback path: [9](#0-8) 

Change line 68-69 to use `.Distinct()`:
```csharp
backups.AddRange(
    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Distinct()
        .Where(k => !backups.Contains(k)));
```

**Testing Requirements:**
- Unit test with duplicate entries in `MinerList.Pubkeys` to verify graceful handling
- Integration test simulating term transition with insufficient candidates and duplicate initial miners
- Regression test ensuring `ArgumentException` is not thrown under any circumstances

### Proof of Concept

**Initial State:**
1. Deploy Election contract with `InitialElectionContract` input containing duplicate miners:
   ```
   MinerList = ["pubkey_A_hex", "pubkey_A_hex", "pubkey_B_hex"]
   ```
2. `State.InitialMiners.Value.Value` now contains duplicate ByteString entries for pubkey_A

**Trigger Condition:**
1. Set `MinersCount = 10` (requiring 10 miners)
2. Ensure only 2 valid candidates with active votes exist
3. Wait for term transition trigger (term duration expires)

**Execution Steps:**
1. Consensus system calls `GetConsensusExtraDataForNextTerm`
2. `GenerateFirstRoundOfNextTerm` calls `TryToGetVictories`
3. `GetVictories` determines insufficient candidates (2 < 10, diff = 8)
4. Fallback adds initial miners including both "pubkey_A_hex" entries to victories
5. `victories.GenerateFirstRoundOfNewTerm` is called with duplicate pubkey_A in Pubkeys
6. Line 17 executes: `.ToDictionary(miner => miner.ToHex(), ...)`
7. First pubkey_A adds key to dictionary
8. Second pubkey_A attempts to add same key â†’ `ArgumentException: "An item with the same key has already been added"`

**Expected vs Actual:**
- **Expected**: Term transition succeeds with deduplicated miner list
- **Actual**: `ArgumentException` crashes term generation, consensus halts

**Success Condition:**
Blockchain fails to progress beyond current term, requiring emergency intervention to recover.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Extensions/MinerListExtensions.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in miners.Pubkeys.Distinct()
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L22-52)
```csharp
    public override Empty InitialElectionContract(InitialElectionContractInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");

        State.Candidates.Value = new PubkeyList();

        State.MinimumLockTime.Value = input.MinimumLockTime;
        State.MaximumLockTime.Value = input.MaximumLockTime;

        State.TimeEachTerm.Value = input.TimeEachTerm;

        State.MinersCount.Value = input.MinerList.Count;
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
        foreach (var pubkey in input.MinerList)
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey
            };

        State.CurrentTermNumber.Value = 1;

        State.DataCentersRankingList.Value = new DataCenterRankingList();

        State.Initialized.Value = true;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L41-49)
```csharp
    public override PubkeyList GetVictories(Empty input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        var currentMiners = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(k => k.ToHex()).ToList();
        return new PubkeyList { Value = { GetVictories(currentMiners) } };
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L62-77)
```csharp
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-210)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```
