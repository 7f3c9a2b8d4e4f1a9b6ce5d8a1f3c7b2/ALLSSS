# Audit Report

## Title
Missing Validation Allows Negative AutoDistributeThreshold Values, Inverting Distribution Logic

## Summary
The `CreateScheme()` function in the TokenHolder contract accepts `AutoDistributeThreshold` values without validation, allowing negative amounts to be set. This causes the auto-distribution logic in `RegisterForProfits()` to malfunction by inverting the threshold comparison, triggering distribution on every registration regardless of actual balance, completely defeating the threshold mechanism.

## Finding Description

The `CreateScheme()` function directly stores the `AutoDistributeThreshold` map from user input without any validation on the threshold values. [1](#0-0) 

The protobuf schema defines `auto_distribute_threshold` as `map<string, int64>`, which permits negative values since `int64` is a signed integer type. [2](#0-1) 

The vulnerability manifests in `RegisterForProfits()` where the auto-distribution logic performs a threshold comparison. [3](#0-2) 

The critical flaw occurs at the comparison: when `threshold.Value` is negative (e.g., -1000) and `balance` is non-negative (token balances are always >= 0), the condition `balance < threshold.Value` evaluates to FALSE. [4](#0-3) 

For example:
- If threshold = -1000 and balance = 100
- Then `100 < -1000` is FALSE
- The code does NOT continue, proceeding to trigger distribution

When distribution is triggered, the code sets `AmountsMap[symbol] = 0`, which instructs the Profit contract to distribute ALL available balance. [5](#0-4) 

The Profit contract interprets `amount.Value == 0` as a signal to query and distribute the entire balance. [6](#0-5) 

This completely inverts the intended threshold logic:
- **Intended**: Trigger distribution when balance >= threshold (e.g., 100 >= 1000 = don't distribute yet)
- **Actual with negative threshold**: Trigger distribution when balance >= negative_threshold (e.g., 100 >= -1000 = always true, always distribute)

The test suite demonstrates the intended behavior with positive thresholds but lacks validation tests for negative values. [7](#0-6) 

## Impact Explanation

**Operational Impact - Medium Severity:**

The vulnerability causes significant operational dysfunction of the auto-distribution mechanism:

1. **Threshold Mechanism Failure**: The threshold feature becomes completely inverted - instead of batching distributions until meaningful profit accumulation, it triggers on every single `RegisterForProfits` call regardless of balance amount, even with zero accumulated profits.

2. **Economic Inefficiency**: Forces frequent small distributions instead of economical batch distributions, resulting in excessive gas costs that scale linearly with registration frequency rather than profit accumulation.

3. **Loss of Distribution Control**: Scheme managers lose the ability to control distribution timing and optimize for gas efficiency or strategic distribution schedules.

4. **Premature Profit Distribution**: Early beneficiaries receive immediate distributions before meaningful profit accumulation, breaking the intended economic model where distributions occur at optimal thresholds.

5. **System-Wide Trust Impact**: If multiple schemes are misconfigured, the overall TokenHolder contract's reliability and economic design is compromised.

**Severity Justification**: While this does not directly cause fund theft (beneficiaries still receive their correct proportional shares), it fundamentally breaks a core economic feature and causes operational/economic damage. The severity is Medium because it requires scheme manager misconfiguration and primarily affects operational efficiency rather than fund security.

## Likelihood Explanation

**Likelihood Assessment - Medium:**

The vulnerability has realistic preconditions for triggering:

1. **Accidental Misconfiguration**: Scheme managers may accidentally provide negative values through:
   - UI input bugs that fail to validate positive-only inputs
   - Misunderstanding of parameter semantics (interpreting threshold as a delta or offset)
   - Copy-paste errors or typos when constructing transaction inputs
   - Integer overflow/underflow in frontend calculations

2. **No Defense Layers**: Complete absence of validation creates multiple failure points:
   - No protobuf-level constraints (int64 allows negatives)
   - No contract-level validation in `CreateScheme()`
   - No warning messages or error conditions
   - No visibility into the misconfiguration until unexpected behavior occurs

3. **Realistic Execution**: The vulnerability is fully executable within standard AElf contract semantics through normal public method calls with no special privileges required.

4. **Detection Difficulty**: The bug manifests as frequent distributions rather than obvious failures, making it difficult to diagnose without understanding the inverted comparison logic.

While this requires the scheme manager's own action (self-inflicted), the lack of any validation makes accidental triggering realistic, especially in production environments with complex frontends and integration layers.

## Recommendation

Add validation in the `CreateScheme()` function to ensure all `AutoDistributeThreshold` values are positive:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Validate AutoDistributeThreshold values
    if (input.AutoDistributeThreshold != null && input.AutoDistributeThreshold.Any())
    {
        foreach (var threshold in input.AutoDistributeThreshold)
        {
            Assert(!string.IsNullOrEmpty(threshold.Key), "Invalid token symbol in auto distribute threshold.");
            Assert(threshold.Value > 0, $"Auto distribute threshold for {threshold.Key} must be positive.");
        }
    }

    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Additionally, consider adding a negative test case to the test suite to verify the validation rejects negative threshold values.

## Proof of Concept

```csharp
[Fact]
public async Task CreateScheme_With_Negative_AutoDistributeThreshold_Should_Trigger_On_Every_Registration()
{
    var nativeTokenSymbol = TokenHolderContractTestConstants.NativeTokenSymbol;
    
    // Create scheme with NEGATIVE threshold (bug trigger)
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = nativeTokenSymbol,
        AutoDistributeThreshold =
        {
            { nativeTokenSymbol, -1000 } // Negative threshold
        }
    });
    
    // Contribute small amount (way below intended threshold)
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Amount = 10, // Only 10 tokens, should NOT trigger if threshold was 1000
        Symbol = nativeTokenSymbol
    });
    
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
    {
        Manager = Starter
    });
    var schemeId = schemeIds.SchemeIds.First();
    
    var schemeBefore = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    var periodBefore = schemeBefore.CurrentPeriod;
    
    // Register for profits - should NOT trigger distribution with only 10 tokens
    // But WILL trigger due to negative threshold bug
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = 100,
        SchemeManager = Starter
    });
    
    var schemeAfter = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    var periodAfter = schemeAfter.CurrentPeriod;
    
    // BUG: Period incremented from 1 to 2, proving distribution was triggered
    // even though balance (10) is far below intended threshold (1000)
    periodAfter.ShouldBe(periodBefore + 1); // This proves the bug
    
    // Expected behavior: Period should remain at 1 because 10 < 1000
    // Actual behavior: Period incremented to 2 because 10 > -1000 (inverted logic)
}
```

This test demonstrates that with a negative threshold of -1000, a balance of only 10 tokens triggers automatic distribution, proving the threshold logic is inverted. With the intended positive threshold of 1000, no distribution should occur until balance reaches 1000.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L178-206)
```csharp
        // Check auto-distribute threshold.
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }
```

**File:** protobuf/token_holder_contract.proto (L69-69)
```text
    map<string, int64> auto_distribute_threshold = 3;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L437-443)
```csharp
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L359-419)
```csharp
    public async Task RegisterForProfits_With_Auto_Distribute_Test()
    {
        var amount = 1000L;
        var nativeTokenSymbol = TokenHolderContractTestConstants.NativeTokenSymbol;
        var tokenA = "JUN";
        await StarterCreateIssueAndApproveTokenAsync(tokenA, 1000000L, 100000L);
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = nativeTokenSymbol,
            AutoDistributeThreshold =
            {
                { nativeTokenSymbol, amount },
                { tokenA, amount }
            }
        });
        await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeManager = Starter,
            Amount = amount,
            Symbol = nativeTokenSymbol
        });
        await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeManager = Starter,
            Amount = amount,
            Symbol = tokenA
        });
        var beforeLockBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = nativeTokenSymbol,
            Owner = Starter
        })).Balance;
        await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
        {
            Amount = amount,
            SchemeManager = Starter
        });
        var afterLockBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = nativeTokenSymbol,
            Owner = Starter
        })).Balance;
        beforeLockBalance.ShouldBe(afterLockBalance.Add(amount));
        var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
        {
            Manager = Starter
        });
        var schemeId = schemeIds.SchemeIds.First();
        var profitMap = await ProfitContractStub.GetProfitsMap.CallAsync(new Profit.ClaimProfitsInput
        {
            Beneficiary = Starter,
            SchemeId = schemeId
        });
        profitMap.Value.Count.ShouldBe(2);
        profitMap.Value.ContainsKey(nativeTokenSymbol).ShouldBeTrue();
        profitMap.Value[nativeTokenSymbol].ShouldBe(amount);
        var schemeInfoInProfit = await ProfitContractStub.GetScheme.CallAsync(schemeId);
        var schemeInfoInTokenHolder = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
        schemeInfoInProfit.CurrentPeriod.ShouldBe(2);
        schemeInfoInTokenHolder.Period.ShouldBe(2);
    }
```
