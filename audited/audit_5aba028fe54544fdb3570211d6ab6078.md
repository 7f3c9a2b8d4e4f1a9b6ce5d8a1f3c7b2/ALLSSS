### Title
Term Transition DoS via Empty Miner List Leading to RoundId=0 Assertion Failure

### Summary
The `GenerateFirstRoundOfNextTerm` method can return a Round with `RoundId=0` when the current round has no miners or the miner list generation fails, causing the assertion at line 210 of `GetConsensusExtraDataForNextTerm` to fail. This blocks term transitions and halts consensus progression, particularly affecting side chains or chains with misconfigured initial miner lists.

### Finding Description

The vulnerability exists in the term transition flow starting from `GetConsensusExtraDataForNextTerm`: [1](#0-0) 

The assertion at line 210 requires that `firstRoundOfNextTerm.RoundId != 0`, but `GenerateFirstRoundOfNextTerm` can violate this invariant: [2](#0-1) 

The root cause occurs when:
1. Line 226 calls `TryToGetCurrentRoundInformation(out var currentRound)` without checking the return value
2. For side chains, `TryToGetVictories` returns false at line 268-271: [3](#0-2) 

3. The fallback path (lines 236-242) creates a `MinerList` from `currentRound.RealTimeMinersInformation.Keys`, which can be empty
4. This empty `MinerList` is passed to `GenerateFirstRoundOfNewTerm`: [4](#0-3) 

When `Pubkeys` is empty, the loop at lines 23-38 doesn't execute, leaving `round.RealTimeMinersInformation` empty. The `RoundId` property is calculated as: [5](#0-4) 

For an empty `RealTimeMinersInformation`, the sum of an empty collection is 0, making `RoundId=0`.

The `FirstRound` initialization method lacks validation for non-empty miner lists: [6](#0-5) 

### Impact Explanation

**Consensus DoS and Chain Halt:**
- Term transition is completely blocked when the assertion fails
- All nodes attempting to produce the NextTerm block will fail with "Failed to generate new round information."
- The blockchain cannot progress to the next term, effectively halting consensus
- Requires contract upgrade or state repair to recover

**Affected Parties:**
- Side chains are most vulnerable since they always bypass `TryToGetVictories`
- Main chain if Election contract's `GetVictories` returns empty (no valid candidates, no current miners, no initial miners)
- Any chain initialized with empty or misconfigured miner lists

**Severity Justification:**
This is a **HIGH** severity issue because it causes complete consensus failure and requires manual intervention to resolve. Unlike temporary DoS, this is a permanent blocking condition that prevents any further blockchain progression.

### Likelihood Explanation

**Medium Likelihood** due to:

**Feasible Preconditions:**
- Side chains initialized with empty initial miner lists (configuration error)
- State corruption leading to rounds with no miners
- Bugs in miner list management removing all miners from current round

**Attack Complexity:**
- No attacker action required - this is a defensive check failure
- Can occur through legitimate but edge-case operations
- More likely during initial deployment or after configuration errors

**Side Chain Scenario (Most Likely):**
Side chains don't use the Election contract for victories, so they always rely on the current round's miner list fallback. If initialized incorrectly or if the current round loses all miners due to bugs, term transition will fail.

**Main Chain Scenario (Less Likely but Possible):**
The Election contract's `GetVictories` uses multiple fallbacks: [7](#0-6) 

If all three fallbacks (valid candidates, current miners, initial miners) are empty or null, it returns an empty list, triggering the same vulnerability path.

### Recommendation

**Immediate Fix:**
Add validation in `GenerateFirstRoundOfNextTerm` to ensure miner list is non-empty:

```csharp
private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
{
    Round newRound;
    TryToGetCurrentRoundInformation(out var currentRound);
    
    if (TryToGetVictories(out var victories))
    {
        Assert(victories.Pubkeys.Any(), "Victories list cannot be empty.");
        Context.LogDebug(() => "Got victories successfully.");
        newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime, currentRound);
    }
    else
    {
        // Miners of new round are same with current round.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(
            currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        Assert(miners.Pubkeys.Any(), "Cannot generate next term with empty miner list.");
        newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
            Context.CurrentBlockTime, currentRound);
    }
    // ... rest of method
}
```

**Additional Safeguards:**
1. Add validation in `FirstRound` method to reject empty miner lists
2. Add validation in `MinerList.GenerateFirstRoundOfNewTerm` to assert non-empty `Pubkeys`
3. Ensure Election contract's `GetVictories` never returns empty by properly initializing `InitialMiners`

**Test Cases:**
1. Test term transition with empty current round miner list
2. Test side chain initialization with empty miner list
3. Test Election contract `GetVictories` with all fallbacks empty
4. Test that assertion properly catches and reports the issue

### Proof of Concept

**Initial State:**
- Side chain deployed with empty or misconfigured initial miner list
- OR main chain where Election contract returns empty victories and current round has no miners

**Execution Steps:**

1. Chain initialization creates a round with empty `RealTimeMinersInformation`: [6](#0-5) 

2. When term transition time arrives, miner calls `NextTerm`: [8](#0-7) 

3. This triggers `GetConsensusBlockExtraData` with `AElfConsensusBehaviour.NextTerm`: [9](#0-8) 

4. `GetConsensusExtraDataForNextTerm` calls `GenerateFirstRoundOfNextTerm` which returns Round with `RoundId=0`

5. Assertion fails: `Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.")`

**Expected Result:**
Term transition succeeds with valid miner list

**Actual Result:**
Transaction reverts with assertion failure, term transition blocked indefinitely

**Success Condition:**
All nodes attempting term transition fail the assertion, consensus progression halts

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L45-47)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L74-92)
```csharp
    public override Empty FirstRound(Round input)
    {
        /* Basic checks. */
        Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");

        /* Initial settings. */
        State.CurrentTermNumber.Value = 1;
        State.CurrentRoundNumber.Value = 1;
        State.FirstRoundNumberOfEachTerm[1] = 1;
        State.MiningInterval.Value = input.GetMiningInterval();
        SetMinerList(input.GetMinerList(), 1);

        AddRoundInformation(input);

        Context.LogDebug(() =>
            $"Initial Miners: {input.RealTimeMinersInformation.Keys.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
