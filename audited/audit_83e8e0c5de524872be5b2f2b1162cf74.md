### Title
Malicious Controller Contract Can Permanently Brick Method Fee Management via Invalid OwnerAddress Validation

### Summary
The `ChangeMethodFeeController` function validates organization existence by calling `ValidateOrganizationExist` on the provided `ContractAddress`, but this validation is insufficient because a malicious contract can implement this method to always return true for any `OwnerAddress`. This allows an attacker who controls the current fee controller to set the `OwnerAddress` to an unusable address (such as a contract address that cannot be a transaction sender), permanently bricking both fee management and the ability to change the controller back.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:**

The `ChangeMethodFeeController` function performs authorization and validation: [2](#0-1) 

The `CheckOrganizationExist` method makes a cross-contract call to validate the organization, but it only verifies that the target contract returns true - it does NOT verify that `OwnerAddress` is actually a valid organization address that can act as a transaction sender.

The legitimate validation implementation in governance contracts checks if an organization exists in their state: [3](#0-2) [4](#0-3) 

However, a malicious contract can implement `ValidateOrganizationExist` to always return `true` for any address, including non-organization addresses like raw contract addresses.

**Why Protections Fail:**

Authorization checks require the sender to match the `OwnerAddress`: [5](#0-4) [6](#0-5) 

In legitimate usage, `OwnerAddress` is an organization address, and transactions are executed via virtual addresses when proposals are released: [7](#0-6) 

If `OwnerAddress` is set to an address that is neither a user account nor a valid organization (such as a raw contract address), that address cannot be `Context.Sender` because:
1. Contracts cannot directly send transactions (they're not EOAs)
2. It's not a virtual address derived from an organization's hash
3. No mechanism exists to impersonate arbitrary addresses as senders

### Impact Explanation

**Operational DoS Impact:**

Once the malicious `AuthorityInfo` is set:
- `SetMethodFee` becomes permanently unusable (requires sender = invalid OwnerAddress)
- `ChangeMethodFeeController` becomes permanently unusable (requires sender = invalid OwnerAddress)
- No recovery mechanism exists to regain control
- Method fees cannot be updated, preventing fee adjustments needed for economic management

**System-Wide Severity:**

This same pattern exists across **all AElf system contracts** implementing ACS1:
- Configuration, MultiToken, Parliament, Association, Referendum
- Consensus (AEDPoS), CrossChain, Economic, Election
- Profit, TokenConverter, TokenHolder, Treasury, Vote [8](#0-7) [9](#0-8) 

A single compromised organization can permanently brick fee management across the entire protocol.

### Likelihood Explanation

**Attacker Capabilities Required:**

The attacker must currently control the method fee controller organization, meaning they can get a malicious proposal approved and released. This requires either:
1. Compromising the current governance organization (key theft, social engineering, voting manipulation)
2. Exploiting a separate vulnerability in organization logic
3. Being a malicious insider with proposal creation/approval privileges

**Attack Complexity:**

1. Deploy a malicious contract implementing:
```solidity
ValidateOrganizationExist(Address input) returns BoolValue { return true; }
```

2. Create proposal to call `ChangeMethodFeeController` with:
```
AuthorityInfo {
  ContractAddress: MaliciousContract,
  OwnerAddress: AnyUnusableAddress (e.g., Configuration contract address, random contract)
}
```

3. Get proposal approved and released through current governance

4. System is permanently bricked - no recovery possible

**Feasibility:**

While requiring organization control is a high privilege, this represents a **permanent and irrecoverable** escalation. Even temporary compromise results in permanent damage. The validation logic trusts external contracts to honestly report organization validity, violating defense-in-depth principles.

### Recommendation

**Add OwnerAddress Format Validation:**

Modify `CheckOrganizationExist` to verify that `OwnerAddress` is actually the result of `CalculateOrganizationAddress` for the given `ContractAddress`:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Verify organization exists
    var exists = Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
    
    if (!exists) return false;
    
    // Verify ContractAddress is a known system contract (Parliament/Association/Referendum)
    var systemContracts = Context.GetSystemContractNameToAddressMapping();
    var isSystemContract = systemContracts.Values.Contains(authorityInfo.ContractAddress);
    
    return isSystemContract;
}
```

**Whitelist Authorized Governance Contracts:**

Only allow `ContractAddress` to be one of the three system governance contracts:
- Parliament
- Association  
- Referendum

This prevents arbitrary contracts from acting as authorization providers.

**Add Recovery Mechanism:**

Implement an emergency override controlled by Genesis contract or multi-sig that can reset bricked controllers.

### Proof of Concept

**Initial State:**
- Configuration contract has default Parliament controller
- Attacker controls enough votes in Parliament organization

**Attack Steps:**

1. **Deploy Malicious Contract:**
```csharp
public class MaliciousController {
    public BoolValue ValidateOrganizationExist(Address input) {
        return new BoolValue { Value = true }; // Always return true
    }
}
```

2. **Create Malicious Proposal:**
```csharp
var proposal = await ParliamentContract.CreateProposal(new CreateProposalInput {
    ToAddress = ConfigurationContractAddress,
    ContractMethodName = "ChangeMethodFeeController",
    Params = new AuthorityInfo {
        ContractAddress = MaliciousControllerAddress,
        OwnerAddress = ConfigurationContractAddress // Contract address - cannot be sender
    }.ToByteString()
});
```

3. **Approve and Release:**
```csharp
await ParliamentContract.Approve(proposalId);
await ParliamentContract.Release(proposalId);
```

**Expected Result:**
Transaction succeeds, controller is changed

**Actual Result:**
- `CheckOrganizationExist` calls `MaliciousController.ValidateOrganizationExist(ConfigurationContractAddress)`
- Returns `true` (malicious contract accepts any address)
- Validation passes on line 28
- Controller is set to invalid AuthorityInfo

**Post-Attack State:**
- `SetMethodFee` reverts: "Unauthorized to set method fee" (sender ≠ ConfigurationContractAddress)
- `ChangeMethodFeeController` reverts: "Unauthorized behavior" (sender ≠ ConfigurationContractAddress)
- No recovery possible - contract permanently bricked

### Citations

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L17-17)
```csharp
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L23-32)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L72-77)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L138-140)
```csharp
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L119-119)
```csharp
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L86-86)
```csharp
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
```
