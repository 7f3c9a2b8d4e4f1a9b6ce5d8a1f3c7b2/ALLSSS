### Title
GetLatestVotingResult Returns Inconsistent Data When CurrentSnapshotNumber Exceeds TotalSnapshotNumber

### Summary
The `GetLatestVotingResult` method returns a `VotingResult` with inconsistent data when `CurrentSnapshotNumber` exceeds `TotalSnapshotNumber`. After the sponsor takes the final snapshot, the method returns a result with non-zero `VotersCount` and `VotesAmount` but an empty `Results` map (option-to-votes breakdown), creating a permanent data inconsistency that could mislead systems relying on this view method.

### Finding Description

The vulnerability occurs in the interaction between `TakeSnapshot` and `GetLatestVotingResult`.

When `TakeSnapshot` is called for the last valid snapshot (when `CurrentSnapshotNumber == TotalSnapshotNumber`), the validation at line 247-248 permits the operation since `CurrentSnapshotNumber - 1 < TotalSnapshotNumber` holds true. [1](#0-0) 

The method then increments `CurrentSnapshotNumber` to `TotalSnapshotNumber + 1` and creates a new `VotingResult` for this next snapshot at lines 263-271. However, this new result only copies `VotersCount` and `VotesAmount` from the previous snapshot, leaving the `Results` map (which contains option-to-votes breakdown) empty. [2](#0-1) 

Subsequently, when `GetLatestVotingResult` is called, it directly uses `CurrentSnapshotNumber` without validation and returns the incomplete result for snapshot `TotalSnapshotNumber + 1`. [3](#0-2) 

The `VotingResult` structure includes both aggregate counts and per-option breakdown, creating an expectation of data consistency. [4](#0-3) 

Once `CurrentSnapshotNumber > TotalSnapshotNumber`, voting is blocked by the check at line 382-383 in `AssertValidVoteInput`, ensuring this inconsistent state persists permanently. [5](#0-4) 

### Impact Explanation

The vulnerability causes **operational impact through data inconsistency**:

1. **Misleading Data**: Systems calling `GetLatestVotingResult` receive a `VotingResult` where `VotersCount` and `VotesAmount` are non-zero (carried from the last valid snapshot), but the `Results` map is empty. This violates the invariant that aggregate counts should match the sum of per-option votes.

2. **Decision-Making Impact**: External contracts, UIs, or governance systems relying on `GetLatestVotingResult` to determine voting outcomes would see incomplete data. While they can access total counts, they cannot see how votes are distributed across options, which is critical for determining winners or making informed decisions.

3. **Real-World Usage**: The Election contract demonstrates real usage of this method for retrieving vote counts, confirming that this is not theoretical. [6](#0-5) 

4. **Permanent State**: The inconsistency is permanent once created, as no mechanism exists to correct it without the sponsor avoiding taking the final snapshot entirely.

**Severity Justification**: Medium - No direct fund loss, but creates persistent data integrity issues affecting decision-making systems that depend on complete voting results.

### Likelihood Explanation

**High likelihood** - This occurs through normal operational flow:

1. **Reachable Entry Point**: `GetLatestVotingResult` is a public view method callable by anyone at any time.

2. **Feasible Preconditions**: 
   - A voting item exists with `TotalSnapshotNumber > 0` (standard case)
   - The sponsor takes all `TotalSnapshotNumber` snapshots (expected behavior to close voting periods)
   - Any user or contract calls `GetLatestVotingResult`

3. **No Attacker Required**: This is not an attack - it's the natural consequence of sponsors completing their snapshot duties as designed. The test suite confirms taking all snapshots is expected behavior. [7](#0-6) 

4. **Execution Practicality**: Guaranteed to occur whenever a sponsor takes the final snapshot for any voting item.

5. **Detection**: Users may not immediately notice since aggregate counts (`VotersCount`, `VotesAmount`) appear correct - only the detailed `Results` map is empty.

### Recommendation

**Fix `GetLatestVotingResult` to return the last valid snapshot when voting has ended:**

```csharp
public override VotingResult GetLatestVotingResult(Hash input)
{
    var votingItem = AssertVotingItem(input);
    
    // If current snapshot exceeds total, return the last valid snapshot instead
    var targetSnapshotNumber = votingItem.CurrentSnapshotNumber > votingItem.TotalSnapshotNumber
        ? votingItem.TotalSnapshotNumber
        : votingItem.CurrentSnapshotNumber;
    
    var votingResultHash = new VotingResult
    {
        VotingItemId = input,
        SnapshotNumber = targetSnapshotNumber
    }.GetHash();
    return State.VotingResults[votingResultHash];
}
```

**Alternative approach:** Modify `TakeSnapshot` to copy the `Results` map when creating the final snapshot, ensuring data consistency. However, the first approach is cleaner as it preserves the semantic meaning of "latest valid result" rather than "current snapshot."

**Add test case:**
```csharp
[Fact]
public async Task GetLatestVotingResult_After_Final_Snapshot_Returns_Valid_Data()
{
    var votingItem = await RegisterVotingItemAsync(10, 2, true, DefaultSender, 2);
    await Vote(voteUser, votingItem.VotingItemId, votingItem.Options[0], 100);
    await TakeSnapshot(votingItem.VotingItemId, 1);
    await Vote(voteUser, votingItem.VotingItemId, votingItem.Options[1], 200);
    await TakeSnapshot(votingItem.VotingItemId, 2); // Takes final snapshot
    
    var result = await GetLatestVotingResult(votingItem.VotingItemId);
    result.Results.Count.ShouldBeGreaterThan(0); // Should have option breakdown
    result.Results.Values.Sum().ShouldBe(result.VotesAmount); // Consistency check
}
```

### Proof of Concept

**Initial State:**
- Voting item registered with `TotalSnapshotNumber = 3`
- `CurrentSnapshotNumber = 1`

**Transaction Steps:**
1. Users vote in snapshot 1 (e.g., Option A: 100 votes, Option B: 50 votes)
2. Sponsor calls `TakeSnapshot(votingItemId, 1)` → `CurrentSnapshotNumber = 2`
3. Users vote in snapshot 2 (e.g., Option A: 150 votes, Option B: 100 votes)
4. Sponsor calls `TakeSnapshot(votingItemId, 2)` → `CurrentSnapshotNumber = 3`
5. Users vote in snapshot 3 (e.g., Option A: 200 votes, Option B: 150 votes)
6. Sponsor calls `TakeSnapshot(votingItemId, 3)` → `CurrentSnapshotNumber = 4` (exceeds `TotalSnapshotNumber`)
7. Anyone calls `GetLatestVotingResult(votingItemId)`

**Expected Result:**
- Return `VotingResult` for snapshot 3 with complete data:
  - `VotersCount = 6`
  - `VotesAmount = 750`
  - `Results = {"Option A": 450, "Option B": 300}`

**Actual Result:**
- Returns `VotingResult` for snapshot 4 with inconsistent data:
  - `VotersCount = 6` (copied from snapshot 3)
  - `VotesAmount = 750` (copied from snapshot 3)
  - `Results = {}` (empty map - inconsistent!)

**Success Condition:**
The vulnerability is confirmed when `GetLatestVotingResult` returns a `VotingResult` where `VotersCount > 0` and `VotesAmount > 0`, but `Results.Count == 0`, violating data consistency invariants.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L247-248)
```csharp
        Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L263-271)
```csharp
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L382-383)
```csharp
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
```

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L44-53)
```csharp
    public override VotingResult GetLatestVotingResult(Hash input)
    {
        var votingItem = AssertVotingItem(input);
        var votingResultHash = new VotingResult
        {
            VotingItemId = input,
            SnapshotNumber = votingItem.CurrentSnapshotNumber
        }.GetHash();
        return State.VotingResults[votingResultHash];
    }
```

**File:** protobuf/vote_contract.proto (L162-177)
```text
message VotingResult {
    // The voting activity id.
    aelf.Hash voting_item_id = 1;
    // The voting result, option -> amount of votes,
    map<string, int64> results = 2;
    // The snapshot number.
    int64 snapshot_number = 3;
    // The total number of voters.
    int64 voters_count = 4;
    // The start time of this snapshot.
    google.protobuf.Timestamp snapshot_start_timestamp = 5;
    // The end time of this snapshot.
    google.protobuf.Timestamp snapshot_end_timestamp = 6;
    // Total votes received during the process of this snapshot.
    int64 votes_amount = 7;
}
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L224-238)
```csharp
    public override Int64Value GetVotersCount(Empty input)
    {
        return new Int64Value
        {
            Value = State.VoteContract.GetLatestVotingResult.Call(State.MinerElectionVotingItemId.Value).VotersCount
        };
    }

    public override Int64Value GetVotesAmount(Empty input)
    {
        return new Int64Value
        {
            Value = State.VoteContract.GetLatestVotingResult.Call(State.MinerElectionVotingItemId.Value).VotesAmount
        };
    }
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/SnapshotTests.cs (L78-101)
```csharp
    public async Task VoteContract_TakeSnapshot_Success_Test()
    {
        var registerItem = await RegisterVotingItemAsync(10, 4, true, DefaultSender, 3);
        for (var i = 0; i < 3; i++)
        {
            var transactionResult = (await VoteContractStub.TakeSnapshot.SendAsync(
                new TakeSnapshotInput
                {
                    VotingItemId = registerItem.VotingItemId,
                    SnapshotNumber = i + 1
                })).TransactionResult;

            transactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            var votingItem = await GetVoteItem(registerItem.VotingItemId);
            votingItem.CurrentSnapshotNumber.ShouldBe(i + 2);
            var voteResult = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
            {
                VotingItemId = registerItem.VotingItemId,
                SnapshotNumber = i + 2
            });
            voteResult.SnapshotNumber.ShouldBe(i + 2);
        }
    }
```
