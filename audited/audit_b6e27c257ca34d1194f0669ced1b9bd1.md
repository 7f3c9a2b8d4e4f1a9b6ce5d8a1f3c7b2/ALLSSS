# Audit Report

## Title
Vote ID Collision Causing Permanent Denial of Service for Specific Candidate Vote Counts

## Summary
The Election contract's vote ID generation mechanism creates deterministic IDs based on a candidate's current active vote count. When votes are withdrawn, the `LockTimeMap` entries are never cleaned up, causing these vote count values to become permanently "poisoned." Future votes that generate the same ID will fail the collision check, resulting in a permanent denial of service for legitimate voters.

## Finding Description

The vulnerability exists in the interaction between three functions in the Election contract:

**Vote ID Generation Logic:**
The `GenerateVoteId()` function generates vote IDs deterministically. When the optional `Token` field is not provided (which is the standard usage pattern as evidenced by test helpers), the vote ID is computed by hashing the contract address, candidate's public key, and the candidate's **current** `ObtainedActiveVotedVotesAmount`. [1](#0-0) 

**Vote Creation Check:**
The `Vote()` function generates a vote ID and then asserts that no vote with this ID already exists by checking `State.LockTimeMap[voteId] == 0`. If the check passes, it stores the lock time in the map. [2](#0-1) 

**Missing Cleanup in Withdrawal:**
The `Withdraw()` function decreases the candidate's `ObtainedActiveVotedVotesAmount`, effectively allowing the vote count to return to previous values. [3](#0-2) 

However, during withdrawal, while `WeightsAlreadyFixedMap` is explicitly cleaned up, the `LockTimeMap` entry is never removed. [4](#0-3) 

**Root Cause:**
The vote ID generation depends on a mutable value (`ObtainedActiveVotedVotesAmount`) that can decrease through withdrawals and cycle back to previous values. However, the collision-detection map (`LockTimeMap`) persists indefinitely, creating a scenario where vote IDs collide across different time periods.

**Attack Scenario:**
1. Candidate starts with 0 active votes
2. Alice votes 100 tokens → generates voteId based on count=0, stores in `LockTimeMap`
3. Candidate now has 100 active votes
4. Lock period expires, Alice withdraws → candidate returns to 0 active votes
5. `LockTimeMap[voteId]` still contains the old lock time (never removed)
6. Bob attempts to vote for the same candidate with any amount when count=0
7. System generates the same voteId (deterministic based on count=0)
8. Vote fails at assertion: `Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.")`

## Impact Explanation

**Denial of Service Impact:**
- Legitimate users are permanently blocked from voting for a candidate whenever the candidate's active vote count returns to a previously-used value
- An attacker can deliberately "poison" sequential vote count values (0, 1, 2, ..., N) by creating and withdrawing small votes at each count level
- The capital cost is minimal since tokens are returned after withdrawal (only gas fees incurred)
- Once poisoned, these vote count values remain unusable forever since `LockTimeMap` entries are never cleared

**Affected Users:**
- All future voters attempting to vote when candidate vote counts match poisoned values
- The candidates themselves, who cannot receive new votes at certain vote count thresholds
- The election system's integrity, as vote distribution becomes artificially constrained

**Severity Justification:**
This is a HIGH severity issue because it breaks a core function of the Election contract. The voting mechanism is fundamental to AElf's governance system, and preventing legitimate users from voting constitutes a critical operational failure that undermines the democratic process.

## Likelihood Explanation

**Natural Occurrence:**
This vulnerability will manifest naturally through normal operations without malicious actors. As users vote and withdraw over time, vote counts naturally fluctuate. When a candidate's vote count decreases (through withdrawals) and later returns to a previous value (through new votes), the collision will occur automatically.

**Attacker Capabilities Required:**
- Access to the public `Vote()` function (no privileges needed)
- Minimal token amount (even 1 token per count value)
- Patience to wait for minimum lock periods to expire

**Attack Complexity:**
LOW - The attack sequence is straightforward:
1. Vote for a candidate with minimal amounts at sequential vote count values (0, 1, 2, ...)
2. Wait for minimum lock periods to expire
3. Withdraw all votes
4. All those count values are now permanently unusable by any future voter

**Economic Rationality:**
- Attack cost is near zero: tokens are fully returned after withdrawal
- Only transaction gas fees are consumed
- High impact (DoS of voting) relative to minimal cost makes this highly exploitable
- Count value 0 is especially critical as it's the starting state for all candidates

**Probability Assessment:**
HIGH - The vulnerability will trigger naturally through legitimate usage patterns as the system matures and users regularly vote and withdraw.

## Recommendation

The `Withdraw()` function should clean up the `LockTimeMap` entry to prevent vote ID reuse:

```csharp
public override Empty Withdraw(Hash input)
{
    // ... existing validation and withdrawal logic ...
    
    if (!State.WeightsAlreadyFixedMap[input])
    {
        RemoveBeneficiaryOfVoter();
        State.WeightsAlreadyFixedMap.Remove(input);
    }
    
    // Add cleanup for LockTimeMap
    State.LockTimeMap.Remove(input);
    
    // ... remaining logic ...
    return new Empty();
}
```

Alternatively, the vote ID generation mechanism could be redesigned to use a monotonically increasing counter or incorporate the voter's address to ensure true uniqueness across all votes regardless of vote count cycling.

## Proof of Concept

```csharp
[Fact]
public async Task VoteIdCollision_CausesDoS_Test()
{
    // Setup: Get a candidate
    var candidate = ValidationDataCenterKeyPairs[0];
    await AnnounceElectionAsync(candidate);
    
    // Alice votes when candidate has 0 votes
    var aliceKeyPair = VoterKeyPairs[0];
    var voteResult1 = await VoteToCandidateAsync(
        aliceKeyPair, 
        candidate.PublicKey.ToHex(), 
        90 * 86400, // 90 days lock time (minimum)
        100
    );
    voteResult1.Status.ShouldBe(TransactionResultStatus.Mined);
    var voteId1 = Hash.Parser.ParseFrom(voteResult1.ReturnValue);
    
    // Verify candidate now has 100 votes
    var candidateVotes1 = await ElectionContractStub.GetCandidateVote.CallAsync(
        new StringValue { Value = candidate.PublicKey.ToHex() }
    );
    candidateVotes1.ObtainedActiveVotedVotesAmount.ShouldBe(100);
    
    // Fast forward past lock time
    BlockTimeProvider.SetBlockTime(BlockTimeProvider.GetBlockTime().AddDays(91));
    
    // Alice withdraws her vote
    var withdrawResult = await WithdrawVotes(aliceKeyPair, voteId1);
    withdrawResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify candidate back to 0 votes
    var candidateVotes2 = await ElectionContractStub.GetCandidateVote.CallAsync(
        new StringValue { Value = candidate.PublicKey.ToHex() }
    );
    candidateVotes2.ObtainedActiveVotedVotesAmount.ShouldBe(0);
    
    // Bob tries to vote when candidate is back at 0 votes
    var bobKeyPair = VoterKeyPairs[1];
    var voteResult2 = await VoteToCandidateAsync(
        bobKeyPair,
        candidate.PublicKey.ToHex(),
        90 * 86400,
        100
    );
    
    // This should fail due to vote ID collision
    voteResult2.Status.ShouldBe(TransactionResultStatus.Failed);
    voteResult2.Error.ShouldContain("Vote already exists");
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L402-412)
```csharp
    private Hash GenerateVoteId(VoteMinerInput voteMinerInput)
    {
        if (voteMinerInput.Token != null)
            return Context.GenerateId(Context.Self, voteMinerInput.Token);

        var candidateVotesCount =
            State.CandidateVotes[voteMinerInput.CandidatePubkey]?.ObtainedActiveVotedVotesAmount ?? 0;
        return Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(voteMinerInput.CandidatePubkey.GetBytes(),
                candidateVotesCount.ToBytes(false)));
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L432-434)
```csharp
        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L656-660)
```csharp
        candidateVotes.ObtainedActiveVotingRecordIds.Remove(input);
        candidateVotes.ObtainedWithdrawnVotingRecordIds.Add(input);
        candidateVotes.ObtainedActiveVotedVotesAmount =
            candidateVotes.ObtainedActiveVotedVotesAmount.Sub(votingRecord.Amount);
        State.CandidateVotes[newestPubkey] = candidateVotes;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L665-669)
```csharp
        if (!State.WeightsAlreadyFixedMap[input])
        {
            RemoveBeneficiaryOfVoter();
            State.WeightsAlreadyFixedMap.Remove(input);
        }
```
