### Title
Reentrancy Vulnerability in TokenConverter Allows Bancor Pricing Manipulation via Stale Connector Balances

### Summary
The `Buy` and `Sell` functions in TokenConverter are vulnerable to reentrancy attacks through token transfer callbacks. While the Bancor pricing functions `GetReturnFromPaid` and `GetAmountToPayFromReturn` are pure functions, external state changes can occur between price calculation and state updates, allowing attackers to exploit stale connector balances and bypass the Bancor bonding curve's price discovery mechanism.

### Finding Description

The vulnerability exists in the state update ordering of the `Buy` function in TokenConverterContract: [1](#0-0) 

**Root Cause**: The contract follows a dangerous pattern:
1. Calculate price using `GetSelfBalance(fromConnector)` which reads `State.DepositBalance[fromConnector.Symbol]`
2. Execute token transfer via `TransferFrom` (lines 133-140)
3. **Only after transfer completion**, update `State.DepositBalance` (line 141)

The MultiToken contract's `DoTransferFrom` implementation enables reentrancy: [2](#0-1) 

The critical issue is at lines 91-93 where `DealWithExternalInfoDuringTransfer` is called **after** the balance transfer but **before** allowance updates. This callback mechanism is implemented as: [3](#0-2) 

If a token has `TransferCallbackExternalInfoKey` configured in its ExternalInfo, line 346 executes `Context.SendInline` to invoke external contract code, creating a reentrancy opportunity.

**Why Existing Protections Fail**: 
- No reentrancy guards exist in TokenConverter
- The `GetSelfBalance` function for deposit accounts relies on contract state rather than actual token balances: [4](#0-3) 

For deposit accounts (line 378), it returns `State.DepositBalance[connector.Symbol]`, which lags behind actual balances during reentrancy.

### Impact Explanation

**Direct Fund Impact**: An attacker can drain the TokenConverter at artificially favorable prices by exploiting stale balance state. 

In the Bancor formula for buying tokens:
`amountToPay = ((toBalance / (toBalance - amountToReceive))^(toWeight/fromWeight) - 1) * fromBalance`

With a **lower** `fromBalance` (stale `State.DepositBalance`), the calculated `amountToPay` is **lower**, allowing the attacker to purchase resource tokens more cheaply than they should.

**Quantified Impact**:
- First `Buy` call: Attacker pays X tokens at price based on balance B
- During transfer callback, attacker reenters
- Second `Buy` call: Attacker pays X tokens at **same price** based on stale balance B
- Actual balance is now B+X, so second purchase should be more expensive
- Attacker saves the price difference, effectively stealing from the connector

**Affected Parties**:
- Legitimate token buyers pay inflated prices after attacker's manipulation
- Connector reserves become depleted faster than intended
- Protocol economics disrupted as Bancor curve no longer enforces proper price discovery

**Severity**: HIGH - Breaks core pricing invariant and enables fund extraction

### Likelihood Explanation

**Attacker Capabilities Required**:
1. Token with `TransferCallbackExternalInfoKey` configured in ExternalInfo must be used
2. Attacker controls the callback contract to reenter TokenConverter
3. Either: (a) base token has callback, or (b) attacker gets malicious token added as connector

**Attack Complexity**: MEDIUM
- Standard token transfer callbacks are supported by the MultiToken contract [5](#0-4) 
- Setting up callback requires token creation with ExternalInfo
- Adding connector requires connector controller permission (typically Parliament governance)

**Feasibility Conditions**:
- If **base token** (ELF) or existing resource tokens have callbacks configured, attack is immediately feasible
- If attacker can propose and pass governance to add malicious token connector, attack becomes feasible
- The `EnableConnector` function can be called by anyone with sufficient deposit [6](#0-5) 

**Detection/Operational Constraints**: 
- Attack leaves on-chain traces (multiple rapid Buy calls)
- However, automated monitoring may not distinguish from legitimate high-frequency trading
- Damage occurs before detection can prevent it

**Probability**: MEDIUM-HIGH if any connector token has transfer callbacks; LOW-MEDIUM if requires governance approval for malicious token

### Recommendation

**1. Implement Reentrancy Guard Pattern**:
```
Add a state variable `_locked` and modifier:
- Set `_locked = true` at start of Buy/Sell
- Check `Assert(!_locked, "Reentrant call")` 
- Set `_locked = false` at end
```

**2. Follow Checks-Effects-Interactions Pattern**:
Reorder operations in `Buy` function:
- Calculate price (checks)
- Update `State.DepositBalance` **BEFORE** transfers (effects)
- Execute token transfers (interactions)

Updated line ordering for Buy:
```
Line 120-124: Calculate amountToPay and fee
Line 127: Assert PayLimit
Line 130: Handle fee
Line 141: UPDATE State.DepositBalance FIRST ← MOVE HERE
Line 133-140: Then TransferFrom base token
Line 143-149: Then Transfer bought token
```

**3. Add Invariant Checks**:
After all operations, verify:
```
Assert(State.DepositBalance[connector.Symbol] matches expected value based on transfers)
```

**4. Test Cases to Add**:
- Test Buy with token that has malicious transfer callback attempting reentrancy
- Test Sell with similar reentrancy scenario
- Verify both functions revert on reentrant calls
- Test that legitimate sequential calls still work correctly

### Proof of Concept

**Initial State**:
- Connector pair: ELF (base, deposit account) ↔ RESOURCE (buy/sell enabled)
- State.DepositBalance[ELF_CONNECTOR] = 10,000 ELF
- RESOURCE token balance = 1,000 tokens
- Attacker has malicious contract with callback registered on ELF token ExternalInfo

**Attack Sequence**:

**Step 1**: Attacker calls `Buy(symbol: RESOURCE, amount: 100, payLimit: 0)`
- TokenConverter calculates price using fromBalance = 10,000 ELF
- Suppose Bancor formula calculates amountToPay = 1,100 ELF
- TokenConverter calls `TransferFrom(ELF, from: attacker, to: self, amount: 1,100)`

**Step 2**: During TransferFrom, callback is triggered
- Actual ELF balance of contract is now 11,100
- But State.DepositBalance still shows 10,000
- Attacker's callback calls `Buy(symbol: RESOURCE, amount: 100, payLimit: 0)` again

**Step 3**: Second Buy executes with stale state
- GetSelfBalance(fromConnector) returns 10,000 (stale State.DepositBalance)
- Bancor formula again calculates amountToPay = 1,100 ELF (same price!)
- Should be higher price due to increased reserves

**Step 4**: First Buy completes
- Updates State.DepositBalance[ELF_CONNECTOR] = 10,000 + 1,100 = 11,100

**Step 5**: Second Buy completes  
- Updates State.DepositBalance[ELF_CONNECTOR] = 11,100 + 1,100 = 12,200
- Attacker received 200 RESOURCE tokens for 2,200 ELF

**Expected vs Actual**:
- **Expected**: Second purchase at higher price due to bonding curve → Total cost > 2,200 ELF
- **Actual**: Both purchases at same stale price → Total cost = 2,200 ELF
- **Attacker Profit**: Price difference × amount = funds stolen from connector

**Success Condition**: Attacker successfully purchases tokens at below-market rates by exploiting reentrancy to bypass Bancor price discovery.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-141)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-94)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L1-50)
```csharp
namespace AElf.Contracts.MultiToken;

public static class TokenContractConstants
{
    public const int TokenNameLength = 80;
    public const int MaxDecimals = 18;
    public const int SymbolMaxLength = 10;
    public const int MemoMaxLength = 64;

    public const string PayTxFeeSymbolListName = "SymbolListToPayTxFee";
    public const string PayRentalSymbolListName = "SymbolListToPayRental";

    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
    public const string LockCallbackExternalInfoKey = "aelf_lock_callback";
    public const string UnlockCallbackExternalInfoKey = "aelf_unlock_callback";
    public const string LogEventExternalInfoKey = "aelf_log_event";
    public const string TokenAliasExternalInfoKey = "aelf_token_alias";
    public const int DELEGATEE_MAX_COUNT = 24;
    public const char NFTSymbolSeparator = '-';
    public const int NFTSymbolMaxLength = 30;
    public const string UserContractMethodFeeKey = "UserContractMethodFee";
    public const string CollectionSymbolSuffix = "0";
    public const string SeedCollectionSymbol = "SEED-0";
    public const string SeedOwnedSymbolExternalInfoKey = "__seed_owned_symbol";
    public const string SeedExpireTimeExternalInfoKey = "__seed_exp_time";
    public const string NftCreateChainIdExternalInfoKey = "__nft_create_chain_id";
    public const int DefaultMaxBatchApproveCount = 100;
    public const char AllSymbolIdentifier = '*';

}

```
