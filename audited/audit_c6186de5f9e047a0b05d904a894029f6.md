# Audit Report

## Title
Time Slot Validation Allows Overlapping and Unequal Mining Windows via Lenient Interval Checks

## Summary
The `CheckRoundTimeSlots()` function in the AEDPoS consensus contract uses a lenient validation rule that allows mining time intervals to vary from 0ms to 2× the base interval. This enables malicious miners to craft `NextRoundInput` data with overlapping or gapped time slots that pass validation, breaking the fundamental consensus assumption of sequential, non-overlapping mining windows.

## Finding Description

The vulnerability exists in the time slot validation logic within `CheckRoundTimeSlots()`. The validation condition uses `Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval`, which only rejects intervals when they differ by MORE than the base interval. This permits any interval in the range [0, 2×baseMiningInterval]. [1](#0-0) 

When legitimate rounds are generated, the system calculates equal time slots by multiplying the mining interval by each miner's order: [2](#0-1) 

However, when miners provide custom `NextRoundInput`, the validation only checks the lenient interval rule, not equality. Each miner's actual time slot duration is uniformly determined by `GetMiningInterval()`, which calculates the interval from the first two miners: [3](#0-2) 

This creates the core vulnerability: arbitrary `ExpectedMiningTime` values combined with a uniform slot duration enable overlapping windows.

**Concrete Attack Scenario:**
Assume 4 miners with baseMiningInterval = 4000ms:
- Miner A: ExpectedMiningTime = t+0 → slot: [t+0, t+4000ms]
- Miner B: ExpectedMiningTime = t+4000ms → slot: [t+4000ms, t+8000ms]  
  (baseMiningInterval = 4000ms)
- Miner C: ExpectedMiningTime = t+12000ms → slot: [t+12000ms, t+16000ms]  
  (interval from B: 8000ms, validation: |8000-4000| = 4000 ≤ 4000 ✓)
- Miner D: ExpectedMiningTime = t+14000ms → slot: [t+14000ms, t+18000ms]  
  (interval from C: 2000ms, validation: |2000-4000| = 2000 ≤ 4000 ✓)

Result: 4000ms gap (t+8000 to t+12000) and 2000ms overlap (t+14000 to t+16000).

The validation providers for `NextRound` behavior do not prevent this: [4](#0-3) [5](#0-4) 

The provided Round is converted and stored directly without regeneration or comparison: [6](#0-5) 

During overlapping periods, `IsTimeSlotPassed()` returns false for multiple miners simultaneously: [7](#0-6) 

Both miners receive consensus behavior allowing them to mine concurrently: [8](#0-7) 

The entry point `NextRound` is publicly callable by any miner in the current round: [9](#0-8) 

## Impact Explanation

**Consensus Integrity Breach:**
- Breaks the sequential mining guarantee - multiple miners can produce blocks simultaneously during overlapping time slots
- Creates gaps where no miner has an active time slot, potentially causing block production delays
- Enables strategic time slot allocation favoring colluding miners

**Unfair Mining Advantages:**
- Colluding miners can allocate themselves longer effective mining windows while compressing honest miners' time slots
- Non-colluding miners placed in overlapping regions face unpredictable block acceptance and potential wasted mining efforts
- Miners placed in gap regions may appear to "miss" their time slots when in reality no one should be mining

**Reward Misallocation:**
- Unfair time slot distribution leads to unequal block production opportunities across miners
- Long-term systematic advantage for colluding miners in accumulating mining rewards
- Honest miners disadvantaged by shorter or poorly positioned time slots

**Network Impact:**
- Chain quality degradation from non-uniform block timing patterns
- Potential for increased fork rates during overlapping mining periods
- May break assumptions in LIB (Last Irreversible Block) height calculations that depend on sequential time slot progression

**Severity: HIGH** - This fundamentally breaks core consensus time slot invariants and enables systematic, repeatable mining unfairness.

## Likelihood Explanation

**Attacker Capabilities:**
- Requires being a miner who reaches the extra block producer position (typically at round end)
- Must craft malicious `NextRoundInput` with manipulated `ExpectedMiningTime` values
- Must have the ability to include custom consensus header information in produced blocks

**Attack Complexity:**
- **LOW** - Simple manipulation of timestamp values within the allowed 2× range
- No cryptographic breaks, complex timing attacks, or protocol modifications required
- Can be automated once mining infrastructure is controlled

**Feasibility Conditions:**
- Attacker must be in the active miner set and reach extra block producer position
- This occurs naturally in rotation, making it periodically available to any miner
- For sustained advantage, requires 2-3 colluding miners (feasible in typical miner set sizes)

**Detection Constraints:**
- Difficult to detect as manipulated Rounds pass all on-chain validation checks
- Appears as legitimate consensus data in transaction history
- Would require off-chain monitoring and analysis of time slot distribution patterns to identify

**Economic Rationality:**
- Cost: Normal mining operational costs plus minimal development effort
- Benefit: Increased share of block rewards proportional to time slot advantage gained
- Highly rational for profit-maximizing miners, especially with minimal collusion

**Probability: MEDIUM-HIGH** - Exploitable by any malicious miner upon reaching extra block producer position, with clear economic incentives and low barriers to execution.

## Recommendation

Strengthen the `CheckRoundTimeSlots()` validation to enforce strict equality of mining intervals:

```csharp
public ValidationResult CheckRoundTimeSlots()
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

    var baseMiningInterval =
        (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

    if (baseMiningInterval <= 0)
        return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

    // FIXED: Enforce strict equality instead of lenient tolerance
    for (var i = 1; i < miners.Count - 1; i++)
    {
        var miningInterval =
            (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
        if (miningInterval != baseMiningInterval)  // Changed from Math.Abs() check
            return new ValidationResult { Message = "Mining intervals must be equal." };
    }

    return new ValidationResult { Success = true };
}
```

Alternatively, consider regenerating the next round information server-side rather than accepting arbitrary `NextRoundInput` from miners, using only `FinalOrderOfNextRound` from the input and recalculating all `ExpectedMiningTime` values based on the current block time and mining interval.

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_TimeSlotManipulation_AllowsOverlappingMiningWindows()
{
    // Setup: Bootstrap consensus with 4 miners
    var miners = new[] { "MinerA", "MinerB", "MinerC", "MinerD" };
    await InitializeConsensusWithMiners(miners);
    
    // Advance to a state where MinerA becomes extra block producer
    await AdvanceToExtraBlockProducerPosition("MinerA");
    
    var currentTime = TimestampHelper.GetUtcNow();
    
    // MinerA crafts malicious NextRoundInput with overlapping slots
    var maliciousNextRound = new NextRoundInput
    {
        RoundNumber = 2,
        TermNumber = 1,
        RealTimeMinersInformation =
        {
            ["MinerA"] = new MinerInRound { Pubkey = "MinerA", Order = 1, ExpectedMiningTime = currentTime },
            ["MinerB"] = new MinerInRound { Pubkey = "MinerB", Order = 2, ExpectedMiningTime = currentTime.AddMilliseconds(4000) },
            ["MinerC"] = new MinerInRound { Pubkey = "MinerC", Order = 3, ExpectedMiningTime = currentTime.AddMilliseconds(12000) }, // 8000ms gap
            ["MinerD"] = new MinerInRound { Pubkey = "MinerD", Order = 4, ExpectedMiningTime = currentTime.AddMilliseconds(14000) }  // 2000ms overlap
        },
        RandomNumber = GenerateRandomNumber()
    };
    
    // Execute malicious NextRound - should pass validation but create overlaps
    var result = await ConsensusStub.NextRound.SendAsync(maliciousNextRound);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Passes validation!
    
    // Verify overlap: At time t+14500, both MinerC and MinerD can mine
    var testTime = currentTime.AddMilliseconds(14500);
    var roundInfo = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Both miners' time slots have NOT passed
    var minerCSlotPassed = roundInfo.IsTimeSlotPassed("MinerC", testTime);
    var minerDSlotPassed = roundInfo.IsTimeSlotPassed("MinerD", testTime);
    
    minerCSlotPassed.ShouldBeFalse(); // MinerC slot: [12000, 16000] - NOT passed at 14500
    minerDSlotPassed.ShouldBeFalse(); // MinerD slot: [14000, 18000] - NOT passed at 14500
    
    // Both miners can mine simultaneously during overlap [14000, 16000]
    // This violates the sequential mining invariant
}
```

## Notes

This vulnerability specifically affects the `NextRound` transition mechanism where miners provide their own round information. The `UpdateValue` behavior (normal block production within a round) is not directly affected, but miners can exploit manipulated round structures once they're in place. The issue is exacerbated in scenarios with smaller miner sets where collusion is more feasible.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L49-55)
```csharp
        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-90)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L33-33)
```csharp
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L57-62)
```csharp
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-165)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```
