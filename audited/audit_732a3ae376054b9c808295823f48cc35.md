### Title
Stale Beneficiaries in Treasury Reward Schemes Due to Profits Receiver Address Desynchronization

### Summary
When a miner's custom profits receiver address is changed via `SetProfitsReceiver`, the Treasury contract's beneficiary removal logic fails to remove the old receiver address from BasicReward, WelcomeReward, and FlexibleReward schemes. This occurs because `GetAddressesFromCandidatePubkeys` uses the current profits receiver mapping at removal time, which differs from the address that was originally added as beneficiary, leaving stale beneficiaries who continue receiving rewards indefinitely.

### Finding Description

The vulnerability exists in the Treasury contract's beneficiary management across three reward update functions: `UpdateBasicMinerRewardWeights`, `UpdateWelcomeRewardWeights`, and `UpdateFlexibleRewardWeights`.

**Root Cause:**

When adding beneficiaries, the code uses `GetProfitsReceiver` which returns `State.ProfitsReceiverMap[pubkey]` if set, otherwise the default address from the pubkey: [1](#0-0) 

When removing beneficiaries, the code uses `GetAddressesFromCandidatePubkeys` which returns BOTH the default address AND the CURRENT profits receiver: [2](#0-1) 

**Affected Functions:**

1. **UpdateBasicMinerRewardWeights** - Removes beneficiaries using `GetAddressesFromCandidatePubkeys`: [3](#0-2) 

But adds beneficiaries using the current `GetProfitsReceiver`: [4](#0-3) 

2. **UpdateWelcomeRewardWeights** - Removes using `GetAddressesFromCandidatePubkeys`: [5](#0-4) 

But adds using current `GetProfitsReceiver`: [6](#0-5) 

3. **UpdateFlexibleRewardWeights** - Removes using `GetAddressesFromCandidatePubkeys`: [7](#0-6) 

**Why Protections Fail:**

The Profit contract's `RemoveBeneficiary` function returns silently when the beneficiary doesn't exist: [8](#0-7) 

This means when attempting to remove the wrong address (current receiver instead of old receiver), the removal fails silently without error, leaving the old receiver as a stale beneficiary.

**Execution Path:**

1. Term N: Miner with pubkey PK1 has custom receiver CustomAddr1, which is added as beneficiary
2. Between Terms: `SetProfitsReceiver` changes receiver from CustomAddr1 to CustomAddr2, updating `State.ProfitsReceiverMap[PK1]` [9](#0-8) 

3. Term N+2: Removal attempts using `GetAddressesFromCandidatePubkeys` returns [DefaultAddr, CustomAddr2]
4. Both removal attempts fail silently (neither exists as beneficiary)
5. CustomAddr1 remains as stale beneficiary permanently

Note: `SetProfitsReceiver` only updates the Election contract's BackupSubsidy scheme, NOT the Treasury's BasicReward/Welcome/Flexible schemes: [10](#0-9) 

### Impact Explanation

**Direct Fund Impact - Reward Misallocation:**
- Stale beneficiaries continue accumulating profit shares in BasicReward, WelcomeReward, and FlexibleReward schemes indefinitely
- Each term (7 days), mining rewards are distributed according to beneficiary shares, with stale addresses receiving portions they should not
- The legitimate new receiver never receives rewards for past periods in these schemes
- This creates permanent fund leakage where rewards are misdirected to addresses that should no longer be beneficiaries

**Quantified Damage:**
- Mining rewards are substantial (1,000,000 * 1,250,000 ELF per term based on block production)
- BasicReward receives ~40% of miner rewards (4/10 default weight)
- Each stale beneficiary continues receiving their share (typically 1 share per miner, adjusted by performance)
- If 10% of active miners change their receiver address, and rewards continue for 52 terms (1 year), the misallocation compounds significantly

**Affected Parties:**
1. **Legitimate receivers**: Do not receive rewards they are entitled to for basic/welcome/flexible schemes
2. **Old receiver addresses**: May be compromised, malicious, or belong to former administrators who should no longer receive rewards
3. **Protocol integrity**: Reward distribution accuracy is compromised, violating the economic model

**Severity Justification - HIGH:**
- Permanent fund misallocation with no automatic cleanup mechanism
- Affects multiple critical reward schemes (Basic, Welcome, Flexible)
- No access control required beyond normal SetProfitsReceiver permission
- Accumulates over time with each receiver address change
- Cannot be easily detected as beneficiary lists are not regularly audited

### Likelihood Explanation

**Attacker Capabilities:**
- Any candidate admin can call `SetProfitsReceiver` for their candidate's pubkey [11](#0-10) 

- This is a legitimate, expected operation for managing profit distributions
- No special permissions beyond being a candidate admin are required

**Attack Complexity - LOW:**
1. Become a candidate and get elected as miner
2. Set a custom profits receiver (CustomAddr1) to receive rewards
3. Continue mining for at least one term to receive beneficiary status
4. Change profits receiver to a different address (CustomAddr2) via `SetProfitsReceiver`
5. CustomAddr1 automatically becomes a stale beneficiary without any additional action
6. Wait for subsequent term distributions to receive ongoing rewards at both addresses

**Feasibility Conditions:**
- Miner must be active and producing blocks (normal operation)
- Must have ability to call `SetProfitsReceiver` (standard for candidate admins)
- No suspicious transactions required - all operations are legitimate use cases
- Trigger is automatic during normal term transitions

**Detection/Operational Constraints:**
- Very difficult to detect as beneficiary changes are logged but historical mappings are not stored
- No alerts or monitoring for beneficiary count mismatches
- Would require manual audit of profit scheme beneficiaries vs current miner list
- Legitimate use case (changing receivers) makes patterns indistinguishable from exploitation

**Probability - HIGH:**
- Occurs naturally whenever any miner changes their profits receiver while active
- Even non-malicious address changes trigger the vulnerability
- With dozens of active miners changing receivers over time, accumulation is inevitable
- No cleanup mechanism exists, so issue compounds continuously

### Recommendation

**Code-Level Mitigation:**

1. **Store Historical Receiver Mappings:** Maintain a record of which address was actually added as beneficiary for each pubkey-term combination:

```csharp
// In TreasuryContractState.cs
public MappedState<string, long, Address> HistoricalProfitsReceiverMap { get; set; }
```

2. **Update GetAddressesFromCandidatePubkeys to use historical data:**

```csharp
private List<Address> GetAddressesFromCandidatePubkeys(ICollection<string> pubkeys, long termNumber)
{
    var addresses = new List<Address>();
    foreach (var pubkey in pubkeys)
    {
        // Add default address
        addresses.Add(Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey)));
        
        // Add the HISTORICAL receiver that was used when beneficiary was added
        var historicalReceiver = State.HistoricalProfitsReceiverMap[pubkey][termNumber];
        if (historicalReceiver != null)
        {
            addresses.Add(historicalReceiver);
        }
    }
    return addresses.Distinct().ToList();
}
```

3. **Store receiver address when adding beneficiaries:**

```csharp
// In UpdateBasicMinerRewardWeights after line 816
State.HistoricalProfitsReceiverMap[i.Pubkey][previousTermInformation.Last().TermNumber] = 
    GetProfitsReceiver(i.Pubkey);
```

4. **Update all three affected functions** (UpdateBasicMinerRewardWeights, UpdateWelcomeRewardWeights, UpdateFlexibleRewardWeights) to pass term numbers and use historical mappings.

**Invariant Checks:**
- Assert that beneficiary removal actually removes expected addresses
- Add event logging for beneficiary additions/removals with addresses
- Implement periodic reconciliation between expected and actual beneficiaries

**Test Cases:**
1. Test changing profits receiver between terms and verify old receiver is properly removed
2. Test multiple receiver changes and verify no stale beneficiaries accumulate
3. Test edge case of receiver changing back to default address
4. Test concurrent changes across multiple miners

### Proof of Concept

**Initial State:**
- Miner Alice with pubkey PK_ALICE is an active block producer
- Alice's admin is ADMIN_ALICE
- Current term is N

**Transaction Sequence:**

1. **Term N - Set Custom Receiver:**
   - ADMIN_ALICE calls `TreasuryContract.SetProfitsReceiver(PK_ALICE, CUSTOM_ADDR_1)`
   - State.ProfitsReceiverMap[PK_ALICE] = CUSTOM_ADDR_1

2. **Term N - Alice Produces Blocks:**
   - Alice produces blocks and earns rewards
   - During term N release, `UpdateBasicMinerRewardWeights` is called
   - Beneficiary added: CUSTOM_ADDR_1 (via GetProfitsReceiver(PK_ALICE))

3. **Between Term N and N+2 - Change Receiver:**
   - ADMIN_ALICE calls `TreasuryContract.SetProfitsReceiver(PK_ALICE, CUSTOM_ADDR_2)`
   - State.ProfitsReceiverMap[PK_ALICE] = CUSTOM_ADDR_2
   - Election contract updates BackupSubsidy (removes CUSTOM_ADDR_1, adds CUSTOM_ADDR_2)
   - BasicReward beneficiaries remain unchanged (CUSTOM_ADDR_1 still beneficiary)

4. **Term N+2 - Attempt Removal:**
   - `UpdateBasicMinerRewardWeights` called with previousTermInformation from term N
   - `GetAddressesFromCandidatePubkeys([PK_ALICE])` returns [DEFAULT_ADDR_ALICE, CUSTOM_ADDR_2]
   - `RemoveBeneficiaries` attempts to remove both addresses
   - DEFAULT_ADDR_ALICE removal: fails silently (never was beneficiary)
   - CUSTOM_ADDR_2 removal: fails silently (never was beneficiary)
   - CUSTOM_ADDR_1 is NEVER removed

5. **Term N+3 and Beyond - Ongoing Distribution:**
   - `DistributeProfits` called for BasicReward scheme
   - CUSTOM_ADDR_1 continues receiving profit shares
   - CUSTOM_ADDR_2 receives nothing from BasicReward
   - Funds permanently misdirected to CUSTOM_ADDR_1

**Expected Result:** CUSTOM_ADDR_1 should be removed from beneficiaries in step 4

**Actual Result:** CUSTOM_ADDR_1 remains as stale beneficiary and continues receiving rewards indefinitely

**Success Condition:** Query `ProfitContract.GetProfitDetails` for BasicReward scheme shows CUSTOM_ADDR_1 as beneficiary after term N+2, despite being replaced by CUSTOM_ADDR_2 in the profits receiver mapping.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L606-609)
```csharp
        var pubkey = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.Pubkey));
        
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L614-620)
```csharp
        var previousProfitsReceiver = State.ProfitsReceiverMap[input.Pubkey];
        //Set same profits receiver address.
        if (input.ProfitsReceiverAddress == previousProfitsReceiver)
        {
            return new Empty();
        }
        State.ProfitsReceiverMap[input.Pubkey] = input.ProfitsReceiverAddress;
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L651-655)
```csharp
    private Address GetProfitsReceiver(string pubkey)
    {
        return State.ProfitsReceiverMap[pubkey] ??
               Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey));
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L657-663)
```csharp
    private List<Address> GetAddressesFromCandidatePubkeys(ICollection<string> pubkeys)
    {
        var addresses = pubkeys.Select(k => Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)))
            .ToList();
        addresses.AddRange(pubkeys.Select(GetProfitsReceiver));
        return addresses;
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L780-787)
```csharp
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L814-821)
```csharp
                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L850-857)
```csharp
        var previousMinerAddresses =
            GetAddressesFromCandidatePubkeys(previousTermInformation.RealTimeMinersInformation.Keys);
        var possibleWelcomeBeneficiaries = new RemoveBeneficiariesInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            Beneficiaries = { previousMinerAddresses }
        };
        State.ProfitContract.RemoveBeneficiaries.Send(possibleWelcomeBeneficiaries);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L872-877)
```csharp
            foreach (var minerAddress in newElectedMiners.Select(GetProfitsReceiver))
                newBeneficiaries.BeneficiaryShares.Add(new BeneficiaryShare
                {
                    Beneficiary = minerAddress,
                    Shares = 1
                });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L907-913)
```csharp
            var previousMinerAddresses =
                GetAddressesFromCandidatePubkeys(previousTermInformation.RealTimeMinersInformation.Keys);
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.ReElectionRewardHash.Value,
                Beneficiaries = { previousMinerAddresses }
            });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L233-235)
```csharp
        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L379-398)
```csharp
    public override Empty SetProfitsReceiver(SetProfitsReceiverInput input)
    {
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName) == Context.Sender,
            "No permission.");
        var rankingList = State.DataCentersRankingList;
        if (!rankingList.Value.DataCenters.ContainsKey(input.CandidatePubkey)) return new Empty();
        var beneficiaryAddress = input.PreviousReceiverAddress.Value.Any()
            ? input.PreviousReceiverAddress
            : Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.CandidatePubkey));
        //set same profits receiver address
        if (beneficiaryAddress == input.ReceiverAddress)
        {
            return new Empty();
        }
        RemoveBeneficiary(input.CandidatePubkey,beneficiaryAddress);
        AddBeneficiary(input.CandidatePubkey,input.ReceiverAddress);

        return new Empty();
    }
```
