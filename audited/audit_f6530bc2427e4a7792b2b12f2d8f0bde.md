### Title
Non-Deterministic Order Conflict Resolution in ApplyNormalConsensusData Breaks Consensus

### Summary
The `ApplyNormalConsensusData` function iterates over `RealTimeMinersInformation.Values` without explicit ordering when resolving order conflicts for the next round. Since protobuf maps are implemented as C# Dictionary objects with undefined iteration order, different nodes may process conflicting miners in different sequences, resulting in different final `FinalOrderOfNextRound` assignments and breaking blockchain consensus.

### Finding Description

**Location**: [1](#0-0) 

**Root Cause**: The conflict resolution logic queries `RealTimeMinersInformation.Values.Where(...)` to find miners with conflicting orders, then iterates over this collection without explicit ordering. The `RealTimeMinersInformation` field is a protobuf map [2](#0-1) , which translates to a C# Dictionary with undefined iteration order.

When multiple miners have the same `FinalOrderOfNextRound`, the conflict resolution loop reassigns each conflicting miner to the next available order slot. The specific order assigned to each miner depends on the iteration sequence, which is non-deterministic.

**Why Protections Fail**: The codebase explicitly uses `.OrderBy()` in other consensus-critical locations:
- [3](#0-2)  orders by `FinalOrderOfNextRound`
- [4](#0-3)  orders by `Order`
- [5](#0-4)  orders by `Order`

However, `ApplyNormalConsensusData` lacks this ordering, creating an inconsistency.

**Execution Path**: This function is called from [6](#0-5)  during block production when miners update their consensus information. The resulting `updatedRound` becomes part of the block's consensus extra data [7](#0-6) .

### Impact Explanation

**Consensus Integrity Violation**: When multiple miners have conflicting `FinalOrderOfNextRound` values (due to hash collisions in signature-based order calculation or edge cases), different nodes iterating in different orders will produce different Round states. This breaks the fundamental requirement that all nodes must reach identical state given the same inputs.

**Concrete Scenario**:
- Assume 5 miners, and miners A and B both currently have `FinalOrderOfNextRound = 3`
- New miner C produces a block with `supposedOrderOfNextRound = 3`
- Node X iterates [A, B]: assigns A→4, B→5, C→3
- Node Y iterates [B, A]: assigns B→4, A→5, C→3
- Result: Different Round states (A and B have swapped orders)

**Who is Affected**: All network nodes attempting to validate consensus data. The miner schedule for the next round depends on `FinalOrderOfNextRound` ordering [8](#0-7) , so this non-determinism directly affects block production order and consensus integrity.

**Severity**: HIGH - Breaks core consensus invariant requiring deterministic state transitions.

### Likelihood Explanation

**Preconditions**: 
1. Multiple miners must have the same `FinalOrderOfNextRound` value simultaneously
2. A new miner produces a block claiming that same order

**Trigger Mechanisms**:
- **Hash Collisions**: The `supposedOrderOfNextRound` is calculated as `GetAbsModulus(sigNum, minersCount) + 1` [9](#0-8) . With modulo operation, collisions are mathematically possible.
- **Concurrent Updates**: Multiple miners can call this function in the same round, and intermediate states may have duplicates.
- **State Inconsistencies**: Edge cases during round transitions or miner replacement could create duplicate orders.

**Complexity**: LOW - No special attacker capabilities required. The issue manifests from normal protocol operation under specific mathematical conditions.

**Detection**: DIFFICULT - The non-determinism only manifests when nodes have different C# Dictionary iteration orders, which may not be obvious in testing environments where iteration happens to be consistent.

**Probability**: MEDIUM - While the comment at line 29 states "Multiple conflicts is unlikely" [10](#0-9) , it acknowledges conflicts can occur, and the code explicitly handles them. The mathematical possibility of hash collisions combined with the codebase's explicit conflict handling logic indicates this is a real concern.

### Recommendation

**Immediate Fix**: Add explicit ordering to the conflicts collection before iteration:

```csharp
var conflicts = RealTimeMinersInformation.Values
    .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound)
    .OrderBy(i => i.Pubkey)  // Add deterministic ordering by pubkey
    .ToList();
```

**Rationale**: Ordering by `Pubkey` (string) ensures consistent, deterministic iteration across all nodes, matching the pattern used elsewhere in the codebase where dictionary values are sorted.

**Additional Checks**:
1. Add unit tests that verify deterministic behavior when multiple conflicts exist
2. Add assertions to detect duplicate `FinalOrderOfNextRound` values after conflict resolution
3. Consider adding validation in [11](#0-10)  to ensure no duplicate orders exist

**Regression Prevention**: Add test cases that:
- Create scenarios with 3+ miners having the same `FinalOrderOfNextRound`
- Verify conflict resolution produces identical results across multiple executions
- Test with different dictionary iteration orders (can be simulated with different hash seeds)

### Proof of Concept

**Initial State**:
- Round with 5 miners: [M1, M2, M3, M4, M5]
- M1.FinalOrderOfNextRound = 2
- M2.FinalOrderOfNextRound = 3  
- M3.FinalOrderOfNextRound = 3 (duplicate due to previous hash collision)
- M4.FinalOrderOfNextRound = 4
- M5.FinalOrderOfNextRound = 5

**Transaction**: M6 produces block with signature that results in `supposedOrderOfNextRound = 3`

**Expected Behavior**: Deterministic conflict resolution where M2 and M3 are reassigned to orders 1 and 6 in a consistent manner across all nodes.

**Actual Result (Non-Deterministic)**:
- **Node A** (iterates [M2, M3]): 
  - M2 gets reassigned to order 1
  - M3 gets reassigned to order 6
  - Final: M1=2, M2=1, M3=6, M4=4, M5=5, M6=3

- **Node B** (iterates [M3, M2]):
  - M3 gets reassigned to order 1  
  - M2 gets reassigned to order 6
  - Final: M1=2, M2=6, M3=1, M4=4, M5=5, M6=3

**Success Condition**: Different nodes produce different Round states (M2 and M3 have swapped final orders), causing consensus failure when nodes attempt to validate each other's blocks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-40)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** protobuf/aedpos_contract.proto (L247-247)
```text
    map<string, MinerInRound> real_time_miners_information = 2;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L112-112)
```csharp
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L35-35)
```csharp
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L128-133)
```csharp
        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = updatedRound,
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-20)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
```
