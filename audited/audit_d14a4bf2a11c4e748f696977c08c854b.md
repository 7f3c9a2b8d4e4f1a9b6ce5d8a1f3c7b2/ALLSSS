### Title
Recovery Event Skipped During Severe→Abnormal→Severe Status Transitions

### Summary
The `GetMaximumBlocksCount()` function fails to fire the recovery event (`IrreversibleBlockHeightUnacceptable` with distance = 0) when blockchain status transitions from Severe to Abnormal status. If the system subsequently re-enters Severe status, the `IsPreviousBlockInSevereStatus` flag remains true throughout without the recovery event being fired, breaking the event consistency invariant and causing monitoring/notification gaps.

### Finding Description

The vulnerability exists in the `GetMaximumBlocksCount()` function which has three execution paths based on blockchain mining status: [1](#0-0) 

**Path 1 (Abnormal status)**: Returns early after calculating an adjusted block count. This path does NOT check or modify the `IsPreviousBlockInSevereStatus` flag and does NOT fire any recovery event. [2](#0-1) 

**Path 2 (Severe status)**: Fires the `IrreversibleBlockHeightUnacceptable` event with a positive distance value and sets `IsPreviousBlockInSevereStatus.Value = true`. [3](#0-2) 

**Path 3 (Normal status with recovery)**: Only fires the recovery event (distance = 0) when the status is Normal AND the flag is still true.

**Root Cause**: The Abnormal status path (lines 42-55) does not handle the case where the previous block was in Severe status. When transitioning from Severe→Abnormal, the flag remains true but no recovery event is fired.

**Status Evaluation Logic**: [4](#0-3) 

- Normal: R ≤ R_LIB + 2
- Abnormal: R_LIB + 2 < R < R_LIB + CB1 (where CB1 = Max(8, MaximumTinyBlocksCount))
- Severe: R ≥ R_LIB + CB1

**Exploitation Path**: When the Last Irreversible Block (LIB) advances significantly during Severe status, the current round R can fall into the Abnormal range (R < R_LIB + CB1). The system exits Severe but the recovery event is never fired because the Abnormal path doesn't handle it. If new rounds are then added without LIB advancing, the system can re-enter Severe status with the flag still set to true.

### Impact Explanation

**Event Consistency Violation**: The recovery event serves as a notification to external systems that the severe blockchain condition has been resolved. The event processor relies on this notification: [5](#0-4) 

When distance > 0, the system triggers a chain rollback. The recovery event (distance = 0) signals that severe status has ended.

**Concrete Harms**:
1. **Monitoring Gap**: External monitoring systems won't be notified that the severe condition was temporarily resolved
2. **Event Contract Violation**: Breaks the invariant that every Severe status entry should have a corresponding recovery notification
3. **State Inconsistency**: The `IsPreviousBlockInSevereStatus` flag remains in an inconsistent state, indicating a previous severe status that never properly recovered
4. **Operational Impact**: Event-driven systems expecting the recovery notification for alerting or automated recovery processes won't receive it

**Who is Affected**: Blockchain operators, monitoring systems, and any external systems that rely on the complete event stream for consensus health tracking.

### Likelihood Explanation

**Feasibility**: The Severe→Abnormal transition occurs naturally when the Last Irreversible Block (LIB) catches up during a severe condition. This is a normal operational scenario, not requiring any attacker action.

**Realistic Conditions**:
- Initial state: R_LIB = 100, R = 109, CB1 = 8 → Severe (109 ≥ 108)
- LIB advances: R_LIB = 105, R = 110 → Abnormal (107 < 110 < 113)
- New rounds: R_LIB = 105, R = 114 → Severe (114 ≥ 113)

**Probability**: Medium-High. This occurs whenever:
1. The blockchain enters Severe status (R falls significantly behind R_LIB)
2. LIB makes progress and catches up partially (moving status to Abnormal)
3. New blocks are produced before LIB fully catches up (returning to Severe)

This is a natural blockchain dynamic that can occur during network congestion, temporary partitions, or block production irregularities.

**No Attacker Required**: This is not an exploit requiring malicious action—it's a logic flaw in the normal consensus flow.

### Recommendation

**Fix**: Add recovery event handling to the Abnormal status path. After the existing Abnormal block calculation logic (before line 54 return), add:

```csharp
if (State.IsPreviousBlockInSevereStatus.Value)
{
    Context.Fire(new IrreversibleBlockHeightUnacceptable
    {
        DistanceToIrreversibleBlockHeight = 0
    });
    State.IsPreviousBlockInSevereStatus.Value = false;
}
```

**Invariant to Enforce**: Any transition OUT of Severe status (to either Normal or Abnormal) must fire the recovery event if `IsPreviousBlockInSevereStatus` is true.

**Test Cases**:
1. Test Severe→Abnormal transition: Verify recovery event is fired and flag is reset
2. Test Severe→Abnormal→Severe transition: Verify recovery event fires during Abnormal phase
3. Test Severe→Normal transition: Verify existing behavior (recovery event) is maintained
4. Verify event count matches: number of Severe events (distance > 0) should equal number of recovery events (distance = 0) over the blockchain lifetime

### Proof of Concept

**Initial State**:
- Current Round Number (R) = 109
- Last Irreversible Block Round (R_LIB) = 100
- SevereStatusRoundsThreshold (CB1) = 8
- `IsPreviousBlockInSevereStatus.Value` = false

**Step 1 - Enter Severe Status**:
- Call `GetMaximumBlocksCount()`
- Status = Severe (109 ≥ 100 + 8)
- Event fired: `IrreversibleBlockHeightUnacceptable` with distance > 0
- `IsPreviousBlockInSevereStatus.Value` = true
- Returns 1

**Step 2 - LIB Advances, Status Becomes Abnormal**:
- LIB advances to R_LIB = 105
- Current Round R = 110
- Call `GetMaximumBlocksCount()`
- Status = Abnormal (105 + 2 < 110 < 105 + 8)
- Enters Abnormal branch (lines 42-55)
- **Expected**: Recovery event should fire, flag should be reset to false
- **Actual**: NO recovery event fired, flag remains true
- Returns calculated count

**Step 3 - Re-enter Severe Status**:
- New rounds added, R = 114
- R_LIB still = 105
- Call `GetMaximumBlocksCount()`
- Status = Severe (114 ≥ 105 + 8)
- Event fired: `IrreversibleBlockHeightUnacceptable` with distance > 0
- Flag remains true (already true from Step 1)
- Returns 1

**Success Condition**: The recovery event was never fired between the two Severe status periods, violating the event consistency invariant.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L42-55)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L69-78)
```csharp
        if (!State.IsPreviousBlockInSevereStatus.Value)
            return AEDPoSContractConstants.MaximumTinyBlocksCount;

        Context.Fire(new IrreversibleBlockHeightUnacceptable
        {
            DistanceToIrreversibleBlockHeight = 0
        });
        State.IsPreviousBlockInSevereStatus.Value = false;

        return AEDPoSContractConstants.MaximumTinyBlocksCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L119-129)
```csharp
        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
        }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockHeightUnacceptableLogEventProcessor.cs (L54-64)
```csharp
        if (distanceToLib.DistanceToIrreversibleBlockHeight > 0)
        {
            Logger.LogDebug($"Distance to lib height: {distanceToLib.DistanceToIrreversibleBlockHeight}");
            Logger.LogDebug("Will rollback to lib height.");
            _taskQueueManager.Enqueue(
                async () =>
                {
                    var chain = await _blockchainService.GetChainAsync();
                    await _blockchainService.ResetChainToLibAsync(chain);
                }, KernelConstants.UpdateChainQueueName);
        }
```
