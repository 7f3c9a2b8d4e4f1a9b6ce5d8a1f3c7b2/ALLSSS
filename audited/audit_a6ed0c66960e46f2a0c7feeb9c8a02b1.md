### Title
Vote Contract Allows Unrestricted Post-Registration Option Manipulation Enabling Vote Outcome Manipulation

### Summary
The Vote contract's `GetHash` function intentionally excludes options from the voting item ID hash, allowing sponsors to add or remove options after registration via `AddOption`/`RemoveOption` without any timestamp or voting status validation. This design enables sponsors to manipulate vote outcomes by freezing votes for leading options or introducing new options mid-vote, compromising voting integrity for generic voting items outside the Election contract's specialized mitigation logic.

### Finding Description

The voting item ID is generated by hashing the registration input WITHOUT options: [1](#0-0) 

This stable ID design allows the sponsor to modify options after registration through public methods that only verify sponsor authorization: [2](#0-1) [3](#0-2) 

**Root Cause**: No timestamp or voting status validation exists in `AddOption`/`RemoveOption`. These methods only check:
1. Voting item existence
2. Sponsor authorization  
3. Option length/uniqueness
4. Maximum option count

The `Vote` method enforces that voters can only vote for options that CURRENTLY exist: [4](#0-3) 

**Why Existing Protections Fail**:
- Registration validation only checks start/end timestamps are valid, not that options are immutable: [5](#0-4) 

- Vote validation checks snapshot number but NOT option modification permissions: [6](#0-5) 

- Tests confirm AddOption/RemoveOption work during active voting with no time restrictions: [7](#0-6) [8](#0-7) 

**Execution Path**:
1. Sponsor registers voting item with initial options via `Register`: [9](#0-8) 

2. Users cast votes; votes accumulate in `VotingResult.Results` map: [10](#0-9) 

3. Sponsor calls `RemoveOption` to remove a leading option (no timestamp check prevents this)
4. Votes for removed option remain in Results but new votes cannot be cast for it
5. OR sponsor calls `AddOption` to add new option mid-vote that didn't exist when voting started

### Impact Explanation

**Vote Outcome Manipulation**: 
- **Freezing Leading Options**: Sponsor removes options with high vote counts, preventing additional votes while allowing competing options to accumulate votes unrestricted
- **Late-Stage Option Injection**: Sponsor adds new options after significant voting has occurred, enabling options that weren't available to early voters to win

**Affected Parties**:
- Generic voting item users (governance votes, funding decisions, community polls)
- The Election contract has partial mitigation through pubkey replacement tracking, but even it is vulnerable when candidates quit without replacement: [11](#0-10) 

**Concrete Example**:
1. DAO creates voting item: "Treasury Fund Allocation" with options ["Project A", "Project B", "Project C"]
2. Community votes over 7 days: A=10,000 votes, B=5,000 votes, C=3,000 votes
3. Day 6: Sponsor (compromised or malicious) calls `RemoveOption("Project A")`
4. Day 7: Only B and C receive new votes; B reaches 11,000 votes
5. Project B "wins" despite Project A originally leading with 10,000 votes

**Severity Justification**: High for generic voting items, Medium for Election (has partial mitigation). Violates fundamental voting integrity principle that options should be fixed once voting begins.

### Likelihood Explanation

**Reachable Entry Point**: [12](#0-11) 
These are public RPC methods callable by anyone who is the sponsor.

**Feasible Preconditions**:
- Attacker must be the voting item sponsor OR compromise sponsor account
- For legitimate sponsors: economic/political incentive to manipulate outcomes
- For governance voting items: sponsor is often a smart contract that could have exploitable upgrade/admin logic

**Execution Practicality**:
- Single transaction call to `AddOption` or `RemoveOption`
- No complex state setup required
- Transaction cost minimal (standard gas fees)
- Election contract demonstrates this is actively used functionality: [13](#0-12) 

**Detection/Operational Constraints**:
- Option modifications are on-chain and visible
- However, users may not monitor option changes continuously
- No events are fired for option modifications
- VotingResult still contains removed options, making manipulation subtle

**Probability**: Medium-High. While requires sponsor role, many voting scenarios have sponsors with conflicts of interest or multi-sig sponsors where compromise is feasible.

### Recommendation

**1. Add Voting Status Validation**:
Modify `AddOption` and `RemoveOption` to check voting status before allowing modifications:

```csharp
public override Empty AddOption(AddOptionInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
    
    // NEW: Prevent option modification after voting starts
    Assert(Context.CurrentBlockTime < votingItem.StartTimestamp, 
        "Cannot modify options after voting has started.");
    
    AssertOption(votingItem, input.Option);
    Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
        $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
    votingItem.Options.Add(input.Option);
    State.VotingItems[votingItem.VotingItemId] = votingItem;
    return new Empty();
}
```

Apply same check to `RemoveOption`, `AddOptions`, `RemoveOptions`.

**2. Alternative Design - Immutable Options**:
For generic voting items, consider including options in the hash or adding a `LockOptions` method that prevents further modifications once voting begins.

**3. Election Contract Exception**:
Add a boolean flag `AllowDynamicOptions` to `VotingRegisterInput` that only Election contract can set to true, allowing it to maintain current candidate management behavior while protecting generic voting items.

**4. Emit Events**:
Add events for option modifications so monitoring tools can track changes:
```csharp
Context.Fire(new OptionModified
{
    VotingItemId = votingItem.VotingItemId,
    Option = input.Option,
    Action = "Added",
    Timestamp = Context.CurrentBlockTime
});
```

**5. Test Cases**:
- Test that AddOption/RemoveOption fail after StartTimestamp
- Test that options remain immutable during active voting period
- Test Election contract can still manage candidates with AllowDynamicOptions flag

### Proof of Concept

**Initial State**:
- Sponsor registers voting item with StartTimestamp = now + 1 day, EndTimestamp = now + 8 days
- Options = ["Option A", "Option B", "Option C"]
- Voting item created successfully with stable ID (options excluded from hash)

**Attack Sequence**:

1. **Day 1-5**: Normal voting occurs
   - Alice votes 5,000 tokens for "Option A"
   - Bob votes 3,000 tokens for "Option A"  
   - Carol votes 4,000 tokens for "Option B"
   - Total: A=8,000, B=4,000, C=0

2. **Day 6**: Sponsor manipulation
   ```
   Transaction: Sponsor.RemoveOption({
       VotingItemId: <voting_item_id>,
       Option: "Option A"
   })
   ```
   - Transaction succeeds (no timestamp check)
   - Option A removed from votingItem.Options
   - Existing votes (A=8,000) remain in VotingResult.Results["Option A"]

3. **Day 6-7**: Continued voting
   - Dave attempts to vote for "Option A"
   - **Transaction fails**: "Option Option A not found" (line 381 check)
   - Dave votes 5,000 for "Option B" instead
   - Eve votes 1,000 for "Option B"
   - New totals: A=8,000 (frozen), B=10,000, C=0

**Expected Result**: Option A should win with 8,000 votes, or at minimum remain a valid voting option throughout the voting period.

**Actual Result**: Option B wins with 10,000 votes. Option A's 8,000 votes are effectively disenfranchised. The sponsor successfully manipulated the vote outcome by removing the leading option mid-vote.

**Success Condition**: Sponsor call to `RemoveOption` succeeds during active voting period (between StartTimestamp and EndTimestamp), demonstrating the lack of temporal access control on option modification methods.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteExtensions.cs (L7-12)
```csharp
    public static Hash GetHash(this VotingRegisterInput votingItemInput, Address sponsorAddress)
    {
        var input = votingItemInput.Clone();
        input.Options.Clear();
        return HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(input), HashHelper.ComputeFrom(sponsorAddress));
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-54)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);

        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Accepted currency is in white list means this token symbol supports voting.
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");

        // Initialize voting event.
        var votingItem = new VotingItem
        {
            Sponsor = Context.Sender,
            VotingItemId = votingItemId,
            AcceptedCurrency = input.AcceptedCurrency,
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
        };

        State.VotingItems[votingItemId] = votingItem;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L280-290)
```csharp
    public override Empty AddOption(AddOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        AssertOption(votingItem, input.Option);
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        votingItem.Options.Add(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L303-312)
```csharp
    public override Empty RemoveOption(RemoveOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
        votingItem.Options.Remove(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L356-371)
```csharp
    public async Task VoteContract_AddOption_Success_Test()
    {
        var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1);
        var address = Accounts[3].Address.ToBase58();
        var transactionResult = (await VoteContractStub.AddOption.SendAsync(new AddOptionInput
        {
            Option = address,
            VotingItemId = registerItem.VotingItemId
        })).TransactionResult;

        transactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var votingItem = await GetVoteItem(registerItem.VotingItemId);
        votingItem.Options.Count.ShouldBe(4);
        votingItem.Options.Contains(address).ShouldBeTrue();
    }
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L435-450)
```csharp
    public async Task VoteContract_RemoveOption_Success_Test()
    {
        var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1);
        var removeOption = registerItem.Options[0];
        var transactionResult = (await VoteContractStub.RemoveOption.SendAsync(new RemoveOptionInput
        {
            Option = removeOption,
            VotingItemId = registerItem.VotingItemId
        })).TransactionResult;

        transactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var votingItem = await GetVoteItem(registerItem.VotingItemId);
        votingItem.Options.Count.ShouldBe(2);
        votingItem.Options.Contains(removeOption).ShouldBeFalse();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L257-261)
```csharp
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
```

**File:** protobuf/vote_contract.proto (L35-41)
```text
    // Add an option to a voting activity.
    rpc AddOption (AddOptionInput) returns (google.protobuf.Empty) {
    }

    // Remove an option from a voting activity.
    rpc RemoveOption (RemoveOptionInput) returns (google.protobuf.Empty) {
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L308-317)
```csharp
            State.VoteContract.RemoveOption.Send(new RemoveOptionInput
            {
                VotingItemId = State.MinerElectionVotingItemId.Value,
                Option = oldPubkey
            });
            State.VoteContract.AddOption.Send(new AddOptionInput
            {
                VotingItemId = State.MinerElectionVotingItemId.Value,
                Option = newPubkey
            });
```
