### Title
Side Chain Miner Count Limit Bypass via Cross-Chain Synchronization

### Summary
Side chains can operate with more miners than `MaximumMinersCount` allows because `UpdateInformationFromCrossChain` and `NextTermInput.Create()` do not validate the miner count against the configured limit. This allows a side chain to accept and persist an arbitrarily large miner list from the main chain, bypassing consensus safety constraints.

### Finding Description

The vulnerability exists in the cross-chain miner list synchronization path for side chains:

**Root Cause 1: No validation in cross-chain update** [1](#0-0) 

The `UpdateInformationFromCrossChain` method extracts all miners from the main chain's consensus information and stores them in `State.MainChainCurrentMinerList.Value` without checking if the count exceeds the side chain's `State.MaximumMinersCount.Value`.

**Root Cause 2: No validation in NextTermInput creation** [2](#0-1) 

The `Create()` method blindly copies all entries from `round.RealTimeMinersInformation` without validating the count against `MaximumMinersCount`.

**Root Cause 3: Side chain fallback uses unvalidated list** [3](#0-2) 

For side chains, `TryToGetVictories` returns false at: [4](#0-3) 

When victories are unavailable, the fallback path uses `currentRound.RealTimeMinersInformation.Keys` which may contain more miners than allowed.

**Root Cause 4: No validation in term processing** [5](#0-4) 

`ProcessNextTerm` creates a `MinerList` from ALL keys in `nextRound.RealTimeMinersInformation` (line 189) and stores it without checking if the count exceeds `MaximumMinersCount`.

**Root Cause 5: Insufficient validation** [6](#0-5) 

The `ValidationForNextTerm` method only validates term number and round number increments but does NOT check if `extraData.Round.RealTimeMinersInformation.Count` exceeds `State.MaximumMinersCount.Value`.

### Impact Explanation

**Consensus Integrity Violation:**
- Side chains can operate with more block producers than the governance-approved `MaximumMinersCount` limit
- If main chain has 25 miners and side chain limit is 17, the side chain will operate with all 25 miners
- This violates the consensus security model where miner count affects decentralization, block time intervals, and reward distribution

**Concrete Harm:**
1. **Security degradation**: More miners than intended reduces individual miner accountability and changes security assumptions
2. **Economic impact**: Reward distribution calculated for 17 miners but split among 25, creating accounting mismatches with the Election contract which receives the limited count via: [7](#0-6) 
3. **Governance bypass**: The `MaximumMinersCount` limit set by Parliament becomes unenforceable on side chains

**Affected Parties:**
- All side chain participants expecting the configured miner count limit
- Side chain governance expecting their `MaximumMinersCount` setting to be enforced
- Economics contracts receiving inconsistent miner counts

### Likelihood Explanation

**High Likelihood - This occurs during normal operations:**

1. **Reachable Entry Point**: `UpdateInformationFromCrossChain` is a public method callable by the CrossChain contract during routine cross-chain indexing: [8](#0-7) 

2. **Feasible Preconditions**:
   - Side chain exists with `MaximumMinersCount` configured
   - Main chain has more miners than side chain's limit
   - Cross-chain indexing is functioning (required for normal operation)

3. **Execution Practicality**: This happens automatically without any attacker action:
   - Main chain produces blocks with 25 miners
   - CrossChain contract indexes main chain consensus data
   - Calls `UpdateInformationFromCrossChain` with main chain's miner list
   - Side chain stores and uses all 25 miners despite limit of 17

4. **No Attack Required**: This is a design flaw, not an attack - it occurs during normal cross-chain synchronization whenever main chain miner count exceeds side chain's configured limit.

### Recommendation

**Add validation in multiple layers:**

1. **In `UpdateInformationFromCrossChain`**, add check after line 57:
```csharp
var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
Assert(minersKeys.Count <= State.MaximumMinersCount.Value, 
    $"Main chain miner count {minersKeys.Count} exceeds side chain maximum {State.MaximumMinersCount.Value}");
```

2. **In `NextTermInput.Create()`**, add validation:
```csharp
Assert(round.RealTimeMinersInformation.Count <= /* get max count from state */,
    "Miner count exceeds maximum allowed");
```

3. **In `ValidationForNextTerm`**, add check:
```csharp
var maxCount = /* access State.MaximumMinersCount.Value through context */;
if (extraData.Round.RealTimeMinersInformation.Count > maxCount)
    return new ValidationResult { Message = $"Miner count {extraData.Round.RealTimeMinersInformation.Count} exceeds maximum {maxCount}" };
```

4. **In `ProcessNextTerm`**, add assertion before line 189:
```csharp
Assert(nextRound.RealTimeMinersInformation.Count <= State.MaximumMinersCount.Value,
    "Term miner count exceeds configured maximum");
```

5. **Add test case**: Verify that attempting NextTerm with excessive miners fails validation, and cross-chain updates with too many miners are rejected.

### Proof of Concept

**Initial State:**
- Side chain deployed with `MaximumMinersCount` = 17
- Main chain operating with 25 miners
- Cross-chain indexing enabled between chains

**Attack Steps:**
1. Main chain produces block with 25 miners in consensus data
2. CrossChain contract indexes this block
3. CrossChain contract calls `AEDPoSContract.UpdateInformationFromCrossChain(mainChainConsensusData)`
4. Side chain stores all 25 miner pubkeys in `State.MainChainCurrentMinerList.Value`
5. On next term transition, `GenerateFirstRoundOfNextTerm` uses current round miners (25 total)
6. `NextTermInput.Create()` creates input with 25 miners in `RealTimeMinersInformation`
7. `ValidationForNextTerm` validates successfully (no miner count check)
8. `ProcessNextTerm` stores MinerList with all 25 miners
9. `UpdateMinersCountToElectionContract` sends limited count (17) to Election contract

**Expected Result:**
- Side chain should reject miner list exceeding its configured `MaximumMinersCount` of 17
- Or side chain should only use the first 17 miners from main chain list

**Actual Result:**
- Side chain accepts and operates with all 25 miners
- `MaximumMinersCount` limit is bypassed
- Inconsistency: Election contract believes there are 17 miners, but consensus operates with 25

**Success Condition:**
Query side chain's `GetCurrentMinerList()` returns 25 miners despite `GetMaximumMinersCount()` returning 17.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-38)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L57-61)
```csharp
        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```
