### Title
Unnecessary Privileged Access for TokenContract in DistributeProfits Enables Cross-Scheme Profit Manipulation

### Summary
The TokenHolderContract grants the TokenContract (MultiToken) system contract privileged access to distribute profits for any TokenHolder scheme, regardless of ownership. This authorization is unnecessary as TokenContract never calls this function in its implementation. If TokenContract contains a vulnerability or is maliciously upgraded through governance, an attacker could manipulate profit distributions for any scheme, causing incorrect dividend allocations and disrupting distribution cycles.

### Finding Description

The `DistributeProfits` function contains an authorization check that allows two callers: the scheme manager OR the TokenContract system contract. [1](#0-0) 

**Root Cause:** The authorization logic treats TokenContract as a privileged caller that can distribute profits for ANY scheme by providing an arbitrary `input.SchemeManager` address. Unlike normal callers where `Context.Sender == input.SchemeManager` (self-authorization), TokenContract can set `input.SchemeManager` to any victim address while `Context.Sender == TokenContract`, bypassing the ownership requirement.

**Why Protections Fail:**

1. The check validates the caller's identity but not the caller's relationship to the scheme being managed.

2. The `input.SchemeManager` parameter is user-controlled input, not validated against the caller's authority.

3. Investigation of the TokenContract implementation reveals zero references to `DistributeProfits` or `TokenHolder`, indicating this privilege is unused and unnecessary.

**Execution Path:**
- TokenContract (if compromised) → TokenHolderContract.DistributeProfits(SchemeManager=VictimAddress) → Pass authorization check → ProfitContract.DistributeProfits → Unauthorized distribution

The underlying ProfitContract also trusts TokenHolderContract as an authorized caller: [2](#0-1) 

This creates a privilege escalation chain where TokenContract's authority in TokenHolderContract translates to control over ProfitContract operations for any scheme.

### Impact Explanation

**Direct Financial Impact:**
- Unauthorized profit distributions to beneficiaries at incorrect times or amounts
- Period counter manipulation [3](#0-2)  disrupts distribution cycles
- Manipulated `AmountsMap` [4](#0-3)  can specify arbitrary distribution amounts

**Affected Parties:**
- All DApp contracts using TokenHolder profit schemes for dividend distribution
- Users who are beneficiaries of these schemes expecting correct profit allocations
- Example: A DApp contract like the test example [5](#0-4)  uses TokenHolder for profit distribution

**Severity Justification:**
- **HIGH** - Violates critical invariant: "Profit/Treasury/TokenHolder share calculations, donation/release logic, dividend distribution and settlement accuracy"
- Breaks fundamental access control model where only scheme managers control their schemes
- Creates systemic risk affecting the entire TokenHolder ecosystem

### Likelihood Explanation

**Attacker Capabilities Required:**

*Scenario A - TokenContract Vulnerability:*
- Discover a vulnerability in the TokenContract that allows calling arbitrary external contracts
- TokenContract is a large, complex system contract handling critical token operations (transfers, locks, approvals, NFTs, etc.)
- Higher attack surface due to complexity

*Scenario B - Malicious Upgrade:*
- AElf system contracts are upgradeable through governance proposals [6](#0-5) 
- If governance keys are compromised, TokenContract could be upgraded with malicious logic to exploit this privilege

**Attack Complexity:** Medium
- No complex cryptographic operations required
- Straightforward contract-to-contract call
- Parameters are simple: target scheme manager address and optional amounts map

**Feasibility Conditions:**
- TokenContract vulnerability discovery (precedented in smart contract ecosystems)
- OR governance compromise (requires multiple validators/parliament members)

**Detection Constraints:**
- Legitimate-looking transactions originating from trusted system contract
- Difficult to distinguish from normal operations without detailed scheme manager validation

**Probability Reasoning:** The likelihood is **MEDIUM** because while it requires either a vulnerability or governance compromise, both scenarios are realistic given:
1. TokenContract's complexity and critical role
2. Historical precedent of smart contract vulnerabilities
3. The unnecessary privilege violates defense-in-depth principles

### Recommendation

**Code-Level Mitigation:**

Remove TokenContract from the authorization check entirely:

```csharp
Assert(Context.Sender == input.SchemeManager, "No permission to distribute profits.");
```

**Rationale:**
- TokenContract has no legitimate use case for this privilege (verified by codebase analysis showing zero usage)
- Follows principle of least privilege
- Maintains intended security model: only scheme managers control their own schemes

**Invariant Check to Add:**
If TokenContract truly needs this capability in the future, add explicit validation:
```csharp
if (Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName)) {
    Assert(IsTokenContractAuthorizedForScheme(input.SchemeManager), 
           "TokenContract not authorized for this scheme");
}
```

**Test Cases to Prevent Regression:**
1. Test that TokenContract cannot call DistributeProfits for schemes it doesn't manage
2. Test that only scheme managers can distribute profits for their own schemes
3. Test that period increments only occur through authorized distributions

### Proof of Concept

**Required Initial State:**
1. DApp contract deploys and creates a TokenHolder profit scheme with itself as manager
2. Scheme accumulates profits (100,000 ELF) waiting for periodic distribution
3. TokenContract contains a vulnerability or is maliciously upgraded

**Transaction Steps:**

Step 1 - Attacker exploits TokenContract vulnerability:
```
Attacker → TokenContract.VulnerableFunction() {
    // Malicious code calls:
    TokenHolderContract.DistributeProfits({
        SchemeManager: DAppContractAddress,
        AmountsMap: { "ELF": 200000 }  // Double the actual amount
    })
}
```

Step 2 - Authorization bypass occurs:
- Check: `Context.Sender == TokenContract` ✓ (passes)
- GetValidScheme retrieves DAppContract's scheme
- Calls ProfitContract.DistributeProfits with manipulated amounts

Step 3 - Period counter incremented [3](#0-2) 

**Expected vs Actual Result:**
- **Expected:** Only DAppContract can distribute its own scheme's profits when appropriate
- **Actual:** TokenContract distributes profits prematurely with manipulated amounts, disrupting distribution cycle

**Success Condition:**
- Profits distributed to beneficiaries at wrong time
- Period counter advanced without DAppContract authorization
- DAppContract's distribution logic broken for subsequent cycles

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L134-135)
```csharp
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L141-141)
```csharp
        if (input.AmountsMap != null && input.AmountsMap.Any()) distributeProfitsInput.AmountsMap.Add(input.AmountsMap);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L144-145)
```csharp
        scheme.Period = scheme.Period.Add(1);
        State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L426-428)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");
```

**File:** test/AElf.Contracts.TestContract.DApp/DAppContract_ACS9.cs (L40-43)
```csharp
        State.TokenHolderContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeManager = Context.Self
        });
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L98-144)
```csharp
    private void UpdateSmartContract(Address contractAddress, byte[] code, Address author, bool isUserContract)
    {
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        Assert(author == info.Author, "No permission.");

        var oldCodeHash = info.CodeHash;
        var newCodeHash = HashHelper.ComputeFrom(code);
        Assert(oldCodeHash != newCodeHash, "Code is not changed.");
        AssertContractNotExists(newCodeHash);

        info.CodeHash = newCodeHash;
        info.IsUserContract = isUserContract;
        info.Version++;

        var reg = new SmartContractRegistration
        {
            Category = info.Category,
            Code = ByteString.CopyFrom(code),
            CodeHash = newCodeHash,
            IsSystemContract = info.IsSystemContract,
            Version = info.Version,
            ContractAddress = contractAddress,
            IsUserContract = isUserContract
        };

        var contractInfo = Context.UpdateSmartContract(contractAddress, reg, null, info.ContractVersion);
        Assert(contractInfo.IsSubsequentVersion,
            $"The version to be deployed is lower than the effective version({info.ContractVersion}), please correct the version number.");

        info.ContractVersion = contractInfo.ContractVersion;
        reg.ContractVersion = info.ContractVersion;

        State.ContractInfos[contractAddress] = info;
        State.SmartContractRegistrations[reg.CodeHash] = reg;

        Context.Fire(new CodeUpdated
        {
            Address = contractAddress,
            OldCodeHash = oldCodeHash,
            NewCodeHash = newCodeHash,
            Version = info.Version,
            ContractVersion = info.ContractVersion
        });

        Context.LogDebug(() => "BasicContractZero - update success: " + contractAddress.ToBase58());
    }
```
