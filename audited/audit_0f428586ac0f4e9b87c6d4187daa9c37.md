### Title
Duplicate Options Can Bypass Validation in AddOptions and Register Methods

### Summary
The `AddOptions` method validates each option individually against existing options but does not check for duplicates within the input array itself, allowing multiple identical options to be added in a single transaction. Similarly, the `Register` method accepts initial options without any duplicate validation. This violates the uniqueness invariant enforced by the `AddOption` method and can lead to option slot exhaustion and data integrity issues.

### Finding Description

The Vote contract has three methods for managing options: `AddOption`, `AddOptions`, and `Register`. However, duplicate validation is inconsistent across these methods. [1](#0-0) 

The `AssertOption` helper performs validation in this order:
1. Length check (≤1024 bytes)  
2. Duplicate check using `votingItem.Options.Contains(option)` [2](#0-1) 

The `AddOption` method correctly prevents duplicates by calling `AssertOption` before adding the single option. [3](#0-2) 

However, the `AddOptions` batch method has a critical flaw: it validates each option in `input.Options` against the existing `votingItem.Options` list (line 318), but does NOT check for duplicates within the input array itself. After validation, it adds all options at once using `AddRange` (line 319). This means if the input contains `["OptionA", "OptionA"]`, both will pass validation (neither exists in the voting item yet) and both will be added, creating duplicates. [4](#0-3) 

The `Register` method also bypasses duplicate validation entirely, directly assigning `input.Options` to the voting item at line 49 without any uniqueness checks.

### Impact Explanation

**Data Integrity Violation**: The contract's design intent is clear from `AddOption`—options must be unique. The batch methods violate this invariant, creating inconsistent state.

**Option Slot Denial of Service**: The contract enforces a maximum of 64 options per voting item. [5](#0-4)  A sponsor (either maliciously or accidentally) could call `AddOptions` with 32 duplicate pairs, consuming all 64 slots with only 32 unique options, preventing legitimate options from being added.

**Inconsistent Behavior**: Developers and sponsors expect consistent validation across single and batch operations. This inconsistency can lead to integration bugs and unexpected behavior in applications built on this contract.

**Who is Affected**: All voting items where sponsors use `AddOptions` or `Register` with duplicate options, and all participants in those voting activities who may be confused by duplicate option listings.

### Likelihood Explanation

**Reachable Entry Point**: Both `AddOptions` and `Register` are public methods callable by the voting item sponsor. [6](#0-5) 

**Feasible Preconditions**: The sponsor role is a legitimate and necessary role for voting item management. While sponsors are generally trusted to manage their own voting items properly, the lack of validation enables both accidental mistakes and intentional misuse.

**Execution Practicality**: Exploitation is trivial—simply call `AddOptions` with an array containing duplicate strings, or call `Register` with duplicate options in the initial options array. No complex setup or multi-step process required.

**Detection**: The test suite has no coverage for duplicate options in batch operations, as confirmed by the absence of such tests. [7](#0-6) 

**Probability**: HIGH for accidental occurrence through sponsor mistakes or UI bugs; MEDIUM for intentional misuse given that sponsors control their own items.

### Recommendation

**1. Add Duplicate Validation to AddOptions:**
```csharp
public override Empty AddOptions(AddOptionsInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
    
    // Check for duplicates within input array
    var uniqueOptions = input.Options.Distinct().ToList();
    Assert(uniqueOptions.Count == input.Options.Count, "Duplicate options in input.");
    
    // Validate each unique option
    foreach (var option in uniqueOptions) 
        AssertOption(votingItem, option);
    
    votingItem.Options.AddRange(uniqueOptions);
    Assert(votingItem.Options.Count <= VoteContractConstants.MaximumOptionsCount,
        $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
    State.VotingItems[votingItem.VotingItemId] = votingItem;
    return new Empty();
}
```

**2. Add Duplicate Validation to Register:**
Before line 49 in the Register method, add:
```csharp
// Validate options for duplicates and length
var uniqueOptions = input.Options.Distinct().ToList();
Assert(uniqueOptions.Count == input.Options.Count, "Duplicate options in input.");
foreach (var option in uniqueOptions)
{
    Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid option length.");
}
```

**3. Add Test Cases:**
Add comprehensive test coverage for duplicate detection in both `AddOptions` and `Register` methods, including test cases for:
- Duplicate options within input array
- Near-limit duplicate scenarios (e.g., 32 duplicate pairs)
- Mixed valid and duplicate options

### Proof of Concept

**Initial State:**
- Create a voting item with 3 initial options using `Register`
- Voting item has 61 available option slots (64 max - 3 used)

**Attack Steps:**

1. **Exploit AddOptions with duplicates:**
```
Call AddOptions({
    VotingItemId: <voting_item_id>,
    Options: ["DuplicateOption", "DuplicateOption", "DuplicateOption", ...]  // 30 copies
})
```

**Expected Result (Current Broken Behavior):**
- Transaction succeeds
- Voting item now has 33 total options: 3 original + 30 duplicates
- Option list contains 30 identical "DuplicateOption" entries
- Only 31 slots remain available for unique options
- Querying the voting item shows duplicate options in the list

**Expected Result (After Fix):**
- Transaction fails with error: "Duplicate options in input."
- Voting item remains unchanged with 3 options
- Option slots protected from duplicate pollution

**Success Condition:** A voting item can be populated with duplicate options via `AddOptions`, consuming option slots and violating the uniqueness invariant enforced by `AddOption`.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-52)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);

        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Accepted currency is in white list means this token symbol supports voting.
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");

        // Initialize voting event.
        var votingItem = new VotingItem
        {
            Sponsor = Context.Sender,
            VotingItemId = votingItemId,
            AcceptedCurrency = input.AcceptedCurrency,
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
        };
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L280-290)
```csharp
    public override Empty AddOption(AddOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        AssertOption(votingItem, input.Option);
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        votingItem.Options.Add(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L292-296)
```csharp
    private void AssertOption(VotingItem votingItem, string option)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(!votingItem.Options.Contains(option), "Option already exists.");
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L314-324)
```csharp
    public override Empty AddOptions(AddOptionsInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        foreach (var option in input.Options) AssertOption(votingItem, option);
        votingItem.Options.AddRange(input.Options);
        Assert(votingItem.Options.Count <= VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L3-7)
```csharp
public static class VoteContractConstants
{
    public const int MaximumOptionsCount = 64;
    public const int OptionLengthLimit = 1024;
}
```

**File:** protobuf/vote_contract.proto (L43-45)
```text
    // Add multiple options to a voting activity.
    rpc AddOptions (AddOptionsInput) returns (google.protobuf.Empty) {
    }
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L452-506)
```csharp
    [Fact]
    public async Task VoteContract_AddOptions_Test()
    {
        //without permission
        {
            var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1);
            var otherUser = Accounts[10].KeyPair;
            var transactionResult = (await GetVoteContractTester(otherUser).AddOptions.SendWithExceptionAsync(
                new AddOptionsInput
                {
                    VotingItemId = registerItem.VotingItemId,
                    Options =
                    {
                        Accounts[0].Address.ToBase58(),
                        Accounts[1].Address.ToBase58()
                    }
                })).TransactionResult;

            transactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
            transactionResult.Error.Contains("Only sponsor can update options").ShouldBeTrue();
        }
        //voteItem does not exist
        {
            var itemId = HashHelper.ComputeFrom("hash");
            var transactionResult = (await VoteContractStub.AddOptions.SendWithExceptionAsync(new AddOptionsInput
            {
                VotingItemId = itemId,
                Options =
                {
                    Accounts[0].Address.ToBase58()
                }
            })).TransactionResult;

            transactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
            transactionResult.Error.Contains("Voting item not found.").ShouldBeTrue();
        }
        //success
        {
            var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1);
            var transactionResult = (await VoteContractStub.AddOptions.SendAsync(new AddOptionsInput
            {
                VotingItemId = registerItem.VotingItemId,
                Options =
                {
                    Accounts[3].Address.ToBase58(),
                    Accounts[4].Address.ToBase58()
                }
            })).TransactionResult;

            transactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            var votingItem = await GetVoteItem(registerItem.VotingItemId);
            votingItem.Options.Count.ShouldBe(5);
        }
    }
```
