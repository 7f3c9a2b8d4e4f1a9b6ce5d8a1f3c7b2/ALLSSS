### Title
ConfigurationContract Invalid Data Causes Chain Halt via Unhandled Protobuf Deserialization Exception in Consensus

### Summary
The AEDPoS consensus contract's `IsSecretSharingEnabled()` method deserializes configuration data without exception handling. If the ConfigurationContract returns invalid bytes for the `SecretSharingEnabled` configuration key, the protobuf `MergeFrom()` operation will throw an `InvalidProtocolBufferException`, causing all consensus block production to fail and halting the entire blockchain.

### Finding Description

The vulnerability exists in the `IsSecretSharingEnabled()` method which unconditionally deserializes configuration data: [1](#0-0) 

The Configuration contract's `SetConfiguration` method accepts arbitrary bytes without validation of their format or type compatibility: [2](#0-1) 

This method is invoked during critical consensus operations:

1. **Block Extra Data Generation** - Called when producing blocks with UpdateValue behavior: [3](#0-2) 

2. **Consensus Transaction Processing** - Called when processing UpdateValue consensus transactions: [4](#0-3) 

The `GetConsensusBlockExtraData` method is called by both `GetConsensusExtraData` and `GenerateConsensusTransactions`, which are ACS4 interface methods used by the consensus system: [5](#0-4) 

**Root Cause:** The code uses protobuf's `MergeFrom()` method which throws `InvalidProtocolBufferException` when deserializing malformed or type-incompatible byte data. There is no try-catch block to handle this exception.

**Why Protections Fail:** The Configuration contract only validates that the input key is non-empty and value is not empty, but does not validate that the bytes represent a valid protobuf message of the expected type: [6](#0-5) 

### Impact Explanation

**Concrete Harm:**
- **Complete Chain Halt:** All block production stops indefinitely. No miner can successfully generate consensus transactions or produce blocks.
- **Transaction Processing Failure:** All pending transactions become unprocessable, affecting all users and applications.
- **Consensus Deadlock:** The blockchain cannot progress past the point where the invalid configuration causes exceptions.

**Affected Parties:**
- All network miners cannot produce blocks
- All users cannot execute transactions
- All dApps and services become unavailable
- The entire blockchain ecosystem is frozen

**Severity Justification:** This is a **Critical** severity vulnerability because it results in complete denial of service requiring emergency intervention (likely a hard fork or coordinated manual fix by all nodes) to restore chain operation.

### Likelihood Explanation

**Attack Prerequisites:**
1. Create a Parliament proposal to set the `SecretSharingEnabled` configuration key with invalid bytes (e.g., bytes that don't represent a valid BoolValue protobuf message)
2. Obtain Parliament approval for the proposal (requires majority of Parliament members)
3. Execute the approved proposal

**Feasibility:**
- **Medium Likelihood:** The Configuration contract is controlled by Parliament's default organization, requiring governance approval: [7](#0-6) 

- Parliament members might not carefully validate the binary protobuf format of configuration bytes
- Tooling bugs or human error could create malformed proposals
- A coalition of malicious Parliament members could deliberately pass such a proposal

**Attack Complexity:** Low once governance approval is obtained. The exploit automatically triggers during the next consensus round when any miner attempts to produce a block with UpdateValue behavior.

**Detection/Operational Constraints:** The attack would be immediately obvious (complete chain halt), but recovery requires emergency coordination among all validators and potentially a hard fork.

### Recommendation

**Immediate Fix - Add Exception Handling:**

Wrap the protobuf deserialization in a try-catch block with safe default behavior:

```csharp
private bool IsSecretSharingEnabled()
{
    if (State.ConfigurationContract.Value == null)
    {
        var configurationContractAddress =
            Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
        if (configurationContractAddress == null)
        {
            return false;
        }
        State.ConfigurationContract.Value = configurationContractAddress;
    }

    try
    {
        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);
        return secretSharingEnabled.Value;
    }
    catch
    {
        // Return safe default if configuration is malformed
        return false;
    }
}
```

**Additional Validation in Configuration Contract:**

Add type validation in `SetConfiguration` to verify bytes represent a valid protobuf message before storing:

```csharp
public override Empty SetConfiguration(SetConfigurationInput input)
{
    AssertPerformedByConfigurationControllerOrZeroContract();
    Assert(input.Key.Any() && input.Value != ByteString.Empty, "Invalid set config input.");
    
    // Validate protobuf format for known configuration keys
    ValidateConfigurationValue(input.Key, input.Value);
    
    State.Configurations[input.Key] = new BytesValue { Value = input.Value };
    Context.Fire(new ConfigurationSet
    {
        Key = input.Key,
        Value = input.Value
    });
    return new Empty();
}
```

**Test Cases:**
1. Test `IsSecretSharingEnabled()` with non-existent configuration (should return false)
2. Test with valid BoolValue bytes (should deserialize correctly)
3. Test with invalid/corrupted bytes (should not throw exception, return safe default)
4. Test with empty BytesValue (should return false)
5. Integration test: Set invalid configuration via governance and verify consensus still functions

### Proof of Concept

**Initial State:**
- AElf blockchain running with AEDPoS consensus
- Parliament governance operational
- Configuration contract deployed

**Attack Steps:**

1. **Create Malicious Proposal:**
   - Attacker creates a Parliament proposal calling `ConfigurationContract.SetConfiguration`
   - Input: `{Key: "SecretSharingEnabled", Value: <invalid_bytes>}`
   - Where `<invalid_bytes>` = arbitrary corrupted data (e.g., `0xFF 0xFF 0xFF 0xFF`) that doesn't represent a valid BoolValue protobuf

2. **Obtain Approval:**
   - Proposal is submitted to Parliament
   - Obtains majority approval through social engineering, tooling bug, or malicious coalition
   - Proposal is released and executed

3. **Configuration Set:**
   - `SetConfiguration` executes successfully (no validation of bytes)
   - Invalid bytes stored: `State.Configurations["SecretSharingEnabled"] = new BytesValue { Value = <invalid_bytes> }`

4. **Chain Halt Triggered:**
   - Next miner attempts to produce block with UpdateValue behavior
   - Calls `GenerateConsensusTransactions()` → `GetConsensusBlockExtraData()` → `GetConsensusExtraDataToPublishOutValue()` → `IsSecretSharingEnabled()`
   - `MergeFrom(<invalid_bytes>)` throws `InvalidProtocolBufferException`
   - Block production fails

5. **Cascade Failure:**
   - All subsequent miners hit the same exception
   - No blocks can be produced
   - Chain completely halted

**Expected Result:** Chain continues producing blocks normally

**Actual Result:** Complete chain halt - all miners unable to produce blocks due to unhandled `InvalidProtocolBufferException`

**Success Condition:** Chain stops producing blocks immediately after the malicious configuration is set and any miner attempts UpdateValue behavior.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L71-77)
```csharp
        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract.cs (L10-21)
```csharp
    public override Empty SetConfiguration(SetConfigurationInput input)
    {
        AssertPerformedByConfigurationControllerOrZeroContract();
        Assert(input.Key.Any() && input.Value != ByteString.Empty, "Invalid set config input.");
        State.Configurations[input.Key] = new BytesValue { Value = input.Value };
        Context.Fire(new ConfigurationSet
        {
            Key = input.Key,
            Value = input.Value
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L122-125)
```csharp
        if (IsSecretSharingEnabled())
        {
            UpdateLatestSecretPieces(updatedRound, pubkey, triggerInformation);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-74)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }

    public override TransactionList GenerateConsensusTransactions(BytesValue input)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);
        // Some basic checks.
        Assert(triggerInformation.Pubkey.Any(),
            "Data to request consensus information should contain pubkey.");

        var pubkey = triggerInformation.Pubkey;
        var randomNumber = triggerInformation.RandomNumber;
        var consensusInformation = new AElfConsensusHeaderInformation();
        consensusInformation.MergeFrom(GetConsensusBlockExtraData(input, true).Value);
        var transactionList = GenerateTransactionListByExtraData(consensusInformation, pubkey, randomNumber);
        return transactionList;
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_Helper.cs (L8-19)
```csharp
    private AuthorityInfo GetDefaultConfigurationController()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        return new AuthorityInfo
        {
            ContractAddress = State.ParliamentContract.Value,
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty())
        };
    }
```
