### Title
RemoveSubScheme Fails to Update CachedDelayTotalShares Causing Incorrect Profit Distribution in Delayed Distribution Schemes

### Summary
The `RemoveSubScheme` function removes a sub-scheme's shares from `TotalShares` but fails to update `CachedDelayTotalShares`, unlike `RemoveBeneficiary` which correctly updates this cache. In schemes with delayed distribution (DelayDistributePeriodCount > 0), this causes future profit distributions to use inflated share counts, resulting in beneficiaries receiving less profit than entitled and funds becoming permanently locked in period virtual addresses.

### Finding Description

The vulnerability exists in the `RemoveSubScheme` function which only updates `TotalShares` but does not update `CachedDelayTotalShares`: [1](#0-0) 

In contrast, `RemoveBeneficiary` correctly updates `CachedDelayTotalShares` for all affected periods when removing shares: [2](#0-1) 

**Root Cause:**

The `CachedDelayTotalShares` map stores the total shares at each distribution period for schemes with delayed distribution. When `DistributeProfits` is called with a delay, it caches the current `TotalShares` for use in future periods: [3](#0-2) 

When a delayed distribution period arrives, it retrieves the cached value instead of using the current `TotalShares`. This cached value is stored in `DistributedProfitsInfo.TotalShares` and used as the denominator for profit calculations: [4](#0-3) 

During profit claiming, beneficiaries receive their share calculated as: `profitAmount = totalAmount * beneficiaryShares / totalShares` where `totalShares` comes from the cached value: [5](#0-4) [6](#0-5) 

**Why Protections Fail:**

While `RemoveSubScheme` removes the sub-scheme from `scheme.SubSchemes` list and clears its `ProfitDetails`, it doesn't account for the already-cached share values in `CachedDelayTotalShares`. The removed sub-scheme won't receive distributions (it's removed from the SubSchemes list), but its shares remain in the cached denominator, causing all other beneficiaries to receive proportionally less.

### Impact Explanation

**Direct Financial Harm:**
- Beneficiaries lose a portion of their entitled profits proportional to the removed sub-scheme's shares
- Example: If a scheme has 100 shares (50 from sub-scheme, 50 from beneficiaries), and the sub-scheme is removed before delayed distribution:
  - Expected: Beneficiaries receive 100% of 1000 tokens = 1000 tokens
  - Actual: Beneficiaries receive (50/100) * 1000 = 500 tokens
  - Lost: 500 tokens remain permanently locked in period virtual address

**Fund Lock:**
The "missing" tokens cannot be recovered because:
1. The removed sub-scheme's `ProfitDetails` are cleared and cannot claim
2. Other beneficiaries already calculated their shares using the inflated denominator
3. No mechanism exists to redistribute unclaimed profits from period virtual addresses

**Affected Parties:**
- All remaining beneficiaries in schemes with delayed distribution after a sub-scheme removal
- Token holders relying on accurate profit distribution from staking or voting schemes
- Protocol treasury and reward distribution mechanisms

**Severity Justification:**
HIGH severity due to:
- Permanent loss of funds (tokens locked forever)
- Affects core economic mechanism (profit distribution)
- Can be triggered by normal operations (scheme manager removing sub-schemes)
- No recovery mechanism exists

### Likelihood Explanation

**Reachable Entry Point:**
The vulnerability is triggered through the public `RemoveSubScheme` method callable by the scheme manager: [7](#0-6) 

**Feasible Preconditions:**
1. Scheme must have `DelayDistributePeriodCount > 0` (common for staking/voting schemes)
2. Scheme manager removes a sub-scheme during the delay period
3. Future distributions occur using cached shares from before the removal

**Execution Practicality:**
- No special privileges needed beyond being the scheme manager (legitimate role)
- Standard contract operations with no unusual parameters
- Demonstrated in existing tests that schemes with delay distribution are common: [8](#0-7) 

**Economic Rationality:**
The vulnerability occurs during normal operations without malicious intent. A scheme manager may legitimately need to remove a sub-scheme (e.g., a voting scheme deciding to stop delegating profits to a sub-pool), unaware of the financial consequences.

**Detection Difficulty:**
The bug is not immediately visible as:
- The transaction succeeds without error
- Effects only manifest in future distribution periods
- Requires comparing expected vs actual profit amounts across multiple periods

### Recommendation

**Immediate Fix:**
Add `CachedDelayTotalShares` update logic to `RemoveSubScheme`, mirroring the approach in `RemoveBeneficiary`:

```csharp
public override Empty RemoveSubScheme(RemoveSubSchemeInput input)
{
    // ... existing validation code ...
    
    var shares = scheme.SubSchemes.SingleOrDefault(d => d.SchemeId == input.SubSchemeId);
    if (shares == null) return new Empty();
    
    // ... existing code to remove sub-scheme ...
    
    // Update cached delay total shares (NEW CODE)
    if (scheme.DelayDistributePeriodCount > 0)
    {
        var currentPeriod = scheme.CurrentPeriod;
        for (var period = currentPeriod; 
             period < currentPeriod.Add(scheme.DelayDistributePeriodCount); 
             period++)
        {
            if (scheme.CachedDelayTotalShares.ContainsKey(period))
            {
                scheme.CachedDelayTotalShares[period] = 
                    scheme.CachedDelayTotalShares[period].Sub(shares.Shares);
            }
        }
    }
    
    scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
    State.SchemeInfos[input.SchemeId] = scheme;
    
    return new Empty();
}
```

**Invariant Checks:**
Add assertion that for schemes with delayed distribution: `sum(all beneficiary shares + sub-scheme shares) == CachedDelayTotalShares[period]` for all cached periods.

**Test Cases:**
1. Test removing sub-scheme from scheme with DelayDistributePeriodCount > 0
2. Verify subsequent distributions use correct (reduced) total shares
3. Verify beneficiaries receive full entitled amounts after sub-scheme removal
4. Test removing multiple sub-schemes across multiple periods

### Proof of Concept

**Initial State:**
- Create scheme with DelayDistributePeriodCount = 3
- Period 1: Add sub-scheme with 100 shares (TotalShares = 100)
- Period 1: Add individual beneficiary with 50 shares (TotalShares = 150)
- Period 1: Distribute 1500 tokens â†’ CachedDelayTotalShares[4] = 150

**Exploit Steps:**
1. Period 2: Manager calls RemoveSubScheme for the sub-scheme
   - TotalShares becomes 50
   - CachedDelayTotalShares[4] remains 150 (BUG!)
   
2. Period 4: DistributeProfits called
   - Uses CachedDelayTotalShares[4] = 150 as totalShares
   - Sub-scheme not in SubSchemes list, gets 0 tokens
   - Beneficiary claims: 1500 * 50/150 = 500 tokens

**Expected vs Actual Result:**
- Expected: Beneficiary receives 1500 * 50/50 = 1500 tokens (100% after sub-scheme removal)
- Actual: Beneficiary receives 500 tokens (33.3%)
- Lost: 1000 tokens permanently locked in period 4 virtual address

**Success Condition:**
Verify beneficiary's claimed amount < expected amount, and unclaimed balance remains in period virtual address with no valid claimer.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L131-156)
```csharp
    public override Empty RemoveSubScheme(RemoveSubSchemeInput input)
    {
        Assert(input.SchemeId != input.SubSchemeId, "Two schemes cannot be same.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only manager can remove sub-scheme.");

        var shares = scheme.SubSchemes.SingleOrDefault(d => d.SchemeId == input.SubSchemeId);
        if (shares == null) return new Empty();

        var subSchemeId = input.SubSchemeId;
        var subScheme = State.SchemeInfos[subSchemeId];
        Assert(subScheme != null, "Sub scheme not found.");

        var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
        // Remove profit details
        State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
        scheme.SubSchemes.Remove(shares);
        scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L243-258)
```csharp
        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-583)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** test/AElf.Contracts.Profit.Tests/BVT/SchemeTests.cs (L165-178)
```csharp
    public async Task ProfitContract_DelayDistribution_Test()
    {
        const int delayDistributePeriodCount = 3;
        const int contributeAmountEachTime = 100_000;
        var creator = Creators[0];
        var creatorAddress = Address.FromPublicKey(CreatorKeyPair[0].PublicKey);

        await creator.CreateScheme.SendAsync(new CreateSchemeInput
        {
            IsReleaseAllBalanceEveryTimeByDefault = true,
            ProfitReceivingDuePeriodCount = 100,
            DelayDistributePeriodCount = delayDistributePeriodCount,
            CanRemoveBeneficiaryDirectly = true
        });
```
