### Title
Missing Cryptographic Validation of Decrypted Secret Shares Allows Consensus Data Pollution

### Summary
The `UpdateLatestSecretPieces` function accepts decrypted secret shares from miners without any cryptographic validation that the decryption was performed correctly. Malicious miners can inject garbage data into the secret sharing pool, which gets used to reconstruct InValues for miners who fail to produce blocks, corrupting consensus data and affecting random number generation.

### Finding Description

**Root Cause:**
In `UpdateLatestSecretPieces`, decrypted pieces provided by miners are stored directly without validation: [1](#0-0) 

The contract has no way to verify these are correct decryptions because:
- The original encryption uses asymmetric cryptography requiring private keys
- Only the recipient miner possesses the private key needed to decrypt
- The contract cannot re-perform or verify the decryption operation

**Exploitation Path:**

1. **Injection Phase**: A malicious miner provides garbage data in `DecryptedPieces` when mining. These unvalidated pieces are stored in the round state for the target victim miner.

2. **Reconstruction Phase**: When `RevealSharedInValues` executes (during NextRound transition), it uses these stored pieces to reconstruct the victim's InValue via Shamir's Secret Sharing: [2](#0-1) 

The `SecretSharingHelper.DecodeSecret` function performs mathematical reconstruction without validating piece correctness: [3](#0-2) 

This produces a wrong reconstructed value when garbage pieces are included.

3. **Propagation Phase**: The corrupted reconstructed value is used in `SupplyCurrentRoundInformation` to fill InValues for miners who failed to mine: [4](#0-3) 

The wrong InValue becomes part of the permanent consensus record and is used for signature calculations.

**Why Existing Protections Fail:**

The validation in `UpdateValueValidationProvider` only checks InValues explicitly provided by miners, not reconstructed values: [5](#0-4) 

This validation doesn't protect against pollution of reconstructed values in the secret sharing pool.

### Impact Explanation

**Consensus Integrity Violation:**
- Corrupted InValues produce wrong OutValues (OutValue = Hash(InValue))
- Affected miners' consensus records contain incorrect data
- Signature calculations use corrupted values, affecting miner ordering for future rounds: [6](#0-5) 

**Random Number Generation Compromise:**
- The secret sharing mechanism is designed to generate verifiable random numbers
- Corrupted InValues bias or break the randomness guarantees
- Applications relying on consensus randomness (elections, lottery, DeFi protocols) are affected

**Scope of Impact:**
- Any miner who fails to produce a block becomes vulnerable
- Common scenarios: network issues, node downtime, configuration errors
- Affects all miners over time as network conditions fluctuate
- No mechanism exists to correct corrupted values once set

**Severity Justification:**
This violates the "Consensus & Cross-Chain" critical invariant requiring "correct round transitions and miner schedule integrity." While not directly stealing funds, it undermines fundamental consensus security properties that all protocol operations depend on.

### Likelihood Explanation

**Attacker Capabilities:**
- Any active miner in the consensus set can execute this attack
- Requires no special privileges beyond normal block production rights
- Attack can be launched opportunistically whenever the attacker mines a block

**Attack Complexity:**
- Simple execution: provide arbitrary bytes in `DecryptedPieces` field
- No cryptographic sophistication required
- Node software already collects legitimate DecryptedPieces; attacker modifies before submission: [7](#0-6) 

**Feasibility Conditions:**
- Attack succeeds when victim miner fails to produce a block in the next round
- High probability: miners experience intermittent downtime due to network/hardware issues
- Attacker can target multiple victims simultaneously by corrupting multiple DecryptedPieces

**Detection Constraints:**
- Corrupted DecryptedPieces are indistinguishable from legitimate ones at storage time
- Only revealed when reconstruction produces wrong results
- By then, the data is already committed to the blockchain
- No alerting or rollback mechanism exists

**Economic Rationality:**
- Zero direct cost to execute (part of normal block production)
- Potential benefits: manipulating random numbers for favorable outcomes, disrupting competitor miners
- Risk is low: difficult to prove malicious intent vs. implementation bug

### Recommendation

**Immediate Mitigation:**
Add cryptographic validation by verifying reconstructed InValues against known OutValues before accepting them:

```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    // ... existing code ...
    
    var revealedInValue = 
        HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
    
    // ADD VALIDATION: Check if reconstructed value matches OutValue
    if (anotherMinerInPreviousRound.OutValue != null && 
        anotherMinerInPreviousRound.OutValue != Hash.Empty)
    {
        var expectedOutValue = HashHelper.ComputeFrom(revealedInValue);
        if (expectedOutValue != anotherMinerInPreviousRound.OutValue)
        {
            Context.LogWarning($"Reconstructed InValue validation failed for {publicKeyOfAnotherMiner}");
            continue; // Skip setting corrupted PreviousInValue
        }
    }
    
    currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
}
```

**Additional Safeguards:**
1. Implement threshold validation: require N of M reconstructions to match before accepting
2. Add slashing conditions for miners who repeatedly provide invalid DecryptedPieces
3. Implement cryptographic commitments to DecryptedPieces that can be verified on-chain
4. Add monitoring to detect reconstruction failures and alert validators

**Test Cases:**
1. Test reconstruction with one corrupted DecryptedPiece among valid pieces
2. Test reconstruction with majority corrupted pieces
3. Verify validation rejects mismatched OutValue/reconstructed InValue pairs
4. Test fallback to previous round's InValue when reconstruction fails

### Proof of Concept

**Initial State:**
- Round N: Honest Miner A mines with InValue = 0x1234..., OutValue = Hash(0x1234...) = 0xABCD...
- Miner A generates EncryptedPieces for all miners including Miner B

**Attack Execution:**

1. **Round N - Malicious Block Production:**
   - Miner B mines a block with UpdateValue behavior
   - In `triggerInformation.DecryptedPieces`, Miner B provides:
     ```
     {
       "MinerA_PubKey": 0xGARBAGE_DATA_0000111122223333...
     }
     ```
   - Contract calls `UpdateLatestSecretPieces` which stores: `Round[N].MinerInfo[MinerA].DecryptedPieces[MinerB] = 0xGARBAGE...`

2. **Round N - NextRound Transition:**
   - Miner C mines with NextRound behavior
   - Contract calls `RevealSharedInValues` on Round N
   - For Miner A, it collects all DecryptedPieces including the garbage from Miner B
   - `DecodeSecret([legitimate_pieces, 0xGARBAGE...], orders, threshold)` produces `wrong_value = 0xBADF00D...`
   - Contract sets: `Round[N+1].MinerInfo[MinerA].PreviousInValue = 0xBADF00D...`

3. **Round N+1 - Supply Missing Information:**
   - Miner A fails to produce their block (offline)
   - At round end, `SupplyCurrentRoundInformation` executes
   - Line 191 retrieves corrupted PreviousInValue: `0xBADF00D...`
   - Line 213 sets: `MinerA.InValue = 0xBADF00D...` (wrong!)

**Expected vs Actual Result:**
- **Expected:** Miner A's InValue should be `0x1234...` (from previous round) or skipped entirely
- **Actual:** Miner A's InValue is corrupted value `0xBADF00D...`
- **Verification:** `Hash(0xBADF00D...) != 0xABCD...` (Miner A's original OutValue)

**Success Condition:**
Query Round N+1 miner information for Miner A shows PreviousInValue that does NOT hash to their OutValue from Round N, proving consensus data corruption.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-146)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-52)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L189-214)
```csharp
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
            }

            if (previousInValue == null)
            {
                // Handle abnormal situation.

                // The fake in value shall only use once during one term.
                previousInValue = HashHelper.ComputeFrom(miner);
                signature = previousInValue;
            }

            // Fill this two fields at last.
            miner.InValue = previousInValue;
            miner.Signature = signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L133-141)
```csharp
            var decryptedPiece =
                await _accountService.DecryptMessageAsync(senderPublicKey, interestingMessage.ToByteArray());
            decryptedPieces[pubkey] = decryptedPiece;
            secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].DecryptedPieces[selfPubkey]
                = ByteString.CopyFrom(decryptedPiece);
        }

        _encryptedPieces[secretSharingInformation.CurrentRoundId] = encryptedPieces;
        _decryptedPieces[secretSharingInformation.CurrentRoundId] = decryptedPieces;
```
