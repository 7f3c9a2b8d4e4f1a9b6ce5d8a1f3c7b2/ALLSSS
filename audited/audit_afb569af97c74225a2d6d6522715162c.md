### Title
Broken Mining Order Validation Allows Consensus Failure Through Duplicate FinalOrderOfNextRound Values

### Summary
The `NextRoundMiningOrderValidationProvider` validation is completely ineffective due to two critical flaws: (1) it applies `Distinct()` to entire miner objects instead of order values, failing to detect duplicate `FinalOrderOfNextRound` entries, and (2) it checks `ProvidedRound` (the newly generated next round with no orders set) instead of `BaseRound` (the current round where orders should be validated). This allows malicious miners to inject duplicate mining orders that break consensus when the next round begins, causing multiple miners to compete for the same time slot.

### Finding Description

**Root Cause 1 - Incorrect Distinct() Usage:** [1](#0-0) 

The validation calls `Distinct()` on entire `MinerInRound` objects. Since each miner has a unique `Pubkey` field [2](#0-1) , protobuf's structural equality will consider all miners distinct even if they share identical `FinalOrderOfNextRound` values. The validation should apply `Distinct()` to the extracted order values, not the miner objects.

**Root Cause 2 - Wrong Round Checked:**

The validator checks `validationContext.ProvidedRound` [3](#0-2) , which for NextRound behavior is the newly generated next round contained in the block header's extra data [4](#0-3) . 

In the next round, miners have not yet set their `FinalOrderOfNextRound` or `OutValue` fields (these determine the *next-next* round's order) [5](#0-4) , so both counts evaluate to 0, making the validation always pass (0 == 0). The validator should check `BaseRound` (current round state) where miners have set these fields during UpdateValue blocks.

**Exploitation Path:**

During UpdateValue behavior, conflict resolution occurs in `ApplyNormalConsensusData` [6](#0-5) , which reassigns conflicting orders. However, UpdateValue blocks are NOT validated by `NextRoundMiningOrderValidationProvider` [7](#0-6) . 

A malicious block producer can:
1. Modify their node to bypass conflict resolution
2. Set duplicate `FinalOrderOfNextRound` values in `TuneOrderInformation` 
3. The UpdateValue block validation passes (no duplicate order checks exist)
4. `ProcessUpdateValue` persists the duplicate orders [8](#0-7) 
5. When `GenerateNextRoundInformation` executes for NextRound, it assigns the same `Order` value to multiple miners in the next round [9](#0-8) 

### Impact Explanation

**Consensus Integrity Violation (Critical):**
Multiple miners assigned identical `Order` values in a round violates the core AEDPoS consensus invariant that each miner has a unique time slot. When round transitions occur [10](#0-9) , colliding miners will:
- Attempt block production at the same `ExpectedMiningTime` 
- Create competing blocks at the same height
- Trigger consensus deadlock or chain forks
- Potentially halt block production entirely

**Scope:** Affects all miners and the entire blockchain. Once duplicate orders persist, the next round cannot function correctly. The network requires manual intervention or emergency consensus reset.

**Severity:** HIGH - Breaks fundamental consensus assumptions, causes operational failure, and compromises blockchain liveness.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an active miner in the validator set (can produce UpdateValue blocks)
- Needs modified node software to bypass `ApplyNormalConsensusData` conflict resolution
- Can craft malicious `TuneOrderInformation` in block headers

**Attack Complexity:** MEDIUM
- No economic cost beyond being a validator
- Requires understanding of AEDPoS internals
- Single malicious miner can execute alone (no coordination needed)
- Detection is difficult - invalid state persists in contract storage

**Feasibility Conditions:**
The validation system provides NO protection:
- UpdateValue validation never checks for duplicate orders [7](#0-6) 
- NextRound validation is non-functional [11](#0-10) 
- No state invariant checks in `ProcessUpdateValue` [12](#0-11) 

**Likelihood Assessment:** HIGH - Given the complete absence of validation and relatively low attack prerequisites.

### Recommendation

**1. Fix NextRoundMiningOrderValidationProvider:**

Change line 15-16 to:
```csharp
var distinctOrderCount = validationContext.BaseRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct().Count();
var minersWithOrdersCount = validationContext.BaseRound.RealTimeMinersInformation.Values
    .Count(m => m.FinalOrderOfNextRound > 0);
    
if (distinctOrderCount != minersWithOrdersCount)
    return new ValidationResult { Message = "Duplicate FinalOrderOfNextRound values detected." };
    
if (distinctOrderCount != validationContext.BaseRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**2. Add UpdateValue Order Uniqueness Validation:**

Create `UpdateValueMiningOrderValidationProvider` and add to UpdateValue validators [7](#0-6)  to check both:
- Current miner's `SupposedOrderOfNextRound` doesn't conflict with existing `FinalOrderOfNextRound` values
- `TuneOrderInformation` doesn't create duplicates

**3. Add State Invariant Check in ProcessUpdateValue:**

After line 260, validate:
```csharp
var orderCounts = currentRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .GroupBy(m => m.FinalOrderOfNextRound)
    .Where(g => g.Count() > 1);
Assert(!orderCounts.Any(), "Duplicate mining orders detected after update.");
```

**4. Test Coverage:**

Add regression tests for:
- Multiple miners with identical `FinalOrderOfNextRound` 
- Malicious `TuneOrderInformation` creating collisions
- NextRound generation with duplicate source orders

### Proof of Concept

**Initial State:**
- Round N with 5 miners: A, B, C, D, E
- All have mined (OutValue set) during round N

**Attack Sequence:**

1. Miner A produces UpdateValue block at height H:
   - Calculates `SupposedOrderOfNextRound = 1` based on signature
   - Bypasses conflict resolution (modified node)
   - Sets `TuneOrderInformation = { B: 1, C: 1, D: 1, E: 1 }` (all duplicate orders)
   - Block header contains Round N with all miners having `FinalOrderOfNextRound = 1`

2. Block H validation:
   - `MiningPermissionValidationProvider`: PASS (A is valid miner)
   - `TimeSlotValidationProvider`: PASS (correct time slot)
   - `UpdateValueValidationProvider`: PASS (A's OutValue/Signature valid)
   - No duplicate order check exists → Block accepted

3. Block H execution (`ProcessUpdateValue`):
   - Line 247: Sets A's `FinalOrderOfNextRound = 1`
   - Lines 259-260: Applies `TuneOrderInformation`, sets B/C/D/E `FinalOrderOfNextRound = 1`
   - State persisted: All 5 miners have `FinalOrderOfNextRound = 1`

4. NextRound block at height H+X:
   - Extra block producer calls `GenerateNextRoundInformation` [13](#0-12) 
   - Lines 26-36: All 5 miners assigned `Order = 1` in Round N+1
   - Line 33: All have `ExpectedMiningTime = currentTime + interval * 1` (identical)

5. NextRound validation:
   - `NextRoundMiningOrderValidationProvider`: Checks ProvidedRound (N+1)
   - Round N+1 has no `FinalOrderOfNextRound` or `OutValue` set yet
   - Validation: `0 distinct == 0 OutValue` → PASS (false negative)

**Result:** Round N+1 begins with 5 miners competing for Order=1 time slot. Consensus deadlock occurs as multiple miners produce conflicting blocks simultaneously.

**Expected:** Validation should reject UpdateValue block in step 2 or NextRound block in step 5 due to duplicate orders.

**Actual:** Both blocks accepted, consensus breaks in Round N+1.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** protobuf/aedpos_contract.proto (L284-284)
```text
    string pubkey = 9;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L23-40)
```csharp
        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```
