### Title
Unbounded Order Values in RecoverFromUpdateValue Enable Consensus DoS

### Summary
The `RecoverFromUpdateValue` function copies `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` values from provided round data without validating they are within bounds (1 to minerCount). Combined with broken hash validation logic, a malicious miner can inject out-of-bounds order values that cause next round generation to fail with exceptions, halting consensus.

### Finding Description

**Location**: [1](#0-0) 

The `RecoverFromUpdateValue` function blindly copies order values from the provided round data without any bounds checking. A miner can forge consensus header data with arbitrary order values (e.g., 0, negative, or exceeding minerCount).

**Validation Bypass**: The validation logic in `ValidateConsensusAfterExecution` is fundamentally broken: [2](#0-1) 

After calling `RecoverFromUpdateValue`, both `headerInformation.Round` and `currentRound` reference the same modified object (since `RecoverFromUpdateValue` returns `this`), making the hash comparison on line 100-101 always pass (comparing object to itself).

**No Input Validation**: When the UpdateValue transaction executes, `ProcessUpdateValue` directly stores the unvalidated order values to state: [3](#0-2) 

**Exploitation Impact**: When `GenerateNextRoundInformation` runs to create the next round, it uses these malicious `FinalOrderOfNextRound` values to set `Order` in the next round: [4](#0-3) 

Subsequently, `BreakContinuousMining` attempts to find miners with specific orders: [5](#0-4) 

If no miner has `Order == 1` (because a malicious miner set their `FinalOrderOfNextRound` to 0 or another invalid value), the `.First()` call throws `InvalidOperationException`, halting consensus.

### Impact Explanation

**Consensus DoS**: A malicious miner can halt the entire consensus system by injecting invalid order values. When the current round completes and the system attempts to generate the next round, it will encounter exceptions and fail to progress.

**Protocol-Wide Impact**: Since consensus is the foundation of blockchain operation, this DoS affects all protocol functions - no new blocks can be produced, no transactions can be processed, and the chain becomes stuck until manual intervention.

**Severity**: High - Complete denial of service of the core consensus mechanism.

**Affected Parties**: All network participants (validators, users, applications) are impacted as the chain stops producing blocks.

### Likelihood Explanation

**Attacker Capabilities**: Requires being an active consensus miner (validator), which is a privileged position but not impossible to obtain through the election process.

**Attack Complexity**: Low - The attacker simply needs to:
1. Wait for their assigned time slot to produce a block
2. Forge consensus header data with invalid order values (e.g., set `FinalOrderOfNextRound = 0`)
3. Produce the block normally

**Feasibility**: The broken validation logic makes this attack straightforward - no sophisticated techniques or race conditions required. The malicious values will pass all validations and be stored to state.

**Detection**: The attack would be immediately visible when the next round transition fails, but by then the invalid data is already in state.

**Economic Rationality**: An adversarial miner or a compromised validator node could execute this attack. The cost is only the gas for producing their assigned block, making this economically feasible for disruption purposes.

**Probability Assessment**: Moderate to High if a malicious actor gains miner status.

### Recommendation

**Add Bounds Validation in RecoverFromUpdateValue**:
```csharp
foreach (var information in providedRound.RealTimeMinersInformation)
{
    var minerCount = RealTimeMinersInformation.Count;
    
    // Validate SupposedOrderOfNextRound
    if (information.Value.SupposedOrderOfNextRound < 1 || 
        information.Value.SupposedOrderOfNextRound > minerCount)
        continue; // Or return this without modification
    
    // Validate FinalOrderOfNextRound  
    if (information.Value.FinalOrderOfNextRound < 1 || 
        information.Value.FinalOrderOfNextRound > minerCount)
        continue; // Or return this without modification
    
    RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
        information.Value.SupposedOrderOfNextRound;
    RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
        information.Value.FinalOrderOfNextRound;
    // ...
}
```

**Fix Validation Logic**: In `ValidateConsensusAfterExecution`, clone the current round before recovery to enable proper comparison:
```csharp
var currentRoundClone = currentRound.Clone();
headerInformation.Round = currentRoundClone.RecoverFromUpdateValue(headerInformation.Round, ...);
if (headerInformation.Round.GetHash(...) != currentRound.GetHash(...))
```

**Add Validation Provider**: Create an `OrderValueValidationProvider` that verifies all order values are within [1, minerCount] and are distinct for miners who have determined their next order.

**Test Cases**: Add regression tests that attempt to inject order values of 0, -1, minerCount+1, and MAX_INT to verify they are rejected.

### Proof of Concept

**Initial State**: 
- 5 active miners in current round (Round N)
- All miners have valid Order values 1-5
- Attacker is Miner #3

**Attack Sequence**:

1. Attacker's turn arrives to produce block in Round N
2. Attacker calls `GetConsensusExtraData` to get legitimate consensus data
3. Attacker modifies the returned `AElfConsensusHeaderInformation`:
   - Sets their `FinalOrderOfNextRound = 0` (or any value < 1 or > 5)
4. Attacker produces block with this forged consensus data in header
5. `ValidateBeforeExecution` runs:
   - Calls `RecoverFromUpdateValue` which copies the `FinalOrderOfNextRound = 0`
   - No validation catches the invalid value
   - Validation passes
6. `ProcessUpdateValue` executes:
   - Stores `FinalOrderOfNextRound = 0` to state for attacker's miner
7. `ValidateConsensusAfterExecution` runs:
   - Hash comparison passes (broken logic - compares object to itself)
8. Block is accepted, Round N continues with corrupted state
9. At end of Round N, `GenerateNextRoundInformation` is called:
   - Attacker's `FinalOrderOfNextRound = 0` becomes their `Order = 0` in Round N+1
10. `BreakContinuousMining` executes:
    - Line 79: `nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1)`
    - Throws `InvalidOperationException: Sequence contains no matching element`
11. Round N+1 generation fails, consensus is stuck

**Expected vs Actual**: 
- Expected: Invalid order value rejected, block production fails or miner reassigned valid order
- Actual: Invalid order value accepted, stored to state, causes next round generation to crash

**Success Condition**: Consensus halts and cannot generate Round N+1, observable through node logs showing exception in `BreakContinuousMining`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L24-27)
```csharp
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L87-101)
```csharp
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-33)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-79)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
```
