# Audit Report

## Title
Missing LIB Validation in NextTerm Allows Malicious Miners to DoS Blockchain via Inconsistent Irreversible Block Fields

## Summary
The AEDPoS consensus validation logic contains a critical gap where `LibInformationValidationProvider` is not applied to NextTerm behavior transitions. This allows a malicious miner to inject arbitrary `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` values that bypass validation, triggering a blockchain-wide denial-of-service by forcing all miners into single-block production mode.

## Finding Description

The vulnerability stems from inconsistent validation logic across different consensus behaviors. When validating consensus information before execution, the system applies different validation providers based on the behavior type. [1](#0-0) 

For UpdateValue behavior, the `LibInformationValidationProvider` is explicitly added to validate LIB (Last Irreversible Block) field consistency. However, for NextTerm behavior, only `RoundTerminateValidationProvider` is added, completely omitting LIB validation.

The `LibInformationValidationProvider` is the only component that validates these critical fields: [2](#0-1) 

This validator ensures LIB values don't regress and remain consistent. Its absence for NextTerm creates an exploitable gap.

Additionally, the Round hash computation used in post-execution validation deliberately excludes the LIB fields: [3](#0-2) 

The `GetCheckableRound` method only includes RoundNumber, TermNumber, RealTimeMinersInformation, and BlockchainAge in the hash computation, completely omitting `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber`. This means a malicious miner can modify these values without breaking the hash comparison in ValidateConsensusAfterExecution.

**Attack Flow:**

When a NextTerm transition occurs, the miner obtains consensus data through GetConsensusExtraData: [4](#0-3) 

The Round object generated includes LIB fields copied from current round state: [5](#0-4) 

When generating the consensus transaction, these fields are blindly copied: [6](#0-5) 

A malicious miner can modify the `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` values in the consensus header before producing the block. The modified values pass all validation checks and are stored in contract state: [7](#0-6) 

## Impact Explanation

The malicious LIB values directly affect the blockchain's operational status through `GetMaximumBlocksCount`: [8](#0-7) 

The BlockchainMiningStatusEvaluator uses the corrupted `ConfirmedIrreversibleBlockRoundNumber` to determine mining status: [9](#0-8) 

**Attack Scenario:**
If an attacker sets `ConfirmedIrreversibleBlockRoundNumber = 10` (artificially low) while the current round is 100:
- Calculation: `100 >= 10 + 8` (SevereStatusRoundsThreshold = 8)
- Status becomes `BlockchainMiningStatus.Severe`

When Severe status is triggered: [10](#0-9) 

The blockchain enters emergency mode where:
- MaximumBlocksCount reduces to 1
- All miners can only produce 1 block at a time
- `IrreversibleBlockHeightUnacceptable` events are fired
- Blockchain throughput drops drastically

**Impact Severity:**
- **Blockchain-wide DoS**: Entire network forced into degraded single-block production
- **Persistent**: Effect lasts for complete term duration (potentially thousands of blocks)
- **Operational impact**: Network becomes practically unusable
- **No direct fund loss**: But severe availability and usability degradation

## Likelihood Explanation

**Attacker Requirements:**
- Must be a current miner in the active miner list
- Access control validation only checks miner list membership: [11](#0-10) 

**Attack Complexity:**
1. Wait for NextTerm transition opportunity (when scheduled to produce NextTerm block)
2. Obtain legitimate consensus header via GetConsensusExtraData
3. Modify LIB fields in the Round object before block production
4. Produce and broadcast block with modified header
5. Block passes all validations due to missing LibInformationValidationProvider
6. Malicious values stored in state via AddRoundInformation

**Feasibility:**
- **High**: Only requires regular miner privileges (no special elevated access)
- **Repeatable**: Can execute at every term transition
- **Undetectable**: No validation failure occurs, appears as legitimate block
- **Rational attack**: Compromised or malicious miner could disrupt competitors/network

**Operational Constraints:**
- Term transitions less frequent than round transitions
- Effect persists entire term (significant duration)
- Manual monitoring required to detect inconsistent LIB values

**Probability Assessment:** MEDIUM-HIGH
- Limited attacker pool (must be miner)
- But miners are not fully trusted in security model
- Single compromised miner sufficient
- Severe impact warrants high priority

## Recommendation

Apply `LibInformationValidationProvider` to NextTerm behavior to ensure LIB field consistency:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

Additionally, consider including LIB fields in the Round hash computation for NextTerm transitions, or implement separate LIB-specific validation that ensures monotonic increase and consistency between height and round number fields across all consensus behaviors.

## Proof of Concept

Due to the architectural nature of this vulnerability (requiring block production and consensus header manipulation at the node level), a direct smart contract test cannot fully demonstrate the exploit. The vulnerability exists in the validation gap between consensus behaviors.

However, the vulnerability can be confirmed by code inspection:

1. Verify LibInformationValidationProvider is absent for NextTerm in ValidateBeforeExecution
2. Verify GetCheckableRound excludes LIB fields from hash
3. Verify NextTermInput.Create copies LIB fields without validation
4. Verify GetMaximumBlocksCount uses these values for status evaluation
5. Demonstrate that artificially low ConfirmedIrreversibleBlockRoundNumber triggers Severe status

A complete PoC would require:
- Setting up a test network with multiple miners
- Intercepting consensus header generation at NextTerm
- Modifying LIB fields before block production
- Observing validation bypass and MaximumBlocksCount reduction

The code analysis conclusively demonstrates the validation gap exists and the attack vector is viable within the AElf consensus protocol design.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L8-34)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L244-245)
```csharp
        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-38)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L106-129)
```csharp
        public BlockchainMiningStatusEvaluator(long currentConfirmedIrreversibleBlockRoundNumber,
            long currentRoundNumber, int maximumTinyBlocksCount)
        {
            _libRoundNumber = currentConfirmedIrreversibleBlockRoundNumber;
            _currentRoundNumber = currentRoundNumber;
            _maximumTinyBlocksCount = maximumTinyBlocksCount;
        }

        /// <summary>
        ///     Stands for CB1
        /// </summary>
        public int SevereStatusRoundsThreshold => Math.Max(8, _maximumTinyBlocksCount);

        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
        }
```
