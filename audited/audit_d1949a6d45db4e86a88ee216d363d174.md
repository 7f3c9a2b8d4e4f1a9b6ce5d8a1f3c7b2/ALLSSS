### Title
Governance Fee Control Bypass for Cross-Chain Indexing Methods Due to Hardcoded GetMethodFee Override

### Summary
The CrossChain contract's `GetMethodFee` method contains hardcoded logic that always returns `IsSizeFeeFree=true` for `ProposeCrossChainIndexing` and `ReleaseCrossChainIndexingProposal`, completely ignoring any fees stored via `SetMethodFee`. This creates a silent governance control failure where Parliament believes they have set fees for these critical cross-chain methods, but the fees are never enforced during actual transaction execution.

### Finding Description

The vulnerability exists in the CrossChain contract's ACS1 fee provider implementation with a state inconsistency between fee storage and fee retrieval:

**Fee Storage Path:**
The `SetMethodFee` function accepts any method name without validation and stores fee configuration in `State.TransactionFees[input.MethodName]`: [1](#0-0) 

This allows governance (Parliament by default) to successfully store fees for `ProposeCrossChainIndexing` and `ReleaseCrossChainIndexingProposal`.

**Fee Retrieval Path:**
However, `GetMethodFee` contains hardcoded logic that bypasses stored state for these specific methods: [2](#0-1) 

For `ProposeCrossChainIndexing` and `ReleaseCrossChainIndexingProposal`, it returns a new `MethodFees` object with `IsSizeFeeFree=true` and an empty `Fees` list, completely ignoring `State.TransactionFees[input.Value]`.

**Actual Fee Collection:**
The critical issue is that the TokenContract's `ChargeTransactionFees` method calls the target contract's `GetMethodFee` to retrieve fee configuration: [3](#0-2) 

The `isSizeFeeFree` flag from `GetMethodFee` determines whether size fees are charged, and the `fee` dictionary from `methodFees.Fees` determines base fees. Since the hardcoded return has `IsSizeFeeFree=true` and empty fees, no fees are collected regardless of what governance stored via `SetMethodFee`.

**Root Cause:**
The hardcoded override in `GetMethodFee` takes precedence over stored state, creating an unbreakable bypass of governance fee control. There is no validation in `SetMethodFee` to prevent setting fees for these methods, nor any warning that such fees will be ignored.

### Impact Explanation

**Governance Integrity Violation:**
Parliament (the default MethodFeeController) completely loses control over fee configuration for two critical cross-chain methods. When governance passes a proposal to set fees for `ProposeCrossChainIndexing` or `ReleaseCrossChainIndexingProposal`, the fees are stored but silently ignored during execution.

**Economic and Operational Impact:**
1. **Spam Prevention Failure**: If governance determines that fee-free cross-chain indexing enables spam attacks, they cannot enforce fees to mitigate this
2. **Economic Policy Bypass**: Any economic incentive structure requiring fees on cross-chain indexing cannot be implemented
3. **Dead State Storage**: `State.TransactionFees` accumulates invalid configuration data that misleads governance
4. **Trust Erosion**: Governance believes they control all method fees per ACS1 standard, but this hidden exception violates that expectation

**Affected Parties:**
- **Governance/Parliament**: Loses control over critical infrastructure fee configuration
- **Miners**: Can execute cross-chain indexing for free regardless of governance policy (while miners are already restricted by `AssertAddressIsCurrentMiner`, governance should still have ultimate authority over fees)
- **Protocol Economics**: Cannot implement fee-based spam prevention or economic incentives for cross-chain operations

**Severity Justification:**
HIGH severity because:
1. Completely breaks governance control over core cross-chain functionality
2. Silent failure with no validation or warning mechanisms
3. Violates fundamental ACS1 contract standard expectations
4. No available workaround for governance
5. Affects critical cross-chain infrastructure

### Likelihood Explanation

**Attacker Capabilities:**
No attacker exploitation required - this is a governance dysfunction vulnerability. Any legitimate governance attempt to set fees for these methods triggers the issue.

**Attack Complexity:**
- **Trigger Condition**: Parliament simply calls `SetMethodFee` with `MethodName = "ProposeCrossChainIndexing"` or `"ReleaseCrossChainIndexingProposal"`
- **Steps**: Single governance proposal and approval cycle
- **Detection**: Extremely difficult - fees appear to be set successfully in state, but are never enforced

**Feasibility Conditions:**
- **Probability**: 100% - every attempt to set fees for these methods fails silently
- **Prerequisites**: None - normal governance operations
- **Constraints**: None - the hardcoded logic cannot be overridden

**Economic Rationality:**
Not an economic exploit - this is a design flaw that breaks governance control. The likelihood is HIGH because:
1. Governance may legitimately need to set fees for spam prevention
2. Economic policy changes may require fee adjustments
3. No mechanism exists to inform governance that their fee settings are ineffective
4. The ACS1 interface promises fee control but doesn't deliver it for these methods

### Recommendation

**Immediate Fix:**
Modify `GetMethodFee` to respect stored state for all methods, removing the hardcoded override:

```csharp
public override MethodFees GetMethodFee(StringValue input)
{
    return State.TransactionFees[input.Value] ?? new MethodFees
    {
        MethodName = input.Value,
        IsSizeFeeFree = false
    };
}
```

If `ProposeCrossChainIndexing` and `ReleaseCrossChainIndexingProposal` must remain fee-free by design, implement this as an initialization policy rather than a hardcoded override:

```csharp
// In Initialize or deployment script
State.TransactionFees[nameof(ProposeCrossChainIndexing)] = new MethodFees
{
    MethodName = nameof(ProposeCrossChainIndexing),
    IsSizeFeeFree = true
};
```

**Validation Enhancement:**
If certain methods should permanently remain fee-free, add validation to `SetMethodFee`:

```csharp
private static readonly HashSet<string> FeeExemptMethods = new()
{
    nameof(ProposeCrossChainIndexing),
    nameof(ReleaseCrossChainIndexingProposal)
};

public override Empty SetMethodFee(MethodFees input)
{
    Assert(!FeeExemptMethods.Contains(input.MethodName), 
        $"Method {input.MethodName} is fee-exempt and cannot have fees configured.");
    // ... rest of implementation
}
```

**Test Cases to Add:**
1. Test that `SetMethodFee` rejects fee-exempt methods (if using validation approach)
2. Test that fees set via `SetMethodFee` are correctly returned by `GetMethodFee` for all methods
3. Integration test verifying actual fee collection matches `GetMethodFee` return values
4. Test that governance can modify fee-free policy through proper channels if needed

### Proof of Concept

**Required Initial State:**
- CrossChain contract deployed and initialized
- Parliament contract set as MethodFeeController (default configuration)

**Transaction Sequence:**

1. **Governance sets fees for ProposeCrossChainIndexing:**
   - Parliament creates proposal: `SetMethodFee({MethodName: "ProposeCrossChainIndexing", Fees: [{Symbol: "ELF", BasicFee: 100000000}]})`
   - Miners approve and release proposal
   - Transaction succeeds, `State.TransactionFees["ProposeCrossChainIndexing"]` = MethodFees with 1 ELF base fee

2. **Query stored fees:**
   - Call `State.TransactionFees["ProposeCrossChainIndexing"]` directly
   - **Result**: Returns MethodFees with BasicFee = 100000000 ELF ✓ (fees appear to be set)

3. **Query fees via GetMethodFee:**
   - Call `GetMethodFee({Value: "ProposeCrossChainIndexing"})`
   - **Result**: Returns MethodFees with IsSizeFeeFree=true and empty Fees list ✗ (stored fees ignored)

4. **Execute ProposeCrossChainIndexing transaction:**
   - Miner calls `ProposeCrossChainIndexing` with cross-chain data
   - TokenContract calls `ChargeTransactionFees`, which calls `GetMethodFee` on CrossChainContract
   - Receives hardcoded response: IsSizeFeeFree=true, empty fees
   - **Result**: Zero fees charged, transaction executes for free ✗

**Expected vs Actual Result:**
- **Expected**: Fees set by governance via SetMethodFee should be enforced during execution, charging 1 ELF base fee
- **Actual**: GetMethodFee returns hardcoded size-fee-free configuration, charging 0 fees
- **Success Condition for Exploit**: Governance loses control - stored fees never take effect

**Verification:**
Check transaction fee events after step 4 - no `TransactionFeeCharged` event with Symbol="ELF" and Amount=100000000 will be emitted, proving fees were not collected despite being set by governance.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_ACS1_TransactionFeeProvider.cs (L12-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_ACS1_TransactionFeeProvider.cs (L37-49)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (new List<string>
            {
                nameof(ProposeCrossChainIndexing), nameof(ReleaseCrossChainIndexingProposal)
            }.Contains(input.Value))
            return new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
        return State.TransactionFees[input.Value];
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-52)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
```
