### Title
Consensus Threshold Manipulation via Strategic Mining Abstention Blocks Term Changes

### Summary
The `NeedToChangeTerm()` function calculates the consensus threshold (`MinersCountOfConsent`) based on the total number of miners but only counts miners who have actually mined blocks in the current round. Colluding miners can deliberately abstain from mining to prevent the active miner count from reaching the required two-thirds threshold, blocking term changes indefinitely (up to 3 days before evil miner detection). This violates the democratic election mechanism and delays critical operations including miner list updates, reward distribution, and election snapshot processing.

### Finding Description

The vulnerability exists in the term change consensus mechanism. The `NeedToChangeTerm()` method filters miners based on whether they have `ActualMiningTimes` entries before checking if the term change threshold is met: [1](#0-0) 

The threshold `MinersCountOfConsent` is calculated as two-thirds plus one of the **total** miner count: [2](#0-1) 

**Root Cause:** The mismatch between using total miners for the threshold calculation but only counting active miners (those with `ActualMiningTimes`) creates an exploitable gap.

When a new round is generated, `ActualMiningTimes` is reset for all miners (new `MinerInRound` objects are created without copying this field): [3](#0-2) 

Miners populate `ActualMiningTimes` only when they produce blocks via `UpdateValue` or `TinyBlock` transactions: [4](#0-3) [5](#0-4) 

The consensus behavior provider uses `NeedToChangeTerm()` to decide between `NextRound` and `NextTerm`: [6](#0-5) 

**Why Existing Protections Fail:**

The evil miner detection mechanism has a tolerance of 4,320 missed time slots (3 days): [7](#0-6) 

This gives colluding miners a 3-day window to block term changes before being marked as evil: [8](#0-7) 

### Impact Explanation

**Concrete Harm:**

1. **Election Integrity Violation:** Miners who lost elections can prevent newly elected miners from taking their positions. The term change process updates the miner list based on election results: [9](#0-8) 

2. **Reward Distribution Delay:** Mining rewards donation to Treasury and subsequent release are blocked: [10](#0-9) 

3. **Statistical Reset Prevention:** Evil miner counters and production statistics remain unflushed: [11](#0-10) 

4. **Election Snapshot Failure:** Critical election snapshots cannot be taken, affecting governance data integrity: [12](#0-11) 

**Quantified Impact:**
- For a 21-miner configuration: `MinersCountOfConsent = 21 * 2 / 3 + 1 = 15`
- If 8 miners abstain: Only 13 miners remain active
- Even if all 13 support term change: `13 < 15` → blocked
- Duration: Up to 3 days (4,320 consecutive missed slots)
- Affected parties: New election winners, token holders expecting rewards, governance participants

### Likelihood Explanation

**Attacker Capabilities:**
- Requires 1/3 + 1 miners to collude (8 out of 21 in standard configuration)
- Attackers must be current miners scheduled in the round
- No special permissions or external resources needed beyond mining rights

**Attack Complexity:**
- **Execution:** Trivial - miners simply don't call `UpdateValue` or `TinyBlock` methods
- **Detection:** Visible via `MissedTimeSlots` counter increment, but tolerated for 3 days
- **Coordination:** Requires pre-coordination among minority colluding miners

**Feasibility Conditions:**
- Most likely when current miners face election loss and want to extend their tenure
- Economic incentive: Continue earning mining rewards for 3 additional days
- No technical barriers - miners control their own block production

**Economic Rationality:**
If miners are about to lose their positions (e.g., losing an upcoming election), they have strong financial incentive to delay the term change. Mining rewards continue accruing during the delay period, making the attack economically rational for miners facing replacement.

**Probability Assessment:** MEDIUM-HIGH
- Requires minority collusion (feasible in adversarial scenarios)
- Direct economic benefit for attackers
- No immediate punishment (3-day tolerance window)

### Recommendation

**Code-Level Mitigation:**

Modify `NeedToChangeTerm()` to use a denominator based on miners who **should have** mined (expected active miners) rather than total miners, or calculate the threshold based only on miners with `ActualMiningTimes`:

```csharp
public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
{
    var minersWithActivity = RealTimeMinersInformation.Values
        .Where(m => m.ActualMiningTimes.Any())
        .ToList();
    
    // Use dynamic threshold based on active miners, not total miners
    var activeMinersConsent = minersWithActivity.Count.Mul(2).Div(3).Add(1);
    
    return minersWithActivity
        .Select(m => m.ActualMiningTimes.Last())
        .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp, t, currentTermNumber, periodSeconds))
        >= activeMinersConsent;
}
```

**Invariant Checks:**
- Add assertion: "Active miners supporting term change must exceed two-thirds of **active** miners, not total miners"
- Add minimum activity threshold: "At least 51% of total miners must have mined in the round for term change to be valid"

**Additional Safeguards:**
1. Reduce `TolerableMissedTimeSlotsCount` during term change periods
2. Add emergency term change mechanism if miners remain inactive beyond tolerance
3. Implement automatic term change after absolute time threshold (e.g., 1.5x `periodSeconds`)

**Test Cases:**
1. Test term change with 1/3 miners inactive
2. Test term change blocked when >1/3 miners abstain  
3. Test evil miner detection triggers before term change succeeds
4. Test term change with varying activity levels

### Proof of Concept

**Initial State:**
- 21 active miners in current term (term N)
- Election results show 8 current miners lost and will be replaced in term N+1
- Current time has exceeded term period threshold
- `MinersCountOfConsent = 21 * 2 / 3 + 1 = 15`

**Attack Sequence:**

1. **Round Start:** New round begins, all miners have empty `ActualMiningTimes`

2. **Strategic Abstention:** 8 losing miners coordinate to NOT call `UpdateValue` or `TinyBlock`
   - These 8 miners deliberately skip their time slots
   - Their `ActualMiningTimes` remain empty
   - Their `MissedTimeSlots` increment by 1 each round

3. **Active Mining:** Remaining 13 miners produce blocks normally
   - Each has `ActualMiningTimes` populated
   - All 13 have timestamps indicating term change should occur

4. **Term Change Check:** When `GetConsensusBehaviourToTerminateCurrentRound()` executes:
   - `NeedToChangeTerm()` filters: 13 miners with `ActualMiningTimes.Any()`
   - All 13 have times indicating term change needed
   - Count = 13
   - Threshold = 15 (based on total 21 miners)
   - **Result:** `13 < 15` → returns `false`

5. **Behavior Decision:** 
   - Since `NeedToChangeTerm()` returns `false`
   - Returns `AElfConsensusBehaviour.NextRound` instead of `NextTerm`
   - **Term change is blocked**

6. **Repetition:** Attack repeats for up to 4,320 rounds (3 days)
   - At round 4,321, abstaining miners marked as evil
   - But term change has been delayed by 3 days

**Expected vs Actual:**
- **Expected:** Term changes when time threshold exceeded and 2/3 consensus reached
- **Actual:** Term change blocked despite time threshold being met, because inactive miners not counted toward threshold but still counted in threshold calculation

**Success Condition:** 
Term change transaction (`NextTerm`) is not generated despite `periodSeconds` having elapsed and majority of **active** miners indicating term change readiness.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L179-183)
```csharp
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L304-304)
```csharp
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L30-35)
```csharp
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```
