### Title
Indefinite Symbol Reservation via Unbounded SEED NFT Expiration Time

### Summary
The `CreateNFTInfo()` and `ExtendSeedExpirationTime()` functions lack upper bound validation on expiration times, allowing SEED NFT owners to reserve symbols indefinitely (e.g., until year 9999). This prevents legitimate users from creating tokens with those symbols, effectively enabling permanent namespace squatting and denial-of-service attacks on the token creation system.

### Finding Description

**Root Cause:**

In `CreateNFTInfo()`, the expiration time validation only checks a lower bound with no maximum limit: [1](#0-0) 

The validation merely ensures `Context.CurrentBlockTime.Seconds <= expirationTimeLong`, permitting astronomically large values like timestamps representing year 9999 or beyond.

Similarly, `ExtendSeedExpirationTime()` allows SEED NFT owners to update expiration times without any upper bound checks: [2](#0-1) 

The function only validates sender ownership (line 703) but imposes no limits on the new expiration value (lines 711-712).

**Why Protections Fail:**

When a SEED NFT is created, it reserves an `ownedSymbol` in the state mapping: [3](#0-2) 

The `CheckSymbolSeed()` function prevents creating new SEED NFTs for symbols that are already reserved by unexpired SEEDs: [4](#0-3) 

The assertion at line 66 fails if an existing SEED reserves the symbol and hasn't expired (`Context.CurrentBlockTime.Seconds <= symbolSeedExpireTime`).

**Execution Path:**

1. Attacker obtains a SEED NFT (either as SEED-0 collection owner creating one, or by receiving an existing SEED)
2. Attacker calls `ExtendSeedExpirationTime()` with `ExpirationTime = 253402300799` (December 31, 9999) or similar far-future timestamp
3. The symbol remains reserved in `State.SymbolSeedMap` indefinitely
4. When anyone attempts to create a token with that symbol:
   - Non-whitelisted users cannot obtain a SEED NFT for it because `CheckSymbolSeed()` fails in `CreateNFTInfo()` [5](#0-4) 
   - Whitelisted addresses (system contracts) also fail because `CheckSymbolSeed()` is invoked during validation [6](#0-5) 

### Impact Explanation

**Concrete Harm:**
- **Symbol Namespace DoS**: Attackers can permanently block desirable token symbols (e.g., "BTC", "ETH", "USD") from being created by legitimate projects
- **Griefing Attack**: Malicious actors can squat on hundreds or thousands of valuable symbol names, preventing the ecosystem from developing properly
- **Economic Damage**: Projects unable to use their intended symbols face branding issues and user confusion

**Affected Parties:**
- All future token creators who wish to use reserved symbols
- The broader AElf ecosystem's token namespace utility

**Severity Justification:**
Medium severity is appropriate because:
- Impact is operational (DoS on namespace) rather than direct fund theft
- Attack requires obtaining SEED NFTs, which depends on SEED-0 collection owner distribution policies
- However, once obtained, execution is trivial and effects are permanent
- No governance mechanism exists to forcibly expire or override reserved symbols

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a SEED NFT owner to call `ExtendSeedExpirationTime()` [7](#0-6) 
- Alternatively, must be the SEED-0 collection owner to create new SEED NFTs with far-future expiration during initial creation
- Once in possession of any SEED NFT, can extend its expiration arbitrarily

**Attack Complexity:**
- Low complexity: Single function call with one parameter (symbol and far-future timestamp)
- No additional preconditions beyond SEED NFT ownership
- Attack is immediately effective and irreversible

**Feasibility Conditions:**
- SEED NFTs must be distributed to users (either through SEED-0 owner issuance or secondary transfers)
- If SEED-0 owner is controlled by governance and only issues SEEDs with reasonable expiration times to trusted parties, attack surface is reduced
- However, SEED NFT owners can transfer their SEEDs to arbitrary addresses, and new owners can extend expiration

**Economic Rationality:**
- Attack cost is minimal: transaction fee for `ExtendSeedExpirationTime()` call
- Potential gain is significant: controlling valuable symbol namespace
- Could be used for speculation (holding symbols ransom) or pure griefing

**Probability Assessment:**
Medium likelihood - depends on SEED distribution model, but mechanism is fully functional and unprotected once SEEDs are in circulation.

### Recommendation

**Code-Level Mitigation:**

Add maximum expiration time validation in both functions:

1. In `CreateNFTInfo()`, add upper bound check after line 45:
```csharp
const long MaxExpirationPeriod = 31536000; // 1 year in seconds
Assert(expirationTimeLong <= Context.CurrentBlockTime.Seconds + MaxExpirationPeriod, 
    "Expiration time exceeds maximum allowed period.");
```

2. In `ExtendSeedExpirationTime()`, add the same validation before line 711:
```csharp
const long MaxExpirationPeriod = 31536000; // 1 year in seconds
Assert(input.ExpirationTime <= Context.CurrentBlockTime.Seconds + MaxExpirationPeriod,
    "Expiration time exceeds maximum allowed period.");
```

**Invariant Checks:**
- SEED expiration times must be <= (current time + maximum reasonable period, e.g., 1-5 years)
- Consider making the maximum period configurable via governance

**Additional Considerations:**
- Implement governance-controlled mechanism to forcibly expire or transfer SEED NFTs used for namespace squatting
- Add monitoring for SEED NFTs with abnormally long expiration times

**Test Cases:**
- Attempt to create SEED NFT with expiration time > max allowed period → should fail
- Attempt to extend SEED expiration beyond max period → should fail  
- Verify existing valid SEEDs continue to function within reasonable expiration ranges
- Test that symbols can be re-used after SEED expiration

### Proof of Concept

**Initial State:**
- SEED-0 collection exists with an owner address
- Target symbol "VALUABLE" is not yet reserved

**Attack Steps:**

1. **Create SEED NFT with far-future expiration:**
   - Caller: SEED-0 collection owner
   - Call: `Create()` with `CreateInput`:
     - Symbol: "SEED-1" 
     - ExternalInfo includes:
       - `__seed_owned_symbol`: "VALUABLE"
       - `__seed_exp_time`: "253402300799" (year 9999)
   - Result: SEED-1 created, State.SymbolSeedMap["VALUABLE"] = "SEED-1"

2. **Alternative - Extend existing SEED:**
   - Caller: Owner of SEED-1
   - Call: `ExtendSeedExpirationTime()` with:
     - Symbol: "SEED-1"
     - ExpirationTime: 253402300799
   - Result: SEED-1 expiration updated to year 9999

3. **Victim attempts to create token:**
   - Caller: Any user
   - Attempt: Create token with symbol "VALUABLE"
   - Path 1 (non-whitelisted): Try to obtain SEED for "VALUABLE" → `CheckSymbolSeed()` fails with "OwnedSymbol has been created"
   - Path 2 (whitelisted): `AssertValidCreateInput()` calls `CheckSymbolSeed()` → fails with same error
   - Result: Token creation blocked

**Expected vs Actual:**
- Expected: SEED expiration should be limited to reasonable timeframes (days, weeks, or months)
- Actual: No validation exists, allowing expiration times centuries in the future

**Success Condition:**
Symbol "VALUABLE" remains reserved and unusable by anyone (except SEED-1 owner who can use it once) until year 9999, effectively permanently blocking the namespace.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L42-45)
```csharp
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                       out var expirationTime)
                   && long.TryParse(expirationTime, out var expirationTimeLong) &&
                   Context.CurrentBlockTime.Seconds <= expirationTimeLong, "Invalid ownedSymbol.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L50-50)
```csharp
            CheckSymbolSeed(ownedSymbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L51-51)
```csharp
            State.SymbolSeedMap[ownedSymbol.ToUpper()] = input.Symbol;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L57-67)
```csharp
    private void CheckSymbolSeed(string ownedSymbol)
    {
        var oldSymbolSeed = State.SymbolSeedMap[ownedSymbol.ToUpper()];

        Assert(oldSymbolSeed == null || !GetTokenInfo(oldSymbolSeed).ExternalInfo.Value
                   .TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                       out var oldSymbolSeedExpireTime) ||
               !long.TryParse(oldSymbolSeedExpireTime, out var symbolSeedExpireTime)
               || Context.CurrentBlockTime.Seconds > symbolSeedExpireTime,
            "OwnedSymbol has been created");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L695-722)
```csharp
    public override Empty ExtendSeedExpirationTime(ExtendSeedExpirationTimeInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo == null)
        {
            throw new AssertionException("Seed NFT does not exist.");
        }

        Assert(tokenInfo.Owner == Context.Sender, "Sender is not Seed NFT owner.");
        var oldExpireTimeLong = 0L;
        if (tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                out var oldExpireTime))
        {
            long.TryParse(oldExpireTime, out oldExpireTimeLong);
        }

        tokenInfo.ExternalInfo.Value[TokenContractConstants.SeedExpireTimeExternalInfoKey] =
            input.ExpirationTime.ToString();
        State.TokenInfos[input.Symbol] = tokenInfo;
        Context.Fire(new SeedExpirationTimeUpdated
        {
            ChainId = tokenInfo.IssueChainId,
            Symbol = input.Symbol,
            OldExpirationTime = oldExpireTimeLong,
            NewExpirationTime = input.ExpirationTime
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L282-282)
```csharp
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
```
