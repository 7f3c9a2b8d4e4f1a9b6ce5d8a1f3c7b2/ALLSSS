### Title
Piecewise Write Fee Structure Allows Fee Evasion Through Transaction Splitting

### Summary
The write fee calculation uses a piecewise polynomial structure with discontinuous rate changes at boundaries (x=10 and x=100). Since the fee calculation resets for each transaction, attackers can split write operations across multiple transactions to repeatedly utilize lower-tier rates, avoiding the steep quadratic fees designed for high-volume operations. This enables significant fee savings, undermining the protocol's progressive fee design.

### Finding Description

The `GetWriteFeeInitialCoefficient()` function defines three fee tiers with increasing marginal costs: [1](#0-0) 

The three intervals are:
- **[0, 10]**: `x/8 + 1/10000` (cheapest, linear)
- **(10, 100]**: `x/4` (moderate, linear with higher slope)
- **(100, +∞)**: `x/4 + 25x²/16` (expensive, quadratic growth)

The fee calculation applies these formulas cumulatively per transaction based on write count: [2](#0-1) [3](#0-2) 

The root cause is that each transaction's write count starts fresh at the beginning of the piecewise function. The cumulative calculation processes intervals sequentially, but this resets for each new transaction, allowing attackers to avoid expensive higher tiers by keeping operations below thresholds.

No protection exists to prevent strategic transaction splitting or to enforce continuity of fees across related transactions.

### Impact Explanation

**Concrete Example - 200 Write Operations:**

**Option 1: Single transaction (200 writes)**
- Tier 1 [0-10]: `f₁(10) = 10/8 + 1/10000 = 1.2501` tokens
- Tier 2 (10-100]: `f₂(90) = 90/4 = 22.5` tokens  
- Tier 3 (100-200]: `f₃(100) = 100/4 + 100² × 25/16 = 25 + 15625 = 15650` tokens
- **Total: 15,673.75 tokens**

**Option 2: Two transactions (100 writes each)**
- Transaction 1 & 2 each pay:
  - Tier 1 [0-10]: `1.2501` tokens
  - Tier 2 (10-100]: `22.5` tokens
  - Subtotal: `23.75` tokens
- **Total: 47.50 tokens**

**Fee Savings: 15,626.25 tokens (99.7% reduction!)**

The additional TX fee cost (based on transaction size, typically 1-2 tokens per transaction) is negligible compared to the WRITE fee savings. [4](#0-3) 

**Who is affected:**
- The protocol loses substantial fee revenue from resource tokens
- Honest users who don't optimize pay 300x+ more than attackers
- The fee structure's purpose (discouraging large operations) is defeated

### Likelihood Explanation

**Attacker Capabilities:**
- Any user deploying smart contracts can structure their logic to split operations across multiple contract calls/transactions
- No special permissions or governance control needed
- Standard contract development practice

**Attack Complexity:** Low
- Attacker simply needs to design their contract to batch operations in groups of <100 writes per transaction
- Example: Instead of one `ProcessBatch(200 items)` function, call `ProcessBatch(100 items)` twice

**Economic Rationality:** Highly profitable
- For 200 writes: Save 15,626 tokens, pay ~2 extra tokens in TX fees
- Net savings: 15,624 tokens
- For larger operations (1000+ writes), savings grow exponentially due to quadratic tier

**Feasibility Conditions:**
- Works on any contract with significant write operations
- No blockchain state requirements
- No timing constraints
- Cannot be detected or prevented without protocol changes

**Probability:** HIGH - Sophisticated users will naturally discover this optimization when designing high-throughput contracts.

### Recommendation

**1. Make fee calculation cumulative across related operations:**

Add a per-account or per-contract-address cumulative write counter that persists across transactions within a time window (e.g., per block or per day). The fee calculation should use this cumulative count instead of resetting per transaction.

**2. Implement fee continuity checks:**

Modify the `CalculateFee` function to track the last interval boundary crossed and start subsequent calculations from that point, preventing reset exploitation.

**3. Alternative: Remove or smooth discontinuities:**

Replace the piecewise structure with a continuous function (e.g., single polynomial or exponential) that maintains progressive pricing without exploitable jumps:
- Example: `fee(x) = a×x + b×x^c` where c ≈ 1.5-2.0

**4. Add transaction pattern detection:**

Monitor for suspicious patterns (multiple small transactions from same address) and apply aggregate fee calculation retroactively.

**5. Test cases to add:**
- Verify fee for N operations in 1 transaction > fee for same N operations split across k transactions (for all N, k combinations)
- Test boundary conditions at x=10, 100 with ±1 write variations
- Validate cumulative counter persistence across transaction boundaries

### Proof of Concept

**Initial State:**
- Attacker controls a smart contract with capability to perform 200 state writes
- Current WRITE token price: 1 token = $0.10 (example)
- TX fee: ~1.5 tokens per transaction

**Attack Sequence:**

**Step 1:** Attacker deploys contract with two functions:
```
Function A: Performs 100 write operations
Function B: Performs 100 write operations  
```

**Step 2:** Execute attack:
- Transaction 1: Call Function A
  - Writes: 100
  - WRITE fee: 23.75 tokens
  - TX fee: 1.5 tokens
  - Total: 25.25 tokens

- Transaction 2: Call Function B
  - Writes: 100
  - WRITE fee: 23.75 tokens
  - TX fee: 1.5 tokens
  - Total: 25.25 tokens

- **Attack Total Cost: 50.50 tokens**

**Step 3:** Compare with honest approach:
- Single transaction with 200 writes
- WRITE fee: 15,673.75 tokens
- TX fee: 1.5 tokens
- **Honest Total Cost: 15,675.25 tokens**

**Expected Result:** Attacker pays 50.50 tokens
**Actual Result:** Attacker pays 50.50 tokens (as designed)
**Honest User Result:** Pays 15,675.25 tokens

**Success Condition:** Attack achieves 99.68% fee reduction (saves 15,624.75 tokens = $1,562 at $0.10/token)

The vulnerability is confirmed by the fee calculation logic that processes each transaction independently without cross-transaction state tracking. [5](#0-4)

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L210-240)
```csharp
                new CalculateFeePieceCoefficients
                {
                    // Interval [0, 10]: x / 8 + 1 / 10000
                    Value =
                    {
                        10,
                        1, 1, 8,
                        0, 1, 10000
                    }
                },
                new CalculateFeePieceCoefficients
                {
                    // Interval (10, 100]: x / 4
                    Value =
                    {
                        100,
                        1, 1, 4
                    }
                },
                new CalculateFeePieceCoefficients
                {
                    // Interval (100, +∞): x / 4 + x^2 * 25 / 16
                    Value =
                    {
                        int.MaxValue,
                        1, 1, 4,
                        2, 25, 16
                    }
                }
            }
        };
```

**File:** src/AElf.Kernel.FeeCalculation/Infrastructure/CalculateFunction.cs (L34-58)
```csharp
    public long CalculateFee(int totalCount)
    {
        if (CalculateFeeCoefficients.PieceCoefficientsList.Count != _currentCalculateFunctions.Count)
            throw new ArgumentOutOfRangeException(nameof(_currentCalculateFunctions),
                "Coefficients count not match.");

        var remainCount = totalCount;
        var result = 0L;
        var pieceStart = 0;
        for (var i = 0; i < _currentCalculateFunctions.Count; i++)
        {
            var function = _currentCalculateFunctions[i];
            var pieceCoefficient = CalculateFeeCoefficients.PieceCoefficientsList[i].Value;
            var pieceUpperBound = pieceCoefficient[0];
            var interval = pieceUpperBound - pieceStart;
            pieceStart = pieceUpperBound;
            var count = Math.Min(interval, remainCount);
            result += function(count);
            if (pieceUpperBound > totalCount) break;

            remainCount -= interval;
        }

        return result;
    }
```

**File:** src/AElf.Kernel.FeeCalculation/Infrastructure/WriteFeeProvider.cs (L15-18)
```csharp
    protected override int GetCalculateCount(ITransactionContext transactionContext)
    {
        return transactionContext.Trace.StateSet.Writes.Count;
    }
```

**File:** src/AElf.Kernel.FeeCalculation/Extensions/CalculateFeeCoefficientsExtensions.cs (L10-10)
```csharp
    private const decimal Precision = 100000000;
```

**File:** src/AElf.Kernel.FeeCalculation/Infrastructure/TokenFeeProviderBase.cs (L24-37)
```csharp
    public Task<long> CalculateFeeAsync(ITransactionContext transactionContext, IChainContext chainContext)
    {
        var functionDictionary = _calculateFunctionProvider.GetCalculateFunctions(chainContext);
        var targetKey = ((FeeTypeEnum)_tokenType).ToString().ToUpper();
        if (!functionDictionary.ContainsKey(targetKey))
        {
            var currentKeys = string.Join(" ", functionDictionary.Keys);
            throw new InvalidOperationException($"Function not found. Current keys: {currentKeys}");
        }

        var function = functionDictionary[targetKey];
        var count = GetCalculateCount(transactionContext);
        return Task.FromResult(function.CalculateFee(count));
    }
```
