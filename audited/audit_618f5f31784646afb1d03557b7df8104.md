# Audit Report

## Title
Proposal Hash Squatting via Expired Entry Overwrite Enables Denial-of-Service and Authorship Hijacking

## Summary
The `RegisterContractProposingData` function in the Genesis contract (BasicContractZero) lacks validation to verify that the caller is the original proposer when overwriting an expired proposal entry. This allows any address to hijack expired proposal hashes, preventing legitimate proposers from re-submitting their proposals and potentially enabling authorship takeover through governance manipulation.

## Finding Description

The vulnerability exists in the `RegisterContractProposingData` helper function [1](#0-0) , which is invoked during contract deployment and update proposals [2](#0-1) [3](#0-2) .

The root cause is insufficient validation when an expired proposal entry is overwritten. The function checks whether no entry exists OR the current time exceeds the expiration time [4](#0-3) , but then unconditionally creates a new entry with the caller as the proposer [5](#0-4) . There is no verification that the caller is the original proposer.

Proposal hashes are deterministically computed from input parameters [6](#0-5) . The default expiration period is 72 hours (259,200 seconds) [7](#0-6) .

The proposer identity is critical because:
1. `ReleaseApprovedContract` validates that only the registered proposer can progress the proposal [8](#0-7) 
2. When contracts are deployed, the proposer can become the contract author (if whitelisted) [9](#0-8) [10](#0-9) 

**Attack Flow:**
1. Original proposer Alice calls `ProposeNewContract` with specific parameters, creating a proposal entry that expires in 72 hours
2. Proposal expires due to governance delays or timing issues
3. Attacker Bob calls `ProposeNewContract` with identical parameters
4. `RegisterContractProposingData` allows the overwrite because `Context.CurrentBlockTime >= registered.ExpiredTime`
5. Bob becomes the new proposer, locking out Alice for another 72 hours
6. If Bob is whitelisted and his proposal passes governance, Bob becomes the contract author

## Impact Explanation

**Denial-of-Service Impact:** When a legitimate proposer's entry expires, an attacker can immediately re-register the same proposal hash as their own. The original proposer cannot re-submit for another 72 hours due to the "Already proposed" assertion. For deterministic contract deployments requiring specific salt values to achieve particular contract addresses, this becomes a permanent denial-of-service since changing the salt changes the resulting address.

**Authorship Hijacking Impact:** If the attacker is in the deployment controller's proposer whitelist and their duplicate proposal passes through Parliament approval and code checking, the attacker becomes the contract author instead of the legitimate designer. Contract authors have privileged operations including the ability to propose contract updates [11](#0-10)  and transfer authorship [12](#0-11) .

**Indefinite Squatting:** An attacker can maintain control over a proposal hash indefinitely by re-registering it every 72 hours before expiration, effectively preventing the legitimate proposer from ever using those parameters.

This violates the security invariant that proposal lifecycle should be controlled exclusively by the original proposer.

## Likelihood Explanation

**Attack Complexity:** Low. The attacker needs to:
1. Monitor the chain for expired proposal entries (easily automated)
2. Extract the input parameters from the original proposal transaction (publicly available on-chain)
3. Call `ProposeNewContract` or `ProposeUpdateContract` with identical parameters immediately after expiration

**Economic Barriers:** Minimal. No explicit fees, stakes, or deposits are required beyond standard transaction gas costs. The attacker doesn't need to complete the full governance process to achieve denial-of-service; merely registering the hash is sufficient to block the legitimate proposer.

**Entry Points:** The attack uses public methods `ProposeNewContract` [13](#0-12)  and `ProposeUpdateContract` [14](#0-13)  that are accessible to any address.

**Realistic Scenario:** Legitimate proposals may expire due to governance bottlenecks, Parliament coordination delays, or deliberate timing by participants. Once expired, they become vulnerable to hijacking.

## Recommendation

Add validation in `RegisterContractProposingData` to ensure that when overwriting an expired entry, the caller must be the original proposer:

```csharp
private void RegisterContractProposingData(Hash proposedContractInputHash)
{
    var registered = State.ContractProposingInputMap[proposedContractInputHash];
    
    // If entry exists and hasn't expired, reject
    Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
    
    // If expired entry exists, only original proposer can re-register
    if (registered != null && Context.CurrentBlockTime >= registered.ExpiredTime)
    {
        Assert(registered.Proposer == Context.Sender, "Only original proposer can re-register expired proposal.");
    }
    
    var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
    State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
    {
        Proposer = Context.Sender,
        Status = ContractProposingInputStatus.Proposed,
        ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
    };
}
```

Alternatively, implement automatic cleanup of expired entries or allow the original proposer to reclaim their hash through a dedicated method.

## Proof of Concept

```csharp
[Fact]
public async Task ProposalHashSquatting_Attack()
{
    // Setup: Original proposer creates a proposal
    var contractDeploymentInput = new ContractDeploymentInput
    {
        Category = KernelConstants.DefaultRunnerCategory,
        Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value)
    };

    var utcNow = TimestampHelper.GetUtcNow();
    
    // Step 1: Legitimate proposer creates proposal
    var originalProposingTx = await LegitimateProposerTester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeNewContract), 
        contractDeploymentInput, 
        utcNow);
    originalProposingTx.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var proposedContractInputHash = ContractProposed.Parser
        .ParseFrom(originalProposingTx.Logs.First(l => l.Name.Contains(nameof(ContractProposed))).NonIndexed)
        .ProposedContractInputHash;

    // Step 2: Wait for expiration (72 hours)
    var expirationPeriod = await Tester.CallContractMethodAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractProposalExpirationTimePeriod),
        new Empty());
    var expirationSeconds = Int32Value.Parser.ParseFrom(expirationPeriod).Value;
    
    // Step 3: Attacker hijacks the expired proposal hash
    var attackerProposingTx = await AttackerTester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeNewContract),
        contractDeploymentInput,
        utcNow.AddSeconds(expirationSeconds));
    
    // Vulnerability: Attacker successfully registers with same hash
    attackerProposingTx.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 4: Original proposer cannot re-submit
    var retrialTx = await LegitimateProposerTester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeNewContract),
        contractDeploymentInput,
        utcNow.AddSeconds(expirationSeconds + 1));
    
    // Denial-of-Service: Original proposer is blocked
    retrialTx.Status.ShouldBe(TransactionResultStatus.Failed);
    retrialTx.Error.ShouldContain("Already proposed.");
}
```

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L175-178)
```csharp
    private Hash CalculateHashFromInput(IMessage input)
    {
        return HashHelper.ComputeFrom(input);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L257-266)
```csharp
    private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
    {
        if (!State.ContractDeploymentAuthorityRequired.Value)
            return sender;

        var contractDeploymentController = State.ContractDeploymentController.Value;
        var isProposerInWhiteList = ValidateProposerAuthority(contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposer);
        return isProposerInWhiteList ? proposer : Context.Self;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L122-128)
```csharp
    public override Hash ProposeNewContract(ContractDeploymentInput input)
    {
        // AssertDeploymentProposerAuthority(Context.Sender);
        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        AssertContractNotExists(codeHash);
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-178)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L181-183)
```csharp
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L277-284)
```csharp
    public override Empty ReleaseApprovedContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];
        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.Proposed &&
            contractProposingInput.Proposer == Context.Sender, "Invalid contract proposing status.");
        contractProposingInput.Status = ContractProposingInputStatus.Approved;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L314-321)
```csharp
        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address =
            DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
                DecideNonSystemContractAuthor(contractProposingInput?.Proposer, Context.Sender), false,
                input.ContractOperation?.Deployer, input.ContractOperation?.Salt);
        return address;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L519-524)
```csharp
    public override Empty SetContractAuthor(SetContractAuthorInput input)
    {
        var info = State.ContractInfos[input.ContractAddress];
        Assert(info != null, "Contract not found.");
        var oldAuthor = info.Author;
        Assert(Context.Sender == info.Author, "No permission.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L5-5)
```csharp
    public const int ContractProposalExpirationTimePeriod = 259200; // 60 * 60 * 72
```
