### Title
Consensus Signature Manipulation via PreviousInValue Bypass

### Summary
Miners can bypass the cryptographic commitment scheme by providing null or Hash.Empty for PreviousInValue in non-first rounds, triggering a fallback path that calculates signatures using a deterministic fake value instead of their actual committed InValue. This allows miners to choose between two different signature values and manipulate their mining order in subsequent rounds, breaking the randomness guarantees of the AEDPoS consensus protocol.

### Finding Description

**Vulnerable Code Location:**
The vulnerability exists in the `GetConsensusExtraDataToPublishOutValue` function where miners can force execution down the "fake previous in value" path by not providing their actual PreviousInValue. [1](#0-0) 

**Root Cause:**
The validation logic explicitly allows null or Hash.Empty values for PreviousInValue without any penalty: [2](#0-1) 

When PreviousInValue is null or Hash.Empty, the code computes a deterministic fake value based on the miner's public key and current block height. For actively mining nodes, the `appointedPreviousInValue` from previous round state is null (since InValue is only stored for miners who missed their turn), causing the system to use the computed fake value for signature calculation. [3](#0-2) 

**Why Protections Fail:**
The system explicitly permits miners not to reveal their InValues, as evidenced by the comment and conditional storage: [4](#0-3) 

The trigger information provider retrieves PreviousInValue from a local cache that only retains the 10 most recent entries and returns Hash.Empty if missing: [5](#0-4) [6](#0-5) 

**Execution Path:**
1. Miner generates InValue_N in Round N, publishes OutValue_N = Hash(InValue_N)
2. In Round N+1, miner intentionally doesn't cache InValue_N or provides null
3. Trigger information provider returns Hash.Empty for PreviousInValue
4. Validation passes (returns true for Hash.Empty)
5. Contract takes fake path, computes fakePreviousInValue = Hash(pubkey + currentHeight)
6. Signature calculated using fake value instead of actual InValue_N
7. Miner never reveals their committed InValue_N, breaking the commitment chain

### Impact Explanation

**Direct Consensus Integrity Harm:**
The signature value directly determines mining order in the next round through a modulo operation: [7](#0-6) 

By choosing whether to reveal their real InValue or use the fake path, a malicious miner can compute both possible signatures and select whichever yields a more favorable mining position. This violates the core security property of AEDPoS that mining order should be unpredictable and non-manipulable.

**Affected Parties:**
- All honest miners lose fair randomness in mining order assignment
- The consensus protocol's security assumptions are violated
- Protocol users face potential block production manipulation

**Severity Justification:**
HIGH - This breaks a fundamental cryptographic commitment scheme underlying consensus randomness. While the fake value is deterministic (not arbitrarily chosen), the ability to choose between two options gives malicious miners a strategic advantage in mining order assignment, potentially leading to longer-term consensus manipulation or MEV extraction through favorable scheduling.

### Likelihood Explanation

**Attacker Capabilities:**
Any miner participating in the consensus protocol can execute this attack. The only requirement is controlling their own InValue cache population, which is entirely under the miner's control through the local `IInValueCache` service.

**Attack Complexity:**
LOW - The attack is straightforward:
1. Before producing a block, pre-compute signature with real InValue: `sig_real = previousRound.CalculateSignature(InValue_N)`
2. Pre-compute signature with fake value: `sig_fake = previousRound.CalculateSignature(Hash(pubkey + height))`
3. Calculate mining orders from both: `order = (signature % minersCount) + 1`
4. Choose to provide real InValue or null based on which gives better order
5. Produce block with chosen option

**Feasibility Conditions:**
The attack requires no special permissions or state. The miner simply:
- Does not call `_inValueCache.AddInValue()` for their InValue, OR
- Provides null in the trigger information

The validation explicitly allows this, making execution guaranteed to succeed.

**Detection Constraints:**
Difficult to detect as the behavior is indistinguishable from legitimate cache misses or intentional non-revelation (which the protocol permits). No on-chain evidence exists to prove malicious intent.

**Probability:**
HIGH - Rational miners have strong incentive to optimize their mining order. The attack cost is zero (just don't cache a value), while the benefit is improved block production scheduling. In competitive mining environments, this becomes a nash equilibrium where all rational miners must exploit this to stay competitive.

### Recommendation

**Code-Level Mitigation:**
1. Require PreviousInValue revelation for all non-first rounds and non-replacement miners. Modify validation to reject null/Hash.Empty:

```csharp
// In UpdateValueValidationProvider.ValidatePreviousInValue():
if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
    return true;

// REMOVE these permissive checks:
// if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;
// if (previousInValue == Hash.Empty) return true;

// REQUIRE valid PreviousInValue for miners who were in previous round
var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
if (previousInValue == null || previousInValue == Hash.Empty)
    return false; // Reject instead of allowing

return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

2. Add penalty mechanism for miners who fail to reveal InValues (missed blocks, reduced rewards, or temporary suspension).

3. Remove the fake value fallback path entirely for active miners, only keeping it for genuine replacement scenarios with additional validation.

**Invariant Checks:**
- Assert that miners who produced blocks in previous round MUST provide valid PreviousInValue
- Verify Hash(PreviousInValue) == PreviousRound.OutValue for all revelations
- Track and penalize repeated failures to reveal InValues

**Test Cases:**
- Test that UpdateValue transactions with null PreviousInValue are rejected for miners who were active in previous round
- Test that fake value path is only accessible for genuine miner replacements (with Election contract verification)
- Test that repeated non-revelation triggers penalties
- Test signature calculation consistency across rounds

### Proof of Concept

**Required Initial State:**
- Blockchain with active AEDPoS consensus
- Attacker is a registered miner in the current mining schedule
- At least Round N=2 (past first round)

**Attack Sequence:**

1. **Round N - Normal Operation:**
   - Attacker mines normally, generates InValue_N
   - Publishes OutValue_N = Hash(InValue_N)
   - Stores signature_N in round state

2. **Round N+1 - Pre-Attack Calculation:**
   - Attacker retrieves previousRound state
   - Computes `sig_real = previousRound.CalculateSignature(InValue_N)`
   - Computes `fakePreviousInValue = Hash(pubkey + (N+1))`  
   - Computes `sig_fake = previousRound.CalculateSignature(fakePreviousInValue)`
   - Calculates `order_real = (sig_real % minersCount) + 1`
   - Calculates `order_fake = (sig_fake % minersCount) + 1`

3. **Round N+1 - Exploitation:**
   - If `order_fake` is better than `order_real`:
     - Attacker does NOT call `_inValueCache.AddInValue(N, InValue_N)`
     - Trigger information has `PreviousInValue = Hash.Empty`
     - Validation passes (line 46 returns true)
     - Fake path executes (lines 96-108)
     - Signature calculated with fakePreviousInValue
   - Otherwise, use normal path with real InValue_N

4. **Expected vs Actual Result:**
   - **Expected:** Miner uses signature based on their committed InValue_N
   - **Actual:** Miner uses signature based on fake computed value
   - Mining order in Round N+2 reflects the manipulated signature

**Success Condition:**
The attacker's `FinalOrderOfNextRound` in Round N+1 matches the order calculated from the fake signature rather than the real InValue commitment, demonstrating successful signature manipulation and mining order control.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L72-108)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound) && !IsFirstRoundOfCurrentTerm(out _))
        {
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
            else
            {
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L42-46)
```csharp
        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IInValueCache.cs (L23-33)
```csharp
    public Hash GetInValue(long roundId)
    {
        // Remove old in values. (Keep 10 in values.)
        const int keepInValuesCount = 10;
        if (_inValues.Keys.Count > keepInValuesCount)
            foreach (var id in _inValues.Keys.OrderByDescending(id => id).Skip(keepInValuesCount))
                _inValues.Remove(id);

        _inValues.TryGetValue(roundId, out var inValue);
        return inValue ?? Hash.Empty;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L53-67)
```csharp
        if (hint.Behaviour == AElfConsensusBehaviour.UpdateValue)
        {
            var newInValue = _inValueCache.GetInValue(hint.RoundId);
            var previousInValue = _inValueCache.GetInValue(hint.PreviousRoundId);
            Logger.LogDebug($"New in value {newInValue} for round of id {hint.RoundId}");
            Logger.LogDebug($"Previous in value {previousInValue} for round of id {hint.PreviousRoundId}");
            var trigger = new AElfConsensusTriggerInformation
            {
                Pubkey = Pubkey,
                InValue = newInValue,
                PreviousInValue = previousInValue,
                Behaviour = hint.Behaviour
            };

            return trigger.ToBytesValue();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
