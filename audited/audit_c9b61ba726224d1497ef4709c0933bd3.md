# Audit Report

## Title
Auto-Distribution Break Statement Prevents Multiple Token Threshold Checks in TokenHolder Contract

## Summary
The `RegisterForProfits` function contains a break statement that exits the threshold checking loop after processing only the first qualifying token, preventing subsequent tokens from being evaluated and distributed even when they simultaneously meet their configured thresholds. This breaks the multi-token auto-distribution functionality.

## Finding Description

The `RegisterForProfits` function implements auto-distribution logic to automatically trigger profit distribution when token balances exceed configured thresholds. The function iterates through all thresholds defined in `scheme.AutoDistributeThreshold` to check which tokens qualify for distribution. [1](#0-0) 

The critical flaw is the unconditional `break` statement at line 199. When the first token meets its threshold:
1. The token symbol is added to `distributedInput.AmountsMap` with value 0
2. The `break` immediately exits the foreach loop
3. All remaining thresholds are never evaluated
4. Subsequent qualifying tokens are excluded from the distribution

The `AutoDistributeThreshold` field is explicitly designed as a `map<string, int64>` to support multiple token symbols with different threshold values: [2](#0-1) 

The downstream `DistributeProfits` function in the Profit contract only processes tokens explicitly listed in the `AmountsMap` parameter. When a token symbol maps to value 0, the contract fetches and distributes the full balance of that token: [3](#0-2) 

Therefore, tokens not added to `AmountsMap` due to the premature loop exit will not be distributed, regardless of whether their balances exceed their configured thresholds.

## Impact Explanation

**Direct Impact**: When multiple token types accumulate in a profit scheme's virtual address and simultaneously meet their thresholds, only the first token encountered in the dictionary iteration will be auto-distributed. Other qualifying tokens remain locked in the virtual address.

**Affected Scenarios**:
- Multi-token profit schemes with configurations like `{"ELF": 1000, "USDT": 500, "BTC": 0.1}`
- When all three tokens exceed their thresholds simultaneously, only one gets distributed
- The remaining tokens' profits are trapped until the scheme manager manually calls `DistributeProfits` or another `RegisterForProfits` triggers when only those tokens qualify

**Severity Justification - Medium**:
1. Funds are not permanently lost but become temporarily inaccessible through auto-distribution
2. Manual intervention by the scheme manager can distribute the trapped profits
3. The issue affects core functionality of multi-token profit schemes
4. User experience is degraded as expected distributions don't occur

## Likelihood Explanation

**Reachable Entry Point**: `RegisterForProfits` is a public RPC method callable by any user: [4](#0-3) 

**Feasible Preconditions**:
1. A profit scheme created with multiple tokens in `AutoDistributeThreshold`
2. Multiple token types contributed to the scheme over time
3. Multiple tokens simultaneously exceed their configured thresholds
4. Any user calls `RegisterForProfits` to lock tokens and register

These conditions are realistic in production environments where schemes accept diverse payment tokens.

**Execution Practicality**: The bug triggers automatically during normal operation. No attacker manipulation is required - the break statement executes whenever the first qualifying token is found.

**Probability**: High for multi-token schemes. As profit schemes accumulate various token types, it's expected that multiple thresholds would be reached simultaneously, especially after periods where no distribution occurs.

## Recommendation

Remove the `break` statement on line 199 to allow the loop to continue evaluating all thresholds. The corrected logic should:

```csharp
foreach (var threshold in scheme.AutoDistributeThreshold)
{
    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
    {
        Owner = virtualAddress,
        Symbol = threshold.Key
    }).Balance;
    if (balance < threshold.Value) continue;
    if (distributedInput == null)
        distributedInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
    distributedInput.AmountsMap[threshold.Key] = 0;
    // Remove the 'break;' statement here to check all thresholds
}
```

This allows all qualifying tokens to be added to `AmountsMap` and distributed in a single call.

## Proof of Concept

```csharp
[Fact]
public async Task MultiToken_AutoDistribution_Bug_Proof()
{
    // Setup: Create scheme with multiple auto-distribute thresholds
    var amount = 1000L;
    var tokenELF = "ELF";
    var tokenJUN = "JUN";
    
    await StarterCreateIssueAndApproveTokenAsync(tokenJUN, 1000000L, 100000L);
    
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = tokenELF,
        AutoDistributeThreshold = 
        {
            { tokenELF, amount },
            { tokenJUN, amount }
        }
    });
    
    // Contribute both tokens to exceed thresholds
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Amount = amount,
        Symbol = tokenELF
    });
    
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Amount = amount,
        Symbol = tokenJUN
    });
    
    // Trigger auto-distribution via RegisterForProfits
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = amount,
        SchemeManager = Starter
    });
    
    // Get profits map - should contain BOTH tokens if working correctly
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
    {
        Manager = Starter
    });
    
    var profitMap = await ProfitContractStub.GetProfitsMap.CallAsync(new Profit.ClaimProfitsInput
    {
        Beneficiary = Starter,
        SchemeId = schemeIds.SchemeIds.First()
    });
    
    // BUG: Due to break statement, only 1 token distributed instead of 2
    // Expected: profitMap.Value.Count == 2 (both ELF and JUN)
    // Actual: profitMap.Value.Count == 1 (only first token checked)
    profitMap.Value.Count.ShouldBe(1); // Demonstrates the bug
    profitMap.Value.ContainsKey(tokenJUN).ShouldBeFalse(); // JUN not distributed
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L184-200)
```csharp
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }
```

**File:** protobuf/token_holder_contract.proto (L40-42)
```text
    // The user registers a bonus project.
    rpc RegisterForProfits (RegisterForProfitsInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/token_holder_contract.proto (L69-69)
```text
    map<string, int64> auto_distribute_threshold = 3;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L437-444)
```csharp
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
```
