### Title
Method Fee Token Validation Bypass via Token Contract Upgrade Leading to Fee Accumulation

### Summary
The Economic contract (and all ACS1-implementing contracts) validate fee tokens only once during `SetMethodFee` using the Token contract's `IsTokenAvailableForMethodFee` method, but do not re-validate during fee charging. If the Token contract is upgraded to modify this validation logic to allow non-burnable tokens, fees can be set and charged for tokens that cannot be burned, causing fees to silently accumulate in the Token contract indefinitely without being distributed or burned.

### Finding Description

**Core Validation Logic:**

The `AssertValidToken` function in the Economic contract validates tokens by calling the Token contract's `IsTokenAvailableForMethodFee` method: [1](#0-0) 

This validation is performed when fees are initially set via `SetMethodFee`: [2](#0-1) 

Currently, `IsTokenAvailableForMethodFee` in the Token contract returns true only for burnable tokens: [3](#0-2) 

**The Vulnerability:**

When fees are charged via `ChargeTransactionFees`, there is NO re-validation that tokens remain valid for method fees. The system simply retrieves stored fees from state and charges them: [4](#0-3) 

After fees are collected, they are transferred/burned via `TransferTransactionFeesToFeeReceiver`. This function checks `IsBurnable` directly and **silently returns** if the token is not burnable: [5](#0-4) 

**Attack Scenario:**

1. Token contract is upgraded (via governance) with modified `IsTokenAvailableForMethodFee` logic that allows non-burnable tokens
2. Method fee controller sets fees using a non-burnable token (e.g., "NBURN")
3. Validation passes because upgraded `IsTokenAvailableForMethodFee` returns true
4. Fees are stored in contract state
5. Users execute transactions and fees are charged from their balances
6. `ClaimTransactionFees` is called and fees accumulate in Token contract
7. `TransferTransactionFeesToFeeReceiver` silently fails due to `!tokenInfo.IsBurnable` check
8. Fees remain trapped in Token contract, never burned or distributed

**Affected Scope:**

This vulnerability affects ALL contracts implementing ACS1 (17+ system contracts including Economic, Consensus, Parliament, Treasury, TokenConverter, Election, etc.): [6](#0-5) 

### Impact Explanation

**Direct Fund Impact:**
- All transaction fees paid in non-burnable tokens are permanently locked in the Token contract
- Protocol loses 100% of fee revenue for affected tokens (no burning, no dividend distribution)
- Users pay fees that provide no economic value to the system

**Quantified Damage:**
- If 10,000 transactions each pay 0.1 tokens in a non-burnable fee token, 1,000 tokens accumulate uselessly
- Main chain loses 10% burn + 90% dividend distribution = 100% of fee economic function
- Side chains without fee receivers lose 100% of fees

**Affected Parties:**
- Users: Pay fees that are wasted
- Protocol: Loses fee-based economic mechanisms (burn deflation, dividend rewards)
- Validators/Stakers: Lose dividend distributions from transaction fees

**Severity Justification:**
High severity due to permanent loss of fee revenue across the entire protocol, breaking core tokenomics assumptions.

### Likelihood Explanation

**Preconditions:**
- Token contract must be upgraded via Genesis contract's `UpdateSmartContract` method (requires governance approval)
- Upgrade must modify `IsTokenAvailableForMethodFee` to allow non-burnable tokens

**Exploitation Complexity:**
- Low - Once Token contract is upgraded, setting fees with non-burnable tokens is straightforward
- Method fee controllers can immediately configure vulnerable fees
- No special privileges needed beyond standard fee configuration authority

**Feasibility Assessment:**
- **Moderate to High**: While malicious governance compromise is unlikely, this vulnerability could be introduced as a **bug during legitimate upgrades**
- Examples of risky changes:
  - Adding feature flags that inadvertently bypass `IsBurnable` check
  - Refactoring validation logic with logic errors
  - Adding new token types with different validation rules
  - Testing changes that aren't properly reverted

**Detection/Operational Constraints:**
- Silent failure in `TransferTransactionFeesToFeeReceiver` makes this hard to detect
- No events or errors emitted when fee burning fails
- Fees appear to charge successfully from user perspective
- Only observable through monitoring Token contract balance growth

**Probability Reasoning:**
Medium-High likelihood because:
1. Token contract upgrades are expected system maintenance
2. Bug introduction during refactoring is realistic
3. Silent failure mode prevents early detection
4. Affects 17+ system contracts simultaneously

### Recommendation

**Code-Level Mitigation:**

1. **Add re-validation during fee charging** in `ChargeTransactionFees`:

```csharp
// In TokenContract_Fees.cs, after line 38
var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
    new StringValue { Value = input.MethodName });
    
// Add validation for each fee symbol
if (methodFees != null && methodFees.Fees.Any())
{
    foreach (var methodFee in methodFees.Fees)
    {
        Assert(IsTokenAvailableForMethodFee(methodFee.Symbol), 
            $"Token {methodFee.Symbol} is no longer valid for method fees.");
    }
}
```

2. **Make fee burning failures explicit** in `TransferTransactionFeesToFeeReceiver`:

Replace silent return with:
```csharp
if (!tokenInfo.IsBurnable)
{
    Context.LogDebug(() => $"Cannot burn/distribute fees for non-burnable token {symbol}");
    Context.Fire(new FeeProcessingFailed 
    { 
        Symbol = symbol, 
        Amount = totalAmount,
        Reason = "Token not burnable"
    });
    return;
}
```

3. **Add invariant check in SetMethodFee**:

Store validation criteria with fees to detect inconsistencies:
```csharp
// Store token requirements at fee setup time
State.FeeTokenRequirements[input.MethodName][methodFee.Symbol] = new TokenRequirements
{
    IsBurnable = GetTokenInfo(methodFee.Symbol).IsBurnable,
    ValidatedAt = Context.CurrentHeight
};
```

**Test Cases:**

1. Test fee charging after simulated Token contract upgrade that changes validation
2. Test non-burnable token fee setting rejection
3. Test fee processing failure events emission
4. Test cross-contract consistency after Token contract state changes

### Proof of Concept

**Initial State:**
- Token contract deployed with current `IsTokenAvailableForMethodFee` implementation
- Non-burnable token "NBURN" exists with `IsBurnable = false`
- Economic contract deployed with method fee configuration capability

**Exploit Steps:**

1. **Upgrade Token Contract:**
   - Governance proposal to upgrade Token contract
   - New implementation modifies `IsTokenAvailableForMethodFee`:
   ```csharp
   public override BoolValue IsTokenAvailableForMethodFee(StringValue input)
   {
       return new BoolValue { Value = true }; // Bug: allows all tokens
   }
   ```
   - Proposal approved and executed via Genesis contract

2. **Set Vulnerable Fees:**
   - Method fee controller calls `EconomicContract.SetMethodFee`:
   ```
   Input: { 
     MethodName: "IssueNativeToken",
     Fees: [{ Symbol: "NBURN", BasicFee: 100 }]
   }
   ```
   - Validation passes because upgraded `IsTokenAvailableForMethodFee` returns true
   - Fees stored in `State.TransactionFees["IssueNativeToken"]`

3. **Users Pay Fees:**
   - User calls `IssueNativeToken` with sufficient NBURN balance
   - Pre-execution plugin calls `ChargeTransactionFees`
   - 100 NBURN deducted from user balance
   - `TransactionFeeCharged` event emitted

4. **Fees Accumulate:**
   - Next block: `ClaimTransactionFees` called by miner
   - NBURN fees added to Token contract balance
   - `TransferTransactionFeesToFeeReceiver` called
   - Check `!tokenInfo.IsBurnable` returns true (NBURN is not burnable)
   - Function silently returns without burning or distributing
   - Fees remain in Token contract indefinitely

**Expected vs Actual Result:**
- **Expected:** Only burnable tokens accepted for fees; fees burned/distributed correctly
- **Actual:** Non-burnable tokens accepted; fees charged but never burned/distributed; silent accumulation

**Success Condition:**
Verify Token contract balance increases by fee amount without corresponding `Burned` events or dividend distributions, demonstrating fee accumulation without processing.

### Citations

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L11-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
```

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L78-87)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L252-257)
```csharp
    private bool IsTokenAvailableForMethodFee(string symbol)
    {
        var tokenInfo = GetTokenInfo(symbol);
        if (tokenInfo == null) throw new AssertionException("Token is not found.");
        return tokenInfo.IsBurnable;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-52)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1156-1160)
```csharp
        var tokenInfo = GetTokenInfo(symbol);
        if (!tokenInfo.IsBurnable)
        {
            return;
        }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L78-87)
```csharp

    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
```
