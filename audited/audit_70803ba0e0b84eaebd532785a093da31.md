### Title
Division by Zero DoS in Consensus Miner Count Calculation Due to Missing Validation in SetMinerIncreaseInterval

### Summary
The `SetMinerIncreaseInterval()` function lacks validation to prevent setting `State.MinerIncreaseInterval.Value` to zero or negative values. This allows a governance authority to cause a division by zero exception in critical consensus operations (`GetAutoIncreasedMinersCount()` and `GetMinersCount()`), resulting in a complete denial of service of the blockchain's consensus mechanism with no recovery path except contract upgrade.

### Finding Description

The vulnerability exists in the `SetMinerIncreaseInterval()` method which only validates that the new interval is less than or equal to the current value, but does not enforce a minimum positive value: [1](#0-0) 

The check on line 61 allows zero: `Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");`. If the current value is 31536000 (default) and an input of 0 is provided, the assertion passes (0 ≤ 31536000).

This zero value is then used as a divisor in two critical locations:

**Location 1 - GetAutoIncreasedMinersCount():** [2](#0-1) 

Line 94 performs `.Div(State.MinerIncreaseInterval.Value)` which will throw `DivideByZeroException` if the value is 0.

**Location 2 - GetMinersCount():** [3](#0-2) 

Line 390 performs the same division operation.

The `Div()` extension method is a simple wrapper that throws `DivideByZeroException`: [4](#0-3) 

This is confirmed by test expectations: [5](#0-4) 

**Critical Call Paths:**

`GetMinersCount()` is called during consensus operations:
- In `ProcessNextRound()` during first round initialization: [6](#0-5) 

- In `UpdateMinersCountToElectionContract()` during term transitions: [7](#0-6) 

Both are invoked through `NextRound` and `NextTerm` consensus commands, which are essential for blockchain operation.

### Impact Explanation

**Operational Impact - Complete Consensus DoS:**
- Once `MinerIncreaseInterval` is set to 0, any subsequent call to `NextRound` or `NextTerm` will fail with `DivideByZeroException`
- These are mandatory consensus operations that must succeed for the blockchain to produce new blocks and transition between rounds/terms
- The blockchain becomes permanently stuck and cannot progress
- No transactions can be processed, including governance transactions to fix the issue
- Only solution is a hard fork or contract upgrade through validator coordination

**Affected Operations:**
1. Round transitions (NextRound) - executed every round (typically every few minutes)
2. Term transitions (NextTerm) - executed every term (typically every week)
3. Election contract miner count updates - breaks election mechanics
4. View methods like `GetMaximumMinersCount()` - breaks external integrations

**Severity: Critical** - Complete halt of blockchain operation with no self-recovery mechanism.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Control of `MaximumMinersCountController`, which defaults to Parliament's default organization [8](#0-7) 

This requires compromise of the governance system or approval from a majority of Parliament members.

**Attack Complexity:**
- Single governance transaction: `SetMinerIncreaseInterval(0)`
- The validation at line 61 only checks `input.Value <= State.MinerIncreaseInterval.Value`, which passes for zero
- No recovery mechanism exists once set

**Feasibility Conditions:**
- Contract must be initialized (which happens at genesis)
- `BlockchainStartTimestamp` must be set (happens during first round, line 123 of ProcessConsensusInformation.cs)
- Both conditions are always true in production

**Detection:**
- Malicious governance proposal would be visible on-chain
- However, accidental misconfiguration is also possible since the validation doesn't clearly indicate that zero is invalid

**Probability Assessment:**
- Requires trusted governance compromise/error (Medium-Low probability)
- BUT: Missing validation is a clear bug - zero is mathematically invalid for an "interval"
- Test coverage shows the zero case was never validated: [9](#0-8) 

Tests only check `currentValue - 1` and `currentValue + 1`, not zero or negative values.

**Overall Likelihood:** Medium - While governance compromise is required, the missing validation represents a significant oversight that enables catastrophic failure through a single transaction.

### Recommendation

**Immediate Fix:**
Add explicit validation in `SetMinerIncreaseInterval()` to enforce a minimum positive value:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Miner increase interval must be positive.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

**Additional Safeguards:**
1. Add defensive checks in `GetAutoIncreasedMinersCount()` and `GetMinersCount()`:
```csharp
Assert(State.MinerIncreaseInterval.Value > 0, "Invalid miner increase interval configuration.");
```

2. Consider adding a minimum allowed interval constant (e.g., 1 day = 86400 seconds) to prevent unreasonably small values that could cause other issues.

**Test Cases to Add:**
1. Test `SetMinerIncreaseInterval(0)` - should fail
2. Test `SetMinerIncreaseInterval(-1)` - should fail
3. Test consensus operations after setting to minimum valid value - should succeed
4. Test that division operations never receive zero divisor

### Proof of Concept

**Initial State:**
- AEDPoS contract initialized with default `MinerIncreaseInterval = 31536000` (1 year) [10](#0-9) 

- First round completed, `BlockchainStartTimestamp` is set
- Parliament governance is initialized with default organization

**Attack Steps:**

1. Attacker (with Parliament control) creates proposal to call `SetMinerIncreaseInterval(0)`:
```
Input: Int64Value { Value = 0 }
Method: AEDPoSContract.SetMinerIncreaseInterval
```

2. Proposal passes governance approval and is executed:
   - Line 61 check: `0 <= 31536000` → PASSES
   - `State.MinerIncreaseInterval.Value` set to 0
   - Transaction succeeds

3. Next consensus operation (NextRound or NextTerm) is attempted:
   - Calls `GetMinersCount()` or `GetMaximumMinersCount()`
   - Reaches line 94 or 390: `.Div(State.MinerIncreaseInterval.Value)` where value is 0
   - Throws `DivideByZeroException`
   - Transaction fails and reverts

**Expected Result:**
- Consensus operations succeed normally

**Actual Result:**
- All consensus operations fail with `DivideByZeroException`
- Blockchain halts permanently
- No recovery possible through on-chain transactions

**Success Condition:**
The blockchain becomes unable to produce new blocks after the next round/term transition attempt, demonstrating complete consensus DoS.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L31-43)
```csharp
    private void RequiredMaximumMinersCountControllerSet()
    {
        if (State.MaximumMinersCountController.Value != null) return;
        EnsureParliamentContractAddressSet();

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MaximumMinersCountController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L50-51)
```csharp
        Should.Throw<DivideByZeroException>(() => { number1.Div(0); });
        Should.Throw<DivideByZeroException>(() => { number2.Div(0); });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L126-136)
```csharp
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L133-146)
```csharp
        var newMinerIncreaseInterval = minerIncreaseInterval.Value - 1;
        await ParliamentReachAnAgreementAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = newMinerIncreaseInterval
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
        minerIncreaseInterval.Value.ShouldBe(newMinerIncreaseInterval);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L22-31)
```csharp
    public override Empty InitialAElfConsensusContract(InitialAElfConsensusContractInput input)
    {
        Assert(State.CurrentRoundNumber.Value == 0 && !State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        State.PeriodSeconds.Value = input.IsTermStayOne
            ? int.MaxValue
            : input.PeriodSeconds;

        State.MinerIncreaseInterval.Value = input.MinerIncreaseInterval;
```
