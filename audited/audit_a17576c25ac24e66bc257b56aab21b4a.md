### Title
Period Desynchronization Causes RegisterForProfits Denial of Service

### Summary
The `UpdateTokenHolderProfitScheme()` function returns early when `SchemeId` is set and `updateSchemePeriod` is false, preventing Period synchronization with the underlying Profit contract. When the scheme manager calls `DistributeProfits` directly on the Profit contract (bypassing the TokenHolder contract), the TokenHolder's Period becomes stale, causing all subsequent `RegisterForProfits` calls with auto-distribute to fail.

### Finding Description

The vulnerability exists in the `UpdateTokenHolderProfitScheme()` function: [1](#0-0) 

When `scheme.SchemeId != null` and `updateSchemePeriod` is false, the function returns early without fetching the current Period from the Profit contract. Most functions call `GetValidScheme()` with the default `updateSchemePeriod = false`: [2](#0-1) 

The Profit contract allows both the scheme manager and the TokenHolder contract to call `DistributeProfits`: [3](#0-2) 

When the scheme manager calls `DistributeProfits` directly on the Profit contract (not through the TokenHolder wrapper), the Profit contract's `CurrentPeriod` advances, but the TokenHolder's cached Period remains stale. The Profit contract strictly validates that the input period matches its current period: [4](#0-3) 

In `RegisterForProfits`, when auto-distribute is triggered, it uses the stale Period from the TokenHolder scheme: [5](#0-4) 

This causes the Profit contract's assertion to fail when the periods don't match, reverting the entire `RegisterForProfits` transaction: [6](#0-5) 

**Note on Symbol and Thresholds**: These fields are set at scheme creation and are never updated by `UpdateTokenHolderProfitScheme`, so they cannot become stale due to the early return. Only the Period field is affected.

### Impact Explanation

**Operational Impact - Denial of Service**: Users cannot register for profits when auto-distribute is enabled. The `RegisterForProfits` function becomes completely unusable until someone calls `DistributeProfits` through the TokenHolder contract (which passes `updateSchemePeriod = true` to resynchronize).

**Affected Users**: All users attempting to stake tokens in a TokenHolder scheme where:
1. The scheme has auto-distribute thresholds configured
2. The period has become desynchronized
3. The threshold balance has been reached

**Severity Justification**: High severity due to complete operational DoS of the staking/profit registration functionality, which is a core feature of the TokenHolder contract. This prevents users from earning rewards and locks out new participants from the profit-sharing scheme.

### Likelihood Explanation

**Attacker Capabilities**: The scheme manager (who created the TokenHolder scheme) can directly call `DistributeProfits` on the Profit contract. This is explicitly allowed by the Profit contract's access control.

**Attack Complexity**: Low. The scheme manager simply needs to:
1. Call `DistributeProfits` directly on the Profit contract instead of through the TokenHolder contract
2. This can be done intentionally (to cause DoS) or unintentionally (by using a Profit contract interface directly)

**Feasibility Conditions**: 
- Requires the scheme to have been initialized (SchemeId set) through at least one prior operation where `Context.Sender == manager` (e.g., `AddBeneficiary` or `RemoveBeneficiary`)
- The scheme manager must have access to call the Profit contract directly

**Detection/Operational Constraints**: The desynchronization is not easily detectable until `RegisterForProfits` fails. The scheme manager may not realize they've caused this issue if they call the Profit contract directly for legitimate operational reasons.

**Probability**: Medium to High. Scheme managers may use direct Profit contract calls for various reasons (gas optimization, automation scripts, multi-step operations), making unintentional desynchronization likely.

### Recommendation

**Fix 1 - Always Update Period**: Remove the early return optimization or always fetch the Period when it's needed:

```csharp
private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
    bool updateSchemePeriod)
{
    if (scheme.SchemeId == null || updateSchemePeriod)
    {
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[manager] = scheme;  // Also fix: use manager, not Context.Sender
    }
    else
    {
        // Always fetch Period even when not doing full update
        var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
        scheme.Period = originScheme.CurrentPeriod;
    }
}
```

**Fix 2 - Restrict Direct Profit Contract Access**: Modify the Profit contract to only allow the TokenHolder contract (not the scheme manager) to call `DistributeProfits` for TokenHolder-managed schemes. This ensures all distributions go through the TokenHolder contract.

**Fix 3 - Additional Bug Fix**: Line 298 saves to `Context.Sender` instead of `manager`, which should also be corrected: [7](#0-6) 

**Invariant Check**: Add assertion in `RegisterForProfits` before auto-distribute to verify Period synchronization.

**Test Cases**:
1. Test RegisterForProfits after scheme manager calls Profit.DistributeProfits directly
2. Test multiple Period advances through direct Profit contract calls
3. Test recovery by calling TokenHolder.DistributeProfits to resynchronize

### Proof of Concept

**Initial State**:
- Scheme created by manager Alice with auto-distribute threshold enabled
- Profit contract CurrentPeriod = 0
- TokenHolder scheme Period = 0 (synchronized)

**Attack Steps**:
1. Alice calls `AddBeneficiary()` on TokenHolder contract
   - Sets SchemeId on the TokenHolder scheme at the correct key
   - TokenHolder Period = 0

2. Alice calls `DistributeProfits()` through TokenHolder contract
   - Profit contract CurrentPeriod advances to 1
   - TokenHolder Period updates to 1
   - Both synchronized

3. Alice calls `DistributeProfits()` directly on Profit contract (bypassing TokenHolder)
   - Profit contract CurrentPeriod advances to 2
   - TokenHolder Period remains 1 (stale)

4. User Bob attempts `RegisterForProfits()` with sufficient balance to trigger auto-distribute
   - Line 152: `GetValidScheme()` called with `updateSchemePeriod = false`
   - Line 289: Early return because `SchemeId != null` and `!updateSchemePeriod`
   - Line 196: Uses stale Period = 1
   - Line 203: Calls `Profit.DistributeProfits(Period=1)`
   - Profit contract assertion fails: `1 != 2`
   - **Transaction reverts**

**Expected vs Actual**:
- Expected: Bob successfully registers for profits
- Actual: Transaction reverts with "Invalid period" error

**Success Condition**: All `RegisterForProfits` calls fail until someone calls `TokenHolder.DistributeProfits()` (which passes `updateSchemePeriod=true`) to resynchronize the Period.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-152)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L193-196)
```csharp
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L203-203)
```csharp
            State.ProfitContract.DistributeProfits.Send(distributedInput);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-289)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L298-298)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L425-428)
```csharp
        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L478-480)
```csharp
        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```
