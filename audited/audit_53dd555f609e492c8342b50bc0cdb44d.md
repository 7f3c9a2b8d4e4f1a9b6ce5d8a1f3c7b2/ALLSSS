# Audit Report

## Title
NFT Contract Governance Fee Changes Silently Ignored Due to Missing State Management

## Summary
The NFT contract implements the ACS1 transaction fee standard but fails to store fee configurations or controller authority to state. The `SetMethodFee()` and `ChangeMethodFeeController()` methods are non-functional stubs that accept input but discard it without any state mutation, while `GetMethodFee()` returns hard-coded fees (100 ELF for Create method). This creates a critical silent failure mode where governance fee adjustment proposals execute successfully but have zero effect on actual fee enforcement.

## Finding Description

The NFT contract inherits from ACS1 (transaction fee standard) [1](#0-0)  but critically fails to implement the required state storage mechanism.

**Missing State Variables:**

The `NFTContractState` class completely lacks the state mappings required for ACS1 compliance [2](#0-1) . In contrast, proper ACS1 implementations define `MappedState<string, MethodFees> TransactionFees` [3](#0-2)  and `SingletonState<AuthorityInfo> MethodFeeController` [4](#0-3) .

**Non-Functional SetMethodFee:**

The NFT contract's `SetMethodFee()` method immediately returns empty without any state mutation [5](#0-4) . Compare this to proper implementations that validate tokens, check authorization, and persist fees to state [6](#0-5)  and [7](#0-6) .

**Hard-Coded Fee Enforcement:**

The `GetMethodFee()` method returns a hard-coded fee of 100 ELF (100_00000000 in smallest units) for the Create method instead of retrieving stored values [8](#0-7) . Proper implementations retrieve fees from state storage [9](#0-8) .

**Fee Enforcement Path:**

During transaction execution, the fee charging system queries the target contract's `GetMethodFee()` to determine what to charge users [10](#0-9) . The hard-coded return values become the actual enforced fees regardless of governance settings.

**Non-Functional Controller Management:**

Similarly, `ChangeMethodFeeController()` discards controller updates without storing [11](#0-10) , and `GetMethodFeeController()` returns an empty authority structure [12](#0-11) , contrasting with proper implementations that manage controller state [13](#0-12)  and [14](#0-13) .

**Target Method Affected:**

The Create method, which establishes new NFT protocols on the mainchain, is the primary method affected by this fixed fee [15](#0-14) .

## Impact Explanation

**Governance Dysfunction:**
When governance creates proposals to adjust NFT contract fees through standard procedures, the proposals execute successfully but produce no effect. The silent failure mode provides no indication to governance participants that their decisions are being ignored, creating institutional distrust and operational confusion.

**Economic Harm and Availability Risk:**
Users are locked into paying a fixed 100 ELF fee for the Create method that cannot adapt to market conditions. If ELF token appreciates significantly, this fee becomes economically prohibitive (potentially thousands of dollars at realistic token prices), effectively creating a denial-of-service condition for NFT protocol creation functionality. No mechanism exists to adjust fees except a full contract upgrade.

**Interface Contract Violation:**
The contract inherits from ACS1, creating an explicit expectation of fee governance support, but the implementation is non-functional. This violates the principle of interface transparency - external systems and governance participants have no indication that fee changes are impossible without examining the contract's internal implementation.

## Likelihood Explanation

**High Likelihood - Normal Operations:**
Fee adjustments are routine governance activities across all AElf system contracts. The NFT contract appearing to support the ACS1 interface makes governance attempts inevitable as market conditions evolve. This is not an attack scenario but a design flaw affecting normal operations.

**Zero Complexity:**
Any governance actor following standard procedures to adjust fees will encounter this issue. The execution path is straightforward: create proposal → approve → release → call SetMethodFee → observe no effect. The transaction succeeds with no error, no event indicating failure, and no state change that can be queried.

**Economic Inevitability:**
Token price volatility makes fee adjustments economically necessary over the contract's lifetime. Market forces guarantee this issue will manifest as fees become either too expensive (limiting usage) or require adjustment for other economic reasons.

## Recommendation

Implement full ACS1 compliance by adding the required state variables and implementing proper state management:

1. Add to `NFTContractState.cs`:
   - `internal MappedState<string, MethodFees> TransactionFees { get; set; }`
   - `public SingletonState<AuthorityInfo> MethodFeeController { get; set; }`

2. Update `SetMethodFee()` to:
   - Validate input tokens
   - Check authorization against `MethodFeeController`
   - Store fees: `State.TransactionFees[input.MethodName] = input;`

3. Update `GetMethodFee()` to:
   - Retrieve from state: `return State.TransactionFees[input.Value];`
   - Keep Create method's default if not set

4. Update `ChangeMethodFeeController()` to:
   - Validate organization exists
   - Check authorization
   - Store controller: `State.MethodFeeController.Value = input;`

5. Update `GetMethodFeeController()` to:
   - Initialize default controller if not set
   - Return stored value: `return State.MethodFeeController.Value;`

Reference the Parliament contract implementation as a template for the complete pattern.

## Proof of Concept

```csharp
// This test demonstrates the silent failure of SetMethodFee
public async Task SetMethodFee_On_NFTContract_SilentlyFails()
{
    // 1. Get current fee for Create method
    var initialFee = await NFTContractStub.GetMethodFee.CallAsync(
        new StringValue { Value = "Create" });
    Assert.Equal(100_00000000, initialFee.Fees[0].BasicFee);
    
    // 2. Attempt to change fee via governance proposal
    var newFee = new MethodFees
    {
        MethodName = "Create",
        Fees = { new MethodFee { Symbol = "ELF", BasicFee = 1_00000000 } }
    };
    
    // Execute through Parliament governance
    var proposalId = await CreateAndApproveProposal(
        NFTContractAddress,
        "SetMethodFee",
        newFee
    );
    await ParliamentContractStub.Release.SendAsync(proposalId);
    
    // 3. Verify fee was NOT changed (silent failure)
    var actualFee = await NFTContractStub.GetMethodFee.CallAsync(
        new StringValue { Value = "Create" });
    Assert.Equal(100_00000000, actualFee.Fees[0].BasicFee); // Still 100 ELF!
    
    // 4. Users continue paying the old hard-coded fee
    var result = await NFTContractStub.Create.SendAsync(createInput);
    // Transaction charged 100 ELF, not the governance-approved 1 ELF
}
```

## Notes

This vulnerability is particularly insidious due to its silent failure mode. Unlike access control violations that revert with errors, these methods accept input and return success, providing false confirmation to governance that their decisions were implemented. The contract's inheritance from ACS1 creates an explicit interface contract that the implementation fails to honor, making this a clear protocol invariant violation rather than a design choice.

### Citations

**File:** protobuf/nft_contract.proto (L20-20)
```text
    option (aelf.base) = "acs1.proto";
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L6-46)
```csharp
public partial class NFTContractState : ContractState
{
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState_ChargeFee.cs (L10-10)
```csharp
    internal MappedState<string, MethodFees> TransactionFees { get; set; }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentState.cs (L23-26)
```csharp
    public MappedState<string, MethodFees> TransactionFees { get; set; }

    public SingletonState<ProposerWhiteList> ProposerWhiteList { get; set; }
    public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-11)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L13-16)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L39-42)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        return new AuthorityInfo();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L46-50)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L37-52)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (new List<string>
            {
                nameof(ClaimTransactionFees), nameof(DonateResourceToken), nameof(ChargeTransactionFees),
                nameof(CheckThreshold), nameof(CheckResourceToken), nameof(ChargeResourceToken),
                nameof(CrossChainReceiveToken)
            }.Contains(input.Value))
            return new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
        var fees = State.TransactionFees[input.Value];
        return fees;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-39)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-73)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);

        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;

        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
            ProtocolName = tokenCreateInput.TokenName,
            IsTokenIdReuse = input.IsTokenIdReuse,
            IssueChainId = tokenCreateInput.IssueChainId,
            IsBurnable = tokenCreateInput.IsBurnable,
            NftType = input.NftType
        };
        State.NftProtocolMap[symbol] = protocolInfo;

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = tokenCreateInput.Symbol,
            Creator = tokenCreateInput.Issuer,
            IsBurnable = tokenCreateInput.IsBurnable,
            IssueChainId = tokenCreateInput.IssueChainId,
            ProtocolName = tokenCreateInput.TokenName,
            TotalSupply = tokenCreateInput.TotalSupply,
            Metadata = protocolInfo.Metadata,
            BaseUri = protocolInfo.BaseUri,
            IsTokenIdReuse = protocolInfo.IsTokenIdReuse,
            NftType = protocolInfo.NftType
        });

        return new StringValue
        {
            Value = symbol
        };
    }
```
