### Title
Single-Block Method Fee DOS Attack via Temporary Controller Bypass

### Summary
A compromised method fee controller (Parliament organization) can execute a multi-step attack entirely within a single block by temporarily transferring control to an attacker-controlled Association organization, setting astronomical method fees to DOS the chain, and then restoring the original controller to hide the attack. The lack of upper bounds on method fees combined with Association's instant governance mechanism enables this stealth DOS vector.

### Finding Description

The vulnerability exists in the method fee controller change mechanism in `BasicContractZeroContract_ACS1_TransactionFeeProvider.cs`: [1](#0-0) [2](#0-1) 

**Root Cause 1: No Time Lock on Controller Changes**
The `ChangeMethodFeeController` function allows immediate controller changes once authorized, with no delay or cooling-off period. The only validation is that the new organization exists: [3](#0-2) [4](#0-3) 

**Root Cause 2: No Upper Bound on Method Fees**
The `SetMethodFee` function only validates that fees are non-negative, with no upper bound check: [5](#0-4) 

**Root Cause 3: Association Instant Governance**
Association organizations support immediate proposal execution in the same block. If an Association has a single member with minimal threshold, that member can create, approve, and release proposals instantly: [6](#0-5) 

**Attack Execution Path:**

1. **Preparation Phase (Multi-block):**
   - Attacker compromises Parliament organization (gains majority control)
   - Attacker creates Association organization with only their address as member and threshold of 1
   - Attacker creates Parliament proposal to change Genesis controller to their Association
   - Parliament members approve the proposal

2. **Attack Phase (Single Block):**
   - **Tx1:** Attacker releases Parliament proposal → `MethodFeeController` changes to attacker's Association
   - **Tx2:** Attacker creates Association proposal to set astronomical fees (e.g., Int64.MaxValue)
   - **Tx3:** Attacker approves Association proposal (as sole member)
   - **Tx4:** Attacker releases Association proposal → Astronomical fees are set on all methods
   - **Tx5:** Attacker creates Association proposal to restore Parliament as controller
   - **Tx6:** Attacker approves Association proposal
   - **Tx7:** Attacker releases Association proposal → Controller restored to Parliament

The fee charging logic confirms astronomical fees cause transaction failures: [7](#0-6) 

When users lack sufficient balance for astronomical fees, `ChargeFirstSufficientToken` returns false, causing transaction execution to fail.

### Impact Explanation

**Complete Chain DOS:**
Setting astronomical method fees (e.g., `Int64.MaxValue` = 9,223,372,036,854,775,807) on critical methods makes them uncallable by any user, as no one holds sufficient token balance. This affects:
- All contract method calls requiring fees
- Token transfers, staking, governance voting
- Cross-chain operations, consensus participation
- Economic system operations

**Stealth and Persistence:**
By restoring the original controller in the same block, the attack leaves minimal trace. Off-chain observers would see:
- Controller temporarily changed and restored (block N)
- Method fees suddenly astronomical (block N)
- No obvious malicious actor (controller appears legitimate)

The DOS persists until a new governance proposal successfully changes fees back, which could take days or weeks depending on governance velocity.

**Affected Parties:**
- All chain users unable to execute transactions
- DApps unable to function
- Cross-chain operations frozen
- Block producers unable to process user transactions

**Severity Justification:** CRITICAL - Complete operational shutdown of the blockchain with difficult recovery requiring emergency governance intervention.

### Likelihood Explanation

**Attacker Capabilities:**
The attack requires the attacker to first compromise the Parliament organization (default method fee controller). While this is a high bar, it is the explicit threat model stated in the question ("compromised controller"). Once Parliament is compromised:
- Creating an Association organization is permissionless
- All subsequent steps are standard contract calls

**Attack Complexity:**
Once Parliament is compromised, the attack is straightforward:
- 7 transactions in a single block
- No complex timing or race conditions
- No need for sophisticated exploits

**Feasibility Conditions:**
- Parliament organization must be compromised (given as precondition)
- Attacker must be able to submit 7 transactions in same block (standard capability)
- No emergency stop mechanism exists to prevent this
- Tests confirm controller can be changed to Association organizations: [8](#0-7) 

**Detection/Operational Constraints:**
The attack happens in a single block, making real-time detection and intervention impossible. By the time the block is finalized, the DOS is complete and controller is restored.

**Probability:** HIGH - If Parliament is compromised (given threat model), this attack is trivial to execute and highly impactful, making it an attractive vector for malicious actors.

### Recommendation

**1. Implement Time Lock for Controller Changes:**
```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    // Add time lock
    var currentTime = Context.CurrentBlockTime;
    var lastChangeTime = State.LastControllerChangeTime.Value;
    Assert(lastChangeTime == null || 
           (currentTime - lastChangeTime).Seconds >= MinimalControllerChangeInterval,
           "Controller change too frequent.");
    
    State.MethodFeeController.Value = input;
    State.LastControllerChangeTime.Value = currentTime;
    return new Empty();
}
```

Add state variable: `SingletonState<Timestamp> LastControllerChangeTime`

Set `MinimalControllerChangeInterval` to at least 24-48 hours.

**2. Implement Upper Bounds on Method Fees:**
```csharp
private void AssertValidToken(string symbol, long amount)
{
    Assert(amount >= 0, "Invalid amount.");
    Assert(amount <= MaximumMethodFee, "Fee amount exceeds maximum allowed.");
    
    if (State.TokenContract.Value == null)
        State.TokenContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

    Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
        $"Token {symbol} cannot set as method fee.");
}
```

Define `MaximumMethodFee` as a reasonable upper bound (e.g., 1,000,000 tokens or configurable via governance).

**3. Add Emergency Fee Reset Mechanism:**
Implement a special emergency organization (high threshold, multiple miners required) that can reset fees to default values without normal governance delay.

**4. Add Test Cases:**
- Test rapid controller changes blocked by time lock
- Test astronomical fee values rejected
- Test emergency fee reset functionality
- Test Association-based controller change attack scenario

### Proof of Concept

**Initial State:**
- MethodFeeController = Parliament Default Organization
- Current method fees = reasonable values (e.g., 0.1 ELF)

**Attack Sequence:**

**Setup (Multi-block):**
1. Attacker compromises Parliament (controls 51%+ of miner votes)
2. Create Association: `AssociationContract.CreateOrganization({OrganizationMemberList: [AttackerAddress], ProposalReleaseThreshold: {MinimalApprovalThreshold: 1, MinimalVoteThreshold: 1}})`
   → Returns `AttackerAssociationAddress`
3. Create Parliament Proposal: `ParliamentContract.CreateProposal({ToAddress: GenesisContract, MethodName: "ChangeMethodFeeController", Params: {OwnerAddress: AttackerAssociationAddress, ContractAddress: AssociationContract}})`
   → Returns `ProposalId1`
4. Parliament miners approve: `ParliamentContract.Approve(ProposalId1)` (x N miners)

**Attack Execution (Block N - Single Block):**

**Tx1:** `ParliamentContract.Release(ProposalId1)`
- Expected: Success, controller changed to AttackerAssociationAddress

**Tx2:** `AssociationContract.CreateProposal({ToAddress: GenesisContract, MethodName: "SetMethodFee", Params: {MethodName: "Transfer", Fees: [{Symbol: "ELF", BasicFee: 9223372036854775807}]}})`
- Expected: Success, returns `ProposalId2`

**Tx3:** `AssociationContract.Approve(ProposalId2)`
- Expected: Success

**Tx4:** `AssociationContract.Release(ProposalId2)`
- Expected: Success, Transfer fee now astronomical

**Tx5:** `AssociationContract.CreateProposal({ToAddress: GenesisContract, MethodName: "ChangeMethodFeeController", Params: {OwnerAddress: ParliamentDefaultOrg, ContractAddress: ParliamentContract}})`
- Expected: Success, returns `ProposalId3`

**Tx6:** `AssociationContract.Approve(ProposalId3)`
- Expected: Success

**Tx7:** `AssociationContract.Release(ProposalId3)`
- Expected: Success, controller restored to Parliament

**Post-Attack State:**
- MethodFeeController = Parliament Default Organization (restored)
- Transfer method fee = 9,223,372,036,854,775,807 ELF (astronomical)
- Any user attempting `TokenContract.Transfer()` fails with "Transaction fee not enough"
- Chain effectively DOS'd for all Transfer operations

**Success Condition:** All 7 transactions succeed in block N, method fees are astronomical, and controller appears legitimate (Parliament), making the attack difficult to trace.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L9-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-200)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L704-745)
```csharp
    private bool ChargeFirstSufficientToken(Dictionary<string, long> symbolToAmountMap, Address fromAddress,
        out string symbol, out long amount, out long existingBalance, out long existingAllowance,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, TransactionFeeDelegations delegations = null)
    {
        symbol = null;
        amount = 0L;
        existingBalance = 0L;
        existingAllowance = 0L;
        bool chargeResult;

        if (delegations != null)
        {
            //from address -> delegatee
            chargeResult = TryToChargeDelegateBaseFee(symbolToAmountMap, fromAddress, transactionFeeFreeAllowancesMap,
                delegations, out amount, out symbol, out existingBalance, out existingAllowance);
            return chargeResult;
        }

        chargeResult = TryToChargeUserBaseFee(symbolToAmountMap, fromAddress, transactionFeeFreeAllowancesMap,
            out amount, out symbol, out existingBalance, out existingAllowance);

        if (symbol != null)
        {
            existingBalance = GetBalance(fromAddress, symbol);
            existingAllowance = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbol);
            amount = symbolToAmountMap[symbol];
        }

        //For user, if charge failed and delegation is null, priority charge primary token
        if (!chargeResult)
        {
            var primaryTokenSymbol = GetPrimaryTokenSymbol(new Empty()).Value;
            if (symbolToAmountMap.ContainsKey(primaryTokenSymbol))
            {
                symbol = primaryTokenSymbol;
                existingBalance = GetBalance(fromAddress, symbol);
                existingAllowance = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbol);
            }
        }

        return chargeResult;
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L1273-1300)
```csharp
    public async Task ChangeMethodFeeControllerByAssociation_Test()
    {
        var createOrganizationResult = await Tester.ExecuteContractWithMiningAsync(AssociationContractAddress,
            nameof(AssociationContractImplContainer.AssociationContractImplStub.CreateOrganization),
            new Association.CreateOrganizationInput
            {
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1,
                    MinimalVoteThreshold = 1
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { AnotherMinerAddress }
                },
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { AnotherMinerAddress }
                }
            });

        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.ReturnValue);

        var methodFeeController = await GetMethodFeeController(Tester, BasicContractZeroAddress);
        const string proposalCreationMethodName =
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ChangeMethodFeeController);
        var proposalId = await CreateProposalAsync(Tester, methodFeeController.ContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName,
```
