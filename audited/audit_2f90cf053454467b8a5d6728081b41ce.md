# Audit Report

## Title
Retroactive Vote Invalidation via Strategic Member Removal in Association Governance

## Summary
The Association contract's vote counting mechanism filters votes against the current organization member list, allowing votes from previously removed members to be retroactively invalidated. This enables manipulation of governance outcomes by removing members after they vote, causing their votes to no longer count toward threshold calculations.

## Finding Description

The vulnerability exists in the temporal inconsistency between vote casting and vote counting in the Association contract.

When members vote on a proposal, their addresses are stored in the proposal's vote lists. [1](#0-0)  The voting methods validate current membership when the vote is cast. [2](#0-1) 

However, when checking if a proposal can be released, the vote counting logic filters votes against the **current** organization member list rather than preserving the validity of votes cast when the voter was a member. [3](#0-2) 

Specifically, the vote counting uses `.Count(organization.OrganizationMemberList.Contains)` which only counts votes from addresses that are **currently** members:
- Rejection counting: [4](#0-3) 
- Abstention counting: [5](#0-4) 
- Approval counting: [6](#0-5) 

The `Contains()` method simply checks current membership without any historical validation. [7](#0-6) 

The `RemoveMember` method can be called through the organization's proposal mechanism. [8](#0-7)  When a proposal is released, the organization's virtual address becomes `Context.Sender`, allowing member management actions to be executed through governance. [9](#0-8) 

**Root Cause**: Vote lists store only addresses without timestamps or membership snapshots. [10](#0-9)  This allows the vote counting logic to retroactively filter out votes from members who were valid at voting time but were subsequently removed.

**Why Existing Protections Fail**: While `AssertIsAuthorizedOrganizationMember` validates membership when voting, [11](#0-10)  there is no mechanism to preserve vote validity after a member is removed. The validation at vote-counting time re-checks membership, creating the temporal vulnerability.

## Impact Explanation

**Concrete Harm**:
- **Governance Manipulation**: Attackers can block legitimate proposals by removing members who approved them, causing approval counts to fall below thresholds
- **Vote Invalidation**: Members who voted in good faith have their votes retroactively nullified without their consent
- **Proposal Blocking**: Proposals that met release thresholds can be prevented from execution by strategically removing approvers
- **Proposal Forcing**: Malicious proposals can be pushed through by removing members who rejected them

**Attack Scenario**:
1. Organization has 5 members with threshold requiring 3 approvals
2. Proposal P1 receives 3 approvals from members A, B, C (meets threshold at approval time)
3. Attacker creates Proposal P2 to call `RemoveMember` for member A
4. Proposal P2 passes with votes from B, C, and others
5. P2 executes through `Release`, removing A from the organization member list
6. When P1's release is attempted, `IsReleaseThresholdReached` recounts votes using current membership
7. Only 2 approvals count (B and C) because A is no longer in `organization.OrganizationMemberList`
8. P1 can no longer be released despite having met requirements when voted

**Who Is Affected**: All Association-based organizations using the governance mechanism, including multi-signature wallets and DAOs built on this contract.

**Severity Justification**: HIGH - This directly undermines the integrity of the governance system, allowing manipulation of proposal outcomes through retroactive vote invalidation. It violates the fundamental invariant that validly cast votes should maintain their validity unless explicitly changed through proper governance reconsideration processes.

## Likelihood Explanation

**Attacker Capabilities**: Only requires ability to create proposals and coordinate votes - standard governance participation. No special privileges beyond being an authorized proposer and having sufficient member support.

**Attack Complexity**: Medium - Requires:
1. Creating a member removal proposal concurrent with or after the target proposal
2. Coordinating sufficient votes to pass the removal proposal
3. Executing the removal before the target proposal is released

**Feasibility Conditions**:
- Multiple active proposals can exist simultaneously (verified in code - proposals are identified by hash, allowing concurrent existence)
- `RemoveMember` is a standard governance action callable via proposals through the `Release` mechanism
- No time locks or delays prevent immediate removal
- Vote recounting happens on every `GetProposal` call and during `Release` execution

**Detection Constraints**: Difficult to detect as member management is a legitimate governance function. The attack leaves no obvious trace distinguishing it from normal organizational restructuring.

**Economic Rationality**: Transaction cost is comparable to any governance action (gas fees + coordination effort). The benefit is control over high-value proposals (treasury transfers, permission changes, contract upgrades, etc.).

**Probability**: HIGH - The attack vector is straightforward, requires no special setup beyond normal governance participation, and can be executed through standard contract operations.

## Recommendation

Implement one of the following fixes:

**Option 1: Snapshot Membership at Vote Time**
Store a membership snapshot with each vote, so vote validity is determined by membership at the time of voting rather than at counting time. Modify the ProposalInfo structure to include vote validation data.

**Option 2: Lock Member Removal During Active Votes**
Prevent member removal if the member has active votes on pending proposals. Check all active proposals before allowing `RemoveMember` to execute.

**Option 3: Immutable Vote Counts**
Store vote counts as integers that are incremented at vote time and never recalculated based on current membership. This preserves the historical validity of votes.

**Recommended Solution (Option 3 - Simplest and Most Secure):**
Modify vote counting to use integer counters instead of filtering address lists. Store approval/rejection/abstention counts as integers that are incremented when votes are cast and used directly for threshold comparisons without rechecking membership.

## Proof of Concept

```csharp
[Fact]
public async Task Test_RetroactiveVoteInvalidation_Vulnerability()
{
    // Setup: Create organization with 5 members, requiring 3 approvals
    var members = new[] { Reviewer1, Reviewer2, Reviewer3, DefaultSender, Accounts[4].Address };
    var organizationAddress = await CreateOrganizationAsync(members, minimalApprovalThreshold: 3);
    
    // Step 1: Create Proposal P1 (target proposal)
    var p1Id = await CreateProposalAsync(organizationAddress, Reviewer1KeyPair);
    
    // Step 2: Members A, B, C approve P1 (meets threshold)
    await ApproveProposalAsync(p1Id, Reviewer1KeyPair); // Member A
    await ApproveProposalAsync(p1Id, Reviewer2KeyPair); // Member B  
    await ApproveProposalAsync(p1Id, Reviewer3KeyPair); // Member C
    
    // Verify P1 can be released (3 approvals meets threshold)
    var p1Status = await GetProposalAsync(p1Id);
    p1Status.ToBeReleased.ShouldBeTrue(); // This passes
    
    // Step 3: Create Proposal P2 to remove Member A
    var removeMemberInput = Reviewer1; // Remove member A who approved P1
    var p2Id = await CreateRemoveMemberProposalAsync(organizationAddress, removeMemberInput);
    
    // Step 4: P2 gets approved and released
    await ApproveProposalAsync(p2Id, Reviewer2KeyPair);
    await ApproveProposalAsync(p2Id, Reviewer3KeyPair);
    await ApproveProposalAsync(p2Id, DefaultSenderKeyPair);
    await ReleaseProposalAsync(p2Id, Reviewer1KeyPair);
    
    // Step 5: Verify Member A has been removed
    var org = await GetOrganizationAsync(organizationAddress);
    org.OrganizationMemberList.OrganizationMembers.Contains(Reviewer1).ShouldBeFalse();
    
    // Step 6: VULNERABILITY - P1's approval count drops to 2 (only B and C count now)
    p1Status = await GetProposalAsync(p1Id);
    p1Status.ToBeReleased.ShouldBeFalse(); // P1 can no longer be released!
    p1Status.ApprovalCount.ShouldBe(3); // Still 3 addresses in approval list
    // But only 2 count toward threshold because A is no longer a member
    
    // This demonstrates retroactive vote invalidation
}
```

This test demonstrates that a proposal which met its release threshold can be blocked by removing an approver after they voted, even though their vote was valid when cast.

### Citations

**File:** protobuf/association_contract.proto (L76-103)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-59)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }

    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }

    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```
