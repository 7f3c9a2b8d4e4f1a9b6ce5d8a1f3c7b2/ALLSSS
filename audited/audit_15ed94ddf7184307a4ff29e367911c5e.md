# Audit Report

## Title
Referendum Organization Self-Modification Deadlock via Unreachable Thresholds and Inaccessible Whitelists

## Summary
The Referendum contract allows organizations to modify their own voting thresholds and proposer whitelists through proposals, but the validation logic does not verify that thresholds are achievable relative to token supply or that whitelist addresses are accessible. Once an organization sets impossible-to-meet thresholds or a whitelist containing only inaccessible addresses, it permanently loses governance capability with no recovery mechanism.

## Finding Description

The vulnerability exists in two organization self-modification functions that lack sufficient validation:

**1. ChangeOrganizationThreshold** allows threshold modification when called by the organization address itself (via released proposal): [1](#0-0) 

**2. ChangeOrganizationProposerWhiteList** allows whitelist modification under the same conditions: [2](#0-1) 

When a proposal is released, it executes via the virtual address mechanism, setting `Context.Sender` to the organization address: [3](#0-2) 

The virtual address is converted to the organization address as the transaction sender: [4](#0-3) 

**Root Cause: Insufficient Validation**

The `Validate` function performs inadequate checks: [5](#0-4) 

This validation only ensures:
- Token symbol exists
- ProposerWhiteList is not empty (count > 0)
- `MinimalApprovalThreshold <= MinimalVoteThreshold`
- `MinimalApprovalThreshold > 0`
- Thresholds are non-negative

**Critical Missing Validations:**

1. **No Token Supply Feasibility Check**: The validation does not compare `MinimalVoteThreshold` or `MinimalApprovalThreshold` against the token's total or circulating supply. An organization could set `MinimalVoteThreshold = 10^18` for a token with only 10^6 total supply.

2. **No Whitelist Accessibility Check**: The validation only checks that the whitelist count is greater than zero via the `Empty()` helper: [6](#0-5) 

It does not verify whether addresses have known private keys, are burn addresses, or belong to cooperative parties.

3. **Proposal Creation Requires Whitelisted Addresses**: Only whitelisted proposers can create proposals: [7](#0-6) 

4. **Proposal Release Requires Meeting Thresholds**: The `IsReleaseThresholdReached` function checks if vote counts meet the configured thresholds: [8](#0-7) 

If `MinimalVoteThreshold` exceeds the token supply, this condition can never be satisfied.

**No Recovery Mechanism**: Unlike Parliament contract which has emergency response organizations, the Referendum contract provides no admin override, emergency function, or time-based reset capability. The only way to modify organization parameters is through the organization's own proposal process, creating an unbreakable deadlock when thresholds become unreachable.

**Attack Execution Path:**
1. Whitelisted proposer creates proposal calling `ChangeOrganizationThreshold` with unreachable thresholds (e.g., `MinimalVoteThreshold = 10^18` when token supply = 10^6)
2. Proposal gets approved under current (valid) thresholds
3. Proposer calls `Release()` which verifies thresholds using OLD values
4. Release executes via `SendVirtualInlineBySystemContract` with organization address as sender
5. New thresholds are set and pass validation (no supply check performed)
6. All future proposals now require 10^18 votes but only 10^6 tokens exist
7. No proposal can ever reach `MinimalVoteThreshold`
8. Organization is permanently deadlocked

The same attack works for whitelists: setting a whitelist containing only inaccessible addresses (burn addresses, lost keys) prevents any future proposals from being created.

## Impact Explanation

**High Severity - Permanent Governance DoS**

The impact is severe because:

1. **Complete Loss of Function**: The affected organization loses 100% of governance capability permanently. No proposals can be created (if whitelist is inaccessible) or released (if thresholds are unreachable).

2. **Irreversible**: No recovery mechanism exists. The deadlock is permanent.

3. **Asset Freeze**: Any funds, permissions, or authority controlled by the organization become permanently inaccessible. If the organization manages protocol parameters, token minting rights, or treasury funds, these become frozen.

4. **Broad Impact**: Affects all stakeholders:
   - Token holders lose governance participation rights
   - Contracts depending on the organization for configuration updates fail
   - Services managed by the organization become unmaintainable

5. **Cascade Effects**: If the deadlocked organization manages critical system parameters (cross-chain indexing, consensus configuration, fee schedules), the entire protocol could be impacted.

The severity is high rather than critical because the impact is scoped to the specific organization, not the entire protocol. However, for organizations managing critical infrastructure, the impact approaches critical severity.

## Likelihood Explanation

**Medium to High Likelihood**

The likelihood is elevated due to multiple realistic trigger scenarios:

**1. Accidental Misconfiguration (High Probability)**:
- Legitimate operators could easily make typos when entering threshold values
- Adding extra zeros: intending 1,000,000 but entering 1,000,000,000
- Confusion about token decimals
- Copy-paste errors from different token contexts
- No warnings or safeguards during proposal creation
- Token holders may not carefully review technical threshold parameters in proposals

**2. Malicious Attack (Medium Probability)**:
- Requires attacker to be in proposer whitelist (moderate barrier)
- Must convince token holders to approve the malicious proposal (requires social engineering or obfuscation)
- However, thresholds can be hidden in complex multi-call proposals
- Disgruntled organization members with whitelist access could exploit during governance disputes

**3. Low Attack Complexity**:
- Only requires one successful proposal to pass
- No need for complex contract interactions or timing exploits
- Attack is deterministic once proposal is released

**4. No Detection Before Execution**:
- Current validation provides no warnings about unrealistic thresholds
- Token holders cannot easily verify threshold feasibility during voting
- No simulation or dry-run capability to detect the issue

**5. Realistic Preconditions**:
- Requires only normal organization operation
- No need for unusual chain state or timing conditions
- Works on any Referendum organization

The combination of high accidental probability and permanent impact makes this a significant vulnerability requiring immediate mitigation.

## Recommendation

Implement comprehensive validation in the `Validate` function:

**1. Add Token Supply Validation:**
```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    
    var tokenInfo = GetTokenInfo(organization.TokenSymbol);
    Assert(!string.IsNullOrEmpty(tokenInfo.Symbol), "Token not exists.");
    
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    
    // NEW: Validate thresholds against token supply
    Assert(proposalReleaseThreshold.MinimalVoteThreshold <= tokenInfo.Supply, 
        "MinimalVoteThreshold exceeds token supply.");
    Assert(proposalReleaseThreshold.MinimalApprovalThreshold <= tokenInfo.Supply, 
        "MinimalApprovalThreshold exceeds token supply.");
    
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

**2. Add Reasonable Threshold Bounds:**
Consider adding maximum reasonable thresholds (e.g., 80% of supply) to prevent even theoretically achievable but practically impossible thresholds.

**3. Implement Emergency Recovery Mechanism:**
Add an emergency response organization pattern similar to Parliament contract, allowing a super-majority to override deadlocked organizations.

**4. Add Whitelist Validation:**
Consider requiring whitelists to contain a minimum number of addresses and/or implementing a time-lock before whitelist changes take effect, allowing detection and correction of mistakes.

**5. Add Proposal Simulation/Validation:**
Implement view functions that allow token holders to simulate proposal effects before voting, including threshold feasibility checks.

## Proof of Concept

```csharp
[Fact]
public async Task OrganizationDeadlock_UnreachableThreshold_Test()
{
    // Create organization with valid thresholds
    var tokenSymbol = "TEST";
    await CreateAndIssueToken(tokenSymbol, 1_000_000); // Total supply: 1M
    
    var organizationAddress = await CreateOrganizationAsync(
        minimalApprovalThreshold: 1000,
        minimalVoteThreshold: 2000,
        maximalAbstentionThreshold: 500,
        maximalRejectionThreshold: 500,
        new[] { DefaultSender },
        tokenSymbol: tokenSymbol);
    
    // Create proposal to set impossible threshold (1B when supply is 1M)
    var impossibleThreshold = new ProposalReleaseThreshold
    {
        MinimalApprovalThreshold = 1_000_000_000,
        MinimalVoteThreshold = 1_000_000_000,
        MaximalAbstentionThreshold = 0,
        MaximalRejectionThreshold = 0
    };
    
    var proposalId = await CreateProposalAsync(organizationAddress, 
        nameof(ReferendumContractStub.ChangeOrganizationThreshold),
        impossibleThreshold);
    
    // Approve and release under current valid thresholds
    await ApproveWithTokenAsync(proposalId, tokenSymbol, 2000);
    await ReferendumContractStub.Release.SendAsync(proposalId);
    
    // Verify new impossible thresholds are set
    var org = await ReferendumContractStub.GetOrganization.CallAsync(organizationAddress);
    org.ProposalReleaseThreshold.MinimalVoteThreshold.ShouldBe(1_000_000_000);
    
    // Try to create and release a corrective proposal - IT WILL FAIL
    var correctiveProposalId = await CreateProposalAsync(organizationAddress,
        nameof(ReferendumContractStub.ChangeOrganizationThreshold),
        new ProposalReleaseThreshold { MinimalApprovalThreshold = 1000, MinimalVoteThreshold = 2000 });
    
    // Even with all tokens voting, cannot meet 1B threshold (only 1M exist)
    await ApproveWithTokenAsync(correctiveProposalId, tokenSymbol, 1_000_000);
    
    // Release fails - threshold not reached
    var releaseResult = await ReferendumContractStub.Release.SendWithExceptionAsync(correctiveProposalId);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
    
    // Organization is permanently deadlocked
}
```

## Notes

This vulnerability affects all Referendum organizations and represents a design flaw rather than an implementation bug. The lack of supply-relative validation is a fundamental oversight that enables permanent governance deadlock. The high likelihood of accidental triggering (through simple typos) combined with the permanent, irreversible impact makes this a critical governance security issue requiring immediate remediation.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-137)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L266-276)
```csharp
    public void SendVirtualInlineBySystemContract(Hash fromVirtualAddress, Address toAddress, string methodName,
        ByteString args)
    {
        TransactionContext.Trace.InlineTransactions.Add(new Transaction
        {
            From = ConvertVirtualAddressToContractAddressWithContractHashName(fromVirtualAddress, Self),
            To = toAddress,
            MethodName = methodName,
            Params = args
        });
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L13-16)
```csharp
    public static bool Empty(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Count() == 0;
    }
```
