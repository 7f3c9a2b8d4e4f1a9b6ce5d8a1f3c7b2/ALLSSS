### Title
Division by Zero DoS in SetMinerIncreaseInterval Allows Complete Consensus Failure

### Summary
The `SetMinerIncreaseInterval()` function lacks validation to prevent setting `MinerIncreaseInterval` to zero or negative values. Since the interval is used as a divisor in critical consensus calculations, setting it to zero causes a `DivideByZeroException` that breaks all round transitions, term changes, and miners count updates, resulting in a complete consensus denial-of-service.

### Finding Description

The vulnerability exists in `SetMinerIncreaseInterval()` which only validates that the new interval value is less than or equal to the current value, but fails to enforce a minimum positive value. [1](#0-0) 

The problematic check at line 61 only prevents increases but allows zero or negative values. The `MinerIncreaseInterval` is then used as a divisor in two critical locations:

1. In `GetAutoIncreasedMinersCount()`: [2](#0-1) 

2. In `GetMinersCount()`: [3](#0-2) 

The `Div()` method performs standard division without zero-checking: [4](#0-3) 

Test suite confirms division by zero throws `DivideByZeroException`: [5](#0-4) 

These calculation functions are called during critical consensus operations:
- First round transition: [6](#0-5) 
- Every term transition: [7](#0-6) 
- Maximum miners count updates: [8](#0-7) 

### Impact Explanation

**Complete Consensus Denial of Service**: Once `MinerIncreaseInterval` is set to zero, all consensus operations that calculate miners count will fail with `DivideByZeroException`. This includes:

1. **Round transitions fail**: The blockchain cannot move from round 1 to round 2, as `ProcessNextRound` calls `GetMinersCount()` to update the Election Contract
2. **Term transitions fail**: Every term change requires `GetMinersCount()` calculation, preventing the blockchain from advancing terms
3. **Miners count updates fail**: Any attempt to update maximum miners count will fail
4. **View method failures**: `GetMaximumMinersCount()` queries will fail

The blockchain becomes completely stuck, unable to produce blocks beyond the initial round. No recovery is possible without contract upgrade or hard fork, as the interval can only be decreased (never increased) per the existing validation logic.

**Affected parties**: All network participants - miners cannot produce blocks, users cannot submit transactions, and the entire blockchain halts.

### Likelihood Explanation

**Attack Requirements**:
- Attacker must control the `MaximumMinersCountController`, which defaults to Parliament's default organization
- Requires creating and passing a governance proposal
- One simple transaction: `SetMinerIncreaseInterval(0)`

**Feasibility**: HIGH
- Parliament governance is the intended control mechanism, but is vulnerable to:
  - Malicious governance takeover (if voting power is concentrated)
  - Accidental misconfiguration (human error in proposal parameters)
  - No validation prevents honest mistakes
- The attack is irreversible due to the decrease-only constraint
- No gas cost barrier (standard governance transaction)

**Detection**: The attack would be immediately obvious as all consensus operations fail, but by then the damage is done and the blockchain is halted.

**Probability**: Medium-to-High depending on governance security, but the impact severity (complete DoS) makes this a critical vulnerability regardless.

### Recommendation

Add minimum value validation in `SetMinerIncreaseInterval()`:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Miner increase interval must be positive.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

Additionally, consider:
1. **Add upper bound check**: Prevent setting interval too low (e.g., minimum 1 day or configurable lower bound)
2. **Allow interval increases**: Remove or relax the decrease-only constraint to allow recovery from misconfiguration
3. **Add test case**: Test that setting interval to 0 or negative values is properly rejected
4. **Add integration test**: Verify that miners count calculations work correctly after interval changes

### Proof of Concept

**Initial State**:
- Blockchain initialized with `MinerIncreaseInterval = 31536000` (1 year)
- Parliament governance operational

**Attack Steps**:
1. Attacker (or honest user making mistake) creates Parliament proposal:
   - Target: `AEDPoSContract.SetMinerIncreaseInterval`
   - Parameter: `Int64Value { Value = 0 }`
2. Proposal passes through Parliament voting
3. Proposal is released and executed
4. `State.MinerIncreaseInterval.Value` is now 0

**Result**:
- Next call to `ProcessNextRound` (round 1 → 2 transition) executes:
  - Line 128: `GetMinersCount(nextRound)` is called
  - Line 390: `.Div(State.MinerIncreaseInterval.Value)` → `.Div(0)`
  - Throws `DivideByZeroException`
  - Transaction fails, round transition blocked
- All subsequent consensus operations fail
- Blockchain halts permanently

**Expected behavior**: Transaction should be rejected with "Miner increase interval must be positive."

**Actual behavior**: Transaction succeeds, blockchain enters unrecoverable DoS state.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L20-28)
```csharp
        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L50-51)
```csharp
        Should.Throw<DivideByZeroException>(() => { number1.Div(0); });
        Should.Throw<DivideByZeroException>(() => { number2.Div(0); });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L126-136)
```csharp
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```
