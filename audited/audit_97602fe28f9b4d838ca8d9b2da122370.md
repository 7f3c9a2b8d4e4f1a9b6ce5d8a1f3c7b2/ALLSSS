### Title
Null Reference Exception in GetResourceInfo Causes Parallel Execution DoS

### Summary
The `GetResourceInfo` method in `TokenContract_ACS2_StatePathsProvider.cs` calls `.ToString()` on Address objects parsed from transaction parameters without null checks. An attacker can craft transactions with null Address fields in the protobuf message that pass basic validation but trigger unhandled `NullReferenceException` during resource extraction, disrupting parallel transaction execution and potentially causing node instability.

### Finding Description

The vulnerability exists in the `GetResourceInfo` method where it processes `Transfer` and `TransferFrom` transactions: [1](#0-0) 

At lines 22-23 and 47-48, the code calls `.ToString()` on Address objects (`args.To`, `args.From`) without null validation: [2](#0-1) 

The `GetPath` helper method directly adds these string values to the state path without null checking: [3](#0-2) 

**Root Cause**: In protobuf3 C#, message types like `Address` can be null if not explicitly set in the serialized message. The protobuf definitions confirm this: [4](#0-3) 

**Why Existing Protections Fail**:

Transaction validation only checks the Transaction-level fields, not the contents of parameters: [5](#0-4) 

This validation occurs before resource extraction: [6](#0-5) 

However, `GetResourceInfo` is called during resource extraction via an event handler with insufficient exception handling: [7](#0-6) 

The try-catch block only handles `SmartContractFindRegistrationException`, not `NullReferenceException`: [8](#0-7) 

### Impact Explanation

**Operational DoS**: An attacker can spam transactions with null Address fields to repeatedly trigger unhandled exceptions during resource extraction. This disrupts:
- Parallel transaction execution grouping
- Resource extraction caching mechanism
- Transaction processing pipeline efficiency

**Node Instability**: The `HandleTransactionAcceptedEvent` uses fire-and-forget execution without proper exception handling: [9](#0-8) 

Unhandled exceptions in async tasks can lead to task crashes and degraded node performance.

**Severity**: Medium - causes operational disruption and resource exhaustion but does not directly compromise funds or governance. The attack is low-cost (transaction fees only) and can be sustained to degrade network performance.

### Likelihood Explanation

**Attacker Capabilities**: Any user can craft malicious transactions. No special privileges required.

**Attack Complexity**: Low - attacker simply needs to:
1. Create a Transaction with valid From, To (MultiToken contract address), MethodName ("Transfer")
2. Serialize a TransferInput protobuf message with null To field
3. Submit the transaction

**Feasibility Conditions**: 
- Transaction passes `VerifyFields()` validation since Transaction-level fields are valid
- No validation exists for TransferInput contents before `GetResourceInfo` is called
- Exception propagates unhandled through resource extraction system

**Economic Rationality**: Attack cost is minimal (only transaction fees), while impact on node performance is significant. Attacker can sustain attack as long as they have funds for transaction fees.

**Detection**: Exceptions would be logged but might not trigger immediate alerts, allowing sustained attack.

### Recommendation

**Immediate Fix**: Add null checks in `GetResourceInfo` before calling `.ToString()`:

```csharp
case nameof(Transfer):
{
    var args = TransferInput.Parser.ParseFrom(txn.Params);
    if (args.To == null || args.To.Value.IsNullOrEmpty())
        return new ResourceInfo { NonParallelizable = true };
    
    var resourceInfo = new ResourceInfo
    {
        WritePaths =
        {
            GetPath(nameof(TokenContractState.Balances), txn.From.ToString(), args.Symbol),
            GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol)
        },
        // ... rest of the code
    };
}
```

**Enhanced Exception Handling**: Wrap resource extraction in try-catch to return `NonParallelizable` on any exception:

```csharp
private async Task<TransactionResourceInfo> GetResourcesForOneAsync(...)
{
    try
    {
        // existing code
    }
    catch (Exception ex)
    {
        Logger.LogWarning(ex, $"Failed to extract resources for {transaction.GetHash()}");
        return new TransactionResourceInfo
        {
            TransactionId = transaction.GetHash(),
            ParallelType = ParallelType.NonParallelizable
        };
    }
}
```

**Test Cases**: Add regression tests for null/invalid inputs in `ACS2_TokenResourceTests.cs`:
- Test GetResourceInfo with null To address
- Test GetResourceInfo with null From address
- Test GetResourceInfo with empty Symbol
- Verify graceful degradation (returns NonParallelizable instead of crashing)

### Proof of Concept

**Initial State**: Node running and accepting transactions

**Attack Steps**:
1. Create a `TransferInput` protobuf message with null `To` field:
   ```csharp
   var transferInput = new TransferInput
   {
       Amount = 100,
       Symbol = "ELF",
       // To field intentionally not set (null)
   };
   ```

2. Create Transaction with valid fields:
   ```csharp
   var transaction = new Transaction
   {
       From = attackerAddress,
       To = tokenContractAddress,
       MethodName = "Transfer",
       Params = transferInput.ToByteString(),
       // ... other required fields
   };
   ```

3. Submit transaction to node

**Expected Result**: Transaction rejected with validation error

**Actual Result**: 
- Transaction passes validation and enters pool
- `TransactionAcceptedEvent` is published
- `GetResourceInfo` is called
- `NullReferenceException` is thrown at `args.To.ToString()`
- Exception propagates unhandled
- Resource extraction fails
- Parallel execution system disrupted

**Success Condition**: Node logs show `NullReferenceException` during resource extraction, and parallel transaction grouping is impacted. Sustained attack degrades node performance.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L15-38)
```csharp
            case nameof(Transfer):
            {
                var args = TransferInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), txn.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol)
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };

                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L98-111)
```csharp
    private ScopedStatePath GetPath(params string[] parts)
    {
        return new ScopedStatePath
        {
            Address = Context.Self,
            Path = new StatePath
            {
                Parts =
                {
                    parts
                }
            }
        };
    }
```

**File:** protobuf/token_contract.proto (L318-327)
```text
message TransferInput {
    // The receiver of the token.
    aelf.Address to = 1;
    // The token symbol to transfer.
    string symbol = 2;
    // The amount to to transfer.
    int64 amount = 3;
    // The memo.
    string memo = 4;
}
```

**File:** src/AElf.Types/Types/Transaction.cs (L19-31)
```csharp
        public bool VerifyFields()
        {
            if (To == null || From == null)
                return false;

            if (RefBlockNumber < 0)
                return false;

            if (string.IsNullOrEmpty(MethodName))
                return false;

            return true;
        }
```

**File:** src/AElf.Kernel.TransactionPool/Infrastructure/BasicTransactionValidationProvider.cs (L18-30)
```csharp
    public async Task<bool> ValidateTransactionAsync(Transaction transaction, IChainContext chainContext)
    {
        var transactionId = transaction.GetHash();
        if (!transaction.VerifySignature())
        {
            await LocalEventBus.PublishAsync(new TransactionValidationStatusChangedEvent
            {
                TransactionId = transactionId,
                TransactionResultStatus = TransactionResultStatus.NodeValidationFailed,
                Error = "Incorrect transaction signature."
            });
            return false;
        }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/ResourceExtractionService.cs (L127-178)
```csharp
    private async Task<TransactionResourceInfo> GetResourcesForOneAsync(IChainContext chainContext,
        Transaction transaction, CancellationToken ct)
    {
        IExecutive executive = null;
        var address = transaction.To;

        try
        {
            executive = await _smartContractExecutiveService.GetExecutiveAsync(chainContext, address);
            if (!executive.IsParallelizable())
                return new TransactionResourceInfo
                {
                    TransactionId = transaction.GetHash(),
                    ParallelType = ParallelType.NonParallelizable,
                    ContractHash = executive.ContractHash
                };

            var nonparallelContractCode =
                await _nonparallelContractCodeProvider.GetNonparallelContractCodeAsync(chainContext, address);
            if (nonparallelContractCode != null && nonparallelContractCode.CodeHash == executive.ContractHash)
                return new TransactionResourceInfo
                {
                    TransactionId = transaction.GetHash(),
                    ParallelType = ParallelType.NonParallelizable,
                    ContractHash = executive.ContractHash,
                    IsNonparallelContractCode = true
                };

            if (_resourceCache.TryGetValue(transaction.GetHash(), out var resourceCache) &&
                executive.ContractHash == resourceCache.ResourceInfo.ContractHash &&
                resourceCache.ResourceInfo.IsNonparallelContractCode == false)
                return resourceCache.ResourceInfo;

            var txContext = GetTransactionContext(chainContext, transaction.To, transaction.ToByteString());
            var resourceInfo = await executive.GetTransactionResourceInfoAsync(txContext, transaction.GetHash());
            // Try storing in cache here
            return resourceInfo;
        }
        catch (SmartContractFindRegistrationException)
        {
            return new TransactionResourceInfo
            {
                TransactionId = transaction.GetHash(),
                ParallelType = ParallelType.InvalidContractAddress
            };
        }
        finally
        {
            if (executive != null)
                await _smartContractExecutiveService.PutExecutiveAsync(chainContext, address, executive);
        }
    }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/ResourceExtractionService.cs (L218-227)
```csharp
    public async Task HandleTransactionAcceptedEvent(TransactionAcceptedEvent eventData)
    {
        var chainContext = await GetChainContextAsync();
        var transaction = eventData.Transaction;

        var resourceInfo = await GetResourcesForOneAsync(chainContext, transaction, CancellationToken.None);
        _resourceCache.TryAdd(transaction.GetHash(),
            new TransactionResourceCache(resourceInfo, transaction.To,
                eventData.Transaction.GetExpiryBlockNumber()));
    }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Application/ParallelExecutionInterestedEventsHandler.cs (L32-36)
```csharp
    public Task HandleEventAsync(TransactionAcceptedEvent eventData)
    {
        _ = _resourceExtractionService.HandleTransactionAcceptedEvent(eventData);
        return Task.CompletedTask;
    }
```
