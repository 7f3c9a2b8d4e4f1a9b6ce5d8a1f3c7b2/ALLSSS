### Title
RoundId Manipulation Bypasses Time Slot Validation in NextRound Consensus Transitions

### Summary
A malicious miner can craft a NextRound proposal with arbitrary `ExpectedMiningTime` values that sum to equal the current `BaseRound.RoundId`, causing the validation logic to incorrectly skip `CheckRoundTimeSlots()`. This allows acceptance of a new consensus round with invalid, unequal time slots that violate consensus timing rules, potentially disrupting block production schedules and consensus integrity.

### Finding Description

The vulnerability exists in `TimeSlotValidationProvider.ValidateHeaderInformation()` where RoundId equality is used to determine whether to validate time slots for a new round: [1](#0-0) 

The `RoundId` property is calculated as the sum of all miners' `ExpectedMiningTime.Seconds` values: [2](#0-1) 

**Root Cause:** The logic assumes that if `ProvidedRound.RoundId == BaseRound.RoundId`, then it's not a new round and only needs to check the miner's individual time slot. However, an attacker can craft a NextRound with `ExpectedMiningTime` values that deliberately sum to match `BaseRound.RoundId`, making the validator incorrectly treat a new round as the same round.

**Attack Mechanism:**
1. Attacker queries `BaseRound.RoundId` (e.g., 28.9 billion for 17 miners with timestamps ~1.7B each)
2. Attacker crafts `ProvidedRound` for NextRound with manipulated values:
   - Sets 16 miners to `ExpectedMiningTime.Seconds = 1`
   - Sets 1 miner to `ExpectedMiningTime.Seconds = 28,899,999,984` (BaseRound.RoundId - 16)
   - Result: `ProvidedRound.RoundId = 28.9 billion = BaseRound.RoundId`
3. Validation flow in `ValidateBeforeExecution` runs validators for NextRound behavior: [3](#0-2) 

4. `RoundTerminateValidationProvider` only validates `RoundNumber` increments and `InValue` nullity, NOT `ExpectedMiningTime` values: [4](#0-3) 

5. `TimeSlotValidationProvider` sees equal RoundIds and skips `CheckRoundTimeSlots()`, only checking the attacker's individual time slot in BaseRound: [5](#0-4) 

6. `CheckRoundTimeSlots()` would normally reject this by verifying equal intervals between miners: [6](#0-5) 

However, it never executes due to the bypassed condition.

7. The malicious round is stored without validation: [7](#0-6) 

**Alternative Attack Vectors:**
- Set `ExpectedMiningTime` to null for some miners and manipulate `round_id_for_validation` field directly: [8](#0-7) 

- Use integer overflow (though unnecessary): C# LINQ `.Sum()` does not use checked arithmetic, allowing silent overflow to wrap around and match target RoundId.

### Impact Explanation

**Consensus Integrity Violation:**
- The accepted malicious round has arbitrary, unequal time slots (e.g., intervals ranging from milliseconds to years)
- Miners cannot reliably determine their mining windows, breaking the AEDPoS scheduling mechanism
- Time-based validations throughout the consensus system depend on valid `ExpectedMiningTime` values

**Concrete Harms:**
1. **Consensus Disruption:** Miners with compressed time slots (e.g., 1ms intervals) cannot physically produce blocks in time, while others with extended slots monopolize block production
2. **Chain Halt Risk:** If critical miners have invalid time slots, consensus may fail to progress rounds
3. **Reward Manipulation:** Unequal time slots enable unfair distribution of block production and associated rewards
4. **Cascading Failures:** Subsequent rounds generated from the malicious round inherit broken timing assumptions

**Affected Parties:**
- All network participants: consensus breaks down network-wide
- Honest miners: unable to produce blocks in their assigned slots
- Users: transaction finality degraded or halted

**Severity Justification:** HIGH - Direct compromise of core consensus invariant (equal time slot distribution) with practical exploitation path requiring only current miner privileges.

### Likelihood Explanation

**Attacker Requirements:**
- Must be a current miner (validated by `MiningPermissionValidationProvider`): [9](#0-8) 

- Must mine during their valid time slot in current round to trigger NextRound

**Attack Complexity:** LOW
- Simple arithmetic: calculate target sum and distribute across miners
- No cryptographic breaking required
- No race conditions or timing dependencies
- Single transaction execution path via `NextRound` method: [10](#0-9) 

**Feasibility Conditions:**
- `BaseRound.RoundId` is publicly readable state
- Valid `Timestamp.Seconds` range (-62B to 253B) easily accommodates attack values: [11](#0-10) 

- No additional checks validate ExpectedMiningTime reasonableness or sum integrity

**Detection Constraints:**
- Attack appears as valid NextRound transaction pre-execution
- Only detectable post-execution when subsequent blocks reveal timing inconsistencies
- No automatic rollback mechanism for accepted invalid rounds

**Probability Assessment:** HIGH - Any malicious miner can execute this attack during their time slot with near certainty of success, limited only by the normal consensus flow constraints.

### Recommendation

**Immediate Fix:**
Modify `TimeSlotValidationProvider.ValidateHeaderInformation()` to always validate new round time slots for NextRound/NextTerm behaviors regardless of RoundId equality:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    
    // For NextRound/NextTerm, ALWAYS validate time slots
    if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.NextRound ||
        validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.NextTerm)
    {
        validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
        if (!validationResult.Success) return validationResult;
    }
    // For same round updates (UpdateValue/TinyBlock), check RoundId and miner time slot
    else if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
    {
        validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
        if (!validationResult.Success) return validationResult;
    }
    else
    {
        if (!CheckMinerTimeSlot(validationContext))
        {
            validationResult.Message = $"Time slot already passed before execution.{validationContext.SenderPubkey}";
            validationResult.IsReTrigger = true;
            return validationResult;
        }
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

**Additional Invariant Checks:**
1. Add RoundId integrity validation in `RoundTerminateValidationProvider`:
   - For NextRound: Assert `ProvidedRound.RoundId != BaseRound.RoundId`
   - Validate RoundId falls within expected range based on current timestamp

2. Add ExpectedMiningTime sanity checks:
   - Values must be within reasonable range of `Context.CurrentBlockTime`
   - Maximum deviation from current time (e.g., ±1 year)

**Regression Test Cases:**
1. Test NextRound with manipulated ExpectedMiningTime summing to BaseRound.RoundId → should FAIL
2. Test NextRound with `round_id_for_validation` set to BaseRound.RoundId → should FAIL
3. Test legitimate NextRound with proper time slots → should PASS
4. Test UpdateValue with matching RoundId → should PASS (legitimate same-round update)

### Proof of Concept

**Initial State:**
- Network has 17 active miners
- Current round (BaseRound) has RoundNumber = 100, RoundId = 28,900,000,000 (17 miners × ~1.7B seconds each)
- Attacker is Miner #5 with valid mining privileges

**Attack Transaction Sequence:**

**Step 1:** Attacker queries current state:
```
GetCurrentRoundInformation() → BaseRound
BaseRound.RoundId = 28,900,000,000
BaseRound.RoundNumber = 100
```

**Step 2:** Attacker constructs malicious NextRoundInput:
```
NextRoundInput {
  RoundNumber = 101,
  TermNumber = BaseRound.TermNumber,
  RealTimeMinersInformation = {
    "Miner1": { Order = 1, ExpectedMiningTime.Seconds = 1 },
    "Miner2": { Order = 2, ExpectedMiningTime.Seconds = 1 },
    ...
    "Miner16": { Order = 16, ExpectedMiningTime.Seconds = 1 },
    "Miner17": { Order = 17, ExpectedMiningTime.Seconds = 28,899,999,984 }
  }
}
```

**Step 3:** Attacker calls NextRound during their valid time slot:
```
NextRound(maliciousInput) → success
```

**Step 4:** Validation flow:
- MiningPermissionValidationProvider: ✓ Attacker is in BaseRound miner list
- TimeSlotValidationProvider: 
  - Calculates ProvidedRound.RoundId = 1+1+...+28,899,999,984 = 28,900,000,000
  - Compares: ProvidedRound.RoundId (28,900,000,000) == BaseRound.RoundId (28,900,000,000) → TRUE
  - Skips CheckRoundTimeSlots()
  - Only checks attacker's time slot in BaseRound → ✓ PASS
- RoundTerminateValidationProvider: ✓ RoundNumber = 101 (correct increment)
- NextRoundMiningOrderValidationProvider: ✓ FinalOrderOfNextRound consistency

**Expected Result:** Transaction rejected due to invalid time slots

**Actual Result:** Transaction ACCEPTED, malicious round stored as Round #101

**Success Condition:** Query `GetRoundInformation(101)` returns round with ExpectedMiningTime values [1, 1, ..., 28,899,999,984], confirming bypass of time slot validation. Subsequent block production attempts fail as miners cannot honor the invalid time slots.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-19)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** protobuf/aedpos_contract.proto (L262-264)
```text
    // The round id, calculated by summing block producers’ expecting time (second).
    int64 round_id_for_validation = 10;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Election/TimestampHelper.cs (L6-16)
```csharp
{
    /// <summary>
    ///     0001-01-01T00:00:00Z
    /// </summary>
    public static Timestamp MinValue => new() { Nanos = 0, Seconds = -62135596800L };

    /// <summary>
    ///     9999-12-31T23:59:59.999999999Z
    /// </summary>
    public static Timestamp MaxValue => new() { Nanos = 999999999, Seconds = 253402300799L };
}
```
