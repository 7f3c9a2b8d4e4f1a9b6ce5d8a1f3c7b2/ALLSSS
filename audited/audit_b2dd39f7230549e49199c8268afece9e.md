### Title
Missed Time Slots Reset Without Evil Miner Detection at Term Boundaries

### Summary
The `ProcessNextTerm()` function resets `MissedTimeSlots` counters to zero for all miners when transitioning to a new term, but critically fails to check if any miner exceeded the evil threshold (4320 missed slots) before the reset. This allows miners with poor performance to avoid punishment by having their counters cleared at term boundaries without triggering the evil miner detection mechanism that only executes during round transitions.

### Finding Description

**Exact Code Locations:**

The vulnerability exists in the term transition logic: [1](#0-0) 

**Root Cause:**

Evil miner detection via `TryToDetectEvilMiners()` is only invoked during round transitions in `ProcessNextRound()`: [2](#0-1) 

However, in `ProcessNextTerm()`, the function:
1. Calls `CountMissedTimeSlots()` to increment missed slots for the current round: [3](#0-2) 

2. Then immediately resets all counters without checking the evil threshold: [4](#0-3) 

**Why Protections Fail:**

The evil miner detection logic checks if `MissedTimeSlots >= TolerableMissedTimeSlotsCount` (4320 slots = 3 days): [5](#0-4) 

This threshold is defined as: [6](#0-5) 

The `CountMissedTimeSlots()` implementation increments the counter for miners who didn't produce blocks: [7](#0-6) 

Missed time slots also accumulate during round generation: [8](#0-7) 

**Relevant Execution Path:**

1. Miner accumulates missed slots across rounds within a term (approaching 4320)
2. Term transition is triggered based on time via `NeedToChangeTerm()`: [9](#0-8) 

3. `ProcessNextTerm()` is called instead of `ProcessNextRound()`
4. Final round's missed slots are counted, potentially pushing the miner over the 4320 threshold
5. No evil detection occurs before counter reset
6. Miner starts the new term with a clean slate

### Impact Explanation

**What Harm Occurs:**

Miners can systematically underperform by missing time slots without facing the intended punishment of being marked as evil nodes and banned from consensus participation. The evil node punishment mechanism includes: [10](#0-9) 

**Quantified Damage:**

- A miner can miss up to ~4,300 slots per term indefinitely without punishment
- With 1-minute slots, this represents ~72 hours of downtime per term
- Across multiple terms, a malicious miner could accumulate thousands of missed slots (e.g., 4,300 × N terms) while appearing compliant
- The historical data is sent to the Election contract but no ban occurs: [11](#0-10) 

**Who Is Affected:**

- Honest miners who maintain high availability are disadvantaged
- The network's consensus reliability is undermined
- Users relying on consistent block production face degraded service
- The entire economic model based on miner performance metrics is compromised

**Severity Justification:**

HIGH severity because:
- Bypasses a critical consensus integrity invariant (miner performance accountability)
- Allows indefinite exploitation across multiple terms
- No remediation occurs as the punishment mechanism is completely bypassed
- Undermines the fundamental trustworthiness of the validator set

### Likelihood Explanation

**Attacker Capabilities:**

Any current miner can exploit this vulnerability by simply choosing to miss time slots strategically. No special privileges, tokens, or governance control are required beyond being in the active miner set.

**Attack Complexity:**

LOW complexity:
1. Miner monitors their own `MissedTimeSlots` counter (visible in current round information)
2. Maintains poor performance while staying under 4,320 missed slots per term
3. Allows natural term transitions to reset the counter
4. Repeats indefinitely

**Feasibility Conditions:**

- Term duration must be long enough to accumulate significant missed slots (typical configuration)
- Miner must be in the active set (a prerequisite for any consensus-related exploit)
- No coordination with other miners required
- No reliance on timing precision - the vulnerability exists at every term boundary

**Detection/Operational Constraints:**

While the Election contract receives historical data showing accumulated `RecentlyMissedTimeSlots`, there is no automatic enforcement action at term boundaries: [12](#0-11) 

Manual intervention via emergency response organization is possible but reactive: [13](#0-12) 

**Probability Reasoning:**

HIGH probability of exploitation because:
- The vulnerability is passive (no active "timing" required)
- Economic incentive exists: miners can reduce operational costs by running unreliable infrastructure
- Detection requires manual monitoring of historical data across term boundaries
- No automated enforcement prevents this behavior

### Recommendation

**Exact Code-Level Mitigation:**

Add evil miner detection before resetting counters in `ProcessNextTerm()`. Insert the following check after line 168 (after `CountMissedTimeSlots()` is called):

```csharp
// After line 168: CountMissedTimeSlots();
// Add evil miner detection before reset
if (State.IsMainChain.Value && 
    TryToGetCurrentRoundInformation(out var currentRoundForDetection) &&
    currentRoundForDetection.TryToDetectEvilMiners(out var evilMinersAtTermEnd))
{
    Context.LogDebug(() => "Evil miners detected at term boundary.");
    foreach (var evilMiner in evilMinersAtTermEnd)
    {
        Context.LogDebug(() =>
            $"Evil miner {evilMiner} at term end, missed time slots: {currentRoundForDetection.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
        State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
        {
            Pubkey = evilMiner,
            IsEvilNode = true
        });
    }
}
```

**Invariant Checks to Add:**

1. Before any `MissedTimeSlots` reset, verify no miner exceeds `TolerableMissedTimeSlotsCount`
2. Add assertion: `Assert(all miners' MissedTimeSlots < TolerableMissedTimeSlotsCount OR evil detection was performed)`

**Test Cases to Prevent Regression:**

1. Create test where miner accumulates 4,310 missed slots during a term
2. Trigger term transition via `NextTerm()`
3. Verify miner is marked as evil before counter reset
4. Verify miner is removed from candidate list and banned
5. Test boundary case: miner at exactly 4,320 missed slots at term end
6. Test multiple consecutive terms with near-threshold accumulation

### Proof of Concept

**Required Initial State:**
- Main chain with active consensus
- Miner in active validator set
- Term period configured (e.g., 7 days)
- Evil threshold: 4,320 missed slots (3 days at 1-minute intervals)

**Transaction Steps:**

1. **Setup**: Miner is part of initial miner list and begins producing blocks

2. **Accumulation Phase** (within Term N):
   - Miner intentionally misses time slots during multiple rounds
   - Monitors their `MissedTimeSlots` counter via `GetCurrentRoundInformation()`
   - Ensures counter stays between 4,000-4,319 by the end of the term
   - During round transitions, `ProcessNextRound()` is called, which WOULD detect evil if threshold exceeded
   - But miner stays just below threshold

3. **Term Transition** (Term N → Term N+1):
   - Time elapses such that `NeedToChangeTerm()` returns true
   - Next miner calls `NextTerm()` with prepared `NextTermInput`
   - `ProcessNextTerm()` executes:
     - Calls `CountMissedTimeSlots()` - may push counter to 4,320+
     - Does NOT call `TryToDetectEvilMiners()`
     - Resets `MissedTimeSlots` to 0 at line 179-183
     - Miner enters Term N+1 with clean record

4. **Repeat**: Miner continues pattern in Term N+1

**Expected vs Actual Result:**

- **Expected**: Miner with 4,320+ missed slots should be detected as evil, marked with `IsEvilNode=true`, banned from Election contract, and removed from subsequent miner lists
- **Actual**: Miner's counter is reset to 0 without detection, they continue participating in consensus with no punishment

**Clear Success Condition:**

Exploitation succeeds if after term transition:
1. Miner's `MissedTimeSlots` counter is 0 in the new term
2. Miner is NOT in the banned pubkey map: `State.BannedPubkeyMap[minerPubkey]` returns false/null
3. Miner remains in the candidate list and can continue mining
4. No `EvilMinerDetected` event was fired for this miner despite crossing the threshold

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L37-51)
```csharp
    private void UpdateCurrentMinerInformationToElectionContract(Round previousRound)
    {
        State.ElectionContract.UpdateMultipleCandidateInformation.Send(new UpdateMultipleCandidateInformationInput
        {
            Value =
            {
                previousRound.RealTimeMinersInformation.Select(i => new UpdateCandidateInformationInput
                {
                    Pubkey = i.Key,
                    RecentlyProducedBlocks = i.Value.ProducedBlocks,
                    RecentlyMissedTimeSlots = i.Value.MissedTimeSlots
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L87-96)
```csharp
    private void CountMissedTimeSlots()
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return;

        foreach (var minerInRound in currentRound.RealTimeMinersInformation)
            if (minerInRound.Value.OutValue == null)
                minerInRound.Value.MissedTimeSlots = minerInRound.Value.MissedTimeSlots.Add(1);

        TryToUpdateRoundInformation(currentRound);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L52-55)
```csharp
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L115-118)
```csharp
        candidateInformation.ProducedBlocks = candidateInformation.ProducedBlocks.Add(input.RecentlyProducedBlocks);
        candidateInformation.MissedTimeSlots =
            candidateInformation.MissedTimeSlots.Add(input.RecentlyMissedTimeSlots);
        State.CandidateInformationMap[input.Pubkey] = candidateInformation;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-351)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
    }
```
