# Audit Report

## Title
Late UpdateValue Transaction Can Corrupt Next Round Mining Schedule

## Summary
The `ProcessUpdateValue` method fails to validate the `round_id` field in `UpdateValueInput`, allowing stale transactions from previous rounds to corrupt mining schedules in subsequent rounds. This enables manipulation of miner positions and false mining participation records.

## Finding Description

The `UpdateValueInput` message includes a `round_id` field explicitly documented to "ensure the values to update will be apply to correct round by comparing round id." [1](#0-0) 

However, `ProcessUpdateValue` retrieves the current round from storage and directly applies the update without validating that `updateValueInput.RoundId` matches the current round: [2](#0-1) 

The current round is retrieved via `TryToGetCurrentRoundInformation`, which returns whatever `State.CurrentRoundNumber` points to: [3](#0-2) 

**Attack Scenario:**

When a miner produces a block with `UpdateValue` behavior, `ApplyNormalConsensusData` calculates `SupposedOrderOfNextRound` and `FinalOrderOfNextRound`: [4](#0-3) 

These values are packaged into `UpdateValueInput` with the current round's `RoundIdForValidation`: [5](#0-4) 

If the extra block producer executes `NextRound` before the `UpdateValue` transaction processes, the round advances to N+1. When the late `UpdateValue` transaction executes, `ProcessUpdateValue` applies its data to Round N+1 instead of Round N.

The critical impact occurs during next round generation. `GenerateNextRoundInformation` identifies miners who participated by checking `SupposedOrderOfNextRound != 0`: [6](#0-5) 

The attacker's miner is incorrectly included as having mined in Round N+1, and their `FinalOrderOfNextRound` determines their position in Round N+2: [7](#0-6) 

**Why Existing Protections Fail:**

`UpdateValueValidationProvider` only validates that consensus information (OutValue, Signature) is properly filled and that previous in values are correct - it does NOT check `round_id`: [8](#0-7) 

`PreCheck` only verifies the miner is in the current or previous round's miner list, not that the transaction data belongs to the current round: [9](#0-8) 

`EnsureTransactionOnlyExecutedOnceInOneBlock` prevents duplicate consensus transactions within one block but cannot prevent stale transactions from previous rounds: [10](#0-9) 

## Impact Explanation

This vulnerability breaks the fundamental consensus invariant of correct round transitions and miner schedule integrity. Specific harms include:

1. **False Mining Records**: Miners can appear to have mined in rounds where they didn't participate, corrupting the historical mining record used for reward calculations and reputation tracking.

2. **Mining Schedule Manipulation**: Attackers can influence their position in future rounds by injecting their `FinalOrderOfNextRound` value into incorrect rounds, potentially securing more favorable time slots.

3. **Schedule Disruption**: Legitimate miners' expected positions can be displaced by the corrupted order calculations, affecting network predictability and fairness.

4. **Compounding Effect**: Since `GenerateNextRoundInformation` carries forward `ProducedBlocks` and `MissedTimeSlots` counts, repeated exploitation can lead to sustained manipulation across multiple rounds.

The consensus protocol's fairness guarantee is violated, as mining positions should be determined by cryptographic signatures from actual block production, not by stale transactions applied to wrong rounds.

## Likelihood Explanation

This vulnerability is highly exploitable due to natural timing conditions in distributed blockchain systems:

1. **Public Entry Point**: `UpdateValue` is a public RPC method that any authorized miner can call: [11](#0-10) 

2. **Natural Race Conditions**: The timing window occurs when a miner produces a block near round boundaries and network latency delays transaction inclusion, allowing the extra block producer's `NextRound` to execute first.

3. **Minimal Attack Requirements**: Only requires being an authorized miner - no special privileges beyond normal mining participation.

4. **Difficult Detection**: The transaction passes all existing validation checks and executes successfully, making malicious exploitation hard to distinguish from natural timing issues.

5. **Deliberate Exploitation**: A malicious miner can intentionally delay broadcasting their `UpdateValue` transaction, wait for the round to advance, then submit it to manipulate their position in the next round.

## Recommendation

Add explicit round_id validation in `ProcessUpdateValue`:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // Add validation for round_id
    Assert(updateValueInput.RoundId == currentRound.RoundNumber, 
           $"Round ID mismatch: expected {currentRound.RoundNumber}, got {updateValueInput.RoundId}");
    
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    // ... rest of the method
}
```

This ensures the documented purpose of the `round_id` field is enforced, preventing stale transactions from corrupting future round schedules.

## Proof of Concept

```csharp
[Fact]
public async Task LateUpdateValue_CorruptsNextRoundSchedule()
{
    // Setup: Initialize consensus with miner A and B in Round 1
    var minerA = SampleAccount.Accounts[0].KeyPair;
    var minerB = SampleAccount.Accounts[1].KeyPair;
    
    // Round 1: Miner A produces block and generates UpdateValueInput
    var round1 = GetCurrentRoundInformation();
    var updateInput = round1.ExtractInformationToUpdateConsensus(
        minerA.PublicKey.ToHex(), ByteString.Empty);
    // updateInput.RoundId = 1
    
    // Simulate NextRound executing before UpdateValue
    await MinerB_ProducesNextRoundBlock();
    var round2 = GetCurrentRoundInformation();
    Assert.Equal(2, round2.RoundNumber);
    
    // Late UpdateValue transaction executes in Round 2
    await UpdateValueStub.UpdateValue.SendAsync(updateInput);
    
    // Verify corruption: Miner A appears to have mined in Round 2
    var corruptedRound2 = GetCurrentRoundInformation();
    var minerAInRound2 = corruptedRound2.RealTimeMinersInformation[minerA.PublicKey.ToHex()];
    Assert.NotEqual(0, minerAInRound2.SupposedOrderOfNextRound); // Should be 0!
    
    // Impact: Miner A is incorrectly included in Round 3 generation
    var round3 = GenerateNextRoundInformation(corruptedRound2);
    var minersWhoMinedInRound2 = round3.RealTimeMinersInformation.Values
        .Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    Assert.Contains(minerA.PublicKey.ToHex(), 
        minersWhoMinedInRound2.Select(m => m.Pubkey)); // FALSE POSITIVE!
}
```

## Notes

This vulnerability exists because the `round_id` field, while documented and populated correctly, is never actually validated during transaction execution. The validation happens only at the block header level (checking `Round.RoundId` in extraData), but not at the transaction parameter level (checking `UpdateValueInput.RoundId`). This creates a gap where stale transactions can be applied to incorrect rounds after round transitions.

### Citations

**File:** protobuf/aedpos_contract.proto (L199-200)
```text
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L35-50)
```csharp
        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
            RandomNumber = randomNumber
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L25-36)
```csharp
        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
