# Audit Report

## Title
DataCentersRankingList Allows Negative Vote Amounts via Quit-Reannounce-Withdraw Sequence

## Summary
The Election Contract contains a critical state desynchronization vulnerability where candidates who quit election and then re-announce can have negative vote amounts in the DataCentersRankingList. This occurs because QuitElection preserves CandidateVotes while removing the ranking list entry, re-announcing resets the ranking value to 0, and subsequent voter withdrawals create negative values that corrupt ranking logic and subsidy distribution.

## Finding Description

The vulnerability exploits an incorrect assumption that DataCentersRankingList and CandidateVotes remain synchronized. The attack sequence is:

**1. QuitElection removes from ranking but preserves CandidateVotes:** [1](#0-0) 

When a candidate quits, their DataCentersRankingList entry is set to 0 and then removed via `UpdateDataCenterAfterMemberVoteAmountChanged`. However, `State.CandidateVotes[pubkey]` is never cleared - it retains all vote records and amounts from before quitting. [2](#0-1) 

The candidate is marked as `IsCurrentCandidate = false`, but their vote data persists.

**2. Re-announcing adds back with value 0 regardless of existing votes:** [3](#0-2) 

When re-announcing, the candidate is added back to DataCentersRankingList with a hardcoded value of 0, completely ignoring the fact that `State.CandidateVotes[pubkey]` still contains the original vote amounts.

**3. Withdraw subtracts from ranking list creating negative values:** [4](#0-3) 

When voters withdraw after the candidate has re-announced, the withdrawal subtracts from the DataCentersRankingList value (currently 0), creating negative values. Critically, there is no check that prevents withdrawal from a candidate who previously quit, and no validation that the subtraction result must be non-negative.

**4. SafeMath.Sub permits negative results within type bounds:** [5](#0-4) 

The `checked` block only prevents overflow beyond `long`'s range. The operation `0L - 1000L = -1000L` is perfectly valid for signed integers and does NOT throw an exception.

**5. Negative values break ranking logic:** [6](#0-5) [7](#0-6) [8](#0-7) 

These comparisons treat negative values as legitimately "less than" positive values, causing incorrect candidate ranking and replacement decisions. Candidates with negative amounts become prime targets for removal despite potentially having actual voter support.

**6. DataCenterRankingList type permits negative values:** [9](#0-8) 

The protobuf definition uses `int64` (signed), which allows negative values without type-level enforcement of non-negativity.

## Impact Explanation

**Critical Protocol Invariant Violated:** The election system assumes vote amounts are non-negative, as voting inherently represents accumulation of support. Negative vote amounts are mathematically and semantically invalid.

**Concrete Impacts:**

1. **Ranking Corruption**: Candidates with negative values are incorrectly sorted below all legitimate candidates, regardless of their actual voter support

2. **Subsidy Misallocation**: The DataCentersRankingList determines BackupSubsidy profit scheme beneficiaries. Candidates with negative values lose subsidy access unfairly: [10](#0-9) 

3. **Unfair Replacement**: New candidates can incorrectly replace candidates with negative values even when those candidates have legitimate outstanding votes in CandidateVotes

4. **Election Integrity**: Voters who legitimately voted for a candidate find their voting power nullified or inverted when the candidate undergoes quit-reannounce, fundamentally breaking trust in the election mechanism

**Severity: HIGH** - This breaks a core invariant of the voting system, enables ranking manipulation, affects economic rewards distribution tied to consensus, and can occur through both accidental operational patterns and deliberate exploitation.

## Likelihood Explanation

**Attack Complexity: LOW** - Requires only standard public operations available to any candidate and voters:
- Announce election (public)
- Vote (public)  
- Quit election (requires candidate admin, but normal operation)
- Re-announce (public)
- Withdraw votes after lock period (public)

**Feasible Preconditions:**
1. Candidate announces and gets added to ranking list (space available)
2. Voters vote for candidate
3. Candidate quits (valid if not a current miner): [11](#0-10) 

4. Candidate re-announces (space available)
5. Voters withdraw after lock time expires (standard operation)

**Realistic Scenarios:**

- **Accidental**: Candidate experiences downtime/technical issues, quits temporarily, resolves issues and re-announces. Original voters naturally withdraw when lock periods expire, inadvertently creating negative values

- **Malicious**: Candidate admin intentionally exploits the quit-reannounce sequence to manipulate their ranking position or grief competitors

- **Griefing**: Attacker votes for candidates they control, forces quit-reannounce, then withdraws to assign negative votes

**No Detection or Prevention:** The negative value persists in contract state and affects all subsequent ranking operations. There is no validation, automatic correction, or monitoring.

**Probability: MEDIUM-HIGH** - Can occur through normal operational flows or deliberate manipulation with no special privileges required.

## Recommendation

**Solution: Synchronize DataCentersRankingList with CandidateVotes during re-announcement**

When a candidate re-announces after quitting, the DataCentersRankingList value should be restored from the actual CandidateVotes amount rather than hardcoded to 0:

```csharp
if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
{
    // Check if candidate has existing votes from before quitting
    var existingVotes = State.CandidateVotes[pubkey];
    var voteAmount = existingVotes?.ObtainedActiveVotedVotesAmount ?? 0;
    
    State.DataCentersRankingList.Value.DataCenters.Add(pubkey, voteAmount);
    RegisterCandidateToSubsidyProfitScheme(pubkey);
}
```

**Alternative Solution: Clear CandidateVotes during QuitElection**

Alternatively, ensure CandidateVotes is cleared when quitting to maintain true state:

```csharp
// In QuitElection after line 254
State.CandidateVotes.Remove(pubkey);
```

**Additional Safeguard: Add non-negativity check in Withdraw**

```csharp
var newAmount = rankingList.DataCenters[newestPubkey].Sub(votingRecord.Amount);
Assert(newAmount >= 0, "Withdrawal would create negative vote amount");
rankingList.DataCenters[newestPubkey] = newAmount;
```

## Proof of Concept

```csharp
[Fact]
public async Task ElectionContract_NegativeVotes_Via_QuitReannounce_Test()
{
    // Setup: Announce candidate and get them into ranking list
    var candidateKeyPair = ValidationDataCenterKeyPairs.First();
    await AnnounceElectionAsync(candidateKeyPair);
    
    // Voter votes for candidate
    var voterKeyPair = VoterKeyPairs.First();
    var voteAmount = 1000_00000000; // 1000 ELF
    var lockTime = 90 * 86400; // 90 days
    var voteResult = await VoteToCandidateAsync(voterKeyPair, 
        candidateKeyPair.PublicKey.ToHex(), lockTime, voteAmount);
    var voteId = Hash.Parser.ParseFrom(voteResult.ReturnValue);
    
    // Verify candidate has positive votes in ranking list
    var rankingBefore = await ElectionContractStub.GetDataCenterRankingList.CallAsync(new Empty());
    rankingBefore.DataCenters[candidateKeyPair.PublicKey.ToHex()].ShouldBe(voteAmount);
    
    // Candidate quits election
    await QuitElectionAsync(candidateKeyPair);
    
    // Verify removed from ranking list but CandidateVotes preserved
    var rankingAfterQuit = await ElectionContractStub.GetDataCenterRankingList.CallAsync(new Empty());
    rankingAfterQuit.DataCenters.ContainsKey(candidateKeyPair.PublicKey.ToHex()).ShouldBeFalse();
    
    var candidateVotes = await ElectionContractStub.GetCandidateVote.CallAsync(
        new StringValue { Value = candidateKeyPair.PublicKey.ToHex() });
    candidateVotes.ObtainedActiveVotedVotesAmount.ShouldBe(voteAmount); // Still has votes!
    
    // Candidate re-announces
    await AnnounceElectionAsync(candidateKeyPair);
    
    // Verify added back with 0, not actual vote amount
    var rankingAfterReannounce = await ElectionContractStub.GetDataCenterRankingList.CallAsync(new Empty());
    rankingAfterReannounce.DataCenters[candidateKeyPair.PublicKey.ToHex()].ShouldBe(0); // BUG: Should be voteAmount
    
    // Advance time past lock period
    await BlockTimeProvider.SetBlockTime(TimestampHelper.GetUtcNow().AddSeconds(lockTime + 1));
    
    // Voter withdraws
    var withdrawStub = GetElectionContractTester(voterKeyPair);
    await withdrawStub.Withdraw.SendAsync(voteId);
    
    // VULNERABILITY: Ranking list now has NEGATIVE value
    var rankingFinal = await ElectionContractStub.GetDataCenterRankingList.CallAsync(new Empty());
    var finalAmount = rankingFinal.DataCenters[candidateKeyPair.PublicKey.ToHex()];
    finalAmount.ShouldBe(-voteAmount); // NEGATIVE VOTES!
    
    // Demonstrate impact: Negative value candidate incorrectly identified as minimum
    var sortedCandidates = rankingFinal.DataCenters.OrderBy(x => x.Value).ToList();
    sortedCandidates.First().Key.ShouldBe(candidateKeyPair.PublicKey.ToHex()); // Unfairly ranked lowest
}
```

## Notes

This vulnerability represents a fundamental state consistency issue where two authoritative sources of truth (DataCentersRankingList and CandidateVotes) become desynchronized through the quit-reannounce sequence. The root cause is that QuitElection and AnnounceElection do not properly reconcile these two state variables, assuming they will naturally stay synchronized through voting operations alone. The ability for voters to withdraw after a candidate quits but before they re-announce creates the critical window where this desynchronization manifests as negative values.

The impact extends beyond mere data corruption - it affects economic incentives (subsidy distribution), fairness (ranking manipulation), and trust in the election system (vote weight inversion). Given that the DataCentersRankingList feeds into the consensus mechanism's validator selection process, maintaining its integrity is critical for chain security.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L112-116)
```csharp
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L251-254)
```csharp
        // Update candidate information.
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L262-268)
```csharp
        var dataCenterList = State.DataCentersRankingList.Value;
        if (dataCenterList.DataCenters.ContainsKey(pubkey))
        {
            dataCenterList.DataCenters[pubkey] = 0;
            UpdateDataCenterAfterMemberVoteAmountChanged(dataCenterList, pubkey, true);
            State.DataCentersRankingList.Value = dataCenterList;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L292-296)
```csharp
        if (State.AEDPoSContract.Value != null)
            Assert(
                !State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
                    .Contains(publicKeyByteString),
                "Current miners cannot quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L475-481)
```csharp
        foreach (var pubkeyToVotesAmount in rankingList.DataCenters.OrderBy(x => x.Value))
            if (pubkeyToVotesAmount.Value < minimumVotes)
            {
                replaceWillHappen = true;
                minimumVotesCandidate = pubkeyToVotesAmount.Key;
                break;
            }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L671-676)
```csharp
        var rankingList = State.DataCentersRankingList.Value;
        if (!rankingList.DataCenters.ContainsKey(newestPubkey)) return new Empty();
        rankingList.DataCenters[newestPubkey] =
            rankingList.DataCenters[newestPubkey].Sub(votingRecord.Amount);
        UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, newestPubkey);
        State.DataCentersRankingList.Value = rankingList;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L688-689)
```csharp
        else if (rankingList.DataCenters.Any(x => x.Value < amountAfterWithdraw))
            return;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L741-742)
```csharp
        var minimumVoteCandidateInDataCenter = list.OrderBy(x => x.Value).First();
        if (voteAmount <= minimumVoteCandidateInDataCenter.Value) return;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L781-794)
```csharp
    private void AddBeneficiary(string candidatePubkey, Address profitsReceiver = null)
    {
        var beneficiaryAddress = GetBeneficiaryAddress(candidatePubkey, profitsReceiver);
        var subsidyId = GenerateSubsidyId(candidatePubkey, beneficiaryAddress);
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = beneficiaryAddress,
                Shares = 1,
            },
            ProfitDetailId = subsidyId
        });
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** protobuf/election_contract.proto (L460-463)
```text
message DataCenterRankingList {
    // The top n * 5 candidates with vote amount, candidate public key -> vote amount.
    map<string, int64> data_centers = 1;
}
```
