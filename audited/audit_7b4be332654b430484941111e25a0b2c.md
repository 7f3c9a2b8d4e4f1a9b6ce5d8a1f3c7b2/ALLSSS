### Title
Zero Block Production Limit During Abnormal Consensus Status Due to Empty Miner Intersection

### Summary
When the blockchain enters `Abnormal` status, if no miners mined blocks in both of the last two rounds (empty intersection), `GetMaximumBlocksCount()` returns 0, preventing all tiny block production and severely degrading consensus performance. This exacerbates an already critical situation where the blockchain is struggling to advance its Last Irreversible Block (LIB).

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:** 

The function retrieves miner lists from the previous two rounds and calculates their intersection to determine a reduction factor for block production limits. [2](#0-1) 

When this intersection is empty (`minersOfLastTwoRounds = 0`), the calculated factor becomes zero. [3](#0-2) 

The `Ceiling` function, when given zero as the numerator, returns zero. [4](#0-3) 

This results in `GetMaximumBlocksCount()` returning 0, which is then used by the consensus behavior provider to determine if miners can produce tiny blocks. [5](#0-4) 

**Why Protections Fail:**

1. No validation that `minersOfLastTwoRounds > 0` before calculating the factor
2. No minimum floor value (e.g., 1) for the return value during abnormal status
3. The code assumes miner continuity between rounds, which may not hold during consensus issues

**Execution Path:**

When `GetMaximumBlocksCount()` is invoked during consensus command generation, it determines the blockchain status. [6](#0-5) 

If the status is `Abnormal` (LIB has not advanced for 2+ rounds), the problematic code path executes. With `_maximumBlocksCount = 0`, the consensus behavior provider cannot authorize tiny block production because the condition `ActualMiningTimes.Count < 0` is always false. [7](#0-6) 

### Impact Explanation

**Consensus Integrity Compromise:** The blockchain enters a deadlock-like state where:
- LIB has already stalled for 2+ rounds (triggering Abnormal status)
- Block production is further restricted to 0 tiny blocks per time slot
- Miners can only produce one block per time slot (UPDATE_VALUE), dramatically reducing throughput
- This severely delays LIB advancement and consensus recovery

**Operational Impact:** 
- During network disruptions or when miner sets change between rounds, this creates a death spiral
- The blockchain's ability to recover from consensus issues is eliminated
- Transaction processing throughput drops to minimum levels exactly when the chain needs maximum resilience
- Prolonged periods in this state could make the blockchain effectively unusable

**Affected Parties:**
- All network participants experience severely degraded performance
- Users cannot get transactions confirmed efficiently
- The entire blockchain's availability and liveness is compromised

**Severity Justification:** HIGH - This is a consensus-level denial of service that occurs during critical recovery periods, making bad situations catastrophically worse.

### Likelihood Explanation

**Realistic Scenario:**

The vulnerability activates when:
1. Blockchain enters Abnormal status (`currentRoundNumber > libRoundNumber + 2`)
2. Miner participation differs between rounds N-1 and N-2

This is realistic because:
- Abnormal status indicates the blockchain is already experiencing consensus difficulties
- During network partitions, different miner subsets may be active in different rounds
- Miner set changes, node failures, or network issues can prevent consistent participation
- The miner list is recorded based on who actually mined blocks [8](#0-7) 

**Entry Point:** The function is called from public consensus methods during block production. [9](#0-8) 

**Feasibility:** No attacker action required - this is triggered by natural network conditions during consensus stress, making it a design flaw vulnerability rather than an active exploit.

**Probability:** MEDIUM-HIGH during network disruptions or consensus issues, which are the exact scenarios where resilience is most critical.

### Recommendation

**Immediate Fix:**

Add a minimum floor value for the maximum blocks count in abnormal status:

```csharp
// In GetMaximumBlocksCount(), Abnormal status branch
var minersOfLastTwoRounds = previousRoundMinedMinerList
    .Intersect(previousPreviousRoundMinedMinerList).Count();
    
// Ensure at least 1 miner overlap to prevent zero factor
if (minersOfLastTwoRounds == 0)
{
    // Fallback to reduced but non-zero limit
    return Math.Max(1, AEDPoSContractConstants.MaximumTinyBlocksCount / 2);
}

var factor = minersOfLastTwoRounds.Mul(
    blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
        (int)currentRoundNumber.Sub(libRoundNumber)));
var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
    Math.Max(1, Ceiling(factor, currentRound.RealTimeMinersInformation.Count)));
```

**Additional Protections:**

1. Add null checks before accessing `MinedMinerListMap` entries [10](#0-9) 
2. Ensure `Ceiling` function never returns less than 1 when used for block count limits
3. Add invariant check: `Assert(count > 0, "Maximum blocks count must be positive")`

**Test Cases:**

1. Test with empty intersection (no common miners between rounds)
2. Test early rounds where previous round data may be missing
3. Test during miner set transitions
4. Test abnormal status recovery with various miner participation patterns

### Proof of Concept

**Initial State:**
- Blockchain in Abnormal status: `currentRoundNumber = 5, libRoundNumber = 2`
- Round 4 miners: [MinerA, MinerB]
- Round 3 miners: [MinerC, MinerD]
- Intersection: empty set (count = 0)

**Execution Steps:**

1. Miner calls `GetConsensusCommand()` to request next block production authorization
2. System invokes `GetMaximumBlocksCount()` [11](#0-10) 
3. Function determines status = Abnormal (5 > 2 + 2)
4. Retrieves miners from rounds 4 and 3
5. Calculates intersection: 0 miners
6. Computes `factor = 0 * (8 - 3) = 0`
7. Calls `Ceiling(0, minerCount) = 0`
8. Returns `Math.Min(8, 0) = 0`
9. Consensus behavior provider receives `_maximumBlocksCount = 0`
10. Condition `ActualMiningTimes.Count < 0` evaluates to false
11. Miner cannot produce tiny blocks

**Expected Result:** Miner should be able to produce at least 1 tiny block per time slot to maintain throughput during abnormal status.

**Actual Result:** Miner can produce zero tiny blocks, severely limiting blockchain progress during critical recovery period.

**Success Condition:** After fix, `GetMaximumBlocksCount()` returns at least 1 even with empty miner intersection, allowing continued block production.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L35-39)
```csharp
        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L42-55)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L81-85)
```csharp
    private static int Ceiling(int num1, int num2)
    {
        var flag = num1 % num2;
        return flag == 0 ? num1.Div(num2) : num1.Div(num2).Add(1);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-62)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L68-68)
```csharp
        var minersCountInTheory = GetMaximumBlocksCount();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L223-236)
```csharp
    private void RecordMinedMinerListOfCurrentRound()
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        State.MinedMinerListMap.Set(currentRound.RoundNumber, new MinerList
        {
            Pubkeys = { currentRound.GetMinedMiners().Select(m => ByteStringHelper.FromHexString(m.Pubkey)) }
        });

        // Remove information out of date.
        var removeTargetRoundNumber = currentRound.RoundNumber.Sub(3);
        if (removeTargetRoundNumber > 0 && State.MinedMinerListMap[removeTargetRoundNumber] != null)
            State.MinedMinerListMap.Remove(removeTargetRoundNumber);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L39-46)
```csharp
        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();
```
