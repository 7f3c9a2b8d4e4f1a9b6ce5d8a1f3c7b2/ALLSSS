### Title
Insufficient Threshold Validation in Referendum Contract Allows Creation of Permanently Non-Functional Governance Organizations

### Summary
The Referendum contract's `CreateOrganization` function lacks validation to ensure `ProposalReleaseThreshold` values are achievable relative to the token's total supply. This allows creation of organizations with approval thresholds that exceed available token supply, rendering them permanently unable to release any proposals and creating a governance deadlock for that organization.

### Finding Description

The vulnerability exists in the `Validate` method of the Referendum contract. [1](#0-0) 

The validation only checks:
- `MinimalApprovalThreshold <= MinimalVoteThreshold`
- `MinimalApprovalThreshold > 0`
- Token existence (but not its supply)

It does NOT validate whether the threshold values are achievable given the token's total or circulating supply.

In contrast, the Parliament contract validates thresholds against `AbstractVoteTotal` [2](#0-1)  and the Association contract validates against `organizationMemberCount` [3](#0-2) , ensuring thresholds cannot exceed what's physically possible.

When proposals attempt to be released, the system checks if approval count meets the threshold [4](#0-3) . If the threshold exceeds the total token supply, no amount of voting can ever satisfy this condition.

The `CreateOrganization` function is publicly accessible [5](#0-4)  and will create organizations that pass validation but are fundamentally broken.

### Impact Explanation

**Direct Impact:**
- Creates permanently non-functional governance organizations where no proposal can ever be released
- Violates the governance invariant that organizations with valid thresholds should be operable

**Potential Scenarios:**
1. **User Error**: Legitimate users accidentally set `MinimalApprovalThreshold` to values like `10^18` (intending percentage but providing absolute values), creating unusable organizations
2. **Governance Authority Deadlock**: If such an organization is set as a `MethodFeeController` or other governance authority [6](#0-5) , it creates permanent deadlock (though this requires current authority approval)
3. **Resource Waste**: Proposals created under such organizations lock tokens permanently until expiration, as they can never be released or meet thresholds

**Severity**: High for affected organizations - any proposal under such an organization becomes permanently stuck, and tokens locked for voting cannot be reclaimed until proposal expiration.

### Likelihood Explanation

**Reachable Entry Point**: `CreateOrganization` is a public function callable by anyone [5](#0-4) 

**Feasible Preconditions**: None required - any user can call this function with arbitrary threshold values

**Execution Practicality**: 
- Simple to execute: call `CreateOrganization` with `MinimalApprovalThreshold = 10^20` and `MinimalVoteThreshold = 10^20`
- Passes all validation: thresholds satisfy `MinimalApprovalThreshold <= MinimalVoteThreshold` and `> 0`
- Token supply in test environments is typically `10^16` [7](#0-6) , making thresholds of `10^18+` impossible

**Economic Rationality**: Low cost (just gas for organization creation), but limited direct harm unless the organization is adopted as a governance authority

**Likelihood**: Medium to High for accidental creation; Low for malicious exploitation requiring social engineering to get others to use the dysfunctional organization

### Recommendation

**Code-Level Mitigation**:
Add validation in the `Validate` method to check thresholds against token supply:

```csharp
private bool Validate(Organization organization)
{
    // Existing checks...
    var tokenInfo = GetTokenInfo(organization.TokenSymbol);
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    
    // Add validation against total supply
    return proposalReleaseThreshold.MinimalApprovalThreshold <= tokenInfo.TotalSupply &&
           proposalReleaseThreshold.MinimalVoteThreshold <= tokenInfo.TotalSupply &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

Location to modify: [1](#0-0) 

**Additional Checks**:
- Consider validating against circulating supply rather than total supply for more realistic limits
- Add upper bound constants (similar to Parliament's `AbstractVoteTotal`) if token supply is too large

**Test Cases**:
- Test organization creation with `MinimalApprovalThreshold > tokenInfo.TotalSupply` - should fail validation
- Test proposal release scenarios with edge-case thresholds near total supply
- Verify existing organizations with valid thresholds continue to function

### Proof of Concept

**Initial State**:
- ELF token exists with total supply = `100000000_00000000` (10^16)
- Attacker has standard user account

**Attack Steps**:
1. Attacker calls `CreateOrganization` with:
   - `TokenSymbol = "ELF"`
   - `MinimalApprovalThreshold = 10000000000000000000` (10^19, exceeds total supply)
   - `MinimalVoteThreshold = 10000000000000000000` (10^19)
   - `MaximalAbstentionThreshold = 0`
   - `MaximalRejectionThreshold = 0`
   - `ProposerWhiteList = [AttackerAddress]`

2. Organization is created successfully (validation passes)

3. Attacker creates a proposal under this organization

4. Even if all token holders (10^16 total supply) approve and lock tokens, `proposal.ApprovalCount` can never reach 10^19

5. `Release` call fails with "Not approved" error [8](#0-7)  because threshold check fails [9](#0-8) 

**Expected vs Actual**:
- Expected: Organization creation should fail validation if thresholds exceed token supply
- Actual: Organization is created, but permanently non-functional

**Success Condition**: Organization exists but no proposal can ever be released, confirming permanent governance deadlock.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L12-40)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            TokenSymbol = input.TokenSymbol,
            OrganizationHash = organizationHash,
            ProposerWhiteList = input.ProposerWhiteList,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization data.");

        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;

        State.Organizations[organizationAddress] = organization;
        Context.Fire(new OrganizationCreated
        {
            OrganizationAddress = organizationAddress
        });

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/ReferendumContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Referendum.Tests/ReferendumContractTestBase.cs (L135-135)
```csharp
        const long totalSupply = 100000000_00000000;
```
