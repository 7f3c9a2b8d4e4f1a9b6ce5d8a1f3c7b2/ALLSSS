### Title
Secret Sharing Data Loss During NextRound Transitions Due to Unpersisted State Modifications

### Summary
The `RevealSharedInValues` function modifies `currentRound` in-memory during NextRound transitions to reveal miners' previous in values, but these modifications are never persisted to contract state. This causes systematic data loss on every round transition, breaking the secret sharing mechanism used for consensus randomness generation and preventing recovery of missed miners' in values.

### Finding Description

The vulnerability exists in the NextRound consensus flow where secret sharing revelations are lost:

**Location 1: RevealSharedInValues modifies currentRound in-memory** [1](#0-0) 

The function sets `PreviousInValue` fields for miners in the provided `currentRound` object but does not persist these changes to state.

**Location 2: RevealSharedInValues called during block generation** [2](#0-1) 

At line 176, `nextRound` is generated from `currentRound`. At line 189, `RevealSharedInValues(currentRound, pubkey)` modifies the old round. However, only `nextRound` is returned (line 200-202) and eventually persisted.

**Location 3: Round generation creates new objects** [3](#0-2) 

`GenerateNextRoundInformation` creates entirely new `MinerInRound` objects (lines 29, 46) without copying `PreviousInValue` fields, meaning modifications to `currentRound` after generation cannot affect `nextRound`.

**Location 4: SupplyCurrentRoundInformation attempts to use missing data** [4](#0-3) 

At line 173, a fresh `currentRound` is read from state. At line 191, it attempts to read `PreviousInValue` fields that were never persisted, causing the recovery mechanism to fail.

**Root Cause:**
The `RevealSharedInValues` function operates during off-chain block generation (`GetConsensusBlockExtraData`) and modifies round data that is never written back to state. The modified `currentRound` object is discarded after the function returns, and only `nextRound` (generated before the modifications) is persisted via `AddRoundInformation`. [5](#0-4) 

The `ProcessNextRound` function (line 156) only persists the new round, not the modified current round.

### Impact Explanation

**Consensus Integrity Breakdown:**
- Secret sharing is designed to allow miners to reveal each other's previous in values through decryption of shared secret pieces
- These revealed values are critical for generating proper random numbers and recovering in values for miners who missed their time slots
- With revealed values lost on every NextRound transition, the consensus randomness generation is compromised

**Specific Harms:**
1. **Failed Miner Recovery**: When miners miss their slots, `SupplyCurrentRoundInformation` cannot use revealed `PreviousInValue` fields (line 191) because they were never saved, forcing use of fallback fake values (line 208)
2. **Randomness Degradation**: The consensus random hash generation depends on proper in value chains; lost revelations break this chain
3. **Secret Sharing Mechanism Failure**: The entire purpose of encrypted/decrypted pieces becomes meaningless if revelations aren't persisted

**Severity Justification:**
HIGH - This systematically breaks a core consensus security mechanism (secret sharing) on every round transition, affecting all miners and compromising the integrity of consensus randomness generation. While blocks continue to be produced, the security guarantees of the secret sharing protocol are violated.

### Likelihood Explanation

**Automatic Exploitation:**
- No attacker action required
- Occurs automatically on every NextRound transition
- 100% reproducible under normal consensus operation

**Attack Complexity:**
- None - this is a systematic logic bug, not an exploit
- Happens during normal validator operations
- No special preconditions or timing required

**Feasibility:**
- The bug executes with every round change (every few minutes typically)
- All miners are affected equally
- No detection mechanisms exist because it appears as normal operation

**Probability:**
CERTAIN - The vulnerability is triggered on every single NextRound transition. Given that rounds transition regularly (typically every few minutes based on mining intervals), this bug manifests hundreds of times per day across the entire network.

### Recommendation

**Code-Level Fix:**

Modify `GetConsensusExtraDataForNextRound` to either:

**Option 1 (Preferred):** Call `RevealSharedInValues` with `nextRound` instead of `currentRound`, and ensure the revealed values are copied to the appropriate round:

```
Change line 189 from:
RevealSharedInValues(currentRound, pubkey);

To:
RevealSharedInValuesForNextRound(currentRound, nextRound, pubkey);
```

And create a new function that properly sets revealed values in `nextRound` based on `previousRound` (which is the current round from the perspective of next round).

**Option 2:** Persist the modified `currentRound` to state before generating `nextRound`:

```
After line 189, add:
TryToUpdateRoundInformation(currentRound);
```

However, this requires ensuring the modifications happen in a transaction context, not during off-chain block generation.

**Invariant Checks:**
1. Add assertion: After `AddRoundInformation(nextRound)`, verify that miners who had sufficient encrypted/decrypted pieces in the previous round have non-null/non-empty `PreviousInValue` fields
2. Add test: Verify that secret revelations from round N are available when processing round N+1

**Test Cases:**
1. Create round with multiple miners producing blocks with encrypted pieces
2. Trigger NextRound transition
3. Verify that SupplyCurrentRoundInformation in the new round can read the revealed PreviousInValue fields
4. Confirm that miners who missed slots can have their in values properly recovered using the revealed values

### Proof of Concept

**Initial State:**
- Round N in progress with 5 miners
- All miners have produced blocks with encrypted/decrypted secret pieces
- Secret sharing is enabled

**Exploitation Steps:**

1. **Round N completes**: Extra block producer triggers NextRound
   - `GetConsensusExtraDataForNextRound` is called
   - `GenerateNextRoundInformation` creates round N+1 object
   - `RevealSharedInValues(currentRound, pubkey)` reveals in values in round N object (in-memory only)
   - Round N+1 returned without the revealed values

2. **Round N+1 begins**: First miner produces block
   - `SupplyCurrentRoundInformation` reads round N+1 from state
   - Line 191 attempts to read `PreviousInValue` for miners
   - **Expected**: Revealed in values from RevealSharedInValues are available
   - **Actual**: `PreviousInValue` fields are null/empty because revelations were never persisted

3. **Verification**: Check state after step 2
   - Query `State.Rounds[N+1].RealTimeMinersInformation[minerKey].PreviousInValue` for all miners
   - **Success Condition**: All values are null/empty despite RevealSharedInValues having "revealed" them
   - This confirms the secret sharing data was lost during the transition

**Observable Impact:**
- Miners who miss slots cannot have their in values properly recovered
- `SupplyCurrentRoundInformation` falls back to fake in values (line 208) instead of using revealed values
- Secret sharing mechanism provides no benefit despite computational overhead of encryption/decryption

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L171-220)
```csharp
    private void SupplyCurrentRoundInformation()
    {
        var currentRound = GetCurrentRoundInformation(new Empty());
        Context.LogDebug(() => $"Before supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
        var notMinedMiners = currentRound.RealTimeMinersInformation.Values.Where(m => m.OutValue == null).ToList();
        if (!notMinedMiners.Any()) return;
        TryToGetPreviousRoundInformation(out var previousRound);
        foreach (var miner in notMinedMiners)
        {
            Context.LogDebug(() => $"Miner pubkey {miner.Pubkey}");

            Hash previousInValue = null;
            Hash signature = null;

            // Normal situation: previous round information exists and contains this miner.
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
            }

            if (previousInValue == null)
            {
                // Handle abnormal situation.

                // The fake in value shall only use once during one term.
                previousInValue = HashHelper.ComputeFrom(miner);
                signature = previousInValue;
            }

            // Fill this two fields at last.
            miner.InValue = previousInValue;
            miner.Signature = signature;

            currentRound.RealTimeMinersInformation[miner.Pubkey] = miner;
        }

        TryToUpdateRoundInformation(currentRound);
        Context.LogDebug(() => $"After supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```
