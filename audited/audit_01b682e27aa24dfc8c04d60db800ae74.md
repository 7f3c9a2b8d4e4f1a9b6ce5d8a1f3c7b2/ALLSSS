### Title
Permanent Method Fee Control Deadlock Due to Missing Initialization Validation in RequiredMethodFeeControllerSet

### Summary
The Parliament contract's `RequiredMethodFeeControllerSet()` method lacks validation that `State.DefaultOrganizationAddress.Value` is properly initialized before using it to set the method fee controller. If any ACS1 method (`GetMethodFeeController`, `SetMethodFee`, or `ChangeMethodFeeController`) is called before the `Initialize()` method properly sets this value, the fee controller's `OwnerAddress` becomes permanently set to a zero/null address that no one controls, creating an irreversible governance deadlock where method fees can never be modified.

### Finding Description

The vulnerability exists in the `RequiredMethodFeeControllerSet()` private method: [1](#0-0) 

This method directly uses `State.DefaultOrganizationAddress.Value` (line 68) without validating it's non-null. The method is called by all ACS1 interface methods: [2](#0-1) [3](#0-2) [4](#0-3) 

The `State.DefaultOrganizationAddress.Value` is only set during initialization: [5](#0-4) 

**Root Cause:** Unlike other system contracts (Association, Configuration, etc.) which call `Parliament.GetDefaultOrganizationAddress()` to obtain the default organization (which includes an initialization check), Parliament's own `RequiredMethodFeeControllerSet()` directly accesses `State.DefaultOrganizationAddress.Value` without validation: [6](#0-5) [7](#0-6) 

**Execution Path:**
1. Parliament contract deployed but `Initialize()` not yet called (possible in non-standard deployments)
2. Any user calls `GetMethodFeeController()`, `SetMethodFee()`, or `ChangeMethodFeeController()`
3. `RequiredMethodFeeControllerSet()` executes with null `State.DefaultOrganizationAddress.Value`
4. Creates `AuthorityInfo` with `OwnerAddress = null` (zero address)
5. Sets `State.MethodFeeController.Value` to this permanently
6. Subsequent `Initialize()` call sets `State.DefaultOrganizationAddress.Value`, but `State.MethodFeeController.Value` is already set and never reset
7. All future fee control operations require `Context.Sender == null address`, which is impossible

### Impact Explanation

**Harm:** Complete and permanent loss of method fee governance control for the Parliament contract. Once triggered, the contract cannot:
- Update method fees via `SetMethodFee()`
- Change the fee controller via `ChangeMethodFeeController()`
- Recover through any means, as the owner address is locked to a zero address

**Who is Affected:** 
- Parliament governance system loses ability to adjust transaction fees
- Entire blockchain governance is compromised as Parliament is a core system contract
- All proposals requiring fee adjustments become impossible to execute

**Severity Justification:** CRITICAL - This creates an irreversible governance deadlock. Unlike other vulnerabilities that can be mitigated through upgrades or governance actions, once the fee controller is set to a zero address, no recovery mechanism exists. The Parliament contract's fee structure becomes permanently immutable.

### Likelihood Explanation

**Attacker Capabilities Required:** 
- Minimal - Any user can call `GetMethodFeeController()` (a view function) or attempt fee-related operations
- No special privileges needed to trigger the vulnerability

**Preconditions:**
1. Parliament contract deployed without proper initialization
2. At least one call to any ACS1 method before `Initialize()` executes

**Feasibility:**
- **Standard Production Deployment:** Very Low - The production initialization provider guarantees `Initialize()` is in the deployment transaction method call list [8](#0-7) 
  
- **Non-Standard Deployments:** High - Test environments, side chains, and manual deployments may separate deployment from initialization [9](#0-8) 

**Probability:** While standard production deployments have protections, the vulnerability represents a critical defensive programming failure. Any deployment scenario that doesn't follow the exact standard pattern (side chain deployments, test environments being promoted to production, emergency redeployments, etc.) could trigger this irreversible deadlock.

### Recommendation

**Code-Level Mitigation:**
Add validation in `RequiredMethodFeeControllerSet()` to ensure `State.DefaultOrganizationAddress.Value` is properly initialized before using it:

```csharp
private void RequiredMethodFeeControllerSet()
{
    if (State.MethodFeeController.Value != null) return;
    
    // Add this validation
    Assert(State.DefaultOrganizationAddress.Value != null && 
           !State.DefaultOrganizationAddress.Value.Value.IsNullOrEmpty(), 
           "Parliament contract not properly initialized.");

    var defaultAuthority = new AuthorityInfo
    {
        OwnerAddress = State.DefaultOrganizationAddress.Value,
        ContractAddress = Context.Self
    };

    State.MethodFeeController.Value = defaultAuthority;
}
```

**Alternative Approach:**
Follow the pattern used by other contracts - call `GetDefaultOrganizationAddress()` which already includes initialization validation, or check `State.Initialized.Value` before proceeding.

**Invariant Check to Add:**
- Assert that `State.DefaultOrganizationAddress.Value` is non-null before creating the `AuthorityInfo`
- Consider adding `Assert(State.Initialized.Value, "Not initialized.")` similar to `GetDefaultOrganizationAddress()`

**Test Case:**
Add a test that attempts to call `GetMethodFeeController()` on a deployed-but-uninitialized Parliament contract and verifies it properly rejects the call rather than setting a null owner address.

### Proof of Concept

**Required Initial State:**
- Parliament contract deployed using non-standard deployment method (bypassing `ParliamentContractInitializationProvider`)
- `State.DefaultOrganizationAddress.Value` is null
- `State.Initialized.Value` is false

**Transaction Steps:**
1. Deploy Parliament contract code without calling `Initialize()`
2. Call `GetMethodFeeController()` from any address
3. Observe `State.MethodFeeController.Value.OwnerAddress` is set to zero address
4. Call `Initialize()` with proper parameters
5. Observe `State.DefaultOrganizationAddress.Value` is now set to valid organization
6. Attempt to call `SetMethodFee()` from the valid organization address
7. Transaction fails because `Context.Sender != State.MethodFeeController.Value.OwnerAddress` (zero address)

**Expected Result:** Step 2 should fail with "Parliament contract not properly initialized" error

**Actual Result:** Step 2 succeeds and permanently locks fee control to an uncontrollable address, making step 6 and all future fee modifications impossible

**Success Condition:** The vulnerability is confirmed when `State.MethodFeeController.Value.OwnerAddress` becomes permanently set to a zero/null address before proper initialization, with no recovery mechanism available.

### Notes

This vulnerability is particularly insidious because:
1. It can be triggered by any user calling a seemingly innocuous view function (`GetMethodFeeController`)
2. The damage is permanent and irreversible - no contract upgrade or governance action can recover fee control
3. Parliament is a fundamental system contract, so this affects the entire blockchain's governance capability
4. The lazy initialization pattern is secure in other contracts (Association, Configuration) because they call Parliament's protected `GetDefaultOrganizationAddress()` method, but Parliament's own implementation lacks self-protection

While standard production deployments include proper initialization, the absence of defensive validation creates unacceptable risk in any non-standard deployment scenario or potential future deployment process changes.

### Citations

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L10-18)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L46-50)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L62-73)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.DefaultOrganizationAddress.Value,
            ContractAddress = Context.Self
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L11-36)
```csharp
    public override Empty Initialize(InitializeInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        var proposerWhiteList = new ProposerWhiteList();

        if (input.PrivilegedProposer != null)
            proposerWhiteList.Proposers.Add(input.PrivilegedProposer);

        State.ProposerWhiteList.Value = proposerWhiteList;
        var organizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = DefaultOrganizationMinimalApprovalThreshold,
                MinimalVoteThreshold = DefaultOrganizationMinimalVoteThresholdThreshold,
                MaximalAbstentionThreshold = DefaultOrganizationMaximalAbstentionThreshold,
                MaximalRejectionThreshold = DefaultOrganizationMaximalRejectionThreshold
            },
            ProposerAuthorityRequired = input.ProposerAuthorityRequired,
            ParliamentMemberProposingAllowed = true
        };
        var defaultOrganizationAddress = CreateNewOrganization(organizationInput);
        State.DefaultOrganizationAddress.Value = defaultOrganizationAddress;
        return new Empty();
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L250-254)
```csharp
    public override Address GetDefaultOrganizationAddress(Empty input)
    {
        Assert(State.Initialized.Value, "Not initialized.");
        return State.DefaultOrganizationAddress.Value;
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L49-63)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** src/AElf.GovernmentSystem/ParliamentContractInitializationProvider.cs (L24-39)
```csharp
    public List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        var initializationData = _parliamentContractInitializationDataProvider.GetContractInitializationData();
        return new List<ContractInitializationMethodCall>
        {
            new()
            {
                MethodName = nameof(ParliamentContractContainer.ParliamentContractStub.Initialize),
                Params = new InitializeInput
                {
                    PrivilegedProposer = initializationData.PrivilegedProposer,
                    ProposerAuthorityRequired = initializationData.ProposerAuthorityRequired
                }.ToByteString()
            }
        };
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTestBase.cs (L65-77)
```csharp
        ParliamentContractAddress = AsyncHelper.RunSync(() =>
            DeploySystemSmartContract(
                KernelConstants.CodeCoverageRunnerCategory,
                ParliamentCode,
                ParliamentSmartContractAddressNameProvider.Name,
                DefaultSenderKeyPair
            ));
        ParliamentContractStub = GetParliamentContractTester(DefaultSenderKeyPair);
        AsyncHelper.RunSync(() => ParliamentContractStub.Initialize.SendAsync(new InitializeInput
        {
            ProposerAuthorityRequired = false,
            PrivilegedProposer = DefaultSender
        }));
```
