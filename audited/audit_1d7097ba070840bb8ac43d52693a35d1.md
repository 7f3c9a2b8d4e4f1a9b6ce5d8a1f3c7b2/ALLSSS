### Title
Premature Dividend Distribution Due to Unsynced Period Value in Side Chain Release Check

### Summary
The `Release()` function in the side chain dividends pool uses an unsynced `scheme.Period` value that starts at 0 instead of 1, causing the time-based release check `elapsed_periods > scheme.Period - 1` to evaluate to `elapsed_periods > -1`, which is always true. This results in the first dividend distribution occurring immediately after round 1 completes (typically within minutes of blockchain start) instead of after the first configured period elapses (e.g., 7 days).

### Finding Description

The vulnerability exists in the `Release()` method's period comparison logic: [1](#0-0) 

The method retrieves the TokenHolder scheme via `GetScheme`, which is a view method that returns cached state without synchronization: [2](#0-1) 

**Root Cause:** When the TokenHolder scheme is created during initialization, the `Period` field is never explicitly set and defaults to 0: [3](#0-2) 

However, the underlying Profit scheme's `CurrentPeriod` is initialized to 1: [4](#0-3) 

The `Period` field only gets synchronized with `CurrentPeriod` when `UpdateTokenHolderProfitScheme` is called with `updateSchemePeriod=true`: [5](#0-4) 

This synchronization happens during `DistributeProfits` (after the first release is triggered), but NOT during the `GetScheme` view call used in the release check.

**Execution Path:**
1. Side chain initializes with profit scheme: [6](#0-5) 

2. Release() is called automatically on every consensus operation after round 1: [7](#0-6) 

3. First check evaluates: `0 > (0 - 1)` = `0 > -1` = **true**, triggering immediate release

4. After first distribution, Period syncs to CurrentPeriod and increments, future checks work correctly

### Impact Explanation

**Direct Impact:**
- Dividends accumulated before the first period completes are distributed prematurely to beneficiaries
- If the configured period is 7 days but release occurs after 1 minute, beneficiaries receive their shares approximately 10,080 minutes (7 days) early
- This breaks the intended time-lock mechanism for dividend distribution

**Affected Parties:**
- All side chains using the dividend pool mechanism
- Beneficiaries receive unexpected early distributions
- The economic model's time-based vesting schedule is violated

**Severity Justification:**
- **Medium severity** - while no funds are stolen or lost, the timing invariant for dividend distribution is broken, potentially affecting economic incentives and expectations
- The first period's dividends are distributed without the intended time delay, violating the contract's economic design

### Likelihood Explanation

**Exploitability:**
- **100% reproducible** - this is not an exploit but an automatic bug that occurs on every side chain
- No attacker action required - the premature release happens automatically
- Occurs immediately after round 1 completes (typically within the first few blocks/minutes of operation)

**Preconditions:**
- Side chain must be initialized (happens during genesis)
- Round number must exceed 1 (happens naturally during consensus)
- TokenHolder contract must be deployed (standard deployment)

**Detection:**
- The premature distribution can be observed by monitoring the first `DistributeProfits` transaction timing
- Expected: first distribution after `PeriodSeconds` elapsed
- Actual: first distribution shortly after blockchain start

### Recommendation

**Fix 1: Sync Period Before Comparison**
Modify the `Release()` method to use the synchronized Period value or directly query the underlying Profit scheme's `CurrentPeriod`:

```csharp
public void Release()
{
    if (State.TokenHolderContract.Value == null) return;
    var scheme = State.TokenHolderContract.GetScheme.Call(Context.Self);
    
    // Get the actual CurrentPeriod from the underlying Profit scheme
    var profitScheme = Context.Call<Scheme>(
        Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName),
        nameof(ProfitContractContainer.ProfitContractReferenceState.GetScheme),
        scheme.SchemeId);
    
    var isTimeToRelease =
        (Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
        .Div(State.PeriodSeconds.Value) >= profitScheme.CurrentPeriod;
    
    if (isTimeToRelease)
    {
        State.TokenHolderContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeManager = Context.Self
        });
    }
}
```

**Fix 2: Initialize Period Correctly**
Update `CreateScheme` in TokenHolder to explicitly synchronize Period immediately after scheme creation.

**Invariant Checks:**
- Add assertion: `scheme.Period >= 0` and should equal underlying `CurrentPeriod` before first distribution
- Add unit test verifying first release occurs after full period elapses, not immediately

**Test Cases:**
1. Test that first dividend release does NOT occur before one full period has elapsed
2. Test that `elapsed_periods` calculation matches expected timing
3. Test that Period synchronization happens before first comparison

### Proof of Concept

**Initial State:**
- Side chain initialized with `PeriodSeconds = 604800` (7 days)
- Blockchain starts at timestamp T0
- TokenHolder scheme created with `Period = 0` (default)
- Underlying Profit scheme has `CurrentPeriod = 1`

**Transaction Steps:**

1. **Genesis block (height 0):**
   - `InitialAElfConsensusContract` called with `IsSideChain = true` [8](#0-7) 
   
   - Creates dividend pool scheme with `Period = 0`

2. **Round 1 completes, Round 2 begins (height ~10-100):**
   - `ProcessConsensusInformation` executes
   - `Release()` called because `currentRound.RoundNumber > 1`
   
3. **Release() evaluation at T0 + 60 seconds:**
   - `elapsed_periods = 60 / 604800 = 0`
   - `scheme.Period = 0` (unsynced cached value)
   - Check: `0 > (0 - 1)` = `0 > -1` = **true**
   - `DistributeProfits` triggered prematurely

**Expected Result:**
First distribution should occur at T0 + 604800 seconds (7 days)

**Actual Result:**
First distribution occurs at T0 + ~60 seconds (1 minute)

**Success Condition:**
Monitor the timestamp of the first `DistributeProfits` transaction on a side chain. If it occurs within minutes/hours instead of after the full `PeriodSeconds` duration, the vulnerability is confirmed.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L16-35)
```csharp
    private void InitialProfitSchemeForSideChain(long periodSeconds)
    {
        var tokenHolderContractAddress =
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName);
        // No need to continue if Token Holder Contract didn't deployed.
        if (tokenHolderContractAddress == null)
        {
            Context.LogDebug(() => "Token Holder Contract not found, so won't initial side chain dividends pool.");
            return;
        }

        State.TokenHolderContract.Value = tokenHolderContractAddress;
        State.TokenHolderContract.CreateScheme.Send(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = AEDPoSContractConstants.SideChainShareProfitsTokenSymbol,
            MinimumLockMinutes = periodSeconds.Div(60)
        });

        Context.LogDebug(() => "Side chain dividends pool created.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L102-122)
```csharp
    public void Release()
    {
        if (State.TokenHolderContract.Value == null) return;
        var scheme = State.TokenHolderContract.GetScheme.Call(Context.Self);
        var isTimeToRelease =
            (Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.PeriodSeconds.Value) > scheme.Period - 1;
        Context.LogDebug(() => "ReleaseSideChainDividendsPool Information:\n" +
                               $"CurrentBlockTime: {Context.CurrentBlockTime}\n" +
                               $"BlockChainStartTime: {State.BlockchainStartTimestamp.Value}\n" +
                               $"PeriodSeconds: {State.PeriodSeconds.Value}\n" +
                               $"Scheme Period: {scheme.Period}");
        if (isTimeToRelease)
        {
            Context.LogDebug(() => "Ready to release side chain dividends pool.");
            State.TokenHolderContract.DistributeProfits.Send(new DistributeProfitsInput
            {
                SchemeManager = Context.Self
            });
        }
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L259-262)
```csharp
    public override TokenHolderProfitScheme GetScheme(Address input)
    {
        return State.TokenHolderProfitSchemes[input];
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L938-954)
```csharp
    private Scheme GetNewScheme(CreateSchemeInput input, Hash schemeId, Address manager)
    {
        var scheme = new Scheme
        {
            SchemeId = schemeId,
            // The address of general ledger for current profit scheme.
            VirtualAddress = Context.ConvertVirtualAddressToContractAddress(schemeId),
            Manager = manager,
            ProfitReceivingDuePeriodCount = input.ProfitReceivingDuePeriodCount,
            CurrentPeriod = 1,
            IsReleaseAllBalanceEveryTimeByDefault = input.IsReleaseAllBalanceEveryTimeByDefault,
            DelayDistributePeriodCount = input.DelayDistributePeriodCount,
            CanRemoveBeneficiaryDirectly = input.CanRemoveBeneficiaryDirectly
        };

        return scheme;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L83-83)
```csharp
        if (!State.IsMainChain.Value && currentRound.RoundNumber > 1) Release();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L22-41)
```csharp
    public override Empty InitialAElfConsensusContract(InitialAElfConsensusContractInput input)
    {
        Assert(State.CurrentRoundNumber.Value == 0 && !State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        State.PeriodSeconds.Value = input.IsTermStayOne
            ? int.MaxValue
            : input.PeriodSeconds;

        State.MinerIncreaseInterval.Value = input.MinerIncreaseInterval;

        Context.LogDebug(() => $"There are {State.PeriodSeconds.Value} seconds per period.");

        if (input.IsSideChain) InitialProfitSchemeForSideChain(input.PeriodSeconds);

        if (input.IsTermStayOne || input.IsSideChain)
        {
            State.IsMainChain.Value = false;
            return new Empty();
        }
```
