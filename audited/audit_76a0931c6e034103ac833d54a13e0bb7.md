### Title
Threshold Mismatch in Secret Sharing Reconstruction on Side Chains Leads to Consensus Integrity Compromise

### Summary
The `RevealSharedInValues` function incorrectly calculates the Shamir secret sharing threshold using the current round's miner count instead of the previous round's miner count. On side chains, when the main chain updates its miner list, this causes a threshold mismatch between secret encoding and decoding, resulting in incorrect secret reconstruction and corrupted consensus random number generation.

### Finding Description

The vulnerability exists in the `RevealSharedInValues` function where the threshold calculation uses the wrong round's miner count. [1](#0-0) 

The function calculates `minimumCount` from `currentRound.RealTimeMinersInformation.Count`, but it should use `previousRound.RealTimeMinersInformation.Count` because the secrets being decoded were originally encoded in the previous round with that round's threshold.

This contrasts with the correct implementation in `SecretSharingService`: [2](#0-1) 

The secret encoding uses the previous round's miner count to determine the threshold: [3](#0-2) 

**Exploitation Path on Side Chains:**

Side chains can update their miner list from the main chain via cross-chain updates: [4](#0-3) 

When the main chain miner list changes, the side chain's round generation detects this and creates a new round with the updated miner count: [5](#0-4) 

Subsequently, when `RevealSharedInValues` is called during the next regular round transition: [6](#0-5) 

The function attempts to decode secrets from a round with N miners using a threshold calculated from a round with M miners (where M ≠ N), violating the fundamental requirement of Shamir's secret sharing.

Additionally, line 36 uses the wrong miner count for validation: [7](#0-6) 

This check compares decrypted pieces from the previous round against the current round's miner count, which is incorrect.

### Impact Explanation

**Consensus Integrity Compromise:**
The Shamir secret sharing scheme requires the same threshold for both encoding and decoding. Using different thresholds produces incorrect results: [8](#0-7) 

When the threshold parameter doesn't match the encoding threshold, the Lagrange interpolation in `DecodeSecret` reconstructs an incorrect secret value.

**Concrete Harm:**
1. The incorrectly decoded value is stored as `PreviousInValue` for other miners: [9](#0-8) 

2. These corrupted `PreviousInValue` entries pollute the consensus state and affect random number generation used for extra block producer selection and other consensus decisions.

3. This breaks the consensus randomness invariant, potentially allowing manipulation of miner selection order and compromising the fairness guarantees of the AEDPoS consensus mechanism.

**Who is Affected:**
All side chains in the AElf ecosystem are vulnerable whenever the main chain undergoes a term transition that changes the miner count (which happens regularly as demonstrated in the test suite): [10](#0-9) 

### Likelihood Explanation

**High Likelihood - Occurs Automatically:**

This vulnerability triggers automatically without requiring any attacker action:

1. **Reachable Entry Point:** The vulnerability is in the consensus flow executed by every miner during normal block production via `GetConsensusExtraData`.

2. **Feasible Preconditions:**
   - Side chain must be running (standard configuration)
   - Main chain undergoes a term transition (happens regularly per test evidence)
   - Side chain syncs the new miner list via `UpdateInformationFromCrossChain`
   
3. **Execution Practicality:** The bug triggers during the first regular round after the side chain adopts a new miner count from the main chain. No special conditions or attacker involvement required.

4. **Frequency:** Main chain term transitions occur at regular intervals (test shows it happens multiple times as miner count increases), making this a recurring issue.

**Detection:** The bug manifests as consensus state corruption that may go undetected initially but accumulates over time, affecting consensus randomness quality and potentially causing consensus failures.

### Recommendation

**Fix the threshold calculation to use previousRound's miner count:**

```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    Context.LogDebug(() => "About to reveal shared in values.");
    
    if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;
    
    if (!TryToGetPreviousRoundInformation(out var previousRound)) return;
    
    // FIX: Use previousRound's miner count instead of currentRound's
    var minersCount = previousRound.RealTimeMinersInformation.Count;
    var minimumCount = minersCount.Mul(2).Div(3);
    minimumCount = minimumCount == 0 ? 1 : minimumCount;
    
    foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
    {
        // ... rest of the code
    }
}
```

**Additional Invariant Check:**
Add validation that the decoded secret produces a valid hash before storing it as `PreviousInValue`.

**Test Case:**
Add a test that simulates a side chain receiving a main chain miner list update and verifies that secret reconstruction continues to work correctly across the miner count change boundary.

### Proof of Concept

**Initial State:**
- Side chain running with 7 miners
- Round N-1: Miners encode their secrets with threshold = ⌊7 × 2/3⌋ = 4
- Round N: Still 7 miners, secrets stored in encrypted/decrypted pieces

**Attack Sequence:**
1. Main chain undergoes term transition, miner count increases from 7 to 9
2. Cross-chain contract calls `UpdateInformationFromCrossChain` on side chain
3. Side chain's `State.MainChainCurrentMinerList` updated to 9 miners
4. Round N+1: `GenerateNextRoundInformation` detects miner list change, creates new round with 9 miners
5. Round N+2: Miner calls `GetConsensusExtraData` for `NextRound` behavior
6. `RevealSharedInValues(currentRound=N+1, pubkey)` is invoked
7. Function calculates `minimumCount = ⌊9 × 2/3⌋ = 6` using Round N+1's count
8. Function attempts to decode secrets from Round N (encoded with threshold 4)
9. `DecodeSecret` called with threshold=6 on data encoded with threshold=4

**Expected Result:**
Secrets decoded with correct threshold=4, producing valid `PreviousInValue` hashes.

**Actual Result:**
Secrets decoded with incorrect threshold=6, producing corrupted `PreviousInValue` values that corrupt consensus state and break randomness guarantees.

**Success Condition:**
Comparing the hash of the decoded secret against the expected in-value would show mismatch, proving incorrect reconstruction.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-36)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L101-104)
```csharp
        var minersCount = secretSharingInformation.PreviousRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        var secretShares =
            SecretSharingHelper.EncodeSecret(newInValue.ToByteArray(), minimumCount, minersCount);
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L146-149)
```csharp
        var round = secretSharingInformation.PreviousRound;
        var minersCount = round.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L57-61)
```csharp
        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-294)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L176-189)
```csharp
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/BVT/MinersCountTest.cs (L117-118)
```csharp
            minerCount = currentRound.RealTimeMinersInformation.Count;
            Assert.Equal(AEDPoSContractTestConstants.SupposedMinersCount.Add(termCount.Mul(2)), minerCount);
```
