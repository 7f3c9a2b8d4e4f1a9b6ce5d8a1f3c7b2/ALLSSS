### Title
Treasury Funds Permanently Locked When Multiple Terms Are Skipped During Network Outage

### Summary
When the consensus round has expired multiple terms ago (e.g., during extended network outage), `ArrangeAbnormalMiningTime` correctly calculates future mining times accounting for missed rounds, but `GenerateFirstRoundOfNewTerm` only increments the term number by 1. This causes intermediate terms to be skipped entirely, preventing their treasury releases from ever executing and permanently locking mining rewards and transaction fees intended for those periods.

### Finding Description

The vulnerability exists in the interaction between three components:

**1. Time Arrangement Calculation:** [1](#0-0) 

When `CurrentRound` has expired multiple rounds ago, `ArrangeAbnormalMiningTime` calculates `missedRoundsCount` by dividing the elapsed time by the total round duration, then arranges mining time at `RoundStartTime + (missedRoundsCount + 1) * TotalMilliseconds`. The comment explicitly states this handles miners offline for many rounds: [2](#0-1) 

**2. Term Transition Only Increments By One:** [3](#0-2) 

When `NextTerm` behavior is triggered, `GenerateFirstRoundOfNewTerm` only increments `TermNumber` by 1, regardless of how many terms worth of time have actually elapsed.

**3. Treasury Release Tied to Term Numbers:** [4](#0-3) 

During `ProcessNextTerm`, the treasury release is called with the previous term number. Each term transition only releases funds for one specific period number.

**Execution Path:**
1. Network halts for 21+ days (3 terms at 7 days each)
2. Miner requests consensus command via `GetConsensusCommand`: [5](#0-4) 

3. Behavior provider determines `NextTerm` is needed: [6](#0-5) 

4. `TerminateRoundCommandStrategy` uses `ArrangeExtraBlockMiningTime`: [7](#0-6) 

5. Mining time is arranged far in future, but term only advances from 1→2 (should be 1→4)
6. Terms 2 and 3 are skipped, their treasury releases never execute

### Impact Explanation

**Direct Financial Loss:**
- Mining rewards constitute a portion of the 20% total ELF supply allocated over time [8](#0-7) 

- Each skipped term's accumulated rewards (mining rewards + transaction fees + resource consumption) remain locked in profit schemes forever
- The `DistributeProfits` calls for skipped period numbers will never be executed: [9](#0-8) 

**Affected Parties:**
- Miners lose basic rewards, welcome rewards, and flexible rewards for skipped terms
- Citizens lose welfare distributions for skipped terms  
- Backup candidates lose subsidy payments for skipped terms

**Election Integrity:**
Election snapshots are tied to term numbers and would be missing for skipped terms: [10](#0-9) 

### Likelihood Explanation

**Trigger Conditions:**
- Requires network-wide consensus halt lasting multiple term periods (21+ days for 3 terms)
- Can occur from: all miners offline simultaneously, network partition, critical consensus bug, or coordinated halt

**Execution Complexity:**
- Not an intentional attack, but a design flaw in extended outage recovery
- Automatically triggers when first miner resumes after multi-term gap
- No special permissions or complex transactions required

**Probability Assessment:**
- Medium likelihood: While extended outages are uncommon, blockchain networks have experienced multi-day halts
- AElf mainnet uses 7-day terms, making multi-term gaps realistic in crisis scenarios
- Impact severity increases linearly with outage duration

**Detection:**
- Skipped terms would be observable on-chain through discontinuous term number progression
- Locked treasury funds would appear in profit scheme balances but never distribute

### Recommendation

**1. Implement Multi-Term Catch-Up Logic:**
Calculate the actual target term based on elapsed time in `GenerateFirstRoundOfNewTerm`:
```
var elapsedSeconds = (currentBlockTime - blockchainStartTimestamp).Seconds;
var targetTermNumber = elapsedSeconds.Div(periodSeconds) + 1;
```

**2. Execute Treasury Releases for All Skipped Terms:**
In `ProcessNextTerm`, iterate through all skipped terms and trigger treasury releases:
```csharp
var currentTerm = currentRound.TermNumber;
var targetTerm = CalculateExpectedTerm(currentBlockTime, blockchainStartTimestamp, periodSeconds);
for (var term = currentTerm + 1; term <= targetTerm; term++) {
    State.TreasuryContract.Release.Send(new ReleaseInput { PeriodNumber = term - 1 });
}
```

**3. Add Invariant Check:**
Assert that term number progression doesn't skip more than one term under normal circumstances, with exception handling for recovery scenarios.

**4. Test Coverage:**
Add regression tests simulating:
- Network halt spanning 2-5 term periods
- Verify all skipped terms receive treasury releases
- Verify election snapshots are properly recorded or handled
- Verify term number alignment with elapsed time

### Proof of Concept

**Initial State:**
- Term 1, Round 100
- Period seconds = 604800 (7 days)
- Blockchain start timestamp = T₀
- Current time = T₀ + 21 days (3 terms elapsed)
- All miners offline, no blocks produced

**Execution Steps:**
1. Miner A comes online at T₀ + 21 days
2. Calls `GetConsensusCommand` → returns `NextTerm` behavior
3. Mines termination block with consensus extra data
4. `ProcessNextTerm` executes:
   - Updates term from 1 → 2 (not 1 → 4 as expected)
   - Calls `Treasury.Release(PeriodNumber=1)`
   - Terms 2 and 3 never get releases

**Expected Result:**
- Terms 1, 2, 3 should all receive treasury releases
- Term number should advance to 4

**Actual Result:**  
- Only term 1 receives treasury release
- Term number advances to 2
- Funds for terms 2 and 3 remain locked in treasury profit schemes
- Subsequent term transitions (2→3, 3→4) will not retroactively release skipped term funds

**Success Condition:**
Query profit scheme balances and distributed periods - terms 2 and 3 show undistributed accumulated profits with no mechanism to release them.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L33-36)
```csharp
        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L44-47)
```csharp
    /// <summary>
    ///     This method for now is able to handle the situation of a miner keeping offline so many rounds,
    ///     by using missedRoundsCount.
    /// </summary>
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L40-41)
```csharp
        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L25-26)
```csharp
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L19-26)
```csharp
///     The Treasury is the largest profit scheme in AElf main chain.
///     Actually the Treasury is our Dividends Pool.
///     Income of the Treasury is mining rewards
///     (AEDPoS Contract will:
///     1. transfer ELF tokens to general ledger of Treasury every time we change term (7 days),
///     the amount of ELF should be based on blocks produced during last term. 1,000,000 * 1250000 ELF,
///     then release the Treasury;
///     2. Release Treasury)
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L129-134)
```csharp
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.TreasuryHash.Value,
            Period = input.PeriodNumber,
            AmountsMap = { State.SymbolList.Value.Value.ToDictionary(s => s, s => 0L) }
        });
```
