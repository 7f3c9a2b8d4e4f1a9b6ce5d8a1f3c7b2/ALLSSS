# Audit Report

## Title
Retroactive Miner Count Calculation Causes Sudden Jumps When MinerIncreaseInterval is Modified

## Summary
The `SetMinerIncreaseInterval()` function allows governance to decrease the miner increase interval, but the miner count calculation retroactively applies the new interval to the entire blockchain history. This causes a sudden, unintended jump in the allowed miner count at the next term transition, disrupting consensus dynamics and diluting mining rewards.

## Finding Description

The vulnerability stems from how the AEDPoS consensus contract calculates the auto-increased miner count. The `GetAutoIncreasedMinersCount()` function uses a formula that divides the entire elapsed blockchain time by the current `MinerIncreaseInterval`: [1](#0-0) 

When governance calls `SetMinerIncreaseInterval()` to decrease the interval value, the function only validates that the new interval is not greater than the current value, with no historical tracking: [2](#0-1) 

At the next term transition, `ProcessNextTerm()` calls `UpdateMinersCountToElectionContract()`: [3](#0-2) 

This invokes `GetMinersCount()` which uses the same retroactive calculation: [4](#0-3) 

The suddenly increased count is sent to the Election contract: [5](#0-4) 

The Election contract stores this count: [6](#0-5) 

And uses it in `GetVictories()` to determine how many candidates become miners: [7](#0-6) 

Additionally, the data center count is calculated as 5x the miner count: [8](#0-7) 

## Impact Explanation

Using the constant `SupposedMinersCount = 17`: [9](#0-8) 

**Concrete Example:**
- Blockchain age: 3 years (94,608,000 seconds)
- Original interval: 31,536,000 seconds (1 year)
- Original miner count: 17 + (94,608,000 / 31,536,000) × 2 = 23 miners
- New interval: 3,153,600 seconds (36.5 days)
- New miner count: 17 + (94,608,000 / 3,153,600) × 2 = 77 miners
- **Sudden jump: 54 miners in one term transition**

**Impact on Stakeholders:**

1. **Existing Miners**: Mining reward per miner drops from 1/23 to 1/77 of the reward pool (approximately 70% reduction), as rewards are donated to the Treasury contract based on blocks mined: [10](#0-9) 

2. **Consensus Network**: A sudden 3x increase in miner count disrupts consensus algorithm performance, increases coordination overhead, and violates the gradual growth model designed to maintain network stability.

3. **Data Center Operators**: ValidDataCenterCount jumps from 115 to 385, allowing 270 additional data centers into the subsidy scheme, diluting subsidy distribution across many more beneficiaries.

4. **Candidates**: 54 candidates suddenly become miners without following the intended gradual admission process, undermining the fairness of the election system.

## Likelihood Explanation

**Attacker Profile**: Requires governance control via `MaximumMinersCountController` (typically Parliament contract), which is realistic as parameter adjustments are normal governance operations.

**Attack Complexity**: Low - single transaction calling `SetMinerIncreaseInterval()` with a decreased value. The effect triggers automatically at the next scheduled term transition.

**Realistic Scenario**: Governance might legitimately want to accelerate future miner growth by decreasing the interval, expecting the change to apply going forward. However, due to the retroactive calculation, it unexpectedly causes a massive immediate jump instead.

**Detection Challenge**: The effect becomes visible only after the term transition completes and the new miner set is selected, making it difficult to prevent once the parameter is changed.

## Recommendation

Implement historical tracking of interval changes to prevent retroactive application:

**Option 1: Track Interval Change History**
- Store a mapping of `timestamp -> interval` whenever `SetMinerIncreaseInterval()` is called
- Calculate miner increases segment-by-segment based on the interval active during each time period
- Sum the accumulated increases from all segments

**Option 2: Store Accumulated Miner Count**
- Track the accumulated miner count at the time of each interval change
- Only apply the new interval to calculate growth from that point forward
- Formula: `StoredMinerCount + ((CurrentTime - LastChangeTime) / NewInterval) * 2`

**Option 3: Prevent Decreases**
- Modify line 61 to only allow `input.Value >= State.MinerIncreaseInterval.Value`
- This prevents any retroactive effect by ensuring the interval can only increase (slow down growth)

**Option 4: Cap Maximum Decrease**
- Add validation to limit how much the interval can decrease in a single change
- For example: `input.Value >= State.MinerIncreaseInterval.Value * 50 / 100` (no more than 50% decrease)

The recommended approach is Option 1 or 2, as they preserve the intended functionality (allowing faster growth) while fixing the retroactive calculation bug.

## Proof of Concept

Due to the complexity of the AEDPoS consensus system and requirement for full blockchain simulation with term transitions, a production-ready PoC would require:

1. Deploy the full consensus contract stack with initial configuration
2. Advance blockchain time by 3 years (simulated)
3. Call `SetMinerIncreaseInterval()` with governance approval to decrease the interval
4. Trigger a term transition via `NextTerm()`
5. Observe the miner count jump from 23 to 77
6. Verify reward dilution and data center expansion

The vulnerability is confirmed through code analysis showing the direct execution path from `SetMinerIncreaseInterval()` through the retroactive calculation in `GetAutoIncreasedMinersCount()` to the Election contract's `GetVictories()` method, with no intermediate guards to prevent the sudden jump.

---

**Notes:**
- This is a logic vulnerability in the protocol design rather than a traditional exploit requiring malicious input
- The issue arises from legitimate governance actions having unintended retroactive consequences
- The fix requires modifying the miner count calculation to track historical intervals or prevent decreases
- Impact is severe due to 70% reward dilution for existing miners and consensus disruption from sudden 3x miner increase

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L176-176)
```csharp
        UpdateMinersCountToElectionContract(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L41-84)
```csharp
    public override PubkeyList GetVictories(Empty input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        var currentMiners = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(k => k.ToHex()).ToList();
        return new PubkeyList { Value = { GetVictories(currentMiners) } };
    }

    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L406-409)
```csharp
    private int GetValidationDataCenterCount()
    {
        return GetMinersCount(new Empty()).Value.Mul(5);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```
