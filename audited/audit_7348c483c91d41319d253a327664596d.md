### Title
Symbol Number Collision Causes Guaranteed Transaction Failure with Maximum Fee Consumption in NFT Creation

### Summary
The `GenerateSymbolNumber()` function contains a critical flaw where the `randomHash` is computed once before the do-while loop and never modified within it. When a symbol number collision occurs, `Context.ConvertHashToInt64()` deterministically returns the same already-used number on every iteration, causing the loop to execute until AElf's branch threshold (15,000) is exceeded, resulting in transaction failure and maximum fee consumption for the user.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:** The `GenerateSymbolNumber()` function calculates `randomHash` from the previous block height and sender address before entering the do-while loop. [2](#0-1) 

Inside the loop, `Context.ConvertHashToInt64(randomHash, from, from.Mul(10))` is called with the same static hash value. [3](#0-2) 

The `ConvertHashToInt64` implementation uses deterministic modulo arithmetic, meaning identical inputs always produce identical outputs. [4](#0-3) 

If the generated `randomNumber` already exists in `State.IsCreatedMap`, the while condition `State.IsCreatedMap[randomNumber]` remains true indefinitely since the same number is checked on every iteration.

**Why Protections Fail:** While AElf's execution observer prevents truly infinite execution by limiting branches to 15,000 iterations, [5](#0-4)  this protection mechanism causes the transaction to fail with `RuntimeBranchThresholdExceededException` after consuming maximum computational resources. [6](#0-5) 

**Execution Path:**
1. User calls public `Create(CreateInput)` method [7](#0-6) 
2. `GetSymbol()` invokes `GenerateSymbolNumber()` [8](#0-7) 
3. Symbol collision triggers infinite loop until branch threshold
4. Transaction fails, fees consumed, no NFT created

### Impact Explanation

**Direct Financial Loss:** Users attempting to create NFT protocols lose transaction fees equivalent to 15,000 loop iterations when their transaction encounters a symbol collision. This represents substantial resource consumption without any successful outcome.

**Denial of Service:** Legitimate users are unable to create NFT protocols when collisions occur. As the `State.IsCreatedMap` grows over time with more NFT creations, collision probability increases, making the system progressively less reliable.

**Who Is Affected:** Any user calling the `Create()` method can be affected. The initial number space spans 900 million values (from 10^8 to 10^9), [9](#0-8)  but collisions are inevitable as adoption grows.

**Severity Justification:** HIGH - Combines guaranteed financial loss (wasted fees), denial of critical functionality (NFT creation), and exploitability by malicious actors who can predict or influence random number generation.

### Likelihood Explanation

**Attacker Capabilities:** An attacker can predict the symbol number by observing:
- Block height (publicly available on-chain)
- Target user's address (known from pending transactions or social engineering)
- Random bytes from consensus contract (potentially observable or predictable)

**Attack Complexity:** LOW to MEDIUM
1. Monitor pending `Create()` transactions in mempool or identify target user
2. Calculate the symbol number that will be generated for that user at the next block
3. Front-run by creating an NFT with that exact symbol number
4. Victim's transaction executes, hits collision, and fails after 15,000 iterations

**Accidental Triggering:** Even without malicious intent, natural collisions will occur as more NFTs are created. With deterministic random generation based on limited entropy sources, birthday paradox makes collisions statistically likely over time.

**Economic Rationality:** Attacker cost is minimal (one NFT creation fee), while victim suffers maximum transaction fee loss. The attack is economically profitable if the attacker benefits from denying the victim's NFT creation (e.g., competitive NFT launch scenarios).

### Recommendation

**Code-Level Mitigation:**
Modify the `GenerateSymbolNumber()` function to rehash on each iteration when a collision is detected:

```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
    {
        Value = Context.CurrentHeight.Sub(1)
    }.ToBytesValue());
    
    var randomHash = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(Context.Sender),
        HashHelper.ComputeFrom(randomBytes));
    
    long randomNumber;
    int attempt = 0;
    const int maxAttempts = 100; // Reasonable limit
    
    do
    {
        // Rehash on each attempt to generate different numbers
        var attemptHash = HashHelper.ConcatAndCompute(randomHash, HashHelper.ComputeFrom(attempt));
        randomNumber = Context.ConvertHashToInt64(attemptHash, from, from.Mul(10));
        attempt++;
        
        if (attempt >= maxAttempts)
        {
            // Expand number space and retry
            length++;
            from = 1L;
            for (var i = 1; i < length; i++) from = from.Mul(10);
            attempt = 0;
        }
    } while (State.IsCreatedMap[randomNumber]);

    return randomNumber;
}
```

**Invariant Checks:**
- Assert maximum iteration count is never exceeded
- Monitor collision rate metrics
- Alert if collision frequency exceeds statistical expectations

**Test Cases:**
1. Create test where `State.IsCreatedMap` contains the specific number that would be generated
2. Verify transaction succeeds by finding alternative number
3. Test with saturated number space to ensure graceful handling
4. Measure gas consumption remains bounded and predictable

### Proof of Concept

**Initial State:**
- NFT contract deployed and initialized
- User Alice prepares to create NFT protocol with type "Art"

**Attack Sequence:**

1. **Setup:** Attacker Bob observes Alice's address and current block height (H)

2. **Prediction:** Bob calculates the symbol number Alice will generate:
   - Block height for random bytes: H
   - Sender: Alice's address
   - Combines these to compute hash
   - Applies `ConvertHashToInt64` with current number range
   - Determines Alice will get symbol "AR123456789"

3. **Front-Running:** Bob quickly calls `Create()` with his own NFT using any configuration, obtaining symbol "AR123456789" before Alice's transaction executes

4. **Collision:** Alice's transaction executes in block H+1:
   - Calls `Create()` → `GetSymbol()` → `GenerateSymbolNumber()`
   - Generates same "AR123456789" number
   - Checks `State.IsCreatedMap["AR123456789"]` → true (Bob's NFT)
   - Loop executes checking same number repeatedly
   - After 15,000 iterations: `RuntimeBranchThresholdExceededException`

5. **Result:**
   - **Expected:** Alice successfully creates NFT with unique symbol
   - **Actual:** Alice's transaction fails, fees consumed for 15,000 loop iterations, no NFT created

**Success Condition:** Transaction reverts with branch threshold exceeded exception, Alice loses transaction fees, no NFT protocol created despite valid input.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-27)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L173-177)
```csharp
        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L7-7)
```csharp
    public const int ExecutionBranchThreshold = 15000;
```

**File:** docs-sphinx/architecture/smart-contract/restrictions/others.rst (L14-15)
```text

- AElf's contract patcher will patch method branch count observer for your contract. This is used to prevent infinitely loop case. The number of code control transfer in your contract will be counted during transaction execution. The observer will pause transaction execution if the number exceeds 15,000. The limit adjustment is governed by ``Parliament``.
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```
