### Title
Token Deposit Loss Through Pubkey Replacement in Election Contract

### Summary
When a candidate registers via `AnnounceElection` and subsequently has their public key replaced via `ReplaceCandidatePubkey`, the 100,000 ELF deposit refund is sent to the wrong address upon calling `QuitElection`. The refund logic incorrectly uses the NEW pubkey to derive the recipient address instead of tracking the original payer, resulting in permanent loss of the candidate's deposit.

### Finding Description

The vulnerability exists in the interaction between three functions in the Election contract:

**Root Cause:**

When a candidate registers through `AnnounceElection`, their deposit (100,000 ELF) is locked but the `CandidateSponsorMap` state variable is never set. [1](#0-0) 

The deposit is locked from `Context.Sender` (the candidate's address). [2](#0-1) 

In contrast, `AnnounceElectionFor` properly records the sponsor in the map. [3](#0-2) 

When a pubkey is replaced through `ReplaceCandidatePubkey`, the sponsor map entry is transferred from old to new pubkey, preserving null values. [4](#0-3) 

**Failure Point:**

In `QuitElection`, the refund logic uses a fallback that derives the recipient address from the current pubkey passed in the input parameter: [5](#0-4) 

The critical line 245 shows: `To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes)`

Since `CandidateSponsorMap[newPubkey]` is null (copied from the original null value), the fallback `Address.FromPublicKey(pubkeyBytes)` is used, where `pubkeyBytes` is derived from the NEW pubkey at line 231, not the original candidate's pubkey who paid the deposit.

**Why Existing Protections Fail:**

The authorization check at line 236 validates the admin's permission using the `initialPubkey` mapping, but the refund destination at line 245 uses the current `input.Value` pubkey, creating a mismatch. The code correctly retrieves the `AnnouncementTransactionId` for unlocking but fails to retrieve the correct recipient address.

### Impact Explanation

**Direct Financial Loss:**
- The original candidate loses their entire 100,000 ELF deposit (defined in ElectionContractConstants). [6](#0-5) 
- The deposit is transferred to an address derived from the replacement pubkey, which may be controlled by a different party or be completely inaccessible.

**Affected Parties:**
- Any candidate who registered via `AnnounceElection` (not `AnnounceElectionFor`) and later performed pubkey replacement through the legitimate key rotation mechanism.
- At 100,000 ELF per affected candidate, this represents significant economic damage.

**Severity Justification:**
This is a **CRITICAL** vulnerability because:
1. It causes permanent and complete loss of substantial funds (100,000 ELF)
2. It affects a core protocol mechanism (candidate registration/withdrawal)
3. It can occur through normal, legitimate operational flows (key rotation)
4. There is no recovery mechanism once funds are sent to the wrong address

### Likelihood Explanation

**Attacker Capabilities:**
- **Malicious Admin Scenario**: An admin can deliberately replace the candidate's pubkey to one they control, then call `QuitElection` to steal the 100,000 ELF deposit. This requires only admin privileges, which are intentionally granted by the candidate.
- **Accidental Loss Scenario**: Even with honest participants, legitimate key rotation followed by election withdrawal results in fund loss.

**Attack Complexity:**
The exploit requires only three standard contract calls:
1. `AnnounceElection` (legitimate candidate registration)
2. `ReplaceCandidatePubkey` (legitimate key rotation feature)
3. `QuitElection` (standard withdrawal)

No special timing, state manipulation, or complex transaction sequences are required.

**Feasibility Conditions:**
- Pubkey replacement is a documented and intended feature for key rotation scenarios. [7](#0-6) 
- The admin permission check explicitly allows this operation, making it accessible in normal workflows.
- No external conditions or rare states are required.

**Detection/Operational Constraints:**
- The vulnerability is not easily detectable until funds are already lost
- There are no warnings or checks in the contract to prevent this scenario
- Standard operational procedures (key rotation) trigger the vulnerability

**Probability Assessment:**
**HIGH** - The vulnerability will manifest whenever:
- A candidate uses `AnnounceElection` (common path for self-registration)
- The candidate performs pubkey replacement (legitimate operational need)
- The candidate withdraws from election (standard exit mechanism)

### Recommendation

**Immediate Fix:**

Modify the `QuitElection` function to track and use the initial pubkey for refund destination when the sponsor map is null:

```solidity
// In QuitElection, replace the refund logic at line 245:
var recipientAddress = State.CandidateSponsorMap[input.Value];
if (recipientAddress == null)
{
    // Use initialPubkey to derive the original candidate's address
    var originalPubkeyBytes = ByteArrayHelper.HexStringToByteArray(initialPubkey);
    recipientAddress = Address.FromPublicKey(originalPubkeyBytes);
}

State.TokenContract.TransferFrom.Send(new TransferFromInput
{
    From = lockVirtualAddress,
    To = recipientAddress,
    Symbol = Context.Variables.NativeSymbol,
    Amount = ElectionContractConstants.LockTokenForElection,
    Memo = "Quit election."
});
```

**Alternative Fix:**

Set the `CandidateSponsorMap` in `AnnounceElection` to maintain consistency with `AnnounceElectionFor`:

```solidity
// In AnnounceElection, after line 106, add:
var address = Address.FromPublicKey(recoveredPublicKey);
State.CandidateSponsorMap[pubkey] = address;
```

**Invariant to Add:**
- Assert that refund recipient address matches the original payer's address derived from the initial pubkey
- Verify `CandidateSponsorMap` consistency during pubkey replacement

**Test Cases:**
1. Register candidate via `AnnounceElection`, replace pubkey, quit election → verify refund goes to original candidate
2. Register via `AnnounceElectionFor`, replace pubkey, quit election → verify refund goes to sponsor
3. Prevent regression by testing both announcement methods with and without pubkey replacement

### Proof of Concept

**Initial State:**
- Alice has 100,000+ ELF tokens
- Bob controls a separate pubkey (pubkeyB)
- Alice sets admin address to adminAddress

**Transaction Sequence:**

1. **Alice calls `AnnounceElection(adminAddress)` with signature from pubkeyA:**
   - Alice's address (derived from pubkeyA) pays 100,000 ELF deposit
   - `CandidateAdmins[pubkeyA] = adminAddress`
   - `CandidateSponsorMap[pubkeyA]` remains null (NOT set)
   - `AnnouncementTransactionId` stored for unlocking

2. **Admin calls `ReplaceCandidatePubkey(pubkeyA, pubkeyB)`:**
   - Permission check passes (admin owns pubkeyA)
   - `CandidateSponsorMap[pubkeyB] = CandidateSponsorMap[pubkeyA] = null`
   - `InitialPubkeyMap[pubkeyB] = pubkeyA`
   - Candidate information transferred to pubkeyB

3. **Admin calls `QuitElection(pubkeyB)`:**
   - Authorization check passes (admin verified via InitialPubkeyMap)
   - Unlock virtual address correctly derived from original AnnouncementTransactionId
   - Refund destination: `CandidateSponsorMap[pubkeyB] ?? Address.FromPublicKey(pubkeyB)`
   - Since `CandidateSponsorMap[pubkeyB]` is null, refund goes to `Address.FromPublicKey(pubkeyB)`

**Expected Result:**
- 100,000 ELF should return to Alice's address (derived from pubkeyA)

**Actual Result:**
- 100,000 ELF is sent to Bob's address (derived from pubkeyB)
- Alice permanently loses her deposit
- If Bob controls pubkeyB, this constitutes theft
- If pubkeyB is inaccessible, funds are permanently lost

**Success Condition:**
Verify that Alice's balance decreased by 100,000 ELF after step 1 and Bob's balance (or an inaccessible address) increased by 100,000 ELF after step 3, while Alice's balance did not recover the funds.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L140-140)
```csharp
        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L239-249)
```csharp
        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L320-321)
```csharp
        State.CandidateSponsorMap[newPubkey] = State.CandidateSponsorMap[oldPubkey];
        State.CandidateSponsorMap.Remove(oldPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```
