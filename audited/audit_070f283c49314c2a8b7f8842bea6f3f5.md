### Title
PreviousInValue State Inconsistency Through Unconditional Overwrites in UpdateValue Processing

### Summary
The `PerformSecretSharing` function allows any miner to unconditionally overwrite `PreviousInValue` for other miners during `UpdateValue` calls, enabling multiple overwrites within the same round with no validation. This violates consensus invariants as the last miner to call `UpdateValue` in a round can corrupt the `PreviousInValue` used for signature calculations of non-mining miners during round transitions.

### Finding Description

The vulnerability exists in the consensus update flow, though not directly in `RevealSharedInValues` as suggested. The `RevealSharedInValues` function is only called during view operations and doesn't modify chain state. [1](#0-0) 

However, the actual vulnerability occurs in `PerformSecretSharing` called during `UpdateValue` transaction processing: [2](#0-1) 

At lines 295-296, `PreviousInValue` is unconditionally overwritten for any miner specified in `MinersPreviousInValues` without any validation or protection against overwrites. Multiple miners calling `UpdateValue` in the same round can repeatedly overwrite the same `PreviousInValue` field, with the last writer winning.

The `UpdateValue` method is public and calls this code path: [3](#0-2) [4](#0-3) 

In contrast, `UpdateLatestSecretPieces` has proper protection against overwrites: [5](#0-4) 

The corrupted `PreviousInValue` is then used during round transitions when `SupplyCurrentRoundInformation` fills in data for miners who didn't mine: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Violation**: The corrupted `PreviousInValue` is used to calculate signatures for non-mining miners during round transitions, directly affecting consensus calculations and random number generation. [7](#0-6) 

**State Inconsistency**: Different miners can have inconsistent views of which `PreviousInValue` should be used, violating the consensus invariant that all miners should agree on consensus state within a round.

**Affected Parties**: All miners in the consensus set are affected, particularly those who fail to produce blocks in a given round, as their signature calculations will be based on potentially corrupted data.

**Severity**: This is a Medium-to-High severity issue as it undermines consensus integrity, though exploitation requires miner participation and affects only specific scenarios (when miners don't produce blocks).

### Likelihood Explanation

**Reachable Entry Point**: `UpdateValue` is a public contract method callable by any miner during their block production. [3](#0-2) 

**Attacker Capabilities**: Any miner in the consensus set can construct a malicious `UpdateValueInput` with arbitrary `MinersPreviousInValues` values. The input structure is defined in protobuf: [8](#0-7) 

**Execution Practicality**: The attack requires:
1. Attacker must be a valid miner (verified by PreCheck)
2. Attacker produces a block in the target round
3. Attacker constructs UpdateValueInput with fake MinersPreviousInValues
4. No validation prevents this at processing time

**Detection Difficulty**: The overwrite happens during normal consensus operations. Without additional monitoring, it's difficult to detect which miner provided incorrect values versus which provided correct values through legitimate secret sharing.

**Feasibility**: High - requires only one malicious miner to corrupt another miner's PreviousInValue. The one-transaction-per-block restriction doesn't prevent this: [9](#0-8) 

### Recommendation

**Code-Level Fix**: Add a protective check in `PerformSecretSharing` similar to the one in `UpdateLatestSecretPieces`:

```csharp
private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
    string publicKey)
{
    minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
    foreach (var decryptedPreviousInValue in input.DecryptedPieces)
        round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
            .Add(publicKey, decryptedPreviousInValue.Value);

    foreach (var previousInValue in input.MinersPreviousInValues)
        // ADD THIS CHECK:
        if (round.RealTimeMinersInformation.ContainsKey(previousInValue.Key) &&
            (round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue == Hash.Empty ||
             round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue == null))
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
}
```

**Additional Validation**: Consider adding validation that `MinersPreviousInValues` contains only values that can be reconstructed from the available `DecryptedPieces` via secret sharing, preventing arbitrary value injection.

**Invariant Enforcement**: Add test cases ensuring `PreviousInValue` cannot be overwritten once set to a non-empty value within the same round.

### Proof of Concept

**Initial State**:
- Round N with miners A, B, C, and M (malicious)
- Secret sharing protocol in progress
- Miner B expected to have PreviousInValue reconstructed

**Attack Steps**:
1. Miner A produces block at time T1, calls `UpdateValue`:
   - Includes `MinersPreviousInValues[B] = correctHash` (reconstructed through secret sharing)
   - State: `Round[N].RealTimeMinersInformation[B].PreviousInValue = correctHash`

2. Malicious Miner M produces block at time T2, calls `UpdateValue`:
   - Constructs malicious `UpdateValueInput` with `MinersPreviousInValues[B] = maliciousHash`
   - Transaction processed via `PerformSecretSharing`
   - State: `Round[N].RealTimeMinersInformation[B].PreviousInValue = maliciousHash` (OVERWRITTEN)

3. Miner B fails to produce their block (OutValue remains null)

4. Extra block producer triggers `NextRound`:
   - `SupplyCurrentRoundInformation` called
   - For Miner B: reads `PreviousInValue = maliciousHash`
   - Calculates incorrect signature: `signature = previousRound.CalculateSignature(maliciousHash)`
   - Wrong signature propagated to next round

**Expected Result**: `PreviousInValue` should remain immutable once set through legitimate secret sharing reconstruction.

**Actual Result**: `PreviousInValue` is overwritten by later `UpdateValue` calls, corrupting consensus data for non-mining miners.

**Success Condition**: Attacker successfully modifies another miner's `PreviousInValue` used in consensus calculations, demonstrating state inconsistency violation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-257)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L171-199)
```csharp
    private void SupplyCurrentRoundInformation()
    {
        var currentRound = GetCurrentRoundInformation(new Empty());
        Context.LogDebug(() => $"Before supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
        var notMinedMiners = currentRound.RealTimeMinersInformation.Values.Where(m => m.OutValue == null).ToList();
        if (!notMinedMiners.Any()) return;
        TryToGetPreviousRoundInformation(out var previousRound);
        foreach (var miner in notMinedMiners)
        {
            Context.LogDebug(() => $"Miner pubkey {miner.Pubkey}");

            Hash previousInValue = null;
            Hash signature = null;

            // Normal situation: previous round information exists and contains this miner.
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** protobuf/aedpos_contract.proto (L215-216)
```text
    // The InValue in the previous round, miner public key -> InValue.
    map<string, aelf.Hash> miners_previous_in_values = 11;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```
