### Title
Integer Overflow in Withdraw Function Due to Unbounded MinimumLockMinutes Parameter

### Summary
The `CreateScheme` function in TokenHolderContract does not validate the `MinimumLockMinutes` parameter, allowing malicious actors to create schemes with extremely large lock period values. When users register for profits in such schemes and later attempt to withdraw, the `AddMinutes` calculation triggers an integer overflow exception, permanently locking their tokens.

### Finding Description

The vulnerability exists in the `CreateScheme` function which accepts `CreateTokenHolderProfitSchemeInput` without validating the `minimum_lock_minutes` field: [1](#0-0) 

The input parameter `MinimumLockMinutes` is defined as `int64` and directly stored in the scheme state without any bounds checking: [2](#0-1) 

When users attempt to withdraw their locked tokens, the `Withdraw` function performs a time validation check: [3](#0-2) 

The `AddMinutes` extension method internally multiplies the minutes by 60 to convert to seconds using SafeMath: [4](#0-3) 

The `Mul` operation uses checked arithmetic that throws `OverflowException` on overflow: [5](#0-4) 

**Root Cause**: When `MinimumLockMinutes >= 153,722,867,280,913` (which equals `int64.MaxValue / 60 + 1`), the multiplication `minutes * 60` exceeds `int64.MaxValue`, causing a checked arithmetic overflow exception that aborts the transaction.

**Why Existing Protections Fail**: 
- No authorization check restricts who can call `CreateScheme`
- No validation exists on the range or reasonableness of `MinimumLockMinutes`
- The proto definition allows the full `int64` range
- No update mechanism exists to modify a scheme after creation [6](#0-5) 

### Impact Explanation

**Direct Fund Impact**: Users who call `RegisterForProfits` on a malicious scheme will have their tokens permanently locked without any possibility of withdrawal. The locked tokens cannot be recovered because:
1. The `Withdraw` function will always fail with an overflow exception
2. No alternative withdrawal mechanism exists
3. No scheme update functionality exists to reduce `MinimumLockMinutes`

**Affected Parties**: Any user who registers for profits in a scheme created with `MinimumLockMinutes >= 153,722,867,280,913`. The impact scales with the number of users and amount of tokens locked.

**Severity Justification**: This is a HIGH severity issue because:
- Results in complete and permanent loss of user funds
- Trivial to exploit (single transaction to create malicious scheme)
- Users cannot detect the issue before locking tokens without manually calculating the overflow threshold
- No recovery mechanism exists

### Likelihood Explanation

**Attacker Capabilities**: Any address can call `CreateScheme` - no special privileges required. The attacker only needs to:
1. Pay transaction fees to call `CreateScheme`
2. Set `MinimumLockMinutes` to a value >= 153,722,867,280,913

**Attack Complexity**: Very low - single transaction with one malicious parameter value.

**Feasibility Conditions**: 
- No preconditions beyond having sufficient balance for transaction fees
- Attack works immediately without waiting periods
- Victims must be convinced to call `RegisterForProfits` on the malicious scheme (social engineering or deceptive scheme names)

**Detection Constraints**: Users can query the scheme via `GetScheme` to see `MinimumLockMinutes` before registering, but values like 153,722,867,280,913 minutes (~292 million years) may not be immediately recognized as malicious versus just "very long term staking."

**Probability**: HIGH - The attack is economically rational (costs only transaction fees), technically simple, and leaves no avenue for fund recovery.

### Recommendation

**Code-Level Mitigation**: Add validation in `CreateScheme` to enforce a maximum reasonable value for `MinimumLockMinutes`:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add validation
    const long MaxReasonableLockMinutes = 525600 * 10; // 10 years in minutes
    const long SafetyThreshold = int64.MaxValue / 60 - 1; // Prevent overflow
    
    Assert(input.MinimumLockMinutes >= 0, "MinimumLockMinutes must be non-negative.");
    Assert(input.MinimumLockMinutes <= MaxReasonableLockMinutes, 
           $"MinimumLockMinutes exceeds maximum allowed value of {MaxReasonableLockMinutes}.");
    Assert(input.MinimumLockMinutes <= SafetyThreshold,
           "MinimumLockMinutes would cause arithmetic overflow.");
    
    // ... rest of existing code
}
```

**Invariant Checks**: 
- Enforce `0 <= MinimumLockMinutes <= SafetyThreshold` where `SafetyThreshold = (int64.MaxValue / 60) - 1 = 153,722,867,280,912`
- Consider adding a more restrictive business logic limit (e.g., 10 years maximum lock period)

**Test Cases**: Add regression tests including:
- Test CreateScheme with `MinimumLockMinutes = int64.MaxValue` (should fail)
- Test CreateScheme with `MinimumLockMinutes = 153,722,867,280,913` (should fail)
- Test CreateScheme with `MinimumLockMinutes = 153,722,867,280,912` (should succeed if within business logic limits)
- Test full flow: CreateScheme → RegisterForProfits → Withdraw with various large lock periods

### Proof of Concept

**Initial State**:
- Attacker has address `AttackerAddress` with sufficient ELF for transaction fees
- Victim has address `VictimAddress` with 10,000 ELF tokens

**Transaction Steps**:

1. **Attacker creates malicious scheme**:
```
Call: TokenHolderContract.CreateScheme
Input: {
    Symbol: "ELF",
    MinimumLockMinutes: 153722867280913,  // Causes overflow
    AutoDistributeThreshold: {}
}
Sender: AttackerAddress
```

2. **Victim registers for profits** (believing it's a legitimate staking scheme):
```
Call: TokenHolderContract.RegisterForProfits
Input: {
    SchemeManager: AttackerAddress,
    Amount: 10000
}
Sender: VictimAddress
```
Expected: Victim's 10,000 ELF tokens are locked
Actual: ✓ Tokens successfully locked

3. **Victim attempts withdrawal** (at any point in time):
```
Call: TokenHolderContract.Withdraw
Input: AttackerAddress
Sender: VictimAddress
```
Expected: Should validate lock time and potentially allow withdrawal
Actual: ✗ Transaction fails with `System.OverflowException` in `SafeMath.Mul`
Result: Victim's tokens remain permanently locked, withdrawal impossible

**Success Condition**: The attack succeeds if Step 3 always fails with overflow exception, preventing any withdrawal regardless of elapsed time.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** protobuf/token_holder_contract.proto (L15-21)
```text
service TokenHolderContract {
    
    option (aelf.csharp_state) = "AElf.Contracts.TokenHolder.TokenHolderContractState";
    
    // Create a scheme for distributing bonus.
    rpc CreateScheme (CreateTokenHolderProfitSchemeInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/token_holder_contract.proto (L63-70)
```text
message CreateTokenHolderProfitSchemeInput {
    // The token symbol.
    string symbol = 1;
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 2;
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 3;
}
```

**File:** src/AElf.CSharp.Core/Extension/TimestampExtensions.cs (L39-42)
```csharp
    public static Timestamp AddMinutes(this Timestamp timestamp, long minutes)
    {
        return timestamp + new Duration { Seconds = minutes.Mul(60) };
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L79-85)
```csharp
    public static long Mul(this long a, long b)
    {
        checked
        {
            return a * b;
        }
    }
```
