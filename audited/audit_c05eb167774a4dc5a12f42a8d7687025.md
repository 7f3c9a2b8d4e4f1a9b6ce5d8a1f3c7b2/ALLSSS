### Title
MinimalVoteThreshold Counts Historical Votes Instead of Current Member Participation, Bypassing Quorum Requirements

### Summary
The `CheckEnoughVoteAndApprovals()` function counts all historical votes toward `MinimalVoteThreshold` without filtering by current organization membership, unlike all other threshold checks. This allows proposals to be released without adequate participation from the current organization, as the vote count doesn't scale when members are added and includes votes from removed members.

### Finding Description

**Root Cause Location:** [1](#0-0) 

The `MinimalVoteThreshold` check concatenates all vote lists and counts total elements without filtering by current organization membership. This is inconsistent with other threshold checks that properly filter:

- **Approval threshold** filters by current members: [2](#0-1) 

- **Rejection threshold** filters by current members: [3](#0-2) 

- **Abstention threshold** filters by current members: [4](#0-3) 

The vulnerability occurs because organizations can modify membership after voting begins using: [5](#0-4) [6](#0-5) 

When `Release()` is called, it checks thresholds against the current organization state: [7](#0-6) 

While the validation ensures thresholds are valid for the current member count: [8](#0-7) 

This validation only checks that `MinimalVoteThreshold <= organizationMemberCount` at the time of validation, not that the actual votes counted come from the current member set.

**Why Protections Fail:**
- `AssertProposalNotYetVotedBySender` only prevents duplicate votes by the same address, not membership changes [9](#0-8) 
- No check validates that votes counted toward `MinimalVoteThreshold` are from current members at release time

### Impact Explanation

**Concrete Harm:**
1. **Quorum Bypass via Member Addition**: If an organization starts with 10 members, gets 8 votes, then adds 20 new members (total 30), the proposal can still be released with only 8/30 votes (26.7% participation) instead of requiring 8 out of 10 (80%). The quorum requirement becomes meaningless.

2. **Vote Inflation via Removed Members**: If members vote and are subsequently removed, their votes still count toward `MinimalVoteThreshold` while not counting toward approval/rejection/abstention thresholds, creating an inconsistent state where historical non-members influence quorum.

3. **Governance Integrity Violation**: The `MinimalVoteThreshold` is designed to ensure adequate organizational participation before executing proposals. This vulnerability allows proposals to execute without true quorum from the current membership, undermining the fundamental governance invariant.

**Severity Justification**: HIGH - This breaks the quorum mechanism, a critical governance protection. Proposals can be executed with minority support that no longer represents the current organization composition, potentially allowing unauthorized actions.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to propose (requires being in `ProposerWhiteList`)
- Ability to modify organization membership (requires organization governance approval)
- Both are standard governance operations, not privileged actions

**Attack Complexity**: LOW
- Simple sequence: create proposal → gather votes → modify membership → release proposal
- No timing constraints beyond proposal expiration
- No special state manipulation required

**Feasibility Conditions:**
- Organizations frequently modify membership as part of normal operations
- Proposals can have long lifetimes (until `ExpiredTime`), providing ample opportunity for membership changes [10](#0-9) 

**Detection/Operational Constraints**: 
- Membership changes are legitimate operations that wouldn't raise suspicion
- The inconsistency is subtle and wouldn't be detected until analysis of vote ratios

**Probability**: HIGH - This can occur naturally during normal governance operations without malicious intent, making it both an exploitable vulnerability and an operational flaw.

### Recommendation

**Exact Code-Level Mitigation:**
Modify line 56 in `CheckEnoughVoteAndApprovals()` to filter votes by current organization membership, matching the pattern used for other thresholds:

```csharp
var isVoteThresholdReached =
    proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
    proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
    proposal.Rejections.Count(organization.OrganizationMemberList.Contains) >=
    organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**Invariant Check to Add:**
Add assertion that vote participation ratio is calculated from current membership:
```csharp
var currentMemberVoteCount = 
    proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
    proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
    proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
Assert(currentMemberVoteCount >= organization.ProposalReleaseThreshold.MinimalVoteThreshold,
    "Insufficient current member participation");
```

**Test Cases:**
1. Create organization with 10 members, MinimalVoteThreshold=8
2. Create proposal and get 8 votes
3. Add 20 new members
4. Attempt to release - should FAIL (currently would PASS)
5. Verify that only votes from current members count toward threshold

### Proof of Concept

**Required Initial State:**
- Organization with 10 members: M1-M10
- ProposalReleaseThreshold: MinimalVoteThreshold=8, MinimalApprovalThreshold=6
- Proposer P in ProposerWhiteList

**Transaction Steps:**
1. P creates proposal targeting sensitive action
2. M1-M6 call `Approve(proposalId)` (6 approvals)
3. M7-M8 call `Abstain(proposalId)` (2 abstentions)
4. Total votes: 8, Meeting thresholds: 8>=8 ✓, 6>=6 ✓
5. Organization calls `AddMember(M11)` through `AddMember(M30)` adding 20 new members
6. Organization now has 30 members, validation passes: 8<=30 ✓
7. P calls `Release(proposalId)`

**Expected vs Actual Result:**
- **Expected**: Release should FAIL because only 8/30 current members voted (26.7% participation)
- **Actual**: Release SUCCEEDS because line 56 counts all 8 historical votes regardless of current membership

**Success Condition:**
The proposal executes despite only 26.7% of current organization members participating, demonstrating quorum bypass through the MinimalVoteThreshold counting mechanism.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-37)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L72-73)
```csharp
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L89-89)
```csharp
        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L132-138)
```csharp
    private void AssertProposalNotYetVotedBySender(ProposalInfo proposal, Address sender)
    {
        var isAlreadyVoted = proposal.Approvals.Contains(sender) || proposal.Rejections.Contains(sender) ||
                             proposal.Abstentions.Contains(sender);

        Assert(!isAlreadyVoted, "Sender already voted.");
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L187-188)
```csharp
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
