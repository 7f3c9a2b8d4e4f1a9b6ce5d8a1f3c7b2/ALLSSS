### Title
Hardcoded TinyBlocksCount Causes Premature Block Production Timeout During Blockchain Stress

### Summary
The `TinyBlocksCount` constant is hardcoded to 8 for calculating block mining time limits, but the actual maximum blocks count is dynamically reduced to as low as 1 during severe blockchain status. This mismatch causes block production to receive insufficient execution time during stress periods, leading to premature timeouts that prevent chain recovery and create a negative feedback loop.

### Finding Description

The root cause is a hardcoded constant that doesn't align with dynamic blockchain status adjustments: [1](#0-0) 

This hardcoded value is used to calculate timing intervals: [2](#0-1) [3](#0-2) 

However, the actual maximum blocks count is dynamic and varies based on blockchain mining status: [4](#0-3) [5](#0-4) [6](#0-5) 

The `TinyBlockCommandStrategy` receives the dynamic `_maximumBlocksCount` parameter but still uses the hardcoded `DefaultBlockMiningLimit`: [7](#0-6) [8](#0-7) 

This `LimitMillisecondsOfMiningBlock` flows through to create a hard timeout on block execution: [9](#0-8) [10](#0-9) [11](#0-10) 

### Impact Explanation

**Concrete Operational Harm:**
During severe blockchain status (when LIB lags ≥8 rounds), with a typical 4000ms mining interval:
- System reduces maximum blocks from 8 to 1
- But `DefaultBlockMiningLimit` = (4000/8) × 3/5 = 300ms (only 7.5% of time slot)
- Miner has full 4000ms available but receives 300ms timeout
- If block execution requires >300ms (common with moderate transaction load), the cancellation token fires
- Block production is cancelled and fails

**Negative Feedback Loop:**
1. Blockchain enters severe status due to LIB lag
2. System correctly reduces blocks to 1 per slot to aid recovery
3. But block production receives only 300ms timeout (insufficient)
4. Blocks fail to produce due to premature timeout
5. LIB continues lagging, maintaining severe status
6. **Chain cannot self-recover and remains effectively halted**

**Affected Parties:**
- All network participants (miners fail to produce blocks)
- Users (transactions cannot be processed)
- Chain operation (consensus effectively stalled)

**Severity Justification:**
This is a **Medium** severity operational DoS vulnerability because it prevents chain recovery during natural stress periods without requiring active attack, but doesn't directly compromise funds or authorization.

### Likelihood Explanation

**Automatic Triggering:**
The vulnerability activates automatically whenever blockchain mining status becomes abnormal or severe, which occurs naturally when:
- Network connectivity issues cause block propagation delays
- Multiple miners go offline simultaneously
- Chain experiences temporary congestion [12](#0-11) 

**No Attacker Required:**
This is not an active attack vector but a design flaw that manifests during legitimate operational stress. The precondition (LIB lag) occurs naturally in distributed blockchain networks.

**High Probability:**
- Entry point is automatic via consensus mechanism
- No special permissions or setup required
- Occurs whenever LIB lags behind by threshold rounds (≥8)
- Detection: miners repeatedly fail to produce blocks during stress periods
- **Probability: High during network stress, inevitable in certain operational scenarios**

### Recommendation

**Immediate Fix:**
Modify `CommandStrategyBase` to accept and use the actual dynamic maximum blocks count:

1. Add `_maximumBlocksCount` field to `CommandStrategyBase`
2. Calculate `TinyBlockSlotInterval` using actual count instead of hardcoded 8:
   - `TinyBlockSlotInterval => MiningInterval.Div(_maximumBlocksCount)`
3. This ensures timing scales proportionally when blocks are reduced

**Alternative Approach:**
If maintaining backward compatibility is critical, adjust the mining limit calculation to compensate for the reduction:
- `DefaultBlockMiningLimit => TinyBlockSlotInterval.Mul(3).Div(5).Mul(TinyBlocksCount).Div(_maximumBlocksCount)`

**Invariant to Enforce:**
- Block execution timeout must scale proportionally with actual allowed block count
- When maximum blocks = 1, mining limit should use majority of the full mining interval, not 1/8th

**Test Cases:**
1. Verify that during severe status (1 block), mining limit ≥ 50% of mining interval
2. Verify that during abnormal status (reduced blocks), total mining time across allowed blocks utilizes reasonable portion of time slot
3. Test block production success rate during simulated severe status with varying transaction loads

### Proof of Concept

**Initial State:**
- Blockchain operating normally with 17 miners
- Mining interval = 4000ms
- LIB progressing normally

**Exploit Sequence:**

1. **Natural Stress Condition:** Network issues or miner downtime causes LIB to lag 8+ rounds behind current round

2. **System Response:** `GetMaximumBlocksCount()` returns 1 (severe status) [6](#0-5) 

3. **Command Generation:** Miner requests consensus command, receives:
   - `MaximumBlocksCount = 1`
   - `LimitMillisecondsOfMiningBlock = 300ms` (calculated from hardcoded 8)

4. **Block Production Attempt:** Miner attempts to produce block with 50 transactions (typical load)

5. **Timeout Trigger:** Block execution requires 400ms (realistic for moderate load)

6. **Cancellation:** At 300ms, cancellation token fires [10](#0-9) 

7. **Failure:** Block production cancelled, miner produces no block

8. **Feedback Loop:** LIB continues lagging → chain remains in severe status → step 2 repeats

**Expected vs Actual:**
- **Expected:** During severe status, miner gets ≥2000ms (50%+ of slot) to produce critical recovery block
- **Actual:** Miner gets only 300ms (7.5% of slot), causing repeated failures and preventing chain recovery

**Success Condition for Exploit:**
Chain remains stuck in severe status with repeated block production failures, observable through:
- Consecutive "Mining canceled because mining time slot expired" log entries
- LIB height not advancing
- Block production success rate dropping to near-zero during stress periods

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L17-17)
```csharp
        private const int TinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L42-42)
```csharp
        private int TinyBlockSlotInterval => MiningInterval.Div(TinyBlocksCount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L49-49)
```csharp
        protected int DefaultBlockMiningLimit => TinyBlockSlotInterval.Mul(3).Div(5);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L33-33)
```csharp
        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L51-54)
```csharp
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-66)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L87-129)
```csharp
    private class BlockchainMiningStatusEvaluator
    {
        private const int AbnormalThresholdRoundsCount = 2;

        /// <summary>
        ///     Stands for R
        /// </summary>
        private readonly long _currentRoundNumber;

        /// <summary>
        ///     Stands for R_LIB
        /// </summary>
        private readonly long _libRoundNumber;

        /// <summary>
        ///     Stands for CB0
        /// </summary>
        private readonly int _maximumTinyBlocksCount;

        public BlockchainMiningStatusEvaluator(long currentConfirmedIrreversibleBlockRoundNumber,
            long currentRoundNumber, int maximumTinyBlocksCount)
        {
            _libRoundNumber = currentConfirmedIrreversibleBlockRoundNumber;
            _currentRoundNumber = currentRoundNumber;
            _maximumTinyBlocksCount = maximumTinyBlocksCount;
        }

        /// <summary>
        ///     Stands for CB1
        /// </summary>
        public int SevereStatusRoundsThreshold => Math.Max(8, _maximumTinyBlocksCount);

        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L16-22)
```csharp
        private readonly int _maximumBlocksCount;

        public TinyBlockCommandStrategy(Round currentRound, string pubkey, Timestamp currentBlockTime,
            int maximumBlocksCount) : base(
            currentRound, pubkey, currentBlockTime)
        {
            _maximumBlocksCount = maximumBlocksCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L48-51)
```csharp
                    LimitMillisecondsOfMiningBlock = IsLastTinyBlockOfCurrentSlot()
                        ? LastTinyBlockMiningLimit
                        : DefaultBlockMiningLimit
                };
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L98-105)
```csharp
        var limitMillisecondsOfMiningBlock = configuredMiningTime == 0
            ? _consensusCommand.LimitMillisecondsOfMiningBlock
            : configuredMiningTime;
        // Update consensus scheduler.
        var blockMiningEventData = new ConsensusRequestMiningEventData(chainContext.BlockHash,
            chainContext.BlockHeight,
            _nextMiningTime,
            TimestampHelper.DurationFromMilliseconds(limitMillisecondsOfMiningBlock),
```

**File:** src/AElf.Kernel/Miner/Application/MiningService.cs (L50-62)
```csharp
            using var cts = new CancellationTokenSource();
            var expirationTime = blockTime + requestMiningDto.BlockExecutionTime;
            if (expirationTime < TimestampHelper.GetUtcNow())
            {
                cts.Cancel();
            }
            else
            {
                var ts = (expirationTime - TimestampHelper.GetUtcNow()).ToTimeSpan();
                if (ts.TotalMilliseconds > int.MaxValue) ts = TimeSpan.FromMilliseconds(int.MaxValue);

                cts.CancelAfter(ts);
            }
```

**File:** src/AElf.Kernel/Miner/Application/MiningService.cs (L77-78)
```csharp
            var blockExecutedSet = await _blockExecutingService.ExecuteBlockAsync(block.Header,
                systemTransactions, pending, cts.Token);
```
