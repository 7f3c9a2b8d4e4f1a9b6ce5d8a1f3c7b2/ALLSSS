### Title
Infinite Loop DoS in GenerateSymbolNumber() Due to Deterministic Hash Collision

### Summary
The `GenerateSymbolNumber()` function contains a critical infinite loop vulnerability where the do-while loop repeatedly calls a deterministic hash-to-integer conversion with identical parameters. If the generated number already exists in `State.IsCreatedMap`, the loop will never terminate, causing the transaction to fail with out-of-gas. An attacker can deliberately create NFTs with symbol numbers that will be generated by future users, causing complete denial of service for NFT creation.

### Finding Description

The vulnerability exists in the `GenerateSymbolNumber()` function [1](#0-0)  where the collision resolution logic is fundamentally broken.

**Root Cause:**

The function computes `randomHash` once based on the sender's address and random bytes from the consensus contract [2](#0-1) . It then enters a do-while loop that repeatedly calls `Context.ConvertHashToInt64(randomHash, from, from.Mul(10))` [3](#0-2) .

The critical flaw is that `ConvertHashToInt64` is a deterministic pure function [4](#0-3)  that converts a hash to an integer using modulo arithmetic. Since `randomHash` and `from` never change within the loop, the function returns the **exact same number** on every iteration.

If that number already exists in `State.IsCreatedMap`, the condition `State.IsCreatedMap[randomNumber]` remains true forever, creating an infinite loop. The transaction will continue executing until it exhausts its gas limit and fails.

**Why Protections Fail:**

There are no protections against this scenario. The code assumes that if a collision occurs, somehow a different number will be generated on the next iteration, but this is impossible given the deterministic nature of the conversion function and the unchanging input parameters.

### Impact Explanation

**Operational Impact - Complete DoS:**

This vulnerability enables complete denial of service for NFT creation. When triggered:

1. **Transaction Failure**: The victim's `Create()` transaction [5](#0-4)  will enter an infinite loop and fail with out-of-gas error
2. **Permanent Blocking**: For certain sender addresses, NFT creation becomes impossible if their deterministic number is pre-occupied
3. **Protocol Disruption**: Core NFT functionality is broken for affected users

**Affected Users:**

Any user attempting to create an NFT whose computed symbol number has been pre-created by an attacker. Since the number generation is deterministic based on sender address and block randomness (which becomes public after block finalization), attackers can calculate and target specific victims.

**Severity Justification:**

This is a **Critical** severity issue because:
- It completely breaks core protocol functionality (NFT creation)
- It affects arbitrary users without requiring special permissions
- The attack is practical and economically viable
- There is no workaround for affected users

### Likelihood Explanation

**Attack Complexity: Low**

The attack requires only:
1. Observing the blockchain state to obtain random bytes from the previous block
2. Computing `Hash(Hash(victimAddress) || Hash(randomBytes))` 
3. Converting the hash to a number using the same logic as the contract
4. Creating an NFT normally (which occupies that number in `State.IsCreatedMap`)

**Attacker Capabilities:**

- **Public Entry Point**: The `Create()` function is publicly accessible [6](#0-5)  with no special authorization requirements (only chain ID check)
- **No Special Permissions**: Any user can create NFTs
- **Predictable Randomness**: Block random bytes are public and deterministic after block finalization
- **Front-Running**: Attacker can submit transactions before victims in the same block

**Feasibility:**

- The number space starts at 9 digits (100,000,000 to 999,999,999) [7](#0-6) , but the attack doesn't require filling this space
- An attacker only needs to create ONE NFT per victim to DoS them
- Cost is limited to normal NFT creation fees and gas
- Attack can be targeted at specific high-value users or executed broadly

**Economic Rationality:**

The attack is economically rational for:
- Competitors wanting to disrupt a rival's NFT launches
- Attackers seeking ransom (create DoS, demand payment to release the number)
- Griefing attacks on the protocol
- State exhaustion attacks to fill `IsCreatedMap` over time

### Recommendation

**Immediate Fix:**

Modify the `GenerateSymbolNumber()` function to regenerate `randomHash` within the loop by incorporating the iteration count or previous random number:

```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
    {
        Value = Context.CurrentHeight.Sub(1)
    }.ToBytesValue());
    
    long randomNumber;
    var attempt = 0L;
    do
    {
        var randomHash = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(Context.Sender),
            HashHelper.ComputeFrom(randomBytes),
            HashHelper.ComputeFrom(attempt)); // Add iteration counter
        randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        attempt++;
        
        // Add safety limit to prevent infinite loops
        Assert(attempt < 1000, "Failed to generate unique symbol number after 1000 attempts");
    } while (State.IsCreatedMap[randomNumber]);

    return randomNumber;
}
```

**Additional Safeguards:**

1. Add a maximum iteration limit to prevent infinite loops
2. Consider using a nonce-based system instead of pure randomness
3. Add monitoring for repeated collision attempts
4. Implement exponential backoff or penalty for repeated failures

**Test Cases:**

1. Test collision scenario where two transactions in the same block try to create NFTs
2. Test that the same sender can create multiple NFTs in sequence
3. Test behavior when number space approaches saturation
4. Fuzz test with various sender addresses and block heights

### Proof of Concept

**Required Initial State:**
- NFT contract deployed on AELF mainchain
- Attacker has sufficient funds for NFT creation

**Attack Sequence:**

1. **Reconnaissance Phase:**
   - Attacker identifies target victim address: `VictimAddress`
   - Current block height N is mined with random bytes: `RandomBytes_N`

2. **Computation Phase:**
   - Attacker computes: `victimHash = Hash(Hash(VictimAddress) || Hash(RandomBytes_N))`
   - Attacker calculates: `targetNumber = ConvertHashToInt64(victimHash, 100000000, 1000000000)`
   - Result: `targetNumber = 123456789` (example)

3. **Exploitation Phase:**
   - At block N+1, attacker submits transaction to create NFT
   - This causes symbol "XX123456789" to be generated (where XX is NFT type)
   - `State.IsCreatedMap[123456789] = true` is set

4. **Victim DoS:**
   - Victim submits transaction at block N+1 to create NFT with same type
   - `GetSymbol()` calls `GenerateSymbolNumber()`
   - Same `randomHash` is computed (same sender, same random bytes)
   - Loop executes: `ConvertHashToInt64(randomHash, ...) = 123456789`
   - Check: `State.IsCreatedMap[123456789] == true` âœ“
   - Loop repeats infinitely with same inputs
   - Transaction fails with out-of-gas

**Expected vs Actual:**
- **Expected**: Collision detection generates a new random number
- **Actual**: Infinite loop with same number, transaction failure

**Success Condition:**
Victim's NFT creation transaction fails with out-of-gas error while attacker successfully created their NFT with the predicted symbol number.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L169-178)
```csharp
    public long ConvertHashToInt64(Hash hash, long start = 0, long end = long.MaxValue)
    {
        if (start < 0 || start > end) throw new ArgumentException("Incorrect arguments.");

        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-35)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);

```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```
