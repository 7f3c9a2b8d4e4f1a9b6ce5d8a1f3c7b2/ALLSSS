### Title
Missing Resource Amount Validation for Non-Exclusive Side Chains Allows Rental Fee Evasion

### Summary
When creating a side chain with `IsPrivilegePreserved = false`, the `InitialResourceAmount` validation is bypassed, allowing the side chain to be initialized without providing required resource token amounts. This causes `GetResourceUsage()` to return zero for missing resource symbols and `PayRental()` to never charge rental fees for those resources, enabling unlimited free resource consumption.

### Finding Description

The vulnerability exists in the side chain creation validation flow: [1](#0-0) 

When `IsPrivilegePreserved` is `false`, the validation returns early without calling `AssertValidResourceTokenAmount`, which is responsible for ensuring all symbols from `PayRentalSymbolListName` are present in `InitialResourceAmount`: [2](#0-1) 

The unvalidated `InitialResourceAmount` is then passed to `InitializeFromParentChain`, which directly sets `State.ResourceAmount` without any symbol validation: [3](#0-2) 

This creates a mismatch where `GetResourceUsage()` iterates over `PayRentalSymbolListName` but reads from `State.ResourceAmount`, returning zero for any missing symbols: [4](#0-3) 

Similarly, `PayRental()` only charges fees for symbols in `PayRentalSymbolListName`, calculating zero rental for symbols with missing amounts: [5](#0-4) 

### Impact Explanation

A malicious actor can create a non-exclusive side chain by setting `IsPrivilegePreserved = false` and providing an `InitialResourceAmount` with only a subset of required resource symbols (e.g., `{"CPU": 1}` instead of `{"CPU": 1, "RAM": 1, "DISK": 1, "NET": 1}`).

The missing resource symbols (RAM, DISK, NET) will:
1. Report zero usage via `GetResourceUsage()`, hiding actual resource allocations
2. Never be charged rental fees by `PayRental()` (rental = duration × 0 × Rental = 0)
3. Effectively provide unlimited free resources to the side chain

This violates the economic model where side chains must pay rental fees for all allocated resources. The protocol loses rental fee revenue, and resource allocation accounting becomes inconsistent. Exclusive side chains (with `IsPrivilegePreserved = true`) have proper validation, creating an unfair advantage for non-exclusive chains.

### Likelihood Explanation

The attack is highly practical:
- **Entry Point**: `RequestSideChainCreation` is a public method callable by any address with sufficient locked tokens
- **Preconditions**: Attacker only needs to set `IsPrivilegePreserved = false` and provide partial `InitialResourceAmount`
- **Execution**: Single transaction to create the side chain proposal, then standard governance approval/release flow
- **Detection**: The vulnerability is in validation logic, not runtime behavior, making it difficult to detect without code review

The economic cost is reasonable (locked token amount for side chain creation), and the bypass is automatic through the conditional validation logic. Test code confirms non-exclusive side chains are a supported use case: [6](#0-5) 

### Recommendation

**Fix 1**: Enforce resource amount validation regardless of privilege preservation status:

Remove the early return at line 124-125 in `CrossChainContract_Helper.cs::AssertValidSideChainCreationRequest`, or restructure to always call `AssertValidResourceTokenAmount` before the privilege-specific validations.

**Fix 2**: Add validation in `InitializeFromParentChain`:

```csharp
foreach (var pair in input.ResourceAmount) {
    Assert(Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
        "Invalid resource symbol.");
    State.ResourceAmount[pair.Key] = pair.Value;
}

// Ensure all required symbols are present
foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName)) {
    Assert(State.ResourceAmount[symbol] > 0, 
        "All resource symbols must have positive amounts.");
}
```

**Test Case**: Add test that attempts to create a non-exclusive side chain with partial resource amounts and verifies it fails validation.

### Proof of Concept

**Initial State**:
- `PayRentalSymbolListName` configured as "CPU,RAM,DISK,NET" at genesis
- Attacker has approved sufficient locked token amount

**Attack Steps**:
1. Call `RequestSideChainCreation` with:
   - `IsPrivilegePreserved = false`
   - `InitialResourceAmount = {"CPU": 1}` (missing RAM, DISK, NET)
   - Valid `IndexingPrice` and `LockedTokenAmount`

2. Validation passes because line 124-125 returns early for non-exclusive chains

3. Proposal is approved and `ReleaseSideChainCreation` is called

4. `InitializeFromParentChain` sets only `State.ResourceAmount["CPU"] = 1`

5. `GetResourceUsage()` returns `{CPU: 1, RAM: 0, DISK: 0, NET: 0}`

6. `PayRental()` calculates: `rental = duration × 0 × Rental["RAM"] = 0` for RAM, DISK, NET

**Expected Result**: Validation should fail, requiring all resource symbols

**Actual Result**: Side chain created successfully with zero rental charges for RAM, DISK, NET resources

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L124-127)
```csharp
        if (!sideChainCreationRequest.IsPrivilegePreserved)
            return; // there is no restriction for non-exclusive side chain creation

        AssertValidResourceTokenAmount(sideChainCreationRequest);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L139-145)
```csharp
    private void AssertValidResourceTokenAmount(SideChainCreationRequest sideChainCreationRequest)
    {
        var resourceTokenMap = sideChainCreationRequest.InitialResourceAmount;
        foreach (var resourceTokenSymbol in Context.Variables.GetStringArray(PayRentalSymbolListName))
            Assert(resourceTokenMap.ContainsKey(resourceTokenSymbol) && resourceTokenMap[resourceTokenSymbol] > 0,
                "Invalid side chain resource token request.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L14-26)
```csharp
    public override Empty InitializeFromParentChain(InitializeFromParentChainInput input)
    {
        Assert(!State.InitializedFromParentChain.Value, "MultiToken has been initialized");
        State.InitializedFromParentChain.Value = true;
        Assert(input.Creator != null, "creator should not be null");
        foreach (var pair in input.ResourceAmount) State.ResourceAmount[pair.Key] = pair.Value;

        foreach (var pair in input.RegisteredOtherTokenContractAddresses)
            State.CrossChainTransferWhiteList[pair.Key] = pair.Value;

        SetSideChainCreator(input.Creator);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L179-186)
```csharp
    public override ResourceUsage GetResourceUsage(Empty input)
    {
        var usage = new ResourceUsage();
        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName))
            usage.Value.Add(symbol, State.ResourceAmount[symbol]);

        return usage;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1040-1062)
```csharp
        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName))
        {
            var donates = 0L;

            var availableBalance = GetBalance(creator, symbol);

            // Try to update owning rental.
            var owningRental = State.OwningRental[symbol];
            if (owningRental > 0)
            {
                // If Creator own this symbol and current balance can cover the debt, pay the debt at first.
                if (availableBalance > owningRental)
                {
                    donates = owningRental;
                    // Need to update available balance,
                    // cause existing balance not necessary equals to available balance.
                    availableBalance = availableBalance.Sub(owningRental);
                    State.OwningRental[symbol] = 0;
                }
            }

            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
            if (availableBalance >= rental) // Success
```

**File:** test/AElf.Contracts.CrossChain.Tests/CrossChainContractTestBase.cs (L94-96)
```csharp
    internal async Task<int> InitAndCreateSideChainAsync(long parentChainHeightOfCreation = 0,
        int parentChainId = 0, long lockedTokenAmount = 10, long indexingFee = 1, ECKeyPair keyPair = null,
        bool withException = false, bool isPrivilegeReserved = false)
```
