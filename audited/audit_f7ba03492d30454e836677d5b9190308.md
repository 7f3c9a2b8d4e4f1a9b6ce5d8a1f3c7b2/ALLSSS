### Title
Unbounded Storage Accumulation via Large TotalSnapshotNumber

### Summary
The Vote contract allows users to register voting items with arbitrarily large `TotalSnapshotNumber` values without any upper bound validation, and each snapshot creates a permanent `VotingResult` storage entry that is never deleted. While this enables storage bloat, the 1 ELF transaction fee per snapshot acts as a proportional economic deterrent.

### Finding Description

The `Register` method in the Vote contract accepts a `TotalSnapshotNumber` parameter with only a minimum validation (cannot be 0), but no maximum bound: [1](#0-0) 

When a voting item is registered, the first `VotingResult` entry is created in state storage: [2](#0-1) 

Subsequently, the sponsor can call `TakeSnapshot` up to `TotalSnapshotNumber - 1` times, each creating an additional `VotingResult` entry: [3](#0-2) 

The `TakeSnapshot` method only verifies the sponsor's authorization and that the snapshot limit hasn't been reached: [4](#0-3) 

**Critical Finding:** There is no cleanup mechanism anywhere in the contract. The `VotingResults` mapping never deletes entries: [5](#0-4) 

This contrasts with other defensive limits in the same contract, such as `MaximumOptionsCount = 64`: [6](#0-5) 

### Impact Explanation

**Storage Bloat Impact:**
- Each `VotingResult` entry contains a Hash (32 bytes), multiple int64 fields (24 bytes), two Timestamps (~32 bytes), and a map, totaling approximately 88+ bytes per entry
- These entries accumulate indefinitely with no cleanup mechanism
- Over time, across many voting items and users, this creates permanent blockchain state growth

**Economic Considerations:**
- The transaction fee mechanism provides partial mitigation:
  - `Register` costs 10 ELF by default: [7](#0-6) 
  - `TakeSnapshot` costs 1 ELF by default: [8](#0-7) 
- To create N snapshot entries: total cost = 10 + (N-1) Ã— 1 = N + 9 ELF
- Example: 100,000 entries would cost 100,009 ELF + gas for 99,999 transactions

**Severity Assessment:**
While the unlimited bound is a design weakness inconsistent with other defensive coding practices in the contract, the **economic cost provides substantial practical protection**. Creating enough entries to cause meaningful storage bloat (100K+ entries) would cost 100K+ ELF, making it economically irrational for most attackers.

### Likelihood Explanation

**Attack Complexity:**
- **Low technical complexity:** Simply call `Register` with large `TotalSnapshotNumber`, then repeatedly call `TakeSnapshot`
- **High economic barrier:** Each snapshot beyond the first costs 1 ELF
- **High operational burden:** Requires N-1 separate transactions (not automatic)

**Feasibility Conditions:**
- Attacker needs substantial funds (proportional to desired bloat)
- Must execute thousands/millions of transactions
- Each transaction incurs gas costs beyond the method fee
- Block throughput limits constrain execution rate

**Realistic Scenarios:**
1. **Single attacker:** Economically irrational due to linear cost (1 ELF per entry)
2. **Accidental misuse:** User could mistakenly input very large number, but would notice costs when calling TakeSnapshot
3. **Gradual accumulation:** Many legitimate users over time could accumulate moderate amounts, but this represents normal protocol usage

**Probability Assessment:** LOW - The proportional fee mechanism makes significant storage bloat economically prohibitive. While the lack of an explicit upper bound is poor defensive coding practice, the fee structure provides effective economic protection.

### Recommendation

**Primary Fix:** Add an explicit upper bound on `TotalSnapshotNumber` consistent with other defensive limits in the contract:

```csharp
public const int MaximumSnapshotNumber = 1000; // or appropriate value

// In AssertValidNewVotingItem:
if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;
Assert(input.TotalSnapshotNumber <= VoteContractConstants.MaximumSnapshotNumber,
    $"Total snapshot number cannot be greater than {VoteContractConstants.MaximumSnapshotNumber}");
```

**Secondary Considerations:**
- Evaluate if a cleanup mechanism is needed for expired voting items
- Consider if the 1 ELF per snapshot fee is adequate long-term
- Document the intended maximum reasonable snapshot count

**Test Cases:**
- Attempt to register with `TotalSnapshotNumber` exceeding the limit
- Verify appropriate error message
- Test boundary conditions (at limit, limit + 1)

### Proof of Concept

**Attack Sequence:**
1. Attacker calls `Register` with `TotalSnapshotNumber = 100000`
   - Cost: 10 ELF
   - Result: 1 `VotingResult` entry created

2. Attacker calls `TakeSnapshot` 99,999 times sequentially
   - Cost: 99,999 ELF + gas costs
   - Result: 99,999 additional `VotingResult` entries created

3. **Total Attack Cost:** 100,009 ELF + gas for 100,000 transactions

4. **Storage Impact:** 100,000 permanent `VotingResult` entries (~8.8 MB minimum) that never get deleted

**Expected vs Actual:**
- **Expected:** Contract should reject `TotalSnapshotNumber` values exceeding a reasonable limit
- **Actual:** Contract accepts any positive value, allowing unbounded storage accumulation at proportional cost

**Success Condition:** While technically executable, the attack requires ~100K ELF investment for modest storage impact, making it economically irrational and thus not a practical vulnerability.

### Notes

While this finding identifies a **code quality issue** (lack of explicit upper bound validation inconsistent with other defensive practices like `MaximumOptionsCount`), it does **not constitute a practical security vulnerability** due to the effective economic protection provided by the fee mechanism. The 1 ELF per entry cost makes significant storage bloat economically prohibitive. This should be addressed as a defensive coding improvement rather than a critical security fix.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L57-63)
```csharp
        var votingResultHash = GetVotingResultHash(votingItemId, 1);
        State.VotingResults[votingResultHash] = new VotingResult
        {
            VotingItemId = votingItemId,
            SnapshotNumber = 1,
            SnapshotStartTimestamp = input.StartTimestamp
        };
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L245-248)
```csharp
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");

        Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L263-271)
```csharp
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L358-359)
```csharp
        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;
```

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L11-14)
```csharp
    /// <summary>
    ///     This hash is calculated by: voting_item_id & epoch_number
    /// </summary>
    public MappedState<Hash, VotingResult> VotingResults { get; set; }
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L3-7)
```csharp
public static class VoteContractConstants
{
    public const int MaximumOptionsCount = 64;
    public const int OptionLengthLimit = 1024;
}
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L42-49)
```csharp
            case nameof(Register):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L50-58)
```csharp
            default:
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 1_00000000 }
                    }
                };
        }
```
