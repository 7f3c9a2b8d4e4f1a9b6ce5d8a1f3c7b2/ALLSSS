### Title
Continuous Block Limit Bypass via Candidate Public Key Replacement

### Summary
A miner can bypass the continuous blocks production limit by exploiting the candidate public key replacement mechanism. When `ReplaceCandidatePubkey` is called, the consensus contract updates round information but fails to update the `LatestPubkeyToTinyBlocksCount` state, creating a pubkey mismatch that allows the validation checks to be bypassed and the counter to be reset, enabling unlimited continuous block production.

### Finding Description

The AEDPoS consensus system enforces a continuous blocks limit to prevent network forks and ensure decentralization. This limit is tracked in `State.LatestPubkeyToTinyBlocksCount` and enforced through three checkpoints:

**Validation Check:** [1](#0-0) 

**Command Generation Check:** [2](#0-1) 

**Counter Reset Logic:** [3](#0-2) 

All three checks compare the stored pubkey in `LatestPubkeyToTinyBlocksCount` against the current miner's pubkey.

**Root Cause:** When a miner calls `ReplaceCandidatePubkey` through the Election contract, the consensus contract's `RecordCandidateReplacement` method updates the round information: [4](#0-3) 

However, the `LatestPubkeyToTinyBlocksCount` state is **never updated** to reflect the new pubkey. This creates a permanent mismatch where:
- `LatestPubkeyToTinyBlocksCount.Pubkey` = old pubkey
- `SenderPubkey` / `_processingBlockMinerPubkey` = new pubkey

When the miner produces the next block with their new key, all three pubkey equality checks fail, causing:
1. Validation to pass even if `BlocksCount < 0`
2. `GetConsensusCommand` to not force `NextRound` behavior
3. Counter to reset to maximum value instead of decrementing

The Election contract allows this replacement: [5](#0-4) 

No rate limiting exists on key replacements, and miners typically control their admin accounts, making this exploit practical.

### Impact Explanation

**Consensus Integrity Violation:** The continuous blocks limit exists to prevent network instability and forks. The maximum limit is defined as: [6](#0-5) 

This mechanism is dynamically adjusted based on blockchain health: [7](#0-6) 

By bypassing this limit, a miner can:
- Produce unlimited continuous blocks (by repeatedly changing keys)
- Defeat fork prevention mechanisms
- Cause network synchronization issues for other nodes
- Violate protocol-level decentralization guarantees
- Undermine the blockchain health monitoring system

**Affected Parties:** All network participants suffer from potential network instability and increased fork risk.

**Severity:** Medium - violates a critical consensus safety mechanism but requires some preparation (multiple keypairs) and is visible on-chain.

### Likelihood Explanation

**Attacker Capabilities:**
- Miner must control their candidate admin account (typical scenario as verified in permission check)
- Miner must have multiple valid keypairs prepared in advance
- Each old key becomes banned after replacement: [8](#0-7) 

**Attack Complexity:** Low - requires only calling a public contract method between block productions

**Feasibility:** High
- Entry point is the publicly accessible `ReplaceCandidatePubkey` method
- No rate limiting or cooldown period exists on key replacements
- Miner can prepare multiple keypairs offline before attack
- Execution between blocks is straightforward

**Detection:** Partial - replacements are visible on-chain via events: [9](#0-8) 

However, distinguishing legitimate replacements from exploit attempts is difficult.

**Economic Rationality:** High - minimal cost (only transaction fees), no collateral at risk, potential advantage in block production.

**Overall Likelihood:** Medium - practical for any miner to execute with modest preparation.

### Recommendation

**Primary Fix:** Update `RecordCandidateReplacement` to handle `LatestPubkeyToTinyBlocksCount` state:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");

    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

    // Update LatestPubkeyToTinyBlocksCount if affected miner is the current producer
    if (State.LatestPubkeyToTinyBlocksCount.Value != null &&
        State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == input.OldPubkey)
    {
        State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
        {
            Pubkey = input.NewPubkey,
            BlocksCount = State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount
        };
    }

    // ... rest of existing logic
}
```

**Secondary Mitigation:** Add rate limiting to `ReplaceCandidatePubkey`:
- Track last replacement timestamp per candidate
- Enforce minimum cooldown period (e.g., 1 round or 1 term)
- Prevent replacements during active block production periods

**Invariant Check:** Add assertion in validation/reset logic to detect pubkey chain:
- Query Election contract for pubkey replacement history
- Resolve through replacement chain to find effective pubkey
- Compare against resolved pubkey instead of literal match

**Test Cases:**
1. Miner produces blocks up to limit, replaces key, verifies counter persists
2. Miner attempts bypass, verifies validation still enforces limit
3. Multiple replacements in sequence still maintain counter continuity

### Proof of Concept

**Initial State:**
- Miner A is an active block producer
- `LatestPubkeyToTinyBlocksCount.Pubkey = "MinerA"`
- `LatestPubkeyToTinyBlocksCount.BlocksCount = 0`
- Miner A has prepared keypair "MinerA_new"

**Attack Sequence:**

1. Miner A produces one more block
   - Validation passes (BlocksCount = 0, not negative)
   - After execution: `BlocksCount = -1`

2. Miner A (as admin) calls `Election.ReplaceCandidatePubkey(oldPubkey: "MinerA", newPubkey: "MinerA_new")`
   - Election contract updates all candidate state
   - Consensus contract receives `RecordCandidateReplacement`
   - Round information updated to use "MinerA_new"
   - **`LatestPubkeyToTinyBlocksCount` remains unchanged with Pubkey = "MinerA", BlocksCount = -1**

3. Miner A (now using "MinerA_new" key) produces next block
   - `SenderPubkey` = "MinerA_new"
   - `LatestPubkeyToTinyBlocksCount.Pubkey` = "MinerA"
   - Equality check: "MinerA" == "MinerA_new" â†’ FALSE
   - **Validation bypassed despite BlocksCount = -1**
   - `_processingBlockMinerPubkey` = "MinerA_new"
   - Counter reset: `BlocksCount = minersCountInTheory - 1` (e.g., 7)

**Expected Result:** Validation should fail due to BlocksCount = -1

**Actual Result:** Validation passes and counter resets, allowing unlimited continuous block production through repeated key changes

**Success Condition:** Miner successfully produces blocks beyond the configured limit without triggering `NextRound` behavior

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L17-19)
```csharp
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L352-363)
```csharp
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L140-143)
```csharp
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L245-246)
```csharp
        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L250-254)
```csharp
        Context.Fire(new CandidatePubkeyReplaced
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L17-55)
```csharp
    /// <summary>
    ///     Implemented GitHub PR #1952.
    ///     Adjust (mainly reduce) the count of tiny blocks produced by a miner each time to avoid too many forks.
    /// </summary>
    /// <returns></returns>
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }
```
