# Audit Report

## Title
Permanent DOS of Method Fee Governance via Cross-Contract Authority with Near-Impossible Approval Thresholds

## Summary
The `ChangeMethodFeeController()` function in the Association contract lacks validation of approval threshold reasonableness, allowing the method fee controller to be changed to a Parliament organization with near-impossible thresholds (up to 9999/10000 = 99.99% approval). This permanently freezes all future method fee adjustments with no recovery mechanism, creating a critical governance DOS vulnerability.

## Finding Description

**Root Cause - Missing Threshold Validation:**

The `ChangeMethodFeeController()` method in the Association contract only performs two validations: sender authorization and organization existence. [1](#0-0) 

The organization existence check is performed via `CheckOrganizationExist()`, which only calls the target contract's `ValidateOrganizationExist` method and returns a boolean - it performs no validation of governance parameters like approval thresholds. [2](#0-1) 

**Parliament Threshold Limits:**

Parliament organizations use ratio-based thresholds validated against `AbstractVoteTotal = 10000` (representing 100%). [3](#0-2) 

The validation logic allows `MinimalApprovalThreshold` up to `MinimalVoteThreshold`, which can be up to 10000 (100%). [4](#0-3) 

**Test Confirmation:**

Test cases explicitly confirm that Parliament organizations with `MinimalApprovalThreshold = 10000` (100%) are valid and can be created successfully. [5](#0-4) 

Integration tests demonstrate that Parliament organizations can be set as the Association contract's method fee controller through the standard proposal process. [6](#0-5) 

**Approval Formula Creates DOS:**

Parliament's approval check requires: `approvedMemberCount * AbstractVoteTotal >= MinimalApprovalThreshold * parliamentMembers.Count` [7](#0-6) 

With `MinimalApprovalThreshold = 9999` and 100 miners, this requires `approvedMemberCount >= 99.99`, which rounds to 100 miners (100% consensus) - practically impossible in real-world governance.

**No Recovery Mechanism:**

The `RequiredMethodFeeControllerSet()` function only initializes the controller if it's null - once set to a high-threshold organization, there is no automatic recovery path. [8](#0-7) 

**Attack Execution Path:**

1. Miner creates Parliament organization with `MinimalApprovalThreshold = 9999, MinimalVoteThreshold = 10000`
2. Current controller (default Parliament with 66.67% threshold) creates proposal to change Association's method fee controller to the new Parliament organization
3. Proposal approved with 66.67% miner support and released
4. Association's method fee controller is now a Parliament organization requiring 99.99% approval
5. All future controller changes require 99.99% consensus - effectively impossible

## Impact Explanation

**Critical Severity Justification:**

**Permanent Governance Lockout:** Once the controller is set to a near-impossible threshold organization, the method fee governance becomes permanently frozen. The approval formula requires 99.99% consensus for 9999/10000 threshold, which means with 100 miners, even 99 out of 100 approvals (99%) would fail.

**No Recovery Path:** There is no emergency override, admin intervention, or time-based fallback mechanism. The only way to change the controller is through the controller itself, creating a circular dependency.

**Broad System Impact:** Method fees control transaction costs for all Association contract operations. Frozen fees mean:
- Cannot respond to token price fluctuations (fees become prohibitively expensive or worthlessly cheap)
- Cannot adjust for network congestion
- May render contract operations economically infeasible
- Affects all users of the Association governance system

**Quantified Damage:** With 9999/10000 threshold and 100 miners, achieving approval requires all 100 miners to vote yes. Real-world challenges include miner downtime, key management issues, coordination difficulties, and potential malicious holdouts - making 100% consensus practically impossible.

## Likelihood Explanation

**Feasibility: MEDIUM-HIGH**

**Attacker Requirements:**
- Control of current method fee controller (default is Parliament's default organization with 6667/10000 = 66.67% threshold) [9](#0-8) 

- Ability to create Parliament organizations (any miner or whitelisted proposer can do this) [10](#0-9) 

**Attack Complexity: LOW**
- Uses standard governance procedures (create organization, create proposal, get approvals, release)
- No special privileges required beyond 66.67% miner approval
- Test infrastructure proves this works in practice

**Realistic Scenarios:**
1. **Malicious**: 66.67% miner collusion to permanently capture fee governance
2. **Accidental**: Well-intentioned proposal to "enhance security" with high thresholds without realizing irreversibility
3. **Social Engineering**: Misleading proposal descriptions that hide the governance implications

**No Detection/Prevention:**
- No threshold sanity checks in `ChangeMethodFeeController`
- No warnings for dangerously high thresholds
- No upper bound below 100% to prevent near-impossible governance

## Recommendation

**Immediate Fix: Add Threshold Validation**

Add validation in `ChangeMethodFeeController` to reject organizations with unreasonably high thresholds:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    // NEW: Validate threshold reasonableness
    ValidateReasonableThreshold(input);
    
    State.MethodFeeController.Value = input;
    return new Empty();
}

private void ValidateReasonableThreshold(AuthorityInfo authorityInfo)
{
    // For Parliament organizations, prevent near-impossible thresholds
    if (authorityInfo.ContractAddress == State.ParliamentContract.Value)
    {
        var org = State.ParliamentContract.GetOrganization.Call(authorityInfo.OwnerAddress);
        const long maxReasonableThreshold = 9500; // 95% max
        Assert(org.ProposalReleaseThreshold.MinimalApprovalThreshold <= maxReasonableThreshold,
            "Approval threshold too high - would create governance DOS");
    }
}
```

**Long-term Solutions:**
1. Implement emergency recovery mechanism for stuck controllers
2. Add time-based fallback to default controller after inactivity
3. Require multi-step confirmation for high-threshold changes
4. Add monitoring/alerts for dangerous governance proposals

## Proof of Concept

```csharp
[Fact]
public async Task MethodFeeGovernanceDOS_Via_ImpossibleThreshold()
{
    // Step 1: Create Parliament organization with near-impossible threshold (9999/10000)
    var createOrgResult = await ParliamentContractStub.CreateOrganization.SendAsync(
        new Parliament.CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 9999,  // 99.99% approval required
                MinimalVoteThreshold = 10000,
                MaximalAbstentionThreshold = 0,
                MaximalRejectionThreshold = 0
            }
        });
    var impossibleOrg = Address.Parser.ParseFrom(createOrgResult.TransactionResult.ReturnValue);
    
    // Step 2: Change Association's method fee controller to impossible org
    var methodFeeController = await AssociationContractStub.GetMethodFeeController.CallAsync(new Empty());
    var proposalId = await CreateFeeProposalAsync(
        AssociationContractAddress,
        methodFeeController.OwnerAddress,
        nameof(AssociationContractStub.ChangeMethodFeeController),
        new AuthorityInfo
        {
            OwnerAddress = impossibleOrg,
            ContractAddress = ParliamentContractAddress
        });
    
    // Step 3: Get default Parliament approval (66.67% threshold)
    await ApproveWithMinersAsync(proposalId);
    await ParliamentContractStub.Release.SendAsync(proposalId);
    
    // Step 4: Verify controller changed
    var newController = await AssociationContractStub.GetMethodFeeController.CallAsync(new Empty());
    Assert.Equal(impossibleOrg, newController.OwnerAddress);
    
    // Step 5: Prove permanent DOS - even with 99% miner approval, cannot change back
    var recoveryProposalId = await ParliamentContractStub.CreateProposal.SendAsync(
        new CreateProposalInput
        {
            OrganizationAddress = impossibleOrg,
            ToAddress = AssociationContractAddress,
            ContractMethodName = nameof(AssociationContractStub.ChangeMethodFeeController),
            Params = new AuthorityInfo { /* attempt to change back */ }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
        });
    
    // Get 99 out of 100 miner approvals
    for (int i = 0; i < 99; i++)
    {
        var minerStub = GetParliamentContractTester(InitialMinersKeyPairs[i]);
        await minerStub.Approve.SendAsync(recoveryProposalId.Output);
    }
    
    // Attempt to release - FAILS because 99/100 < 9999/10000 threshold
    var releaseResult = await ParliamentContractStub.Release.SendWithExceptionAsync(recoveryProposalId.Output);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
    
    // Governance is permanently frozen - DOS achieved
}
```

### Citations

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L49-63)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L70-74)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L5-5)
```csharp
    private const int DefaultOrganizationMinimalApprovalThreshold = 6667;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L188-196)
```csharp
            createOrganizationInput.ProposalReleaseThreshold = proposalReleaseThreshold;
            createOrganizationInput.ProposalReleaseThreshold.MinimalApprovalThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MinimalVoteThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MaximalAbstentionThreshold = 0;
            createOrganizationInput.ProposalReleaseThreshold.MaximalRejectionThreshold = 0;
            var transactionResult =
                await minerParliamentContractStub.CreateOrganization.SendAsync(createOrganizationInput);
            transactionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        }
```

**File:** test/AElf.Contracts.Association.Tests/AssociationContractTests.cs (L863-897)
```csharp
    public async Task ChangeMethodFeeController_Test()
    {
        var createOrganizationResult =
            await ParliamentContractStub.CreateOrganization.SendAsync(
                new Parliament.CreateOrganizationInput
                {
                    ProposalReleaseThreshold = new ProposalReleaseThreshold
                    {
                        MinimalApprovalThreshold = 1000,
                        MinimalVoteThreshold = 1000
                    }
                });
        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.TransactionResult.ReturnValue);

        var methodFeeController = await AssociationContractStub.GetMethodFeeController.CallAsync(new Empty());
        var defaultOrganization = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
        methodFeeController.OwnerAddress.ShouldBe(defaultOrganization);

        const string proposalCreationMethodName = nameof(AssociationContractStub.ChangeMethodFeeController);

        var proposalId = await CreateFeeProposalAsync(AssociationContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName, new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = ParliamentContractAddress
            });

        await ApproveWithMinersAsync(proposalId);
        var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId);
        releaseResult.TransactionResult.Error.ShouldBeNullOrEmpty();
        releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var newMethodFeeController = await AssociationContractStub.GetMethodFeeController.CallAsync(new Empty());
        Assert.True(newMethodFeeController.OwnerAddress == organizationAddress);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L50-59)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        Assert(
            ValidateAddressInWhiteList(Context.Sender) || ValidateParliamentMemberAuthority(Context.Sender) ||
            State.DefaultOrganizationAddress.Value == Context.Sender,
            "Unauthorized to create organization.");
        var organizationAddress = CreateNewOrganization(input);

        return organizationAddress;
    }
```
