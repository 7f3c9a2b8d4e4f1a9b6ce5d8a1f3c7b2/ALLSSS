### Title
Continuous Blocks Validation Bypass via Manipulated Round Number in UpdateValue

### Summary
The `RecoverFromUpdateValue()` function does not validate that the `providedRound.RoundNumber` matches the current round number, only checking for pubkey existence. A malicious block producer can exploit this by setting `ProvidedRound.RoundNumber` to a value ≤ 2 while maintaining correct `RoundIdForValidation`, thereby bypassing the `ContinuousBlocksValidationProvider` check and producing more consecutive blocks than consensus rules allow.

### Finding Description

**Root Cause:**
The `RecoverFromUpdateValue()` function performs minimal validation on the provided round: [1](#0-0) 

It only checks whether the pubkey exists in both rounds but does not validate critical round identity fields like `RoundNumber` or `TermNumber`. The function then proceeds to merge data from the provided round into the base round without verifying round consistency.

**Validation Gap:**
During `ValidateBeforeExecution`, the consensus extra data's Round object is used to recover the base round before validation providers execute: [2](#0-1) 

For UpdateValue behavior, the validation pipeline includes `ContinuousBlocksValidationProvider`, which relies on `ProvidedRound.RoundNumber` to determine whether to enforce continuous blocks limits: [3](#0-2) 

The check `ProvidedRound.RoundNumber > 2` is intended to skip validation only during the first two rounds (bootstrap period). However, since `ProvidedRound` comes from the attacker-controlled consensus header: [4](#0-3) 

**Why Existing Protections Fail:**
While `TimeSlotValidationProvider` validates that `ProvidedRound.RoundId` matches `BaseRound.RoundId`: [5](#0-4) 

The `RoundId` is computed from `ExpectedMiningTime` or falls back to `RoundIdForValidation`. In the simplified UpdateValue round, `ExpectedMiningTime` is not populated, so it uses `RoundIdForValidation`: [6](#0-5) 

An attacker can set both `RoundIdForValidation` (to match current round) and `RoundNumber` (to ≤ 2) independently, passing the RoundId check while bypassing the continuous blocks validation.

### Impact Explanation

**Consensus Integrity Violation:**
The continuous blocks check exists to prevent any single miner from dominating block production. The system tracks how many consecutive blocks each miner produces via `LatestPubkeyToTinyBlocksCount`: [7](#0-6) 

By bypassing this check, a malicious miner can:
1. Continue producing blocks even after exceeding the allowed consecutive block limit
2. Monopolize block production and associated mining rewards
3. Cause denial-of-service by preventing other miners from producing blocks
4. Centralize consensus, undermining the distributed nature of the AEDPoS protocol

**Affected Parties:**
- Honest miners lose block production opportunities and mining rewards
- The entire network suffers from reduced decentralization
- Users experience degraded consensus security guarantees

**Severity Justification:**
This is a **High severity** vulnerability because it directly violates core consensus invariants, allowing an attacker to manipulate the miner schedule integrity and time-slot validation rules outlined in the critical invariants section.

### Likelihood Explanation

**Attacker Capabilities:**
The attacker must be an active miner with block production rights, which is a realistic precondition in the AEDPoS consensus system.

**Attack Complexity:**
The attack is straightforward:
1. Miner produces blocks until `LatestPubkeyToTinyBlocksCount.BlocksCount` becomes negative
2. Instead of being forced to switch to NextRound behavior, the miner crafts a malicious consensus header
3. Sets `ProvidedRound.RoundNumber = 1` (or 2) in the header
4. Sets `ProvidedRound.RoundIdForValidation` to the current round's RoundId
5. Submits the block with UpdateValue behavior
6. Validation passes because the RoundNumber check is bypassed

**Feasibility:**
The block producer controls the consensus header information created during block generation. While the honest path sets RoundNumber correctly via `GetUpdateValueRound`: [8](#0-7) 

A malicious producer can modify this field before submitting the block, as the consensus header is part of the block's extra data controlled by the producer.

**Detection Constraints:**
The attack leaves no obvious traces beyond the miner producing more consecutive blocks than expected. Network observers would notice abnormal block production patterns, but by then the damage is done.

### Recommendation

**Immediate Fix:**
Add explicit round identity validation in `RecoverFromUpdateValue()`:

```csharp
public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
{
    if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
        !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
        return this;
    
    // Add validation for round identity
    if (providedRound.RoundNumber != this.RoundNumber)
        return this; // Or throw exception
    
    if (providedRound.TermNumber != this.TermNumber)
        return this; // Or throw exception
    
    // Existing recovery logic...
}
```

**Additional Validation Layer:**
Add a dedicated validation provider for UpdateValue that explicitly checks round identity:

```csharp
public class RoundIdentityValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        if (validationContext.ProvidedRound.RoundNumber != validationContext.CurrentRoundNumber)
            return new ValidationResult { Message = "Provided round number doesn't match current round." };
            
        if (validationContext.ProvidedRound.TermNumber != validationContext.CurrentTermNumber)
            return new ValidationResult { Message = "Provided term number doesn't match current term." };
            
        return new ValidationResult { Success = true };
    }
}
```

Then add this provider to the UpdateValue validation pipeline: [9](#0-8) 

**Test Cases:**
1. Attempt UpdateValue with `ProvidedRound.RoundNumber` < current round → should fail
2. Attempt UpdateValue with `ProvidedRound.RoundNumber` > current round → should fail
3. Attempt UpdateValue with mismatched `TermNumber` → should fail
4. Verify continuous blocks limit still enforced after fix

### Proof of Concept

**Initial State:**
- Blockchain at round 100, term 5
- Miner A has already produced 8 consecutive blocks
- `State.LatestPubkeyToTinyBlocksCount.Value.Pubkey = "MinerA"`
- `State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount = -1` (exceeded limit)

**Attack Steps:**

1. Miner A should now be forced to produce a NextRound block according to: [10](#0-9) 

2. Instead, Miner A crafts malicious consensus header:
   - `AElfConsensusHeaderInformation.Behaviour = UpdateValue`
   - `AElfConsensusHeaderInformation.Round.RoundNumber = 1`
   - `AElfConsensusHeaderInformation.Round.RoundIdForValidation = [current round's RoundId]`
   - `AElfConsensusHeaderInformation.SenderPubkey = "MinerA"`

3. Submit block with UpdateValue transaction

**Expected Result (Current Behavior):**
- `ValidateBeforeExecution` is called
- `RecoverFromUpdateValue` accepts the malicious round (only checks pubkey)
- `ContinuousBlocksValidationProvider.ValidateHeaderInformation` executes
- Check `ProvidedRound.RoundNumber > 2` evaluates to `1 > 2 = false`
- Continuous blocks validation is skipped
- Block is accepted
- Miner A continues producing blocks indefinitely

**Expected Result (After Fix):**
- `ValidateBeforeExecution` is called  
- `RecoverFromUpdateValue` detects `providedRound.RoundNumber (1) != this.RoundNumber (100)`
- Returns without merging, OR new `RoundIdentityValidationProvider` detects mismatch
- Validation fails with "Provided round number doesn't match current round"
- Block is rejected
- Miner A cannot bypass the continuous blocks limit

**Notes**

The vulnerability exists because the original design assumed block producers would honestly populate all consensus header fields. However, the system must be Byzantine-fault-tolerant and validate all attacker-controllable inputs. The `RoundIdForValidation` field alone is insufficient for round identity verification, as it can be manipulated independently of `RoundNumber`.

The issue is distinct from the described "future round data injection" scenario but represents a real exploitable validation bypass affecting consensus fairness and security.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L10-12)
```csharp
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-14)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-14)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L16-16)
```csharp
            RoundNumber = RoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```
