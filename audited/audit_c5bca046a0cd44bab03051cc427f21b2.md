### Title
One-Round Delay in Evil Miner Replacement Due to Incomplete Disqualification Check

### Summary
The `GetEvilMinersPubkeys` method only checks `BannedPubkeyMap` status without considering miners who have exceeded the `TolerableMissedTimeSlotsCount` threshold in the current round. Due to a timing gap where `GetMinerReplacementInformation` is called during round generation (before evil miners are marked in `BannedPubkeyMap` during round processing), evil miners are not detected until one round later, allowing them to continue serving and earning rewards for an additional round.

### Finding Description

The vulnerability exists in the interaction between the Election contract's `GetMinerReplacementInformation` method and the Consensus contract's round generation logic.

**Location 1 - Incomplete Check:** [1](#0-0) 

The `GetEvilMinersPubkeys` method only checks if a miner is in `BannedPubkeyMap`, without considering current round performance metrics like `MissedTimeSlots`.

**Location 2 - Timing Gap in Round Generation:** [2](#0-1) 

During `GenerateNextRoundInformation`, the consensus contract calls `GetMinerReplacementInformation` to identify evil miners for replacement in the next round.

**Location 3 - Evil Miner Detection Logic:** [3](#0-2) 

The `TryToDetectEvilMiners` method correctly identifies miners with `MissedTimeSlots >= TolerableMissedTimeSlotsCount`.

**Location 4 - Delayed Marking:** [4](#0-3) 

Evil miners are only marked in `BannedPubkeyMap` during `ProcessNextRound`, which occurs AFTER the next round has already been generated by `GenerateNextRoundInformation`.

**Root Cause:** 
The execution sequence creates a timing gap:
1. `GenerateNextRoundInformation` is called during block generation (for round N+1)
2. It calls `GetMinerReplacementInformation` to find evil miners
3. `GetEvilMinersPubkeys` checks `BannedPubkeyMap` but finds nothing (miners who exceeded threshold in round N aren't marked yet)
4. Round N+1 is generated without replacing these evil miners
5. Later during block processing, `ProcessNextRound` detects and marks evil miners in `BannedPubkeyMap`
6. But it's too late - they remain in round N+1's miner list
7. They are only replaced in round N+2 [5](#0-4) 

### Impact Explanation

**Consensus Integrity Degradation:**
Evil miners who have demonstrated poor performance (missed time slots) continue participating in consensus for one extra round after exceeding the threshold. This allows them to:
- Continue missing time slots, degrading consensus performance and block production reliability
- Potentially earn miner rewards (subsidy and welfare distributions) they should not receive
- Maintain voting power in consensus decisions for an additional round

**Quantified Impact:**
- **Duration**: One complete consensus round (typically several hours)
- **Affected Parties**: All network participants suffer from reduced consensus quality
- **Reward Misallocation**: Evil miners receive profit scheme distributions (Treasury subsidy/welfare) for the extra round
- **Performance Degradation**: Network continues operating with underperforming miners [6](#0-5) 

The severity is High because this affects the core consensus invariant that miners must meet performance thresholds, and allows reward misallocation to disqualified participants.

### Likelihood Explanation

**Certainty: High** - This occurs automatically through normal consensus operations.

**Preconditions:**
- Main chain operation (evil miner detection only runs on main chain) [7](#0-6) 
- Any miner exceeds `TolerableMissedTimeSlotsCount` in a round
- No attacker action required - this is a design flaw in the timing sequence

**Attack Complexity:** None - this is not an attack but an inherent timing issue in the architecture. The vulnerability manifests naturally whenever miners perform poorly.

**Feasibility:** Guaranteed to occur for any miner that:
1. Misses sufficient time slots in round N to exceed threshold
2. Automatically remains in the miner list for round N+1
3. Is only replaced starting in round N+2

**Detection Constraints:** This one-round delay is observable in the consensus logs but may appear as intended behavior without deep code analysis.

### Recommendation

**Option 1 - Pre-Mark Evil Miners (Recommended):**
In `GenerateNextRoundInformation` (before calling `GetMinerReplacementInformation`), the Consensus contract should:
1. Call `currentRound.TryToDetectEvilMiners(out var evilMiners)` 
2. Mark detected evil miners in Election contract's `BannedPubkeyMap` by calling `UpdateCandidateInformation` with `IsEvilNode = true`
3. Then call `GetMinerReplacementInformation` which will now correctly identify them

**Option 2 - Pass Performance Data:**
Modify `GetMinerReplacementInformationInput` to include current round's `MissedTimeSlots` data:
```protobuf
message GetMinerReplacementInformationInput {
    repeated string current_miner_list = 1;
    map<string, int64> miner_missed_time_slots = 2; // Add this field
}
```

Then update `GetEvilMinersPubkeys` to check both `BannedPubkeyMap` AND whether `MissedTimeSlots >= TolerableMissedTimeSlotsCount` from the input data.

**Option 3 - Enhance GetEvilMinersPubkeys:**
If the Election contract can query Consensus contract state, have `GetEvilMinersPubkeys` also check the current round's `MissedTimeSlots` directly. However, this creates cross-contract dependency issues.

**Testing:**
Add test case verifying that when a miner exceeds `TolerableMissedTimeSlotsCount` in round N, they are excluded from the miner list in round N+1 (not N+2).

### Proof of Concept

**Initial State:**
- Main chain with 17 active miners
- Round N in progress
- Miner M has `MissedTimeSlots = TolerableMissedTimeSlotsCount - 1`

**Exploit Sequence:**

1. **During Round N:**
   - Miner M misses their time slot
   - `MissedTimeSlots` counter increments to equal `TolerableMissedTimeSlotsCount` [3](#0-2) 

2. **Block Generation for Round N+1:**
   - Extra block producer generates block to transition to round N+1
   - `GetConsensusExtraDataForNextRound` calls `GenerateNextRoundInformation` [5](#0-4) 
   - `GetMinerReplacementInformation` is called with current miner list including M [2](#0-1) 
   - `GetEvilMinersPubkeys` checks `BannedPubkeyMap[M]` â†’ returns `false` (M not banned yet) [1](#0-0) 
   - M is NOT included in `EvilMinerPubkeys` list
   - Round N+1 miner list is generated WITH M still included

3. **Block Processing:**
   - `ProcessNextRound` is called
   - `TryToDetectEvilMiners` identifies M (has `MissedTimeSlots >= threshold`)
   - `UpdateCandidateInformation` marks M in `BannedPubkeyMap` [8](#0-7) 
   - But round N+1 already started with M in the miner list

4. **Round N+1 Execution:**
   - M remains in the miner list for entire round N+1
   - M can continue mining (or missing) blocks
   - M receives profit distributions for round N+1

5. **Round N+2 Generation:**
   - `GetMinerReplacementInformation` NOW finds M in `BannedPubkeyMap`
   - M is finally replaced in round N+2

**Expected Result:** M should be replaced in round N+1

**Actual Result:** M is replaced in round N+2 (one-round delay)

**Success Condition:** Verify by logging that miner M with `MissedTimeSlots >= TolerableMissedTimeSlotsCount` at end of round N is still present in round N+1's `RealTimeMinersInformation` but absent in round N+2.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L360-360)
```csharp
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-305)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L176-176)
```csharp
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```
