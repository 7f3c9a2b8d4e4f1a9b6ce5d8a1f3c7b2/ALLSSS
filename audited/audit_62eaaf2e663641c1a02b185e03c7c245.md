# Audit Report

## Title
Association Governance Bypass via Post-Vote Membership Manipulation

## Summary
The Association contract contains a critical inconsistency in vote counting logic within the `CheckEnoughVoteAndApprovals` helper function. While rejection, abstention, and approval counts are filtered by current organization membership, the total vote threshold check counts ALL historical votes regardless of membership status. This allows organizations to bypass `MaximalAbstentionThreshold` and `MaximalRejectionThreshold` constraints by removing members after they vote. [1](#0-0) 

## Finding Description

The vulnerability exists in the threshold validation logic used by the `Release()` function to determine if a proposal can be executed. The root cause is inconsistent membership filtering across different vote counting operations within the helper functions.

**Rejection count** correctly filters by current membership: [2](#0-1) 

**Abstention count** correctly filters by current membership: [3](#0-2) 

**Approval count** correctly filters by current membership: [4](#0-3) 

**Total vote count** INCORRECTLY does NOT filter by membership: [5](#0-4) 

The total vote count uses `.Count()` on concatenated lists without applying `.Contains()` membership filtering, unlike all other vote counting operations. This creates a bypass opportunity.

**Attack Sequence:**

1. A proposal (Proposal A) is created and receives votes that exceed `MaximalAbstentionThreshold` or `MaximalRejectionThreshold`, blocking its release
2. The organization passes a separate `RemoveMember` proposal to remove the dissenting/abstaining members [6](#0-5) 

3. When `Release()` is called on Proposal A, the validation checks against the current (modified) membership list: [7](#0-6) 

4. The abstention/rejection counts become 0 (since removed members are no longer in `OrganizationMemberList`), but the total vote count remains unchanged (unfiltered)
5. Proposal A now passes all threshold checks and can be released, despite originally being blocked

The `Validate()` function only checks threshold consistency at organization creation time and does not prevent retroactive manipulation: [8](#0-7) 

## Impact Explanation

This vulnerability has **HIGH severity** impact because:

1. **Direct Governance Bypass**: Organizations can execute proposals that were legitimately blocked by `MaximalAbstentionThreshold` or `MaximalRejectionThreshold` protections. These thresholds are fundamental governance safeguards designed to ensure proposals don't pass with excessive opposition.

2. **Violation of Governance Invariants**: The contract explicitly provides these threshold mechanisms to protect against contentious proposals. The bug completely undermines this protection, allowing minority factions to force through proposals that the broader membership rejected or abstained from.

3. **Widespread Applicability**: Any Association-based organization using abstention or rejection thresholds (a common security-conscious configuration) is vulnerable. This affects all downstream contracts and systems governed by these organizations.

4. **Trust Model Breach**: Members who voted to block a proposal through abstention or rejection lose their governance power retroactively, fundamentally breaking the multi-signature governance trust model.

While this does not directly result in fund loss, it enables **unauthorized proposal execution** that could lead to arbitrary state changes, configuration modifications, or other governance-controlled actions depending on what the released proposal does.

## Likelihood Explanation

This vulnerability has **MEDIUM-to-HIGH likelihood** of exploitation:

**Attacker Capabilities Required:**
- Control sufficient organization members to pass a `RemoveMember` proposal (achievable if the attacker faction already has near-majority support)
- Ability to coordinate timing between the member removal proposal and the target proposal release
- Only uses standard contract methods available to any organization member

**Attack Complexity:**
- **LOW**: Requires only two standard governance operations (target proposal + member removal proposal)
- No special permissions beyond normal member voting rights
- No strict timing constraints beyond standard proposal expiration periods
- The attack uses legitimate governance mechanisms, making it difficult to detect

**Feasibility Conditions:**
- Organizations must have configured `MaximalAbstentionThreshold` or `MaximalRejectionThreshold` (common for security-conscious setups)
- Target proposal must be blocked by exceeding these thresholds
- Attacker faction must have sufficient votes to pass a removal proposal (easier when the original proposal has narrow approval margins)

**Detection Difficulty:**
- Member removal is a legitimate operation with no inherent red flags
- No on-chain monitoring can distinguish malicious from legitimate removals
- The vulnerability is in internal logic, invisible to external observers

Organizations commonly use these thresholds for important decisions, and the attack requires only coordination among existing members with no external resources, making exploitation realistic.

## Recommendation

Fix the inconsistency by applying membership filtering to the total vote count, matching the filtering used for all other vote types. Modify the `CheckEnoughVoteAndApprovals` function:

**Current vulnerable code (lines 55-57):**
```csharp
var isVoteThresholdReached =
    proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
    organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**Fixed code:**
```csharp
var totalVoteCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
                     proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
                     proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
var isVoteThresholdReached = totalVoteCount >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

This ensures that only votes from current organization members are counted toward the `MinimalVoteThreshold`, maintaining consistency with the rejection, abstention, and approval counting logic.

**Additional Considerations:**
- Consider adding an event or warning when members are removed while active proposals exist
- Document that membership changes affect pending proposal evaluations
- Consider allowing organizations to optionally "snapshot" membership at proposal creation time to prevent retroactive manipulation

## Proof of Concept

**Test Scenario:**

1. Create an Association organization with 10 members
2. Configure thresholds:
   - `MinimalApprovalThreshold` = 5
   - `MinimalVoteThreshold` = 7  
   - `MaximalAbstentionThreshold` = 2
   - `MaximalRejectionThreshold` = 2

3. Create Proposal A and collect votes:
   - 5 members approve
   - 3 members abstain
   - 2 members don't vote
   - Total votes = 8 (meets `MinimalVoteThreshold`)

4. Verify Proposal A is currently blocked:
   - Call `GetProposal(proposalId)` 
   - Check `ToBeReleased` = false
   - Reason: abstentions (3) > `MaximalAbstentionThreshold` (2)

5. Create and pass Proposal B to remove the 3 abstaining members:
   - The 5 approving members vote yes on Proposal B
   - Call `Release(proposalBId)` successfully

6. Verify Proposal A can now be released:
   - Call `GetProposal(proposalAId)`
   - Check `ToBeReleased` = true (bug triggered!)
   - Abstention count now appears as 0 (filtered by current membership)
   - Total vote count still 8 (unfiltered, counting removed members)
   - Call `Release(proposalAId)` succeeds

7. Verify the proposal was executed despite exceeding the configured abstention threshold

This demonstrates the governance bypass where a proposal that should remain blocked can be released by manipulating membership after votes are cast.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-53)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-59)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
