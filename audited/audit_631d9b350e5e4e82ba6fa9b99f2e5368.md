# Audit Report

## Title
Evil Miners Can Propose Cross-Chain Indexing Data After Being Banned Due to Missing BannedPubkey Validation

## Summary
The cross-chain indexing authorization mechanism fails to validate whether miners have been marked as evil in the Election contract's `BannedPubkeyMap`. This creates a one-round timing window where detected evil miners can still propose and release cross-chain indexing data before being fully removed from the consensus round, potentially compromising cross-chain data integrity.

## Finding Description

The authorization for cross-chain indexing operations uses `CheckCrossChainIndexingPermission`, which delegates to `IsCurrentMiner` to verify miner status: [1](#0-0) 

The `IsCurrentMiner` function only checks if the pubkey exists in the current round's miner list: [2](#0-1) 

Critically, it never validates against the Election contract's `BannedPubkeyMap`, which tracks evil miners.

The vulnerability arises from the consensus round transition sequence in `ProcessNextRound`: [3](#0-2) 

The sequence is: (1) pre-generated nextRound is obtained from input, (2) evil miners are detected and marked in `BannedPubkeyMap`, (3) the pre-generated nextRound (which still contains evil miners) is added. This means miners detected at round N's end are marked as banned but remain in round N+1's miner list.

When generating the next round, `GetMinerReplacementInformation` is called to identify evil miners for replacement: [4](#0-3) 

However, this happens BEFORE evil miners are detected and marked. The Election contract's `GetEvilMinersPubkeys` function checks `BannedPubkeyMap`: [5](#0-4) 

When miners are marked as evil, they are added to `BannedPubkeyMap`: [6](#0-5) 

Both critical cross-chain indexing entry points use the insufficient authorization check: [7](#0-6) [8](#0-7) 

Evil miners are detected based on missed time slots: [9](#0-8) [10](#0-9) 

## Impact Explanation

**Cross-Chain Data Integrity Compromise**: Evil miners who have been detected and banned can still propose and release cross-chain indexing data for one complete consensus round. While cross-chain proposals require governance approval from the CrossChainIndexingController organization, a banned miner should not have the ability to propose at all once detected as malicious.

This allows potential submission of fraudulent cross-chain block data including:
- Invalid merkle tree roots
- Incorrect block heights  
- Malicious transaction status information

**Consensus System Trust Violation**: The system explicitly detects and bans malicious miners through the evil node detection mechanism, yet the authorization system continues to trust them for critical cross-chain operations. This undermines the security guarantees provided by the evil node detection system.

**Affected Parties**: All chains relying on cross-chain indexing integrity, including side chains trusting parent chain data and parent chains trusting side chain data indexed by evil miners during the vulnerability window.

## Likelihood Explanation

**Attack Practicality**: The attack is highly practical:
1. An attacker operates a miner node and intentionally accumulates missed time slots (4,320 slots over 3 days)
2. Upon detection and banning at round transition, they immediately call `ProposeCrossChainIndexing` during round N+1
3. No special privileges beyond being an existing miner are required

**Preconditions**: Attacker must be an active miner and accumulate sufficient missed time slots to trigger evil detection. The timing must be coordinated to act within the one-round window.

**Detection Difficulty**: The attack is difficult to detect in real-time because the miner appears legitimate to the `IsCurrentMiner` check, and cross-chain proposals follow the normal governance flow.

**Economic Feasibility**: The cost is reasonable - the attacker loses their miner position but gains the ability to submit potentially malicious cross-chain data before complete removal. For high-value cross-chain attacks, this trade-off may be economically rational.

## Recommendation

Add validation against `BannedPubkeyMap` in the `IsCurrentMiner` check:

```csharp
private bool IsCurrentMiner(string pubkey)
{
    if (pubkey == null) return false;
    
    if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;
    
    // Add check against BannedPubkeyMap
    if (State.ElectionContract.Value != null)
    {
        var isBanned = State.ElectionContract.IsPubkeyBanned.Call(new StringValue { Value = pubkey });
        if (isBanned.Value) return false;
    }
    
    if (!currentRound.IsMinerListJustChanged)
        if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return false;
    
    // ... rest of the existing logic
}
```

Alternatively, update `CheckCrossChainIndexingPermission` to explicitly check the ban status before returning.

## Proof of Concept

The vulnerability can be demonstrated through the following sequence:

1. **Setup**: Deploy a miner node that is part of the current consensus round
2. **Accumulate Missed Slots**: Intentionally miss time slots until `MissedTimeSlots >= 4320`  
3. **Wait for Round Transition**: Monitor for the round transition where evil miners are detected
4. **Exploit Window**: During round N+1 (after being marked in `BannedPubkeyMap` but before removal from `RealTimeMinersInformation`), call `ProposeCrossChainIndexing` with malicious cross-chain data
5. **Verification**: The transaction succeeds because `IsCurrentMiner` returns true despite the miner being in `BannedPubkeyMap`

The core issue is the disconnect between evil miner detection (which updates `BannedPubkeyMap`) and authorization checks (which only validate presence in `RealTimeMinersInformation`), creating a one-round window for exploitation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L136-144)
```csharp
    private bool IsCurrentMiner(string pubkey)
    {
        if (pubkey == null) return false;

        if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;

        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-305)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-291)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```
