### Title
Consensus Signature Forgery Allows Mining Order Manipulation in AEDPoS UpdateValue

### Summary
The AEDPoS consensus mechanism fails to cryptographically verify the `Signature` field submitted in `UpdateValueInput`, allowing authorized miners to submit forged signatures that determine their mining order in the next round. This signature is copied without verification through `GetUpdateValueRound()` and `RecoverFromUpdateValue()`, then used directly in `ApplyNormalConsensusData()` to calculate `SupposedOrderOfNextRound` via modulus operation, breaking the randomness-based fairness of the consensus mechanism.

### Finding Description

**Location of Vulnerability:**

The signature bypass occurs across multiple files in the UpdateValue consensus flow:

1. **Signature Copying Without Verification** [1](#0-0) 

2. **Recovery Without Verification** [2](#0-1) 

3. **Insufficient Validation (Only Null/Empty Check)** [3](#0-2) 

4. **Direct State Update Without Verification** [4](#0-3) 

**Root Cause:**

The signature should be calculated as `XOR(previousInValue, XOR(all signatures from previous round))` via: [5](#0-4) 

However, when a miner submits `UpdateValueInput`, there is **no validation** that the provided signature matches this expected calculation. The validation provider only checks that the signature is not null/empty, but never verifies its correctness against the deterministic calculation.

**Execution Path:**

During block validation: [6](#0-5) 

The validator calls `RecoverFromUpdateValue` which blindly copies the signature from the block header. The only validation is the null/empty check in `UpdateValueValidationProvider`, which does not verify the signature matches `CalculateSignature(previousInValue)`.

**Critical Usage of Forged Signature:**

The forged signature is then used to determine the miner's position in the next round: [7](#0-6) 

And to select the extra block producer: [8](#0-7) 

### Impact Explanation

**Consensus Integrity Violation:**

A malicious authorized miner can:
1. Calculate which signature value would give them position #1 in the next round: `signature = (desiredOrder - 1) + k * minersCount` where k is chosen to create a valid hash
2. Submit this forged signature instead of the correct `CalculateSignature(previousInValue)` result
3. The forged signature passes all validations and gets stored in the round state
4. The miner obtains their desired position in the next round, breaking the randomness-based ordering

**Affected Parties:**
- All honest miners suffer from unfair mining order distribution
- The blockchain's consensus randomness is compromised
- If the attacker mines in position #1, they can also manipulate the extra block producer selection via their forged signature

**Severity Justification:**

This is **HIGH severity** because:
- It breaks a critical invariant: "Correct round transitions and miner schedule integrity"
- Allows systematic manipulation of mining order across multiple rounds
- Undermines the fairness guarantees of the AEDPoS consensus mechanism
- Can be exploited by any authorized miner without detection

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an authorized miner (member of the miner list)
- This is a realistic threat model in consensus systems - protecting against malicious miners is the core purpose of consensus validation

**Attack Complexity:**
1. Calculate desired next-round position
2. Reverse-engineer required signature value: `targetSignature = Hash.FromInt64((desiredOrder - 1) + k * minersCount)` for some offset k
3. Submit `UpdateValue` transaction with forged signature
4. Forged signature is accepted and determines next round order

**Feasibility Conditions:**
- No special privileges required beyond being an authorized miner
- No economic cost (gas fees are negligible)
- Attack is undetectable since there's no verification to fail
- Can be repeated every round to maintain favorable position

**Detection Constraints:**
- No validation exists to detect the forgery
- Honest nodes cannot distinguish forged from legitimate signatures without implementing missing verification

**Probability:** HIGH - Any authorized miner can exploit this with trivial computational effort and guaranteed success.

### Recommendation

**Required Mitigation:**

Add signature verification to `UpdateValueValidationProvider`: 

```csharp
private bool ValidateSignature(ConsensusValidationContext validationContext)
{
    var providedSignature = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey].Signature;
    var previousInValue = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey].PreviousInValue;
    
    if (previousInValue == null || previousInValue == Hash.Empty)
        return true; // Skip validation for first round or missing previous in value
    
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
    return providedSignature == expectedSignature;
}
```

And add this check in `ValidateHeaderInformation`: [9](#0-8) 

**Invariant to Enforce:**
```
For all UpdateValue operations:
providedSignature == previousRound.CalculateSignature(providedPreviousInValue)
```

**Test Cases:**
1. Verify honest miner with correct signature succeeds
2. Verify miner with forged signature (wrong value) is rejected
3. Verify miner with null/empty signature is rejected
4. Verify edge case: first round or missing previous in value

### Proof of Concept

**Initial State:**
- Blockchain running with N authorized miners
- Current round R with all miners having valid signatures
- Attacker is authorized miner with pubkey `AttackerPubkey`

**Attack Steps:**

1. **Calculate Target Signature:**
   - Attacker wants position #1 in next round
   - Calculate: `forgedSig = Hash.FromInt64(0)` (since `(0 % N) + 1 = 1`)

2. **Submit Forged UpdateValue:**
   - Attacker produces their block in round R
   - Instead of using `previousRound.CalculateSignature(previousInValue)`, submit:
     ```
     UpdateValueInput {
       OutValue = HashHelper.ComputeFrom(inValue),
       Signature = forgedSig,  // FORGED VALUE
       PreviousInValue = previousInValue,
       // ... other fields
     }
     ```

3. **Validation Passes:**
   - `ValidateBeforeExecution` calls `RecoverFromUpdateValue` - copies forged signature without verification
   - `UpdateValueValidationProvider.NewConsensusInformationFilled` - checks signature is not null ✓
   - `UpdateValueValidationProvider.ValidatePreviousInValue` - checks hash(previousInValue) == previousOutValue ✓
   - No cryptographic signature verification exists

4. **State Updated with Forged Signature:**
   - `ProcessUpdateValue` executes
   - `minerInRound.Signature = updateValueInput.Signature` stores forged signature
   - Round state now contains forged signature

5. **Next Round Generation:**
   - `ApplyNormalConsensusData` called for attacker
   - `supposedOrderOfNextRound = GetAbsModulus(forgedSig.ToInt64(), minersCount) + 1 = GetAbsModulus(0, N) + 1 = 1`
   - Attacker gets position #1 in next round

**Expected Result:** Signature verification should fail, transaction rejected

**Actual Result:** Forged signature accepted, attacker obtains position #1, consensus randomness compromised

**Success Condition:** Attacker's `SupposedOrderOfNextRound == 1` in the next round, verifiable by querying round state

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L24-24)
```csharp
                    Signature = minerInRound.Signature,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L17-17)
```csharp
        minerInRound.Signature = providedInformation.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-244)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L118-122)
```csharp
        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
```
