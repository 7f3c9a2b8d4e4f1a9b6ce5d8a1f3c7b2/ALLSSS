### Title
Cross-Chain Token Registration Controller Susceptible to Governance Degradation Attack

### Summary
The `ChangeCrossChainTokenContractRegistrationController` function uses only `CheckOrganizationExist` validation, which verifies organization existence but not security properties, allowing unlimited controller delegation and degradation. This contrasts with `ChangeTransferBlackListController` which hardcodes Parliament-only control. An attacker can exploit this through gradual delegation to weaker organizations, eventually registering malicious cross-chain token contract addresses that enable token double-spending across chains.

### Finding Description

The vulnerability exists in the `ChangeCrossChainTokenContractRegistrationController` function [1](#0-0) , which uses `CheckCrossChainTokenContractRegistrationControllerAuthority()` [2](#0-1)  to verify the current controller can modify itself, followed by `CheckOrganizationExist(input)` [3](#0-2)  to validate the new organization exists.

**Root Cause**: The `CheckOrganizationExist` function only verifies that an organization address exists in the governance contract's state [4](#0-3) [5](#0-4) [6](#0-5) . It does NOT validate the organization's security properties (member count, approval thresholds, etc.) or prevent delegation to progressively weaker organizations.

**Why Protections Fail**: Unlike `ChangeTransferBlackListController` which hardcodes Parliament-only control [7](#0-6)  (verified by tests [8](#0-7) ), the cross-chain controller allows the current controller to change itself without Parliamentary approval, enabling unlimited governance degradation.

**Execution Path**: The registered token contract address stored in `State.CrossChainTransferWhiteList[fromChainId]` is used by `CrossChainReceiveToken` to validate cross-chain transfers [9](#0-8) . A malicious registered address bypasses the requirement that tokens must be burned on the source chain before minting on the destination chain.

### Impact Explanation

**Direct Fund Impact**: An attacker controlling the degraded controller can register a fake token contract address from a compromised chain via `RegisterCrossChainTokenContractAddress` [10](#0-9) . This fake contract can issue "burn" transactions without actually burning tokens, enabling double-spending where tokens remain on the source chain while also being minted on the destination chain [11](#0-10) .

**Cross-Chain Integrity**: The registered address serves as the trusted authority for validating cross-chain transfers. Compromising this undermines the entire cross-chain security model, allowing arbitrary token creation.

**Severity Justification**: HIGH - Enables unlimited token inflation through cross-chain double-spending. The impact scales with the total value of tokens eligible for cross-chain transfers. Unlike local token operations, cross-chain attacks are harder to detect and reverse due to multi-chain coordination requirements.

### Likelihood Explanation

**Attack Sequence**:
1. Parliament legitimately delegates cross-chain controller to AssociationA (e.g., 5-member DAO with 5/5 threshold) for operational efficiency
2. AssociationA votes to delegate to AssociationB (3 members, 2/3 threshold) - passes `CheckOrganizationExist`
3. AssociationB delegates to OrganizationC (1 member, 1/1 threshold) - passes `CheckOrganizationExist`
4. OrganizationC, fully controlled by attacker, registers malicious token contract address
5. Attacker executes cross-chain transfers using fake contract, minting tokens without burning

**Feasibility**: The attack does NOT require compromising Parliament directly. It only requires Parliament to make one legitimate operational decision (initial delegation), after which the security degrades through the delegated organizations. Each delegation step is valid according to current code logic.

**Attack Complexity**: MEDIUM - Requires social engineering or compromise of delegated organizations, but does not require breaking cryptographic assumptions or exploiting complex race conditions.

**Detection Constraints**: Controller changes are logged but gradual delegation may appear legitimate. Cross-chain double-spending may not be immediately detected if monitoring focuses on individual chains rather than cross-chain token conservation.

### Recommendation

**Code-Level Mitigation**: Add hardcoded Parliament-only control to `ChangeCrossChainTokenContractRegistrationController`, matching the pattern used for `ChangeTransferBlackListController`:

```csharp
public override Empty ChangeCrossChainTokenContractRegistrationController(AuthorityInfo input)
{
    AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);  // ADD THIS LINE
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    State.CrossChainTokenContractRegistrationController.Value = input;
    return new Empty();
}
```

**Invariant Checks**: Ensure that only the default Parliament organization can change the cross-chain token registration controller, regardless of what the current controller is set to. This prevents governance degradation even if the controller is delegated.

**Test Cases**: Add tests similar to [12](#0-11)  that verify:
1. Non-Parliament addresses cannot change the controller even after delegation
2. Only Parliament proposals can successfully change the controller
3. Attempting multi-step delegation fails at the second step

### Proof of Concept

**Initial State**:
- CrossChainTokenContractRegistrationController is set to default Parliament organization [13](#0-12) 
- Test environment with main chain and side chain configured [14](#0-13) 

**Attack Steps**:
1. Create AssociationA with 5 members via Association contract
2. Submit Parliament proposal to change controller to AssociationA - SUCCEEDS (legitimate delegation)
3. Via AssociationA, change controller to single-member AssociationB - SUCCEEDS (vulnerability)
4. Via AssociationB, register attacker-controlled token contract address from side chain - SUCCEEDS
5. Create fake cross-chain transfer transaction from malicious contract (no actual burn)
6. Call `CrossChainReceiveToken` with fake transaction - SUCCEEDS (tokens minted on destination)
7. Original tokens still exist on source chain - DOUBLE-SPENDING ACHIEVED

**Expected vs Actual**:
- Expected: Step 3 should FAIL with "No permission" (only Parliament can change controller)
- Actual: Step 3 SUCCEEDS because current controller can change itself

**Success Condition**: Attacker receives newly minted tokens on destination chain while retaining original tokens on source chain, violating cross-chain token conservation invariant.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L61-68)
```csharp
    public override Empty ChangeCrossChainTokenContractRegistrationController(AuthorityInfo input)
    {
        CheckCrossChainTokenContractRegistrationControllerAuthority();
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.CrossChainTokenContractRegistrationController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L90-97)
```csharp
    public override Empty ChangeTransferBlackListController(AuthorityInfo input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.TransferBlackListController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L252-264)
```csharp
    private AuthorityInfo GetCrossChainTokenContractRegistrationController()
    {
        var parliamentContractAddress =
            Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
        var controller = new AuthorityInfo
        {
            ContractAddress = State.ParliamentContract.Value,
            OwnerAddress = Context.Call<Address>(parliamentContractAddress,
                nameof(ParliamentContractContainer.ParliamentContractReferenceState.GetDefaultOrganizationAddress),
                new Empty())
        };
        return controller;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L313-320)
```csharp
    private void CheckCrossChainTokenContractRegistrationControllerAuthority()
    {
        if (State.CrossChainTokenContractRegistrationController.Value == null)
            State.CrossChainTokenContractRegistrationController.Value =
                GetCrossChainTokenContractRegistrationController();
        Assert(State.CrossChainTokenContractRegistrationController.Value.OwnerAddress == Context.Sender,
            "No permission.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L218-221)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenApplicationTests.cs (L2108-2143)
```csharp
        // Only Parliament can change TransferBlackListController
        var changeControllerResult = await TokenContractStubUser.ChangeTransferBlackListController.SendWithExceptionAsync(new AuthorityInfo
        {
            ContractAddress = AssociationContractAddress,
            OwnerAddress = organizationAddress
        });
        changeControllerResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        changeControllerResult.TransactionResult.Error.ShouldContain("Unauthorized behavior");
        
        // Test setting non-existent association organization address should fail
        var nonExistentOrgAddress = SampleAddress.AddressList[9]; // Use a non-existent organization address
        var setNonExistentControllerProposalId = await CreateProposalAsync(TokenContractAddress, defaultParliament, 
            nameof(TokenContractStub.ChangeTransferBlackListController), new AuthorityInfo
            {
                ContractAddress = AssociationContractAddress,
                OwnerAddress = nonExistentOrgAddress
            });
        await ApproveWithMinersAsync(setNonExistentControllerProposalId);
        var setNonExistentControllerResult = await ParliamentContractStub.Release.SendWithExceptionAsync(setNonExistentControllerProposalId);
        setNonExistentControllerResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        setNonExistentControllerResult.TransactionResult.Error.ShouldContain("Invalid authority input");
        
        // Parliament changes TransferBlackListController to Association organization
        var changeControllerProposalId = await CreateProposalAsync(TokenContractAddress, defaultParliament, 
            nameof(TokenContractStub.ChangeTransferBlackListController), new AuthorityInfo
            {
                ContractAddress = AssociationContractAddress,
                OwnerAddress = organizationAddress
            });
        await ApproveWithMinersAsync(changeControllerProposalId);
        await ParliamentContractStub.Release.SendAsync(changeControllerProposalId);
        
        // Verify TransferBlackListController has been changed
        var newController = await TokenContractStub.GetTransferBlackListController.CallAsync(new Empty());
        newController.ContractAddress.ShouldBe(AssociationContractAddress);
        newController.OwnerAddress.ShouldBe(organizationAddress);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L536-552)
```csharp
    public override Empty RegisterCrossChainTokenContractAddress(RegisterCrossChainTokenContractAddressInput input)
    {
        CheckCrossChainTokenContractRegistrationControllerAuthority();

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);
        AssertCrossChainTransaction(originalTransaction, Context.GetZeroSmartContractAddress(input.FromChainId),
            nameof(ACS0Container.ACS0ReferenceState.ValidateSystemContractAddress));

        var validAddress = ExtractTokenContractAddress(originalTransaction.Params);

        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);

        State.CrossChainTransferWhiteList[input.FromChainId] = validAddress;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L600-637)
```csharp
            CrossChainTransferInput.Parser.ParseFrom(transferTransaction.Params.ToByteArray());
        var symbol = crossChainTransferInput.Symbol;
        var amount = crossChainTransferInput.Amount;
        var receivingAddress = crossChainTransferInput.To;
        var targetChainId = crossChainTransferInput.ToChainId;
        var transferSender = transferTransaction.From;

        var tokenInfo = AssertValidToken(symbol, amount);
        var issueChainId = GetIssueChainId(tokenInfo.Symbol);
        Assert(issueChainId == crossChainTransferInput.IssueChainId, "Incorrect issue chain id.");
        Assert(targetChainId == Context.ChainId, "Unable to claim cross chain token.");
        var registeredTokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        AssertCrossChainTransaction(transferTransaction, registeredTokenContractAddress,
            nameof(CrossChainTransfer));
        Context.LogDebug(() =>
            $"symbol == {tokenInfo.Symbol}, amount == {amount}, receivingAddress == {receivingAddress}, targetChainId == {targetChainId}");

        CrossChainVerify(transferTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);

        State.VerifiedCrossChainTransferTransaction[transferTransactionId] = true;
        tokenInfo.Supply = tokenInfo.Supply.Add(amount);
        Assert(tokenInfo.Supply <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(receivingAddress, tokenInfo.Symbol, amount);

        Context.Fire(new CrossChainReceived
        {
            From = transferSender,
            To = receivingAddress,
            Symbol = tokenInfo.Symbol,
            Amount = amount,
            Memo = crossChainTransferInput.Memo,
            FromChainId = input.FromChainId,
            ParentChainHeight = input.ParentChainHeight,
            IssueChainId = issueChainId,
            TransferTransactionId = transferTransactionId
        });
        return new Empty();
```

**File:** test/AElf.Contracts.MultiTokenCrossChainTransfer.Tests/MultiTokenContractReferenceFeeTest.cs (L447-467)
```csharp
    [Fact]
    public async Task ChangeCrossChainTokenContractRegistrationController_Success_Test()
    {
        var defaultController =
            await TokenContractStub.GetCrossChainTokenContractRegistrationController.CallAsync(new Empty());
        var defaultParliamentAddress = await GetDefaultParliamentAddressAsync();
        defaultController.OwnerAddress.ShouldBe(defaultParliamentAddress);

        var newAuthority = await CreateNewParliamentAddressAsync();
        var proposalId = await CreateProposalAsync(ParliamentContractStub,
            nameof(TokenContractImplContainer.TokenContractImplStub
                .ChangeCrossChainTokenContractRegistrationController), newAuthority.ToByteString(),
            TokenContractAddress);

        await ApproveWithMinersAsync(proposalId);
        var txResult = await ReleaseProposalAsync(proposalId);
        txResult.Status.ShouldBe(TransactionResultStatus.Mined);
        var newController =
            await TokenContractStub.GetCrossChainTokenContractRegistrationController.CallAsync(new Empty());
        Assert.True(newController.OwnerAddress == newAuthority.OwnerAddress);
    }
```
