### Title
Mid-Voting Member Addition Enables Retroactive Vote Manipulation

### Summary
The `AddMember()` function allows organizations to add new members while proposals are actively being voted on. These newly added members can immediately cast votes on pre-existing proposals, and their votes are counted using the current organization member list rather than a membership snapshot at proposal creation time. This enables attackers who control an organization to manipulate vote outcomes retroactively by adding members mid-voting who then vote to block legitimate proposals or approve malicious ones.

### Finding Description

The vulnerability exists in the interaction between member management and vote counting mechanisms:

**Member Addition**: The `AddMember()` function simply adds new members to the live organization without any checks for active proposals. [1](#0-0) 

**Vote Authorization**: When a member attempts to vote (approve/reject/abstain), the system only checks if they are in the CURRENT organization member list, not whether they were members when the proposal was created. [2](#0-1) [3](#0-2) 

**Vote Counting at Release**: When determining if a proposal can be released, the system filters votes by CURRENT membership, not membership at proposal creation time. [4](#0-3) 

**No Membership Snapshot**: The `ProposalInfo` structure stores lists of voters but does not capture a snapshot of organization members at proposal creation time. [5](#0-4) 

**Root Cause**: The system counts votes using `proposal.Approvals.Count(organization.OrganizationMemberList.Contains)` which filters by the current member list. When members are added mid-voting, they become part of this current list and can vote on proposals created before they joined. Their votes are then counted toward the threshold calculations.

### Impact Explanation

**Direct Governance Impact**:
- **Proposal Blocking**: A legitimate proposal with sufficient approvals and ready for release can be retroactively blocked by adding new members who vote to reject it, pushing rejections above `MaximalRejectionThreshold`.
- **Malicious Approval**: A failing malicious proposal can be saved by adding new attacker-controlled members who vote to approve it, pushing approvals above `MinimalApprovalThreshold`.
- **Voting Integrity Violation**: Members who voted did so based on one electorate composition, but the outcome is determined by a different composition.

**Concrete Attack Scenario**:
1. Organization has 5 members {A,B,C,D,E} with thresholds: MinimalApproval=3, MaximalRejection=2
2. Proposal P1 has 3 approvals (A,B,C), 0 rejections - ready to pass
3. Attacker controls members to pass Proposal P2 adding members {F,G,H}
4. New members F,G,H vote to reject P1
5. P1 now has 3 rejections > MaximalRejectionThreshold (2), cannot be released
6. A previously passing proposal is now blocked

**Severity**: HIGH - Violates fundamental governance invariant that vote outcomes should be determined by the electorate at proposal creation time, not retroactively changed by electorate modifications.

### Likelihood Explanation

**Attacker Capabilities Required**:
- Control of sufficient organization members to pass a proposal for adding new members (requires existing majority or significant voting power)
- Ability to coordinate voting across controlled addresses

**Attack Complexity**: LOW
- No technical sophistication required
- Straightforward sequence: create add-member proposal → approve it → new members vote on target proposal
- No timing constraints beyond proposal expiration

**Feasibility Conditions**:
- Organization must have active proposals that attacker wants to manipulate
- Attacker must have enough control to pass an add-member proposal
- Target proposal must not have expired

**Detection/Operational Constraints**:
- Member additions are visible on-chain via `MemberAdded` events, but by the time they're detected, new members can already vote
- No automated protection mechanisms exist
- Manual monitoring would not prevent the attack, only detect it after execution

**Economic Rationality**: 
- If attacker already controls majority, cost is just transaction fees
- Potential benefit (blocking/forcing proposals) could be substantial depending on proposal value

**Likelihood Assessment**: MEDIUM-HIGH - Attack is practical once attacker has governance control, which is the prerequisite for many governance attacks. The lack of any protective mechanisms makes exploitation straightforward.

### Recommendation

**Primary Fix - Implement Membership Snapshot**:
1. Modify `ProposalInfo` structure to include `organization_members_snapshot`:
```protobuf
message ProposalInfo {
    ...
    repeated aelf.Address organization_members_snapshot = 14;
}
```

2. Capture membership snapshot in `CreateNewProposal()`: [6](#0-5) 
Store `organization.OrganizationMemberList.OrganizationMembers` in the proposal.

3. Modify vote authorization to check against snapshot: [2](#0-1) 
Change to verify `proposal.organization_members_snapshot.Contains(member)`.

4. Modify vote counting to use snapshot: [4](#0-3) 
Change all filters from `organization.OrganizationMemberList.Contains` to check against the proposal's member snapshot.

**Alternative Fix - Block Member Changes During Active Proposals**:
Add validation in `AddMember()`, `RemoveMember()`, and `ChangeMember()` to ensure no active proposals exist before allowing member modifications. However, this is more restrictive and could impact governance flexibility.

**Test Cases to Add**:
1. Test that members added after proposal creation cannot vote on that proposal
2. Test that vote counts are based on membership at proposal creation, not release
3. Test that removing members after they vote doesn't invalidate their votes (if using snapshot approach)

### Proof of Concept

**Initial Setup**:
- Organization created with 5 members: Alice, Bob, Carol, Dave, Eve
- Thresholds: `MinimalApprovalThreshold=3`, `MaximalRejectionThreshold=2`, `MinimalVoteThreshold=3`
- ProposerWhiteList includes Alice

**Step 1 - Create Legitimate Proposal**:
- Alice creates Proposal P1: "Transfer 1000 ELF from organization treasury to development fund"
- Alice approves P1
- Bob approves P1  
- Carol approves P1
- Dave abstains from P1
- Current status: 3 approvals, 0 rejections, 1 abstention (4 total votes)
- Threshold check: 3 ≥ MinimalApprovalThreshold(3) ✓, 0 ≤ MaximalRejectionThreshold(2) ✓, 4 ≥ MinimalVoteThreshold(3) ✓
- **Expected**: P1 should be releasable

**Step 2 - Attack via Member Addition**:
- Alice creates Proposal P2: "Add members Frank, Grace, Henry"
- Alice, Bob, Carol approve P2 (3 approvals, passes thresholds)
- Alice releases P2
- P2 executes, adding Frank, Grace, Henry to organization
- Organization now has 8 members

**Step 3 - New Members Block Original Proposal**:
- Frank calls `Approve` on P1 → Authorization check passes (Frank is in current member list) → Vote recorded
- Grace calls `Reject` on P1 → Authorization check passes → Vote recorded
- Henry calls `Reject` on P1 → Authorization check passes → Vote recorded

**Step 4 - Attempt to Release P1**:
- Alice attempts to release P1
- System calculates: 
  - `approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains)` = 4 (Alice, Bob, Carol, Frank all in current list)
  - `rejectionMemberCount = proposal.Rejections.Count(organization.OrganizationMemberList.Contains)` = 2 (Grace, Henry in current list)
- Wait, let me recalculate: If Frank approved and Grace/Henry rejected:
  - Approvals: Alice, Bob, Carol, Frank = 4
  - Rejections: Grace, Henry = 2
  - This still passes: 4≥3 ✓, 2≤2 ✓

Let me correct the PoC:

**Step 3 - New Members Block Original Proposal** (Corrected):
- Frank calls `Reject` on P1 → Vote recorded
- Grace calls `Reject` on P1 → Vote recorded  
- Henry calls `Reject` on P1 → Vote recorded

**Step 4 - Attempt to Release P1** (Corrected):
- Alice attempts to release P1
- System calculates:
  - `approvedMemberCount` = 3 (Alice, Bob, Carol)
  - `rejectionMemberCount` = 3 (Frank, Grace, Henry)
- Threshold check: 3 ≥ MinimalApprovalThreshold(3) ✓, BUT 3 > MaximalRejectionThreshold(2) ✗
- **Actual Result**: P1 is rejected and cannot be released
- **Expected Result**: P1 should have been releasable based on votes from original members

**Success Condition**: The attack succeeds when a proposal that was ready for release (meeting all thresholds based on original member votes) becomes unreleasable after new members are added and vote to block it.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-59)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }

    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L145-173)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId,
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** protobuf/association_contract.proto (L76-103)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```
