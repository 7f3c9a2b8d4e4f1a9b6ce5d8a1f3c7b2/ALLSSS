### Title
Missing IsWithdrawn Check Allows Double Withdrawal and Vote Count Manipulation in Delegated Voting

### Summary
The `Withdraw()` function in VoteContract lacks validation to prevent withdrawing an already-withdrawn vote. While SafeMath.Sub() will eventually revert on underflow (using checked arithmetic), multiple successful withdrawals corrupt vote accounting in delegated voting scenarios (IsLockToken = false) before the underflow occurs. This critically affects the Election contract's miner selection process.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:** The `Withdraw()` function processes withdrawal operations without checking if `votingRecord.IsWithdrawn` is already true. While the function sets this flag at line 203, it never validates it beforehand. [2](#0-1) 

**Why Protections Fail:**

1. **Permission checks insufficient:** Lines 197-200 only validate that the caller is authorized (voter for locked tokens, sponsor for delegated), but don't check withdrawal state. [3](#0-2) 

2. **Two distinct vulnerability paths:**

   **Path A - IsLockToken = true (Regular Voting):** Second withdrawal attempts fail at token unlock operation (lines 224-231) because tokens were already unlocked. The entire transaction reverts, including prior state changes. No accounting damage occurs. [4](#0-3) 

   **Path B - IsLockToken = false (Delegated Voting):** The critical vulnerability exists here. Lines 224-231 are skipped entirely, so withdrawal completes successfully. Each call:
   - Removes from ActiveVotes list (no-op after first removal)
   - Adds to WithdrawnVotes (creates duplicates)
   - Decrements `Results[option]` at line 215-216
   - Decrements `VotesAmount` at line 220 [5](#0-4) 

3. **SafeMath behavior:** The `.Sub()` method uses checked arithmetic and throws OverflowException on underflow (reverts, doesn't wrap): [6](#0-5) 

4. **Election Contract uses delegated voting:** The Election contract registers its voting item with `IsLockToken = false`, making it vulnerable: [7](#0-6) 

5. **Election.Withdraw lacks protection:** The Election contract's Withdraw method also doesn't check IsWithdrawn before calling VoteContract.Withdraw and decrementing its own vote counters: [8](#0-7) 

### Impact Explanation

**Direct Governance Impact:**
- In delegated voting (Election contract), a voter can call `Withdraw()` multiple times with the same vote ID
- Each successful call decrements vote counts in both VoteContract and ElectionContract
- Corrupts critical metrics: `VotesAmount`, `Results[option]`, `ActiveVotedVotesAmount`, `ObtainedActiveVotedVotesAmount`
- Continues until `VotesAmount < votingRecord.Amount`, then reverts with overflow
- By that point, vote accounting is already significantly corrupted

**Affected Systems:**
- **Election Contract:** Miner election vote tallies become incorrect, potentially affecting consensus miner selection
- **Voting Results:** `VotingResult.VotesAmount` and `VotingResult.Results` no longer reflect actual active votes
- **Governance Decisions:** Any governance mechanism relying on delegated voting could have manipulated vote counts

**Severity Justification:** HIGH
- Breaks critical invariant: VotesAmount must equal sum of active votes
- Directly manipulates Election contract's miner selection votes
- Affects consensus integrity through corrupted election results
- Simple to execute (just call withdraw multiple times)
- No cost beyond transaction fees

### Likelihood Explanation

**Attacker Capabilities:** 
- For VoteContract: Any sponsor of a delegated voting item can exploit this
- For Election: Any voter who has cast votes and waited past lock time

**Attack Complexity:** LOW
- No special setup required beyond normal voting participation
- Simply call `Withdraw(voteId)` multiple times with same vote ID
- No need to bypass cryptographic checks or exploit race conditions

**Feasibility Conditions:**
- Delegated voting item must exist (IsLockToken = false)
- For Election: Very feasible as it's the main miner election mechanism
- Attacker must be authorized withdrawer (voter for regular, sponsor for delegated)

**Detection Constraints:**
- Vote counts gradually become inconsistent
- May not be immediately obvious until significant divergence
- Event logs show multiple Withdrawn events for same vote ID

**Probability:** HIGH for delegated voting scenarios, NONE for regular locked token voting (protected by unlock failure)

### Recommendation

**Code-Level Mitigation:**

Add an assertion at the beginning of the `Withdraw()` function to check withdrawal status:

```csharp
public override Empty Withdraw(WithdrawInput input)
{
    var votingRecord = State.VotingRecords[input.VoteId];
    if (votingRecord == null) throw new AssertionException("Voting record not found.");
    
    // ADD THIS CHECK:
    Assert(!votingRecord.IsWithdrawn, "Vote has already been withdrawn.");
    
    var votingItem = State.VotingItems[votingRecord.VotingItemId];
    // ... rest of function
}
```

**Invariant Checks:**
- Verify `VotesAmount` equals sum of all active (non-withdrawn) vote amounts
- Validate `Results[option]` totals match VotesAmount
- Assert vote ID exists in ActiveVotes before allowing withdrawal

**Test Cases:**
1. Test double withdrawal of same vote in delegated voting (should fail with "already withdrawn" error)
2. Test that VotesAmount remains consistent after withdrawal
3. Test Election.Withdraw called twice with same vote ID (should fail on second call)
4. Verify WithdrawnVotes list doesn't contain duplicates

### Proof of Concept

**Required Initial State:**
- Delegated voting item created with IsLockToken = false (e.g., Election contract)
- Sponsor has cast vote(s) on behalf of voter(s)
- Initial VotesAmount = V, votingRecord.Amount = A (where V >= A)

**Attack Transaction Steps:**

1. **First Withdrawal (Legitimate):**
   - Call `VoteContract.Withdraw(voteId)`
   - Result: IsWithdrawn = true, VotesAmount = V - A
   - Transaction succeeds

2. **Second Withdrawal (Exploit):**
   - Call `VoteContract.Withdraw(voteId)` again with SAME voteId
   - Line 203: IsWithdrawn already true, but no check prevents continuation
   - Line 220: VotesAmount = (V - A) - A = V - 2A
   - Transaction succeeds (no unlock step to fail)

3. **Third Withdrawal (Continued Exploitation):**
   - Call `VoteContract.Withdraw(voteId)` again
   - VotesAmount = V - 3A
   - Continues until V - nA < A

4. **Nth Withdrawal (Eventually Fails):**
   - When VotesAmount < votingRecord.Amount
   - SafeMath.Sub() throws OverflowException
   - Transaction reverts, BUT previous withdrawals already corrupted state

**Expected vs Actual Result:**
- **Expected:** Second call to Withdraw() should fail with "Vote already withdrawn"
- **Actual:** Second and subsequent calls succeed, each decrementing VotesAmount until eventual underflow revert
- **Success Condition:** VotesAmount incorrectly shows V - nA instead of V - A after n withdrawals of the same vote

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L191-239)
```csharp
    public override Empty Withdraw(WithdrawInput input)
    {
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;

        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;

        if (votingItem.IsLockToken)
            State.TokenContract.Unlock.Send(new UnlockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                Amount = votingRecord.Amount,
                LockId = input.VoteId
            });

        Context.Fire(new Withdrawn
        {
            VoteId = input.VoteId
        });

        return new Empty();
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L60-62)
```csharp
        var votingRegisterInput = new VotingRegisterInput
        {
            IsLockToken = false,
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L631-664)
```csharp
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input);

        var actualLockedTime = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockDays = State.LockTimeMap[input];
        Assert(actualLockedTime >= claimedLockDays,
            $"Still need {claimedLockDays.Sub(actualLockedTime).Div(86400)} days to unlock your token.");

        var voterPublicKey = Context.RecoverPublicKey();

        var voterVotes = GetElectorVote(voterPublicKey);

        Assert(voterVotes != null, $"Voter {Context.Sender.ToBase58()} never votes before");

        voterVotes.ActiveVotingRecordIds.Remove(input);
        voterVotes.WithdrawnVotingRecordIds.Add(input);
        voterVotes.ActiveVotedVotesAmount = voterVotes.ActiveVotedVotesAmount.Sub(votingRecord.Amount);

        State.ElectorVotes[Context.Sender.ToBase58()] = voterVotes;

        // Update Candidate's Votes information.
        var newestPubkey = GetNewestPubkey(votingRecord.Option);
        var candidateVotes = State.CandidateVotes[newestPubkey];

        Assert(candidateVotes != null, $"Newest pubkey {newestPubkey} is invalid. Old pubkey is {votingRecord.Option}");

        candidateVotes.ObtainedActiveVotingRecordIds.Remove(input);
        candidateVotes.ObtainedWithdrawnVotingRecordIds.Add(input);
        candidateVotes.ObtainedActiveVotedVotesAmount =
            candidateVotes.ObtainedActiveVotedVotesAmount.Sub(votingRecord.Amount);
        State.CandidateVotes[newestPubkey] = candidateVotes;

        UnlockTokensOfVoter(input, votingRecord.Amount);
        RetrieveTokensFromVoter(votingRecord.Amount);
        WithdrawTokensOfVoter(input);
```
