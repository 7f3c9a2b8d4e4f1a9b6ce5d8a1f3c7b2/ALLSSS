### Title
Welcome Reward Capture Through Coordinated Evil Miner Replacement

### Summary
The Treasury contract's welcome reward mechanism distributes rewards equally (1 share each) to all new miners without distinguishing between genuinely elected new miners and evil miner replacements. [1](#0-0)  A coordinated cartel can exploit this by deliberately forcing miner turnover through strategic evil miner behavior, allowing cartel-controlled replacements to capture welcome rewards intended for legitimate new participants or to dilute rewards away from genuine new miners.

### Finding Description
The vulnerability exists in the interaction between three mechanisms:

1. **New Miner Identification**: Miners are considered "new" solely based on `LatestMinedTerm[pubkey] == 0` without validating the reason they're new. [2](#0-1) 

2. **Evil Miner Replacement**: When miners miss `TolerableMissedTimeSlotsCount` (4,320 time slots ≈ 3 days), [3](#0-2)  they are automatically replaced mid-term with alternative candidates from the election snapshot. [4](#0-3) 

3. **Welcome Reward Distribution**: All new miners receive exactly 1 share regardless of how they became "new." [5](#0-4)  When multiple new miners exist, the welcome reward pool is split equally among them.

The replacement candidates are selected from the election snapshot based purely on vote count, without checking whether they've previously mined. [6](#0-5)  If a replacement has `LatestMinedTerm[replacement] == 0`, they qualify for welcome rewards at term end. [7](#0-6) 

The root cause is the lack of distinction between "new by election" versus "new by replacement" when distributing welcome rewards, combined with no rate limiting on evil replacements per term.

### Impact Explanation
**Quantified Impact**: Using default reward weights (BasicMinerReward=2, WelcomeReward=1, FlexibleReward=1), [8](#0-7)  a coordinated attack provides significant economic benefit:

- **Without Attack** (1 legitimate new miner, 16 existing miners):
  - Existing miners collectively receive: 1.88 weight units
  - New miner receives: 1.12 weight units

- **With Attack** (1 legitimate + 10 forced cartel replacements):
  - Cartel (6 old + 10 replacement miners) receives: 2.84 weight units
  - Legitimate new miner receives: 0.165 weight units (85% reduction)
  - **Cartel gain: +0.96 weight units (~51% increase)**

**Affected Parties**:
- Legitimate new miners have their welcome rewards diluted from 100% to 1/(K+1) where K is the number of cartel replacements
- The protocol's mechanism for attracting new participants is undermined
- Voters indirectly benefit as Flexible Reward redirects to them when new miners exist [9](#0-8) 

**Severity Justification**: Medium - While the economic gain is substantial (~50% increase), the attack requires significant resources and only provides benefit when legitimate new miners are joining.

### Likelihood Explanation
**Attacker Capabilities Required**:
1. Control over multiple candidate pubkeys with sufficient votes to be selected as alternative miners
2. Ability to coordinate K miners to deliberately miss blocks for 3 days
3. Pool of K candidates who have never mined before (`LatestMinedTerm[p] == 0`)
4. Willingness to have K pubkeys permanently banned from mining

**Attack Complexity**: 
- **Medium-High**: Requires coordinating multiple entities and controlling voting power, but the technical execution is straightforward (simply miss blocks)
- Evil miners are detected automatically through the consensus mechanism with no special permissions needed
- The alternative selection is deterministic based on election snapshot votes

**Feasibility Conditions**:
- A cartel controlling significant voting power (to ensure alternatives are cartel-controlled)
- Access to fresh candidate pubkeys (never mined before) - can be achieved by cycling through new pubkeys
- Economic rationality depends on welcome reward value exceeding the cost of acquiring/maintaining candidates
- Most effective when legitimate new miners are joining (otherwise welcome rewards redirect to Basic Reward anyway)

**Detection Constraints**:
- Missing blocks for 3 days is highly visible and creates evidence
- Pattern of coordinated evil behavior followed by replacements would be suspicious
- However, no automatic circuit breakers exist to prevent this

**Probability**: Medium - Requires substantial resources but is technically achievable for a well-funded cartel, especially during periods when new miners are naturally joining the network.

### Recommendation
**Immediate Mitigations**:

1. **Separate Welcome Reward Schemes**: Create distinct reward pools for genuinely elected new miners versus evil miner replacements.
   ```
   - Add a new profit scheme: "ReplacementReward" with reduced weight
   - In UpdateWelcomeRewardWeights, check if miners are from ReplaceCandidateMap
   - Route replacements to ReplacementReward, genuine new miners to WelcomeReward
   ```

2. **Rate Limit Evil Replacements**: Add a maximum number of evil replacements allowed per term.
   ```csharp
   // In TreasuryContract.cs, Release method after line 152:
   const int MaxReplacementsPerTerm = 3;
   if (replaceCandidates != null && replaceCandidates.Value.Count > MaxReplacementsPerTerm)
   {
       // Only consider first MaxReplacementsPerTerm as "new"
       // or reject the term transition entirely
   }
   ```

3. **Track Replacement Source**: Modify the new miner identification to consider replacement context.
   ```csharp
   // Add to UpdateWelcomeRewardWeights:
   var genuineNewMiners = newElectedMiners
       .Where(m => !State.WasEvilReplacement[m]).ToList();
   // Give full welcome rewards only to genuineNewMiners
   ```

4. **Increase Evil Penalty**: Instead of giving replacements normal Basic Reward shares, reduce their shares for the first N terms to offset the welcome reward benefit.

**Invariant Checks**:
- Assert that new miners per term ≤ reasonable threshold (e.g., 20% of total miners)
- Monitor and alert on patterns of coordinated evil behavior
- Track historical "new miner" rate to detect anomalies

**Test Cases**:
- Test with K evil miners (K > 10) all replaced in same term
- Verify welcome reward distribution with mixed genuine/replacement new miners
- Test that rate limiting prevents excessive dilution
- Verify economic game theory: forced replacement should not be profitable

### Proof of Concept

**Initial State**:
- 17 active miners (16 cartel-controlled, 1 independent)
- 1 legitimate new candidate with sufficient votes about to be elected next term
- 10 cartel candidates with sufficient votes, never mined before (`LatestMinedTerm[p] == 0`)
- Welcome reward weight = 1, Basic = 2, Flexible = 1

**Attack Steps**:
1. **Term N**: All 17 miners operate normally
2. **Term N to N+1 transition**: Legitimate new miner gets elected, becomes 18th miner
3. **During Term N+1 (mid-term)**: 10 cartel miners deliberately miss 4,320 consecutive time slots (~3 days)
4. **Automatic replacement**: Consensus contract calls `GetMinerReplacementInformation`, [10](#0-9)  selects 10 cartel-controlled alternatives (highest votes among non-miners)
5. **Term N+1 end**: Treasury `Release` is called [11](#0-10) 
   - `maybeNewElectedMiners` includes the legitimate new miner + 10 cartel replacements (all have `LatestMinedTerm[p] == 0`)
   - `UpdateWelcomeRewardWeights` distributes welcome rewards: 11 new miners, each gets 1 share [1](#0-0) 

**Expected vs Actual**:
- **Expected**: Legitimate new miner receives full welcome reward (1.0 weight unit)
- **Actual**: Each new miner receives 1/11 = 0.091 weight units; cartel's 10 replacements collectively capture 10/11 = 0.91 of welcome reward

**Success Condition**: Cartel's total rewards increase from 1.88 to 2.84 weight units (51% increase) while legitimate new miner's welcome reward is reduced by 91%.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L123-166)
```csharp
    public override Empty Release(ReleaseInput input)
    {
        RequireAEDPoSContractStateSet();
        Assert(
            Context.Sender == State.AEDPoSContract.Value,
            "Only AElf Consensus Contract can release profits from Treasury.");
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.TreasuryHash.Value,
            Period = input.PeriodNumber,
            AmountsMap = { State.SymbolList.Value.Value.ToDictionary(s => s, s => 0L) }
        });
        RequireElectionContractStateSet();
        var previousTermInformation = State.AEDPoSContract.GetPreviousTermInformation.Call(new Int64Value
        {
            Value = input.PeriodNumber
        });

        var currentMinerList = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(p => p.ToHex()).ToList();
        var maybeNewElectedMiners = new List<string>();
        maybeNewElectedMiners.AddRange(currentMinerList);
        maybeNewElectedMiners.AddRange(previousTermInformation.RealTimeMinersInformation.Keys);
        var replaceCandidates = State.ReplaceCandidateMap[input.PeriodNumber];
        if (replaceCandidates != null)
        {
            Context.LogDebug(() =>
                $"New miners from replace candidate map: {replaceCandidates.Value.Aggregate((l, r) => $"{l}\n{r}")}");
            maybeNewElectedMiners.AddRange(replaceCandidates.Value);
            State.ReplaceCandidateMap.Remove(input.PeriodNumber);
        }

        maybeNewElectedMiners = maybeNewElectedMiners
            .Where(p => State.LatestMinedTerm[p] == 0 && !GetInitialMinerList().Contains(p)).ToList();
        if (maybeNewElectedMiners.Any())
            Context.LogDebug(() => $"New elected miners: {maybeNewElectedMiners.Aggregate((l, r) => $"{l}\n{r}")}");
        else
            Context.LogDebug(() => "No new elected miner.");

        UpdateStateBeforeDistribution(previousTermInformation, maybeNewElectedMiners);
        ReleaseTreasurySubProfitItems(input.PeriodNumber);
        UpdateStateAfterDistribution(previousTermInformation, currentMinerList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L480-488)
```csharp
    private MinerRewardWeightSetting GetDefaultMinerRewardWeightSetting()
    {
        return new MinerRewardWeightSetting
        {
            BasicMinerRewardWeight = 2,
            WelcomeRewardWeight = 1,
            FlexibleRewardWeight = 1
        };
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L864-880)
```csharp
        if (newElectedMiners.Any())
        {
            Context.LogDebug(() => "Welcome reward will go to new miners.");
            var newBeneficiaries = new AddBeneficiariesInput
            {
                SchemeId = State.VotesWeightRewardHash.Value,
                EndPeriod = previousTermInformation.TermNumber.Add(1)
            };
            foreach (var minerAddress in newElectedMiners.Select(GetProfitsReceiver))
                newBeneficiaries.BeneficiaryShares.Add(new BeneficiaryShare
                {
                    Beneficiary = minerAddress,
                    Shares = 1
                });

            if (newBeneficiaries.BeneficiaryShares.Any()) State.ProfitContract.AddBeneficiaries.Send(newBeneficiaries);
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L916-935)
```csharp
        if (State.HasNewMiner[previousTermInformation.TermNumber])
        {
            Context.LogDebug(() => "Flexible reward will go to Welfare Reward.");
            State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
            {
                SchemeId = State.ReElectionRewardHash.Value,
                SubSchemeId = State.WelfareHash.Value,
                SubSchemeShares = 1
            });
        }
        else
        {
            Context.LogDebug(() => "Flexible reward will go to Basic Reward.");
            State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
            {
                SchemeId = State.ReElectionRewardHash.Value,
                SubSchemeId = State.BasicRewardHash.Value,
                SubSchemeShares = 1
            });
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-342)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-399)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
        var alternativeCandidates = new List<string>();
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }

        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
    }
```
