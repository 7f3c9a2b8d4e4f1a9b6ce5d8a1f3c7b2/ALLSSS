### Title
Missing Cross-Round Order Validation Allows Mining Order Manipulation During Round Transitions

### Summary
The AEDPoS consensus mechanism fails to validate that mining orders in a proposed next round match the `FinalOrderOfNextRound` values determined in the current round. The `NextRoundMiningOrderValidationProvider` checks incorrect fields in the next round data structure, allowing a malicious extra block producer to arbitrarily manipulate mining orders for the upcoming round and gain unfair advantages in block production.

### Finding Description

**Root Cause:**

The validation logic in `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` validates the wrong data structure. It checks `FinalOrderOfNextRound` and `OutValue` fields within the `providedRound` (which represents the next round being proposed), but these fields are never populated during legitimate next round generation. [1](#0-0) 

When a miner triggers a round transition, `GetConsensusExtraDataForNextRound` generates the next round by calling `GenerateNextRoundInformation`, which creates `MinerInRound` objects with only basic fields (`Pubkey`, `Order`, `ExpectedMiningTime`, `ProducedBlocks`, `MissedTimeSlots`) but explicitly does NOT set `FinalOrderOfNextRound` or `OutValue`: [2](#0-1) 

The `Order` field in the next round is supposed to be derived from each miner's `FinalOrderOfNextRound` value in the current round: [3](#0-2) 

However, **no validation exists** to verify that the `Order` values in the provided next round actually match the `FinalOrderOfNextRound` values from the current round stored in state.

**Execution Path:**

1. Extra block producer calls `NextRound` method, providing a `NextRoundInput` containing the proposed next round [4](#0-3) 

2. Before execution, `ValidateBeforeExecution` runs validation providers including `NextRoundMiningOrderValidationProvider`, which checks the provided next round but validates fields that are always 0/null, making the check trivially pass (0 == 0) [5](#0-4) 

3. `ProcessNextRound` directly stores the provided round without regenerating or validating the orders: [6](#0-5) 

4. After execution, `ValidateConsensusAfterExecution` compares the header round with the stored round, but since both are the same manipulated round, the hash comparison passes: [7](#0-6) 

The hash comparison includes the `Order` field as part of `RealTimeMinersInformation`: [8](#0-7) 

### Impact Explanation

**Consensus Integrity Violation:**

A malicious extra block producer can manipulate the mining order for the next round, allowing them to:

1. **Assign themselves priority positions** (e.g., Order 1) to mine first and collect transaction fees
2. **Disadvantage competing miners** by assigning them late orders or positions that conflict with network conditions
3. **Disrupt fair rotation** of the extra block producer role by manipulating who mines in favorable positions
4. **Gain disproportionate rewards** through repeated favorable positioning across multiple rounds

**Affected Parties:**

- **All network miners**: Face unfair competition and reduced mining opportunities
- **Token holders**: Experience degraded consensus fairness and potential centralization
- **Network security**: Undermined by violation of deterministic order assignment based on cryptographic signatures

**Severity Justification:**

This violates the critical invariant of "miner schedule integrity" and "correct round transitions." While it doesn't directly steal funds, it fundamentally breaks the fairness guarantees of the AEDPoS consensus mechanism, which could lead to centralization and loss of trust in the network.

### Likelihood Explanation

**Attacker Capabilities:**

- Attacker must be selected as the extra block producer for a round (rotates among all miners based on deterministic calculation)
- No additional privileges or trusted role compromise required beyond normal mining participation
- Attack requires modifying the client software to generate manipulated `NextRoundInput` data

**Attack Complexity:**

The attack is straightforward:
1. Wait until selected as extra block producer
2. Generate legitimate next round using standard `GenerateNextRoundInformation` logic
3. Modify the `Order` values in the generated round structure before submission
4. Submit the modified `NextRoundInput` via the `NextRound` RPC method

**Feasibility Conditions:**

- Attacker has ~1/N chance per round of being the extra block producer (where N is the miner count)
- Over many rounds, every miner gets opportunities to exploit this
- No detection mechanisms exist since the manipulated round passes all validations and is stored as legitimate state

**Economic Rationality:**

The cost is minimal (normal mining operations), while benefits include increased mining rewards and competitive advantages. The attack is economically rational for any miner seeking to maximize profits.

### Recommendation

**Immediate Fix:**

Add validation in `ProcessNextRound` or a new validation provider that verifies the consistency of mining orders across round transitions:

```csharp
// In ProcessNextRound or new validator:
TryToGetCurrentRoundInformation(out var currentRound);
var nextRound = input.ToRound();

// Validate that provided orders match FinalOrderOfNextRound from current round
foreach (var minerInCurrentRound in currentRound.RealTimeMinersInformation.Values)
{
    if (minerInCurrentRound.FinalOrderOfNextRound > 0 && 
        nextRound.RealTimeMinersInformation.ContainsKey(minerInCurrentRound.Pubkey))
    {
        var expectedOrder = minerInCurrentRound.FinalOrderOfNextRound;
        var actualOrder = nextRound.RealTimeMinersInformation[minerInCurrentRound.Pubkey].Order;
        Assert(expectedOrder == actualOrder, 
            $"Order mismatch for miner {minerInCurrentRound.Pubkey}: expected {expectedOrder}, got {actualOrder}");
    }
}

// Validate miners who didn't mine get remaining orders
var usedOrders = currentRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound).ToList();
var expectedAvailableOrders = Enumerable.Range(1, currentRound.RealTimeMinersInformation.Count)
    .Where(i => !usedOrders.Contains(i)).OrderBy(x => x).ToList();
    
// Continue validation...
```

**Alternative Approach:**

Instead of accepting a provided round, regenerate the next round deterministically in `ProcessNextRound`: [9](#0-8) 

This ensures the stored round always matches the deterministic generation logic.

**Test Cases:**

1. Test that `NextRound` rejects inputs where `Order` values don't match `FinalOrderOfNextRound` from current round
2. Test that miners who mined in current round must have orders matching their `FinalOrderOfNextRound`
3. Test that miners who didn't mine get assigned remaining orders in sequence
4. Test that manipulated order values trigger validation failure before state changes

### Proof of Concept

**Initial State:**
- Round N in progress with 5 miners (A, B, C, D, E)
- During Round N, miners determine their `FinalOrderOfNextRound`:
  - Miner A: FinalOrderOfNextRound = 3
  - Miner B: FinalOrderOfNextRound = 1
  - Miner C: FinalOrderOfNextRound = 5
  - Miner D: FinalOrderOfNextRound = 2
  - Miner E: didn't mine, no FinalOrderOfNextRound set

**Attack Steps:**

1. Miner B is selected as extra block producer for Round N
2. Miner B calls `GetConsensusExtraData` which generates legitimate next round:
   - Miner B: Order = 1 (from FinalOrderOfNextRound)
   - Miner D: Order = 2 (from FinalOrderOfNextRound)
   - Miner A: Order = 3 (from FinalOrderOfNextRound)
   - Miner C: Order = 5 (from FinalOrderOfNextRound)
   - Miner E: Order = 4 (remaining slot)

3. **Attack:** Miner B modifies the `NextRoundInput` before submission:
   - Miner B: Order = 1 (unchanged, keeps first position)
   - Miner D: Order = 5 (demoted to last)
   - Miner A: Order = 4 (demoted)
   - Miner C: Order = 2 (promoted)
   - Miner E: Order = 3 (neutral)

4. Miner B submits manipulated `NextRoundInput` via `NextRound` transaction

**Expected Result:**
Transaction should fail validation with error: "Order values don't match FinalOrderOfNextRound from current round"

**Actual Result:**
Transaction succeeds, manipulated round is stored as Round N+1, and Miner B gains unfair advantage while Miners D and A are disadvantaged

**Success Condition:**
Query `GetRoundInformation(N+1)` and observe that Order values differ from the FinalOrderOfNextRound values that were set in Round N, confirming the manipulation was accepted by the consensus contract.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L25-56)
```csharp
        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L1-50)
```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using AElf.Contracts.Election;
using AElf.CSharp.Core;
using AElf.CSharp.Core.Extension;
using AElf.Sdk.CSharp;
using AElf.Types;
using Google.Protobuf.WellKnownTypes;

namespace AElf.Contracts.Consensus.AEDPoS;

// ReSharper disable once InconsistentNaming
public partial class AEDPoSContract
{
    public override Int64Value GetCurrentRoundNumber(Empty input)
    {
        return new() { Value = State.CurrentRoundNumber.Value };
    }

    public override Round GetCurrentRoundInformation(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var currentRound) ? currentRound : new Round();
    }

    public override Round GetRoundInformation(Int64Value input)
    {
        return TryToGetRoundInformation(input.Value, out var round) ? round : new Round();
    }

    public override MinerList GetCurrentMinerList(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var round)
            ? new MinerList
            {
                Pubkeys =
                {
                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))
                }
            }
            : new MinerList();
    }

    public override PubkeyList GetCurrentMinerPubkeyList(Empty input)
    {
        return new()
        {
            Pubkeys = { GetCurrentMinerList(input).Pubkeys.Select(p => p.ToHex()) }
        };
    }
```
