# Audit Report

## Title
Inconsistent Vote Counting Allows Non-Member Votes to Inflate Participation Threshold

## Summary
The Association contract's release threshold calculation contains a critical inconsistency where votes from removed members are excluded from approval/rejection/abstention counts but included in the total vote participation count. This allows proposals to be released with fewer actual member votes than required by the MinimalVoteThreshold governance parameter.

## Finding Description

The vulnerability exists in the threshold calculation logic within the Association contract's release mechanism. When a member votes on a proposal and is subsequently removed from the organization, their vote remains permanently stored in the proposal's vote lists.

During the voting process, the `Approve`, `Reject`, and `Abstain` functions validate that the sender is a current member before recording their vote. [1](#0-0) [2](#0-1) [3](#0-2) 

However, when members are removed via `RemoveMember`, only the organization's member list is updated - the proposal's vote lists remain unchanged. [4](#0-3) 

The critical flaw occurs in the `CheckEnoughVoteAndApprovals` function. The approval count filters by current membership using `proposal.Approvals.Count(organization.OrganizationMemberList.Contains)`. [5](#0-4) 

Similarly, rejection and abstention counts also filter by current membership. [6](#0-5) [7](#0-6) 

But the MinimalVoteThreshold check counts ALL votes without any membership filter using `proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count()`. [8](#0-7) 

This inconsistency means votes from removed members contribute to meeting the MinimalVoteThreshold requirement while not affecting approval/rejection/abstention thresholds.

## Impact Explanation

This vulnerability enables governance bypass through vote count inflation:

**Concrete Harm:**
- Proposals can be released with fewer actual member votes than intended by the MinimalVoteThreshold parameter
- Organizations can manipulate membership to artificially inflate participation counts
- The fundamental governance invariant that "MinimalVoteThreshold represents required participation from actual members" is violated

**Quantified Scenario:**
Consider an organization with 10 permanent members, MinimalVoteThreshold=7, and MinimalApprovalThreshold=5:
1. 5 permanent members approve a proposal (meets MinimalApprovalThreshold)
2. Organization adds 3 temporary members via governance proposal
3. Temporary members vote (approval/rejection/abstention doesn't matter)
4. Organization removes the 3 temporary members via another governance proposal
5. Proposal now has 8 total votes (meets MinimalVoteThreshold â‰¥ 7) but only 5 from actual members
6. Proposal can be released despite only 50% actual member participation instead of the required 70%

**Severity:** HIGH - This directly violates governance security by allowing proposals to pass with insufficient actual member participation, potentially enabling unauthorized contract calls through the organization's authority.

## Likelihood Explanation

**Attack Complexity:** LOW - Requires only standard organization operations:
1. Create proposals to add/remove members (standard governance)
2. Have temporary members vote during their membership period
3. Remove those members through another proposal

**Feasibility:** Organizations naturally add and remove members for legitimate reasons, meaning this can occur both intentionally (malicious manipulation) and unintentionally (natural member turnover).

**Detection Constraints:** Vote histories are visible on-chain, but the inconsistent counting logic is not obvious. Organizations may not realize their participation thresholds are being bypassed.

**Probability:** HIGH - This can occur in two scenarios:
1. Intentional: Malicious organization operators can deliberately manipulate membership
2. Accidental: Natural member turnover causes historical votes to inflate participation counts

## Recommendation

The MinimalVoteThreshold check should filter votes by current membership, consistent with how approval, rejection, and abstention counts are calculated.

Change the `CheckEnoughVoteAndApprovals` function to filter all vote counting by current membership:

```csharp
var isVoteThresholdReached =
    proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
    proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
    proposal.Rejections.Count(organization.OrganizationMemberList.Contains) >=
    organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

This ensures that only votes from current members count toward all threshold calculations.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Create an Association organization with 10 members and MinimalVoteThreshold=7, MinimalApprovalThreshold=5
2. Create a proposal
3. Have 5 permanent members approve the proposal
4. Add 3 temporary members to the organization
5. Have the 3 temporary members vote (any type)
6. Remove the 3 temporary members
7. Verify that `GetProposal` returns `ToBeReleased=true` despite only 5 current members having voted
8. Successfully call `Release` on the proposal

The test would confirm that the proposal can be released with only 5 current member votes instead of the required 7, demonstrating the governance bypass.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L143-161)
```csharp
    public override Empty Reject(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Rejections.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Reject),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L163-181)
```csharp
    public override Empty Abstain(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Abstentions.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Abstain),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-53)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-58)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
```
