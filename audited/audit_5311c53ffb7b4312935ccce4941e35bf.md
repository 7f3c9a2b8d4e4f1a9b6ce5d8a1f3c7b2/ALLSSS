### Title
Unbounded Iteration in GetProfitsMap View Method Causes DoS via ExecutionCallThreshold Exhaustion

### Summary
The `GetProfitsMap()` view method iterates over all profit details without limit and calculates profits across potentially large period ranges, causing state access counts to exceed the ExecutionCallThreshold (15,000). This results in RuntimeCallThresholdExceededException, preventing users from querying their total profits. While the transaction method `ClaimProfits` has proper limits (10 details max), the view methods lack equivalent protections.

### Finding Description

**Exact Location:** [1](#0-0) 

**Root Cause:**
The `GetProfitsMap()` view method calls `GetAllProfitsMap()` which contains an unbounded loop: [2](#0-1) 

This loop iterates over ALL `availableDetails.Count` (line 125) without the limit enforced in the transaction variant. For each detail, it calls `ProfitAllPeriods` with period count of `profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod)` (line 130), which can span hundreds or thousands of periods if the beneficiary hasn't claimed profits for a long time or if EndPeriod is set far in the future. [3](#0-2) 

Inside `ProfitAllPeriods`, each period iteration performs state access: [4](#0-3) 

Each state access at line 867 counts toward the ExecutionCallThreshold enforced by the ExecutionObserver: [5](#0-4) 

When call count reaches 15,000, the ExecutionObserver throws an exception: [6](#0-5) 

**Why Protections Fail:**
Unlike the transaction method `ClaimProfits` which limits iterations: [7](#0-6) 

The view method lacks equivalent limits on line 125 of ViewMethods.cs, processing ALL details instead of just the first 10.

**Relevant Execution Path:**
1. User calls `GetProfitsMap()` → `GetAllProfitsMap()`
2. Loop processes ALL availableDetails (potentially 50+ details)
3. For each detail: iterates over symbols (5-10) × periods (50-1000+) 
4. Each iteration: state access counts toward ExecutionCallThreshold
5. Total calls: e.g., 50 details × 10 symbols × 50 periods = 25,000 calls
6. Exceeds 15,000 threshold → RuntimeCallThresholdExceededException thrown
7. View method fails, user cannot query profits

### Impact Explanation

**Operational Impact - DoS of View Methods:**
- Users cannot query their total profits via `GetProfitsMap()`, `GetProfitAmount()`, or `GetAllProfitAmount()` (all use the same vulnerable `GetAllProfitsMap()` helper)
- Frontend integrations cannot display profit information
- Users forced to claim profits blindly without knowing amounts
- Affects user experience and system usability

**Who is Affected:**
- Beneficiaries in long-running profit schemes who have accumulated many profit details
- Particularly impacts active users in schemes with TokenHolder integration where stakes are frequently adjusted

**No Fund Loss:**
- Profits remain claimable via `ClaimProfits` transaction (which has proper limits)
- No tokens locked or stolen
- State integrity maintained

**Severity Justification - Medium:**
- Operational impact on query availability
- Degrades UX but doesn't prevent core functionality (claiming)
- Can occur naturally without malicious intent
- Affects legitimate users of the protocol

### Likelihood Explanation

**Natural Occurrence Scenario (Medium Probability):**

Realistic numbers for a scheme running 6-12 months:
- Scheme runs 500+ periods (daily periods over months)
- User has 30 profit details (TokenHolder adjusts stakes monthly, or scheme manager rebalances)
- Scheme uses 8 token symbols
- User hasn't claimed in 50 periods
- Calculation: 30 details × 8 symbols × 50 periods = 12,000 state accesses (near threshold)
- With 50 details × 10 symbols × 50 periods = 25,000 (exceeds threshold)

**Preconditions:**
1. Profit scheme exists and has been running for extended period
2. Beneficiary has accumulated multiple profit details via repeated `AddBeneficiary` calls
3. Beneficiary hasn't claimed profits regularly (LastProfitPeriod remains old)
4. Scheme uses multiple token symbols

**AddBeneficiary Authorization:** [8](#0-7) 

Only scheme manager or TokenHolder contract can add beneficiaries. This is a semi-trusted role, but:
- Managers may legitimately call AddBeneficiary multiple times as user stakes change
- TokenHolder contract automatically calls it when users adjust positions
- No malicious intent required - natural accumulation over time

**Details Accumulate Naturally:** [9](#0-8) 

Old details only removed if expired AND beyond ProfitReceivingDuePeriodCount. Active schemes with EndPeriod far in future retain all details.

**Attack Complexity:** Low
- No special attacker capabilities needed
- Occurs through normal system usage
- Detection difficulty: Low (query simply fails with exception)

**Economic Rationality:** N/A (not an attack, natural occurrence)

### Recommendation

**Code-Level Mitigation:**

Apply the same limits used in `ClaimProfits` to `GetAllProfitsMap` in ViewMethods.cs:

```
Line 125: Change from
for (var i = 0; i < availableDetails.Count; i++)

To:
var maxDetailsToProcess = Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, availableDetails.Count);
for (var i = 0; i < maxDetailsToProcess; i++)
```

Line 130: Change from
```
ProfitAllPeriods(scheme, profitDetail, beneficiary, profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod), true, symbol)
```

To:
```
var limitedPeriodCount = Math.Min(maxProfitReceivingPeriodCount, profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod));
ProfitAllPeriods(scheme, profitDetail, beneficiary, limitedPeriodCount, true, symbol)
```

**Additional Invariant Checks:**
- Add counter to track state accesses in view methods
- Consider pagination for view methods returning large datasets
- Add warning in documentation about view method limitations when many details exist

**Test Cases:**
1. Test GetProfitsMap with 20+ profit details spanning 100+ periods each
2. Verify view method returns partial results instead of throwing exception
3. Test that ClaimProfits can still process profits even when view fails
4. Add integration test simulating long-running scheme with multiple symbols

### Proof of Concept

**Initial State:**
1. Create profit scheme with 10 token symbols
2. Scheme runs for 200 periods
3. Call `AddBeneficiary` 40 times for target user with different period ranges
4. Ensure user's LastProfitPeriod is 0 or low number (hasn't claimed recently)

**Exploitation Steps:**
```
1. Beneficiary calls GetProfitsMap(schemeId, beneficiary)
2. GetAllProfitsMap processes 40 details
3. For each detail: 10 symbols × 50 avg periods = 500 state accesses
4. Total: 40 × 500 = 20,000 state accesses
5. ExecutionCallThreshold (15,000) exceeded at ~30th detail
```

**Expected Result:**
View method returns ReceivedProfitsMap with profit amounts

**Actual Result:**
RuntimeCallThresholdExceededException thrown, query fails

**Success Condition:**
Exception logged in transaction trace, user unable to retrieve profit map despite having valid claimable profits

**Notes**

The vulnerability affects only view methods used for querying profit information. The actual `ClaimProfits` transaction method has proper protections and remains functional. However, users are forced to claim profits without visibility into amounts, creating a poor user experience. The issue stems from an architectural inconsistency where transaction methods enforce limits but view methods do not, despite both performing similar computational work.

The natural accumulation scenario is realistic in production environments where schemes run continuously and users adjust stakes over time through TokenHolder integration. No malicious actor or trusted role compromise is required - the DoS occurs through normal protocol usage patterns.

### Citations

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L88-96)
```csharp
    public override ReceivedProfitsMap GetProfitsMap(ClaimProfitsInput input)
    {
        var allProfitsMapResult = GetAllProfitsMap(input.SchemeId, input.Beneficiary);

        return new ReceivedProfitsMap
        {
            Value = { allProfitsMapResult.AllProfitsMap }
        };
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L103-122)
```csharp
    private GetAllProfitsMapOutput GetAllProfitsMap(Hash schemeId, Address beneficiary, string symbol = null)
    {
        var scheme = State.SchemeInfos[schemeId];
        Assert(scheme != null, "Scheme not found.");
        beneficiary = beneficiary ?? Context.Sender;
        var profitDetails = State.ProfitDetailsMap[schemeId][beneficiary];

        if (profitDetails == null) return new GetAllProfitsMapOutput();

        // ReSharper disable once PossibleNullReferenceException
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod < scheme.CurrentPeriod && (d.LastProfitPeriod == 0
                ? d.EndPeriod >= d.StartPeriod
                : d.EndPeriod >= d.LastProfitPeriod)
        ).ToList();
        
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, availableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);

```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L125-135)
```csharp
        for (var i = 0; i < availableDetails.Count; i++)
        {
            var profitDetail = availableDetails[i];
            if (profitDetail.LastProfitPeriod == 0) profitDetail.LastProfitPeriod = profitDetail.StartPeriod;
            
            var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod),true, symbol);
            AddProfitToDict(allProfitsDict, totalProfitsDictForEachProfitDetail);
            if(i >= profitableDetailCount) continue;
            var claimableProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount,true, symbol);
            AddProfitToDict(claimableProfitsDict, claimableProfitsDictForEachProfitDetail);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L200-207)
```csharp
        else
            currentProfitDetails.Details.Add(profitDetail);

        // Remove details too old.
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L772-777)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
        // Only can get profit from last profit period to actual last period (profit.CurrentPeriod - 1),
        // because current period not released yet.
        for (var i = 0; i < profitableDetailCount; i++)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-871)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-7)
```csharp
    public const int ExecutionCallThreshold = 15000;

    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L21-27)
```csharp
    public void CallCount()
    {
        if (_callThreshold != -1 && _callCount == _callThreshold)
            throw new RuntimeCallThresholdExceededException($"Contract call threshold {_callThreshold} exceeded.");

        _callCount++;
    }
```
