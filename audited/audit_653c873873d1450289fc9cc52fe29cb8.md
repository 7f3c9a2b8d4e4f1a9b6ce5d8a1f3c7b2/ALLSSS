### Title
NFT Contract ACS1 Implementation Non-Functional: Governance Cannot Control Method Fees

### Summary
The NFT contract's ACS1 implementation consists of non-functional stub methods that do not store or manage transaction fees. Unlike all other AElf system contracts, the NFT contract lacks the required state variables (`MethodFeeController` and `TransactionFees`) and implements `SetMethodFee` and `ChangeMethodFeeController` as no-ops. This prevents governance from adjusting fees in response to economic conditions and violates the ACS1 standard that all system contracts must implement. [1](#0-0) 

### Finding Description

The NFT contract implements the ACS1 interface but with critical deficiencies:

1. **Missing State Variables**: The `NFTContractState` class lacks the required `MappedState<string, MethodFees> TransactionFees` and `SingletonState<AuthorityInfo> MethodFeeController` mappings that all other system contracts have. [2](#0-1) 

2. **Non-Functional SetMethodFee**: The `SetMethodFee` method immediately returns `Empty` without storing the input or performing any authorization checks. This means governance proposals to update NFT fees silently do nothing. [3](#0-2) 

3. **Non-Functional ChangeMethodFeeController**: The `ChangeMethodFeeController` method also returns `Empty` without updating any state, preventing governance from even changing who controls the fees. [4](#0-3) 

4. **Hardcoded Fee Structure**: `GetMethodFee` returns a hardcoded 100 ELF fee only for the `Create` method, and empty `MethodFees` for all other methods. This cannot be changed through governance. [5](#0-4) 

5. **Contrast with Proper Implementation**: All other system contracts implement ACS1 correctly with state storage and authorization. For example, the Association contract properly stores fees in `State.TransactionFees[input.MethodName]` and checks authorization against `State.MethodFeeController.Value.OwnerAddress`. [6](#0-5) [7](#0-6) 

6. **Fee Charging Flow**: When the token contract charges transaction fees, it calls the target contract's `GetMethodFee` method. For NFT contract, this returns hardcoded values that governance cannot adjust. [8](#0-7) 

7. **Documentation Violation**: The ACS1 documentation explicitly states that all AElf system contracts implement ACS1, and provides the standard implementation pattern with required state variables. [9](#0-8) [10](#0-9) 

### Impact Explanation

**Governance Control Loss**: Parliament and governance organizations have no ability to adjust NFT contract fees, breaking the "method-fee provider authority" invariant. This is the only system contract where governance lacks this control.

**Economic Rigidity**: 
- The `Create` method has a fixed 100 ELF fee (100 * 10^8 base units). If ELF's USD value increases 10x, creating NFT protocols becomes prohibitively expensive for legitimate users with no recourse.
- If ELF's value drops 90%, the `Create` operation becomes economically spammable.
- Methods like `Mint`, `Transfer`, `Burn`, `Approve`, `TransferFrom`, `Assemble`, `Disassemble`, and `Recast` all have zero base fee (only transaction size fee applies), making them more susceptible to spam than if proper fee controls existed. [11](#0-10) 

**Operational Risk**: Without the ability to adjust fees dynamically:
- Spam attacks on low-fee operations become more feasible
- Economic conditions cannot be adapted to as the protocol evolves
- The NFT contract cannot align with fee policies applied to other system contracts

**Protocol Consistency Violation**: This creates an inconsistency where 15+ system contracts (Parliament, Association, MultiToken, Treasury, Election, etc.) have governance-controlled fees, but NFT contract does not.

### Likelihood Explanation

**Current State**: This issue exists in the deployed code and is immediately observable. The stub implementations are not conditional or behind any access control—they simply do nothing. [1](#0-0) 

**Governance Attempts Will Fail**: Any governance proposal to call `SetMethodFee` or `ChangeMethodFeeController` will execute successfully but have zero effect, potentially misleading governance participants into thinking fees have been updated.

**No Initialization**: The NFT contract has no initialization logic, confirming this is not a temporary state awaiting setup. [12](#0-11) 

**Economic Conditions Already Variable**: Cryptocurrency prices are inherently volatile. The inability to adjust the fixed 100 ELF fee is an immediate operational constraint.

**Detection**: This issue is not stealthy—anyone examining the contract code or attempting to use governance to adjust fees will discover the problem.

### Recommendation

**Add Required State Variables** to `NFTContractState.cs`:

```csharp
public MappedState<string, MethodFees> TransactionFees { get; set; }
public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
```

**Implement SetMethodFee** following the standard pattern from other system contracts:

```csharp
public override Empty SetMethodFee(MethodFees input)
{
    foreach (var methodFee in input.Fees) 
        AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
    RequiredMethodFeeControllerSet();
    Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, 
        "Unauthorized to set method fee.");
    State.TransactionFees[input.MethodName] = input;
    return new Empty();
}
```

**Implement ChangeMethodFeeController** with authorization:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress,
        "Unauthorized behavior.");
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    State.MethodFeeController.Value = input;
    return new Empty();
}
```

**Update GetMethodFee** to read from state:

```csharp
public override MethodFees GetMethodFee(StringValue input)
{
    return State.TransactionFees[input.Value] ?? new MethodFees();
}
```

**Update GetMethodFeeController** with initialization:

```csharp
public override AuthorityInfo GetMethodFeeController(Empty input)
{
    RequiredMethodFeeControllerSet();
    return State.MethodFeeController.Value;
}
```

**Add RequiredMethodFeeControllerSet helper** following the standard pattern from Association contract: [13](#0-12) 

**Add Initialization Logic** to set default fees for critical methods like `Create` via the initialization provider.

**Add Test Coverage** for ACS1 methods following patterns from other system contracts: [14](#0-13) 

### Proof of Concept

**Step 1**: Query current method fee controller:
```
NFTContract.GetMethodFeeController() → Returns empty AuthorityInfo (no owner, no contract address)
```

**Step 2**: Attempt to set method fee via governance:
```
Parliament creates proposal to call NFTContract.SetMethodFee(new MethodFees { 
    MethodName = "Mint", 
    Fees = { new MethodFee { Symbol = "ELF", BasicFee = 1_00000000 } }
})
→ Proposal passes and executes
→ Transaction succeeds but no state change occurs
```

**Step 3**: Verify fee was not stored:
```
NFTContract.GetMethodFee("Mint") → Returns empty MethodFees (zero fees)
```

**Expected Behavior**: After Step 2, `GetMethodFee("Mint")` should return the set fee of 1 ELF.

**Actual Behavior**: Fee query returns empty because `SetMethodFee` is a no-op that doesn't store anything.

**Success Condition**: The stub implementations prevent any governance control over NFT fees, as demonstrated by the no-op behavior and missing state storage.

### Notes

This is a **governance and operational vulnerability** rather than a direct fund theft issue. The severity stems from:

1. Complete loss of governance control over a system contract
2. Economic inflexibility as market conditions change  
3. Violation of the ACS1 standard that defines the AElf fee architecture
4. Inconsistency with all other system contracts in the ecosystem

The fix requires implementing the full ACS1 pattern consistently with other system contracts, adding proper state management, authorization checks, and initialization logic.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-16)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }

    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L6-46)
```csharp
public partial class NFTContractState : ContractState
{
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
}
```

**File:** contract/AElf.Contracts.Association/AssociationState.cs (L11-12)
```csharp
    public MappedState<string, MethodFees> TransactionFees { get; set; }
    public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L10-18)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L49-63)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-39)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
```

**File:** docs-sphinx/reference/acs/acs1.rst (L88-89)
```text
Attention: just the system contract on main chain is able to implement
acs1.
```

**File:** docs-sphinx/reference/acs/acs1.rst (L399-400)
```text
All AElf system contracts implement ACS1, which can be used as a
reference.
```

**File:** protobuf/nft_contract.proto (L22-56)
```text
    // Create a new nft protocol.
    rpc Create (CreateInput) returns (google.protobuf.StringValue) {
    }
    rpc CrossChainCreate (CrossChainCreateInput) returns (google.protobuf.Empty) {
    }
    // Mint (Issue) an amount of nft.
    rpc Mint (MintInput) returns (aelf.Hash) {
    }
    // Transfer nft to another address.
    rpc Transfer (TransferInput) returns (google.protobuf.Empty) {
    }
    // Transfer nft from one address to another.
    rpc TransferFrom (TransferFromInput) returns (google.protobuf.Empty) {
    }
    // Approve another address to transfer nft from own account.
    rpc Approve (ApproveInput) returns (google.protobuf.Empty) {
    }
    // De-approve.
    rpc UnApprove (UnApproveInput) returns (google.protobuf.Empty) {
    }
    // Approve or de-approve another address as the operator of all NFTs of a certain protocol.
    rpc ApproveProtocol (ApproveProtocolInput) returns (google.protobuf.Empty) {
    }
    // Destroy nfts.
    rpc Burn (BurnInput) returns (google.protobuf.Empty) {
    }
    // Lock several nfts and fts to mint one nft.
    rpc Assemble (AssembleInput) returns (aelf.Hash) {
    }
    // Disassemble one assembled nft to get locked nfts and fts back.
    rpc Disassemble (DisassembleInput) returns (google.protobuf.Empty) {
    }
    // Modify metadata of one nft.
    rpc Recast (RecastInput) returns (google.protobuf.Empty) {
    }
```

**File:** test/AElf.Contracts.NFT.Tests/NFTContractInitializationProvider.cs (L13-16)
```csharp
    public List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        return new List<ContractInitializationMethodCall>();
    }
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ACS1ImplTest.cs (L1-1)
```csharp
using System.Threading.Tasks;
```
