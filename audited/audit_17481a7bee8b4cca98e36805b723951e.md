# Audit Report

## Title
Unhandled Exception in CrossChainCreate() Due to Unsafe bool.Parse() on Unvalidated ExternalInfo

## Summary
The NFT contract's `CrossChainCreate()` method performs unsafe `bool.Parse()` and direct dictionary access on token `ExternalInfo` without validation or exception handling. An attacker can create a token on the mainchain with malformed `ExternalInfo` metadata, replicate it cross-chain, and cause permanent DoS of NFT protocol creation on the sidechain for that symbol.

## Finding Description

The vulnerability exists in the NFT contract's `CrossChainCreate()` method where it unsafely parses `ExternalInfo` metadata from tokens created cross-chain. [1](#0-0) 

These lines perform two unsafe operations without any exception handling:
1. **Direct dictionary access** `tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey]` throws `KeyNotFoundException` if the key doesn't exist
2. **Unsafe bool.Parse()** throws `FormatException` if the value is not a valid boolean string like "True" or "False"

The metadata key constants are defined as: [2](#0-1) 

**Root Cause**: The MultiToken contract accepts arbitrary `ExternalInfo` content during token creation without validating the format: [3](#0-2) 

The `AssertValidCreateInput` method validates basic token parameters but does not validate `ExternalInfo` content: [4](#0-3) 

In contrast, the legitimate NFT contract's `Create` method properly sets boolean values as strings: [5](#0-4) 

**Cross-Chain Replication**: The malformed `ExternalInfo` is preserved during cross-chain token creation: [6](#0-5) 

The `ValidateTokenInfoExists` method only validates that `ExternalInfo` matches between source and input (equality check), but doesn't validate content format: [7](#0-6) 

**Why Existing Protections Fail**: Other parts of the codebase use safer patterns with `TryGetValue()` and `TryParse()`: [8](#0-7) 

However, the NFT contract's `CrossChainCreate()` method has no such protections and no exception handling around the vulnerable code: [9](#0-8) 

## Impact Explanation

**Concrete Harm**:
- **Permanent DoS of Cross-Chain NFT Protocol Creation**: Once a malicious token is replicated to a sidechain, any call to `CrossChainCreate()` for that symbol will throw an unhandled exception, causing the transaction to fail permanently
- **Protocol Lock-Out**: The NFT protocol becomes stuck - it exists on the mainchain but cannot be instantiated on the sidechain, completely breaking cross-chain NFT functionality for that symbol
- **Resource Waste**: Legitimate users attempting to create the protocol will pay transaction fees for guaranteed-to-fail transactions
- **No Recovery Path**: The only recovery mechanism is a contract upgrade, requiring governance approval

**Who is Affected**:
- NFT protocol creators attempting to expand their protocols to sidechains
- DApps depending on cross-chain NFT availability for their functionality
- End users unable to interact with NFT protocols on affected sidechains
- The broader ecosystem's cross-chain NFT interoperability

**Severity Justification**: High severity because:
- Complete denial of service for specific NFT protocol symbols
- No recovery mechanism without contract upgrade
- Breaks critical cross-chain functionality that is core to the AElf ecosystem
- Affects operational integrity of the entire NFT system across chains

## Likelihood Explanation

**Attacker Capabilities Required**:
1. Obtain a SEED NFT for token creation (publicly tradeable on markets)
2. Call `MultiToken.Create()` on mainchain with crafted `ExternalInfo` containing malformed values
3. Execute standard cross-chain replication via existing mechanisms

**Attack Complexity**: Low
- Simple 3-step process requiring no specialized knowledge
- No sophisticated cryptographic manipulation needed
- No timing dependencies or race conditions
- Uses only public, permissionless methods

**Feasibility Conditions**:
- SEED NFTs are tradeable assets obtainable by any user with funds
- Token creation with custom `ExternalInfo` is explicitly permitted by design
- Cross-chain replication is a standard, permissionless operation
- `CrossChainCreate()` has no sender restrictions

**Economic Rationality**:
- Attack cost: Price of one SEED NFT + minimal transaction fees
- Attack benefit: Can permanently block competitor NFT protocols from expanding cross-chain
- Economically viable for griefing attacks or competitive advantage
- High damage-to-cost ratio

**Detection/Operational Constraints**:
- Attack leaves on-chain evidence (malicious token creation transaction)
- However, damage is irreversible once token is replicated cross-chain
- No automatic detection mechanisms exist in the current implementation
- No validation occurs until `CrossChainCreate()` is called

**Probability**: Medium-High - All preconditions are readily achievable by any user with modest resources and basic understanding of the system.

## Recommendation

Implement defensive programming with proper validation and exception handling:

```csharp
public override Empty CrossChainCreate(CrossChainCreateInput input)
{
    MakeSureTokenContractAddressSet();
    InitialNFTTypeNameMap();
    Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
    
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
    {
        Symbol = input.Symbol
    });
    
    if (string.IsNullOrEmpty(tokenInfo.Symbol))
        throw new AssertionException($"Token info {input.Symbol} not exists.");

    // Safe dictionary access with TryGetValue
    if (!tokenInfo.ExternalInfo.Value.TryGetValue(NftBaseUriMetadataKey, out var baseUri))
        throw new AssertionException($"Required metadata key {NftBaseUriMetadataKey} not found.");
    
    // Safe boolean parsing with TryParse
    if (!tokenInfo.ExternalInfo.Value.TryGetValue(NftTokenIdReuseMetadataKey, out var isTokenIdReuseStr) ||
        !bool.TryParse(isTokenIdReuseStr, out var isTokenIdReuse))
        throw new AssertionException($"Invalid or missing metadata key {NftTokenIdReuseMetadataKey}.");
    
    // Rest of the method continues safely...
}
```

Additionally, consider adding validation in `MultiToken.Create()` to reject tokens with NFT-like symbols that don't have properly formatted `ExternalInfo` metadata.

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreate_WithMalformedExternalInfo_ShouldThrowException()
{
    // Step 1: Create token with malformed ExternalInfo on mainchain
    var malformedExternalInfo = new ExternalInfo
    {
        Value =
        {
            { "aelf_nft_base_uri", "https://example.com/" },
            { "aelf_nft_token_id_reuse", "NOT_A_BOOLEAN" }, // Invalid boolean value
            { "aelf_nft_type", "TestType" }
        }
    };
    
    var createInput = new CreateInput
    {
        Symbol = "TESTNFT-0",
        TokenName = "Test NFT",
        TotalSupply = 1000,
        Decimals = 0,
        Issuer = MainChainTester.GetAddress(DefaultSender),
        IsBurnable = true,
        IssueChainId = MainChainId,
        ExternalInfo = malformedExternalInfo
    };
    
    await MainChainTokenContractStub.Create.SendAsync(createInput);
    
    // Step 2: Replicate token cross-chain (simulate via ValidateTokenInfoExists)
    await SideChainTokenContractStub.CrossChainCreateToken.SendAsync(/* cross-chain params */);
    
    // Step 3: Attempt to call CrossChainCreate - should throw FormatException
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await SideChainNFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
        {
            Symbol = "TESTNFT-0"
        });
    });
    
    // Verify the exception is FormatException from bool.Parse
    Assert.Contains("FormatException", exception.Message);
}
```

**Notes**:
- The vulnerability is confirmed through code analysis showing unsafe operations without exception handling
- The attack path is straightforward and uses only public methods
- The impact is permanent DoS for specific NFT symbols on sidechains
- The likelihood is medium-high as SEED NFTs are obtainable by any user
- This breaks the security guarantee that valid cross-chain tokens should be creatable on sidechains

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-129)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;

        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = input.Symbol,
            Creator = nftProtocolInfo.Creator,
            IsBurnable = nftProtocolInfo.IsBurnable,
            IssueChainId = nftProtocolInfo.IssueChainId,
            ProtocolName = nftProtocolInfo.ProtocolName,
            TotalSupply = nftProtocolInfo.TotalSupply,
            Metadata = nftProtocolInfo.Metadata,
            BaseUri = nftProtocolInfo.BaseUri,
            IsTokenIdReuse = isTokenIdReuse,
            NftType = nftProtocolInfo.NftType
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L184-201)
```csharp
    private ExternalInfo GetTokenExternalInfo(CreateInput input)
    {
        if (input.Metadata != null) AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var tokenExternalInfo = input.Metadata == null
            ? new ExternalInfo()
            : new ExternalInfo
            {
                Value = { input.Metadata.Value }
            };

        // Add NFT Type to external info.
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
        // Add Uri to external info.
        tokenExternalInfo.Value[NftBaseUriMetadataKey] = input.BaseUri;
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
        return tokenExternalInfo;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L8-9)
```csharp
    private const string NftBaseUriMetadataKey = "aelf_nft_base_uri";
    private const string NftTokenIdReuseMetadataKey = "aelf_nft_token_id_reuse";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L118-131)
```csharp
    private void CheckSeedNFT(string symbolSeed, String symbol)
    {
        Assert(!string.IsNullOrEmpty(symbolSeed), "Seed NFT does not exist.");
        var tokenInfo = GetTokenInfo(symbolSeed);
        Assert(tokenInfo != null, "Seed NFT does not exist.");
        Assert(State.Balances[Context.Sender][symbolSeed] > 0, "Seed NFT balance is not enough.");
        Assert(tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.SeedOwnedSymbolExternalInfoKey, out var ownedSymbol) && ownedSymbol == symbol,
            "Invalid OwnedSymbol.");
        Assert(tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                   out var expirationTime)
               && long.TryParse(expirationTime, out var expirationTimeLong) &&
               Context.CurrentBlockTime.Seconds <= expirationTimeLong, "OwnedSymbol is expired.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L438-460)
```csharp
    public override Empty ValidateTokenInfoExists(ValidateTokenInfoExistsInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo == null) throw new AssertionException("Token validation failed.");

        var validationResult = tokenInfo.TokenName == input.TokenName &&
                               tokenInfo.IsBurnable == input.IsBurnable && tokenInfo.Decimals == input.Decimals &&
                               tokenInfo.Issuer == input.Issuer && tokenInfo.TotalSupply == input.TotalSupply &&
                               tokenInfo.IssueChainId == input.IssueChainId && tokenInfo.Owner == input.Owner;

        if (tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.Count > 0 ||
            input.ExternalInfo != null && input.ExternalInfo.Count > 0)
        {
            validationResult = validationResult && tokenInfo.ExternalInfo.Value.Count == input.ExternalInfo.Count;
            if (tokenInfo.ExternalInfo.Value.Any(keyPair =>
                    !input.ExternalInfo.ContainsKey(keyPair.Key) || input.ExternalInfo[keyPair.Key] != keyPair.Value))
                throw new AssertionException("Token validation failed.");
        }

        Assert(validationResult, "Token validation failed.");
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L492-503)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```
