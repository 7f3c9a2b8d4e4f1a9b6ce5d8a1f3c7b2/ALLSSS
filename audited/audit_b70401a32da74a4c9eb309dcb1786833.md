# Audit Report

## Title
Cross-Chain Token Creation Bypasses Case-Insensitive Duplicate Check, Enabling Phishing Token Creation

## Summary
The `CrossChainCreateToken` function fails to perform case-insensitive duplicate token validation before registering tokens from other chains. While the normal token creation path prevents case variants like "TOKEN" and "token" from coexisting via the `CheckTokenExists` function, the cross-chain creation path only checks for exact symbol matches, allowing an attacker to introduce case-variant phishing tokens from other chains.

## Finding Description

The MultiToken contract implements case-insensitive duplicate prevention through the `CheckTokenExists` helper function, which validates both exact symbol matches and case-insensitive existence. [1](#0-0) 

When tokens are created normally via the `Create` function, this validation is properly enforced by calling `CheckTokenExists` before `RegisterTokenInfo`. [2](#0-1) 

The `RegisterTokenInfo` function then stores both the exact symbol in `State.TokenInfos` and sets the case-insensitive flag in `State.InsensitiveTokenExisting`. [3](#0-2) 

However, the `CrossChainCreateToken` function bypasses this protection entirely. At line 506, it only checks if the exact symbol exists in `State.TokenInfos` without calling `CheckTokenExists` or verifying the case-insensitive mapping. [4](#0-3) 

This creates an inconsistent security model where:
- Direct token creation on a chain prevents "TOKEN" and "token" from coexisting
- Cross-chain token creation allows both to exist if brought from different source chains

**Attack Flow:**
1. Legitimate token "TOKEN" exists on Chain A with `State.InsensitiveTokenExisting["TOKEN"] = true`
2. Attacker creates token "token" (lowercase) on Chain B using a seed NFT or whitelist access
3. Attacker calls `CrossChainCreateToken` on Chain A with a valid cross-chain proof from Chain B
4. The check `State.TokenInfos["token"] == null` passes (exact match not found)
5. `RegisterTokenInfo` is called, creating the duplicate token
6. Both "TOKEN" and "token" now coexist on Chain A as separate tokens

## Impact Explanation

**Direct Financial Impact:**
Users interacting with case-insensitive user interfaces (common in wallets and blockchain explorers) will be unable to distinguish between "TOKEN" and "token", leading to:
- Accidental transfers to the wrong token
- Approval of allowances for phishing tokens instead of legitimate ones
- Loss of funds through confusion

**Protocol Integrity Impact:**
- Undermines the fundamental token uniqueness guarantee that the contract is designed to enforce
- dApps performing case-insensitive symbol lookups will exhibit unpredictable behavior
- Token pricing and trading on DEXs may become unreliable
- Loss of user trust in the token system

The severity is **MEDIUM to HIGH** because it breaks a core security invariant (token uniqueness), enables direct financial loss through user confusion, and affects multiple ecosystem participants (users, dApps, DEXs).

## Likelihood Explanation

**Attack Complexity: MEDIUM**

Prerequisites for exploitation:
1. Access to token creation on at least one chain (requires seed NFT purchase or whitelist access)
2. Ability to generate valid cross-chain proofs (standard cross-chain operation)
3. Target chain must have a legitimate token to impersonate

**Feasibility Assessment:**
- Entry point `CrossChainCreateToken` is publicly accessible
- Seed NFTs can be purchased or obtained through normal means
- Cross-chain proofs are generated through legitimate mechanisms
- The exploit follows normal cross-chain token creation flow, making detection difficult
- Economic cost is reasonable (seed NFT price + transaction fees) compared to potential phishing gains

The likelihood is **MEDIUM** because while the attack requires multi-chain setup and initial investment, it is definitely feasible for motivated attackers targeting high-value tokens. The exploit uses legitimate cross-chain infrastructure, making it indistinguishable from normal operations.

## Recommendation

Add case-insensitive duplicate validation to `CrossChainCreateToken` by calling `CheckTokenExists` before `RegisterTokenInfo`:

```csharp
if (State.TokenInfos[tokenInfo.Symbol] == null)
{
    CheckTokenExists(tokenInfo.Symbol);  // Add this line
    RegisterTokenInfo(tokenInfo);
    // ... rest of code
}
```

This ensures that cross-chain token creation follows the same security model as direct token creation, preventing case-variant duplicates regardless of the token's origin chain.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
public async Task CrossChainCreateToken_Allows_Case_Variant_Duplicates()
{
    // Setup: Create "TOKEN" on Chain A
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "TOKEN",
        TokenName = "Legitimate Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultAddress,
        IsBurnable = true,
        IssueChainId = ChainHelper.ConvertBase58ToChainId("AELF")
    });
    
    // Verify "TOKEN" exists
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "TOKEN" });
    tokenInfo.Symbol.ShouldBe("TOKEN");
    
    // Attacker: Create "token" (lowercase) on Chain B and bring to Chain A via CrossChainCreateToken
    var validateInput = new ValidateTokenInfoExistsInput
    {
        Symbol = "token",  // lowercase variant
        TokenName = "Phishing Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultAddress,
        IsBurnable = true,
        IssueChainId = SideChainId
    };
    
    // Generate cross-chain proof (simplified)
    var crossChainInput = GenerateCrossChainCreateTokenInput(validateInput, SideChainId);
    
    // Execute attack - should fail but currently succeeds
    await TokenContractStub.CrossChainCreateToken.SendAsync(crossChainInput);
    
    // Both "TOKEN" and "token" now exist!
    var legitToken = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "TOKEN" });
    var phishingToken = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = "token" });
    
    legitToken.Symbol.ShouldBe("TOKEN");
    phishingToken.Symbol.ShouldBe("token");  // Vulnerability: duplicate allowed
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L232-233)
```csharp
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L87-88)
```csharp
        CheckTokenExists(tokenInfo.Symbol);
        RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-508)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```
