### Title
Missing Key Existence Check in RecoverFromUpdateValue Causes Validation Failure and Inconsistent State During Miner Replacement

### Summary
The `RecoverFromUpdateValue` function fails to validate key existence before accessing the `RealTimeMinersInformation` dictionary in its loop (lines 22-30), causing a `KeyNotFoundException` when processing blocks with stale miner lists after a candidate replacement. This prevents execution of the proper miner replacement validation logic and leaves the Round object in a partially-updated inconsistent state, resulting in rejection of valid blocks and consensus disruption.

### Finding Description

The vulnerability exists in the `RecoverFromUpdateValue` function where a foreach loop iterates over all miners in the provided round and updates three fields in the current round's `RealTimeMinersInformation` dictionary without checking if the keys exist. [1](#0-0) 

While the function checks if the specific `pubkey` parameter exists in both dictionaries at the beginning, [2](#0-1)  the loop accesses all keys from `providedRound.RealTimeMinersInformation` without verifying they exist in the current state's dictionary.

This contrasts with the defensive coding pattern used consistently throughout the codebase, where `ContainsKey` checks precede dictionary access. [3](#0-2) 

The root cause becomes exploitable when miner replacement occurs via `RecordCandidateReplacement`, which removes an old pubkey and adds a new one to the current round. [4](#0-3) 

This replacement is triggered by the Election contract's `ReplaceCandidatePubkey` function. [5](#0-4) 

The function is called during both before-execution and after-execution validation. [6](#0-5) [7](#0-6) 

The critical issue is that the exception prevents the proper miner replacement validation logic from executing. The validation code at lines 103-123 explicitly handles miner list differences by verifying replacements against the Election contract, but this logic is never reached because the exception is thrown during the recovery step. [8](#0-7) 

### Impact Explanation

**Consensus Disruption**: When a miner replacement occurs, all blocks produced by miners with stale views of the miner list will fail validation with an unhandled exception. This can cause multiple consecutive blocks to be rejected, disrupting consensus and delaying block finalization.

**Validation Logic Bypass**: The system includes proper handling for miner replacements in the validation code, but this protection is unreachable due to the exception. Valid blocks that should be accepted after replacement verification are instead rejected immediately.

**Inconsistent State**: Before the exception is thrown, the loop may have already updated some miners' `SupposedOrderOfNextRound`, `FinalOrderOfNextRound`, and `PreviousInValue` fields while leaving others unchanged. This inconsistent Round object is then used in subsequent validation logic (if any executes before the exception propagates), potentially causing incorrect validation decisions.

**Block Production Impact**: Miners operating with legitimate but slightly delayed state updates will have their blocks systematically rejected, reducing effective mining capacity and potentially violating consensus timing guarantees.

The severity is HIGH because this directly impacts consensus integrity and block validation correctness, which are critical invariants for the blockchain's operation.

### Likelihood Explanation

**Reachable Entry Point**: The vulnerability is triggered through the standard consensus validation flow during block validation, which is executed for every block. [9](#0-8) 

**Feasible Preconditions**: 
1. A candidate calls `ReplaceCandidatePubkey` to replace their public key (a legitimate operation). [10](#0-9) 
2. The replacement transaction executes and updates the consensus contract state
3. A miner produces a block based on their state view before seeing the replacement
4. That block arrives at a validator who has already processed the replacement

**Execution Practicality**: This scenario occurs naturally in distributed systems due to block propagation delays. No attacker capabilities are required - this is a race condition inherent in the system's design. The only requirement is normal network latency between when a replacement occurs and when all miners see the updated state.

**Attack Complexity**: LOW - This requires no special attacker capabilities, just normal timing variations in block propagation. A miner replacement is a legitimate governance action that requires no compromise of trusted roles.

**Probability**: MEDIUM to HIGH - While miner replacements may not be frequent, when they do occur, the vulnerability will deterministically trigger for any miner with a stale view, which is highly likely in a distributed network.

### Recommendation

Add a `ContainsKey` check before accessing the dictionary in the loop to match the defensive pattern used elsewhere in the codebase:

```csharp
foreach (var information in providedRound.RealTimeMinersInformation)
{
    if (!RealTimeMinersInformation.ContainsKey(information.Key))
        continue; // Skip miners that don't exist in current round
        
    RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
        information.Value.SupposedOrderOfNextRound;
    RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
        information.Value.FinalOrderOfNextRound;
    RealTimeMinersInformation[information.Key].PreviousInValue =
        information.Value.PreviousInValue;
}
```

This allows the recovery to complete successfully, after which the existing miner replacement validation logic at lines 103-123 can properly verify the replacement against the Election contract. [11](#0-10) 

**Additional Measures**:
1. Add test cases that simulate miner replacement scenarios with stale block headers
2. Consider adding explicit logging when skipping non-existent miners to aid debugging
3. Review similar recovery functions like `RecoverFromTinyBlock` for the same issue [12](#0-11) 

### Proof of Concept

**Initial State**:
- Current round has miners: ["miner1", "miner2", "miner3"]
- Block height: N

**Step 1 - Miner Replacement**:
- Candidate admin for "miner2" calls `ReplaceCandidatePubkey(oldPubkey: "miner2", newPubkey: "miner2_new")`
- Election contract executes the replacement
- Consensus contract's `RecordCandidateReplacement` is invoked, updating state to: ["miner1", "miner2_new", "miner3"]
- Block height: N+1

**Step 2 - Stale Block Production**:
- "miner1" produces block N+2 based on their stale state view (before seeing the replacement)
- Block header contains Round with miners: ["miner1", "miner2", "miner3"]
- Block is broadcast to network

**Step 3 - Validation Failure**:
- Validator node (with current state) receives block N+2
- `ValidateConsensusAfterExecution` is called
- At line 91, `currentRound.RecoverFromUpdateValue(headerInformation.Round, "miner1")` is invoked
- Loop reaches "miner2" entry from header's miner list
- Tries to access `currentRound.RealTimeMinersInformation["miner2"]`
- **Result**: `KeyNotFoundException` thrown - "miner2" doesn't exist in current state
- Block validation fails with exception

**Expected Behavior**: 
The recovery should skip the non-existent key, complete successfully, and allow the hash comparison logic to detect the miner replacement and validate it against the Election contract.

**Actual Behavior**:
Block validation fails with an unhandled exception, rejecting a potentially valid block and disrupting consensus.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L10-12)
```csharp
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L10-10)
```csharp
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L140-146)
```csharp
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-86)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-92)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-123)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
```
