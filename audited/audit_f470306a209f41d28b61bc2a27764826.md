### Title
Infinite Loop DoS in NFT Symbol Generation Due to Static Random Hash

### Summary
The `GenerateSymbolNumber()` function contains a do-while loop that reuses the same `randomHash` on every iteration, causing it to generate identical random numbers repeatedly. When a collision occurs with an existing entry in `State.IsCreatedMap`, the loop cannot exit normally and continues until the execution observer's branch threshold (15,000 iterations) is exceeded, causing transaction failure and denial of service.

### Finding Description

The vulnerability exists in the `GenerateSymbolNumber()` function where the `randomHash` is computed once before entering the do-while loop: [1](#0-0) 

This static hash is then used repeatedly inside the loop to generate a random number: [2](#0-1) 

**Root Cause:** The `Context.ConvertHashToInt64()` method is deterministic - given the same input hash and range parameters, it always returns the same value: [3](#0-2) 

Since `randomHash` never changes within the loop, the same `randomNumber` is generated on every iteration. If this number already exists in `State.IsCreatedMap`, the while condition remains true indefinitely.

**Why Protections Fail:** The check `State.IsCreatedMap[randomNumber]` is intended to prevent symbol collisions, but the implementation fails to regenerate a different random number when a collision is detected. The loop will continue until AElf's execution observer enforces the branch count threshold: [4](#0-3) 

After 15,000 loop iterations (default branch threshold), the transaction fails with `RuntimeBranchThresholdExceededException`.

**Execution Path:** The vulnerable function is called from the public `Create()` method: [5](#0-4) 

### Impact Explanation

**Operational Impact - Denial of Service:**
- Users cannot create NFTs when their randomly generated symbol number collides with an existing entry
- Transaction fails after executing 15,000 wasteful loop iterations
- User loses transaction fees without achieving the intended NFT creation
- Each failed transaction wastes computational resources by performing 15,000 redundant state queries to `State.IsCreatedMap`

**Who is Affected:**
- Any user attempting to create an NFT through the `Create()` method when their generated number collides
- As the number space fills up naturally over time, collision probability increases, affecting more users

**Severity Justification - MEDIUM:**
- **No fund theft or token supply manipulation** - only operational disruption
- **No governance bypass** - only affects NFT creation functionality
- **Deterministic failure** - transaction will always fail when collision occurs
- **Resource waste** - significant computational overhead (15,000 iterations) before failure
- **Increasing likelihood** - probability rises as NFT creation count grows

The number space starts at 900 million possibilities (9-digit minimum length): [6](#0-5) 

However, natural system growth or intentional space exhaustion increases collision likelihood over time.

### Likelihood Explanation

**Reachable Entry Point:** The `Create()` method is publicly accessible without special permissions, only requiring execution on the AELF mainchain: [7](#0-6) 

**Feasible Preconditions:**
- No special attacker capabilities required
- Collision can occur naturally as the system grows
- An attacker could accelerate the issue by creating many NFTs to fill the number space
- Each NFT creation adds one entry to `State.IsCreatedMap`: [8](#0-7) 

**Execution Practicality:**
- The random number generation is deterministic based on sender address and block height
- Once a collision occurs (whether natural or forced), the transaction immediately enters the infinite loop
- No complex multi-step attack sequence required
- Fully executable under AElf's execution model (branch threshold prevents actual infinite execution)

**Probability Reasoning:**
- Initial collision probability is low (1 in 900 million for 9-digit numbers)
- Increases with each NFT created as more numbers are claimed
- Birthday paradox applies - collision likely well before 50% of space is filled
- Attack cost is proportional to number of NFTs needed to create meaningful collision probability

### Recommendation

**Immediate Fix:** Regenerate a new random hash on each loop iteration by incorporating a nonce or iteration counter:

```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    var iteration = 0;
    long randomNumber;
    do
    {
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        
        // Include iteration counter to ensure different hash each time
        var randomHash = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(Context.Sender),
            HashHelper.ComputeFrom(randomBytes),
            HashHelper.ComputeFrom(iteration));
        
        randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        iteration++;
        
        // Add safety limit to prevent excessive loops
        Assert(iteration < 100, "Failed to generate unique symbol number after 100 attempts");
        
    } while (State.IsCreatedMap[randomNumber]);

    return randomNumber;
}
```

**Invariant Checks:**
- Add maximum iteration limit (e.g., 100 attempts) before failing explicitly
- Consider dynamic expansion of number space when utilization exceeds threshold
- Add monitoring/events when multiple retries are needed

**Test Cases:**
- Test collision scenario where IsCreatedMap already contains the generated number
- Verify loop terminates with different number or explicit error
- Test that branch threshold is never reached
- Verify transaction costs remain reasonable even with retries

### Proof of Concept

**Initial State:**
1. NFT contract is initialized on AELF mainchain
2. Several NFTs have already been created, populating `State.IsCreatedMap`

**Attack Sequence:**
1. Attacker or natural system growth fills `State.IsCreatedMap[X]` where X is a specific number
2. Victim calls `Create()` with input that will generate symbol number X
3. `GenerateSymbolNumber()` computes `randomHash` once
4. Loop begins: `Context.ConvertHashToInt64(randomHash, from, from.Mul(10))` returns X
5. Check `State.IsCreatedMap[X]` returns true (already exists)
6. Loop repeats: same `randomHash` produces same number X again
7. Check fails again, loop continues
8. After 15,000 iterations, `ExecutionObserver.BranchCount()` throws `RuntimeBranchThresholdExceededException`
9. Transaction fails, victim loses transaction fees, NFT is not created

**Expected vs Actual Result:**
- **Expected:** Loop should try different random numbers until finding an unused one
- **Actual:** Loop generates the same number indefinitely until branch threshold terminates execution

**Success Condition:** Transaction failure with `RuntimeBranchThresholdExceededException` after exactly 15,000 loop iterations when collision occurs.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L26-27)
```csharp
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L75-77)
```csharp
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L79-82)
```csharp
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L169-177)
```csharp
    public long ConvertHashToInt64(Hash hash, long start = 0, long end = long.MaxValue)
    {
        if (start < 0 || start > end) throw new ArgumentException("Incorrect arguments.");

        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L29-35)
```csharp
    public void BranchCount()
    {
        if (_branchThreshold != -1 && _branchCount == _branchThreshold)
            throw new RuntimeBranchThresholdExceededException(
                $"Contract branch threshold {_branchThreshold} exceeded.");

        _branchCount++;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-17)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L20-20)
```csharp
        var symbol = GetSymbol(input.NftType);
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```
