# Audit Report

## Title
Null Dereference in Profit Distribution Causes DoS When Sub-Scheme Beneficiary Details Are Removed

## Summary
The `DistributeProfitsForSubSchemes` method in the Profit contract accesses `ProfitDetailsMap` without null validation, enabling a permanent DoS condition when sub-scheme profit details are removed via `RemoveBeneficiary` while the sub-scheme remains in the `SubSchemes` list. This creates an irrecoverable state inconsistency that blocks all future profit distributions for the affected scheme.

## Finding Description

The vulnerability exists due to a missing null check when accessing sub-scheme profit details during distribution. [1](#0-0) 

The contract maintains two separate data structures for sub-schemes:
1. The `SubSchemes` list within the `Scheme` object (modified only by `AddSubScheme`/`RemoveSubScheme`)
2. The `ProfitDetailsMap` state mapping (modified by `AddBeneficiary`/`RemoveBeneficiary`)

When `AddSubScheme` is called, both structures are synchronized by adding the sub-scheme to the list and creating profit details via `AddBeneficiary`. [2](#0-1) 

However, the contract allows these structures to become desynchronized through the following attack path:

**Step 1**: During profit distribution, `DistributeProfitsForSubSchemes` updates `LastProfitPeriod` for all sub-scheme details, then increments the scheme's `CurrentPeriod`. [3](#0-2) [4](#0-3) 

**Step 2**: The `ClaimProfits` method allows anyone to claim profits on behalf of any beneficiary address without authorization checks. [5](#0-4)  When claiming profits for a sub-scheme's virtual address, the method updates `LastProfitPeriod` via `ProfitAllPeriods`. [6](#0-5) 

After claiming up to the current period minus one, `LastProfitPeriod` is set to equal `CurrentPeriod` (period + 1), creating the condition where `LastProfitPeriod >= CurrentPeriod`.

**Step 3**: For schemes with `CanRemoveBeneficiaryDirectly = true`, calling `RemoveBeneficiary` on the sub-scheme's virtual address triggers `RemoveProfitDetails`, which selects all non-removed details for removal. [7](#0-6) 

When `LastProfitPeriod >= CurrentPeriod`, the condition at line 346 evaluates to true, causing complete removal of the detail from the list. [8](#0-7) 

If all details are removed, the entire entry is deleted from `ProfitDetailsMap`. [9](#0-8) 

**Step 4**: The next call to `DistributeProfits` iterates over the `SubSchemes` list and attempts to access `ProfitDetailsMap` for each sub-scheme's virtual address. Since the entry was deleted, `subItemDetail` is null, and accessing `subItemDetail.Details` throws a `NullReferenceException`, causing the transaction to fail. [1](#0-0) 

The root cause is that `RemoveBeneficiary` only removes from `ProfitDetailsMap` but does not update the `SubSchemes` list, while `DistributeProfitsForSubSchemes` expects all entries in `SubSchemes` to have corresponding `ProfitDetailsMap` entries.

## Impact Explanation

**Severity: High** - This vulnerability creates a permanent denial-of-service condition with the following impacts:

1. **Permanent Distribution Failure**: Once triggered, the scheme cannot distribute profits in any future period. Every `DistributeProfits` call will revert with a NullReferenceException.

2. **Fund Locking**: All tokens accumulated in the scheme's virtual address become permanently inaccessible to beneficiaries, as distribution is the only mechanism to release these funds.

3. **Cascading Failures**: If the affected scheme is itself a sub-scheme of parent schemes, the DoS propagates upward, potentially disabling critical system schemes like Treasury or TokenHolder profit distribution.

4. **No Recovery Path**: The contract provides no mechanism to repair this inconsistent state without a contract upgrade. The sub-scheme remains in the `SubSchemes` list permanently, causing all future distributions to fail.

5. **Protocol Treasury Impact**: If system-level schemes (Treasury, Economic contract schemes) are affected, the entire protocol's reward distribution mechanism fails, preventing validator rewards, treasury releases, and token holder dividends.

The impact is severe because it affects availability (permanent DoS), fund accessibility (locked tokens), and can cascade to system-critical contracts.

## Likelihood Explanation

**Likelihood: Medium-High** - The vulnerability is feasible under realistic conditions:

**Attacker Capabilities:**
- No special privileges required beyond scheme creation (public operation)
- Alternatively, requires compromised or malicious scheme manager
- Can also occur through accidental API misuse by legitimate operators

**Attack Complexity: Low**
1. Create a scheme with `CanRemoveBeneficiaryDirectly = true` (valid configuration option)
2. Add a sub-scheme via `AddSubScheme` (manager operation)
3. Distribute profits once (manager operation)
4. Call `ClaimProfits` for the sub-scheme's virtual address (public, permissionless)
5. Call `RemoveBeneficiary` instead of `RemoveSubScheme` (manager operation or API confusion)
6. Next distribution triggers the DoS

**Realistic Scenarios:**
1. **API Confusion**: The dual-API design (`RemoveBeneficiary` vs `RemoveSubScheme`) creates operational confusion. A manager intending to remove a sub-scheme might call the wrong method.
2. **Malicious Manager**: A compromised or malicious scheme manager can intentionally trigger this to grief all beneficiaries.
3. **Accidental Triggering**: Complex schemes with multiple sub-schemes increase the likelihood of using the wrong removal API.

**No Existing Protections:**
- No validation prevents calling `RemoveBeneficiary` on sub-scheme virtual addresses
- No check ensures `SubSchemes` and `ProfitDetailsMap` remain synchronized
- `ClaimProfits` has no authorization check, allowing anyone to manipulate `LastProfitPeriod`

The probability is medium-high because while it requires multiple steps, each step is publicly accessible or falls under normal manager operations, and the dual-API design makes accidental triggering likely.

## Recommendation

**Fix 1: Add Null Check in DistributeProfitsForSubSchemes**

Add a null validation before accessing profit details:

```csharp
private long DistributeProfitsForSubSchemes(string symbol, long totalAmount, Scheme scheme, long totalShares)
{
    var remainAmount = totalAmount;
    foreach (var subSchemeShares in scheme.SubSchemes)
    {
        var subItemVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeShares.SchemeId);
        var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
        
        // Add null check
        if (subItemDetail == null || subItemDetail.Details.Count == 0)
        {
            Context.LogDebug(() => $"Sub-scheme {subSchemeShares.SchemeId} has no profit details, skipping.");
            continue;
        }
        
        // ... rest of the method
    }
    return remainAmount;
}
```

**Fix 2: Prevent RemoveBeneficiary on Sub-Scheme Virtual Addresses**

Add validation in `RemoveBeneficiary` to reject removal of sub-scheme beneficiaries:

```csharp
public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
{
    var scheme = State.SchemeInfos[input.SchemeId];
    Assert(scheme != null, "Scheme not found.");
    
    // Check if beneficiary is a sub-scheme virtual address
    var isSubScheme = scheme.SubSchemes.Any(s => 
        Context.ConvertVirtualAddressToContractAddress(s.SchemeId) == input.Beneficiary);
    Assert(!isSubScheme, "Cannot remove sub-scheme via RemoveBeneficiary. Use RemoveSubScheme instead.");
    
    // ... rest of the method
}
```

**Fix 3: Synchronize State in RemoveBeneficiary**

Alternatively, make `RemoveBeneficiary` automatically update `SubSchemes` when removing a sub-scheme virtual address, ensuring both data structures remain synchronized.

The recommended approach is **Fix 1 + Fix 2** together: defensive null checking prevents the DoS, while validation prevents the inconsistent state from occurring in the first place.

## Proof of Concept

```csharp
[Fact]
public async Task SubScheme_RemoveBeneficiary_Causes_Distribution_DoS()
{
    // Setup: Create parent scheme with CanRemoveBeneficiaryDirectly = true
    var parentSchemeId = await CreateScheme(new CreateSchemeInput
    {
        CanRemoveBeneficiaryDirectly = true
    });
    
    // Create and add sub-scheme
    var subSchemeId = await CreateScheme(new CreateSchemeInput());
    await ProfitContractStub.AddSubScheme.SendAsync(new AddSubSchemeInput
    {
        SchemeId = parentSchemeId,
        SubSchemeId = subSchemeId,
        SubSchemeShares = 100
    });
    
    // Distribute profits (period 1)
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = await GetSchemeAddress(parentSchemeId),
        Symbol = "ELF",
        Amount = 1000
    });
    await ProfitContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = parentSchemeId,
        Period = 1,
        AmountsMap = { { "ELF", 1000 } }
    });
    
    // Trigger the vulnerability: Claim profits for sub-scheme virtual address
    var subSchemeVirtualAddress = await GetSchemeAddress(subSchemeId);
    await ProfitContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = parentSchemeId,
        Beneficiary = subSchemeVirtualAddress
    });
    
    // Remove sub-scheme via RemoveBeneficiary (wrong API)
    await ProfitContractStub.RemoveBeneficiary.SendAsync(new RemoveBeneficiaryInput
    {
        SchemeId = parentSchemeId,
        Beneficiary = subSchemeVirtualAddress
    });
    
    // Attempt next distribution - this will throw NullReferenceException
    var result = await ProfitContractStub.DistributeProfits.SendWithExceptionAsync(
        new DistributeProfitsInput
        {
            SchemeId = parentSchemeId,
            Period = 2,
            AmountsMap = { { "ELF", 0 } }
        });
    
    // Verify DoS: Distribution fails with NullReferenceException
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("NullReferenceException");
}
```

**Notes:**
- This vulnerability represents a critical design flaw where two independent state management systems (`SubSchemes` list and `ProfitDetailsMap`) can become desynchronized
- The permissionless nature of `ClaimProfits` for any beneficiary enables manipulation of `LastProfitPeriod`, which is a key enabler for this attack
- The fix requires both defensive programming (null checks) and architectural improvements (preventing state inconsistency)
- This affects any profit scheme with sub-schemes, including system-critical contracts like Treasury and Economic contracts

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L109-125)
```csharp
        AddBeneficiary(new AddBeneficiaryInput
        {
            SchemeId = input.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = subSchemeVirtualAddress,
                Shares = input.SubSchemeShares
            },
            EndPeriod = long.MaxValue
        });

        // Add a sub profit scheme.
        scheme.SubSchemes.Add(new SchemeBeneficiaryShare
        {
            SchemeId = input.SubSchemeId,
            Shares = input.SubSchemeShares
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L346-349)
```csharp
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L376-383)
```csharp
        if (profitDetails.Details.Count != 0)
        {
            State.ProfitDetailsMap[scheme.SchemeId][beneficiary] = profitDetails;
        }
        else
        {
            State.ProfitDetailsMap[scheme.SchemeId].Remove(beneficiary);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L634-635)
```csharp
            var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
            foreach (var detail in subItemDetail.Details) detail.LastProfitPeriod = scheme.CurrentPeriod;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L754-754)
```csharp
        var beneficiary = input.Beneficiary ?? Context.Sender;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L908-917)
```csharp
                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }

            profitsMap.Add(symbol, totalAmount);
        }

        profitDetail.LastProfitPeriod = lastProfitPeriod;
```
