# Audit Report

## Title
Side Chain Miner Count Limit Bypass via Cross-Chain Synchronization

## Summary
Side chains can operate with more active block producers than the governance-configured `MaximumMinersCount` limit due to missing validation in the cross-chain miner list synchronization path. When a side chain receives the main chain's miner list, it stores and uses all miners without checking against its configured limit, allowing all main chain miners to produce blocks regardless of the side chain's `MaximumMinersCount` setting.

## Finding Description

The vulnerability exists in the cross-chain consensus synchronization mechanism for side chains. The security guarantee being broken is: **the number of active block producers should never exceed the governance-approved `MaximumMinersCount` limit**.

**Root Cause 1: Missing validation in cross-chain update**

The `UpdateInformationFromCrossChain` method extracts all miner public keys from the main chain's consensus information and stores them without validation: [1](#0-0) 

There is no check like `Assert(minersKeys.Count <= State.MaximumMinersCount.Value, "Exceeds maximum miners")`.

**Root Cause 2: Unvalidated round generation**

When the side chain detects the miner list has changed, it generates a new term using the entire unvalidated miner list: [2](#0-1) 

The `GenerateFirstRoundOfNewTerm` method creates a `Round` containing ALL miners from the list: [3](#0-2) 

**Root Cause 3: Side chains always use fallback path**

For side chains, `TryToGetVictories` always returns false because it's main-chain only: [4](#0-3) 

This forces side chains to use the unvalidated miner list from the main chain.

**Root Cause 4: Term processing stores unvalidated list**

The `ProcessNextTerm` method creates and stores a `MinerList` from ALL keys in the round without validation: [5](#0-4) 

**Root Cause 5: Validation only checks term/round numbers**

The `ValidationForNextTerm` method validates term and round number increments but does NOT validate the miner count: [6](#0-5) 

**Root Cause 6: Mining permission only checks list membership**

The consensus validation only verifies if a miner is present in `RealTimeMinersInformation`, not whether the total count exceeds the limit: [7](#0-6) 

**The only enforcement of MaximumMinersCount**

The `GetMinersCount` method does enforce the limit using `Math.Min`: [8](#0-7) 

However, this is only used for **reporting** to the Election contract, not for controlling actual consensus operations: [9](#0-8) 

## Impact Explanation

**HIGH Impact - Consensus Integrity and Governance Bypass**

This vulnerability breaks three critical security guarantees:

1. **Consensus Parameter Enforcement**: The `MaximumMinersCount` is a governance-controlled parameter set via Parliament approval. When this limit is bypassed, the side chain operates with a different security model than intended. For example, if governance sets the limit to 17 miners but the main chain has 25 miners, all 25 can produce blocks on the side chain.

2. **Economic Accounting Mismatch**: The Election contract receives the capped count (17) via `UpdateMinersCountToElectionContract`, but 25 miners are actively producing blocks. This creates inconsistency between:
   - The number of miners receiving rewards/dividends
   - The actual number of active block producers
   - The consensus security assumptions

3. **Governance Authority**: The `MaximumMinersCount` setting controlled by Parliament becomes meaningless for side chains, as it can be silently bypassed through normal cross-chain synchronization.

The actual harm includes:
- **Security degradation**: More miners than intended changes block time intervals, reduces individual accountability, and alters the chain's security assumptions
- **Economic impact**: Reward distribution calculations assume the limited count but must accommodate all active miners
- **Trust violation**: Side chain operators and users expect the configured limit to be enforced

## Likelihood Explanation

**HIGH Likelihood - Occurs During Normal Operations**

This vulnerability triggers automatically without any attacker action:

1. **Reachable Entry Point**: The `UpdateInformationFromCrossChain` method is publicly callable by the CrossChain contract during routine cross-chain indexing: [10](#0-9) 

2. **Simple Preconditions**:
   - A side chain exists with `MaximumMinersCount` configured (normal setup)
   - Main chain has more miners than side chain's limit (common scenario as main chains typically have more miners)
   - Cross-chain indexing is functioning (required for normal operation)

3. **Automatic Execution**: This happens during normal cross-chain synchronization:
   - Main chain produces blocks with its full miner set (e.g., 25 miners)
   - CrossChain contract indexes main chain consensus data as part of regular operation
   - Automatically calls `UpdateInformationFromCrossChain` with the full miner list
   - Side chain accepts and uses all miners despite having a limit of 17

4. **No Attack Required**: This is a design flaw, not an exploit. It occurs naturally whenever the main chain's miner count exceeds the side chain's configured `MaximumMinersCount`.

## Recommendation

Add validation in multiple layers to enforce the `MaximumMinersCount` limit:

**Fix 1: Validate in UpdateInformationFromCrossChain**
```csharp
public override Empty UpdateInformationFromCrossChain(BytesValue input)
{
    // ... existing checks ...
    
    var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
    
    // Add validation against MaximumMinersCount
    Assert(minersKeys.Count <= State.MaximumMinersCount.Value, 
        $"Main chain miner count ({minersKeys.Count}) exceeds side chain maximum ({State.MaximumMinersCount.Value})");
    
    State.MainChainCurrentMinerList.Value = new MinerList
    {
        Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
    };
    
    return new Empty();
}
```

**Fix 2: Validate in ValidationForNextTerm**
```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Check term number
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // Add miner count validation
    if (extraData.Round.RealTimeMinersInformation.Count > State.MaximumMinersCount.Value)
        return new ValidationResult { Message = "Miner count exceeds maximum limit." };
    
    return new ValidationResult { Success = true };
}
```

**Fix 3: Limit miner list in GenerateNextRoundInformation for side chains**

When using the main chain miner list, only select up to `MaximumMinersCount` miners (e.g., by taking the first N sorted miners).

## Proof of Concept

The test in `SideChainConsensusInformationTest.cs` demonstrates that side chains accept the full main chain miner list: [11](#0-10) 

To demonstrate the vulnerability, create a test showing:
1. Side chain configured with `MaximumMinersCount = 17`
2. Main chain with 25 miners sends consensus information
3. Side chain accepts and stores all 25 miners
4. All 25 miners can produce blocks on the side chain
5. Election contract only receives count of 17

The existing test confirms miners from main chain are stored without validation - extending it to verify that miners exceeding the limit can still produce blocks would complete the PoC.

---

## Notes

This vulnerability affects the fundamental consensus integrity of side chains. While `MaximumMinersCount` is correctly enforced for main chains through the Election contract's `GetVictories` mechanism, side chains have a completely different code path that bypasses this validation. The discrepancy between the reported count (capped) and actual active miners (uncapped) creates systemic issues in economics and security assumptions. This is a design flaw rather than an implementation bug, requiring architectural changes to properly enforce governance limits on side chains.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L34-38)
```csharp
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L57-61)
```csharp
        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L268-272)
```csharp
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-294)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L386-391)
```csharp
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L23-38)
```csharp
        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L176-176)
```csharp
        UpdateMinersCountToElectionContract(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainConsensusInformationTest.cs (L79-81)
```csharp
        var minerList = await ConsensusStub.GetMainChainCurrentMinerList.CallAsync(new Empty());
        minerList.Pubkeys.Select(m => m.ToHex()).ShouldBe(headerInformation.Round.RealTimeMinersInformation.Keys);

```
