### Title
Continuous Blocks Validation Bypass via Negative RoundNumber in UpdateValue/TinyBlock Behaviors

### Summary
The `ContinuousBlocksValidationProvider` validation can be bypassed by providing a negative `RoundNumber` in the consensus extra data for UpdateValue or TinyBlock behaviors. The check `ProvidedRound.RoundNumber > 2` evaluates to false for negative values, causing the continuous blocks limit validation to be skipped, allowing a miner to produce more consecutive blocks than the maximum allowed threshold. [1](#0-0) 

### Finding Description
The `RoundNumber` field in the `Round` protobuf message is defined as `int64`, which allows negative values to be serialized and parsed without type-level constraints. [2](#0-1) 

The `ProvidedRound` property in `ConsensusValidationContext` exposes the `Round` object from `ExtraData`, which is parsed from the block header without validating that `RoundNumber` is positive. [3](#0-2) 

For UpdateValue and TinyBlock consensus behaviors, no validation provider checks whether `ProvidedRound.RoundNumber` matches the actual current round number stored in state or whether it is positive. [4](#0-3) 

The continuous blocks validation check only runs if `RoundNumber > 2`. When a miner provides a negative `RoundNumber` (e.g., -1), this condition evaluates to false, causing the validation to be skipped entirely. [5](#0-4) 

The continuous blocks counter (`LatestPubkeyToTinyBlocksCount.BlocksCount`) is decremented each time a miner produces a block. When it becomes negative, it indicates the miner has exceeded the maximum continuous blocks threshold. [6](#0-5) 

### Impact Explanation
A malicious miner who has already produced the maximum allowed consecutive blocks can bypass detection by crafting block headers with negative `RoundNumber` values in the consensus extra data. This allows them to:

1. Continue producing blocks beyond the `MaximumTinyBlocksCount` limit without triggering the validation failure that should occur when `BlocksCount < 0`
2. Potentially dominate block production and centralize consensus power
3. Prevent other miners from getting their fair share of block production slots

The impact is limited to consensus fairness and decentralization rather than direct fund theft or total consensus break. The severity is LOW because:
- The attacker must be a valid miner with legitimate mining permissions
- Other time slot and permission validations still apply
- The bypass only affects one specific anti-centralization check
- State integrity is maintained (the actual round state uses `BaseRound`, not `ProvidedRound`) [7](#0-6) 

### Likelihood Explanation
The attack is practically exploitable with moderate likelihood:

**Attacker Capabilities Required:**
- Must be an authorized miner in the current miner list (validated by `MiningPermissionValidationProvider`)
- Must be within their assigned time slot (validated by `TimeSlotValidationProvider`)
- Must have the technical capability to craft custom block headers with modified protobuf data [8](#0-7) 

**Attack Complexity:**
- Low to moderate - requires modifying consensus extra data in block headers
- The protobuf format allows arbitrary int64 values without additional validation
- No cryptographic challenges or complex preconditions beyond being a valid miner

**Detection Constraints:**
- The attack would be observable in block headers (negative RoundNumber values are anomalous)
- However, if the attacker only uses this occasionally, it may not trigger immediate detection
- The behavior is indistinguishable from legitimate early-round blocks (which also skip validation)

**Economic Rationality:**
- An elected miner has economic incentive to maximize their block production and rewards
- The cost is minimal (just crafting modified headers)
- The benefit is increased block production share and associated rewards

### Recommendation

**Primary Fix:** Add explicit validation that `ProvidedRound.RoundNumber` must be positive and should reasonably match the expected round number for UpdateValue and TinyBlock behaviors.

Add a new validation provider or extend an existing one:

```csharp
// In UpdateValueValidationProvider or a new RoundNumberValidationProvider
if (validationContext.ProvidedRound.RoundNumber <= 0)
    return new ValidationResult { Message = "Round number must be positive." };

// Optionally also check it matches the base round for UpdateValue/TinyBlock
if (validationContext.ProvidedRound.RoundNumber != validationContext.BaseRound.RoundNumber)
    return new ValidationResult { Message = "Provided round number does not match current round." };
```

Register this validator for UpdateValue and TinyBlock behaviors in `ValidateBeforeExecution`. [9](#0-8) 

**Alternative Fix:** Remove the `RoundNumber > 2` condition and always perform continuous blocks validation, or replace it with a check based on `CurrentHeight` or `CurrentRoundNumber` from state rather than the untrusted `ProvidedRound.RoundNumber`.

**Test Cases:**
1. Attempt UpdateValue with `RoundNumber = -1` and verify rejection
2. Attempt UpdateValue with `RoundNumber = 0` and verify rejection  
3. Attempt UpdateValue with `RoundNumber != BaseRound.RoundNumber` and verify rejection
4. Verify legitimate UpdateValue with correct positive RoundNumber still succeeds

### Proof of Concept

**Initial State:**
- Miner A is an authorized miner in round 5
- Miner A has produced `MaximumTinyBlocksCount` consecutive blocks
- `LatestPubkeyToTinyBlocksCount.BlocksCount` for Miner A is now negative (e.g., -1)
- Normally, the next block from Miner A should be rejected by `ContinuousBlocksValidationProvider`

**Attack Steps:**
1. Miner A prepares an UpdateValue block with valid signature and consensus information
2. In the consensus extra data, Miner A sets `Round.RoundNumber = -1` (or any negative value)
3. All other fields in the Round are set correctly (miner information, timestamps, etc.)
4. Miner A signs and broadcasts the block

**Expected Result (Current Implementation):**
- `ContinuousBlocksValidationProvider` check: `ProvidedRound.RoundNumber > 2` evaluates to `false`
- Continuous blocks validation is skipped
- Block passes validation despite `BlocksCount < 0`
- Miner A successfully produces another block beyond the limit

**Expected Result (After Fix):**
- New validation catches `ProvidedRound.RoundNumber <= 0`
- Block is rejected with message "Round number must be positive"
- Miner A cannot bypass the continuous blocks limit

**Success Condition:**
The attack succeeds if a block with negative `RoundNumber` in UpdateValue behavior passes validation when the miner has already exceeded the continuous blocks limit (when it should be rejected).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** protobuf/aedpos_contract.proto (L243-245)
```text
message Round {
    // The round number.
    int64 round_number = 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-75)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```
