### Title
Unbounded RPC Amplification in Vote Contract View Methods Enables Resource Exhaustion Attacks

### Summary
The Vote contract's `GetVotingRecords` and `GetVotedItems` view methods lack pagination limits, allowing attackers to request megabytes of data in a single RPC call. Unlike the Election contract which caps queries at 20 records, these methods process unlimited input arrays, enabling low-cost DoS attacks against RPC infrastructure through resource amplification.

### Finding Description

The Vote contract exposes two view methods without pagination controls:

**1. GetVotingRecords - Unbounded Batch Query** [1](#0-0) 

This method accepts an unbounded array of vote IDs and retrieves all corresponding records without any limit validation. The input type allows unlimited IDs: [2](#0-1) 

Each `VotingRecord` returned contains substantial data including timestamps, addresses, amounts, and option strings up to 1024 bytes: [3](#0-2) 

**2. GetVotedItems - Unbounded Voter History** [4](#0-3) 

This method returns all vote IDs for a given voter across all voting items without pagination. The `VotedItems` structure contains unbounded maps: [5](#0-4) 

**Root Cause:**
No maximum count validation exists before processing input arrays or returning accumulated state data.

**Comparison with Secure Implementation:**

The Election contract demonstrates proper pagination with enforced limits: [6](#0-5) 

Note line 248 enforces a hard cap: `Math.Min(Math.Min(input.Length, 20), ...)` - limiting responses to maximum 20 records regardless of request size. The Vote contract has no such protection.

### Impact Explanation

**Concrete Harm:**
- **Resource Exhaustion DoS**: Attacker sends 1 KB request with 10,000 vote IDs → Node must load, deserialize, and serialize 2-13 MB response (200-1300 bytes per VotingRecord depending on option string length)
- **RPC Infrastructure Degradation**: Sustained attacks exhaust CPU, memory, disk I/O, and bandwidth on public RPC nodes
- **Legitimate User Impact**: Service degradation affects all users relying on RPC endpoints for dApp functionality
- **Attack Cost Asymmetry**: Minimal attacker bandwidth (repeated small requests) vs massive defender cost (repeated large responses)

**Quantified Amplification:**
- Request: ~32 bytes per Hash × 10,000 = 320 KB
- Response: ~200-1300 bytes per record × 10,000 = 2-13 MB
- Amplification factor: 6x to 40x

**Affected Parties:**
- RPC node operators facing infrastructure costs and potential downtime
- dApp users experiencing slow/failed queries
- Chain ecosystem suffering from degraded accessibility

**Severity Justification:**
HIGH - Enables practical DoS attacks with asymmetric cost structure against critical infrastructure without authentication requirements.

### Likelihood Explanation

**Attacker Capabilities:**
- No special privileges required - view methods are publicly accessible
- Vote IDs easily discoverable from blockchain events or state enumeration
- Standard RPC client sufficient for exploitation

**Attack Complexity:**
- Low - Single RPC call with large ID array
- Scriptable and automatable
- No transaction fees for view calls

**Feasibility Conditions:**
- Active voting items with accumulated votes (normal operation)
- Public RPC endpoints accepting queries (standard deployment)
- No rate limiting on view method calls (typical configuration)

**Detection Constraints:**
- Difficult to distinguish from legitimate bulk queries
- View calls generate minimal on-chain traces
- Can be distributed across multiple endpoints/addresses

**Probability Reasoning:**
HIGH - All preconditions exist in normal operation, attack mechanics are straightforward, and economic incentives favor attackers (minimal cost for disruption).

### Recommendation

**1. Implement Pagination with Hard Limits:**

Add pagination to `GetVotingRecords`:
```csharp
public override VotingRecords GetVotingRecords(GetVotingRecordsInput input)
{
    const int MaxRecordsPerQuery = 20; // Match Election contract standard
    var votingRecords = new VotingRecords();
    var limitedIds = input.Ids.Take(MaxRecordsPerQuery);
    votingRecords.Records.AddRange(limitedIds.Select(id => State.VotingRecords[id]));
    return votingRecords;
}
```

**2. Add Paginated Alternative for GetVotedItems:**

Create new method with PageInformation input:
```csharp
public override VotedItems GetPageableVotedItems(GetPageableVotedItemsInput input)
{
    const int MaxItemsPerQuery = 20;
    var allItems = State.VotedItemsMap[input.Voter] ?? new VotedItems();
    var result = new VotedItems();
    
    foreach (var item in allItems.VotedItemVoteIds.Skip(input.Start).Take(MaxItemsPerQuery))
    {
        result.VotedItemVoteIds.Add(item.Key, item.Value);
    }
    return result;
}
```

**3. Update Protobuf Definitions:**

Add PageInformation input (follow Election contract pattern): [7](#0-6) 

**4. Regression Testing:**
- Test queries with 1, 20, 100, 10000 IDs
- Verify maximum 20 records returned
- Benchmark response sizes
- Load test RPC endpoints under pagination limits

### Proof of Concept

**Initial State:**
- 10,000 voting records exist on-chain from normal voting activity
- Each VotingRecord has 500-byte average size
- Public RPC endpoint accepts view queries

**Attack Steps:**

1. **Reconnaissance**: Query recent `Voted` events to collect vote IDs
   ```
   Events: Voted(vote_id=0x1234..., ...) × 10,000
   ```

2. **Craft Malicious Request**:
   ```
   GetVotingRecords({
     ids: [0x1234..., 0x5678..., ... (10,000 hashes)]
   })
   Request size: ~320 KB
   ```

3. **RPC Node Processing**:
   - Deserialize 10,000 Hash values
   - Load 10,000 VotingRecords from state storage
   - Serialize 10,000 VotingRecords to protobuf
   - Response size: ~5 MB

4. **Amplification Result**:
   - Input: 320 KB
   - Output: 5 MB
   - Factor: 15.6x amplification

5. **Sustained Attack**:
   - Repeat request 100 times over 10 seconds
   - Total bandwidth consumed: 500 MB outbound
   - RPC node CPU/memory exhausted
   - Legitimate queries delayed or timeout

**Success Condition:**
RPC response size exceeds 1 MB for queries under 1 MB input, demonstrating exploitable amplification. Node resource consumption (CPU/memory/bandwidth) increases linearly with attacker request rate while defender costs far exceed attacker costs.

### Notes

This vulnerability exists because the Vote contract was implemented without the pagination pattern established in the Election contract. The Election contract's `GetPageableCandidateInformation` method demonstrates the correct approach with enforced maximum record counts. The Vote contract should adopt the same defensive pattern to prevent resource exhaustion attacks while maintaining necessary query functionality through paginated access.

### Citations

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L8-13)
```csharp
    public override VotingRecords GetVotingRecords(GetVotingRecordsInput input)
    {
        var votingRecords = new VotingRecords();
        votingRecords.Records.AddRange(input.Ids.Select(id => State.VotingRecords[id]));
        return votingRecords;
    }
```

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L15-18)
```csharp
    public override VotedItems GetVotedItems(Address input)
    {
        return State.VotedItemsMap[input] ?? new VotedItems();
    }
```

**File:** protobuf/vote_contract.proto (L186-205)
```text
message VotingRecord {
    // The voting activity id.
    aelf.Hash voting_item_id = 1;
    // The address of voter.
    aelf.Address voter = 2;
    // The snapshot number.
    int64 snapshot_number = 3;
    // The amount of vote.
    int64 amount = 4;
    // The time of withdraw.
    google.protobuf.Timestamp withdraw_timestamp = 5;
    // The time of vote.
    google.protobuf.Timestamp vote_timestamp = 6;
    // Whether the vote had been withdrawn.
    bool is_withdrawn = 7;
    // The option voted.
    string option = 8;
    // Whether vote others.
    bool is_change_target = 9;
}
```

**File:** protobuf/vote_contract.proto (L235-245)
```text
message VotedItems {
    // The voted ids.
    map<string, VotedIds> voted_item_vote_ids = 1;
}

message VotedIds {
    // The active vote ids.
    repeated aelf.Hash active_votes = 1;
    // The withdrawn vote ids.
    repeated aelf.Hash withdrawn_votes = 2;
}
```

**File:** protobuf/vote_contract.proto (L259-262)
```text
message GetVotingRecordsInput {
    // The vote ids.
    repeated aelf.Hash ids = 1;
}
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L240-258)
```csharp
    public override GetPageableCandidateInformationOutput GetPageableCandidateInformation(PageInformation input)
    {
        var output = new GetPageableCandidateInformationOutput();
        var candidates = State.Candidates.Value;

        var count = candidates.Value.Count;
        if (count <= input.Start) return output;

        var length = Math.Min(Math.Min(input.Length, 20), candidates.Value.Count.Sub(input.Start));
        foreach (var candidate in candidates.Value.Skip(input.Start).Take(length))
            output.Value.Add(new CandidateDetail
            {
                CandidateInformation = State.CandidateInformationMap[candidate.ToHex()],
                ObtainedVotesAmount = GetCandidateVote(new StringValue { Value = candidate.ToHex() })
                    .ObtainedActiveVotedVotesAmount
            });

        return output;
    }
```

**File:** protobuf/election_contract.proto (L416-421)
```text
message PageInformation {
    // The start index.
    int32 start = 1;
    // The number of records.
    int32 length = 2;
}
```
