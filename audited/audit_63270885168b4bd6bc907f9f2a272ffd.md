### Title
Lock/Unlock Whitelist Bypass via Non-Whitelisted System Contracts

### Summary
The `AssertSystemContractOrLockWhiteListAddress` authority check in Lock/Unlock functions allows ANY system contract to lock tokens when `Context.Origin` equals the address being locked, effectively bypassing the token-specific lock whitelist. This violates the token creator's access control policy and allows non-whitelisted system contracts to lock user tokens when users call those contracts.

### Finding Description

The vulnerability exists in the `Lock` and `Unlock` methods' authority validation logic. [1](#0-0) 

The first authorization check uses `AssertSystemContractOrLockWhiteListAddress` which employs OR logic: [2](#0-1) 

This function passes if `Context.Sender` is EITHER in the token-specific whitelist (`State.LockWhiteLists[symbol]`) OR is ANY system contract from `Context.GetSystemContractNameToAddressMapping()`. 

The second check allows passage if the sender is Election/Vote contracts OR if `Context.Origin == input.Address`. [3](#0-2) 

**Root Cause**: The combination of these two checks means ANY system contract (even if not in the token's lock whitelist) can lock/unlock tokens when the user initiates the transaction. The token-specific whitelist set during token creation [4](#0-3)  becomes effectively meaningless for non-whitelisted system contracts in self-locking scenarios.

**Execution Path**:
1. Token creator creates token with `LockWhiteList = [TreasuryContract, ProfitContract]`
2. User calls a different system contract (e.g., TokenHolder or any other system contract not in whitelist)
3. That system contract calls `Token.Lock(user_address, amount, symbol)`
4. Check 1: System contract IS a system contract → PASS (bypassing whitelist check)
5. Check 2: `Context.Origin` (user) == `input.Address` (user) → PASS
6. User's tokens get locked by non-whitelisted contract

### Impact Explanation

**Auth/Governance Impact**: Token creators explicitly specify a lock whitelist during token creation, intending to restrict which contracts can lock their tokens. This vulnerability allows ANY system contract to bypass this access control when users self-lock tokens through those contracts.

**Operational Impact**: Users' tokens can be locked by contracts the token creator did not authorize, potentially:
- Disrupting token utility if incompatible with certain locking mechanisms
- Enabling unexpected protocol interactions
- Violating business logic constraints the token creator intended

**Affected Parties**: 
- Token creators who specify restricted lock whitelists expecting enforcement
- Token holders whose tokens can be locked by non-whitelisted system contracts
- Protocols integrating tokens expecting whitelist enforcement

**Severity**: The whitelist validation during token creation [4](#0-3)  ensures only system contracts can be whitelisted, suggesting the design intends strict access control. This vulnerability undermines that control mechanism.

### Likelihood Explanation

**Reachable Entry Point**: Yes - `Lock` and `Unlock` are public methods. [5](#0-4) 

**Feasible Preconditions**:
- A system contract exists that calls Lock/Unlock (verified: Election, Vote, TokenHolder contracts do this) [6](#0-5) 
- User calls that system contract to lock tokens
- The system contract is NOT in the token's specific lock whitelist

**Execution Practicality**: High - The test suite demonstrates BasicFunctionContract (a system contract) locking tokens when in the whitelist. [7](#0-6)  The same mechanism works for non-whitelisted system contracts due to the OR logic flaw.

**Attack Complexity**: Low - No special exploit required; normal system contract usage triggers the bypass.

**Probability**: Moderate to High depending on token design choices and system contract ecosystem usage patterns.

### Recommendation

**Code-Level Mitigation**: Modify `AssertSystemContractOrLockWhiteListAddress` to ONLY check the token-specific whitelist, removing the blanket system contract bypass:

```csharp
private void AssertSystemContractOrLockWhiteListAddress(string symbol)
{
    var symbolState = State.LockWhiteLists[symbol];
    var isInWhiteList = symbolState != null && symbolState[Context.Sender];
    Assert(isInWhiteList, "No Permission.");
}
```

This ensures only explicitly whitelisted contracts can lock tokens, enforcing the token creator's intent.

**Alternative**: If system contract privilege is intentional, remove the token-specific whitelist mechanism entirely to avoid confusion. However, the validation during token creation suggests whitelists should be enforced.

**Invariant Check**: Add test cases verifying that non-whitelisted system contracts CANNOT lock tokens even when `Context.Origin` equals `input.Address`, ensuring whitelist enforcement is consistent.

### Proof of Concept

**Initial State**:
- Create token "CUSTOM" with `LockWhiteList = [TreasuryContractAddress]` only
- User holds 1000 CUSTOM tokens
- ProfitContract is a system contract but NOT in CUSTOM's whitelist

**Attack Steps**:
1. User calls `ProfitContract.RegisterForProfits()` with CUSTOM tokens
2. ProfitContract internally calls `TokenContract.Lock(user_address, 1000, "CUSTOM", lockId)`
3. Execution reaches `AssertSystemContractOrLockWhiteListAddress("CUSTOM")`:
   - `Context.Sender` = ProfitContract
   - ProfitContract NOT in `State.LockWhiteLists["CUSTOM"]`
   - But ProfitContract IS in `Context.GetSystemContractNameToAddressMapping()`
   - Check PASSES via OR logic
4. Second check: `Context.Origin` (user) == `input.Address` (user) → PASSES
5. 1000 CUSTOM tokens locked by non-whitelisted ProfitContract

**Expected Result**: Lock should FAIL with "No Permission" since ProfitContract is not in CUSTOM's lock whitelist.

**Actual Result**: Lock SUCCEEDS, bypassing the token creator's access control policy.

**Success Condition**: User's CUSTOM tokens are locked in ProfitContract's virtual address despite ProfitContract not being in the token's intended lock whitelist.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L95-98)
```csharp
        var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Select(m => m.Value);
        var isSystemContractAddress = input.LockWhiteList.All(l => systemContractAddresses.Contains(l));
        Assert(isSystemContractAddress, "Addresses in lock white list should be system contract addresses");
        foreach (var address in input.LockWhiteList) State.LockWhiteLists[input.Symbol][address] = true;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L195-222)
```csharp
    public override Empty Lock(LockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Lock behaviour should be initialed by origin address.");

        var allowance = State.Allowances[input.Address][Context.Sender][input.Symbol];
        if (allowance >= input.Amount)
            State.Allowances[input.Address][Context.Sender][input.Symbol] = allowance.Sub(input.Amount);
        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
        DealWithExternalInfoDuringLocking(new TransferFromInput
        {
            From = input.Address,
            To = virtualAddress,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L196-203)
```csharp
    private void AssertSystemContractOrLockWhiteListAddress(string symbol)
    {
        var symbolState = State.LockWhiteLists[symbol];
        var isInWhiteList = symbolState != null && symbolState[Context.Sender];
        var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Values;
        var isSystemContractAddress = systemContractAddresses.Contains(Context.Sender);
        Assert(isInWhiteList || isSystemContractAddress, "No Permission.");
    }
```

**File:** protobuf/token_contract.proto (L51-57)
```text
    // This method can be used to lock tokens.
    rpc Lock (LockInput) returns (google.protobuf.Empty) {
    }

    // This is the reverse operation of locking, it un-locks some previously locked tokens.
    rpc Unlock (UnlockInput) returns (google.protobuf.Empty) {
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L328-338)
```csharp
    private void LockTokensOfVoter(long amount, Hash voteId)
    {
        State.TokenContract.Lock.Send(new LockInput
        {
            Address = Context.Sender,
            Symbol = Context.Variables.NativeSymbol,
            LockId = voteId,
            Amount = amount,
            Usage = "Voting for Main Chain Miner Election."
        });
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenApplicationTests.cs (L958-988)
```csharp
    private async Task CreateTokenAndIssue(List<Address> whitelist = null, Address issueTo = null)
    {
        if (whitelist == null)
            whitelist = new List<Address>
            {
                BasicFunctionContractAddress,
                OtherBasicFunctionContractAddress,
                TreasuryContractAddress
            };
        await CreateMutiTokenAsync(TokenContractStub,new CreateInput
        {
            Symbol = SymbolForTest,
            Decimals = 2,
            IsBurnable = true,
            Issuer = DefaultAddress,
            Owner = DefaultAddress,
            TokenName = "elf test token",
            TotalSupply = DPoSContractConsts.LockTokenForElection * 1000000,
            LockWhiteList =
            {
                whitelist
            }
        });
        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Symbol = SymbolForTest,
            Amount = DPoSContractConsts.LockTokenForElection * 200000,
            To = issueTo == null ? DefaultAddress : issueTo,
            Memo = "Issue"
        });
    }
```
