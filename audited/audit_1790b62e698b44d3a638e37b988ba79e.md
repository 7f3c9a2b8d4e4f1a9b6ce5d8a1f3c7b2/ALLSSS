# Audit Report

## Title
Incomplete Validation Allows Null MerklePath Indexing Leading to Permanent Cross-Chain Verification DoS

## Summary
The `ValidateParentChainBlockData` function in the CrossChain contract fails to validate that MerklePath values are non-null before indexing, allowing invalid parent chain data to be stored. This creates an irreversible inconsistent state where cross-chain verification queries permanently fail for affected side chain heights.

## Finding Description

The vulnerability exists in the validation logic that processes parent chain block data proposals. [1](#0-0) 

The validation checks whether heights are already indexed (lines 731-734) but **never validates that the proposed MerklePath values (`indexedBlockInfo.Value`) are non-null**. It only verifies that the key (height) isn't already bound in storage.

When validated data gets indexed, the system calls: [2](#0-1) 

The `AddIndexedTxRootMerklePathInParentChain` function accepts null values without validation: [3](#0-2) 

If `path` is null, the assertion at line 55-56 passes (since `existing` is also null for new entries) and stores the null value at line 57. This creates inconsistent state where `ChildHeightToParentChainHeight` contains a non-zero parent chain height but `TxRootMerklePathInParentChain` contains null for the same side chain height.

Later, when querying this data: [4](#0-3) 

The assertion at line 24 fails because `merklePath` is null, causing all queries for that height to revert permanently.

The attack flow requires a miner to propose invalid data: [5](#0-4) 

And then release it after governance approval: [6](#0-5) 

## Impact Explanation

**Permanent Cross-Chain Verification DoS:**
- The `GetBoundParentChainHeightAndMerklePathByHeight` function becomes permanently unavailable for affected side chain heights
- Side chains cannot retrieve merkle paths needed to prove their blocks were indexed on the parent chain
- Cross-chain transaction verification is completely broken for affected heights

**Irreversibility:**
The damage is permanent because the validation at lines 731-734 prevents re-indexing any height where `ChildHeightToParentChainHeight[height] != 0`. Once a height is bound (even with null merkle path), it cannot be corrected through normal mechanisms. Manual state intervention would be required.

**Scope:**
This affects the core cross-chain infrastructure, breaking the trust and verification mechanism between parent and side chains. A single malicious proposal could compromise multiple side chain heights simultaneously.

## Likelihood Explanation

**Required Capabilities:**
- Attacker must be an authorized miner [7](#0-6) 
- Must obtain Parliament governance approval [8](#0-7) 

**Attack Complexity:**
Low - the attacker simply crafts a `ParentChainBlockData` message with null MerklePath values in the `IndexedMerklePath` map. The protobuf definition allows this: [9](#0-8) 

**Feasibility:**
While requiring miner access and governance approval creates barriers, the governance proposal only contains the chain ID [10](#0-9) , not the raw block data. Reviewers would need to inspect the actual `ParentChainBlockData` stored in contract state to detect null merkle paths, which may not be part of standard review procedures.

**Assessment:**
Medium-Low likelihood due to dual permission requirements, but the severe permanent impact and exploitability of the validation gap make this a critical vulnerability.

## Recommendation

Add explicit validation that MerklePath values are non-null in `ValidateParentChainBlockData`:

```csharp
if (blockData.IndexedMerklePath.Any(indexedBlockInfo =>
        indexedBlockInfo.Value == null || // ADD THIS CHECK
        State.ChildHeightToParentChainHeight[indexedBlockInfo.Key] != 0 ||
        State.TxRootMerklePathInParentChain[indexedBlockInfo.Key] != null))
    return false;
```

Additionally, add validation in `AddIndexedTxRootMerklePathInParentChain`:

```csharp
private void AddIndexedTxRootMerklePathInParentChain(long height, MerklePath path)
{
    Assert(path != null, "Merkle path cannot be null."); // ADD THIS CHECK
    var existing = State.TxRootMerklePathInParentChain[height];
    Assert(existing == null, $"Merkle path already bound at height {height}.");
    State.TxRootMerklePathInParentChain[height] = path;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task NullMerklePathIndexing_ShouldCausPermanentDoS()
{
    // Setup: Initialize cross-chain contract with miner permission
    var miner = Accounts[0].Address;
    
    // Step 1: Malicious miner proposes parent chain data with NULL merkle path
    var parentChainBlockData = new ParentChainBlockData
    {
        Height = 100,
        ChainId = ParentChainId,
        TransactionStatusMerkleTreeRoot = HashHelper.ComputeFrom("valid_root"),
        IndexedMerklePath = 
        {
            { 50, null } // NULL merkle path for side chain height 50
        }
    };
    
    var crossChainBlockData = new CrossChainBlockData
    {
        ParentChainBlockDataList = { parentChainBlockData }
    };
    
    // Step 2: Miner proposes (validation SHOULD reject but doesn't due to bug)
    await CrossChainContractStub.ProposeCrossChainIndexing.SendAsync(crossChainBlockData);
    
    // Step 3: Parliament approves proposal (can't see raw data contains null)
    // [Approval logic here]
    
    // Step 4: Miner releases approved proposal
    await CrossChainContractStub.ReleaseCrossChainIndexingProposal.SendAsync(
        new ReleaseCrossChainIndexingProposalInput { ChainIdList = { ParentChainId } });
    
    // Step 5: Query for indexed data - PERMANENT FAILURE
    var result = await CrossChainContractStub.GetBoundParentChainHeightAndMerklePathByHeight
        .CallAsync(new Int64Value { Value = 50 });
    
    // Assert: Query reverts with "merklePath != null" assertion failure
    // State is permanently corrupted - height 50 cannot be re-indexed
}
```

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L52-58)
```csharp
    private void AddIndexedTxRootMerklePathInParentChain(long height, MerklePath path)
    {
        var existing = State.TxRootMerklePathInParentChain[height];
        Assert(existing == null,
            $"Merkle path already bound at height {height}.");
        State.TxRootMerklePathInParentChain[height] = path;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L398-414)
```csharp
            var proposalCreationInput = new CreateProposalBySystemContractInput
            {
                ProposalInput = new CreateProposalInput
                {
                    Params = new AcceptCrossChainIndexingProposalInput
                    {
                        ChainId = chainId
                    }.ToByteString(),
                    ContractMethodName = nameof(AcceptCrossChainIndexingProposal),
                    ExpiredTime =
                        Context.CurrentBlockTime.AddSeconds(CrossChainIndexingProposalExpirationTimePeriod),
                    OrganizationAddress = crossChainIndexingController.OwnerAddress,
                    ToAddress = Context.Self,
                    Token = proposalToken
                },
                OriginProposer = Context.Sender
            };
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L455-463)
```csharp
    private void HandleIndexingProposal(Hash proposalId)
    {
        var crossChainIndexingController = GetCrossChainIndexingController();
        var proposal = GetCrossChainProposal(crossChainIndexingController, proposalId);
        Assert(proposal.ToBeReleased, "Not approved cross chain indexing proposal.");
        Context.SendInline(crossChainIndexingController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release),
            proposal.ProposalId); // release if ready
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L720-743)
```csharp
    private bool ValidateParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData,
        out Dictionary<int, List<ParentChainBlockData>> validatedParentChainBlockData)
    {
        var parentChainId = State.ParentChainId.Value;
        var currentHeight = State.CurrentParentChainHeight.Value;
        validatedParentChainBlockData = new Dictionary<int, List<ParentChainBlockData>>();
        foreach (var blockData in parentChainBlockData)
        {
            if (parentChainId != blockData.ChainId || currentHeight + 1 != blockData.Height ||
                blockData.TransactionStatusMerkleTreeRoot == null)
                return false;
            if (blockData.IndexedMerklePath.Any(indexedBlockInfo =>
                    State.ChildHeightToParentChainHeight[indexedBlockInfo.Key] != 0 ||
                    State.TxRootMerklePathInParentChain[indexedBlockInfo.Key] != null))
                return false;

            currentHeight += 1;
        }

        if (parentChainBlockData.Count > 0)
            validatedParentChainBlockData[parentChainId] = parentChainBlockData.ToList();

        return true;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L776-780)
```csharp
            foreach (var indexedBlockInfo in blockInfo.IndexedMerklePath)
            {
                BindParentChainHeight(indexedBlockInfo.Key, parentChainHeight);
                AddIndexedTxRootMerklePathInParentChain(indexedBlockInfo.Key, indexedBlockInfo.Value);
            }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L19-30)
```csharp
    public override CrossChainMerkleProofContext GetBoundParentChainHeightAndMerklePathByHeight(Int64Value input)
    {
        var boundParentChainHeight = State.ChildHeightToParentChainHeight[input.Value];
        Assert(boundParentChainHeight != 0);
        var merklePath = State.TxRootMerklePathInParentChain[input.Value];
        Assert(merklePath != null);
        return new CrossChainMerkleProofContext
        {
            MerklePathFromParentChain = merklePath,
            BoundParentChainHeight = boundParentChainHeight
        };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-291)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```

**File:** protobuf/acs7.proto (L109-122)
```text
message ParentChainBlockData {
    // The height of parent chain.
    int64 height = 1;
    // The merkle tree root computing from side chain roots.
    CrossChainExtraData cross_chain_extra_data = 2;
    // The parent chain id.
    int32 chain_id = 3;
    // The merkle tree root computing from transactions status in parent chain block.
    aelf.Hash transaction_status_merkle_tree_root = 4;
    // Indexed block height from side chain and merkle path for this side chain block
    map<int64, aelf.MerklePath> indexed_merkle_path = 5;
    // Extra data map.
    map<string, bytes> extra_data = 6;
}
```
