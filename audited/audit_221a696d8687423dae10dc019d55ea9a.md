# Audit Report

## Title
User Contract Authorization Bypass via isUserContract Flag Manipulation During Updates

## Summary
User contract authors can permanently downgrade the authorization requirements for contract updates by using `ProposeUpdateContract` instead of `UpdateUserSmartContract`. This flips the `isUserContract` flag from `true` to `false`, bypassing the miner-based approval requirement and allowing future updates through Parliament governance alone.

## Finding Description

The AElf Genesis contract (BasicContractZero) maintains two distinct update paths for contracts: a stricter miner-approved path for user contracts and a Parliament-governed path for regular contracts. The vulnerability exists because `ProposeUpdateContract` fails to preserve or validate the `isUserContract` flag, allowing user contract authors to silently switch their contract's governance model.

**Root Cause Analysis:**

When `ProposeUpdateContract` is invoked, it only validates that the sender is the contract author [1](#0-0)  and preserves the `IsSystemContract` flag [2](#0-1) , but makes no attempt to preserve or validate the `IsUserContract` flag. The method routes to `UpdateSmartContract` via the `CodeCheckReleaseMethod` parameter [3](#0-2) .

The public `UpdateSmartContract` method then calls the private helper with `isUserContract` hardcoded to `false` [4](#0-3) , regardless of the original contract type.

The private helper unconditionally overwrites the flag [5](#0-4) , permanently changing the contract from user-type to regular-type.

**Bypass Mechanism:**

The authorization model differs fundamentally between the two paths:

- **User Contract Path** (`UpdateUserSmartContract` → `ReleaseApprovedUserSmartContract`): Requires miner authorization via `AssertCurrentMiner()` [6](#0-5) , ensuring only current miners can release updates.

- **Regular Contract Path** (`ProposeUpdateContract` → `ReleaseCodeCheckedContract`): Only validates proposer identity [7](#0-6)  with no miner requirement.

Once the flag is flipped, the `PerformUpdateUserSmartContract` path becomes inaccessible as the contract is no longer recognized as a user contract, and all future updates follow the Parliament-only approval path.

## Impact Explanation

This vulnerability breaks the security invariant that contract types should remain immutable after deployment. User contracts are specifically designed with stricter authorization requirements to provide additional security guarantees to contract users.

**Concrete Impact:**

1. **Governance Model Downgrade**: User contracts deployed with miner-based governance can be unilaterally switched to Parliament-only governance by their authors, weakening the security model without stakeholder awareness.

2. **Stakeholder Trust Violation**: Users who deployed or interact with contracts expecting miner-level security guarantees are unknowingly exposed to reduced protection.

3. **Protocol Integrity**: The ability to mutate contract types violates the design principle that contract classifications are permanent, undermining the protocol's governance architecture.

The comparison between update paths shows the critical difference: `PerformUpdateUserSmartContract` maintains `isUserContract = true` [8](#0-7) , while the regular path forces it to `false`, and there is no validation preventing user contracts from taking the wrong path.

## Likelihood Explanation

**Attack Prerequisites:**
- Attacker must be the author of a user contract (achievable by deploying one)
- Parliament approval required (standard governance process for any contract update)

**Execution Complexity:** Low - The attack requires only calling `ProposeUpdateContract` instead of `UpdateUserSmartContract`. Both are public methods accessible to contract authors with identical authorization checks [9](#0-8) .

**Detection:** The flag change occurs silently in storage without events or validation that would alert stakeholders to the governance model change.

**Feasibility:** High - Any motivated contract author can execute this with minimal effort once Parliament approval is obtained, which is required for legitimate updates anyway.

## Recommendation

Add validation to `ProposeUpdateContract` to prevent user contracts from using this update path:

```csharp
public override Hash ProposeUpdateContract(ContractUpdateInput input)
{
    var proposedContractInputHash = CalculateHashFromInput(input);
    RegisterContractProposingData(proposedContractInputHash);

    var contractAddress = input.Address;
    var info = State.ContractInfos[contractAddress];
    Assert(info != null, "Contract not found.");
    AssertAuthorityByContractInfo(info, Context.Sender);
    
    // Add validation to prevent user contracts from using this path
    Assert(!info.IsUserContract, "User contracts must use UpdateUserSmartContract.");
    
    AssertContractVersion(info.ContractVersion, input.Code, info.Category);
    // ... rest of method
}
```

Additionally, preserve the `IsUserContract` flag in the `ContractCodeCheckInput`:

```csharp
Params = new ContractCodeCheckInput
{
    ContractInput = input.ToByteString(),
    CodeCheckReleaseMethod = nameof(UpdateSmartContract),
    ProposedContractInputHash = proposedContractInputHash,
    Category = info.Category,
    IsSystemContract = info.IsSystemContract,
    IsUserContract = info.IsUserContract  // Preserve user contract flag
}.ToByteString(),
```

And validate in `UpdateSmartContract` that the flag is not being changed inappropriately.

## Proof of Concept

```csharp
// Deploy user contract with IsUserContract = true
var userDeployInput = new UserContractDeploymentInput
{
    Category = 0,
    Code = ByteString.CopyFrom(contractCode)
};
var deployResult = await DeployUserSmartContract(userDeployInput);
var contractAddress = deployResult.Address;

// Verify IsUserContract = true
var info1 = await GetContractInfo(contractAddress);
Assert(info1.IsUserContract == true, "Should be user contract");

// Author calls ProposeUpdateContract instead of UpdateUserSmartContract
var updateInput = new ContractUpdateInput
{
    Address = contractAddress,
    Code = ByteString.CopyFrom(updatedCode)
};
await ProposeUpdateContract(updateInput);
// ... obtain Parliament approval and code check ...
await ReleaseCodeCheckedContract(proposalId);

// Verify IsUserContract is now false
var info2 = await GetContractInfo(contractAddress);
Assert(info2.IsUserContract == false, "Flag was flipped!");

// Future updates now bypass miner approval
// Can use ReleaseCodeCheckedContract without AssertCurrentMiner()
```

**Notes**

This vulnerability demonstrates a critical gap in contract type immutability enforcement. The separation of concerns between `IsSystemContract` preservation and `IsUserContract` handling reveals an incomplete security model. The test suite validates that user contracts maintain their flag through the correct update path [10](#0-9) , but no tests validate prevention of the bypass path. The authorization check [9](#0-8)  correctly validates authorship but is insufficient to maintain contract type integrity across update paths.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L183-183)
```csharp
        AssertAuthorityByContractInfo(info, Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L212-212)
```csharp
                    CodeCheckReleaseMethod = nameof(UpdateSmartContract),
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L215-215)
```csharp
                    IsSystemContract = info.IsSystemContract
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L292-306)
```csharp
    public override Empty ReleaseCodeCheckedContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];

        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.CodeCheckProposed &&
            contractProposingInput.Proposer == Context.Sender, "Invalid contract proposing status.");
        contractProposingInput.Status = ContractProposingInputStatus.CodeChecked;
        State.ContractProposingInputMap[input.ProposedContractInputHash] = contractProposingInput;
        var codeCheckController = State.CodeCheckController.Value;
        Context.SendInline(codeCheckController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release), input.ProposalId);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L334-334)
```csharp
        UpdateSmartContract(contractAddress, input.Code.ToByteArray(), info.Author, false);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L485-485)
```csharp
        AssertCurrentMiner();
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L514-514)
```csharp
        UpdateSmartContract(input.Address, input.Code.ToByteArray(), proposingInput.Author, true);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L110-110)
```csharp
        info.IsUserContract = isUserContract;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L1812-1812)
```csharp
        contractInfo.IsUserContract.ShouldBeTrue();
```
