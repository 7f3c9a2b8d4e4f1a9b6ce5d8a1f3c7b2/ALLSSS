### Title
Unhandled Exception in CrossChainCreate() Due to Unsafe bool.Parse() on Unvalidated ExternalInfo

### Summary
The `CrossChainCreate()` method in the NFT contract performs unsafe `bool.Parse()` and direct dictionary access on `ExternalInfo` values without validation or exception handling. An attacker can create a token on the mainchain with malformed `ExternalInfo` metadata (non-boolean or missing keys), replicate it cross-chain, and cause any subsequent `CrossChainCreate()` call to throw an unhandled exception, permanently preventing NFT protocol creation on the sidechain for that symbol.

### Finding Description

The vulnerability exists in the `CrossChainCreate()` method where it unsafely parses `ExternalInfo` metadata: [1](#0-0) 

These lines perform two unsafe operations:
1. **Direct dictionary access** without checking if keys exist (throws `KeyNotFoundException`)
2. **bool.Parse() without try-catch** for the `NftTokenIdReuseMetadataKey` value (throws `FormatException` if value is not a valid boolean string like "True"/"False")

The constant is defined as: [2](#0-1) 

**Root Cause**: When tokens are created via the MultiToken contract directly (bypassing the NFT contract's `Create` method), the `ExternalInfo` is copied from input without content validation: [3](#0-2) 

The legitimate NFT contract's `Create` method properly sets boolean values: [4](#0-3) 

However, an attacker can call `MultiToken.Create()` directly with arbitrary `ExternalInfo` content.

**Cross-Chain Replication**: The malformed `ExternalInfo` is preserved during cross-chain token creation: [5](#0-4) 

The `ValidateTokenInfoExists` method validates that `ExternalInfo` matches between source and input, but doesn't validate the content format: [6](#0-5) 

**Why Existing Protections Fail**:
- The MultiToken contract accepts any `ExternalInfo` content during token creation
- Cross-chain verification validates proof integrity but not metadata format
- The NFT contract's `CrossChainCreate()` has no pre-validation or exception handling
- Other parts of the codebase use safer patterns like `TryGetValue()`: [7](#0-6) 

### Impact Explanation

**Concrete Harm**:
- **DoS of Cross-Chain NFT Protocol Creation**: Once a malicious token is replicated to a sidechain, any call to `CrossChainCreate()` for that symbol will throw an unhandled exception, making the protocol creation transaction fail permanently.
- **Protocol Lock-Out**: The NFT protocol becomes "stuck" - it exists on the mainchain but cannot be instantiated on the sidechain, breaking cross-chain NFT functionality.
- **Resource Waste**: Legitimate users attempting to create the protocol will pay transaction fees for failing transactions.

**Who is Affected**:
- NFT protocol creators attempting to expand to sidechains
- DApps depending on cross-chain NFT availability
- End users unable to interact with NFT protocols on affected sidechains

**Severity Justification**: High severity due to:
- Complete denial of service for specific NFT protocol symbols
- No recovery mechanism without contract upgrade
- Breaks critical cross-chain functionality
- Affects operational integrity of the NFT system

### Likelihood Explanation

**Attacker Capabilities Required**:
1. Obtain a SEED NFT for token creation (can be purchased/traded on markets)
2. Call `MultiToken.Create()` on mainchain with crafted `ExternalInfo`
3. Execute cross-chain replication via `ValidateTokenInfoExists` + `CrossChainCreateToken`

**Attack Complexity**: Low
- Straightforward 3-step process
- No sophisticated cryptographic manipulation needed
- No timing dependencies or race conditions

**Feasibility Conditions**:
- SEED NFTs are tradeable assets, obtainable by any user
- Token creation with custom `ExternalInfo` is permitted: [8](#0-7) 

- Cross-chain replication is a standard, permissionless operation

**Economic Rationality**:
- Cost: Price of one SEED NFT + transaction fees
- Benefit: Can target specific NFT protocol symbols (e.g., competitors' protocols)
- The attack is economically viable for griefing or competitive advantage

**Detection/Operational Constraints**: 
- Attack leaves on-chain evidence (malicious token creation)
- However, damage is done once token is replicated cross-chain
- No automatic detection or prevention mechanisms exist

**Probability**: Medium-High - All preconditions are achievable by any user with modest resources.

### Recommendation

**Code-Level Mitigation**:

1. **Add safe parsing with validation** in `CrossChainCreate()`:

```csharp
// Validate and safely extract ExternalInfo
if (!tokenInfo.ExternalInfo.Value.TryGetValue(NftBaseUriMetadataKey, out var baseUri))
    throw new AssertionException($"Missing required metadata key: {NftBaseUriMetadataKey}");

if (!tokenInfo.ExternalInfo.Value.TryGetValue(NftTokenIdReuseMetadataKey, out var tokenIdReuseStr) ||
    !bool.TryParse(tokenIdReuseStr, out var isTokenIdReuse))
    throw new AssertionException($"Invalid or missing boolean metadata for key: {NftTokenIdReuseMetadataKey}");
```

2. **Add ExternalInfo validation** in `MultiToken.CreateToken()` for NFT-related symbols:

```csharp
// If symbol looks like NFT protocol (2-letter prefix + numbers), validate NFT metadata
if (IsNftProtocolSymbol(input.Symbol) && input.ExternalInfo != null)
{
    ValidateNftExternalInfo(input.ExternalInfo);
}
```

3. **Implement helper method**:

```csharp
private void ValidateNftExternalInfo(ExternalInfo externalInfo)
{
    if (externalInfo.Value.TryGetValue("aelf_nft_token_id_reuse", out var reuseValue))
    {
        Assert(bool.TryParse(reuseValue, out _), 
            "Invalid boolean value for aelf_nft_token_id_reuse");
    }
}
```

**Invariant Checks to Add**:
- All ExternalInfo keys used by NFT contract must be present and properly formatted
- Boolean metadata values must parse successfully before use
- Dictionary access must use safe patterns (`TryGetValue`, `ContainsKey`)

**Test Cases to Prevent Regression**:
1. Test `CrossChainCreate()` with missing `NftTokenIdReuseMetadataKey`
2. Test `CrossChainCreate()` with invalid boolean value ("invalid", "123", etc.)
3. Test `CrossChainCreate()` with missing `NftBaseUriMetadataKey`
4. Test `MultiToken.Create()` with malformed NFT metadata gets rejected
5. End-to-end cross-chain test with malicious token creation attempt

### Proof of Concept

**Required Initial State**:
- Attacker owns a SEED NFT for symbol "AR123456789" on mainchain (AELF)
- NFT type "AR" is registered in the system

**Attack Sequence**:

1. **On Mainchain (AELF)** - Attacker creates malicious token:
```
Transaction: MultiToken.Create()
Input: {
  Symbol: "AR123456789",
  TokenName: "Malicious NFT",
  TotalSupply: 1000000,
  Decimals: 0,
  Issuer: <attacker_address>,
  IsBurnable: true,
  IssueChainId: 9992731,
  ExternalInfo: {
    "aelf_nft_type": "Art",
    "aelf_nft_base_uri": "https://example.com/",
    "aelf_nft_token_id_reuse": "not_a_boolean"  // MALICIOUS VALUE
  }
}
Expected: Token created successfully
```

2. **Cross-Chain Replication** - Replicate to sidechain:
```
Transaction (Mainchain): MultiToken.ValidateTokenInfoExists()
Input: { Symbol: "AR123456789", ... ExternalInfo with malformed data }
Expected: Validation passes (content not checked)

Transaction (Sidechain): MultiToken.CrossChainCreateToken()
Input: { Cross-chain proof of ValidateTokenInfoExists transaction }
Expected: Token created on sidechain with malformed ExternalInfo
```

3. **On Sidechain** - Trigger the vulnerability:
```
Transaction: NFTContract.CrossChainCreate()
Input: { Symbol: "AR123456789" }
Expected: Transaction FAILS with FormatException
Actual Result: Unhandled exception: "String was not recognized as valid Boolean."
Success Condition: NFT protocol creation permanently blocked for this symbol
```

**Observable Evidence**:
- Transaction reverts with FormatException message
- NFT protocol for "AR123456789" cannot be created on sidechain
- Repeated attempts all fail with same exception
- No recovery path without contract upgrade

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L87-88)
```csharp
        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L199-199)
```csharp
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L9-9)
```csharp
    private const string NftTokenIdReuseMetadataKey = "aelf_nft_token_id_reuse";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L124-130)
```csharp
        Assert(tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.SeedOwnedSymbolExternalInfoKey, out var ownedSymbol) && ownedSymbol == symbol,
            "Invalid OwnedSymbol.");
        Assert(tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                   out var expirationTime)
               && long.TryParse(expirationTime, out var expirationTimeLong) &&
               Context.CurrentBlockTime.Seconds <= expirationTimeLong, "OwnedSymbol is expired.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L449-456)
```csharp
        if (tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.Count > 0 ||
            input.ExternalInfo != null && input.ExternalInfo.Count > 0)
        {
            validationResult = validationResult && tokenInfo.ExternalInfo.Value.Count == input.ExternalInfo.Count;
            if (tokenInfo.ExternalInfo.Value.Any(keyPair =>
                    !input.ExternalInfo.ContainsKey(keyPair.Key) || input.ExternalInfo[keyPair.Key] != keyPair.Value))
                throw new AssertionException("Token validation failed.");
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L489-501)
```csharp
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
```
