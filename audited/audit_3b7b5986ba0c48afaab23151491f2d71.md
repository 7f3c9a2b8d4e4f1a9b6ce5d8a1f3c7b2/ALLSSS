# Audit Report

## Title
Unbounded State Growth in DistributedProfitsMap Due to Missing Cleanup Mechanism

## Summary
The Profit contract's `DistributedProfitsMap` accumulates distribution records indefinitely without any cleanup mechanism, causing unbounded blockchain state growth. While the contract implements cleanup for `ProfitDetailsMap` (beneficiary records), it lacks equivalent logic for `DistributedProfitsMap`, resulting in permanent storage bloat as each profit distribution period creates a new entry that persists forever.

## Finding Description

The vulnerability exists in the Profit contract's state management design where `DistributedProfitsMap` entries are created during each profit distribution but never removed. [1](#0-0) 

When profits are distributed via `DistributeProfits()`, the method calls `UpdateDistributedProfits()` which creates and stores a `DistributedProfitsInfo` record in `DistributedProfitsMap` keyed by a unique virtual address for each scheme-period combination: [2](#0-1) 

Similarly, when profits are burned, entries are still created: [3](#0-2) 

The virtual address generation ensures each period gets a unique entry: [4](#0-3) 

**Critical Inconsistency**: The contract demonstrates awareness of storage management by implementing cleanup logic for `ProfitDetailsMap`: [5](#0-4) 

However, no equivalent cleanup mechanism exists for `DistributedProfitsMap`. Code inspection and grep searches confirm zero removal operations on this map.

**Execution Flow**:

The Treasury contract automatically triggers distributions every consensus term (~7 days): [6](#0-5) 

Multiple core system schemes are distributed per term: [7](#0-6) 

When beneficiaries claim profits via `ClaimProfits()`, tokens are transferred but the `DistributedProfitsInfo` record remains unmodified and persists indefinitely: [8](#0-7) 

Even after the grace period defined by `ProfitReceivingDuePeriodCount` (default 10 periods) expires and no further claims are possible, entries persist indefinitely: [9](#0-8) 

## Impact Explanation

**Concrete Harm**:
- **Unbounded State Growth**: Each consensus term (~7 days) adds permanent entries to blockchain state
- **Quantified Growth**: ~52 periods/year Ã— 7 core system schemes = 364 permanent entries per year minimum
- **Affected Parties**: All full nodes must store ever-growing state; new nodes face increasing sync times; node operators incur growing storage costs
- **No Pruning**: No mechanism exists to clean up entries without a hard fork

**Severity Justification**: 
Medium severity is appropriate because while the growth is unbounded and certain, it accumulates slowly (estimated ~10MB over 10 years for core schemes), doesn't prevent contract operations, and doesn't directly compromise funds or security. However, it represents a clear operational degradation and design inconsistency that violates the principle of bounded blockchain state growth.

## Likelihood Explanation

**Certainty**: 100% - This is not a potential vulnerability but an actively occurring issue:
- No attacker required - natural system operation causes accumulation
- Treasury automatically distributes profits every consensus term via AEDPoS contract
- Already occurring in production since genesis
- Irreversible without contract upgrade
- Accelerating as more schemes are created (scheme creation is permissionless)

**Observable Evidence**: State size growth queries would reveal continuous accumulation of `DistributedProfitsMap` entries with no corresponding deletions.

## Recommendation

Implement a cleanup mechanism for `DistributedProfitsMap` entries similar to the existing logic for `ProfitDetailsMap`. Add cleanup logic in `AddBeneficiary()` or create a dedicated cleanup method:

```csharp
// In AddBeneficiary or a dedicated cleanup method
private void CleanupOldDistributedProfits(Hash schemeId, long currentPeriod, int profitReceivingDuePeriodCount)
{
    // Remove DistributedProfitsMap entries older than grace period
    var cutoffPeriod = currentPeriod - profitReceivingDuePeriodCount;
    for (long period = 1; period < cutoffPeriod; period++)
    {
        var virtualAddress = GetDistributedPeriodProfitsVirtualAddress(schemeId, period);
        if (State.DistributedProfitsMap[virtualAddress] != null)
        {
            State.DistributedProfitsMap.Remove(virtualAddress);
        }
    }
}
```

This should be called periodically during scheme operations to gradually clean up old entries that are beyond the grace period and can no longer be claimed.

## Proof of Concept

A proof of concept would involve:
1. Creating a test scheme
2. Distributing profits for multiple periods
3. Advancing past the grace period (ProfitReceivingDuePeriodCount)
4. Verifying that `DistributedProfitsMap` entries persist indefinitely
5. Confirming that `GetDistributedProfitsInfo()` still returns data for periods beyond grace period
6. Demonstrating unbounded accumulation over many periods

The core issue is observable in production by querying state size growth over time and confirming that `DistributedProfitsMap` entries from old periods remain in storage despite being inaccessible for claims.

## Notes

This is a legitimate design flaw where the contract exhibits inconsistent cleanup patterns between related state variables. The presence of cleanup logic for `ProfitDetailsMap` proves the developers were aware of state management concerns, making the absence of equivalent logic for `DistributedProfitsMap` a clear oversight rather than an intentional design choice. While the impact is gradual rather than immediate, it represents a violation of blockchain sustainability principles and should be addressed in a future contract upgrade.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContractState.cs (L11-11)
```csharp
    public MappedState<Address, DistributedProfitsInfo> DistributedProfitsMap { get; set; }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L203-207)
```csharp
        // Remove details too old.
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L517-558)
```csharp
    private Empty BurnProfits(long period, Dictionary<string, long> profitsMap, Scheme scheme,
        Address profitsReceivingVirtualAddress)
    {
        scheme.CurrentPeriod = period.Add(1);

        var distributedProfitsInfo = new DistributedProfitsInfo
        {
            IsReleased = true
        };
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            if (amount > 0)
            {
                var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = symbol
                });
                if (balanceOfToken.Balance < amount)
                    continue;
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = Context.Self,
                        Amount = amount,
                        Symbol = symbol
                    }.ToByteString());
                State.TokenContract.Burn.Send(new BurnInput
                {
                    Amount = amount,
                    Symbol = symbol
                });
                distributedProfitsInfo.AmountsMap.Add(symbol, -amount);
            }
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;
        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-583)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L750-809)
```csharp
    public override Empty ClaimProfits(ClaimProfitsInput input)
    {
        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null) throw new AssertionException("Scheme not found.");
        var beneficiary = input.Beneficiary ?? Context.Sender;
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][beneficiary];
        if (profitDetails == null) throw new AssertionException("Profit details not found.");

        Context.LogDebug(
            () => $"{Context.Sender} is trying to profit from {input.SchemeId.ToHex()} for {beneficiary}.");

        // LastProfitPeriod is set as 0 at the very beginning, and be updated as current period every time when it is claimed.
        // What's more, LastProfitPeriod can also be +1 more than endPeroid, for it always points to the next period to claim.
        // So if LastProfitPeriod is 0, that means this profitDetail hasn't be claimed before, so just check whether it is a valid one;
        // And if a LastProfitPeriod is larger than EndPeriod, it should not be claimed, and should be removed later.
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
        var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();

        Context.LogDebug(() =>
            $"Profitable details: {profitableDetails.Aggregate("\n", (profit1, profit2) => profit1.ToString() + "\n" + profit2)}");

        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
        // Only can get profit from last profit period to actual last period (profit.CurrentPeriod - 1),
        // because current period not released yet.
        for (var i = 0; i < profitableDetailCount; i++)
        {
            var profitDetail = profitableDetails[i];
            if (profitDetail.LastProfitPeriod == 0)
                // This detail never performed profit before.
                profitDetail.LastProfitPeriod = profitDetail.StartPeriod;

            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
        }

        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;

        foreach (var profitDetail in profitDetailsToRemove)
        {
            availableDetails.Remove(profitDetail);
        }

        State.ProfitDetailsMap[input.SchemeId][beneficiary] = new ProfitDetails { Details = { availableDetails } };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L57-60)
```csharp
    private Hash GeneratePeriodVirtualAddressFromHash(Hash schemeId, long period)
    {
        return HashHelper.XorAndCompute(schemeId, HashHelper.ComputeFrom(period));
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L123-134)
```csharp
    public override Empty Release(ReleaseInput input)
    {
        RequireAEDPoSContractStateSet();
        Assert(
            Context.Sender == State.AEDPoSContract.Value,
            "Only AElf Consensus Contract can release profits from Treasury.");
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.TreasuryHash.Value,
            Period = input.PeriodNumber,
            AmountsMap = { State.SymbolList.Value.Value.ToDictionary(s => s, s => 0L) }
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L705-735)
```csharp
    private void ReleaseTreasurySubProfitItems(long termNumber)
    {
        var amountsMap = State.SymbolList.Value.Value.ToDictionary(s => s, s => 0L);
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.RewardHash.Value,
            Period = termNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            Period = termNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.ReElectionRewardHash.Value,
            Period = termNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.BasicRewardHash.Value,
            Period = termNumber,
            AmountsMap = { amountsMap }
        });
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L6-6)
```csharp
    public const int DefaultProfitReceivingDuePeriodCount = 10;
```
