### Title
Quadratic Voting Accounting Mismatch Allows Voting Result Manipulation Through Persistent Vote Count

### Summary
The `QuadraticVotesCountMap` counter persists across vote withdrawals and is never reset, combined with an accounting mismatch where votes add 1 to results but withdrawals subtract the full token amount (`ticketCost * count`). This allows attackers in delegated voting scenarios to repeatedly vote and withdraw with the same `VoteId`, manipulating voting results and potentially driving them negative.

### Finding Description

**Root Cause - Persistent Vote Count:**

In the `Vote()` method for quadratic voting, the `QuadraticVotesCountMap[input.VoteId]` is incremented and used to calculate the token amount: [1](#0-0) 

However, the `Withdraw()` method never resets or decrements this counter: [2](#0-1) 

The counter persists indefinitely in state: [3](#0-2) 

**Root Cause - Accounting Mismatch:**

When voting in quadratic mode, only `1` is added to the voting results (not the token amount): [4](#0-3) 

The `UpdateVotingResult` method adds this value to both `Results[option]` and `VotesAmount`: [5](#0-4) 

However, when withdrawing, the full `votingRecord.Amount` (which equals `ticketCost * count`) is subtracted: [6](#0-5) 

**Exploitation Path - VoteId Reuse:**

For delegated voting (`IsLockToken = false`), the sponsor provides the `VoteId` and can reuse it: [7](#0-6) 

The `Vote()` method overwrites any existing `VotingRecord` without validation: [8](#0-7) 

No check prevents voting with a previously withdrawn `VoteId`.

### Impact Explanation

**Direct Harm:**
1. **Voting Result Manipulation**: Each vote-withdraw-revote cycle creates a net negative effect on voting results:
   - Cycle 1: Vote adds +1, Withdraw subtracts -(ticketCost × 1) = Net: 1 - ticketCost
   - Cycle 2: Vote adds +1, Withdraw subtracts -(ticketCost × 2) = Net: 1 - 2×ticketCost
   - After n cycles: Net = n - ticketCost × (1+2+...+n) = n - ticketCost × n(n+1)/2

2. **Negative Vote Counts**: With `ticketCost = 1` and just 2 cycles, results become: 2 - 3 = -1

3. **VotesAmount Depletion**: The `VotesAmount` field tracks total votes and can be drained below zero, breaking accounting invariants.

**Affected Parties:**
- Any voting items using quadratic voting with `IsLockToken = false` (delegated voting)
- Governance decisions based on manipulated vote counts
- Legitimate voters whose votes are nullified by negative totals

**Severity Justification:**
This is a **CRITICAL** vulnerability because it:
- Breaks the fundamental integrity of voting results
- Allows complete manipulation of governance outcomes
- Can make voting results mathematically inconsistent (negative values)
- Requires no special privileges beyond being a voting item sponsor

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Create a delegated voting item (`IsLockToken = false`) by calling `Register()`
2. As the sponsor, call `Vote()` and `Withdraw()` repeatedly with a chosen `VoteId`
3. No token holdings required (delegated voting doesn't lock tokens in the Vote contract)

**Attack Complexity:**
- **Low**: Simple sequence of public method calls
- No timing constraints or race conditions
- No need to compromise trusted roles
- Deterministic outcome

**Feasibility Conditions:**
- Delegated voting items must exist or be creatable
- Attacker must be able to create voting items (typically unrestricted in the `Register()` method)
- Attack works independently for each voting item the attacker sponsors

**Economic Rationality:**
- Transaction costs are minimal (just gas fees for Vote/Withdraw calls)
- No token lock-up required for delegated voting
- High reward potential: complete control over voting outcomes
- Cost-benefit ratio strongly favors the attacker

**Detection Constraints:**
- Legitimate-looking vote and withdraw transactions
- No obvious anomalies in individual transactions
- Only aggregate analysis would reveal the manipulation
- QuadraticVotesCountMap state is not commonly monitored

**Probability Assessment:** **HIGH**
- All preconditions are easily satisfiable
- Attack is repeatable and reliable
- No special knowledge or resources required
- Likely to occur if quadratic delegated voting is used

### Recommendation

**Immediate Fixes:**

1. **Reset QuadraticVotesCountMap on Withdrawal:**
```csharp
// In Withdraw() method, after line 205, add:
if (votingItem.IsQuadratic)
{
    State.QuadraticVotesCountMap[input.VoteId] = 0;
}
```

2. **Fix Accounting Mismatch in Withdrawal:**
```csharp
// In Withdraw() method, replace lines 215-220 with:
var amountToSubtract = votingItem.IsQuadratic ? 1 : votingRecord.Amount;
votingResult.Results[votingRecord.Option] = 
    votingResult.Results[votingRecord.Option].Sub(amountToSubtract);
votingResult.VotesAmount = votingResult.VotesAmount.Sub(amountToSubtract);
```

3. **Prevent VoteId Reuse:**
```csharp
// In Vote() method, before line 117, add:
var existingRecord = State.VotingRecords[input.VoteId];
Assert(existingRecord == null || existingRecord.IsWithdrawn, 
    "Cannot reuse an active VoteId.");
```

**Additional Safeguards:**

4. **Add Validation for Withdrawn Records:**
```csharp
// In Withdraw() method, after line 193, add:
Assert(!votingRecord.IsWithdrawn, "Vote already withdrawn.");
```

5. **Implement Negative Result Protection:**
```csharp
// In Withdraw() method, add checks before subtraction:
Assert(votingResult.Results[votingRecord.Option] >= amountToSubtract,
    "Insufficient votes to withdraw.");
Assert(votingResult.VotesAmount >= amountToSubtract,
    "Insufficient total votes to withdraw.");
```

**Test Cases to Prevent Regression:**

1. Test quadratic voting with vote-withdraw-revote cycle using same VoteId
2. Verify QuadraticVotesCountMap resets after withdrawal
3. Verify voting results remain non-negative
4. Test that withdrawn VoteIds cannot be immediately reused
5. Verify accounting consistency: sum of all vote amounts equals VotesAmount

### Proof of Concept

**Initial State:**
- Voting item registered with `IsQuadratic = true`, `IsLockToken = false`, `TicketCost = 1`
- Sponsor address: `SponsorAddress`
- Option: `"OptionA"`
- Initial `Results["OptionA"] = 0`, `VotesAmount = 0`

**Attack Sequence:**

**Step 1: First Vote**
```
Sender: SponsorAddress
Method: Vote(VotingItemId, Voter: VoterX, VoteId: AttackerVoteId, Option: "OptionA")
```
- `QuadraticVotesCountMap[AttackerVoteId]` = 1
- `VotingRecords[AttackerVoteId].Amount` = 1 × 1 = 1
- `Results["OptionA"]` += 1 → **Results = 1**
- `VotesAmount` += 1 → **VotesAmount = 1**

**Step 2: First Withdrawal**
```
Sender: SponsorAddress
Method: Withdraw(VoteId: AttackerVoteId)
```
- `VotingRecords[AttackerVoteId].IsWithdrawn` = true
- `Results["OptionA"]` -= 1 → **Results = 0**
- `VotesAmount` -= 1 → **VotesAmount = 0**
- ⚠️ `QuadraticVotesCountMap[AttackerVoteId]` still = 1 (NOT RESET)

**Step 3: Second Vote (Reusing Same VoteId)**
```
Sender: SponsorAddress
Method: Vote(VotingItemId, Voter: VoterX, VoteId: AttackerVoteId, Option: "OptionA")
```
- `QuadraticVotesCountMap[AttackerVoteId]` = 1 + 1 = 2 (PERSISTED!)
- `VotingRecords[AttackerVoteId].Amount` = 1 × 2 = 2
- `Results["OptionA"]` += 1 → **Results = 1**
- `VotesAmount` += 1 → **VotesAmount = 1**

**Step 4: Second Withdrawal**
```
Sender: SponsorAddress
Method: Withdraw(VoteId: AttackerVoteId)
```
- `Results["OptionA"]` -= 2 → **Results = -1** ❌ NEGATIVE!
- `VotesAmount` -= 2 → **VotesAmount = -1** ❌ NEGATIVE!

**Expected vs Actual Result:**

**Expected:** After 2 vote-withdraw cycles, results should return to 0 (neutral state)

**Actual:** After 2 cycles, `Results["OptionA"] = -1` and `VotesAmount = -1` (BROKEN INVARIANT)

**Success Condition:** The attack succeeds when voting results become negative, proving the accounting mismatch and persistent counter allow result manipulation.

**Notes:**
- The vulnerability is present in the current implementation at lines 100-102 and 215-220
- No tests exist for quadratic voting scenarios (verified via grep search)
- The issue compounds with each cycle, allowing unbounded manipulation
- Higher `TicketCost` values amplify the impact

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L100-102)
```csharp
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L119-119)
```csharp
        UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-180)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L191-239)
```csharp
    public override Empty Withdraw(WithdrawInput input)
    {
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;

        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;

        if (votingItem.IsLockToken)
            State.TokenContract.Unlock.Send(new UnlockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                Amount = votingRecord.Amount,
                LockId = input.VoteId
            });

        Context.Fire(new Withdrawn
        {
            VoteId = input.VoteId
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-388)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
```

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L30-33)
```csharp
    /// <summary>
    ///     Vote Id -> Votes Count
    /// </summary>
    public MappedState<Hash, long> QuadraticVotesCountMap { get; set; }
```
