### Title
Duplicate Mining Orders in Next Round Due to Silent Conflict Resolution Failure

### Summary
The `ApplyNormalConsensusData()` function contains a critical flaw where conflict resolution fails silently when all mining positions are occupied. When a miner updates their consensus data and causes an order conflict, but no free position exists for the conflicted miner, both miners end up with the same `FinalOrderOfNextRound` value. This creates duplicate mining orders in the next round, breaking consensus schedule integrity. [1](#0-0) 

### Finding Description

The vulnerability exists in the conflict resolution logic within `ApplyNormalConsensusData()`. When a miner produces a block, the function calculates their `supposedOrderOfNextRound` based on their signature hash. If another miner already occupies that position, the code attempts to reassign the conflicted miner to a free position. [2](#0-1) 

**Root Cause:** The conflict resolution loop searches for available positions from `supposedOrderOfNextRound + 1` to `minersCount * 2`. If all positions are occupied (which occurs when all miners have already determined their `FinalOrderOfNextRound`), the loop completes without finding any free position. Critically:

1. No assignment occurs (line 36-37 is never executed)
2. The `break` statement (line 38) is never reached
3. The conflicted miner **retains** their original conflicting `FinalOrderOfNextRound`
4. The current miner then gets assigned the same value (line 44)

**Why Existing Protections Fail:**

The validation in `NextRoundMiningOrderValidationProvider` only checks that the count of miners with `FinalOrderOfNextRound > 0` equals the count of miners with `OutValue != null`: [3](#0-2) 

This validation uses `Distinct()` on `MinerInRound` objects (not on the `FinalOrderOfNextRound` values themselves), which uses reference equality. Two miners with duplicate order values are still counted as distinct objects, so the validation **does not detect duplicate orders**.

**Execution Path:** Miners can produce multiple blocks within their time slot (tiny blocks), with each block triggering `ApplyNormalConsensusData()`: [4](#0-3) 

### Impact Explanation

**Consensus Schedule Breakdown:** When the next round is generated, miners are ordered by their `FinalOrderOfNextRound`: [5](#0-4) 

If two miners have the same `Order` value:
- Both miners are scheduled for the **same time slot**
- Both attempt to produce blocks simultaneously
- Creates race conditions and conflicting blocks
- Breaks the deterministic consensus schedule

**Affected Parties:**
- **Entire Network:** Consensus integrity is compromised, potentially causing chain forks or stalls
- **Duplicate Order Miners:** Both miners may be penalized unfairly for "missing" their slot when the other produces
- **Next Round Operations:** The `BreakContinuousMining` logic and extra block producer selection depend on unique orders and will malfunction

**Severity:** Critical - violates the fundamental consensus invariant that each miner must have a unique mining order. This can cause consensus failures, unfair penalties, and network instability.

### Likelihood Explanation

**Attacker Capabilities:** Any miner participating in consensus can trigger this vulnerability. No special privileges required beyond normal block production rights.

**Attack Complexity:** Low
1. Wait until all N miners in a round have produced their first block and determined their `FinalOrderOfNextRound` (positions 1 through N are all occupied)
2. Produce a second block (tiny block) within your time slot
3. If your new signature hash modulo produces a `supposedOrderOfNextRound` that conflicts with an existing miner, and all positions are occupied, duplicate orders are created

**Feasibility Conditions:**
- All miners must have already determined their `FinalOrderOfNextRound` (common in active rounds)
- The recalculated `supposedOrderOfNextRound` must conflict with an existing position
- Miners are **designed** to produce multiple tiny blocks per time slot (up to 8 blocks), making this scenario routine [6](#0-5) 

**Probability:** High - This is not a deliberate attack but a natural consequence of normal consensus operations when:
- Network is healthy and all miners are producing blocks
- Miners produce tiny blocks (standard behavior for throughput)
- Signature hashes naturally create conflicts

### Recommendation

**Immediate Fix:** Modify the conflict resolution logic to ensure assignment always occurs or reject the operation if no free position exists:

```csharp
var assignmentMade = false;
foreach (var orderConflictedMiner in conflicts)
{
    for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
    {
        var maybeNewOrder = i > minersCount ? i % minersCount : i;
        if (maybeNewOrder == 0) continue; // Skip invalid order 0
        if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
        {
            RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound = maybeNewOrder;
            assignmentMade = true;
            break;
        }
    }
    
    // If no free position found, reject the operation
    Assert(assignmentMade, "Unable to resolve order conflict - no available positions");
}
```

**Additional Validation:** Enhance `NextRoundMiningOrderValidationProvider` to check for duplicate order values:

```csharp
var ordersWithValues = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
    
if (ordersWithValues.Count != ordersWithValues.Distinct().Count())
{
    validationResult.Message = "Duplicate FinalOrderOfNextRound values detected.";
    return validationResult;
}
```

**Test Cases:**
1. Scenario with all N positions occupied, miner produces second block causing conflict
2. Verify validation catches duplicate orders before next round generation
3. Test with modulo edge case where `i % minersCount = 0`

### Proof of Concept

**Initial State:**
- Round with 5 miners: A, B, C, D, E
- All miners produce their first blocks with `FinalOrderOfNextRound` = 1, 2, 3, 4, 5 respectively
- All positions are now occupied

**Exploit Steps:**

1. Miner A produces a second tiny block (within their time slot)
2. Miner A's new signature hash results in `supposedOrderOfNextRound = 3` (conflicts with Miner C)
3. `ApplyNormalConsensusData()` is called for Miner A
4. Conflict resolution loop attempts to reassign Miner C:
   - Checks positions: 4 (occupied by D), 5 (occupied by E), 1 (occupied by A), 2 (occupied by B), 3 (occupied by C), 4 (occupied by D)
   - All positions occupied, loop completes without assignment
5. Miner C retains `FinalOrderOfNextRound = 3`
6. Miner A gets assigned `FinalOrderOfNextRound = 3` (line 44)

**Expected Result:** Conflict should be resolved or operation should fail

**Actual Result:** 
- Miner A: `FinalOrderOfNextRound = 3`
- Miner C: `FinalOrderOfNextRound = 3` (DUPLICATE)
- Validation passes (counts match: 5 miners with orders, 5 miners with OutValue)
- Next round generation assigns both miners to Order = 3
- Both scheduled for same time slot, causing consensus failure

**Success Condition:** Both miners have identical `FinalOrderOfNextRound` values, validation does not detect the duplicate, and next round generation creates two miners with the same `Order`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-47)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L55-112)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataToPublishOutValue(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        Assert(triggerInformation.InValue != null, "In value should not be null.");

        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
        var previousInValue = Hash.Empty; // Just initial previous in value.

        if (TryToGetPreviousRoundInformation(out var previousRound) && !IsFirstRoundOfCurrentTerm(out _))
        {
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
            else
            {
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
            }
        }

        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
