# Audit Report

## Title
Unbounded Merkle Path Length Enables Computational DoS in Cross-Chain Transaction Verification

## Summary
The cross-chain token transfer mechanism allows attackers to submit transactions with artificially inflated merkle paths containing up to ~151,000 nodes (limited only by the 5MB transaction size). When validators execute `CrossChainReceiveToken`, the unbounded merkle path iteration occurs in framework code that bypasses execution observer instrumentation, and resource fees only charge for transaction size and state reads—not the ~151,000 SHA256 hash operations performed. This creates an asymmetric attack where validators pay excessive CPU costs while attackers pay fixed transaction fees.

## Finding Description

The vulnerability exists in how cross-chain token transfers validate merkle proofs without enforcing path length limits. When `CrossChainReceiveToken` is called [1](#0-0) , it internally invokes `CrossChainVerify` [2](#0-1)  which calls `VerifyTransaction` on the CrossChain contract [3](#0-2) .

The `VerifyTransaction` method accepts `input.Path` without validating the number of nodes and passes it directly to `ComputeRootWithTransactionStatusMerklePath` [4](#0-3) . This computation uses LINQ's `Aggregate` to iterate through all merkle path nodes [5](#0-4) , with each iteration calling `HashHelper.ConcatAndCompute` [6](#0-5)  to perform SHA256 hashing.

The protobuf definition allows unlimited nodes via `repeated MerklePathNode` [7](#0-6) , and the `CrossChainReceiveTokenInput` includes this unbounded merkle path [8](#0-7) .

**Why existing protections fail:**

1. **Transaction size limit is insufficient**: The 5MB limit [9](#0-8)  allows ~151,000 nodes (assuming 33 bytes per MerklePathNode), far exceeding legitimate merkle path depths.

2. **Execution observer doesn't apply**: The observer instruments backward-jumping branches in contract code only [10](#0-9) . The LINQ `Aggregate` iteration in `MerklePathExtensions` is framework code that was never patched during contract deployment, so execution observer branch counts don't apply.

3. **Fee calculation is size-based, not computation-based**: Resource fees charge for state reads via `ReadFeeProvider` [11](#0-10) , not CPU computation. The SHA256 hashing operations don't increase charged fees.

4. **View transactions are rejected but internal calls are not**: While `VerifyTransaction` is marked as a view method [12](#0-11)  and direct calls would be rejected [13](#0-12) , internal contract calls via `CrossChainReceiveToken` bypass this protection.

**Legitimate path context**: Binary merkle trees have logarithmic depth. The `BinaryMerkleTree.GenerateMerklePath` implementation [14](#0-13)  shows legitimate paths would have ~30 nodes even for 1 billion transactions. An attacker providing 151,000 nodes is 5,000x longer than any legitimate path.

## Impact Explanation

**Operational Impact - Computational DoS:**

Attackers can force validators to perform ~151,000 SHA256 hash computations per malicious transaction. Modern CPUs process 1-10 million SHA256 operations per second, so this represents 15-150ms of additional CPU time per transaction.

**Concrete harm:**
- **Block production delay**: Each malicious transaction adds 15-150ms processing time
- **Amplification potential**: Multiple such transactions multiply the effect 
- **Asymmetric cost**: Attacker pays only fixed transaction size fees (TRAFFIC/STORAGE resources) while validators pay CPU cost that is NOT charged via READ resources
- **Chain throughput degradation**: Legitimate transactions experience delays during block processing

**Severity: Medium** - Causes operational DoS on validators without direct fund theft. The attack is repeatable at low cost and degrades availability of the cross-chain bridge mechanism, which is critical infrastructure. However, the per-transaction impact (15-150ms) is bounded by the 5MB transaction size limit, preventing catastrophic chain halt.

## Likelihood Explanation

**Attacker capabilities:**
- No special permissions required
- Only requires ability to submit transactions calling `CrossChainReceiveToken`
- Can craft malicious `CrossChainReceiveTokenInput` with arbitrary merkle path length

**Attack complexity: Very Low**
1. Construct `MerklePath` with ~151,000 fake `MerklePathNode` entries (within 5MB limit)
2. Create `CrossChainReceiveTokenInput` including transfer transaction bytes and malicious merkle path
3. Submit transaction calling `CrossChainReceiveToken`
4. Transaction passes size validation and enters mempool
5. All validators forced to iterate through nodes during block execution

**Economic rationality:**
- Attack cost: Fixed transaction size fee for 5MB transaction
- Validator cost: ~151,000 SHA256 operations × number of validators
- Clear asymmetry favors attacker
- Attack is repeatable with multiple transactions

**Probability: HIGH** - Trivially exploitable, low cost, high impact on validators, easily repeatable.

## Recommendation

Add explicit merkle path length validation before processing. Since legitimate merkle paths have logarithmic depth (maximum ~50 nodes even for extremely large trees), enforce a reasonable upper bound:

```csharp
// In CrossChainContract_Helper.cs, ComputeRootWithTransactionStatusMerklePath method
private Hash ComputeRootWithTransactionStatusMerklePath(Hash txId, MerklePath path)
{
    // Add length validation
    const int MaxMerklePathLength = 64; // Generous limit for log2 depth
    Assert(path.MerklePathNodes.Count <= MaxMerklePathLength, 
        $"Merkle path length {path.MerklePathNodes.Count} exceeds maximum {MaxMerklePathLength}");
    
    var txResultStatusRawBytes = 
        EncodingHelper.EncodeUtf8(TransactionResultStatus.Mined.ToString());
    var hash = HashHelper.ComputeFrom(
        ByteArrayHelper.ConcatArrays(txId.ToByteArray(), txResultStatusRawBytes));
    return path.ComputeRootWithLeafNode(hash);
}
```

Alternatively, add validation in `VerifyTransaction` or `CrossChainVerify` helper methods to catch the issue earlier.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMerklePathCausesExcessiveComputation()
{
    // Construct malicious merkle path with excessive nodes
    var maliciousPath = new MerklePath();
    for (int i = 0; i < 150000; i++) // 150,000 nodes
    {
        maliciousPath.MerklePathNodes.Add(new MerklePathNode
        {
            Hash = Hash.FromString($"fake{i}"),
            IsLeftChildNode = i % 2 == 0
        });
    }
    
    // Create fake transfer transaction
    var fakeTransfer = new Transaction
    {
        From = Address.FromString("fake"),
        To = Address.FromString("fake"),
        MethodName = "CrossChainTransfer",
        Params = new CrossChainTransferInput
        {
            Symbol = "ELF",
            Amount = 100,
            ToChainId = 9992731
        }.ToByteString()
    };
    
    // Measure execution time for VerifyTransaction with malicious path
    var stopwatch = System.Diagnostics.Stopwatch.StartNew();
    
    var result = await CrossChainContractStub.VerifyTransaction.CallAsync(
        new VerifyTransactionInput
        {
            TransactionId = fakeTransfer.GetHash(),
            Path = maliciousPath,
            ParentChainHeight = 100,
            VerifiedChainId = 9992731
        });
    
    stopwatch.Stop();
    
    // Verify excessive computation occurred
    // With 150k nodes, execution should take >> legitimate ~30-node path
    // This demonstrates the DoS vector
    Assert.True(stopwatch.ElapsedMilliseconds > 10); // Conservative threshold
}
```

## Notes

The claim's attack path description incorrectly states attackers can "submit transaction calling `VerifyTransaction`" directly. This is inaccurate because `VerifyTransaction` is a view method and would be rejected by transaction validation. The actual attack vector is through `CrossChainReceiveToken`, which internally calls `VerifyTransaction`. Despite this minor inaccuracy in the attack description, the underlying vulnerability is valid: unbounded merkle paths cause excessive computation in framework code that bypasses execution observer instrumentation and isn't properly charged via resource fees.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L591-638)
```csharp
    public override Empty CrossChainReceiveToken(CrossChainReceiveTokenInput input)
    {
        var transferTransaction = Transaction.Parser.ParseFrom(input.TransferTransactionBytes);
        var transferTransactionId = transferTransaction.GetHash();

        Assert(!State.VerifiedCrossChainTransferTransaction[transferTransactionId],
            "Token already claimed.");

        var crossChainTransferInput =
            CrossChainTransferInput.Parser.ParseFrom(transferTransaction.Params.ToByteArray());
        var symbol = crossChainTransferInput.Symbol;
        var amount = crossChainTransferInput.Amount;
        var receivingAddress = crossChainTransferInput.To;
        var targetChainId = crossChainTransferInput.ToChainId;
        var transferSender = transferTransaction.From;

        var tokenInfo = AssertValidToken(symbol, amount);
        var issueChainId = GetIssueChainId(tokenInfo.Symbol);
        Assert(issueChainId == crossChainTransferInput.IssueChainId, "Incorrect issue chain id.");
        Assert(targetChainId == Context.ChainId, "Unable to claim cross chain token.");
        var registeredTokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        AssertCrossChainTransaction(transferTransaction, registeredTokenContractAddress,
            nameof(CrossChainTransfer));
        Context.LogDebug(() =>
            $"symbol == {tokenInfo.Symbol}, amount == {amount}, receivingAddress == {receivingAddress}, targetChainId == {targetChainId}");

        CrossChainVerify(transferTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);

        State.VerifiedCrossChainTransferTransaction[transferTransactionId] = true;
        tokenInfo.Supply = tokenInfo.Supply.Add(amount);
        Assert(tokenInfo.Supply <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(receivingAddress, tokenInfo.Symbol, amount);

        Context.Fire(new CrossChainReceived
        {
            From = transferSender,
            To = receivingAddress,
            Symbol = tokenInfo.Symbol,
            Amount = amount,
            Memo = crossChainTransferInput.Memo,
            FromChainId = input.FromChainId,
            ParentChainHeight = input.ParentChainHeight,
            IssueChainId = issueChainId,
            TransferTransactionId = transferTransactionId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L37-46)
```csharp
    public override BoolValue VerifyTransaction(VerifyTransactionInput input)
    {
        var parentChainHeight = input.ParentChainHeight;
        var merkleTreeRoot = GetMerkleTreeRoot(input.VerifiedChainId, parentChainHeight);
        Assert(merkleTreeRoot != null,
            $"Parent chain block at height {parentChainHeight} is not recorded.");
        var rootCalculated = ComputeRootWithTransactionStatusMerklePath(input.TransactionId, input.Path);

        return new BoolValue { Value = merkleTreeRoot == rootCalculated };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L34-40)
```csharp
    private Hash ComputeRootWithTransactionStatusMerklePath(Hash txId, MerklePath path)
    {
        var txResultStatusRawBytes =
            EncodingHelper.EncodeUtf8(TransactionResultStatus.Mined.ToString());
        var hash = HashHelper.ComputeFrom(ByteArrayHelper.ConcatArrays(txId.ToByteArray(), txResultStatusRawBytes));
        return path.ComputeRootWithLeafNode(hash);
    }
```

**File:** src/AElf.Types/Extensions/MerklePathExtensions.cs (L9-14)
```csharp
        public static Hash ComputeRootWithLeafNode(this MerklePath path, Hash leaf)
        {
            return path.MerklePathNodes.Aggregate(leaf, (current, node) => node.IsLeftChildNode
                ? HashHelper.ConcatAndCompute(node.Hash, current)
                : HashHelper.ConcatAndCompute(current, node.Hash));
        }
```

**File:** src/AElf.Types/Helper/HashHelper.cs (L74-78)
```csharp
        public static Hash ConcatAndCompute(Hash hash1, Hash hash2)
        {
            var bytes = ByteArrayHelper.ConcatArrays(hash1.ToByteArray(), hash2.ToByteArray());
            return ComputeFrom(bytes);
        }
```

**File:** protobuf/aelf/core.proto (L155-165)
```text
message MerklePath {
    // The merkle path nodes.
    repeated MerklePathNode merkle_path_nodes = 1;
}

message MerklePathNode{
    // The node hash.
    Hash hash = 1;
    // Whether it is a left child node.
    bool is_left_child_node = 2;
}
```

**File:** protobuf/token_contract.proto (L478-487)
```text
message CrossChainReceiveTokenInput {
    // The source chain id.
    int32 from_chain_id = 1;
    // The height of the transfer transaction.
    int64 parent_chain_height = 2;
    // The raw bytes of the transfer transaction.
    bytes transfer_transaction_bytes = 3;
    // The merkle path created from the transfer transaction.
    aelf.MerklePath merkle_path = 4;
}
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L5-8)
```csharp
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
}

```

**File:** src/AElf.CSharp.CodeOps/Patchers/Module/CallAndBranchCounts/Patcher.cs (L78-93)
```csharp
    private void InsertBranchCountForAllBranches(ILProcessor processor)
    {
        static bool IsValidInstruction(Instruction instruction)
        {
            var targetInstruction = (Instruction) instruction.Operand;
            return targetInstruction.Offset < instruction.Offset; // What does this mean?
        }

        foreach (var instruction in AllBranchingInstructions.Where(IsValidInstruction))
        {
            var jumpingDestination = (Instruction) instruction.Operand;
            var callBranchCountMethod = processor.Create(OpCodes.Call, _proxy.BranchCountMethod);
            processor.InsertBefore(jumpingDestination, callBranchCountMethod);
            instruction.Operand = callBranchCountMethod;
        }
    }
```

**File:** src/AElf.Kernel.FeeCalculation/Infrastructure/ReadFeeProvider.cs (L15-18)
```csharp
    protected override int GetCalculateCount(ITransactionContext transactionContext)
    {
        return transactionContext.Trace.StateSet.Reads.Count;
    }
```

**File:** protobuf/acs7.proto (L56-58)
```text
    rpc VerifyTransaction (VerifyTransactionInput) returns (google.protobuf.BoolValue) {
        option (aelf.is_view) = true;
    }
```

**File:** src/AElf.Kernel.TransactionPool/Infrastructure/TransactionMethodValidationProvider.cs (L23-35)
```csharp
    public async Task<bool> ValidateTransactionAsync(Transaction transaction, IChainContext chainContext = null)
    {
        var isView = await _transactionReadOnlyExecutionService.IsViewTransactionAsync(chainContext, transaction);
        if (isView)
            await LocalEventBus.PublishAsync(new TransactionValidationStatusChangedEvent
            {
                TransactionId = transaction.GetHash(),
                TransactionResultStatus = TransactionResultStatus.NodeValidationFailed,
                Error = "View transaction is not allowed."
            });

        return !isView;
    }
```

**File:** src/AElf.Types/Types/BinaryMerkleTree.cs (L62-100)
```csharp
        public MerklePath GenerateMerklePath(int index)
        {
            if (Root == null || index >= LeafCount)
                throw new InvalidOperationException("Cannot generate merkle path from incomplete binary merkle tree.");
            var path = new MerklePath();
            var indexOfFirstNodeInRow = 0;
            var nodeCountInRow = LeafCount;
            while (index < Nodes.Count - 1)
            {
                Hash neighbor;
                bool isLeftNeighbor;
                if (index % 2 == 0)
                {
                    // add right neighbor node
                    neighbor = Nodes[index + 1];
                    isLeftNeighbor = false;
                }
                else
                {
                    // add left neighbor node
                    neighbor = Nodes[index - 1];
                    isLeftNeighbor = true;
                }

                path.MerklePathNodes.Add(new MerklePathNode
                {
                    Hash = Hash.LoadFromByteArray(neighbor.ToByteArray()),
                    IsLeftChildNode = isLeftNeighbor
                });

                nodeCountInRow = nodeCountInRow % 2 == 0 ? nodeCountInRow : nodeCountInRow + 1;
                var shift = (index - indexOfFirstNodeInRow) / 2;
                indexOfFirstNodeInRow += nodeCountInRow;
                index = indexOfFirstNodeInRow + shift;
                nodeCountInRow /= 2;
            }

            return path;
        }
```
