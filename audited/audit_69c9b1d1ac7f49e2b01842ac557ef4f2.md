### Title
Round Number Manipulation Bypass in Continuous Blocks Validation Allows Unlimited Block Production

### Summary
A malicious miner can bypass continuous blocks validation by manipulating the `ProvidedRound.RoundNumber` field in consensus extra data to claim they are in round 1 or 2, even when the actual round number is much higher. This allows unlimited continuous block production at any time, not just during genesis, potentially enabling a single miner to monopolize block production and achieve 51% control of the consensus.

### Finding Description

The vulnerability exists in the `ContinuousBlocksValidationProvider` where it checks whether to enforce continuous blocks limits: [1](#0-0) 

The critical flaw is that this validation uses `ProvidedRound.RoundNumber`, which is supplied by the miner in the consensus extra data and not verified against the actual round number stored in contract state: [2](#0-1) 

For `UpdateValue` and `TinyBlock` consensus behaviors, no validator enforces that `ProvidedRound.RoundNumber` must match `BaseRound.RoundNumber` (the actual round from state). The `RoundTerminateValidationProvider`, which validates round number progression, is only added for `NextRound` and `NextTerm` behaviors: [3](#0-2) 

The `BaseRound` used in other validations correctly comes from contract state, independent of miner input: [4](#0-3) 

The attacker can craft a `ProvidedRound` with:
- `RoundNumber = 1` or `2` (to bypass the check)
- Copy all miner information and timing from the current actual round (to pass `RoundId` validation in `TimeSlotValidationProvider`)

Since `RoundId` is calculated from `ExpectedMiningTime` values: [5](#0-4) 

The attacker's manipulated round will have matching `RoundId` with the actual `BaseRound`, passing time slot validation while bypassing continuous blocks limits.

### Impact Explanation

**Consensus Integrity Compromise**: A malicious miner can produce unlimited consecutive blocks by bypassing the continuous blocks validation designed to ensure fair miner rotation. This directly violates the consensus invariant requiring "correct round transitions and time-slot validation, miner schedule integrity."

**Concrete Harm**:
- **Block Production Monopolization**: The attacker can produce all blocks within a round or across multiple rounds, effectively monopolizing block production
- **51% Attack Vector**: By producing unlimited consecutive blocks, the attacker gains disproportionate control over the blockchain, potentially reaching majority control
- **Unfair Reward Distribution**: The attacker receives all mining rewards during their monopoly period, stealing rewards from other legitimate miners
- **Consensus Disruption**: Normal miner rotation is broken, preventing other miners from participating in consensus

**Severity Justification**: Critical - This attack fundamentally breaks the consensus mechanism's fairness guarantees and enables a single miner to dominate the network, representing an existential threat to the blockchain's decentralization and security.

### Likelihood Explanation

**Attacker Capabilities**: The attacker must be a valid miner in the current round's miner list. This is a realistic precondition as the attack targets existing miners, not external actors.

**Attack Complexity**: Low - The attack requires:
1. Being a valid miner (normal precondition)
2. Modifying consensus extra data to set `RoundNumber = 1` or `2`
3. Copying current round's miner information to maintain correct `RoundId`

**Execution Practicality**: The attack is highly practical:
- Can be executed through standard `UpdateValue` or `UpdateTinyBlockInformation` contract methods
- No special privileges required beyond being a miner
- Can be performed at any round, not just during genesis
- The manipulated data passes all current validation checks

**Detection**: The attack is difficult to detect proactively because:
- The blocks appear valid and pass all validation
- Only monitoring of continuous block production patterns would reveal the attack
- By the time detection occurs, significant damage may be done

**Probability**: High - Any miner can execute this attack at will with minimal technical barriers.

### Recommendation

**Immediate Fix**: Add explicit validation that `ProvidedRound.RoundNumber` matches `BaseRound.RoundNumber` for `UpdateValue` and `TinyBlock` behaviors in the validation pipeline.

Add a new validator or extend existing ones:

```csharp
// In AEDPoSContract_Validation.cs, add for UpdateValue and TinyBlock:
case AElfConsensusBehaviour.UpdateValue:
case AElfConsensusBehaviour.TinyBlock:
    validationProviders.Add(new RoundNumberConsistencyValidationProvider());
    // ... existing validators
    break;
```

Create `RoundNumberConsistencyValidationProvider`:

```csharp
public class RoundNumberConsistencyValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        if (validationContext.ProvidedRound.RoundNumber != validationContext.BaseRound.RoundNumber)
            return new ValidationResult { Message = "Provided round number does not match current round." };
        
        return new ValidationResult { Success = true };
    }
}
```

**Additional Hardening**:
- Validate that `ProvidedRound.TermNumber` matches `BaseRound.TermNumber`
- Add integrity checks on other critical `Round` fields to prevent similar manipulation vectors

**Test Cases**: Add regression tests that attempt to:
1. Produce blocks with mismatched `ProvidedRound.RoundNumber` and verify rejection
2. Attempt continuous block production with fake round numbers and verify limits are enforced
3. Verify the fix works across all consensus behaviors

### Proof of Concept

**Initial State**:
- Blockchain is at round 100, term 5
- Attacker is a valid miner in the current round's miner list
- Normal continuous blocks limit is 8 blocks (MaximumTinyBlocksCount)

**Attack Steps**:

1. Attacker queries current round information (round 100) to get miner list and timing
2. Attacker crafts malicious consensus extra data:
   - Create `Round` object with `RoundNumber = 1`
   - Copy `RealTimeMinersInformation` from actual round 100
   - Copy `ExpectedMiningTime` values from actual round 100 (ensures `RoundId` matches)
   - Set attacker's own `OutValue`, `Signature`, etc.
3. Attacker calls `UpdateValue` with this crafted data
4. Validation runs:
   - `MiningPermissionValidationProvider`: PASS (checks `BaseRound` which is correct)
   - `TimeSlotValidationProvider`: PASS (`RoundId` matches due to copied timing)
   - `ContinuousBlocksValidationProvider`: **SKIPPED** (line 13 condition false: `ProvidedRound.RoundNumber = 1 <= 2`)
5. Block is accepted and attacker's continuous block count increments
6. Attacker repeats steps 2-5 indefinitely

**Expected Result**: After 8 continuous blocks, `ContinuousBlocksValidationProvider` should reject further blocks with "Sender produced too many continuous blocks."

**Actual Result**: Attacker can produce unlimited blocks because validation is never performed when `ProvidedRound.RoundNumber <= 2`.

**Success Condition**: Attacker produces more than 8 consecutive blocks (exceeding `MaximumTinyBlocksCount`) without any validation failure, monopolizing block production while other miners are unable to produce blocks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-14)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```
