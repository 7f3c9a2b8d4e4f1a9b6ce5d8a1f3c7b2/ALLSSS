### Title
Parliament Method Fee Controller Can Set Unbounded Fees Creating Unrecoverable Governance Deadlock

### Summary
The Parliament contract's `SetMethodFee` method lacks upper bound validation on fee amounts, allowing the fee controller (Parliament's default organization) to set arbitrarily high fees for critical governance methods like `CreateProposal`. Since transaction execution is blocked when users cannot pay fees, and fixing fees requires creating a proposal, this creates an unrecoverable deadlock that permanently halts governance.

### Finding Description
The vulnerability exists in the `SetMethodFee` implementation where fee validation is insufficient: [1](#0-0) 

The only validation performed is in `AssertValidToken`, which checks for non-negative amounts and token validity: [2](#0-1) 

**Root Cause**: No upper bound validation exists on the `BasicFee` amount. A fee of any magnitude (e.g., 1 trillion ELF) can be set as long as it's non-negative and the token is burnable.

**Execution Flow Leading to Deadlock**:

1. The fee controller (defaulting to Parliament's default organization) creates a proposal to set an extremely high fee for `CreateProposal`: [3](#0-2) 

2. When users attempt to call `CreateProposal`, the pre-execution plugin invokes `ChargeTransactionFees`: [4](#0-3) 

3. If the user's balance is insufficient for the excessive fee, `ChargeTransactionFees` returns `Success = false`: [5](#0-4) 

4. The execution plugin checks this result and blocks transaction execution: [6](#0-5) 

5. **Deadlock**: To fix the fee, Parliament must create a proposal to call `SetMethodFee` again, but `CreateProposal` is blocked by the prohibitive fee. No recovery mechanism exists.

### Impact Explanation
**Operational Impact - Complete Governance Denial of Service**:

- **What harm occurs**: All governance operations are permanently halted. No new proposals can be created for any purpose (fee adjustments, consensus changes, contract upgrades, economic parameter updates).

- **Who is affected**: All network participants, including parliament members, miners, and regular users. The entire governance system becomes non-functional.

- **Protocol damage**: The chain enters an unrecoverable state where:
  - No proposals can be created via the primary `CreateProposal` method [7](#0-6) 
  - Even the emergency response organization cannot bypass this since it also requires `CreateProposal`
  - System contracts using `CreateProposalBySystemContract` are also affected as they go through the same fee charging mechanism
  
- **Severity justification**: This is a HIGH severity vulnerability because it creates a permanent, unrecoverable state that completely disables the governance layer with no built-in recovery mechanism.

### Likelihood Explanation
**Realistic Exploitability - Medium to High**:

- **Attacker capabilities**: Requires ability to create and pass a Parliament proposal. This could occur through:
  1. Malicious proposal that miners fail to carefully review
  2. Accidental misconfiguration (typo in fee amount, e.g., 1000000000000 instead of 1000)
  3. Compromised minority of Parliament members submitting deceptive proposals

- **Attack complexity**: LOW - Single proposal with straightforward parameters:
  ```
  SetMethodFee(MethodFees{
    MethodName: "CreateProposal",
    Fees: [{ Symbol: "ELF", BasicFee: 1000000000000000 }]
  })
  ```

- **Feasibility conditions**: 
  - Requires 2/3 Parliament approval (standard governance threshold)
  - No special technical knowledge needed
  - Can be executed as part of a batch of "routine" fee adjustments to obscure intent

- **Detection constraints**: 
  - Fee changes appear as normal governance operations
  - No automatic validation alerts for excessive fees
  - By the time issue is discovered, recovery is impossible

- **Economic rationality**: Attacker bears no direct cost beyond standard proposal creation fees. The attack is viable for:
  - Malicious miners seeking to disrupt the network
  - Competing chains attempting to damage AElf's governance
  - Accidental execution through human error

### Recommendation
**Implement Maximum Fee Bounds Validation**:

Add upper bound validation in `SetMethodFee`:

```csharp
private void AssertValidToken(string symbol, long amount)
{
    Assert(amount >= 0, "Invalid amount.");
    Assert(amount <= MaximumMethodFee, "Fee exceeds maximum allowed.");  // NEW CHECK
    
    if (State.TokenContract.Value == null)
        State.TokenContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

    Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
        $"Token {symbol} cannot set as method fee.");
}
```

Define reasonable maximum fees (e.g., based on percentage of total supply or fixed ELF amount):

```csharp
private const long MaximumMethodFee = 100_00000000; // 100 ELF maximum
```

**Additional Safeguards**:

1. **Fee Change Rate Limiting**: Require minimum time delay between fee adjustments
2. **Fee Change Bounds**: Limit fee changes to certain percentage increase per proposal
3. **Emergency Fee Reset**: Add privileged method callable only by consensus contract to reset fees in emergency
4. **Validation Events**: Emit warning events when fees are set above certain thresholds

**Test Cases to Add**:

```csharp
[Fact]
public async Task SetMethodFee_ExcessiveAmount_ShouldFail()
{
    var excessiveFee = 1000000_00000000; // 1 million ELF
    var methodFees = new MethodFees {
        MethodName = nameof(CreateProposal),
        Fees = { new MethodFee { Symbol = "ELF", BasicFee = excessiveFee } }
    };
    
    var result = await ParliamentContractStub.SetMethodFee
        .SendWithExceptionAsync(methodFees);
    result.TransactionResult.Error.ShouldContain("Fee exceeds maximum");
}
```

### Proof of Concept

**Initial State**:
- Parliament contract initialized with default organization
- Default organization has MethodFeeController authority
- Multiple miners available for proposal approval

**Attack Steps**:

1. **Create Malicious Proposal**:
   ```
   organizationAddress = GetDefaultOrganizationAddress()
   proposalInput = CreateProposalInput{
     OrganizationAddress: organizationAddress,
     ToAddress: ParliamentContractAddress,
     ContractMethodName: "SetMethodFee",
     Params: MethodFees{
       MethodName: "CreateProposal",
       Fees: [{ Symbol: "ELF", BasicFee: 1000000000000 }]  // 10,000 ELF
     },
     ExpiredTime: CurrentTime + 7 days
   }
   proposalId = CreateProposal(proposalInput)
   ```

2. **Get Miner Approvals**:
   ```
   Approve(proposalId) by Miner1
   Approve(proposalId) by Miner2
   Approve(proposalId) by Miner3
   // 2/3 threshold reached
   ```

3. **Release Proposal** (executes SetMethodFee):
   ```
   Release(proposalId)
   // CreateProposal fee now set to 10,000 ELF
   ```

4. **Verify Governance Deadlock**:
   ```
   // Any user attempts to create new proposal
   result = CreateProposal(anyProposalInput)
   // Expected: Transaction succeeds
   // Actual: Transaction fails with "Pre-Error: Transaction fee not enough."
   
   // Even Parliament cannot fix this
   fixProposal = CreateProposal(lowerFeeProposal)
   // Expected: Parliament can fix fees
   // Actual: Transaction fails - cannot create proposal to lower fees
   
   // Success condition: No new proposals can be created, governance permanently halted
   ```

**Verification**: Check that `GetMethodFee("CreateProposal")` returns the excessive amount, and all subsequent `CreateProposal` calls are rejected at pre-execution with insufficient fee error, confirming the unrecoverable deadlock state.

### Citations

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L62-73)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.DefaultOrganizationAddress.Value,
            ContractAddress = Context.Self
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L80-89)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-53)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }

        // Record tx fee bill during current charging process.
        var bill = new TransactionFeeBill();
        var allowanceBill = new TransactionFreeFeeAllowanceBill();
        var fromAddress = Context.Sender;
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L118-126)
```csharp
        ModifyBalance(fromAddress, bill, allowanceBill);
        var chargingOutput = new ChargeTransactionFeesOutput { Success = chargingResult };
        if (!chargingResult)
            chargingOutput.ChargingInformation = "Transaction fee not enough.";
        
        Context.LogDebug(() => "TryToChargeTransactionFee End");
        Context.LogDebug(() => "ChargeTransactionFees End");
        return chargingOutput;
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L123-129)
```csharp
    public bool IsStopExecuting(ByteString txReturnValue, out string preExecutionInformation)
    {
        var chargeTransactionFeesOutput = new ChargeTransactionFeesOutput();
        chargeTransactionFeesOutput.MergeFrom(txReturnValue);
        preExecutionInformation = chargeTransactionFeesOutput.ChargingInformation;
        return !chargeTransactionFeesOutput.Success;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-66)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```
