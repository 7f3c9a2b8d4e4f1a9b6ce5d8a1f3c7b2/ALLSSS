### Title
Dictionary Enumeration Order Inconsistency Causes Secret Sharing Reconstruction Failure

### Summary
The `RevealSharedInValues()` function uses an unsafe pattern to correlate dictionary keys with values when building input lists for Shamir's Secret Sharing reconstruction. The code assumes consistent enumeration order across multiple enumerations of a protobuf MapField (DecryptedPieces), but this order is not guaranteed, causing potential misalignment between `sharedParts[i]` and `orders[i]`, which breaks secret reconstruction and consensus InValue verification.

### Finding Description

**Location**: The vulnerability exists in the `RevealSharedInValues()` function [1](#0-0) 

An identical pattern exists in the off-chain service [2](#0-1) 

**Root Cause**: The code builds two critical lists for Shamir's Secret Sharing:
1. `orders` - created by enumerating `DecryptedPieces` with `.Select((t, i) => ...)` and internally calling `.Keys.ToList()[i]` for each iteration
2. `sharedParts` - created by separately calling `.Values.ToList()` on the same dictionary

The `DecryptedPieces` field is a protobuf `map<string, bytes>` [3](#0-2) , which in C# becomes a MapField with **undefined enumeration order**.

The code pattern assumes three separate enumerations maintain identical ordering:
- The main `Select` enumeration over DecryptedPieces
- The `.Keys.ToList()[i]` enumeration called inside each iteration
- The `.Values.ToList()` enumeration for sharedParts

Protocol Buffers documentation explicitly states maps are unordered, and C# Dictionary enumeration order is implementation-dependent.

**Why This Matters**: The `SecretSharingHelper.DecodeSecret` method explicitly requires ordered inputs [4](#0-3) . The method uses Lagrange interpolation where `sharedParts[i]` **must** correspond to `orders[i]` for correct polynomial reconstruction [5](#0-4) .

**Execution Path**: This function is invoked during consensus block production [6](#0-5)  when miners need to reveal other miners' previous InValues as part of the AEDPoS consensus mechanism.

### Impact Explanation

**Concrete Harm**:
- If enumeration orders are inconsistent, `sharedParts[i]` gets paired with the wrong `orders[i]`
- Lagrange interpolation produces an incorrect secret reconstruction
- The hash of the incorrect value doesn't match the expected `PreviousInValue`
- Consensus verification of previous InValues fails
- This breaks a critical invariant of the AEDPoS consensus mechanism

**Affected Parties**: All consensus nodes attempting to verify previous round InValues

**Severity Justification**: While the bug might work in practice due to current C# Dictionary implementation maintaining consistent enumeration order within a snapshot, this is:
1. **Not guaranteed** by specification
2. **Not guaranteed** for protobuf MapField
3. **Implementation-dependent** and fragile
4. Could break with runtime updates or different execution environments
5. Creates **non-deterministic** consensus behavior risk

The impact is **High** (consensus integrity violation), but likelihood is **Medium** (depends on implementation details), resulting in **Medium** overall severity.

### Likelihood Explanation

**Feasibility Conditions**:
- No attacker action required - this is a latent code defect
- Triggers automatically during normal consensus operation when revealing InValues
- Current C# Dictionary implementation may maintain consistent order in practice, preventing manifestation
- However, this is not contractually guaranteed and could change

**Probability Assessment**:
- **Current State**: Likely works due to implementation details
- **Risk**: High fragility - could break with:
  - .NET runtime updates
  - Different MapField implementations
  - Hash collision scenarios affecting dictionary ordering
  - Contract execution environment changes

**Operational Constraints**: The bug would manifest as consensus failures, making it detectable but difficult to diagnose due to its intermittent nature.

### Recommendation

**Code-Level Mitigation**:

Replace the unsafe enumeration pattern with explicit ordering:

```csharp
// Create a consistently ordered list of (pubkey, decryptedPiece) pairs
var orderedDecryptedPieces = anotherMinerInPreviousRound.DecryptedPieces
    .OrderBy(kvp => kvp.Key)  // Explicit stable ordering
    .ToList();

// Build orders and sharedParts from the same ordered enumeration
var orders = orderedDecryptedPieces
    .Select(kvp => previousRound.RealTimeMinersInformation.Values
        .First(m => m.Pubkey == kvp.Key).Order)
    .ToList();

var sharedParts = orderedDecryptedPieces
    .Select(kvp => kvp.Value.ToByteArray())
    .ToList();
```

**Invariant Checks**:
- Add assertion that `orders.Count == sharedParts.Count`
- Validate reconstructed InValue matches expected hash before using

**Test Cases**:
- Create test with artificially shuffled dictionary to verify the fix handles ordering correctly
- Test with multiple miners having different enumeration orders
- Add integration test that explicitly validates InValue reconstruction accuracy

Apply the same fix to the identical pattern in [7](#0-6) 

### Proof of Concept

**Required Initial State**:
- AEDPoS consensus with 3+ miners
- Previous round where miners have encrypted and decrypted their InValue shares
- Current round where `RevealSharedInValues` is called

**Reproduction Steps**:
1. Deploy consensus with miners Alice (order 1), Bob (order 2), Charlie (order 3)
2. In round N, Bob creates encrypted shares of his InValue and distributes them
3. All miners decrypt Bob's shares, populating their `DecryptedPieces` dictionary
4. In round N+1, Alice calls consensus update, triggering `RevealSharedInValues`
5. If dictionary enumeration is inconsistent (e.g., due to hash collision or implementation change):
   - `orders` might be built as `[2, 1, 3]` (assuming one enumeration order)
   - `sharedParts` might be built as `[1, 2, 3]` (assuming different enumeration order)
   - `DecodeSecret(sharedParts, orders, threshold)` uses wrong pairings
   - Reconstructed InValue is incorrect

**Expected vs Actual**:
- **Expected**: Bob's PreviousInValue correctly reconstructed and set in `currentRound.RealTimeMinersInformation[Bob].PreviousInValue`
- **Actual (when bug manifests)**: Incorrect InValue reconstructed, consensus validation fails

**Success Condition**: The bug manifests when dictionary enumeration order varies between the three separate enumerations, which while unlikely in current implementations, is not prevented by the code and remains a critical fragility in consensus-critical logic.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-50)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L166-176)
```csharp
            var orders = minerInRound.DecryptedPieces.Select((t, i) =>
                    round.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    minerInRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = minerInRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** protobuf/aedpos_contract.proto (L296-296)
```text
    map<string, bytes> decrypted_pieces = 15;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L43-44)
```csharp
        // The shared parts must be sent in order.
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L48-61)
```csharp
            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```
