### Title
Referendum Threshold Bypass Allows Parliament to Unilaterally Change User Fees with Minimal Token Holder Participation

### Summary
The referendum organization created for user fee governance has a MinimalApprovalThreshold of only 1 token, allowing Parliament (the sole proposer) to effectively bypass meaningful token holder consensus. Any account with just 1 token can approve referendum proposals, making the referendum layer a trivial rubber stamp rather than a legitimate democratic check on Parliament's authority over user fee coefficients.

### Finding Description

The vulnerability exists in the governance structure for changing user transaction fee coefficients through `UpdateCoefficientsForSender`. [1](#0-0) 

The referendum organization is created with extremely permissive thresholds that only require 1 token to approve proposals. Parliament is designated as the sole proposer. [2](#0-1) 

The release threshold check requires approval count >= MinimalApprovalThreshold (1 token) and total votes >= MinimalVoteThreshold (1 token). With MaximalRejectionThreshold and MaximalAbstentionThreshold both set to 0, even a single dissenting vote would block the proposal, but the approval bar is trivially low. [3](#0-2) 

The Approve method uses token-weighted voting where anyone who approves token allowance can vote. The allowance amount is added to ApprovalCount.

The governance flow requires approval from the RootController Association, which has both the Referendum and Parliament organizations as members: [4](#0-3) [5](#0-4) 

The Association requires both member organizations to vote. However, since the Referendum threshold is only 1 token, Parliament can easily satisfy this requirement by creating a referendum proposal and having anyone (including themselves or a colluding party) vote with just 1 token. [6](#0-5) 

The test code demonstrates the governance flow where only 100000 tokens are approved for voting (line 949), but theoretically only 1 token would be sufficient to meet the threshold.

### Impact Explanation

**Governance Bypass**: The referendum layer provides no meaningful decentralization check on Parliament's power to modify user transaction fee coefficients. Fee coefficients directly impact the cost of every transaction on the network.

**Affected Parties**: All network users who pay transaction fees based on these coefficients. The fee calculation formulas determine costs for transaction size fees (Tx type).

**Severity**: Parliament can effectively set arbitrary fee coefficients without broad token holder consensus. While Parliament itself is a multi-signature organization (typically requiring 2/3 BP approval), the referendum layer—intended as an additional democratic safeguard representing all token holders—is reduced to a formality requiring only 1 token.

**Value at Risk**: Not direct theft, but governance capture allowing fee manipulation. Parliament could theoretically increase fees dramatically to tax users, or decrease them to zero, affecting network economics and miner incentives.

### Likelihood Explanation

**Attacker Capabilities**: Parliament (controlled by block producers with 2/3 approval) is the only entity that can create referendum proposals in this organization. Any account with 1 token can approve.

**Attack Complexity**: Low. The exploit requires:
1. Parliament creates a proposal in the Referendum organization to approve the Association proposal
2. Any account (including Parliament itself or minimal colluding party) holds/acquires 1 token
3. That account approves 1 token allowance and votes to approve the referendum proposal
4. Parliament approves the Association proposal directly
5. The Association proposal (now having both member approvals) executes the fee change

**Economic Rationality**: Acquiring 1 token has negligible cost. The governance flow is already implemented and tested.

**Detection**: Proposal creation and voting are on-chain and visible, but the low threshold is by design in the current code, making this a structural weakness rather than an exploit requiring detection.

**Probability**: HIGH. This is not a hypothetical attack—it's how the system is designed to work. The referendum provides no practical barrier beyond what Parliament already controls.

### Recommendation

**Immediate Fix**: Increase MinimalApprovalThreshold and MinimalVoteThreshold to meaningful values representing actual token holder consensus. Recommended approach:

1. Set MinimalApprovalThreshold to a percentage of total supply (e.g., 10-20% of circulating supply)
2. Set MinimalVoteThreshold to similar values to ensure participation
3. Consider setting MaximalRejectionThreshold to allow minority veto (e.g., >33% rejection blocks proposal)
4. Add time-weighted voting or vote locking periods to prevent flash-loan attacks

**Code Change** in `GetReferendumControllerCreateInputForUserFee`:

```csharp
ProposalReleaseThreshold = new ProposalReleaseThreshold
{
    MinimalApprovalThreshold = totalSupply / 10,  // 10% of total supply
    MinimalVoteThreshold = totalSupply / 10,      // 10% participation required
    MaximalRejectionThreshold = totalSupply / 3,  // >33% rejection blocks
    MaximalAbstentionThreshold = totalSupply / 2  // >50% abstention blocks
}
```

**Invariant Check**: Add validation that referendum thresholds represent meaningful participation, not symbolic values.

**Test Cases**: 
- Verify that proposals with <10% token approval cannot be released
- Verify that >33% rejection blocks proposals
- Test that Parliament alone cannot satisfy the referendum threshold

### Proof of Concept

**Initial State**:
- UserFeeController initialized with default configuration
- Parliament is the default Parliament organization (2/3 BP approval)
- Referendum organization created with MinimalApprovalThreshold = 1
- Test account holds 1 token (or any amount ≥1)

**Attack Steps**:

1. Parliament creates proposal to change user fee coefficients via UpdateCoefficientsForSender
2. Parliament creates a proposal in Referendum organization to approve the Association (RootController) proposal
3. Test account (or Parliament member) approves 1 token to the referendum proposal virtual address
4. Test account calls Referendum.Approve with 1 token weight
5. Referendum proposal now has ApprovalCount = 1, meeting MinimalApprovalThreshold = 1
6. Parliament releases the referendum proposal, which calls Association.Approve on the RootController proposal
7. Parliament directly approves the RootController Association proposal
8. Both Association members (Referendum + Parliament) have now approved
9. Parliament releases the RootController proposal, executing UpdateCoefficientsForSender
10. User fee coefficients are changed

**Expected vs Actual**:
- Expected: Referendum should require broad token holder consensus (significant % of supply)
- Actual: Referendum passes with only 1 token approval, providing no meaningful check on Parliament

**Success Condition**: Fee coefficients are modified through the governance flow with only 1 token participating in the "referendum," demonstrating that the referendum layer provides no real decentralization or token holder representation.

### Notes

This is a design flaw rather than an implementation bug. The code works as written, but the governance parameters defeat the stated purpose of having a referendum organization. The two-layer governance (Association requiring both Referendum and Parliament approval) appears intended to balance centralized control (Parliament) with decentralized input (token holders via Referendum), but the 1-token threshold makes the referendum approval trivial to obtain.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L133-156)
```csharp
    private CreateOrganizationBySystemContractInput GetReferendumControllerCreateInputForUserFee(
        Address parliamentAddress)
    {
        var whiteList = new List<Address> { parliamentAddress };
        var tokenSymbol = GetPrimaryTokenSymbol(new Empty()).Value;
        return new CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new CreateOrganizationInput
            {
                TokenSymbol = tokenSymbol,
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1,
                    MinimalVoteThreshold = 1,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { whiteList }
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L158-184)
```csharp
    private Association.CreateOrganizationBySystemContractInput GetAssociationControllerCreateInputForUserFee(
        Address parliamentAddress, Address referendumAddress)
    {
        var proposers = new List<Address>
            { referendumAddress, parliamentAddress };
        return new Association.CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new Association.CreateOrganizationInput
            {
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { proposers }
                },
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = proposers.Count,
                    MinimalVoteThreshold = proposers.Count,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { proposers }
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L70-83)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        var organization = State.Organizations[proposal.OrganizationAddress];
        var allowance = GetAllowance(Context.Sender, organization.TokenSymbol, input);

        proposal.ApprovalCount = proposal.ApprovalCount.Add(allowance);
        State.Proposals[input] = proposal;
        var referendumReceiptCreated = LockToken(organization.TokenSymbol, allowance, input, Context.Sender,
            proposal.OrganizationAddress);
        referendumReceiptCreated.ReceiptType = nameof(Approve);
        Context.Fire(referendumReceiptCreated);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** test/AElf.Contracts.MultiTokenCrossChainTransfer.Tests/MultiTokenContractReferenceFeeTest.cs (L918-962)
```csharp
    private async Task VoteToReferendumAsync(Hash input, string primaryTokenSymbol)
    {
        var organizations = await GetControllerForUserFeeAsync();

        var referendumProposal = new CreateProposalInput
        {
            ToAddress = AssociationContractAddress,
            Params = input.ToByteString(),
            OrganizationAddress = organizations.ReferendumController.OwnerAddress,
            ContractMethodName = nameof(AuthorizationContractContainer.AuthorizationContractStub.Approve),
            ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
        };

        var parliamentProposal = new CreateProposalInput
        {
            ToAddress = ReferendumContractAddress,
            Params = referendumProposal.ToByteString(),
            OrganizationAddress = organizations.ParliamentController.OwnerAddress,
            ContractMethodName = nameof(AuthorizationContractContainer.AuthorizationContractStub.CreateProposal),
            ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
        };
        var ret = await MainChainTesterCreatApproveAndReleaseProposalForParliamentAsync(parliamentProposal);
        var referendumProposalId = ProposalCreated.Parser
            .ParseFrom(ret.Logs.First(l => l.Name.Contains(nameof(ProposalCreated)))
                .NonIndexed).ProposalId;
        var proposalVirtualAddress =
            await ReferendumContractStub.GetProposalVirtualAddress.CallAsync(referendumProposalId);
        var approveResult = await TokenContractStub.Approve.SendAsync(new ApproveInput
        {
            Spender = proposalVirtualAddress,
            Symbol = primaryTokenSymbol,
            Amount = 100000
        });
        await ReferendumContractStub.Approve.SendAsync(referendumProposalId);

        parliamentProposal = new CreateProposalInput
        {
            ToAddress = ReferendumContractAddress,
            Params = referendumProposalId.ToByteString(),
            OrganizationAddress = organizations.ParliamentController.OwnerAddress,
            ContractMethodName = nameof(AuthorizationContractContainer.AuthorizationContractStub.Release),
            ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
        };
        await MainChainTesterCreatApproveAndReleaseProposalForParliamentAsync(parliamentProposal);
    }
```
