### Title
Arithmetic Overflow in LastBlockOfCurrentTermMiningLimit Can Permanently Block Term Transitions

### Summary
The `LastBlockOfCurrentTermMiningLimit` property calculates `MiningInterval.Mul(3).Div(5)` without validating that `MiningInterval` is below the overflow threshold. If `MiningInterval` exceeds `int.MaxValue / 3` (approximately 715,827,882 milliseconds or 8.3 days), the checked multiplication will throw an `OverflowException`, causing all term change transactions to fail permanently and freezing the consensus system in its current term.

### Finding Description

The vulnerability exists in the `LastBlockOfCurrentTermMiningLimit` property: [1](#0-0) 

This property uses SafeMath's `Mul()` extension method which employs checked arithmetic: [2](#0-1) 

The property is invoked during term transitions when producing the last block of a term: [3](#0-2) 

The `MiningInterval` value is set once during blockchain initialization via `FirstRound`: [4](#0-3) 

The value is obtained from `Round.GetMiningInterval()` which returns the millisecond difference between miners' expected mining times: [5](#0-4) 

The only validation performed on mining intervals is in `CheckRoundTimeSlots()`, which only ensures the value is positive but has no upper bound check: [6](#0-5) 

Critically, `MiningInterval` is never updated after initialization - neither in `NextRound` nor in `NextTerm` processing: [7](#0-6) 

### Impact Explanation

If `MiningInterval` is set to a value exceeding `int.MaxValue / 3` (715,827,882 milliseconds â‰ˆ 8.3 days) during blockchain initialization:

1. **Permanent DoS of Term Transitions**: Every attempt to execute `NextTerm` will fail when `TerminateRoundCommandStrategy.GetAEDPoSConsensusCommand()` accesses `LastBlockOfCurrentTermMiningLimit`, throwing `OverflowException`.

2. **Frozen Consensus State**: The blockchain becomes permanently stuck in its current term, unable to update the miner list or progress to subsequent terms.

3. **Economic Impact**: Mining rewards cannot be properly distributed to Treasury, as term transitions trigger reward distribution. Miner list updates are blocked, preventing validator set changes.

4. **No Runtime Recovery**: Since `MiningInterval` is set once during `FirstRound` and never modified, there is no way to recover without redeploying the blockchain.

The severity is HIGH when triggered, as it causes irreversible consensus failure affecting the entire blockchain's ability to manage validator transitions.

### Likelihood Explanation

**Likelihood: LOW to MEDIUM** depending on deployment context:

**Low Likelihood Scenarios:**
- Well-governed main chains with careful genesis configuration review
- Chains using standard configuration values (typical: 4000ms)
- Production deployments with multi-party validation of initialization parameters

**Medium Likelihood Scenarios:**
- Side chains with less rigorous governance
- Test chains or private chains lacking configuration validation
- Automated deployment tools that don't validate upper bounds
- Chains copying configuration without understanding parameter constraints

**Preconditions:**
- Requires setting `MiningInterval > 715,827,882` milliseconds during genesis/FirstRound initialization
- This is a **configuration-time vulnerability**, not a runtime exploitation
- Cannot be triggered by untrusted users; requires control over initialization parameters
- Once set incorrectly, the vulnerability becomes latent until the first term change attempt

**Feasibility:**
The vulnerability is practically executable IF the misconfiguration occurs. The overflow is deterministic and will occur on the first `NextTerm` transaction after improper initialization. The lack of validation makes this misconfiguration possible on any chain without custom initialization checks.

### Recommendation

**Immediate Fix:**
Add input validation during `FirstRound` to enforce an upper bound on `MiningInterval`:

```csharp
public override Empty FirstRound(Round input)
{
    Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");
    
    var miningInterval = input.GetMiningInterval();
    
    // Add validation to prevent overflow in MiningInterval.Mul(3)
    const int maxSafeMiningInterval = int.MaxValue / 3;
    Assert(miningInterval > 0 && miningInterval <= maxSafeMiningInterval, 
           $"Mining interval must be between 1 and {maxSafeMiningInterval} milliseconds.");
    
    State.CurrentTermNumber.Value = 1;
    State.CurrentRoundNumber.Value = 1;
    State.FirstRoundNumberOfEachTerm[1] = 1;
    State.MiningInterval.Value = miningInterval;
    // ... rest of initialization
}
```

**Additional Safeguards:**
1. Add validation in `CheckRoundTimeSlots()` to enforce upper bounds on mining intervals
2. Add similar validation in initialization data providers before generating FirstRound input
3. Document the mathematical constraint: `MiningInterval * 3 must not exceed int.MaxValue`

**Test Cases:**
1. Test `FirstRound` with `MiningInterval = int.MaxValue / 3 + 1` (should fail)
2. Test `FirstRound` with `MiningInterval = int.MaxValue / 3` (should succeed)
3. Test `NextTerm` execution with various valid `MiningInterval` values
4. Verify configuration validation in deployment pipelines

### Proof of Concept

**Required Initial State:**
- Fresh blockchain initialization ready for `FirstRound` call
- MinerList with multiple miners and expected mining times configured with excessive intervals

**Attack Sequence:**

1. **Genesis Configuration**: Set `ConsensusOptions.MiningInterval = 800000000` (exceeds safe threshold of 715,827,882)

2. **Initialize Consensus**: Call `FirstRound` with Round input where:
   ```
   Miner 1 ExpectedMiningTime: T
   Miner 2 ExpectedMiningTime: T + 800,000,000 ms
   GetMiningInterval() returns: 800,000,000
   ```

3. **Normal Operation**: Blockchain operates normally during first term, as `LastBlockOfCurrentTermMiningLimit` is only accessed during term changes

4. **Trigger Failure**: Miner attempts to execute `NextTerm` to change term

**Expected vs Actual Result:**

**Expected (if validation existed):** `FirstRound` should reject the input with error message indicating `MiningInterval` exceeds safe bounds

**Actual:** 
- `FirstRound` succeeds without validation
- `State.MiningInterval.Value` is set to 800,000,000
- First `NextTerm` transaction fails with `System.OverflowException` when accessing `LastBlockOfCurrentTermMiningLimit`
- All subsequent term changes are blocked permanently

**Success Condition:**
Blockchain is stuck in term 1 indefinitely. Any transaction attempting `NextTerm` throws `OverflowException` and fails. Validator set cannot be updated and mining rewards distribution is blocked.

### Notes

This vulnerability represents a **configuration validation gap** rather than a runtime exploitation. While untrusted users cannot trigger it, the lack of input validation during critical initialization creates a systemic risk for chains with weak governance or automated deployment processes. The severity justifies fixing despite the trusted-setup context, as the impact (permanent consensus failure) is catastrophic and there is no runtime recovery mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L60-60)
```csharp
        protected int LastBlockOfCurrentTermMiningLimit => MiningInterval.Mul(3).Div(5);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L13-19)
```csharp
    public static int Mul(this int a, int b)
    {
        checked
        {
            return a * b;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L36-37)
```csharp
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L83-83)
```csharp
        State.MiningInterval.Value = input.GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-47)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```
