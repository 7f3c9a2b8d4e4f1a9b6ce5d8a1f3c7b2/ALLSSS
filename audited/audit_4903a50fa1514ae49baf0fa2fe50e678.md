# Audit Report

## Title
Unvalidated ActualMiningTime Allows Term Transition Manipulation

## Summary
The `UpdateValueValidationProvider` does not validate the `ActualMiningTime` field provided by miners in `UpdateValueInput`, allowing arbitrary timestamps to be stored and used in term transition decisions via `NeedToChangeTerm()`. This enables miners to manipulate when consensus transitions to a new term, affecting election timing, miner set changes, and Treasury releases.

## Finding Description

The validation provider for UpdateValue transactions performs incomplete validation, checking only cryptographic fields while ignoring the temporal field: [1](#0-0) 

The validation verifies `OutValue`, `Signature`, and `PreviousInValue` but completely ignores `ActualMiningTime`. When `ProcessUpdateValue` executes, it unconditionally accepts the miner-provided timestamp: [2](#0-1) 

There is no validation that this timestamp correlates with `Context.CurrentBlockTime` or falls within any reasonable range. The stored `ActualMiningTime` values are then used by `NeedToChangeTerm()` to determine when the consensus should transition to a new term: [3](#0-2) 

This method counts how many miners' latest `ActualMiningTime` meets the threshold for changing terms, requiring a supermajority defined by `MinersCountOfConsent`: [4](#0-3) 

The `NeedToChangeTerm()` result directly determines the consensus behavior: [5](#0-4) 

Post-execution validation cannot detect this issue because `GetCheckableRound()` explicitly excludes `ActualMiningTimes` when computing the round hash for comparison: [6](#0-5) 

## Impact Explanation

Term transitions are critical consensus events that determine:
1. **Miner Set Updates**: When new election results take effect and the active miner list changes
2. **Treasury Releases**: Mining reward distribution timing is tied to term transitions
3. **Governance Timing**: The periodicity of elections and their enforcement [7](#0-6) 

A single malicious miner can contribute false timestamps to delay term transitions (though they need 2/3+ consensus to actually trigger the transition). If 2/3+ miners collude, they gain full control over term transition timing, allowing them to:
- Prevent term changes indefinitely, maintaining control of the miner set
- Force premature term changes before legitimate elections complete
- Disrupt the expected periodicity of Treasury releases and reward distributions

While the 2/3+ threshold provides some protection, the lack of any timestamp validation creates an exploitable weakness in the consensus integrity guarantees.

## Likelihood Explanation

**Entry Point**: The `UpdateValue` method is public and called by every miner during their assigned time slot in every round: [8](#0-7) 

**Preconditions**: An attacker only needs to be an active miner, which is a normal operational role not requiring prior system compromise.

**Execution**: Miners generate consensus transactions locally and can modify the `ActualMiningTime` field before signing and broadcasting. The `UpdateValueInput` structure includes this field, which is extracted from round information but ultimately controlled by the miner's node software: [9](#0-8) 

**Detection Difficulty**: No validation compares `ActualMiningTime` to block timestamps, and no monitoring exists for temporal anomalies. The attack is silent and difficult to detect without manual analysis.

**Economic Rationality**: For a miner facing removal from the miner set, delaying term transitions extends their block reward revenue stream. For colluding miners, controlling term timing provides strategic advantages in maintaining consensus control.

## Recommendation

Add validation in `UpdateValueValidationProvider` to verify that `ActualMiningTime` is reasonable relative to `Context.CurrentBlockTime`. The validation should ensure:

1. `ActualMiningTime` is within a tolerance window of the current block time
2. `ActualMiningTime` is not significantly in the past or future
3. `ActualMiningTime` is monotonically increasing within a round for each miner

Example validation logic to add:
```csharp
// In UpdateValueValidationProvider.ValidateHeaderInformation()
var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
var providedTime = validationContext.ExtraData.Round.RealTimeMinersInformation[validationContext.SenderPubkey]
    .ActualMiningTimes.LastOrDefault();
    
if (providedTime != null)
{
    var currentTime = validationContext.CurrentBlockTime;
    var tolerance = TimeSpan.FromMinutes(5).Milliseconds; // Reasonable tolerance
    
    if (Math.Abs((providedTime - currentTime).Milliseconds()) > tolerance)
        return new ValidationResult { Message = "ActualMiningTime deviates too far from current block time." };
}
```

## Proof of Concept

A PoC would require:
1. Deploy a test AEDPoS consensus network with multiple miner nodes
2. Modify one miner node's consensus transaction generation to provide a false `ActualMiningTime` (e.g., 1 day in the past)
3. Observe that the transaction is accepted and the false timestamp is stored
4. Monitor the `NeedToChangeTerm()` calculation to show it uses the false timestamp
5. Demonstrate that with coordinated false timestamps from 2/3+ miners, term transitions can be delayed or forced prematurely

The vulnerability exists because there is no code path that validates `ActualMiningTime` against any reference timestamp, allowing arbitrary values to influence critical consensus decisions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-243)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-194)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L35-42)
```csharp
        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
```
