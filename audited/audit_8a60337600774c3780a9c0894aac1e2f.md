### Title
Hash Collision Vulnerability in CalculateTokenHash Due to Missing Delimiter

### Summary
The `CalculateTokenHash()` function concatenates symbol and tokenId without a delimiter, allowing different (symbol, tokenId) pairs to produce identical hashes. This causes state corruption across NFT protocols when symbols with overlapping numeric patterns exist, leading to balance confusion, asset theft, and NFT metadata corruption.

### Finding Description
The hash calculation in `CalculateTokenHash()` is deterministic but critically flawed: [1](#0-0) 

The function concatenates symbol and tokenId directly as `$"{symbol}{tokenId}"` without any delimiter. This creates hash collisions when different protocols have symbols where one forms a numeric prefix of another.

**Root Cause:**
The concatenation lacks a separator, so:
- Protocol A with symbol="VW123456789" and tokenId=0 produces hash("VW1234567890")
- Protocol B with symbol="VW12345678" and tokenId=90 produces hash("VW1234567890")

These identical hashes cause state mapping collisions in: [2](#0-1) [3](#0-2) 

**Why Existing Protections Fail:**

The collision check in `PerformMint` only validates uniqueness within a single protocol: [4](#0-3) 

This check uses `protocolInfo.IsTokenIdReuse` flag but doesn't prevent **cross-protocol** hash collisions.

**Attack Path:**

1. Protocol symbols are generated via `GetSymbol()` with minimum 9-digit suffixes: [5](#0-4) [6](#0-5) 

2. However, `CrossChainCreate()` accepts any symbol existing in TokenContract without validating suffix length: [7](#0-6) 

3. MultiToken's symbol validation only requires alphanumeric format: [8](#0-7) 

4. This allows protocols with symbols of varying lengths to coexist, enabling collision attacks.

### Impact Explanation
**Direct Fund Impact:**
- **Balance Corruption**: `State.BalanceMap[tokenHash]` collisions cause balance mixing between different protocols. User A minting NFT from Protocol B inadvertently increases balance for NFT from Protocol A.
- **Asset Theft**: Users can transfer/burn NFTs they don't own if their NFT shares a hash with another user's NFT from a different protocol.
- **Allowance Exploitation**: `State.AllowanceMap[tokenHash]` collisions allow unauthorized spending of allowances set for different NFTs.

**NFT Metadata Corruption**: `State.NftInfoMap[tokenHash]` collisions cause NFT metadata to overwrite each other, destroying provenance and ownership records.

**Severity:** Critical - leads to direct asset theft and permanent state corruption affecting all users of colliding protocols.

### Likelihood Explanation
**Attacker Capabilities Required:**
1. Create a token on a sidechain with a specific symbol format (requires standard token creation permission)
2. Trigger CrossChainCreate to mainchain (standard cross-chain operation)
3. Wait for or influence another protocol creation with overlapping symbol pattern

**Attack Complexity:** Medium
- Attacker needs to predict or influence symbol generation patterns
- Requires coordination across chains
- Symbol collision tracking in `State.IsCreatedMap` prevents exact duplicates but not prefix collisions

**Feasibility Conditions:**
- CrossChainCreate accepts symbols validated only by MultiToken regex (no length enforcement)
- Protocol creation is permissioned but available to legitimate users
- No global check prevents symbol patterns that could cause tokenId-based collisions

**Economic Rationality:** 
Attack cost is limited to token creation fees (~minimal) versus potential gain from stealing high-value NFTs or corrupting major NFT collections. Highly profitable for valuable NFT protocols.

**Probability:** Medium-High - The vulnerability is exploitable once two protocols with colliding symbol patterns exist, which becomes increasingly likely as more protocols are created.

### Recommendation
**Immediate Fix:**
Add a delimiter in hash calculation:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}:{tokenId}");
}
```

**Additional Validation:**
In `CrossChainCreate`, enforce minimum symbol length and validate against existing protocols:

```csharp
// In CrossChainCreate
Assert(input.Symbol.Length >= 11, "Symbol must be at least 11 characters");
var nftTypeShortName = input.Symbol.Substring(0, 2);
var numericSuffix = input.Symbol.Substring(2);
Assert(numericSuffix.Length >= 9, "Numeric suffix must be at least 9 digits");
```

**Invariant to Add:**
Before minting, check that tokenHash doesn't exist in any protocol:
```csharp
var existingNft = State.NftInfoMap[tokenHash];
if (existingNft != null)
{
    Assert(existingNft.Symbol == input.Symbol, 
        "Hash collision detected with different protocol");
}
```

**Test Cases:**
1. Create two protocols with symbols "VW123456789" and "VW12345678"
2. Mint NFT from first with tokenId=0
3. Attempt to mint NFT from second with tokenId=90
4. Verify collision is detected and prevented

### Proof of Concept
**Required Initial State:**
- Token "VW12345678" exists in TokenContract (created on sidechain, cross-chain created to mainchain)
- NFT Protocol A created with symbol "VW123456789" via normal Create()

**Exploit Sequence:**
1. Attacker creates NFT Protocol B via CrossChainCreate with symbol "VW12345678"
2. Attacker mints NFT from Protocol B with tokenId=90 to victim address
   - Hash calculated: `ComputeFrom("VW1234567890")`
3. Victim already owns NFT from Protocol A with tokenId=0
   - Hash: `ComputeFrom("VW1234567890")` (SAME)
4. Attacker's mint increases `State.BalanceMap[hash][victim]` 
5. Attacker calls TransferFrom to steal the inflated balance

**Expected Result:** Mint should fail with collision error

**Actual Result:** Mint succeeds, corrupts state, enables theft

**Success Condition:** `State.BalanceMap[calculatedHash][victim]` shows combined balance from both protocols, allowing unauthorized transfer.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L393-393)
```csharp
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L439-441)
```csharp
        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-86)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L18-21)
```csharp
    private static bool IsValidSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+(-[0-9]+)?$");
    }
```
