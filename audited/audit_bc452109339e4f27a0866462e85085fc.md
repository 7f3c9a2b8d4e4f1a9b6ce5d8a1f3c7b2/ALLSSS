### Title
Vote Inflation via VoteId Reuse in Delegated Voting

### Summary
In delegated voting scenarios (IsLockToken=false), the VoteContract allows the sponsor to provide arbitrary VoteId values without validating uniqueness. A malicious sponsor can repeatedly call Vote with the same VoteId, causing vote amounts to accumulate in VotingResult while overwriting the VotingRecord. Upon withdrawal, only the final recorded amount is subtracted, leaving phantom votes permanently inflating the results.

### Finding Description

**Root Cause:**
The `AssertValidVoteInput` function only performs null checks on `input.Voter` and `input.VoteId` for delegated voting but does not validate VoteId uniqueness. [1](#0-0) 

**Critical Flow:**
When a Vote is cast, the VotingRecord is stored directly by assignment, which overwrites any existing record with the same VoteId: [2](#0-1) 

However, the `UpdateVotingResult` method unconditionally adds the vote amount to the results without checking if this VoteId was used before: [3](#0-2) 

Similarly, `UpdateVotedItems` adds the VoteId to the voter's active votes list without duplicate checking: [4](#0-3) 

**Why Protections Fail:**
In non-delegated voting (IsLockToken=true), VoteId is auto-generated using `votingResult.VotesAmount`, making duplicates unlikely: [5](#0-4) 

However, in delegated voting, the sponsor controls VoteId completely with only a null check. The Election contract demonstrates the proper duplicate prevention pattern using `State.LockTimeMap`: [6](#0-5) 

The Vote contract lacks this critical protection.

### Impact Explanation

**Direct Harm:**
- **Vote Inflation**: Sponsor can artificially multiply vote counts by reusing VoteIds. For example, using the same VoteId twice with amounts 100 and 200 results in 300 total votes in results but only 200 withdrawable, leaving 100 phantom votes.
- **Corrupted Voting Results**: Final tallies become permanently inflated and don't reflect legitimate votes, undermining the integrity of any governance decisions based on these results.
- **Unremovable Votes**: Previous vote amounts become permanently locked in VotingResult with no corresponding VotingRecord to track or remove them.

**Who Is Affected:**
- All participants in delegated voting items
- Any governance or decision-making systems relying on Vote contract results
- Downstream systems (like Election) that depend on accurate vote tallies

**Severity Justification:**
High severity due to:
1. Direct manipulation of voting outcomes affecting governance integrity
2. Permanent corruption of voting data (cannot be remediated after execution)
3. Easy exploitation requiring only multiple calls with same VoteId
4. Violation of critical invariant: vote tallies must accurately reflect actual votes

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be the sponsor of a delegated voting item (IsLockToken=false)
- Requires ability to call the public Vote method multiple times
- No special privileges needed beyond being the sponsor

**Attack Complexity:**
- Very low: Simply call Vote method multiple times with identical VoteId parameter
- No complex transaction sequences or timing requirements
- No need to bypass additional security checks

**Feasibility Conditions:**
- Delegated voting items are explicitly supported by the contract design (for contract-managed voting)
- No rate limiting or duplicate detection exists
- Direct state assignment pattern enables overwrites

**Detection/Operational Constraints:**
- Difficult to detect: Appears as normal voting activity
- Only becomes evident upon withdrawal when amounts don't match
- No events or logs distinguish duplicate VoteId usage from legitimate voting

**Probability:**
High - The exploitation path is straightforward, requires no special conditions, and would be discovered by any sophisticated malicious sponsor testing the contract boundaries.

### Recommendation

**Code-Level Mitigation:**
1. Add duplicate VoteId detection in `AssertValidVoteInput` for delegated voting:
   - Create a state mapping (e.g., `MappedState<Hash, bool> UsedVoteIds`) 
   - Before line 389, add: `Assert(State.UsedVoteIds[input.VoteId] == false, "Vote Id already used.");`
   - After validation, set: `State.UsedVoteIds[input.VoteId] = true;`

2. Alternative approach: Use similar pattern as Election contract with a tracking map that stores additional vote metadata to detect reuse.

**Invariant Checks:**
- Ensure each VoteId maps to exactly one VotingRecord throughout its lifetime
- Verify that sum of all VotingRecord amounts equals VotingResult.VotesAmount
- Add assertion that VoteId doesn't exist in VotingRecords before storing

**Test Cases:**
1. Test delegated voting with duplicate VoteId - should fail
2. Test that VotingResult amounts match sum of active VotingRecords
3. Test withdrawal after duplicate VoteId attempt - verify no phantom votes remain
4. Verify withdrawal fully clears all vote effects from results

### Proof of Concept

**Initial State:**
- Sponsor creates delegated voting item with ID = "VotingItem1", IsLockToken=false, Options=["A", "B"]
- VotingResult for "VotingItem1" shows: Results["A"]=0, VotersCount=0, VotesAmount=0

**Attack Steps:**
1. Sponsor calls Vote:
   - Input: VotingItemId="VotingItem1", VoteId="DUPLICATE_HASH", Voter="0x123...", Amount=100, Option="A"
   - Result: VotingRecord["DUPLICATE_HASH"] = {Amount: 100}, VotingResult["A"] = 100, VotersCount=1

2. Sponsor calls Vote AGAIN with SAME VoteId:
   - Input: VotingItemId="VotingItem1", VoteId="DUPLICATE_HASH", Voter="0x123...", Amount=200, Option="A"
   - Result: VotingRecord["DUPLICATE_HASH"] = {Amount: 200} (overwritten), VotingResult["A"] = 300 (accumulated), VotersCount=2

3. Sponsor calls Withdraw:
   - Input: VoteId="DUPLICATE_HASH"
   - Result: Subtracts 200 from VotingResult["A"] (now 100), VotersCount=1
   - VotingRecord["DUPLICATE_HASH"] marked withdrawn

**Expected vs Actual Result:**
- Expected: Only 200 total votes for Option A after step 2 (replacing previous vote)
- Actual: 300 total votes for Option A after step 2 (accumulation)
- Expected after withdrawal: 0 votes remaining
- Actual after withdrawal: 100 phantom votes permanently in results

**Success Condition:**
VotingResult shows vote count exceeding the sum of all non-withdrawn VotingRecord amounts, proving vote inflation occurred.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L146-161)
```csharp
    private void UpdateVotedItems(Hash voteId, Address voter, VotingItem votingItem)
    {
        var votedItems = State.VotedItemsMap[voter] ?? new VotedItems();
        var voterItemIndex = votingItem.VotingItemId.ToHex();
        if (votedItems.VotedItemVoteIds.ContainsKey(voterItemIndex))
            votedItems.VotedItemVoteIds[voterItemIndex].ActiveVotes.Add(voteId);
        else
            votedItems.VotedItemVoteIds[voterItemIndex] =
                new VotedIds
                {
                    ActiveVotes = { voteId }
                };

        votedItems.VotedItemVoteIds[voterItemIndex].WithdrawnVotes.Remove(voteId);
        State.VotedItemsMap[voter] = votedItems;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L390-398)
```csharp
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L432-434)
```csharp
        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;
```
