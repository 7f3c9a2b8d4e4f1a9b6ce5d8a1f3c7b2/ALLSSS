### Title
Consensus Breakdown via Duplicate Mining Orders Through Broken Validation and Lagrange Interpolation Failure

### Summary
A malicious miner can manipulate `TuneOrderInformation` in `UpdateValue` to assign duplicate `FinalOrderOfNextRound` values to multiple miners. The `NextRoundMiningOrderValidationProvider` fails to detect these duplicates due to a bug where it calls `.Distinct()` on `MinerInRound` objects instead of on the `FinalOrderOfNextRound` values. This leads to duplicate `Order` values in the next round, causing consensus protocol breakdown through `GetMiningInterval()` failures and incorrect Lagrange interpolation in `RevealSharedInValues()`.

### Finding Description

The vulnerability chain consists of three critical components:

**1. Unvalidated TuneOrderInformation Input** [1](#0-0) 

When a miner calls `UpdateValue`, they can provide arbitrary `TuneOrderInformation` that directly sets `FinalOrderOfNextRound` for any miner without validation. [2](#0-1) 

The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue` - it does not check `TuneOrderInformation` for validity or duplicate values.

**2. Broken Duplicate Detection** [3](#0-2) 

The critical bug is that `.Distinct()` is called on `MinerInRound` objects themselves, not on their `FinalOrderOfNextRound` values. Since `MinerInRound` is a protobuf-generated class that doesn't override `Equals()`, this only removes duplicate object references (which never occur) and fails to detect when multiple miners have the same `FinalOrderOfNextRound` value.

**3. Duplicate Orders Propagate to Next Round** [4](#0-3) 

When `GenerateNextRoundInformation` creates the next round, it assigns `Order` based on each miner's `FinalOrderOfNextRound`. If multiple miners have the same `FinalOrderOfNextRound`, they will all receive the same `Order` value in the new round.

**4. Consensus Protocol Breakdown** [5](#0-4) 

The `GetMiningInterval()` method assumes exactly one miner has `Order == 1` and one has `Order == 2`. With duplicate orders (e.g., two miners with `Order == 1`), it would select two miners with identical `ExpectedMiningTime`, computing a mining interval of 0 milliseconds, breaking all time-slot calculations.

**5. Lagrange Interpolation Failure** [6](#0-5) 

When `RevealSharedInValues` constructs the `orders` list from miners' `Order` values, duplicate orders will be included. [7](#0-6) 

In `DecodeSecret`, when `orders[j] == orders[i]` with `i != j`, the denominator term `orders[j] - orders[i]` becomes 0. This propagates through the modular arithmetic operations, ultimately causing `Inverse(0)` to return 0, making the entire Lagrange basis polynomial term evaluate to 0 instead of the correct value, resulting in incorrect secret reconstruction.

### Impact Explanation

**Consensus Protocol Breakdown**: With a mining interval of 0 milliseconds, miners cannot determine their time slots, leading to:
- Multiple miners attempting to produce blocks simultaneously
- Time slot validation failures across the network
- Consensus halt or chaotic block production
- Inability to progress to subsequent rounds

**Secret Sharing Compromise**: Incorrect Lagrange interpolation produces wrong revealed `InValue` reconstructions, undermining:
- The commit-reveal randomness scheme
- Validation of miners' previous in-values
- Detection of dishonest miners who submit incorrect values

**Operational Impact**: The entire blockchain network would experience consensus failure, requiring manual intervention to restore chain operation. All miners, validators, and users are affected.

**Severity**: HIGH - A single malicious miner can halt consensus for the entire network without requiring collusion, significant funds, or special privileges beyond being an active miner.

### Likelihood Explanation

**Attacker Capabilities**: Any active miner in the current round can execute this attack. The attacker only needs to:
1. Be authorized as a miner in the current round
2. Construct a custom `UpdateValue` transaction with malicious `TuneOrderInformation`
3. Submit the transaction during their time slot

**Attack Complexity**: LOW
- No collusion required - a single miner can execute
- No complex cryptographic operations needed
- Transaction construction is straightforward
- No race conditions or timing requirements

**Feasibility**: HIGH [8](#0-7) 

While `ExtractInformationToUpdateConsensus` generates legitimate `TuneOrderInformation`, miners can craft custom transactions with arbitrary values since there is no validation.

**Detection**: The attack succeeds silently through validation and only manifests when the next round begins, making preemptive detection difficult.

**Economic Rationality**: A miner wishing to disrupt the network (e.g., competitor chain, ransom demand, grievance) can execute this at minimal cost.

### Recommendation

**1. Fix NextRoundMiningOrderValidationProvider**

Modify the validation to check for duplicate `FinalOrderOfNextRound` values:

```csharp
var finalOrders = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
var distinctCount = finalOrders.Distinct().Count();
if (distinctCount != finalOrders.Count || 
    distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
{
    validationResult.Message = "Invalid FinalOrderOfNextRound - duplicates detected.";
    return validationResult;
}
```

**2. Validate TuneOrderInformation in UpdateValueValidationProvider**

Add validation to ensure:
- All keys in `TuneOrderInformation` correspond to valid miners in the round
- All values are within valid range [1, minersCount]
- No duplicate values are assigned
- The submitting miner's own `FinalOrderOfNextRound` doesn't conflict

**3. Add Duplicate Order Check in RevealSharedInValues**

Before calling `DecodeSecret`, verify the `orders` list contains no duplicates:

```csharp
if (orders.Count != orders.Distinct().Count())
{
    Context.LogDebug(() => "Duplicate orders detected, skipping revelation for this miner.");
    continue;
}
```

**4. Add Integration Tests**

Create test cases that:
- Attempt to submit `UpdateValue` with duplicate `TuneOrderInformation` values
- Verify validation correctly rejects such transactions
- Confirm `NextRound` fails with duplicate `FinalOrderOfNextRound` values
- Test `GetMiningInterval()` behavior with duplicate orders

### Proof of Concept

**Initial State:**
- Current round N with 5 active miners (MinerA, MinerB, MinerC, MinerD, MinerE)
- All miners have unique orders 1-5
- Secret sharing is enabled

**Attack Steps:**

1. Malicious MinerA produces a block during their time slot
2. MinerA crafts a malicious `UpdateValue` transaction:
   ```
   UpdateValueInput {
       OutValue: [legitimate],
       Signature: [legitimate],
       TuneOrderInformation: {
           "MinerB": 2,
           "MinerC": 2  // Duplicate!
       },
       ...
   }
   ```

3. Transaction passes `UpdateValueValidationProvider` (no `TuneOrderInformation` validation)
4. `ProcessUpdateValue` applies: `MinerB.FinalOrderOfNextRound = 2` and `MinerC.FinalOrderOfNextRound = 2`
5. Current round N completes, miners produce remaining blocks
6. A miner calls `NextRound` with round N+1 information
7. `NextRoundMiningOrderValidationProvider` fails to detect duplicates due to `.Distinct()` bug
8. `GenerateNextRoundInformation` assigns both MinerB and MinerC `Order = 2` in round N+1
9. Round N+1 begins

**Actual Result:**
- `GetMiningInterval()` retrieves miners with `Order == 1` and `Order == 2`, gets MinerA and MinerB (or MinerC)
- If both MinerB and MinerC have identical `ExpectedMiningTime`, interval = 0
- Time slot validation breaks, consensus halts
- `RevealSharedInValues` constructs orders list `[1, 2, 2, 3, 4]` with duplicate 2
- `DecodeSecret` performs Lagrange interpolation with duplicate x-coordinate
- Denominator becomes 0, secret reconstruction produces incorrect result

**Expected Result:**
- `NextRound` validation should reject the round due to duplicate `FinalOrderOfNextRound` values
- Attack should be prevented before round N+1 begins

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L76-80)
```csharp
        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-50)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L52-61)
```csharp
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```
