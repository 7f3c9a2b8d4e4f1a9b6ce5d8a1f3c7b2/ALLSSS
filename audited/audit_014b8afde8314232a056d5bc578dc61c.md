# Audit Report

## Title
Permanent Contract Lock Due to Missing Null/Empty Address Validation in SetContractAuthor

## Summary
The `SetContractAuthor()` function in the Genesis contract (BasicContractZero) lacks validation to prevent setting the contract author to a null or empty address. Once the author field is set to null/empty, the contract becomes permanently un-updatable through all update mechanisms, as every authorization check fails. This creates an irreversible denial-of-service condition with no recovery path.

## Finding Description

The `SetContractAuthor()` method directly assigns `input.NewAuthor` to `info.Author` without validating that the address is non-null and has a non-empty `Value` property. [1](#0-0) 

This violates the standard validation pattern used consistently throughout the AElf codebase. For comparison, the `SetSigner()` method correctly validates address inputs: [2](#0-1) 

This validation pattern appears as a standard practice throughout the codebase, indicating that null/empty addresses are a known concern that requires explicit checks.

Once `info.Author` becomes null or has an empty `Value`, all contract update mechanisms become permanently blocked because every authorization path performs an equality check against the author field:

**1. ProposeUpdateContract path fails:**
The method calls `AssertAuthorityByContractInfo()` which performs: [3](#0-2) [4](#0-3) 

When `contractInfo.Author` is null, both conditions in the assertion fail: `null == Context.Self` evaluates to false (since `Context.Self` is never null), and `Context.Sender == null` is also false (since the sender of a transaction cannot be null). The assertion fails with "No permission."

**2. UpdateUserSmartContract path fails:** [5](#0-4) 

When `info.Author` is null, the check `Context.Sender == null` is always false.

**3. UpdateSmartContract path fails:** [6](#0-5) 

Even if a governance proposal exists and bypasses the check on line 332, the private helper method still validates the author: [7](#0-6) 

While this check uses `author == info.Author`, both would be null, but the real blocker is that no governance proposal can be created in the first place because `ProposeUpdateContract` fails.

**4. SetContractAuthor itself cannot fix the issue:**
It has the same permission check that fails when the author is null.

The protobuf `Address` type is a reference type (class) in C# and can indeed be null: [8](#0-7) 

The `SetContractAuthorInput` message definition confirms both fields are optional protobuf messages: [9](#0-8) 

## Impact Explanation

This vulnerability creates a **permanent denial-of-service** condition:

- The affected contract becomes permanently un-updatable - no entity can ever modify the contract code again
- This impacts both system contracts and user contracts where authors can be set
- There is **no recovery mechanism** - even governance proposals cannot fix this because `ProposeUpdateContract` requires author authorization before creating a proposal
- Contract authors lose the ability to fix bugs, patch vulnerabilities, or add features
- Users of the affected contract are permanently stuck with the current code version
- The chain's ability to evolve and fix critical issues in affected contracts is completely eliminated

The severity is **HIGH** because:
1. The impact is permanent and irreversible
2. It breaks critical authorization invariants in the governance system
3. It causes complete operational denial-of-service for contract updates
4. No mitigation or administrative override exists once triggered

## Likelihood Explanation

The likelihood is **MEDIUM** for the following reasons:

**Trigger Mechanism:**
The legitimate contract author must call `SetContractAuthor()` with a null or empty `NewAuthor` field. This can occur through:
- **Accidental bugs in tooling**: Contract management tools or scripts that incorrectly construct the protobuf message
- **Protobuf default behavior**: Protobuf3 messages have all fields optional - if `NewAuthor` is not explicitly set, it defaults to null
- **Developer error**: Incorrect message construction during contract administration

**Attack Complexity:**
- **LOW** - Only a single transaction from the current contract author is required
- No governance approval or multi-signature is needed
- The transaction is straightforward to construct and submit

**Mitigating Factors:**
- Requires the legitimate author to make the call (not an external attacker)
- Author must have access to their private key

**Aggravating Factors:**
- The validation pattern is used everywhere else in the codebase, indicating developers are aware of null address risks
- The permanent and unrecoverable nature means even a single occurrence is catastrophic
- Many contracts in the ecosystem could be vulnerable simultaneously
- Protobuf's default-null behavior makes accidental triggers realistic

## Recommendation

Add explicit validation to `SetContractAuthor()` to match the pattern used in `SetSigner()` and throughout the codebase:

```csharp
public override Empty SetContractAuthor(SetContractAuthorInput input)
{
    var info = State.ContractInfos[input.ContractAddress];
    Assert(info != null, "Contract not found.");
    
    // Add this validation before any state changes
    Assert(input.NewAuthor != null && !input.NewAuthor.Value.IsNullOrEmpty(), 
           "Invalid new author address.");
    
    var oldAuthor = info.Author;
    Assert(Context.Sender == info.Author, "No permission.");
    info.Author = input.NewAuthor;
    State.ContractInfos[input.ContractAddress] = info;
    Context.Fire(new AuthorUpdated()
    {
        Address = input.ContractAddress,
        OldAuthor = oldAuthor,
        NewAuthor = input.NewAuthor
    });

    return new Empty();
}
```

Additionally, consider adding the same validation to `input.ContractAddress` to ensure both input parameters are valid.

## Proof of Concept

```csharp
[Fact]
public async Task SetContractAuthor_NullAddress_LocksContract_Test()
{
    // Deploy a test contract with a valid author
    var author = SampleAddress.AddressList[0];
    var contractAddress = await DeployTestContract(author);
    
    // Verify initial author is set correctly
    var initialAuthor = await GetContractAuthor(contractAddress);
    initialAuthor.ShouldBe(author);
    
    // Call SetContractAuthor with null NewAuthor (simulating unset protobuf field)
    var setAuthorResult = await ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.SetContractAuthor),
        new SetContractAuthorInput
        {
            ContractAddress = contractAddress,
            NewAuthor = null  // This should be rejected but isn't
        });
    
    // Vulnerability: Transaction succeeds when it should fail
    setAuthorResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify author is now null
    var currentAuthor = await GetContractAuthor(contractAddress);
    currentAuthor.ShouldBeNull();
    
    // Demonstrate permanent lock: ProposeUpdateContract fails
    var proposeResult = await ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.ProposeUpdateContract),
        new ContractUpdateInput
        {
            Address = contractAddress,
            Code = ByteString.CopyFrom(updatedCode)
        });
    proposeResult.Status.ShouldBe(TransactionResultStatus.Failed);
    proposeResult.Error.ShouldContain("No permission");
    
    // Demonstrate permanent lock: SetContractAuthor cannot fix itself
    var fixResult = await ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.SetContractAuthor),
        new SetContractAuthorInput
        {
            ContractAddress = contractAddress,
            NewAuthor = author  // Try to restore original author
        });
    fixResult.Status.ShouldBe(TransactionResultStatus.Failed);
    fixResult.Error.ShouldContain("No permission");
    
    // Contract is now permanently locked - no recovery possible
}
```

## Notes

This vulnerability represents a critical gap in input validation that could cause permanent, irreversible damage to contract upgradeability. The consistent use of the validation pattern elsewhere in the codebase demonstrates that this is an oversight rather than an intentional design decision. The fix is straightforward and should be implemented immediately to prevent accidental or malicious contract locks.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-183)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L324-336)
```csharp
    public override Address UpdateSmartContract(ContractUpdateInput input)
    {
        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        var inputHash = CalculateHashFromInput(input);

        if (!TryClearContractProposingData(inputHash, out _))
            Assert(Context.Sender == info.Author, "No permission.");

        UpdateSmartContract(contractAddress, input.Code.ToByteArray(), info.Author, false);

        return contractAddress;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L445-451)
```csharp
    public override Empty UpdateUserSmartContract(UserContractUpdateInput input)
    {
        AssertInlineDeployOrUpdateUserContract();

        var info = State.ContractInfos[input.Address];
        Assert(info != null, "Contract not found.");
        Assert(Context.Sender == info.Author, "No permission.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L520-535)
```csharp
    {
        var info = State.ContractInfos[input.ContractAddress];
        Assert(info != null, "Contract not found.");
        var oldAuthor = info.Author;
        Assert(Context.Sender == info.Author, "No permission.");
        info.Author = input.NewAuthor;
        State.ContractInfos[input.ContractAddress] = info;
        Context.Fire(new AuthorUpdated()
        {
            Address = input.ContractAddress,
            OldAuthor = oldAuthor,
            NewAuthor = input.NewAuthor
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L537-545)
```csharp
    public override Empty SetSigner(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input.");

        if (State.SignerMap[Context.Sender] == input) return new Empty();

        State.SignerMap[Context.Sender] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L98-102)
```csharp
    private void UpdateSmartContract(Address contractAddress, byte[] code, Address author, bool isUserContract)
    {
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        Assert(author == info.Author, "No permission.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** src/AElf.Types/Types/Address.cs (L20-25)
```csharp
        public int CompareTo(Address that)
        {
            if (that == null) throw new InvalidOperationException("Cannot compare address when address is null.");

            return CompareAddress(this, that);
        }
```

**File:** protobuf/acs0.proto (L310-313)
```text
message SetContractAuthorInput{
    aelf.Address contract_address = 1;
    aelf.Address new_author = 2;
}
```
