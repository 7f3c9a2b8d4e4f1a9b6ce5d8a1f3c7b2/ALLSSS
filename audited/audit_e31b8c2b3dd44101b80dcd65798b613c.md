### Title
Proposal ID Reuse Vulnerability Across All Governance Contracts

### Summary
All three governance contracts (Referendum, Parliament, and Association) allow proposal IDs to be reused with completely different content after proposals are removed from state. An attacker can create a proposal with a specific token value, wait for it to expire or be released, then create a new proposal with the same token but entirely different parameters (target address, method, parameters, title, description), resulting in the same proposal ID mapping to different proposals over time. This breaks governance integrity and creates severe confusion for users and off-chain systems.

### Finding Description

**Root Cause:**
The vulnerability exists in the proposal creation logic across all governance contracts. Proposal IDs are generated using a user-controlled `token` field: [1](#0-0) 

The `CreateNewProposal` function only checks if a proposal ID currently exists in state, not whether it was ever used historically: [2](#0-1) 

**Proposal Removal Paths:**
Proposals are permanently removed from state through two mechanisms:

1. **ClearProposal** - allows anyone to clear expired proposals: [3](#0-2) 

2. **Release** - removes proposals after execution: [4](#0-3) 

**Why Protections Fail:**
The `token` field in `CreateProposalInput` is explicitly designed for deterministic proposal ID generation: [5](#0-4) 

When a proposal is removed via `State.Proposals.Remove()`, the check `Assert(State.Proposals[proposalId] == null, "Proposal already exists.")` passes for the same ID, allowing complete content replacement.

**Systemic Issue:**
This pattern exists identically in Association: [6](#0-5) [7](#0-6) 

And Parliament: [8](#0-7) [9](#0-8) 

### Impact Explanation

**Governance Integrity Compromise (HIGH):**
- **Unique Identifier Violation**: Proposal IDs are meant to uniquely identify specific governance actions. Reuse breaks this fundamental assumption.
- **Historical Inconsistency**: The same proposal ID maps to completely different proposals over time, making historical tracking impossible.
- **Off-chain System Confusion**: Block explorers, wallets, monitoring tools, and governance dashboards that track proposals by ID will display incorrect or conflicting information.
- **User Deception**: Users who previously reviewed and approved a proposal with ID X may encounter a completely different proposal with the same ID X later, leading to confusion and potential governance manipulation.

**Affected Parties:**
- All organizations using Referendum, Parliament, or Association contracts
- Off-chain indexers and explorers tracking proposal history
- Governance participants making decisions based on proposal IDs
- Smart contracts that reference proposal IDs

**Severity Justification:**
While this doesn't directly steal funds, it fundamentally breaks governance integrityâ€”a critical invariant for the protocol. The ability to reuse proposal IDs with different content creates opportunities for social engineering, confusion attacks, and undermines trust in the governance system.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be authorized to create proposals (member of proposer whitelist)
- No special privileges beyond normal proposer rights

**Attack Complexity:**
- **Trivial**: Simply reuse the same `token` value in a new proposal after the original expires or is released
- **No Technical Barriers**: The system is designed to allow deterministic proposal ID generation via the token field

**Feasibility Conditions:**
- Proposals naturally expire or get released/executed regularly in normal operations
- `ClearProposal` is public and can be called by anyone on expired proposals
- No rate limiting or historical tracking prevents reuse

**Execution Practicality:**
1. Create proposal with `token = Hash("X")`, targeting legitimate action
2. Wait for proposal to expire (natural governance flow)
3. Call `ClearProposal` or wait for `Release` to remove it from state
4. Create new proposal with same `token = Hash("X")` but completely different content
5. Same proposal ID now refers to different proposal

**Detection/Operational Constraints:**
- Hard to detect without comprehensive off-chain monitoring
- No on-chain alerts or events indicate proposal ID reuse
- Off-chain systems may not detect the reuse until data conflicts arise

**Probability Reasoning:**
**HIGH** - This is not theoretical; it's an inherent design flaw. Any attacker with proposal creation rights can exploit this immediately with zero technical difficulty.

### Recommendation

**Primary Fix - Add Historical Tracking:**
```csharp
// Add to contract state
State.UsedProposalIds[proposalId] = true;

// In CreateNewProposal, check both current and historical usage
Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
Assert(State.UsedProposalIds[proposalId] == null, "Proposal ID has been used before.");

// Mark as used
State.UsedProposalIds[proposalId] = true;
```

**Alternative Fix - Include Creation Timestamp in ID:**
```csharp
private Hash GenerateProposalId(CreateProposalInput input)
{
    var seed = input.Token ?? HashHelper.ComputeFrom(input);
    // Include block height or timestamp to ensure uniqueness
    return Context.GenerateId(Context.Self, 
        HashHelper.ConcatAndCompute(seed, 
            HashHelper.ComputeFrom(Context.CurrentHeight)));
}
```

**Invariant to Enforce:**
- Each proposal ID must be globally unique across the entire contract lifetime
- Once a proposal ID is used, it can never be reused

**Test Cases to Add:**
```csharp
[Fact]
public async Task CreateProposal_Should_Fail_On_Reused_ProposalId_After_Clear()
{
    // Create proposal with specific token
    var token = HashHelper.ComputeFrom("test");
    var proposalId = await CreateProposalWithToken(token);
    
    // Wait for expiry and clear
    await ClearProposal(proposalId);
    
    // Attempt to create new proposal with same token
    var result = await CreateProposalWithToken(token);
    
    // Should fail with "Proposal ID has been used before"
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
}
```

### Proof of Concept

**Initial State:**
- Organization exists with proposer whitelist containing attacker address
- Token value: `Hash("AttackerToken")`

**Step 1 - Create Initial Proposal:**
```
Call: CreateProposal({
    Token: Hash("AttackerToken"),
    ToAddress: LegitimateContract,
    ContractMethodName: "Transfer",
    Params: "100 tokens to Bob",
    ExpiredTime: CurrentTime + 7 days,
    OrganizationAddress: OrgAddress,
    Title: "Legitimate Transfer",
    Description: "Pay Bob for services"
})
Result: ProposalId = Hash(ContractAddress, Hash("AttackerToken"))
```

**Step 2 - Wait for Expiry:**
```
BlockTime advances past ExpiredTime
```

**Step 3 - Clear Proposal:**
```
Call: ClearProposal(ProposalId)
Result: State.Proposals[ProposalId] removed from state
```

**Step 4 - Create Malicious Proposal with Same ID:**
```
Call: CreateProposal({
    Token: Hash("AttackerToken"),  // SAME TOKEN
    ToAddress: AttackerContract,
    ContractMethodName: "Steal",
    Params: "1000 tokens to Attacker",
    ExpiredTime: CurrentTime + 7 days,
    OrganizationAddress: OrgAddress,
    Title: "Malicious Transfer",
    Description: "Steal funds"
})
Result: SAME ProposalId = Hash(ContractAddress, Hash("AttackerToken"))
```

**Expected vs Actual Result:**
- **Expected**: Transaction should fail with "Proposal ID has been used before"
- **Actual**: Transaction succeeds, creating new proposal with same ID but completely different content

**Success Condition:**
Query `GetProposal(ProposalId)` returns the NEW proposal with malicious content, proving the same ID now maps to different proposal. Off-chain systems tracking this ID will show conflicting data between historical records and current state.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L154-157)
```csharp
    private Hash GenerateProposalId(CreateProposalInput input)
    {
        return Context.GenerateId(Context.Self, input.Token ?? HashHelper.ComputeFrom(input));
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L159-187)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ToAddress = input.ToAddress,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            OrganizationAddress = input.OrganizationAddress,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId, 
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L154-161)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** protobuf/acs3.proto (L91-92)
```text
    // The token is for proposal id generation and with this token, proposal id can be calculated before proposing.
    aelf.Hash token = 7;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L140-173)
```csharp
    private Hash GenerateProposalId(CreateProposalInput input)
    {
        return Context.GenerateId(Context.Self, input.Token ?? HashHelper.ComputeFrom(input));
    }

    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId,
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L220-244)
```csharp
    private Hash GenerateProposalId(CreateProposalInput input)
    {
        return Context.GenerateId(Context.Self, input.Token ?? HashHelper.ComputeFrom(input));
    }

    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L179-186)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```
