# Audit Report

## Title
Non-Deterministic FirstActualMiner() Can Cause Consensus Failure During Blockchain Initialization

## Summary
The `FirstActualMiner()` method in the AEDPoS consensus contract iterates over a protobuf map field without explicit ordering, potentially causing different nodes to select different miners during blockchain initialization. This non-deterministic behavior results in divergent blockchain start timestamps across nodes, breaking consensus determinism and risking chain forks.

## Finding Description

The vulnerability exists in the `FirstActualMiner()` method which uses `FirstOrDefault` on `RealTimeMinersInformation.Values` without applying any ordering. [1](#0-0) 

The `RealTimeMinersInformation` field is defined as a protobuf map, which is backed by `Dictionary<K,V>` in C#. [2](#0-1) 

This method is called during the critical transition from round 1 to round 2 to set the blockchain start timestamp. [3](#0-2) 

At this point in blockchain initialization, multiple miners will have already produced blocks in round 1 and set their `OutValue` fields. Without explicit ordering, `FirstOrDefault(m => m.OutValue != null)` returns whichever miner appears first in the dictionary's enumeration order, which is undefined per the Protocol Buffers specification.

The codebase demonstrates clear awareness of this determinism requirement in similar code paths that correctly apply `OrderBy` before using `FirstOrDefault` or `LastOrDefault`. [4](#0-3) [5](#0-4) 

## Impact Explanation

This vulnerability breaks consensus determinism - a fundamental requirement for blockchain operation. When different nodes execute identical transactions but calculate different blockchain start timestamps, all subsequent time-based consensus calculations diverge:

1. **Miner Count Calculation**: The `GetMinersCount()` method uses blockchain start timestamp to calculate how many miners should be allowed. [6](#0-5) 

2. **Term Change Logic**: The `NeedToChangeTerm()` method calculates whether to change terms based on the blockchain start timestamp. [7](#0-6) 

Different timestamps lead to different consensus decisions, causing nodes to:
- Disagree on valid block producers
- Diverge on term transitions
- Validate blocks differently
- Potentially fork the chain

This is a **HIGH severity** issue because it affects consensus-critical state during blockchain initialization, impacts all nodes, and the failure mode is silent until validation conflicts emerge.

## Likelihood Explanation

During normal blockchain operation with multiple miners:
1. In round 1, miners sequentially produce blocks, each setting their `OutValue` through the `ProcessUpdateValue` transaction
2. When transitioning to round 2 via `ProcessNextRound`, multiple miners will have `OutValue != null`
3. Each node deserializes the same Round state from storage but may enumerate the map in different orders
4. Different nodes potentially select different "first actual miners"

The Protocol Buffers specification explicitly states that "iteration order of map values is undefined." While modern .NET Dictionary implementations maintain insertion order, blockchain consensus cannot depend on such implementation details across platforms, versions, or library updates.

The codebase's own patterns - consistently using `OrderBy` in similar scenarios - demonstrate that developers recognized this determinism requirement but missed this specific instance.

**Preconditions**: Only requires normal multi-miner blockchain operation during initialization, which is the standard use case.

## Recommendation

Apply explicit ordering before using `FirstOrDefault`, consistent with the pattern used elsewhere in the codebase:

```csharp
public MinerInRound FirstActualMiner()
{
    return RealTimeMinersInformation.Count > 0
        ? RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.OutValue != null)
        : null;
}
```

This ensures deterministic selection across all nodes by ordering miners by their assigned `Order` field before selecting the first miner with a non-null `OutValue`.

## Proof of Concept

A proof of concept would require a multi-node test environment where:

1. Initialize a blockchain with multiple miners in round 1
2. Have each miner produce blocks and set their `OutValue` 
3. Trigger the round 1 to round 2 transition on multiple nodes simultaneously
4. Observe that different nodes may select different miners from `FirstActualMiner()`
5. Verify that this results in different `BlockchainStartTimestamp` values across nodes
6. Demonstrate that subsequent consensus calculations diverge

Due to the complexity of setting up a full multi-node consensus environment and the dependency on implementation-specific dictionary ordering behavior, this vulnerability is best validated through code review and understanding of protobuf map determinism requirements rather than a simple unit test.

## Notes

While the practical likelihood of manifestation may vary depending on the specific .NET runtime version and protobuf library implementation, this remains a critical determinism bug that violates blockchain consensus requirements and the codebase's own established patterns. The issue should be fixed to ensure robust consensus across all possible execution environments, platform variations, and future library versions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L150-155)
```csharp
    public MinerInRound FirstActualMiner()
    {
        return RealTimeMinersInformation.Count > 0
            ? RealTimeMinersInformation.Values.FirstOrDefault(m => m.OutValue != null)
            : null;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-243)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }

    /// <summary>
    ///     If periodSeconds == 7:
    ///     1, 1, 1 => 0 != 1 - 1 => false
    ///     1, 2, 1 => 0 != 1 - 1 => false
    ///     1, 8, 1 => 1 != 1 - 1 => true => term number will be 2
    ///     1, 9, 2 => 1 != 2 - 1 => false
    ///     1, 15, 2 => 2 != 2 - 1 => true => term number will be 3.
    /// </summary>
    /// <param name="blockchainStartTimestamp"></param>
    /// <param name="termNumber"></param>
    /// <param name="blockProducedTimestamp"></param>
    /// <param name="periodSeconds"></param>
    /// <returns></returns>
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
    }
```

**File:** protobuf/aedpos_contract.proto (L247-247)
```text
    map<string, MinerInRound> real_time_miners_information = 2;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L97-98)
```csharp
        var latestSignature = currentRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .LastOrDefault(m => m.Signature != null)?.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L117-123)
```csharp
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L112-113)
```csharp
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```
