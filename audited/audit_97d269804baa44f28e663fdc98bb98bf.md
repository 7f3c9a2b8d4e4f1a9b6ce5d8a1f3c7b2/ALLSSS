### Title
Race Condition in EnableConnector: Token Supply/Balance Can Change Between Deposit Calculation and State Update

### Summary
The `EnableConnector()` function calculates the required deposit amount based on current token supply, but if the resource token has a transfer callback configured, the token supply can be manipulated between the calculation and when the deposit balance is recorded. This violates the checks-effects-interactions pattern and can lead to under-collateralization of the connector pair.

### Finding Description

The vulnerability exists in the `EnableConnector()` function where there is a time-of-check to time-of-use (TOCTOU) race condition: [1](#0-0) 

The execution flow is:

1. **Line 276**: `GetNeededDeposit(input)` is called, which reads the current token supply and balance: [2](#0-1) 

2. **Lines 277-285**: Base token (ELF) deposit is transferred to the contract

3. **Lines 287-295**: Resource token is transferred from sender to contract - **VULNERABILITY POINT**

4. **Line 297**: Deposit balance is set to the originally calculated amount

The vulnerability occurs because the MultiToken contract executes transfer callbacks: [3](#0-2) [4](#0-3) 

If the resource token has a transfer callback configured (via the `TransferCallbackExternalInfoKey`), the callback executes via `Context.SendInline` during step 3. This callback can:
- Mint additional resource tokens (increasing total supply)
- Burn resource tokens (decreasing total supply)  
- Manipulate token balances

After the callback executes, the deposit balance is set (line 297) using the stale calculation from step 1, which no longer reflects the actual token distribution.

### Impact Explanation

**Direct Fund Impact - Under-collateralization:**

The Bancor formula in the TokenConverter relies on maintaining a specific relationship between the deposit balance and token supply. The deposit is calculated to ensure that if all tokens outside the converter are sold back, there is sufficient base token to purchase them: [5](#0-4) 

**Concrete Attack Scenario:**
- Initial state: Token total supply = 1,000, AmountToTokenConvert = 100
- Calculated amountOutOfTokenConvert = 900
- Calculated needDeposit = BancorFormula(900) = X ELF
- During resource token transfer callback: Attacker mints 100,000 more tokens
- New total supply = 101,000, actual tokens outside = 100,900
- But deposit balance is set to X (calculated for only 900 tokens)

The deposit is now drastically insufficient. When users attempt to sell the resource tokens: [6](#0-5) 

The selling mechanism uses the deposit balance in pricing calculations. With insufficient deposit, either:
1. The contract cannot fulfill sell orders, causing DoS
2. If the deposit runs out, later sellers lose funds
3. The pricing becomes incorrect, allowing exploitation

**Who is affected:** All users attempting to sell the affected resource token would be impacted by incorrect pricing or inability to sell.

### Likelihood Explanation

**Attack Complexity: MEDIUM**

**Prerequisites:**
1. A connector must be added for the malicious token via `AddPairConnector` (requires Parliament approval)
2. The token must have a transfer callback configured in ExternalInfo during creation: [7](#0-6) 

3. EnableConnector is publicly callable without authorization checks (unlike other management functions)

**Feasibility Conditions:**

The attack requires one of two scenarios:

1. **Parliament Error Scenario**: Parliament approves a connector for a token with a malicious transfer callback. While Parliament should vet tokens, this represents a governance failure rather than an impossibility.

2. **Buggy Token Scenario**: A legitimately-intentioned token has a transfer callback that unintentionally manipulates supply (e.g., a bug in callback logic or unintended cross-contract interaction during transfer).

**Likelihood Assessment: LOW to MEDIUM**

While Parliament governance provides a control, this vulnerability represents a fundamental design flaw that violates the checks-effects-interactions pattern. Defense-in-depth principles suggest smart contracts should not rely solely on external governance to prevent exploitable code paths. Additionally, bugs in complex token callback logic could trigger this unintentionally.

### Recommendation

**Fix: Implement Reentrancy Guard and Recalculate After Transfers**

1. Add a reentrancy guard to prevent recursive calls during EnableConnector
2. Recalculate the deposit requirement AFTER all transfers complete, or
3. Move the deposit balance assignment before the resource token transfer:

```
Recommended order:
1. Calculate needDeposit = GetNeededDeposit(input)
2. Transfer base token deposit  
3. SET State.DepositBalance BEFORE resource token transfer
4. Transfer resource token (callback cannot affect already-set balance)
5. Verify final state matches expectations
6. Enable connectors
```

**Invariant Check:**
After EnableConnector completes, verify:
```
actualTokensOutside = CurrentTotalSupply - ConverterBalance
calculatedDeposit >= BancorFormula(actualTokensOutside)
```

**Test Cases:**
1. Test EnableConnector with a token that has a transfer callback that mints tokens during transfer
2. Test EnableConnector with a token that has a transfer callback that burns tokens during transfer
3. Verify deposit balance matches actual token distribution after all transfers complete

### Proof of Concept

**Initial State:**
- Resource token "MAL" created with transfer callback configured
- Parliament approves AddPairConnector for "MAL"
- Total supply of MAL = 10,000 tokens
- Converter balance = 0
- Attacker owns 1,000 MAL tokens

**Attack Steps:**

1. Attacker calls EnableConnector with:
   - TokenSymbol = "MAL"
   - AmountToTokenConvert = 1,000

2. GetNeededDeposit calculates:
   - amountOutOfTokenConvert = 10,000 - 0 - 1,000 = 9,000
   - needDeposit = BancorFormula(9,000) ≈ X ELF

3. X ELF is transferred from attacker to TokenConverter

4. During TransferFrom of 1,000 MAL tokens:
   - Transfer callback is triggered
   - Callback mints 1,000,000 additional MAL tokens
   - New total supply = 1,010,000

5. State.DepositBalance is set to X (calculated for 9,000 tokens outside)

6. Actual tokens outside = 1,010,000 - 1,000 = 1,009,000 tokens

**Expected vs Actual:**
- Expected: Deposit sufficient for 9,000 tokens
- Actual: Deposit is X but should be BancorFormula(1,009,000) ≈ 112X
- Result: Connector is under-collateralized by ~99%

**Success Condition:**
State.DepositBalance << BancorFormula(actualTokensOutside), enabling attacker to sell tokens at incorrect prices or drain the deposit.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L62-73)
```csharp
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(
            new GetTokenInfoInput
            {
                Symbol = input.TokenSymbol
            });
        var balance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = input.TokenSymbol
            }).Balance;
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L75-84)
```csharp
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L91-93)
```csharp
        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-346)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-13)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
```
