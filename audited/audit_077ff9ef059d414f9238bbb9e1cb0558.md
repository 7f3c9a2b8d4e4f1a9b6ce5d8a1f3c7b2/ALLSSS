### Title
DataCentersRankingList Allows Negative Vote Amounts via Quit-Reannounce-Withdraw Sequence

### Summary
The DataCentersRankingList can contain negative vote amounts when a candidate quits election (with outstanding votes), re-announces, and then voters withdraw. This occurs because QuitElection removes the candidate from the ranking list but preserves their CandidateVotes, and re-announcing adds them back with value 0. Subsequent withdrawals subtract from this 0 value, creating negative amounts that break ranking comparisons and cause incorrect candidate replacements.

### Finding Description

The vulnerability exists in the interaction between three operations:

**1. QuitElection removes candidate from ranking list but not CandidateVotes:** [1](#0-0) 

When a candidate quits, their ranking list entry is set to 0 and then removed, but their CandidateVotes (which tracks actual vote amounts) is NOT cleared. The candidate is marked as `IsCurrentCandidate = false` but vote records persist.

**2. Re-announcing adds candidate back to ranking list with value 0:** [2](#0-1) [3](#0-2) 

When re-announcing, the candidate is added back with value 0 if space exists, regardless of their existing CandidateVotes amount.

**3. Withdraw subtracts from ranking list without checking if value would go negative:** [4](#0-3) 

The withdrawal operation checks if the candidate exists in the ranking list but does NOT verify that the subtraction would result in a non-negative value. The SafeMath.Sub() method uses C# `checked` blocks: [5](#0-4) 

However, `checked` only prevents overflow/underflow beyond the `long` type's bounds (-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807). The operation `0 - 1000 = -1000` is within valid range and does NOT throw an exception, resulting in a negative value in the ranking list.

**4. Negative values break ranking comparisons:** [6](#0-5) [7](#0-6) [8](#0-7) 

These comparisons using `x.Value < amountAfterWithdraw`, `OrderBy(x => x.Value)`, and `voteAmount <= minimumVoteCandidateInDataCenter.Value` treat negative values as legitimately "less than" positive values, causing candidates with negative amounts to be incorrectly identified as minimum-vote candidates for replacement.

### Impact Explanation

**Direct Impacts:**
1. **Ranking System Corruption**: Candidates with negative vote amounts are ranked below all candidates with 0 or positive votes, regardless of their actual vote support
2. **Unfair Candidate Replacement**: Candidates with negative values become prime targets for replacement, losing their data center position and subsidy benefits despite potentially having legitimate voter support
3. **Subsidy Misallocation**: The ranking list determines profit subsidy distribution [9](#0-8) 

Candidates with negative values lose subsidy access unfairly.

4. **Voting System Integrity Breach**: The fundamental assumption that vote amounts are non-negative is violated, breaking the election mechanism's mathematical invariants

**Affected Parties:**
- Candidates who quit and re-announce lose fair ranking position
- Voters whose votes result in negative amounts lose expected voting power
- The election system's credibility and fairness is compromised

**Severity Justification**: HIGH - This breaks a critical invariant of the voting system (vote amounts must be non-negative), enables manipulation of candidate rankings, and affects economic rewards distribution. The validation data center selection process, which is central to the consensus mechanism, relies on this ranking data.

### Likelihood Explanation

**Attack Complexity**: LOW
- Requires only standard election contract operations (announce, vote, quit, re-announce, withdraw)
- No special permissions needed beyond being a candidate admin and having voters

**Feasible Preconditions**:
1. A candidate must announce election and be added to the ranking list (requires `Candidates.Count <= MinersCount * 5`) [10](#0-9) 
2. Voters vote for the candidate
3. Candidate quits election (requires admin permission and not being a current miner)
4. Candidate re-announces (same space availability condition as step 1)
5. Voters withdraw their votes after lock time expires

**Realistic Scenarios**:
- **Accidental**: A candidate faces technical issues, quits, resolves them, and re-announces. Original voters withdraw naturally after lock periods expire
- **Malicious**: A candidate admin intentionally executes quit-reannounce to manipulate their ranking after accumulating votes, then coordinates with voters to withdraw
- **Griefing**: An attacker votes for a candidate they control, forces quit/re-announce sequence, then withdraws to give the candidate negative votes

**Detection Difficulty**: The negative value persists in state and affects all subsequent ranking operations until corrected through new votes. There is no automatic validation or correction mechanism.

**Probability Assessment**: MEDIUM-HIGH - While it requires a specific sequence, this can occur through normal operational patterns (candidate downtime/rejoining) or deliberate manipulation.

### Recommendation

**1. Add non-negativity check in Withdraw:**
```
Before line 674 in ElectionContract_Elector.cs, add:
var currentAmount = rankingList.DataCenters[newestPubkey];
if (currentAmount < votingRecord.Amount)
{
    // Candidate ranking list value is less than withdrawal amount
    // This should not happen in normal operation - treat as corrupted state
    // Remove candidate from ranking list instead of allowing negative value
    rankingList.DataCenters.Remove(newestPubkey);
    UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, newestPubkey, true);
}
else
{
    rankingList.DataCenters[newestPubkey] = currentAmount.Sub(votingRecord.Amount);
    UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, newestPubkey);
}
```

**2. Reset ranking list value on re-announce:**
```
In AnnounceElection (lines 112-116 of ElectionContract_Candidate.cs), change:
if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
{
    var candidateVotes = State.CandidateVotes[pubkey];
    var voteAmount = candidateVotes?.ObtainedActiveVotedVotesAmount ?? 0;
    State.DataCentersRankingList.Value.DataCenters.Add(pubkey, voteAmount);
    RegisterCandidateToSubsidyProfitScheme(pubkey);
}
```

**3. Add invariant validation:**
Create a helper method to validate that all ranking list values are non-negative, callable after operations that modify the ranking list.

**4. Add regression test:**
Test case covering: announce → vote → quit → re-announce → withdraw sequence, asserting that ranking list values remain non-negative throughout.

### Proof of Concept

**Initial State:**
- MinersCount = 5 (GetValidationDataCenterCount = 25)
- 10 candidates announced (all in ranking list)
- Candidate A is one of these 10

**Step 1: User votes for Candidate A**
```
Transaction: Vote(candidatePubkey: A, amount: 1000, lockTime: 90 days)
State After:
- CandidateVotes[A].ObtainedActiveVotedVotesAmount = 1000
- DataCentersRankingList.DataCenters[A] = 1000
```

**Step 2: Candidate A quits**
```
Transaction: QuitElection(pubkey: A)
State After:
- CandidateInformationMap[A].IsCurrentCandidate = false
- Candidates.Count = 9
- DataCentersRankingList.DataCenters[A] = REMOVED (not present)
- CandidateVotes[A].ObtainedActiveVotedVotesAmount = 1000 (UNCHANGED)
```

**Step 3: Candidate A re-announces**
```
Transaction: AnnounceElection(admin: A's admin)
State After:
- CandidateInformationMap[A].IsCurrentCandidate = true
- Candidates.Count = 10
- Candidates.Count (10) <= GetValidationDataCenterCount (25) = TRUE
- DataCentersRankingList.DataCenters[A] = 0 (ADDED WITH ZERO)
- CandidateVotes[A].ObtainedActiveVotedVotesAmount = 1000 (STILL UNCHANGED)
```

**Step 4: User withdraws vote (after lock expires)**
```
Transaction: Withdraw(voteId: <vote_id_from_step_1>)
State After:
- CandidateVotes[A].ObtainedActiveVotedVotesAmount = 0
- DataCentersRankingList.DataCenters[A] = 0 - 1000 = -1000 (NEGATIVE!)
```

**Result:**
- Candidate A now has -1000 in DataCentersRankingList
- Any comparison like `OrderBy(x => x.Value).First()` will select A as minimum
- A will be replaced by any candidate with votes >= -1000 (essentially any candidate)
- A loses subsidy profit share despite being a legitimate candidate

**Success Condition:**
The vulnerability is confirmed if `DataCentersRankingList.DataCenters[A] < 0` after the withdrawal in Step 4, which breaks the invariant that vote amounts must be non-negative.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L112-116)
```csharp
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L154-162)
```csharp
        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L211-218)
```csharp
    private void RegisterCandidateToSubsidyProfitScheme(string candidatePubkey)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        AddBeneficiary(candidatePubkey);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L262-268)
```csharp
        var dataCenterList = State.DataCentersRankingList.Value;
        if (dataCenterList.DataCenters.ContainsKey(pubkey))
        {
            dataCenterList.DataCenters[pubkey] = 0;
            UpdateDataCenterAfterMemberVoteAmountChanged(dataCenterList, pubkey, true);
            State.DataCentersRankingList.Value = dataCenterList;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L671-676)
```csharp
        var rankingList = State.DataCentersRankingList.Value;
        if (!rankingList.DataCenters.ContainsKey(newestPubkey)) return new Empty();
        rankingList.DataCenters[newestPubkey] =
            rankingList.DataCenters[newestPubkey].Sub(votingRecord.Amount);
        UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, newestPubkey);
        State.DataCentersRankingList.Value = rankingList;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L688-689)
```csharp
        else if (rankingList.DataCenters.Any(x => x.Value < amountAfterWithdraw))
            return;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L721-723)
```csharp
            if (maxVoteAmountOutOfDataCenter <= amountAfterWithdraw)
                return;
            rankingList.DataCenters.Remove(targetMember);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L741-742)
```csharp
        var minimumVoteCandidateInDataCenter = list.OrderBy(x => x.Value).First();
        if (voteAmount <= minimumVoteCandidateInDataCenter.Value) return;
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L406-409)
```csharp
    private int GetValidationDataCenterCount()
    {
        return GetMinersCount(new Empty()).Value.Mul(5);
    }
```
