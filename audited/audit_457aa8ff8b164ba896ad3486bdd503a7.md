### Title
Miner List Manipulation in NextRound Transition Bypasses Consensus Validation

### Summary
The `ValidationForNextRound()` function fails to validate that the miner list in the next round matches the current round's miner list. An attacker who is the extra block producer can craft a `NextRoundInput` with an arbitrary miner list (adding, removing, or reordering miners) that passes all validation checks, permanently corrupting the consensus miner schedule and gaining control over block production.

### Finding Description

The root cause is in the `RoundTerminateValidationProvider.ValidationForNextRound()` method, which only validates two properties of the next round: [1](#0-0) 

This validation is critically incomplete. It checks:
1. Round number increments by 1 (line 29-30)
2. All `InValue` fields are null (lines 32-34)

**Missing validation**: It does NOT verify that the set of miners in `extraData.Round.RealTimeMinersInformation.Keys` matches the miners in `validationContext.BaseRound.RealTimeMinersInformation.Keys`.

The validation flow in `ValidateBeforeExecution` adds the following providers for NextRound behavior: [2](#0-1) 

The `NextRoundMiningOrderValidationProvider` only validates internal consistency of the provided round (that miners with `FinalOrderOfNextRound > 0` match those with `OutValue != null`), but for a freshly generated next round, both counts are zero, so this check trivially passes: [3](#0-2) 

The `MiningPermissionValidationProvider` only checks that the sender is in the **current** round's miner list, not that the next round's miner list is correct: [4](#0-3) 

When a properly generated next round is created, it preserves the current round's miner list: [5](#0-4) 

The method pulls miners from the current round via `GetMinedMiners()` and `GetNotMinedMiners()`, which iterate over `RealTimeMinersInformation` from the current round: [6](#0-5) 

However, the `ProcessNextRound` method simply stores the provided next round without validating the miner list: [7](#0-6) 

The `AddRoundInformation` method stores the round without any miner list validation: [8](#0-7) 

### Impact Explanation

**Consensus Integrity Compromise (Critical):**
- An attacker gains complete control over the consensus miner schedule by manipulating the miner list in the next round
- Can add unauthorized miners (including adding themselves multiple times for additional mining slots and rewards)
- Can remove legitimate miners, effectively performing a DoS attack on honest validators
- Can reorder miners to maximize their own mining opportunities and block rewards

**Quantified Damage:**
- Complete breakdown of the DPoS consensus mechanism
- Attacker can produce consecutive blocks indefinitely by controlling the miner list
- Can censor transactions by excluding honest miners
- Can double the attacker's block rewards by adding themselves twice to the miner list
- Permanent corruption requiring emergency chain halt and rollback

**Affected Parties:**
- All network participants lose consensus security guarantees
- Legitimate miners lose mining slots and rewards
- Users face transaction censorship and potential double-spend attacks
- Chain governance is compromised as the attacker controls block production

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be a legitimate miner in the current round (achievable through normal election process)
- Must become the extra block producer for a single round (happens deterministically based on signature randomness)
- No special privileges beyond being an elected miner

**Attack Complexity:**
- **Low complexity**: Only requires crafting a malicious `NextRoundInput` message with manipulated `RealTimeMinersInformation` keys
- Attacker calls the public `NextRound` method (accessible via consensus command generation): [9](#0-8) 

**Feasibility Conditions:**
- Extra block producer role rotates among miners, so any elected miner will eventually get this opportunity
- No cryptographic commitment or signature verification binds the miner list
- The validation gap is deterministic and always exploitable

**Detection Constraints:**
- The malicious round passes all validation checks, making the attack invisible to honest nodes
- Honest nodes will accept and propagate the corrupted block
- Detection only occurs when legitimate miners are unexpectedly excluded from mining

**Probability Assessment:**
- **High**: Every elected miner becomes the extra block producer periodically (typically every round or few rounds)
- **Guaranteed success**: No randomness or guessing involved; if validation checks pass, the attack succeeds
- **Reproducible**: Can be executed repeatedly whenever the attacker is the extra block producer

### Recommendation

Add miner list validation to `ValidationForNextRound()` in `RoundTerminateValidationProvider.cs`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing round number check
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // Existing InValue check
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Validate miner list consistency
    if (!extraData.Round.IsMinerListJustChanged)
    {
        var baseMiners = validationContext.BaseRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        var nextMiners = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        
        if (!baseMiners.SequenceEqual(nextMiners))
            return new ValidationResult { Message = "Miner list does not match current round. Expected same miners unless IsMinerListJustChanged is true." };
    }
    
    return new ValidationResult { Success = true };
}
```

**Additional Safeguards:**
1. When `IsMinerListJustChanged` is true, validate that the change is authorized (e.g., from election contract miner replacement)
2. Add integration tests that attempt to craft malicious `NextRoundInput` with manipulated miner lists and verify they are rejected
3. Add assertion in `ProcessNextRound` as defense-in-depth to validate miner list before calling `AddRoundInformation`

### Proof of Concept

**Initial State:**
- Current round N has 5 legitimate miners: {MinerA, MinerB, MinerC, MinerD, MinerE}
- MinerA is the extra block producer for round N
- Round N is progressing normally

**Attack Sequence:**

**Step 1**: MinerA (attacker) is selected as extra block producer for round N based on deterministic calculation

**Step 2**: Instead of calling the legitimate consensus flow, MinerA crafts a malicious `NextRoundInput`:
```
NextRoundInput {
  RoundNumber: N + 1,  // Correct increment
  TermNumber: T,       // Same term
  RealTimeMinersInformation: {
    "MinerA": { Order: 1, InValue: null, ... },
    "MinerA_Clone": { Order: 2, InValue: null, ... },  // ADDED: Duplicate slot for attacker
    "EvilMiner": { Order: 3, InValue: null, ... },      // ADDED: Unauthorized miner
    "MinerB": { Order: 4, InValue: null, ... }
    // REMOVED: MinerC, MinerD, MinerE (legitimate miners excluded)
  },
  IsMinerListJustChanged: false  // Claiming no change to bypass additional checks
}
```

**Step 3**: MinerA calls `NextRound(maliciousInput)`

**Step 4**: Validation executes:
- `MiningPermissionValidationProvider`: Checks MinerA is in round N → **PASS** (MinerA is legitimate)
- `TimeSlotValidationProvider.CheckRoundTimeSlots()`: Checks time intervals → **PASS** (MinerA sets proper spacing)
- `NextRoundMiningOrderValidationProvider`: Checks `FinalOrderOfNextRound count == OutValue count` → **PASS** (0 == 0)
- `RoundTerminateValidationProvider.ValidationForNextRound()`:
  - Checks `RoundNumber == N + 1` → **PASS**
  - Checks all `InValue == null` → **PASS**
  - **MISSING**: No check that miner list matches → **EXPLOITABLE**

**Step 5**: `ProcessNextRound` executes and calls `AddRoundInformation(maliciousRound)` which stores the corrupted round

**Expected Result**: Validation should reject the malicious round due to miner list mismatch

**Actual Result**: Validation passes; the corrupted round N+1 is stored with:
- MinerA gets 2 mining slots (double rewards)
- EvilMiner gains unauthorized mining access
- MinerC, MinerD, MinerE are excluded from consensus (DoS)

**Success Condition**: After the attack, `GetCurrentMinerList()` returns `{MinerA, MinerA_Clone, EvilMiner, MinerB}` instead of the expected `{MinerA, MinerB, MinerC, MinerD, MinerE}`, proving consensus corruption.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-24)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-23)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-135)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }

    private List<MinerInRound> GetNotMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound == 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
