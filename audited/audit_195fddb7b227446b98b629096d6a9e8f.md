### Title
Missing Period Expiration Validation Allows Premature Term Changes

### Summary
The consensus validation logic fails to verify that term changes occur only when the required period has expired and 2/3+1 miners consent. A malicious miner can force a term change prematurely by providing `NextTerm` behaviour without validation that `NeedToChangeTerm()` conditions are met, breaking the Byzantine fault tolerance guarantee.

### Finding Description

The `_isNewTerm` parameter in `TerminateRoundCommandStrategy` is set based on the `behaviour` parameter provided by miners [1](#0-0) , which comes from user-provided trigger information [2](#0-1) .

While `MainChainConsensusBehaviourProvider` correctly checks `NeedToChangeTerm()` to determine appropriate behaviour [3](#0-2) , and `NeedToChangeTerm()` validates that at least 2/3+1 miners have mined in the new term period based on period expiration [4](#0-3) , the validation phase fails to re-check these conditions.

The `RoundTerminateValidationProvider.ValidationForNextTerm()` only verifies structural correctness—that round and term numbers are properly incremented—but does NOT validate whether the period has actually expired or whether 2/3+1 consensus exists [5](#0-4) .

The `NextTerm` transaction processing also lacks this validation check [6](#0-5) , and `ProcessNextTerm` proceeds without verifying `NeedToChangeTerm()` conditions [7](#0-6) .

### Impact Explanation

A single malicious miner can unilaterally force term changes without the required 2/3+1 Byzantine consensus agreement and before the period actually expires. This breaks fundamental consensus invariants:

1. **Consensus Integrity**: The 2/3+1 threshold requirement is bypassed, eliminating Byzantine fault tolerance
2. **Reward Misallocation**: Premature term changes trigger treasury releases and election snapshots with incorrect miner performance data [8](#0-7) 
3. **Governance Disruption**: Election results based on premature snapshots affect future miner selection and voting power distribution
4. **Economic Impact**: Mining rewards and treasury distributions calculated on manipulated round data

Severity: **Critical** - violates core consensus safety and breaks economic distribution mechanisms.

### Likelihood Explanation

**Attacker Capabilities**: Any active miner in the current round can execute this attack.

**Attack Complexity**: Low - the attacker simply provides `Behaviour = NextTerm` in their consensus trigger information when calling `GetConsensusBlockExtraData`, then produces a block with term number incremented by 1.

**Feasibility Conditions**: 
- Attacker must be in the current miner list (checked by `MiningPermissionValidationProvider`)
- No additional preconditions required
- No economic cost beyond normal block production

**Detection Constraints**: The attack appears as a valid consensus state transition since validation only checks structural correctness. Network nodes would accept the block as the validation passes all checks.

**Probability**: High - the lack of validation makes this trivially exploitable by any miner with basic understanding of the consensus mechanism.

### Recommendation

Add validation in `RoundTerminateValidationProvider.ValidationForNextTerm()` to re-check `NeedToChangeTerm()` conditions:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Validate term number increment
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // ADD: Validate period expiration and 2/3+1 consensus
    var blockchainStartTimestamp = GetBlockchainStartTimestamp();
    var periodSeconds = GetPeriodSeconds();
    if (!validationContext.BaseRound.NeedToChangeTerm(blockchainStartTimestamp, 
        validationContext.BaseRound.TermNumber, periodSeconds))
        return new ValidationResult { Message = "Term change conditions not met - insufficient consensus or period not expired." };

    return new ValidationResult { Success = true };
}
```

Additional safeguards:
- Add assertion in `ProcessNextTerm()` to validate `NeedToChangeTerm()` before processing
- Add integration tests covering premature term change attempts
- Log warnings when miners request behaviours that don't match current consensus state

### Proof of Concept

**Initial State:**
- Current term number: 1
- Period seconds: 604800 (7 days)
- Blockchain age: 3 days (less than period)
- Only 1 miner has mined in potential new term period (< 2/3+1 threshold)

**Attack Steps:**
1. Malicious miner calls `GetConsensusBlockExtraData` with `triggerInformation.Behaviour = NextTerm`
2. Contract generates consensus extra data with `TermNumber = 2` without validation
3. Miner produces block with this extra data
4. `ValidateBeforeExecution` is called:
   - `RoundTerminateValidationProvider.ValidationForNextTerm()` only checks term number is incremented (✓ passes)
   - Does NOT check `NeedToChangeTerm()` conditions
5. `NextTerm` transaction executes successfully
6. Term number updated to 2, treasury released, election snapshot taken

**Expected Result:** Block should be rejected with "Term change conditions not met"

**Actual Result:** Block accepted, term changed prematurely, breaking consensus invariants

**Success Condition:** After attack, `State.CurrentTermNumber.Value == 2` despite period not expiring and lacking 2/3+1 consensus.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L16-21)
```csharp
        public TerminateRoundCommandStrategy(Round currentRound, string pubkey, Timestamp currentBlockTime,
            bool isNewTerm) : base(
            currentRound, pubkey, currentBlockTime)
        {
            _isNewTerm = isNewTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L26-47)
```csharp
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-243)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }

    /// <summary>
    ///     If periodSeconds == 7:
    ///     1, 1, 1 => 0 != 1 - 1 => false
    ///     1, 2, 1 => 0 != 1 - 1 => false
    ///     1, 8, 1 => 1 != 1 - 1 => true => term number will be 2
    ///     1, 9, 2 => 1 != 2 - 1 => false
    ///     1, 15, 2 => 2 != 2 - 1 => true => term number will be 3.
    /// </summary>
    /// <param name="blockchainStartTimestamp"></param>
    /// <param name="termNumber"></param>
    /// <param name="blockProducedTimestamp"></param>
    /// <param name="periodSeconds"></param>
    /// <returns></returns>
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```
