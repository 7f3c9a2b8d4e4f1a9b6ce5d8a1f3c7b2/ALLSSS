### Title
Null Reference Exception Risk in GetMaximumBlocksCount Due to Missing Defensive Checks on MinedMinerListMap Access

### Summary
The `GetMaximumBlocksCount()` function accesses historical `MinedMinerListMap` entries without null checks when the blockchain is in Abnormal status. If these entries are missing due to state migration, contract upgrades, or other edge cases, accessing `.Pubkeys` on null will throw a `NullReferenceException`, causing consensus processing to fail and halting block production.

### Finding Description

In `GetMaximumBlocksCount()`, when the blockchain mining status is determined to be `Abnormal` (lines 42-55), the code accesses historical miner list data: [1](#0-0) 

The root cause is that `MappedState` returns `null` when accessing non-existent keys. When `SerializationHelper.Deserialize<T>(null)` is called, it returns `default(T)`, which is `null` for reference types like `MinerList`: [2](#0-1) 

The `MappedState` indexer implementation shows this behavior: [3](#0-2) 

**Evidence of inconsistent defensive programming**: The code includes a defensive null check when removing old entries, indicating developers anticipated missing entries: [4](#0-3) 

However, no such check exists before accessing the entries at lines 44-45, creating an inconsistency that suggests a bug.

**When entries might be missing**:
- During initial rounds, `FirstRound()` does not populate `MinedMinerListMap`: [5](#0-4) 
- After contract upgrades or state migrations with incomplete historical data
- The early return at line 33 protects initial rounds when `libRoundNumber == 0`, but doesn't protect against gaps in later rounds: [6](#0-5) 

### Impact Explanation

**Concrete Impact**: 
- When `MinedMinerListMap[currentRoundNumber.Sub(1)]` returns `null`, accessing `.Pubkeys` throws `NullReferenceException`
- Contract execution fails, causing `ProcessConsensusInformation` to abort: [7](#0-6) 
- Block production halts as consensus processing cannot complete
- This creates a Denial of Service on the consensus mechanism

**Who is Affected**: All network participants - the entire blockchain stops producing blocks until the state issue is resolved through manual intervention.

**Severity**: Medium - High impact (consensus DoS) but Low-Medium likelihood (requires edge case conditions).

### Likelihood Explanation

**Preconditions**:
- Blockchain must be in Abnormal mining status (libRoundNumber + 2 < currentRoundNumber < libRoundNumber + 8)
- Historical `MinedMinerListMap` entries must be missing for `currentRoundNumber - 1` or `currentRoundNumber - 2`

**Feasibility**:
- Under normal operation with proper initialization, entries should exist
- However, the defensive null check in the removal code (line 234) indicates developers anticipated this scenario
- Possible triggers: contract upgrades, state migrations, or unforeseen consensus edge cases
- Not directly exploitable by attackers, but represents a robustness failure

**Attack Complexity**: Not a direct attack vector - this is a defensive programming issue that could manifest during operational edge cases rather than malicious exploitation.

**Probability**: Low to Medium - the defensive null check elsewhere suggests developers were aware of this possibility, making it a known operational risk.

### Recommendation

**Code-Level Mitigation**:
Add defensive null checks before accessing `MinedMinerListMap` entries, consistent with the existing check at line 234:

```csharp
if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
{
    var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)];
    var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)];
    
    // Add defensive null checks
    if (previousRoundMinedMinerList == null || previousPreviousRoundMinedMinerList == null)
    {
        Context.LogDebug(() => "Missing historical mined miner list data, returning default maximum blocks count.");
        return AEDPoSContractConstants.MaximumTinyBlocksCount;
    }
    
    var minersOfLastTwoRounds = previousRoundMinedMinerList.Pubkeys
        .Intersect(previousPreviousRoundMinedMinerList.Pubkeys).Count();
    // ... rest of the logic
}
```

**Invariant Checks**:
- Ensure `MinedMinerListMap[roundNumber]` is not null before accessing `.Pubkeys`
- Consider adding assertions to verify expected state during consensus processing

**Test Cases**:
- Test `GetMaximumBlocksCount()` with missing historical entries in Abnormal status
- Test state migration scenarios with incomplete `MinedMinerListMap` data
- Test contract upgrade paths to ensure historical data integrity

### Proof of Concept

**Required Initial State**:
1. Blockchain initialized and past initial rounds (roundNumber > 3)
2. `MinedMinerListMap` has gaps in historical data (e.g., due to state migration)
3. Current round number significantly ahead of LIB round number (Abnormal status)

**Reproduction Steps**:
1. Deploy contract with state where `currentRoundNumber = 10` and `libRoundNumber = 5`
2. Ensure `MinedMinerListMap[9]` or `MinedMinerListMap[8]` is missing/null
3. Call any consensus method that triggers `ProcessConsensusInformation` â†’ `GetMaximumBlocksCount()`
4. Blockchain mining status evaluated as Abnormal (5 + 2 < 10 < 5 + 8)

**Expected vs Actual**:
- **Expected**: Function gracefully handles missing data or returns safe default
- **Actual**: `NullReferenceException` when accessing `.Pubkeys` on null, contract execution fails

**Success Condition**: Contract execution fails with null reference exception, preventing block production and requiring manual intervention to restore consensus.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L33-33)
```csharp
        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L44-45)
```csharp
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
```

**File:** src/AElf.Types/Helper/SerializationHelper.cs (L88-91)
```csharp
        public static T Deserialize<T>(byte[] bytes)
        {
            if (bytes == null)
                return default;
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L26-36)
```csharp
    public TEntity this[TKey key]
    {
        get
        {
            if (!Cache.TryGetValue(key, out var valuePair))
            {
                valuePair = LoadKey(key);
                Cache[key] = valuePair;
            }

            return valuePair.IsDeleted ? SerializationHelper.Deserialize<TEntity>(null) : valuePair.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L67-69)
```csharp
        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L232-235)
```csharp
        // Remove information out of date.
        var removeTargetRoundNumber = currentRound.RoundNumber.Sub(3);
        if (removeTargetRoundNumber > 0 && State.MinedMinerListMap[removeTargetRoundNumber] != null)
            State.MinedMinerListMap.Remove(removeTargetRoundNumber);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L74-92)
```csharp
    public override Empty FirstRound(Round input)
    {
        /* Basic checks. */
        Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");

        /* Initial settings. */
        State.CurrentTermNumber.Value = 1;
        State.CurrentRoundNumber.Value = 1;
        State.FirstRoundNumberOfEachTerm[1] = 1;
        State.MiningInterval.Value = input.GetMiningInterval();
        SetMinerList(input.GetMinerList(), 1);

        AddRoundInformation(input);

        Context.LogDebug(() =>
            $"Initial Miners: {input.RealTimeMinersInformation.Keys.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");

        return new Empty();
    }
```
