### Title
ConfigurationController Hijacking via Malicious Contract Address Allows Permanent Governance Bypass

### Summary
The `ChangeConfigurationController` method fails to validate that the new controller's `ContractAddress` points to a legitimate governance contract (Parliament, Association, or Referendum). An attacker can pass a Parliament proposal once to change the controller to their own malicious contract, then gain permanent direct control over all configuration changes without any further governance approval, completely bypassing the intended organization-based governance mechanism.

### Finding Description

The vulnerability exists in the `ChangeConfigurationController` method which validates the new controller through `CheckOrganizationExist`: [1](#0-0) 

The authorization check `AssertPerformedByConfigurationController` only verifies that the sender matches the current controller's `OwnerAddress`: [2](#0-1) 

The `CheckOrganizationExist` function makes a cross-contract call to `authorityInfo.ContractAddress` without validating that this address is a legitimate governance contract: [3](#0-2) 

The `AuthorityInfo` structure allows arbitrary addresses for both `contract_address` and `owner_address`: [4](#0-3) 

**Root Cause**: There is no whitelist or validation ensuring that `authorityInfo.ContractAddress` points to one of the three legitimate governance contracts (Parliament, Association, or Referendum). The code only checks if calling `ValidateOrganizationExist` on that address returns true.

**Exploitation Path**:
1. Attacker deploys a malicious contract `MaliciousGovernance` that implements `ValidateOrganizationExist` to always return `true` for any address
2. Attacker creates a Parliament proposal to call `ChangeConfigurationController` with `AuthorityInfo { ContractAddress = MaliciousGovernance, OwnerAddress = attacker's address }`
3. Parliament miners approve the proposal (they may not recognize the malicious contract address)
4. After execution, `State.ConfigurationController.Value` points to the attacker's contract and address
5. Attacker can now directly call `SetConfiguration` and `ChangeConfigurationController` because `AssertPerformedByConfigurationController` only checks if `Context.Sender == State.ConfigurationController.Value.OwnerAddress`, which is now the attacker's address

### Impact Explanation

**Critical Authorization Bypass**: The attacker gains permanent, unilateral control over all blockchain configuration parameters without any governance oversight.

**Affected Operations**:
- Setting block transaction limits via `SetConfiguration`
- Modifying required ACS in contracts
- Changing method fees
- Any future configuration parameters added to the system [5](#0-4) 

**Governance Undermining**: The entire Parliament governance model is bypassed after a single malicious proposal approval. The attacker can repeatedly modify configurations without any approval, voting, or time delays.

**Systemic Impact**: This vulnerability affects the core governance layer. Configuration changes can impact:
- Fee structures (economic manipulation)
- Contract deployment policies  
- System-wide operational parameters
- Security-critical settings like required contract standards

**Severity Justification**: This is a critical privilege escalation that permanently compromises the governance model with a single successful proposal. The attacker doesn't need continuous access or repeated approvals - one successful proposal grants permanent control.

### Likelihood Explanation

**Reachable Entry Point**: `ChangeConfigurationController` is a public method accessible via Parliament proposals. [6](#0-5) 

**Attacker Capabilities Required**:
1. Deploy a malicious contract (standard capability on AElf)
2. Create and get approved ONE Parliament proposal (requires miner coordination but is the normal governance flow)

**Execution Practicality**: 
- The attack is straightforward and requires no complex timing or race conditions
- The malicious contract is simple (just returns true from `ValidateOrganizationExist`)
- Parliament miners may not detect the malicious contract address in the proposal parameters
- Test cases demonstrate this exact flow is possible: [7](#0-6) 

**Detection Difficulty**: The proposal appears legitimate - it's just changing the controller to a new `AuthorityInfo`. Miners would need to manually verify the `ContractAddress` is a known governance contract, which is not enforced by the code.

**Economic Rationality**: The cost is a single proposal approval. The gain is permanent control over system configuration, which could enable fee manipulation, DoS, or other attacks worth far more than the proposal cost.

**Likelihood Assessment**: HIGH - The attack requires only standard capabilities and one successful governance action that may appear legitimate to approvers.

### Recommendation

**Immediate Fix**: Add a whitelist validation in `CheckOrganizationExist` to ensure the `ContractAddress` is one of the three legitimate governance contracts:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a legitimate governance contract
    RequireGovernanceContract(authorityInfo.ContractAddress);
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}

private void RequireGovernanceContract(Address contractAddress)
{
    if (State.ParliamentContract.Value == null)
        State.ParliamentContract.Value = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    if (State.AssociationContract.Value == null)
        State.AssociationContract.Value = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    if (State.ReferendumContract.Value == null)
        State.ReferendumContract.Value = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
        
    Assert(
        contractAddress == State.ParliamentContract.Value ||
        contractAddress == State.AssociationContract.Value ||
        contractAddress == State.ReferendumContract.Value,
        "Invalid governance contract address."
    );
}
```

**Apply to All Affected Contracts**: The same vulnerability exists in other contracts using `CheckOrganizationExist`:
- Genesis contract: `ChangeContractDeploymentController`, `ChangeCodeCheckController`
- All other contracts with similar controller change methods

**Test Cases**: Add regression tests that verify:
1. Changing controller to a non-governance contract address fails
2. Only Parliament, Association, and Referendum contract addresses are accepted
3. Malicious contract addresses are rejected even if they implement `ValidateOrganizationExist`

### Proof of Concept

**Initial State**:
- ConfigurationController is Parliament's default organization (normal state)

**Attack Steps**:

1. **Deploy Malicious Contract**:
```csharp
contract MaliciousGovernance {
    public BoolValue ValidateOrganizationExist(Address input) {
        return new BoolValue { Value = true }; // Always returns true
    }
}
```

2. **Create Parliament Proposal** to call `ChangeConfigurationController`:
```
Input: AuthorityInfo {
    ContractAddress = [MaliciousGovernance address],
    OwnerAddress = [Attacker's address]
}
```

3. **Get Miners to Approve**: Miners approve the proposal (appears to be a normal controller change)

4. **Release Proposal**: Execute the approved proposal
   - `AssertPerformedByConfigurationController()` passes (Parliament is caller)
   - `CheckOrganizationExist(input)` calls `MaliciousGovernance.ValidateOrganizationExist(attacker's address)`
   - Returns `true` (malicious contract always returns true)
   - `State.ConfigurationController.Value` is set to attacker's AuthorityInfo

5. **Direct Control**: Attacker can now directly call `SetConfiguration`:
```
SetConfigurationInput {
    Key = "BlockTransactionLimit",
    Value = [arbitrary value]
}
```
   - `AssertPerformedByConfigurationControllerOrZeroContract()` checks: `Context.Sender == State.ConfigurationController.Value.OwnerAddress`
   - Attacker's address matches, check passes
   - Configuration is changed WITHOUT Parliament approval

**Expected Result**: Step 2 should fail with "Invalid governance contract address"

**Actual Result**: All steps succeed, attacker gains permanent direct control over configuration without governance

**Success Condition**: After step 4, attacker can repeatedly call `SetConfiguration` and `ChangeConfigurationController` without any Parliament proposals or approvals, demonstrating complete governance bypass.

### Citations

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract.cs (L10-21)
```csharp
    public override Empty SetConfiguration(SetConfigurationInput input)
    {
        AssertPerformedByConfigurationControllerOrZeroContract();
        Assert(input.Key.Any() && input.Value != ByteString.Empty, "Invalid set config input.");
        State.Configurations[input.Key] = new BytesValue { Value = input.Value };
        Context.Fire(new ConfigurationSet
        {
            Key = input.Key,
            Value = input.Value
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract.cs (L29-36)
```csharp
    public override Empty ChangeConfigurationController(AuthorityInfo input)
    {
        AssertPerformedByConfigurationController();
        Assert(input != null, "invalid input");
        Assert(CheckOrganizationExist(input), "Invalid authority input.");
        State.ConfigurationController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_Helper.cs (L21-30)
```csharp
    private void AssertPerformedByConfigurationController()
    {
        if (State.ConfigurationController.Value == null)
        {
            var defaultConfigurationController = GetDefaultConfigurationController();
            State.ConfigurationController.Value = defaultConfigurationController;
        }

        Assert(Context.Sender == State.ConfigurationController.Value.OwnerAddress, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L72-77)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** protobuf/authority_info.proto (L5-10)
```text
message AuthorityInfo {
    // The contract address of the controller.
    aelf.Address contract_address = 1;
    // The address of the owner of the contract.
    aelf.Address owner_address = 2;
}
```

**File:** protobuf/configuration_contract.proto (L24-25)
```text
    rpc ChangeConfigurationController (AuthorityInfo) returns (google.protobuf.Empty) {
    }
```

**File:** test/AElf.Contracts.Configuration.Tests/ConfigurationContractTest.cs (L86-116)
```csharp
    public async Task Change_Owner_Address_Authorized()
    {
        var sender = SampleAddress.AddressList[0];
        _testOutputHelper.WriteLine(sender.ToBase58());
        var newOrganization = Address.Parser.ParseFrom((await Tester.ExecuteContractWithMiningAsync(ParliamentAddress,
            nameof(ParliamentContractContainer.ParliamentContractStub.CreateOrganization),
            new CreateOrganizationInput
            {
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1,
                    MinimalVoteThreshold = 1
                },
                ParliamentMemberProposingAllowed = true
            })).ReturnValue);
        var proposalId = await SetTransactionOwnerAddressProposalAsync(new AuthorityInfo
        {
            ContractAddress = ParliamentAddress,
            OwnerAddress = newOrganization
        });
        await ApproveWithMinersAsync(proposalId);
        var transactionResult = await ReleaseProposalAsync(proposalId);
        Assert.True(transactionResult.Status == TransactionResultStatus.Mined);

        var transactionResult2 =
            await ExecuteContractWithMiningAsync(ConfigurationContractAddress,
                nameof(ConfigurationImplContainer.ConfigurationImplStub.GetConfigurationController),
                new Empty());
        var authorityInfo = AuthorityInfo.Parser.ParseFrom(transactionResult2.ReturnValue);
        Assert.True(newOrganization == authorityInfo.OwnerAddress);
    }
```
