### Title
Integer Overflow in Side Chain Rental Calculation Due to Unbounded ResourceAmount Values

### Summary
The `UpdateRentedResources` function lacks upper bound validation on `State.ResourceAmount` values, only checking that values are non-negative. When combined with rental rate calculations in `PayRental`, extreme or accidentally misconfigured `ResourceAmount` values can cause integer overflow during the `duration.Mul(ResourceAmount).Mul(Rental)` computation, throwing an `OverflowException` that causes the entire `DonateResourceToken` system transaction to fail, effectively DoSing the side chain's resource token donation mechanism.

### Finding Description [1](#0-0) 

The `UpdateRentedResources` method only validates that `ResourceAmount` values are non-negative but imposes no upper bound. The `ResourceAmount` state variable is defined as `int32` (max value 2,147,483,647). [2](#0-1) 

The vulnerability manifests in the `PayRental` method, which is called during `DonateResourceToken` on side chains: [3](#0-2) 

This calculation multiplies three values:
- `duration` (long): minutes elapsed since last payment
- `State.ResourceAmount[symbol]` (int): resource consumption per minute
- `State.Rental[symbol]` (long): tokens per minute

The multiplication uses SafeMath with checked arithmetic: [4](#0-3) 

When overflow occurs, the transaction throws `OverflowException` and fails, blocking the `DonateResourceToken` system transaction that is critical for side chain operation. [5](#0-4) 

### Impact Explanation

**Operational Impact**: DoS of side chain resource token donation mechanism

When `ResourceAmount` is set to extreme values (e.g., through governance misconfiguration or typo), the `PayRental` calculation overflows. This causes:

1. `DonateResourceToken` transaction failure every time it executes
2. Side chains unable to process resource token donations from contracts
3. Side chains unable to pay rental fees, accumulating debt indefinitely
4. Potential cascading failures in resource fee accounting

**Quantified Scenario**: 
- `ResourceAmount[CPU] = 100,000,000` (typo: meant 100, typed 100M)
- `Rental[CPU] = 100,000` (100k tokens/minute, reasonable rate)
- `duration = 100,000` minutes (~70 days)
- Calculation: `100,000 * 100,000,000 * 100,000 = 10^20`
- Exceeds `long.MaxValue` (9.22 Ã— 10^18), causing overflow

**Realistic values for comparison**: [6](#0-5) 

The expected values (CPU: 4, RAM: 8, DISK: 512, NET: 1000) are orders of magnitude smaller than what the system accepts.

### Likelihood Explanation

**Attacker Capabilities**: Requires controller authorization through the SideChainRental Association organization (parliament + side chain creator approval). [7](#0-6) 

**Attack Complexity**: Low - single governance proposal with misconfigured value

**Feasibility Conditions**: 
- **Accidental misconfiguration**: Most realistic scenario. Governance proposals submitted with typos or unit confusion (e.g., entering raw bytes instead of GiB) would immediately DoS the system.
- **Compromised controller**: Less likely but possible. If controller is compromised, attacker can permanently DoS side chain operations.

**Detection**: The DoS is immediate and obvious once `DonateResourceToken` is called after the misconfiguration, but prevention requires bounds checking.

**Probability**: Medium - While requiring governance access, the lack of validation means honest mistakes in governance proposals can brick the system. No safeguards exist to catch unreasonable values before they cause failures.

### Recommendation

Add upper bound validation in `UpdateRentedResources` to reject unreasonable resource amounts:

```csharp
public override Empty UpdateRentedResources(UpdateRentedResourcesInput input)
{
    AssertControllerForSideChainRental();
    foreach (var pair in input.ResourceAmount)
    {
        Assert(
            Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
            "Invalid symbol.");
        Assert(pair.Value >= 0, "Invalid amount.");
        
        // Add upper bound validation
        const int MaxReasonableResourceAmount = 1000000; // 1M units (reasonable max)
        Assert(pair.Value <= MaxReasonableResourceAmount, 
            $"Resource amount {pair.Value} exceeds maximum allowed {MaxReasonableResourceAmount}.");
        
        State.ResourceAmount[pair.Key] = pair.Value;
    }
    return new Empty();
}
```

**Additional safeguards**:
1. Add overflow detection in `PayRental` itself with graceful degradation
2. Implement rental calculation preview methods for governance proposals
3. Add integration tests with extreme values to verify overflow protection
4. Document expected ranges for each resource type in governance documentation

### Proof of Concept

**Initial State**:
- Side chain initialized with normal ResourceAmount values (CPU: 4)
- Rental rate set to 100,000 tokens/minute
- Side chain creator has sufficient balance

**Exploitation Steps**:

1. **Controller submits governance proposal** to update ResourceAmount:
   ```
   UpdateRentedResourcesInput {
     ResourceAmount: { "CPU": 100000000 }  // Typo: meant 100
   }
   ```

2. **Proposal approved and executed** by Association organization members

3. **Time passes** - 70 days (~100,000 minutes) without DonateResourceToken execution

4. **DonateResourceToken executes** (system-generated transaction):
   - Calls `PayRental()`
   - Calculates: `100000 * 100000000 * 100000 = 10^20`
   - Overflow occurs: `10^20 > long.MaxValue`
   - SafeMath throws `OverflowException`
   - Transaction fails

**Expected vs Actual**:
- **Expected**: DonateResourceToken succeeds, rental fees charged
- **Actual**: Transaction fails with OverflowException, side chain DoS'ed

**Success Condition**: Side chain cannot process any `DonateResourceToken` transactions until controller submits another governance proposal to reduce ResourceAmount to reasonable values, which may take days due to governance delay.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L913-953)
```csharp
    public override Empty DonateResourceToken(TotalResourceTokensMaps input)
    {
        AssertSenderIsCurrentMiner();
        var donateResourceTokenExecuteHeight = State.DonateResourceTokenExecuteHeight.Value;
        if (donateResourceTokenExecuteHeight == 0)
        {
            donateResourceTokenExecuteHeight = Context.CurrentHeight;
        }

        Assert(donateResourceTokenExecuteHeight == Context.CurrentHeight,
            $"This method already executed in height {State.DonateResourceTokenExecuteHeight.Value}");
        State.DonateResourceTokenExecuteHeight.Value = donateResourceTokenExecuteHeight.Add(1);
        Context.LogDebug(() => $"Start donate resource token. {input}");
        State.LatestTotalResourceTokensMapsHash.Value = HashHelper.ComputeFrom(input);
        Context.LogDebug(() =>
            $"Now LatestTotalResourceTokensMapsHash is {State.LatestTotalResourceTokensMapsHash.Value}");

        var isMainChain = true;
        if (State.DividendPoolContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            if (treasuryContractAddress == null)
            {
                isMainChain = false;
            }
            else
            {
                State.DividendPoolContract.Value = treasuryContractAddress;
            }
        }

        PayResourceTokens(input, isMainChain);

        if (!isMainChain)
        {
            PayRental();
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1061-1061)
```csharp
            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1114-1127)
```csharp
    public override Empty UpdateRentedResources(UpdateRentedResourcesInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.ResourceAmount)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.ResourceAmount[pair.Key] = pair.Value;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState_ChargeFee.cs (L19-26)
```csharp
    /// <summary>
    /// Symbol -> Amount (TBD)
    /// (CPU: core)
    /// (RAM: GiB)
    /// (DISK: GiB)
    /// (NET: MB)
    /// </summary>
    public MappedState<string, int> ResourceAmount { get; set; }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L79-85)
```csharp
    public static long Mul(this long a, long b)
    {
        checked
        {
            return a * b;
        }
    }
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainSideChainRentFeeTest.cs (L19-22)
```csharp
    private const int CpuAmount = 4;
    private const int RamAmount = 8;
    private const int DiskAmount = 512;
    private const int NetAmount = 1000;
```
