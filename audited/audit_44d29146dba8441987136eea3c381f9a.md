### Title
Missing Authorization Check for TinyBlock Producer Allows Unauthorized Extra Block Mining

### Summary
The consensus validation in `ValidateBeforeExecution` does not verify that a miner producing blocks with `TinyBlock` behavior is actually the authorized `ExtraBlockProducerOfPreviousRound`. This allows any miner in the current round to produce extra blocks before the round starts by claiming TinyBlock behavior, bypassing the intended consensus rules and gaining unfair mining rewards.

### Finding Description

The vulnerability exists in the validation flow for consensus blocks at multiple locations:

**Root Cause**: The `MiningPermissionValidationProvider` only verifies that a sender is in the miner list, without checking authorization for specific behaviors: [1](#0-0) 

When validating blocks with `TinyBlock` behavior, the system applies only three basic validators without any behavior-specific authorization checks: [2](#0-1) 

The `TimeSlotValidationProvider` checks timing but does not verify whether the miner is the `ExtraBlockProducerOfPreviousRound`: [3](#0-2) 

**Why Protections Fail**: The intended behavior logic correctly checks `ExtraBlockProducerOfPreviousRound` during command generation: [4](#0-3) 

However, this check is in the command GENERATION path (`GetConsensusCommand`), not in the VALIDATION path (`ValidateBeforeExecution`). A malicious miner can bypass command generation and directly submit a block claiming TinyBlock behavior, which will pass validation despite being unauthorized.

The validation also fails to check per-miner block quotas - there is no validator that verifies `ActualMiningTimes.Count` against `maximumBlocksCount` or the extended quota for the extra block producer.

### Impact Explanation

**Financial Impact**: Mining rewards are distributed based on the number of blocks produced. By producing unauthorized extra blocks, a malicious miner can:
- Gain additional mining reward shares beyond their legitimate quota
- Steal rewards that should go to the legitimate `ExtraBlockProducerOfPreviousRound`
- Accumulate more blocks in `ActualMiningTimes`, increasing their reward distribution in the Treasury system [5](#0-4) 

**Consensus Integrity Impact**: Multiple miners could simultaneously produce blocks in the extra block time slot (before round start), causing:
- Potential chain forks as competing blocks are propagated
- Disruption of the deterministic block production schedule
- Violation of the single extra block producer invariant

**Fairness Impact**: The consensus mechanism is designed to give exclusive mining rights in the extra block slot to the previous round's last miner. This vulnerability breaks that invariant, allowing any miner to compete for those slots.

### Likelihood Explanation

**Attacker Capabilities Required**:
1. Must be an elected miner in the current round (achievable through legitimate election or compromise of an elected miner's node)
2. Must have technical ability to modify node behavior to craft blocks with specific consensus behaviors (feasible for sophisticated attackers with source code access)
3. Must bypass the normal `GetConsensusCommand` flow and inject custom consensus behavior

**Attack Complexity**: Medium
- The attack requires understanding the consensus validation flow
- The attacker must craft properly formatted blocks with TinyBlock behavior
- Timing must be coordinated to fall before the round start time

**Feasibility Conditions**:
- The attack window exists during the extra block time slot (between the previous round end and current round start)
- The attacker's `latestActualMiningTime` must satisfy the timing checks in `TimeSlotValidationProvider`
- The `LatestPubkeyToTinyBlocksCount.BlocksCount` must not be negative yet

**Detection Constraints**: The attack may be difficult to detect initially because:
- The blocks appear valid (pass all validators)
- The behavior is similar to legitimate tiny blocks
- Only careful analysis of which miner should have the extra block slot reveals the issue

### Recommendation

**Add Extra Block Producer Authorization Validator**:

Create a new `ExtraBlockProducerValidationProvider` that explicitly checks authorization for TinyBlock behavior:

```csharp
public class ExtraBlockProducerValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        
        // For TinyBlock behavior before round start, verify sender is authorized
        if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
        {
            var baseRound = validationContext.BaseRound;
            var currentBlockTime = validationContext.ExtraData.Round.RealTimeMinersInformation[validationContext.SenderPubkey]
                .ActualMiningTimes.Last();
            
            // If mining before round start, must be ExtraBlockProducerOfPreviousRound
            if (currentBlockTime < baseRound.GetRoundStartTime() &&
                baseRound.ExtraBlockProducerOfPreviousRound != validationContext.SenderPubkey)
            {
                validationResult.Message = $"Sender {validationContext.SenderPubkey} is not authorized to produce extra blocks";
                return validationResult;
            }
            
            // Verify block quota not exceeded
            var minerInRound = baseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
            var maximumBlocksCount = GetMaximumBlocksCount(); // Need to pass this in context
            
            if (baseRound.ExtraBlockProducerOfPreviousRound == validationContext.SenderPubkey)
            {
                var blocksBeforeCurrentRound = minerInRound.ActualMiningTimes.Count(t => t <= baseRound.GetRoundStartTime());
                if (minerInRound.ActualMiningTimes.Count > maximumBlocksCount + blocksBeforeCurrentRound)
                {
                    validationResult.Message = "Extra block producer exceeded quota";
                    return validationResult;
                }
            }
            else if (minerInRound.ActualMiningTimes.Count >= maximumBlocksCount)
            {
                validationResult.Message = "Miner exceeded maximum blocks quota";
                return validationResult;
            }
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Add this validator to the validation providers list in `ValidateBeforeExecution`: [6](#0-5) 

**Test Cases**:
1. Verify non-extra-block-producer cannot produce TinyBlocks before round start
2. Verify extra block producer can produce TinyBlocks up to their extended quota
3. Verify regular miners cannot exceed maximumBlocksCount during their time slot
4. Test boundary conditions around round start time

### Proof of Concept

**Initial State**:
- Current round N has 5 miners: A, B, C, D, E
- Miner A is the `ExtraBlockProducerOfPreviousRound` (terminated round N-1)
- Round N+1 starts at timestamp T
- Current time is T - 100ms (just before round start)
- MaximumBlocksCount = 8

**Attack Steps**:

1. **Attacker Setup**: Miner B (not the extra block producer) modifies their node to bypass `GetConsensusCommand`

2. **Craft Malicious Block**: Miner B creates a block with:
   - Behavior: `AElfConsensusBehaviour.TinyBlock`
   - Timestamp: T - 50ms (before round start, within extra block slot)
   - Round information updated with this new mining time

3. **Submit for Validation**: Block submitted to `ValidateConsensusBeforeExecution`

4. **Validation Path**:
   - `RecoverFromTinyBlock` adds the mining time to baseRound [7](#0-6) 
   
   - `MiningPermissionValidationProvider`: Checks if B is in miner list → **PASS**
   - `TimeSlotValidationProvider`: Mining time (T-50ms) < expected time & < round start time → **PASS**
   - `ContinuousBlocksValidationProvider`: BlocksCount not negative → **PASS**

5. **Expected Result**: Validation should REJECT (B is not authorized extra block producer)

6. **Actual Result**: Validation **PASSES** - Block accepted

7. **Consequence**: 
   - Miner B produces an extra block during Miner A's exclusive time slot
   - Miner B gains additional mining rewards
   - Potential fork if both A and B produce blocks simultaneously
   - Consensus invariant violated

**Success Condition**: Miner B's unauthorized TinyBlock is accepted by the validation, allowing them to mine during a time slot reserved exclusively for Miner A, thereby gaining unfair mining rewards and disrupting consensus integrity.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-92)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L84-95)
```csharp
    /// <summary>
    ///     Normally this process contained in NextRound method.
    /// </summary>
    private void CountMissedTimeSlots()
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return;

        foreach (var minerInRound in currentRound.RealTimeMinersInformation)
            if (minerInRound.Value.OutValue == null)
                minerInRound.Value.MissedTimeSlots = minerInRound.Value.MissedTimeSlots.Add(1);

        TryToUpdateRoundInformation(currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```
