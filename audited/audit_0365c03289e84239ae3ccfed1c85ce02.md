### Title
Missing Character Validation in AddNFTType Enables DoS of NFT Protocol Creation

### Summary
The `AddNFTType` method only validates that short names are exactly 2 characters long but does not validate the characters themselves. This allows governance to add NFT types with special characters (e.g., "@@", "!!", "**") that will subsequently fail MultiToken contract symbol validation, making it impossible to create NFT protocols of that type and causing a permanent denial-of-service for that NFT category.

### Finding Description

The root cause lies in insufficient validation in the `AddNFTType` method. While it checks the short name length, it does not validate the character content: [1](#0-0) 

The method only asserts `input.ShortName.Length == 2` at line 136, but accepts any characters including special characters like "@", "!", "*", "#", etc.

When an NFT protocol is created, the `GetSymbol` method retrieves the short name from `NFTTypeShortNameMap` and concatenates it with a random number to generate the protocol symbol: [2](#0-1) 

This generated symbol (e.g., "@@123456789") is then passed to the MultiToken contract's `Create` method: [3](#0-2) 

The MultiToken contract validates the symbol through `GetSymbolType`, which calls `IsValidCreateSymbol`: [4](#0-3) 

The `IsValidCreateSymbol` method uses a strict regex pattern that only allows alphanumeric characters: [5](#0-4) 

When special characters are present in the symbol prefix, the regex `^[a-zA-Z0-9]+$` validation fails, causing an assertion error "Invalid Symbol input" at line 10 of GetSymbolType, which prevents the NFT protocol from being created.

### Impact Explanation

**Operational Impact - DoS:**
- Any NFT type added with special characters in its short name becomes permanently unusable
- Users cannot create NFT protocols of that type, as all `Create` calls will fail with "Invalid Symbol input"
- The governance action to add the NFT type is wasted, requiring another governance proposal to remove it via `RemoveNFTType`
- This affects protocol functionality and user experience, preventing legitimate NFT protocol creation for specific categories

**Affected Parties:**
- Users attempting to create NFT protocols of the invalid type
- Protocol operators who must coordinate additional governance actions to fix the issue
- Overall protocol usability and trust

**Severity Justification:**
This is a **Medium** severity issue because:
1. It causes a clear operational DoS for specific NFT types
2. It requires governance oversight/error (not direct attacker exploitation)
3. It's reversible through governance (RemoveNFTType) but causes disruption
4. It doesn't directly affect funds but impacts protocol functionality

### Likelihood Explanation

**Attacker Capabilities:**
- Requires ability to submit and pass a Parliament governance proposal for `AddNFTType`
- This could occur through:
  - Malicious governance proposal (requires Parliament approval)
  - Honest mistake/oversight by governance proposers
  - Lack of awareness of downstream validation requirements

**Attack Complexity:**
- Low complexity: Simply submit `AddNFTType` with special characters in the 2-character short name
- The validation gap is clear and exploitable
- No sophisticated techniques required

**Feasibility Conditions:**
- Realistic governance oversight scenario where proposers don't test symbol generation
- No automated validation exists to catch this during proposal review
- The default NFT types in `InitialNFTTypeNameMap` use alphanumeric characters (AR, MU, VW, etc.), which may not alert governance to validation requirements [6](#0-5) 

**Detection/Operational Constraints:**
- Issue only manifests when users attempt to create NFT protocols of the invalid type
- Requires governance action to fix (RemoveNFTType + AddNFTType with valid short name)

**Probability Reasoning:**
Medium likelihood due to reliance on governance oversight, but the validation gap is easily overlooked without awareness of MultiToken contract symbol requirements.

### Recommendation

**Code-Level Mitigation:**
Add character validation in the `AddNFTType` method to ensure short names only contain alphanumeric characters, matching the MultiToken contract's symbol validation requirements:

```csharp
public override Empty AddNFTType(AddNFTTypeInput input)
{
    AssertSenderIsParliamentDefaultAddress();
    InitialNFTTypeNameMap();
    var fullName = input.FullName;
    Assert(input.ShortName.Length == 2, "Incorrect short name.");
    // Add character validation
    Assert(Regex.IsMatch(input.ShortName, "^[a-zA-Z0-9]+$"), 
        "Short name can only contain alphanumeric characters.");
    Assert(State.NFTTypeFullNameMap[input.ShortName] == null, 
        $"Short name {input.ShortName} already exists.");
    Assert(State.NFTTypeShortNameMap[fullName] == null, 
        $"Full name {fullName} already exists.");
    // ... rest of method
}
```

**Invariant Checks to Add:**
1. NFT type short names must match the regex `^[a-zA-Z0-9]{2}$` (exactly 2 alphanumeric characters)
2. Generated NFT protocol symbols must be valid according to MultiToken contract rules before creation

**Test Cases:**
1. Test `AddNFTType` with special characters ("@@", "!!", "**", "A#", etc.) - should fail
2. Test `AddNFTType` with valid alphanumeric short names ("AB", "X1", "99") - should succeed
3. Test NFT protocol creation after adding valid NFT types - should succeed
4. Regression test to ensure existing functionality is preserved

### Proof of Concept

**Required Initial State:**
- Parliament default organization must be set up
- Caller must be the Parliament default address (or submit governance proposal)

**Transaction Steps:**

1. **Add Invalid NFT Type** (as Parliament):
   ```
   Call: AddNFTType
   Input: {
     full_name: "SpecialCategory",
     short_name: "@@"
   }
   Expected: Success (due to missing validation)
   Result: NFT type added to NFTTypeShortNameMap["SpecialCategory"] = "@@"
   ```

2. **Attempt to Create NFT Protocol** (as any user):
   ```
   Call: Create
   Input: {
     nft_type: "SpecialCategory",
     protocol_name: "Test Protocol",
     total_supply: 1000,
     ...
   }
   Expected: Success
   Actual: FAILURE with error "Invalid Symbol input"
   ```

3. **Verification**:
   - GetSymbol generates symbol "@@123456789" (special chars + random number)
   - MultiToken.Create calls GetSymbolType("@@123456789")
   - IsValidCreateSymbol("@@") returns false (fails regex)
   - Assert fails at TokenContract_NFTHelper.cs line 10
   - NFT protocol creation is permanently blocked for "SpecialCategory" type

**Success Condition:**
The vulnerability is confirmed when NFT protocol creation fails with "Invalid Symbol input" for any NFT type whose short name contains non-alphanumeric characters, demonstrating the DoS condition.

### Notes

The vulnerability stems from a validation mismatch between the NFT contract and MultiToken contract. The NFT contract's `AddNFTType` lacks awareness of the downstream symbol validation requirements enforced by the MultiToken contract. This creates a trap where governance can add NFT types that appear valid but are actually unusable. The fix requires aligning validation rules across contract boundaries to maintain protocol invariants.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-34)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L131-150)
```csharp
    public override Empty AddNFTType(AddNFTTypeInput input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        var fullName = input.FullName;
        Assert(input.ShortName.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.ShortName] == null, $"Short name {input.ShortName} already exists.");
        Assert(State.NFTTypeShortNameMap[fullName] == null, $"Full name {fullName} already exists.");
        State.NFTTypeFullNameMap[input.ShortName] = fullName;
        State.NFTTypeShortNameMap[fullName] = input.ShortName;
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Add(input.ShortName, fullName);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeAdded
        {
            ShortName = input.ShortName,
            FullName = input.FullName
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L39-63)
```csharp
    private NFTTypes InitialNFTTypeNameMap()
    {
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;

        var nftTypes = new NFTTypes();
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;

        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }

        return nftTypes;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L28-31)
```csharp
    private bool IsValidCreateSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+$");
    }
```
