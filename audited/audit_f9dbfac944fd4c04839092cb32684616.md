### Title
Negative Period Values Bypass Validation Leading to DoS in Profit Claiming

### Summary
The `FixProfitDetail` method lacks validation on `StartPeriod` and `EndPeriod` values, allowing scheme managers to set negative period values. These negative periods bypass the intended validation check at line 115 (`d.EndPeriod >= d.StartPeriod`) in `GetAllProfitsMap`, causing excessive loop iterations in `ProfitAllPeriods` that result in gas exhaustion and denial of service for profit claiming operations. [1](#0-0) 

### Finding Description

The root cause is the complete absence of input validation in the `FixProfitDetail` method. While `AddBeneficiary` properly validates that `EndPeriod >= scheme.CurrentPeriod`, [2](#0-1)  the `FixProfitDetail` method allows arbitrary period values to be set without any bounds checking: [3](#0-2) 

The validation check intended to filter invalid periods fails for negative values. When `LastProfitPeriod == 0`, the check `d.EndPeriod >= d.StartPeriod` evaluates to true for cases like `EndPeriod=100, StartPeriod=-1000000` (100 >= -1000000 → true), allowing malformed profit details to pass through.

When these negative periods are processed in `GetAllProfitsMap`, the period count calculation at line 130 produces extremely large values: [4](#0-3) 

For example, with `EndPeriod=100` and `LastProfitPeriod=-1000000` (set from `StartPeriod`), the calculation yields: `100 - (-1000000) = 1000100` periods. This enormous count is passed to `ProfitAllPeriods`, where the loop at line 860 iterates over the entire range: [5](#0-4) 

With `LastProfitPeriod=-1000000` and `maxProfitPeriod` potentially reaching positive values near `CurrentPeriod`, the loop executes over 1 million iterations, each performing hash computations and state lookups, causing transaction failure due to gas exhaustion.

### Impact Explanation

**Operational Disruption**: Affected beneficiaries cannot execute `ClaimProfits` to withdraw their legitimate profit shares. [6](#0-5)  The same validation logic is used in the state-changing claim function, causing identical DoS.

**View Function Failures**: All profit query functions (`GetAllProfitsMap`, `GetProfitAmount`, `GetAllProfitAmount`) fail with gas exhaustion, breaking user interfaces and preventing users from viewing their profit balances.

**Scope**: The impact is contained to beneficiaries within schemes controlled by malicious or compromised managers. However, this includes the TokenHolder contract which has manager privileges [7](#0-6)  and manages critical staking rewards, making the vulnerability's reach broader than isolated user schemes.

**Severity Justification**: MEDIUM - While this is a DoS vulnerability rather than fund theft, it prevents legitimate profit withdrawals and can affect system-critical contracts like TokenHolder. The attack does not drain funds but locks beneficiaries out of their earnings until the malformed ProfitDetail is manually corrected.

### Likelihood Explanation

**Attacker Capabilities**: The attacker must obtain scheme manager privileges through either: (1) creating their own scheme (trivial - any user can do this), or (2) compromising an existing manager account. Scheme managers are per-scheme roles, not globally trusted positions.

**Attack Complexity**: Extremely low - a single transaction calling `FixProfitDetail` with negative `StartPeriod` values is sufficient. The method is publicly accessible to authorized managers. [8](#0-7) 

**Feasibility Conditions**: 
- For self-managed schemes: Requires victims to become beneficiaries in the attacker's scheme
- For existing schemes: Requires manager account compromise or malicious integration code
- TokenHolder contract integration presents highest risk if it calls `FixProfitDetail` with unsanitized parameters

**Detection**: The attack is immediately detectable when victims attempt to claim profits and transactions fail with gas exhaustion. However, by that point the damage is done and manual intervention is required.

**Probability Assessment**: MEDIUM - While obtaining manager role for one's own scheme is trivial, the impact is limited to that scheme's participants. Broader impact requires either social engineering (convincing users to join malicious schemes) or technical compromise (exploiting manager accounts or integration bugs). The TokenHolder integration path increases likelihood for system-wide impact.

### Recommendation

**Input Validation**: Add comprehensive bounds checking in `FixProfitDetail`:

```csharp
public override Empty FixProfitDetail(FixProfitDetailInput input)
{
    // ... existing code ...
    
    // Validate period values
    Assert(input.StartPeriod >= 0 || input.StartPeriod == 0, 
        "StartPeriod cannot be negative");
    Assert(input.EndPeriod >= 0 || input.EndPeriod == 0, 
        "EndPeriod cannot be negative");
    Assert(input.EndPeriod >= input.StartPeriod || input.EndPeriod == 0, 
        "EndPeriod must be greater than or equal to StartPeriod");
    Assert(input.EndPeriod >= scheme.CurrentPeriod || input.EndPeriod == 0, 
        "EndPeriod cannot be in the past");
    
    // ... rest of existing code ...
}
```

**Additional Safeguards**: 
- Add maximum iteration limit in `ProfitAllPeriods` loop to prevent gas exhaustion even if malformed data exists
- Consider adding defensive checks in `GetAllProfitsMap` to detect unreasonable period ranges before calculation

**Test Cases**: Add tests verifying that `FixProfitDetail` rejects negative periods, inverted periods, and periods in the past. Test that attempts to set such values result in assertion failures.

### Proof of Concept

**Initial State**:
- Scheme exists with CurrentPeriod = 50
- Beneficiary has valid ProfitDetail with Shares = 100

**Attack Sequence**:
1. Scheme manager calls `FixProfitDetail`:
   - Input: `StartPeriod = -1000000, EndPeriod = 100, BeneficiaryShare.Shares = 100`
   - Result: ProfitDetail updated with negative StartPeriod (no validation prevents this)

2. Beneficiary calls `ClaimProfits` for their scheme:
   - Line 766: Check passes (100 >= -1000000 → true)
   - Line 782: `LastProfitPeriod = -1000000`
   - Line 784: Calls `ProfitAllPeriods` with maxProfitReceivingPeriodCount
   - Line 860: Loop from -1000000 to ~49 executes 1,000,050 iterations
   - Result: Transaction fails with gas exhaustion

3. Any user calls `GetAllProfitsMap` to view the beneficiary's profits:
   - Line 130: Calculates 100 - (-1000000) = 1,000,100 periods
   - Calls `ProfitAllPeriods` with this huge count
   - Result: View call fails, UI cannot display profit information

**Success Condition**: Beneficiary's `ClaimProfits` transactions consistently fail with out-of-gas errors, and all profit view functions for that beneficiary return errors, effectively locking them out of their earnings until manager manually fixes the ProfitDetail.

### Citations

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L113-117)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod < scheme.CurrentPeriod && (d.LastProfitPeriod == 0
                ? d.EndPeriod >= d.StartPeriod
                : d.EndPeriod >= d.LastProfitPeriod)
        ).ToList();
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L127-130)
```csharp
            var profitDetail = availableDetails[i];
            if (profitDetail.LastProfitPeriod == 0) profitDetail.LastProfitPeriod = profitDetail.StartPeriod;
            
            var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod),true, symbol);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L179-180)
```csharp
        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-273)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L297-301)
```csharp
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-767)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
        var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L856-860)
```csharp
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
```
