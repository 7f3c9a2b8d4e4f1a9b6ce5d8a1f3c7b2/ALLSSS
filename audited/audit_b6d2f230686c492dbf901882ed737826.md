# Audit Report

## Title
Stale Beneficiaries Due to Custom Profits Receiver Address Changes in Treasury Reward Distribution

## Summary
The Treasury contract's reward weight update functions fail to properly remove beneficiaries when miners change their custom profits receiver address. The functions use the current profits receiver mapping to identify beneficiaries for removal, but when a miner has changed their receiver between when they were added and when they should be removed, the removal targets the new receiver address instead of the old one. This leaves the old receiver as a permanent stale beneficiary that continues to drain rewards indefinitely.

## Finding Description

The vulnerability exists in three Treasury reward update functions that follow the same flawed pattern.

In `UpdateBasicMinerRewardWeights`, beneficiaries are removed using `GetAddressesFromCandidatePubkeys` which retrieves addresses for the previous term's miners: [1](#0-0) 

The `GetAddressesFromCandidatePubkeys` function returns both the pubkey-derived address and calls `GetProfitsReceiver` for each pubkey: [2](#0-1) 

The `GetProfitsReceiver` function returns the CURRENT value from `State.ProfitsReceiverMap[pubkey]`, falling back to the pubkey-derived address if no custom receiver is set: [3](#0-2) 

When beneficiaries are added in the same function, they also use `GetProfitsReceiver(i.Pubkey)` which captures the receiver address at that specific point in time: [4](#0-3) 

The root cause is that when a miner changes their custom receiver via `SetProfitsReceiver`, it updates `State.ProfitsReceiverMap[input.Pubkey]` but does NOT update the Treasury's BasicReward, VotesWeightReward, or ReElectionReward schemes: [5](#0-4) 

The Treasury contract only notifies the Election contract to update the Subsidy scheme, but leaves its own three reward schemes unchanged.

The Profit contract's `RemoveBeneficiary` function silently fails if the beneficiary address doesn't exist in the profit details map: [6](#0-5) 

The same vulnerability pattern exists in `UpdateWelcomeRewardWeights`: [7](#0-6) 

And in `UpdateFlexibleRewardWeights`: [8](#0-7) 

**Attack Scenario:**
1. **Term N**: Miner with pubkey "ABC" has no custom receiver. Address_1 (derived from pubkey) is added as beneficiary to BasicReward scheme with X shares.
2. **Between Terms**: Miner's admin calls `SetProfitsReceiver` to change receiver to Address_2. The `ProfitsReceiverMap` is updated, but BasicReward scheme is not.
3. **Term N+1**: `UpdateBasicMinerRewardWeights` attempts to remove beneficiaries using current receiver mapping, which now returns Address_2 for "ABC". The removal of Address_2 fails silently because it was never added. Address_1 remains with X shares.
4. **Result**: Address_1 continues receiving rewards indefinitely as a stale beneficiary, while Address_2 is added for the new term.

## Impact Explanation

**Direct Fund Impact:**
- Stale beneficiary addresses continue receiving shares of BasicReward, WelcomeReward (VotesWeightReward), and FlexibleReward (ReElectionReward) schemes indefinitely
- Each stale beneficiary dilutes rewards for legitimate current miners by inflating the total shares
- The reward calculation follows the pattern `(beneficiary_shares / total_shares) * period_rewards`, so stale shares directly reduce legitimate miner rewards
- Multiple receiver changes compound the issue exponentially, as each change creates a new stale beneficiary
- Affects all three major Treasury reward distribution channels

**Who is Affected:**
- Active miners receive reduced rewards due to inflated total shares from stale beneficiaries
- The Treasury's reward pool is systematically drained by addresses that should no longer be beneficiaries
- Legitimate candidates who don't exploit this mechanism lose competitive advantage

**Severity Justification:**
This is a HIGH severity vulnerability because:
1. It enables permanent theft of mining rewards through a simple, repeatable action
2. There is no cost to the attacker beyond being a registered candidate
3. The funds cannot be recovered once distributed to stale beneficiaries
4. The silent failure in `RemoveBeneficiary` prevents any detection mechanism
5. No expiry mechanism exists to automatically clean up stale beneficiaries

## Likelihood Explanation

**Attacker Capabilities:**
- Any candidate can call `SetProfitsReceiver` through their admin account as verified in the permission check: [9](#0-8) 
- No special privileges required beyond being a registered candidate
- Multiple changes can be made to accumulate stale beneficiaries

**Attack Complexity:**
- Extremely low complexity: requires only calling `SetProfitsReceiver` to change the receiver address
- No timing constraints or race conditions needed
- Works reliably due to deterministic state management in the contracts
- The two-term delay between add/remove operations provides an ample opportunity window for the receiver change

**Feasibility Conditions:**
- Attacker must be a current candidate (realistic for adversarial miners)
- The function is publicly accessible with only basic candidate verification
- No monitoring exists to detect stale beneficiaries in profit schemes

**Detection/Operational Constraints:**
- Stale beneficiaries are indistinguishable from legitimate beneficiaries in profit schemes
- No events or logs indicate when `RemoveBeneficiary` fails silently
- The silent failure mechanism prevents any automated detection

**Probability:**
HIGH - The attack is trivial to execute, costs nothing, and is difficult to detect. Any rational adversarial candidate could exploit this to gain unfair advantage.

## Recommendation

Modify the `SetProfitsReceiver` function to also update the Treasury's three reward schemes (BasicReward, VotesWeightReward, ReElectionReward) when a profits receiver is changed. The function should:

1. Retrieve the previous profits receiver address (as it already does)
2. Remove the old receiver from all three Treasury reward schemes
3. Add the new receiver to all three Treasury reward schemes (if the candidate is currently a beneficiary)
4. Update the `ProfitsReceiverMap`

Alternatively, modify the reward update functions to store the historical receiver address used when adding beneficiaries, and use that historical address when removing them, rather than querying the current mapping.

Additionally, the `RemoveBeneficiary` function in the Profit contract should not silently fail. It should either:
- Assert/throw an error if the beneficiary doesn't exist when `CanRemoveBeneficiaryDirectly` is true
- Log an event when removal fails to enable monitoring

## Proof of Concept

```csharp
// Test scenario demonstrating the vulnerability:
// 1. Setup: Initialize a miner in BasicReward scheme with default address
// 2. Action: Miner calls SetProfitsReceiver to change receiver address
// 3. Trigger: Next term's UpdateBasicMinerRewardWeights is called
// 4. Verify: Old address still exists as beneficiary with shares
// 5. Verify: New address also exists as beneficiary with shares
// Expected: Only new address should be beneficiary, old address should be removed
// Actual: Both addresses are beneficiaries, draining double rewards

[Fact]
public async Task StaleBeneficiary_AfterSetProfitsReceiver_Test()
{
    // Arrange: Setup candidate and add as beneficiary to BasicReward
    var candidateKeyPair = ValidationDataCenterKeyPairs.First();
    var candidatePubkey = candidateKeyPair.PublicKey.ToHex();
    var defaultAddress = Address.FromPublicKey(candidateKeyPair.PublicKey);
    var newReceiverAddress = ValidationDataCenterKeyPairs.Last();
    
    await ProduceTermAsync(); // Term N: Candidate gets added with defaultAddress
    
    // Act: Change profits receiver
    await SetProfitsReceiverAsync(candidatePubkey, Address.FromPublicKey(newReceiverAddress.PublicKey));
    
    await ProduceTermAsync(); // Term N+1: Trigger update with new receiver
    
    // Assert: Old address should be removed but still exists
    var oldBeneficiaryDetails = await GetBasicRewardProfitDetails(defaultAddress);
    oldBeneficiaryDetails.Details.Count.ShouldBeGreaterThan(0); // VULNERABILITY: Should be 0
    oldBeneficiaryDetails.Details.First().IsWeightRemoved.ShouldBeFalse(); // VULNERABILITY: Should be true
    
    var newBeneficiaryDetails = await GetBasicRewardProfitDetails(Address.FromPublicKey(newReceiverAddress.PublicKey));
    newBeneficiaryDetails.Details.Count.ShouldBeGreaterThan(0); // New address correctly added
    
    // Both addresses are now beneficiaries, draining rewards
}
```

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L608-609)
```csharp
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L620-628)
```csharp
        State.ProfitsReceiverMap[input.Pubkey] = input.ProfitsReceiverAddress;
        State.ElectionContract.SetProfitsReceiver.Send(new AElf.Contracts.Election.SetProfitsReceiverInput
        {
            CandidatePubkey = input.Pubkey,
            ReceiverAddress = input.ProfitsReceiverAddress,
            PreviousReceiverAddress = previousProfitsReceiver ?? new Address()
        });

        return new Empty();
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L651-655)
```csharp
    private Address GetProfitsReceiver(string pubkey)
    {
        return State.ProfitsReceiverMap[pubkey] ??
               Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey));
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L657-663)
```csharp
    private List<Address> GetAddressesFromCandidatePubkeys(ICollection<string> pubkeys)
    {
        var addresses = pubkeys.Select(k => Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)))
            .ToList();
        addresses.AddRange(pubkeys.Select(GetProfitsReceiver));
        return addresses;
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L780-787)
```csharp
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L814-819)
```csharp
                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L850-857)
```csharp
        var previousMinerAddresses =
            GetAddressesFromCandidatePubkeys(previousTermInformation.RealTimeMinersInformation.Keys);
        var possibleWelcomeBeneficiaries = new RemoveBeneficiariesInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            Beneficiaries = { previousMinerAddresses }
        };
        State.ProfitContract.RemoveBeneficiaries.Send(possibleWelcomeBeneficiaries);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L905-914)
```csharp
        if (State.ProfitContract.GetScheme.Call(State.ReElectionRewardHash.Value).TotalShares > 0)
        {
            var previousMinerAddresses =
                GetAddressesFromCandidatePubkeys(previousTermInformation.RealTimeMinersInformation.Keys);
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.ReElectionRewardHash.Value,
                Beneficiaries = { previousMinerAddresses }
            });
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-235)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();
```
