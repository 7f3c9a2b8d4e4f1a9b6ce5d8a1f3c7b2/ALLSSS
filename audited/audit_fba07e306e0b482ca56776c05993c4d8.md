### Title
Insufficient Miner List Length in GetVictories() Due to Incorrect Backup Limit Calculation

### Summary
The `GetVictories()` function contains a critical logic error where it limits backup miners based on `currentMiners.Count` instead of the actual `backups.Count`, resulting in a final victories list that can be significantly shorter than the required `State.MinersCount.Value`. This violates the consensus invariant that the miner list must match the configured MinersCount, potentially degrading consensus security and network decentralization.

### Finding Description

The vulnerability exists in the private `GetVictories(List<string> currentMiners)` method. [1](#0-0) 

When valid candidates are insufficient (`validCandidates.Count < State.MinersCount.Value`), the function attempts to fill the shortage using backup miners from current miners and initial miners. [2](#0-1) 

**Root Cause:** At line 72, the code incorrectly limits the number of backups taken using `Math.Min(diff, currentMiners.Count)` instead of checking the actual size of the `backups` collection: [3](#0-2) 

The `backups` list is a filtered subset of `currentMiners` (excluding valid candidates), so `backups.Count` can be much smaller than `currentMiners.Count`. The incorrect limit means that even when `diff` (the shortage) is large, the code may attempt to take more items than exist in the `backups` collection, but the actual result will only include what's available—which can leave the final victories list undersized.

**Why Existing Protections Fail:**
- No validation exists to ensure the returned victories list has exactly `MinersCount` elements
- The consensus contract that calls this function simply uses whatever list is returned without size validation [4](#0-3) 
- The `GenerateFirstRoundOfNewTerm` method accepts any miner list size and creates a round based on the actual count [5](#0-4) 

### Impact Explanation

**Consensus Degradation:** The consensus mechanism expects a specific number of miners defined by `State.MinersCount.Value`. When fewer miners are selected, the consensus round is generated with an incorrect miner count, violating the fundamental consensus invariant. [6](#0-5) 

**Quantified Impact:**
- If `MinersCount = 17` (typical production value) but only 8 miners are selected, network security is reduced by more than 50%
- Fewer miners means easier 51% attacks, reduced decentralization, and concentrated block production power
- Mining rewards intended for 17 miners would be distributed among fewer participants, creating unfair economic advantages

**Who Is Affected:**
- The entire blockchain network suffers from weakened consensus security
- Honest miners lose their expected mining slots and rewards
- Token holders face increased centralization risk
- The governance system may make decisions based on incorrect assumptions about miner count

**Severity:** Critical—this directly compromises the security model of the entire consensus mechanism.

### Likelihood Explanation

**Attack Prerequisites:**
No attacker action is required—this is a natural state progression vulnerability that occurs when:
1. `MinersCount` is increased through governance (e.g., from 5 to 17 during network growth)
2. Insufficient new candidates announce and receive votes to fill the increased miner slots
3. The pool of current miners + initial miners is smaller than the new `MinersCount`

**Feasibility:** HIGH
- Governance-approved increases to `MinersCount` are a normal part of network scaling [7](#0-6) 
- During early network phases or growth periods, candidate acquisition may lag behind miner count increases
- No malicious action required—occurs naturally through legitimate operations

**Execution Complexity:** NONE
- Automatically triggered when `GetVictories()` is called by the consensus contract
- Public view method accessible to anyone [8](#0-7) 

**Detection Difficulty:** The issue would manifest as unexpectedly small miner lists in consensus rounds, but without explicit validation, it may go unnoticed until consensus problems emerge.

### Recommendation

**Immediate Fix:**
Modify line 72 to remove the incorrect `Math.Min` check. Since LINQ's `Take()` method safely handles requests for more items than available, simply use:

```csharp
victories.AddRange(backups.OrderBy(p => p)
    .Take(diff)  // Take as many as available, up to diff
    .Select(v => ByteStringHelper.FromHexString(v)));
```

**Additional Safeguards:**
1. Add explicit validation after the victories list is constructed:
```csharp
Assert(victories.Count == State.MinersCount.Value, 
    $"Victory list size {victories.Count} does not match MinersCount {State.MinersCount.Value}");
```

2. Consider adding a minimum candidate threshold check before allowing `MinersCount` increases in the `UpdateMinersCount` method

3. Add comprehensive test cases covering scenarios where:
   - `MinersCount` >> (`validCandidates.Count` + `currentMiners.Count`)
   - `backups.Count` < `diff` with various `currentMiners.Count` values
   - Verify that `victories.Count` always equals `MinersCount`

### Proof of Concept

**Initial State:**
- Network initialized with 5 initial miners: `["M1", "M2", "M3", "M4", "M5"]`
- `State.MinersCount.Value = 5`
- `State.InitialMiners.Value = ["M1", "M2", "M3", "M4", "M5"]`
- Current consensus round has these 5 miners active

**Step 1: Increase MinersCount via Governance**
- Governance proposal approved to set `MinersCount = 17` for network growth
- `UpdateMinersCount` is called by consensus contract [7](#0-6) 

**Step 2: Limited Candidate Participation**
- Only 3 new candidates announce and receive votes: `["C1", "C2", "C3"]`
- These become the only valid candidates (candidates with `ObtainedActiveVotedVotesAmount > 0`) [9](#0-8) 

**Step 3: GetVictories() Execution**
- Consensus contract calls `GetVictories()` for next term generation [10](#0-9) 
- `currentMiners = ["M1", "M2", "M3", "M4", "M5"]` (returned from consensus contract)
- `validCandidates = ["C1", "C2", "C3"]` (count = 3)
- `diff = 17 - 3 = 14`
- `backups = ["M1", "M2", "M3", "M4", "M5"]` (all 5 current miners, since none overlap with new candidates)
- `backups.Take(Math.Min(14, 5))` = `Take(5)` adds all 5 backups
- `victories = ["C1", "C2", "C3", "M1", "M2", "M3", "M4", "M5"]`

**Expected Result:** `victories.Count = 17` (matching MinersCount)

**Actual Result:** `victories.Count = 8` (significantly less than MinersCount)

**Success Condition:** The miner list for the next consensus term contains only 8 miners instead of the required 17, violating the consensus invariant and degrading network security by 53%.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L41-50)
```csharp
    public override PubkeyList GetVictories(Empty input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        var currentMiners = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(k => k.ToHex()).ToList();
        return new PubkeyList { Value = { GetVictories(currentMiners) } };
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L86-95)
```csharp
    private List<string> GetValidCandidates()
    {
        if (State.Candidates.Value == null) return new List<string>();

        return State.Candidates.Value.Value
            .Where(c => State.CandidateVotes[c.ToHex()] != null &&
                        State.CandidateVotes[c.ToHex()].ObtainedActiveVotedVotesAmount > 0)
            .Select(p => p.ToHex())
            .ToList();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L97-100)
```csharp
    public override Int32Value GetMinersCount(Empty input)
    {
        return new Int32Value { Value = State.MinersCount.Value };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L274-280)
```csharp
        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```
