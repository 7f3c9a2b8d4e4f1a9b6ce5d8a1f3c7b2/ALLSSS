### Title
Chain ID Spoofing in Cross-Chain Transaction Verification Allows Unauthorized Token Minting

### Summary
The `VerifyTransaction` function accepts an arbitrary `VerifiedChainId` parameter without validating it matches the expected source chain for the verification context. An attacker who controls or compromises any registered side chain can create fake cross-chain transfer proofs, enabling unlimited token minting on the destination chain without corresponding burns on legitimate source chains.

### Finding Description

**Root Cause:**

The `VerifyTransaction` function in `CrossChainContract_View.cs` accepts a user-provided `VerifiedChainId` parameter and uses it directly to retrieve merkle roots without any validation: [1](#0-0) 

This function calls `GetMerkleTreeRoot` which will return merkle roots for ANY registered chain (parent, side, or cousin) based solely on the provided `chainId`: [2](#0-1) 

**Attack Vector:**

The vulnerability is exploited through cross-chain token operations. In `CrossChainReceiveToken`, the function accepts a user-provided `FromChainId` and only validates it exists in the whitelist, not that it's the correct source chain: [3](#0-2) 

The `CrossChainVerify` helper then passes this user-controlled `chainId` directly to `VerifyTransaction`: [4](#0-3) 

**Why Existing Protections Fail:**

The whitelist check at line 611 only ensures the chain is registered, but does NOT enforce which chain should be used for a specific verification context. In a multi-chain ecosystem with multiple registered chains (main chain + multiple side chains), an attacker can choose ANY whitelisted chain, not necessarily the one where the transaction legitimately occurred. [5](#0-4) 

### Impact Explanation

**Direct Fund Impact:**

An attacker who controls a registered side chain (or compromises one) can:
1. Create arbitrary `CrossChainTransfer` transactions on their controlled chain with any amount and recipient
2. Wait for normal cross-chain indexing to occur
3. Call `CrossChainReceiveToken` on the destination chain, providing their controlled chain's ID as `FromChainId`
4. Successfully mint tokens without burning any tokens on legitimate source chains

This breaks the critical token supply invariant where cross-chain transfers should maintain total supply (burn on source = mint on destination).

**Affected Parties:**
- Token holders suffer dilution from inflated supply
- The entire cross-chain security model is compromised
- Economic integrity of the main chain is destroyed

**Severity:** CRITICAL - Enables unlimited token creation, completely bypassing the burn-to-mint requirement of cross-chain transfers.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires controlling or compromising a side chain that has its token contract registered in `CrossChainTransferWhiteList`
- Side chain operators have significant control over their chains
- Side chains may have weaker security models than the main chain

**Attack Complexity:** LOW
- Once preconditions are met, the attack is straightforward parameter manipulation
- No special timing or race conditions required
- Attacker simply provides their chain's ID instead of the legitimate source chain ID

**Feasibility Conditions:**
1. Multiple chains must be registered in the whitelist (normal in multi-chain ecosystem)
2. Attacker must control/compromise at least one registered side chain
3. Cross-chain indexing must be operational (normal operation)

**Economic Rationality:**
Creating a side chain requires locked tokens, but if the attacker can mint unlimited tokens on the main chain, the ROI is enormous. Alternatively, if an existing legitimate side chain is compromised (hack, malicious operator, vulnerability), this attack becomes cost-free.

**Detection Constraints:**
The attack appears as a legitimate cross-chain transfer from a valid registered chain, making detection difficult without checking the actual transaction history on the claimed source chain.

### Recommendation

**Code-Level Mitigation:**

1. **Add Chain Context Validation in VerifyTransaction:**

Modify `VerifyTransaction` to validate the `VerifiedChainId` against expected chains for the current context. For side chains verifying parent chain transactions, enforce `VerifiedChainId == State.ParentChainId.Value`. For parent chains verifying side chain transactions, add explicit chain ID parameter validation.

2. **Enforce Source Chain in CrossChainReceiveToken:**

Add validation in `CrossChainReceiveToken` to ensure `input.FromChainId` matches expected source chains based on the token's `IssueChainId` or other contextual information. The system should maintain a mapping of expected cross-chain routes.

3. **Add Invariant Checks:**
```
Assert(input.VerifiedChainId == expectedChainId, "Chain ID mismatch - potential spoofing attempt");
```

4. **Test Cases:**
    - Test attempting cross-chain receive with wrong FromChainId (should fail)
    - Test multi-chain scenarios where attacker provides different chain ID than transaction source
    - Verify all cross-chain operations validate expected source/destination chain relationships

### Proof of Concept

**Initial State:**
- Main Chain M (ChainId = 9992731)
- Side Chain A (ChainId = 100, legitimate)
- Side Chain B (ChainId = 200, attacker-controlled)
- Both side chains registered in `CrossChainTransferWhiteList`

**Attack Steps:**

1. **On Side Chain B (attacker-controlled):**
   - Attacker creates a `CrossChainTransfer` transaction with:
     * Symbol = "ELF"
     * Amount = 1,000,000 tokens
     * To = attacker's address on Main Chain M
     * ToChainId = 9992731 (Main Chain M)
   - Transaction gets mined on Side Chain B
   - No actual tokens burned (attacker controls this chain)

2. **Cross-Chain Indexing:**
   - Side Chain B's blocks indexed into Main Chain M (normal operation)
   - Transaction status merkle root recorded in `State.IndexedSideChainBlockData`

3. **On Main Chain M:**
   - Attacker calls `CrossChainReceiveToken` with:
     * `FromChainId = 200` (Side Chain B)
     * `ParentChainHeight` = height where Side Chain B was indexed
     * `MerklePath` = valid merkle proof from Side Chain B
     * `TransferTransactionBytes` = the fake transaction from step 1

4. **Execution Flow:**
   - Line 611: Whitelist check passes (Side Chain B is registered)
   - Line 617: `CrossChainVerify` called with `chainId = 200`
   - `VerifyTransaction` called with `VerifiedChainId = 200`
   - Line 40: `GetMerkleTreeRoot(200, parentChainHeight)` returns Side Chain B's merkle root
   - Line 43-45: Verification succeeds (transaction DOES exist on Side Chain B)
   - Line 620: Tokens minted on Main Chain M

**Expected Result:** Transaction should fail because tokens weren't burned on a legitimate source chain

**Actual Result:** 1,000,000 tokens successfully minted on Main Chain M without any corresponding burn

**Success Condition:** Attacker's balance on Main Chain M increases by 1,000,000 tokens, while no tokens were burned on any legitimate chain, breaking the token supply invariant.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L37-46)
```csharp
    public override BoolValue VerifyTransaction(VerifyTransactionInput input)
    {
        var parentChainHeight = input.ParentChainHeight;
        var merkleTreeRoot = GetMerkleTreeRoot(input.VerifiedChainId, parentChainHeight);
        Assert(merkleTreeRoot != null,
            $"Parent chain block at height {parentChainHeight} is not recorded.");
        var rootCalculated = ComputeRootWithTransactionStatusMerklePath(input.TransactionId, input.Path);

        return new BoolValue { Value = merkleTreeRoot == rootCalculated };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L253-264)
```csharp
    private Hash GetMerkleTreeRoot(int chainId, long parentChainHeight)
    {
        if (chainId == State.ParentChainId.Value)
            // it is parent chain
            return GetParentChainMerkleTreeRoot(parentChainHeight);

        if (State.SideChainInfo[chainId] != null)
            // it is child chain
            return GetSideChainMerkleTreeRoot(parentChainHeight);

        return GetCousinChainMerkleTreeRoot(parentChainHeight);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L480-482)
```csharp
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L611-617)
```csharp
        var registeredTokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        AssertCrossChainTransaction(transferTransaction, registeredTokenContractAddress,
            nameof(CrossChainTransfer));
        Context.LogDebug(() =>
            $"symbol == {tokenInfo.Symbol}, amount == {amount}, receivingAddress == {receivingAddress}, targetChainId == {targetChainId}");

        CrossChainVerify(transferTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```
