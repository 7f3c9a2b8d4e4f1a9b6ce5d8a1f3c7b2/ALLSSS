### Title
ImpliedIrreversibleBlockHeight Inflation Vulnerability Enables LIB Manipulation

### Summary
The `LibInformationValidationProvider.ValidateHeaderInformation()` method only validates that `ImpliedIrreversibleBlockHeight` doesn't decrease compared to the previous round, but fails to verify it matches the actual block height being validated. This allows malicious block producers to inject inflated values that accumulate over time and manipulate the Last Irreversible Block (LIB) height calculation, undermining consensus safety guarantees.

### Finding Description

**Root Cause:**
The validation logic in `LibInformationValidationProvider` checks monotonicity but not correctness of `ImpliedIrreversibleBlockHeight`. [1](#0-0) 

The validation only rejects blocks where the provided value is LESS than the base round's value, but accepts any value that is greater than or equal, without verifying it matches the expected block height.

**Expected vs Actual Behavior:**
When consensus extra data is generated, `ImpliedIrreversibleBlockHeight` is correctly set to `Context.CurrentHeight`: [2](#0-1) 

However, during validation at height H, the system validates against state from height H-1: [3](#0-2) 

**Missing Validation:**
There is no check to ensure `providedRound.ImpliedIrreversibleBlockHeight == block.Header.Height`. The `UpdateValueValidationProvider` also doesn't validate this field: [4](#0-3) 

**Exploitation Path:**
The inflated value is directly stored in state without additional validation: [5](#0-4) 

These stored values are then used in LIB calculation via a 2/3 consensus threshold: [6](#0-5) 

The calculation retrieves sorted implied heights from previous round miners and selects the value at index (count-1)/3: [7](#0-6) 

### Impact Explanation

**Consensus Safety Violation:**
The LIB height marks blocks as irreversible. If manipulated to advance prematurely, blocks that are not truly irreversible (lacking sufficient confirmation) could be marked as such. This breaks the fundamental consensus safety guarantee.

**Concrete Harm:**
1. **Cross-chain operations** rely on LIB to finalize cross-chain transfers - inflated LIB enables premature confirmation of unfinalized blocks
2. **Chain reorganizations** could revert blocks already marked as irreversible, causing state inconsistency
3. **Double-spending** becomes possible if blocks are marked irreversible before achieving true finality

**Affected Parties:**
- Cross-chain bridges and users performing cross-chain transfers
- Applications depending on irreversibility guarantees
- Overall network integrity

**Severity Justification:**
HIGH - Undermines core consensus invariant (LIB irreversibility), affects cross-chain security, and breaks safety guarantees critical to blockchain operation.

### Likelihood Explanation

**Attacker Capabilities:**
Any block producer (miner) can execute this attack by modifying the `ImpliedIrreversibleBlockHeight` value in their block's consensus extra data before signing. The signature validation only confirms the block producer signed it, not that the data is correct: [8](#0-7) 

**Attack Complexity:**
LOW - Single field modification in consensus extra data. No complex state manipulation required.

**Feasibility Conditions:**
- With 17 miners and 2/3 threshold: index = (17-1)/3 = 5, meaning the 6th lowest value is selected
- A single miner's inflated value (if extremely high) won't immediately affect LIB but contributes to gradual inflation
- Multiple colluding miners (at least 6 out of 17) could immediately manipulate LIB
- Single malicious miner can systematically inflate over many blocks

**Detection:**
Difficult - inflated values appear as legitimate height claims, and gradual inflation may go unnoticed until significant divergence occurs.

**Probability:**
MEDIUM to HIGH - Requires malicious miner participation but no sophisticated attack mechanics. Economic incentives exist for attacks on cross-chain operations or to enable chain reorganizations.

### Recommendation

**Immediate Fix:**
Add explicit validation in `LibInformationValidationProvider.ValidateHeaderInformation()` to check that `ImpliedIrreversibleBlockHeight` equals the block height being validated:

```csharp
// In LibInformationValidationProvider.ValidateHeaderInformation()
// Add after line 30:

// Validate ImpliedIrreversibleBlockHeight matches the block height
// Note: During validation, context is at Height-1, so block being validated is at Height
var expectedHeight = validationContext.BaseRound.RealTimeMinersInformation[pubkey]
    .ImpliedIrreversibleBlockHeight + 1; // Expected increment
    
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0)
{
    var providedHeight = providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
    // Allow only exact match with expected height or previous height (for first block)
    if (providedHeight > expectedHeight)
    {
        validationResult.Message = $"ImpliedIrreversibleBlockHeight ({providedHeight}) exceeds expected height ({expectedHeight}).";
        return validationResult;
    }
}
```

**Alternative Approach:**
Since the correct value should always be the block height, recalculate it during `ProcessUpdateValue` instead of trusting the provided value:

```csharp
// In AEDPoSContract_ProcessConsensusInformation.cs, line 248
// Replace:
minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

// With:
minerInRound.ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**Invariant Check:**
Add assertion in `ProcessUpdateValue` to validate:
```csharp
Assert(updateValueInput.ImpliedIrreversibleBlockHeight == Context.CurrentHeight,
    "ImpliedIrreversibleBlockHeight must match current block height");
```

**Test Cases:**
1. Attempt to submit block with `ImpliedIrreversibleBlockHeight` > expected height → should fail validation
2. Attempt to submit block with `ImpliedIrreversibleBlockHeight` < previous value → should fail (already checked)
3. Submit valid block with correct `ImpliedIrreversibleBlockHeight` → should succeed
4. Test LIB calculation with mixed valid/invalid historical data to ensure resilience

### Proof of Concept

**Initial State:**
- Chain at height 100
- Current round has 17 miners
- Miner A's last `ImpliedIrreversibleBlockHeight` = 99

**Attack Steps:**

1. **Block Generation (Height 101):**
   - Miner A generates consensus extra data normally
   - `ImpliedIrreversibleBlockHeight` is set to 101 (correct)
   - Miner A modifies the value to 150 (inflated by 49) before signing
   - Block is signed with modified consensus data

2. **Validation (Before Execution):**
   - Validation context uses state from height 100
   - `baseRound.ImpliedIrreversibleBlockHeight[MinerA]` = 99
   - `providedRound.ImpliedIrreversibleBlockHeight[MinerA]` = 150
   - Validation checks: 150 >= 99 → **PASSES** ✓
   - No check that 150 == 101 (expected height)

3. **Execution:**
   - `ProcessUpdateValue` stores 150 directly into state
   - No validation against `Context.CurrentHeight` (101)

4. **Future LIB Calculation (Height 102):**
   - `LastIrreversibleBlockHeightCalculator` retrieves heights from round 101
   - Sorted heights include: [99, 100, 101, 101, 101, **150**, ...]
   - At index 5: if 150 is positioned here due to other values, LIB jumps to 150
   - Blocks 102-150 are marked irreversible despite not existing yet

**Expected Result:**
Validation should reject block with `ImpliedIrreversibleBlockHeight` = 150 when block height is 101.

**Actual Result:**
Validation passes, inflated value is stored, and LIB calculation is compromised.

**Success Condition:**
LIB advances beyond actual chain height, breaking irreversibility guarantees.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusValidationProvider.cs (L70-74)
```csharp
        var isValid = await _consensusService.ValidateConsensusBeforeExecutionAsync(new ChainContext
        {
            BlockHash = block.Header.PreviousBlockHash,
            BlockHeight = block.Header.Height - 1
        }, consensusExtraData.ToByteArray());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L31-32)
```csharp
        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
```
