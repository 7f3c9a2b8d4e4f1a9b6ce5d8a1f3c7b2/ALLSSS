### Title
Missing LIB Validation in NextTerm Allows Malicious Miners to DoS Blockchain via Inconsistent Irreversible Block Fields

### Summary
The consensus validation logic fails to validate `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` consistency during NextTerm transitions. A malicious miner can provide a Round object with arbitrary/inconsistent LIB values that bypass validation because LibInformationValidationProvider is not applied to NextTerm behavior, and these fields are excluded from the Round hash computation. This enables blockchain-wide denial-of-service by manipulating the maximum block count calculation.

### Finding Description

The vulnerability exists in the consensus validation flow for NextTerm behavior. When transitioning to a new term, the validation logic in `ValidateBeforeExecution` adds different validators based on the consensus behavior: [1](#0-0) 

For NextTerm behavior (lines 89-91), only `RoundTerminateValidationProvider` is added, while `LibInformationValidationProvider` is exclusively added for UpdateValue behavior (line 82). This means `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` are never validated for consistency or reasonableness during term transitions.

The LibInformationValidationProvider performs the only validation of these fields: [2](#0-1) 

Additionally, the Round hash computation used in `ValidateConsensusAfterExecution` excludes these LIB fields entirely: [3](#0-2) 

The `GetCheckableRound` method only includes RoundNumber, TermNumber, RealTimeMinersInformation, and BlockchainAge in the hash, omitting the LIB fields. This means a malicious miner can modify these values without breaking the hash comparison check.

The attack flow begins when a miner generates NextTerm consensus information: [4](#0-3) 

The Round object from `consensusInformation.Round` is passed to `NextTermInput.Create()`: [5](#0-4) 

The Create method blindly copies all fields including the LIB values without any validation. When ProcessNextTerm executes, these malicious values are stored in state: [6](#0-5) 

### Impact Explanation

The malicious LIB values directly affect `GetMaximumBlocksCount`, which uses them to evaluate blockchain mining status: [7](#0-6) 

The BlockchainMiningStatusEvaluator uses `ConfirmedIrreversibleBlockRoundNumber` to determine blockchain status: [8](#0-7) 

**Attack Scenario:**
If an attacker sets `ConfirmedIrreversibleBlockRoundNumber = 10` (artificially low) while keeping `ConfirmedIrreversibleBlockHeight` at a reasonable value, and the current round is 100:
- The status evaluator calculates: `100 >= 10 + 8` (SevereStatusRoundsThreshold)
- This triggers `BlockchainMiningStatus.Severe`
- MaximumBlocksCount reduces to 1 (line 66)
- All miners can only produce 1 block at a time
- Blockchain throughput drops dramatically
- IrreversibleBlockHeightUnacceptable events fire (lines 61-64)

**Impact Severity:**
- **Blockchain-wide DoS**: Reduces entire network to single block production mode
- **Persistent**: Effect lasts for the entire term until next term transition
- **No fund loss**: But severe operational degradation
- **Affects all users**: Network becomes unusable for practical purposes

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be a current miner (in miner list) to produce NextTerm block
- From PreCheck validation, only miners in current or previous round can execute consensus transactions [9](#0-8) 

**Attack Complexity:**
1. Wait for term transition opportunity (when their turn comes to produce NextTerm block)
2. Generate legitimate NextTerm consensus header via GetConsensusExtraData
3. Modify `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` in the header to inconsistent values
4. Produce block with modified header
5. Block passes all validations and malicious values are stored

**Feasibility:**
- **High**: No special privileges beyond being a regular miner
- **Repeatable**: Can be executed at every term transition
- **Undetectable initially**: No validation failure occurs
- **Economic rationality**: A malicious or compromised miner could execute this to disrupt competitors

**Operational Constraints:**
- Term transitions occur less frequently than round transitions
- But effect persists for entire term (potentially thousands of blocks)
- Detection would require monitoring LIB field consistency manually

**Probability Assessment:** MEDIUM-HIGH
- Requires miner-level access (reduces attacker pool)
- But miners are not fully trusted entities in the security model
- Single compromised miner can execute attack
- Impact is severe enough to warrant high priority

### Recommendation

**Primary Fix - Add LIB Validation for NextTerm:**

Modify the validation logic in `AEDPoSContract_Validation.cs` to include LibInformationValidationProvider for NextTerm behavior:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

**Secondary Fix - Include LIB Fields in Hash:**

Modify `GetCheckableRound` in `Round.cs` to include LIB fields in hash computation:

```csharp
var checkableRound = new Round
{
    RoundNumber = RoundNumber,
    TermNumber = TermNumber,
    RealTimeMinersInformation = { minersInformation },
    BlockchainAge = BlockchainAge,
    ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight, // ADD THIS
    ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber // ADD THIS
};
```

**Additional Validation - Consistency Check:**

Add explicit consistency validation that checks the relationship between round number and block height is reasonable (e.g., height shouldn't be dramatically inconsistent with the expected blocks per round).

**Test Cases:**
1. Test NextTerm with regressed LIB height - should fail
2. Test NextTerm with regressed LIB round number - should fail  
3. Test NextTerm with inconsistent LIB height/round (height very high, round very low) - should fail
4. Test legitimate NextTerm with properly incremented LIB values - should succeed

### Proof of Concept

**Initial State:**
- Current term: 5, round: 100
- ConfirmedIrreversibleBlockHeight: 10000
- ConfirmedIrreversibleBlockRoundNumber: 98
- Attacker is a legitimate miner in the current miner list

**Attack Steps:**

1. **Term transition trigger**: Blockchain reaches condition for term change (NeedToChangeTerm returns true)

2. **Attacker's turn**: Attacker miner's time slot arrives to produce NextTerm block

3. **Generate legitimate header**: Attacker calls GetConsensusExtraData, which internally calls GetConsensusExtraDataForNextTerm, producing a legitimate Round with copied LIB values

4. **Modify LIB fields**: Before broadcasting, attacker modifies the consensus header:
   - Set `ConfirmedIrreversibleBlockRoundNumber = 10` (artificially old)
   - Keep `ConfirmedIrreversibleBlockHeight = 10000` (or any value)

5. **Broadcast block**: Block is validated:
   - ValidateConsensusBeforeExecution: PASSES (no LibInformationValidationProvider for NextTerm)
   - ValidateConsensusAfterExecution: PASSES (LIB fields not in hash)
   
6. **Execute NextTerm**: ProcessNextTerm stores the malicious Round via AddRoundInformation

**Expected Result:**
Validation should fail, rejecting the inconsistent LIB values.

**Actual Result:**
- Validation passes
- Malicious LIB values stored in state
- All subsequent blocks in new term inherit these values
- GetMaximumBlocksCount calculates: currentRound (101) >= libRoundNumber (10) + 8 â†’ Severe status
- MaximumBlocksCount reduced to 1
- Blockchain enters severe degradation mode
- All miners can only produce 1 block at a time until next term

**Success Condition:**
Monitor State.Rounds after NextTerm execution - if ConfirmedIrreversibleBlockRoundNumber is significantly inconsistent with ConfirmedIrreversibleBlockHeight and blockchain status becomes Severe despite actual LIB being recent, the attack succeeded.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L8-34)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L172-179)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextTerm), NextTermInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-78)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }

        if (!State.IsPreviousBlockInSevereStatus.Value)
            return AEDPoSContractConstants.MaximumTinyBlocksCount;

        Context.Fire(new IrreversibleBlockHeightUnacceptable
        {
            DistanceToIrreversibleBlockHeight = 0
        });
        State.IsPreviousBlockInSevereStatus.Value = false;

        return AEDPoSContractConstants.MaximumTinyBlocksCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L87-130)
```csharp
    private class BlockchainMiningStatusEvaluator
    {
        private const int AbnormalThresholdRoundsCount = 2;

        /// <summary>
        ///     Stands for R
        /// </summary>
        private readonly long _currentRoundNumber;

        /// <summary>
        ///     Stands for R_LIB
        /// </summary>
        private readonly long _libRoundNumber;

        /// <summary>
        ///     Stands for CB0
        /// </summary>
        private readonly int _maximumTinyBlocksCount;

        public BlockchainMiningStatusEvaluator(long currentConfirmedIrreversibleBlockRoundNumber,
            long currentRoundNumber, int maximumTinyBlocksCount)
        {
            _libRoundNumber = currentConfirmedIrreversibleBlockRoundNumber;
            _currentRoundNumber = currentRoundNumber;
            _maximumTinyBlocksCount = maximumTinyBlocksCount;
        }

        /// <summary>
        ///     Stands for CB1
        /// </summary>
        public int SevereStatusRoundsThreshold => Math.Max(8, _maximumTinyBlocksCount);

        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
        }
    }
```
