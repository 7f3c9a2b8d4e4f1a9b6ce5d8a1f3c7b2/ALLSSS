### Title
Unbounded State Growth in DistributedProfitsMap Due to Missing Cleanup Mechanism

### Summary
The `DistributedProfitsMap` state variable accumulates profit distribution records indefinitely without any cleanup mechanism, causing unbounded blockchain state growth. While the contract implements cleanup for `ProfitDetailsMap` (beneficiary records), it lacks equivalent logic for `DistributedProfitsMap`, resulting in permanent storage bloat as each profit distribution period creates a new entry that persists forever, even after all claims are complete and the grace period has expired.

### Finding Description

The vulnerability exists in the Profit contract's state management design. [1](#0-0) 

**Root Cause:**

When profits are distributed via `DistributeProfits()`, a unique virtual address is generated for each period, and a `DistributedProfitsInfo` record is stored in `DistributedProfitsMap`. [2](#0-1) 

This information is persisted in the `UpdateDistributedProfits()` method: [3](#0-2) 

Similarly, when profits are burned, entries are still created: [4](#0-3) 

**Why Protections Fail:**

The contract demonstrates awareness of storage management by implementing cleanup logic for `ProfitDetailsMap` (beneficiary records), which removes old profit details when they exceed the grace period: [5](#0-4) 

However, **no equivalent cleanup mechanism exists for `DistributedProfitsMap`**. A grep search for removal operations on `DistributedProfitsMap` returned zero results, confirming the absence of any cleanup code.

**Execution Path:**

1. Treasury calls `DistributeProfits()` every consensus term (~7 days by default) [6](#0-5) 
2. Multiple schemes distribute profits per term: [7](#0-6) 
3. Each distribution creates a permanent entry keyed by virtual address (schemeId XOR hash(period)): [8](#0-7) 
4. When beneficiaries claim via `ClaimProfits()`, tokens are transferred but the `DistributedProfitsInfo` record remains unmodified: [9](#0-8) 
5. Even after the grace period (`ProfitReceivingDuePeriodCount`) expires and no further claims are possible, entries persist indefinitely

### Impact Explanation

**Concrete Harm:**
- **Unbounded State Growth**: Each consensus term (every ~7 days) adds permanent entries to blockchain state
- **Quantified Growth Rate**: 
  - ~52 distribution periods per year
  - 5+ core system schemes (Treasury, RewardHash, VotesWeightRewardHash, ReElectionRewardHash, BasicRewardHash)
  - 260+ entries over 5 years per scheme
  - Total: 1,300+ permanent entries for core schemes alone
  - Each entry: ~200+ bytes minimum (TotalShares + IsReleased + AmountsMap with multiple tokens)
  - Additional user-created schemes amplify this (scheme creation is permissionless) [10](#0-9) 

**Who is Affected:**
- All full nodes must store this ever-growing state
- New nodes face increasing sync times
- Node operators incur growing storage costs
- No pruning mechanism exists without a hard fork

**Severity Justification:**
Medium severity because while the growth is unbounded and certain, it accumulates slowly (~10MB over 10 years for core schemes), doesn't prevent operations, and doesn't directly compromise funds or security—but represents a clear operational degradation over time.

### Likelihood Explanation

**Attack Characteristics:**
- **No attacker required**: Natural system operation causes accumulation
- **Entry point**: Public `DistributeProfits()` method called by scheme managers
- **Complexity**: Zero - happens automatically every consensus term
- **Preconditions**: Normal blockchain operation
- **Detection**: Easily observable through state size growth queries

**Probability:**
- **Certain (100%)**: Treasury automatically distributes profits every consensus term via the AEDPoS contract
- **Already occurring**: This is happening in production since genesis
- **Irreversible**: No mechanism to clean up existing entries
- **Accelerating**: More schemes over time = faster accumulation

### Recommendation

**Immediate Fix:**

Add cleanup logic for old `DistributedProfitsMap` entries, similar to the existing `ProfitDetailsMap` cleanup. In the `DistributeProfits()` or `ClaimProfits()` methods, implement:

```csharp
// After profits are distributed and grace period expires
if (scheme.CurrentPeriod > oldPeriod + scheme.ProfitReceivingDuePeriodCount)
{
    var oldVirtualAddress = GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, oldPeriod);
    State.DistributedProfitsMap.Remove(oldVirtualAddress);
}
```

**Invariant to Enforce:**
`DistributedProfitsMap` should only contain entries for periods where claims are still possible: `period >= currentPeriod - ProfitReceivingDuePeriodCount`

**Test Cases:**
1. Verify entries are removed after `ProfitReceivingDuePeriodCount` periods pass
2. Ensure cleanup doesn't affect active periods
3. Test that historical queries fail gracefully for cleaned periods
4. Confirm state size stabilizes over time rather than growing unbounded

**Alternative Approach:**
If historical data is truly needed for auditing, implement an archive/pruning flag allowing nodes to optionally keep old data while enabling production nodes to prune safely.

### Proof of Concept

**Initial State:**
- Profit scheme exists (e.g., Treasury scheme)
- `ProfitReceivingDuePeriodCount` = 10 (default) [11](#0-10) 

**Transaction Steps:**
1. Period 1: Call `DistributeProfits(schemeId, period=1)` → Creates entry in `DistributedProfitsMap[virtualAddr_1]`
2. Beneficiaries claim profits from period 1
3. Period 2: Call `DistributeProfits(schemeId, period=2)` → Creates entry in `DistributedProfitsMap[virtualAddr_2]`
4. Continue for periods 3-20
5. At period 20, query `GetDistributedProfitsInfo(schemeId, period=1)`

**Expected Result:**
Period 1 entry should be cleaned up after period 11 (1 + 10 grace periods), since no further claims are possible and all beneficiaries have been removed from `ProfitDetailsMap` for that period.

**Actual Result:**
Period 1 entry persists indefinitely in `DistributedProfitsMap`. Querying state at period 100 still shows entries from periods 1-99, all consuming storage despite being unclamable for 80+ periods. This can be verified by calling `GetDistributedProfitsInfo()` for any historical period - it always returns data, confirming no cleanup occurs. [12](#0-11) 

**Success Condition for Exploit:**
State size grows linearly with number of periods. After N periods across M schemes, `DistributedProfitsMap` contains N×M entries, all permanent, demonstrating unbounded storage bloat.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContractState.cs (L11-11)
```csharp
    public MappedState<Address, DistributedProfitsInfo> DistributedProfitsMap { get; set; }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L44-59)
```csharp
    public override Hash CreateScheme(CreateSchemeInput input)
    {
        ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);

        if (input.ProfitReceivingDuePeriodCount == 0)
            input.ProfitReceivingDuePeriodCount = ProfitContractConstants.DefaultProfitReceivingDuePeriodCount;
        else
            Assert(
                input.ProfitReceivingDuePeriodCount > 0 &&
                input.ProfitReceivingDuePeriodCount <= ProfitContractConstants.MaximumProfitReceivingDuePeriodCount,
                "Invalid profit receiving due period count.");

        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L203-207)
```csharp
        // Remove details too old.
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L482-483)
```csharp
        var profitsReceivingVirtualAddress =
            GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, releasingPeriod);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L556-556)
```csharp
        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-583)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L866-874)
```csharp
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L129-134)
```csharp
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.TreasuryHash.Value,
            Period = input.PeriodNumber,
            AmountsMap = { State.SymbolList.Value.Value.ToDictionary(s => s, s => 0L) }
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L708-734)
```csharp
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.RewardHash.Value,
            Period = termNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            Period = termNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.ReElectionRewardHash.Value,
            Period = termNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.BasicRewardHash.Value,
            Period = termNumber,
            AmountsMap = { amountsMap }
        });
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L37-44)
```csharp
    public override DistributedProfitsInfo GetDistributedProfitsInfo(SchemePeriod input)
    {
        var releasedProfitsVirtualAddress = GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);
        return State.DistributedProfitsMap[releasedProfitsVirtualAddress] ?? new DistributedProfitsInfo
        {
            TotalShares = -1
        };
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L57-60)
```csharp
    private Hash GeneratePeriodVirtualAddressFromHash(Hash schemeId, long period)
    {
        return HashHelper.XorAndCompute(schemeId, HashHelper.ComputeFrom(period));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L6-6)
```csharp
    public const int DefaultProfitReceivingDuePeriodCount = 10;
```
