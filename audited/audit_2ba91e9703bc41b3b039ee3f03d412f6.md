# Audit Report

## Title
Missing IsMinerListJustChanged Validation Allows Arbitrary Miner List Installation During Term Transitions

## Summary
The `ValidationForNextTerm()` function in the AEDPoS consensus contract fails to verify that the miner list provided in `NextTerm` transactions matches the election results from the Election contract. This allows any current miner to bypass the democratic election mechanism and install an arbitrary set of miners for the next term, gaining complete control over block production and mining rewards.

## Finding Description

The AEDPoS consensus system is designed to transition between terms using miner lists determined by the Election contract's voting mechanism. However, the validation logic for term transitions contains a critical gap that allows this security guarantee to be bypassed.

**The Legitimate Flow:**

When generating a proper term transition, the contract calls `TryToGetVictories()` to retrieve the elected miner list from the Election contract, and the `IsMinerListJustChanged` flag is always set to true [1](#0-0) [2](#0-1) 

**The Vulnerability:**

During validation, `ValidationForNextTerm()` only checks that term and round numbers increment correctly, but performs no validation of the miner list content or the `IsMinerListJustChanged` flag [3](#0-2) 

During execution, `ProcessNextTerm()` directly extracts the miner list from the attacker-provided input without any cross-check against Election contract results [4](#0-3) [5](#0-4) 

The `SetMinerList()` function only checks whether a miner list already exists for that term, not whether it matches election results [6](#0-5) 

**Attack Execution:**

A malicious current miner can:
1. Wait until term transition time (when `NeedToChangeTerm()` returns true)
2. Construct a `NextTermInput` with correct term number (current + 1) and round number (current + 1), but with an arbitrary `RealTimeMinersInformation` dictionary containing attacker-controlled public keys
3. Call the public `NextTerm()` method [7](#0-6) 
4. Pass `PreCheck()` which only verifies the sender is a current/previous miner [8](#0-7) 
5. Pass validation which only checks term/round number increments
6. The arbitrary miner list gets installed and persists for the entire term

## Impact Explanation

This vulnerability completely subverts the election-based consensus mechanism that is fundamental to AElf's governance model. The impact is severe:

**Consensus Integrity Break**: The core security guarantee that miners are democratically elected is violated. An attacker gains the ability to unilaterally determine who can produce blocks for an entire term (approximately 7 days).

**Mining Reward Theft**: All mining rewards for the compromised term are redirected to the attacker's chosen addresses instead of legitimately elected candidates. Given the system generates mining rewards per block and donates them to Treasury [9](#0-8) , this represents significant economic damage over a full term.

**Governance Capture**: By controlling the miner set, the attacker effectively controls block production, transaction inclusion, and can potentially influence other governance mechanisms that depend on miner participation.

**Legitimate Candidates Disenfranchised**: Candidates who won the election and should rightfully be miners are completely excluded, undermining the democratic nature of the network.

This is **HIGH severity** because it breaks a critical security invariant of the consensus system with lasting effects across an entire term.

## Likelihood Explanation

**Attacker Requirements**: The attacker must be a current or previous miner, which means they already have block production privileges. While this is a privileged position, the threat model for consensus systems must consider malicious miners.

**Attack Complexity**: LOW - The attack is straightforward to execute:
- The timing window is predictable (based on blockchain age and configured term duration)
- Constructing the malicious `NextTermInput` requires only copying the legitimate structure but replacing the miner public keys
- No complex cryptographic operations or multi-step coordination required

**Feasibility**: HIGH - The only race condition is ensuring the malicious transaction is included before any honest miner's `NextTerm` transaction in the same block. However, as a current miner, the attacker has privileged access to propose this transaction in their own block.

**Detection**: The attack leaves no immediate trace during validation since all checks pass. It would only be discovered when the wrong miners start producing blocks in the new term, by which point the damage is done.

**Overall Likelihood**: MEDIUM-HIGH - Any malicious current miner can execute this attack during each term transition, making it a realistic and significant threat.

## Recommendation

Add comprehensive validation to `ValidationForNextTerm()` that verifies:

1. **Verify IsMinerListJustChanged flag**: Check that `extraData.Round.IsMinerListJustChanged == true` for all term transitions
2. **Validate miner list against election results**: During validation, call the Election contract's `GetVictories()` and verify that the miner list in the input matches the elected candidates

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Is next term number correct?
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // NEW: Verify IsMinerListJustChanged flag
    if (!extraData.Round.IsMinerListJustChanged)
        return new ValidationResult { Message = "IsMinerListJustChanged must be true for term transitions." };
    
    // NEW: Validate miner list against election results
    // This requires access to Election contract during validation
    // Consider adding ValidateMinerListAgainstElection() helper
    
    return new ValidationResult { Success = true };
}
```

Additionally, consider adding a verification step in `ProcessNextTerm()` that compares the provided miner list against `TryToGetVictories()` results before calling `SetMinerList()`.

## Proof of Concept

The vulnerability can be demonstrated with a test that:
1. Sets up a network with current miners
2. Advances time to term transition point
3. Has a malicious miner call `NextTerm()` with an arbitrary miner list (containing only the attacker's addresses)
4. Verifies the malicious miner list is successfully installed in `State.MinerListMap[newTermNumber]`
5. Confirms the installed list does NOT match `ElectionContract.GetVictories()` results

The test would show that validation passes and the arbitrary miner list is stored, proving the election mechanism can be bypassed.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L42-42)
```csharp
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L163-163)
```csharp
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```
