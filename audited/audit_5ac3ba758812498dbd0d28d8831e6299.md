# Audit Report

## Title
Overly Restrictive DecryptedPieces Count Check Defeats Threshold Secret Sharing in Consensus

## Summary
The `RevealSharedInValues()` function in the AEDPoS consensus contract requires all miners to submit decrypted pieces instead of using the cryptographic threshold (2/3), completely defeating the fault-tolerance property of Shamir's secret sharing. A single miner can prevent reconstruction of any other miner's `PreviousInValue`, forcing the system to fall back to fake values and breaking the commit-reveal integrity of random number generation.

## Finding Description

The vulnerability exists in the secret sharing reconstruction logic where the validation check contradicts the cryptographic design of threshold secret sharing. [1](#0-0) 

The function correctly calculates `minimumCount` as the 2/3 threshold needed for Shamir's secret sharing reconstruction. [2](#0-1) 

However, the validation check on line 36 requires `DecryptedPieces.Count >= minersCount` (all miners) rather than `>= minimumCount` (2/3 threshold). This check causes the reconstruction to be skipped even when sufficient shares are available. [3](#0-2) 

The actual secret reconstruction correctly uses `minimumCount`, but this code is never reached due to the overly restrictive check on line 36.

The same flawed logic exists in the off-chain service: [4](#0-3) [5](#0-4) [6](#0-5) 

**Attack Scenario:**
1. Miner A generates and shares encrypted pieces with all miners in round N-1
2. In round N, malicious Miner B withholds their decrypted piece for Miner A
3. During the extra block transition to round N+1, `RevealSharedInValues` attempts reconstruction
4. Despite having pieces from (minersCount - 1) miners (exceeding the 2/3 threshold), the check on line 36 fails
5. Miner A's `PreviousInValue` remains null/unreconstructed

When `PreviousInValue` cannot be reconstructed, the system generates fake values: [7](#0-6) 

These fake values are then used in signature calculations that contribute to consensus randomness: [8](#0-7) 

The validation layer permits null/empty `PreviousInValue` without enforcement: [9](#0-8) [10](#0-9) 

## Impact Explanation

**Consensus Integrity Breach:**
The AEDPoS consensus relies on a commit-reveal scheme where miners commit to `in_value` via `out_value = Hash(in_value)` in one round, then reveal the actual `in_value` in the next round for verification. When secret reconstruction fails due to the overly restrictive check, the system loses the actual `in_value` and replaces it with a deterministic fake value based on the miner's public key and block height. This breaks the verifiability guarantee - the revealed value no longer matches what was committed.

**Random Number Manipulation:**
The signature used in consensus is calculated by XORing the `previousInValue` with all miners' signatures from the previous round. When fake values replace actual committed values, the randomness source becomes predictable and manipulable. An attacker can strategically withhold decrypted pieces to force specific miners into using fake values, thereby influencing the consensus randomness that affects mining order and other consensus decisions.

**Complete Failure of Secret Sharing:**
The fundamental purpose of using a (2/3, n) threshold secret sharing scheme is fault tolerance - the system should function correctly even if up to 1/3 of participants are offline, malicious, or uncooperative. By requiring all n participants, the implementation provides no fault tolerance whatsoever. A single miner can DoS the entire secret sharing mechanism, rendering it completely ineffective.

## Likelihood Explanation

**High Likelihood:**

**Attacker Capabilities:** Any miner participating in the consensus network can execute this attack. The attacker simply needs to refrain from including decrypted pieces in their `UpdateValue` transaction. No special permissions, significant economic resources, or technical exploits are required.

**Attack Complexity:** Trivial. The attacker's client software can be modified to skip submitting decrypted pieces for targeted miners. From an external perspective, this appears identical to network delays or temporary node issues.

**No Deterrents:** There are no apparent penalties or slashing mechanisms for miners who fail to submit decrypted pieces. The validation logic explicitly states "It is permissible for miners not publish their in values," treating withheld data as acceptable behavior rather than malicious conduct.

**Economic Incentives:** An attacker can:
- Prevent competitors from proving honest participation
- Manipulate consensus randomness to influence mining order selection
- Degrade the quality of randomness across multiple rounds
- Create plausible deniability by claiming technical issues

**Undetectable Attribution:** The blockchain state only reveals that reconstruction failed, not which specific miner withheld their piece. This makes it extremely difficult to identify and hold attackers accountable.

## Recommendation

Change the validation check to use the cryptographic threshold instead of requiring all miners:

**In contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs line 36:**
```csharp
// Change from:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

// To:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

**In src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs line 162:**
```csharp
// Change from:
if (minerInRound.DecryptedPieces.Count < minersCount) continue;

// To:
if (minerInRound.DecryptedPieces.Count < minimumCount) continue;
```

This change would restore the fault-tolerance property of threshold secret sharing, allowing reconstruction with only 2/3 of shares as cryptographically intended, while maintaining security since the reconstruction algorithm already validates the threshold requirement.

## Proof of Concept

```csharp
[Fact]
public async Task SecretSharing_WithholdSingleDecryptedPiece_PreventReconstruction()
{
    // Setup: 5 miners in consensus
    const int minersCount = 5;
    const int threshold = 3; // 2/3 of 5 = 3.33, rounds down to 3
    
    // Round N-1: Miner A shares encrypted pieces with all 5 miners
    var minerA = "MinerA_PublicKey";
    var currentRound = GenerateRoundWithMiners(minersCount);
    
    // Round N: 4 out of 5 miners submit decrypted pieces for Miner A
    // (exceeds threshold of 3, but less than minersCount of 5)
    var previousRound = new Round();
    previousRound.RealTimeMinersInformation[minerA] = new MinerInRound
    {
        EncryptedPieces = GenerateEncryptedPieces(minersCount),
        DecryptedPieces = GenerateDecryptedPieces(4) // Only 4 out of 5
    };
    
    // Call RevealSharedInValues
    RevealSharedInValues(currentRound, "MinerB_PublicKey");
    
    // VULNERABILITY: Despite having 4 pieces (exceeds threshold of 3),
    // PreviousInValue is NOT reconstructed because check requires all 5
    Assert.Null(currentRound.RealTimeMinersInformation[minerA].PreviousInValue);
    
    // System falls back to fake value in next block production
    var fakeValue = HashHelper.ComputeFrom(minerA.Append(Context.CurrentHeight.ToString()));
    
    // This fake value is used in signature calculation, compromising randomness
    var signature = previousRound.CalculateSignature(fakeValue);
    Assert.NotEqual(expectedSignature, signature); // Randomness compromised
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L22-23)
```csharp
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L147-149)
```csharp
        var minersCount = round.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L162-162)
```csharp
            if (minerInRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L175-176)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L96-106)
```csharp
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L42-46)
```csharp
        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```
