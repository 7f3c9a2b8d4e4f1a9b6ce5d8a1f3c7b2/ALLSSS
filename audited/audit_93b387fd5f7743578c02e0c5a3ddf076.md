### Title
Missing Bounds Validation on FinalOrderOfNextRound Allows Mining Schedule Disruption

### Summary
The `ProcessUpdateValue` method accepts user-supplied `SupposedOrderOfNextRound` and `TuneOrderInformation` values without validating they are within the valid range [1, minersCount]. A malicious miner can submit out-of-bounds order values that propagate to the next round's mining schedule, causing incorrect `ExpectedMiningTime` calculations and disrupting consensus operations including extra block producer selection and continuous mining prevention logic.

### Finding Description

The vulnerability exists in the consensus update flow where order values lack bounds validation:

**Root Cause:** In `ProcessUpdateValue`, the method directly assigns user-supplied order values from `UpdateValueInput` without any bounds checking: [1](#0-0) [2](#0-1) 

These unchecked values become the `FinalOrderOfNextRound` for miners, which is later used to set the `Order` field when generating the next round: [3](#0-2) 

The `Order` field directly determines `ExpectedMiningTime` through multiplication with `miningInterval`, without any bounds enforcement.

**Why Existing Protections Fail:**

1. The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue` fields, not order values: [4](#0-3) 

2. The `NextRoundMiningOrderValidationProvider` validates `FinalOrderOfNextRound` for the *next* round being created, not the `Order` field values derived from the *previous* round's `FinalOrderOfNextRound`: [5](#0-4) 

3. While `ApplyNormalConsensusData` correctly calculates bounded order values using modulus arithmetic, this is only called during block generation on the client side, not during validation: [6](#0-5) 

**Execution Path:**
1. Malicious miner produces block during their time slot
2. Calls `UpdateValue` with crafted `UpdateValueInput` containing out-of-bounds values
3. `ProcessConsensusInformation` is invoked, which calls `ProcessUpdateValue`
4. Invalid order values stored in state without validation
5. Later, when `NextRound` is triggered, `GenerateNextRoundInformation` uses these invalid values to set `Order` and calculate `ExpectedMiningTime`
6. Mining schedule breaks due to invalid time calculations

### Impact Explanation

**Consensus Disruption:**
- Invalid `Order` values (e.g., 1000 when `minersCount` is 7) cause `ExpectedMiningTime` to be calculated as `currentBlockTimestamp + (4000ms × 1000) = 4,000,000ms` (66+ minutes in the future)
- Affected miners cannot mine at their time slots, effectively excluding them from consensus
- Time slot validation fails for subsequent blocks from affected miners

**Critical Logic Failures:**
- `BreakContinuousMining` attempts to find miners with `Order` values of 1, 2, minersCount, and minersCount-1, which fail when orders are out of bounds: [7](#0-6) 

- Extra block producer selection may fail if no miner has the expected order calculated via modulus: [8](#0-7) 

**Attack Amplification:**
Through `TuneOrderInformation`, a single malicious miner can set out-of-bounds `FinalOrderOfNextRound` values for *other* miners, multiplying the impact across the entire miner set.

**Severity:** HIGH - Direct disruption of consensus mechanism, denial of service to mining operations, exploitable by single compromised miner with ability to affect entire network.

### Likelihood Explanation

**Attacker Capabilities:** Any miner in the active miner list can exploit this vulnerability. Miners have legitimate access to produce blocks and submit `UpdateValue` transactions during their time slots.

**Attack Complexity:** Low. The attacker simply needs to:
1. Modify their block producer client to submit custom `UpdateValueInput` values
2. Set `SupposedOrderOfNextRound` to an arbitrary int32 value (e.g., 1000, 10000, or even negative values)
3. Optionally populate `TuneOrderInformation` to affect other miners
4. Include matching values in block header extra data

**Feasibility Conditions:**
- Attacker must be an active miner (realistic given election process)
- No special permissions beyond normal mining rights required
- Attack executes during attacker's regular time slot
- No economic cost beyond normal block production

**Detection:** Difficult to detect proactively since:
- Validation passes with malformed values
- Impact only manifests in next round generation
- Could be mistaken for network issues or client bugs

**Probability:** HIGH - Low barrier to entry, single compromised miner sufficient, immediate impact on next round.

### Recommendation

**Immediate Fix:**
Add bounds validation in `ProcessUpdateValue` before accepting order values:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    
    // Validate SupposedOrderOfNextRound
    Assert(updateValueInput.SupposedOrderOfNextRound >= 1 && 
           updateValueInput.SupposedOrderOfNextRound <= minersCount,
           "SupposedOrderOfNextRound must be within [1, minersCount]");
    
    // Validate TuneOrderInformation values
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount,
               "TuneOrderInformation values must be within [1, minersCount]");
    }
    
    // ... rest of method
}
```

Location to add validation: [9](#0-8) 

**Additional Safeguards:**
1. Add validation in `UpdateValueValidationProvider` to check order bounds during pre-execution validation
2. Add assertion in `GenerateNextRoundInformation` to reject invalid `FinalOrderOfNextRound` values as a defense-in-depth measure
3. Add unit tests verifying rejection of out-of-bounds order values in `UpdateValueInput`

**Test Cases:**
- Submit `UpdateValue` with `SupposedOrderOfNextRound = 0` → should fail
- Submit `UpdateValue` with `SupposedOrderOfNextRound = minersCount + 1` → should fail  
- Submit `UpdateValue` with negative order value → should fail
- Submit `UpdateValue` with `TuneOrderInformation` containing out-of-bounds values → should fail
- Verify next round generation fails gracefully if somehow invalid orders exist in state

### Proof of Concept

**Initial State:**
- Network has 7 active miners (minersCount = 7)
- Current round number = 100
- Attacker is miner with pubkey "AttackerMiner"
- Mining interval = 4000ms

**Attack Steps:**

1. Attacker's time slot arrives in round 100
2. Attacker modifies their block producer client to construct malicious `UpdateValueInput`:
   ```
   UpdateValueInput {
     SupposedOrderOfNextRound = 1000,  // Out of bounds!
     TuneOrderInformation = {
       "HonestMiner1": 2000,  // Attack other miner
       "HonestMiner2": 3000
     },
     // ... other valid fields
   }
   ```

3. Attacker produces block with this transaction and matching consensus extra data

4. Block passes validation because:
   - `UpdateValueValidationProvider` doesn't check order values
   - `ValidateConsensusAfterExecution` matches modified state with modified header
   - No bounds checking exists

5. Transaction executes via `ProcessUpdateValue`:
   - AttackerMiner.FinalOrderOfNextRound = 1000
   - HonestMiner1.FinalOrderOfNextRound = 2000
   - HonestMiner2.FinalOrderOfNextRound = 3000

6. Round 100 completes, round 101 is generated via `NextRound`

**Expected Result (Secure):**
- All miners have Order values in range [1, 7]
- ExpectedMiningTime values are sequential: T, T+4s, T+8s, T+12s, T+16s, T+20s, T+24s
- Mining schedule operates normally

**Actual Result (Vulnerable):**
- AttackerMiner.Order = 1000, ExpectedMiningTime = T + 4,000,000ms (66 minutes delay)
- HonestMiner1.Order = 2000, ExpectedMiningTime = T + 8,000,000ms (133 minutes delay)
- HonestMiner2.Order = 3000, ExpectedMiningTime = T + 12,000,000ms (200 minutes delay)
- BreakContinuousMining fails to find miners with Order=1,2,6,7 (returns null)
- Extra block producer selection may fail
- Affected miners cannot produce blocks at valid times
- Consensus disrupted for entire round 101

**Success Condition:** Mining schedule for round 101 contains miners with Order > minersCount, causing time slot calculation errors and consensus failure.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-33)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-65)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-90)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-22)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

```
