### Title
Consensus Round Number Reset Vulnerability via Validation Bypass During Bootstrap Phase

### Summary
During the first 23 blocks of blockchain initialization, a validation bypass allows a malicious miner to reset the consensus round number back to 1 even after the system has progressed to subsequent rounds. This causes `GetConsensusCommand` to use `FirstRoundCommandStrategy` instead of the appropriate strategy, resulting in incorrect mining time calculations and consensus fork.

### Finding Description

The vulnerability stems from two interconnected flaws:

**Flaw 1: Validation Bypass During Bootstrap**
In the `ValidateBeforeExecution` method, there is a special case that bypasses normal consensus validation during the first 23 blocks when only a single miner is actively producing blocks: [1](#0-0) 

This early return at line 43 occurs BEFORE the `RoundTerminateValidationProvider` is added to the validation pipeline, completely bypassing the critical round number increment validation.

**Flaw 2: Unsafe Round Number Update Logic**
The `TryToUpdateRoundNumber` method has a special case that allows setting round number to 1 without validating whether this is appropriate: [2](#0-1) 

The condition at line 94 evaluates to `false` when `roundNumber == 1`, allowing the update to succeed regardless of the current round number.

**Exploitation Path:**
The normal validation would catch invalid round transitions via `RoundTerminateValidationProvider`: [3](#0-2) 

However, when the bootstrap validation bypass is active, this check never executes.

**Attack Execution:**
1. Attacker submits `NextRound` transaction with `NextRoundInput{RoundNumber: 1}` during blocks 1-23 while being the sole active miner
2. Validation bypasses round number checks due to bootstrap condition
3. `ProcessNextRound` executes, calling `TryToUpdateRoundNumber(1)` which succeeds
4. `State.CurrentRoundNumber.Value` is reset to 1
5. Original round 1 data in `State.Rounds[1]` is overwritten [4](#0-3) 

**Consequence - Wrong Strategy Selection:**
When miners subsequently request consensus commands, the check at line 28 now evaluates to true, causing incorrect strategy selection: [5](#0-4) 

**Incorrect Behavior:**
`FirstRoundCommandStrategy` uses simplified time calculations without RoundId/PreviousRoundId information: [6](#0-5) 

Compare this to `NormalBlockCommandStrategy` which includes proper round tracking: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Compromise:**
- The round number reset causes miners to use `FirstRoundCommandStrategy` which calculates mining times using a simplified formula (`Order + MinersCount - 1) * miningInterval`) instead of the actual expected mining times from the round state
- The consensus hint omits `RoundId` and `PreviousRoundId` fields, breaking round continuity validation
- Original round 1 historical data is permanently overwritten, corrupting consensus state

**Blockchain Fork:**
- When additional miners come online after the attack, they observe `CurrentRoundNumber == 1` but the blockchain has already progressed past genesis
- Nodes disagree on mining schedules due to different time calculations
- The corrupted state cannot be reconciled without chain rollback

**Severity: Critical**
- Directly compromises consensus mechanism integrity
- Causes irrecoverable consensus fork
- Affects entire network operation
- No recovery path without manual intervention

### Likelihood Explanation

**Attack Feasibility: High During Bootstrap**

The attack requires:
1. **Window of Opportunity**: First 23 blocks (checked at line 24 of validation code, using `AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3)` where the constant is 8) [8](#0-7) 

2. **Sole Active Miner**: Attacker must be the only miner producing blocks (other miners offline/delayed start)
3. **Valid Miner Status**: Attacker must be in the configured miner list

**Realistic Scenario:**
This is highly realistic during network initialization where:
- Not all miners start simultaneously due to coordination delays, network issues, or deployment staging
- The system explicitly allows single-miner operation during bootstrap phase
- The relaxed validation is intentionally designed for this scenario but lacks safeguards against malicious exploitation

**Attack Complexity: Low**
- Requires only crafting a single `NextRound` transaction with manipulated round number
- No complex transaction sequences or timing dependencies
- No economic cost (attacker is legitimate miner earning block rewards)

**Detection: Difficult**
- Appears as valid consensus transaction during bootstrap
- No immediate error or anomaly until other miners come online
- Damage becomes apparent only after the vulnerable window closes

### Recommendation

**Immediate Fix:**
Add explicit round number validation in `TryToUpdateRoundNumber` to prevent backward transitions:

```csharp
private bool TryToUpdateRoundNumber(long roundNumber)
{
    var oldRoundNumber = State.CurrentRoundNumber.Value;
    
    // Never allow backward round transitions
    if (oldRoundNumber > 0 && roundNumber <= oldRoundNumber) 
        return false;
    
    // For forward transitions (not first round), must be sequential
    if (roundNumber != 1 && oldRoundNumber + 1 != roundNumber) 
        return false;
        
    State.CurrentRoundNumber.Value = roundNumber;
    return true;
}
```

**Secondary Fix:**
Strengthen validation bypass conditions to exclude round-changing behaviors:

```csharp
if (baseRound.RealTimeMinersInformation.Count != 1 &&
    Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3) &&
    extraData.Behaviour != AElfConsensusBehaviour.NextRound &&  // ADD THIS
    extraData.Behaviour != AElfConsensusBehaviour.NextTerm)      // ADD THIS
{
    // ... existing bootstrap bypass logic
}
```

**Test Cases:**
1. Attempt `NextRound` with `RoundNumber=1` when current round is 2+ during bootstrap phase - should fail
2. Verify `FirstRoundCommandStrategy` is never used after initial round 1 completion
3. Test that validation always enforces sequential round increments regardless of bootstrap state

### Proof of Concept

**Initial State:**
- Blockchain initialized via `FirstRound` with multiple miners configured
- `State.CurrentRoundNumber.Value = 1`, `State.Rounds[1]` contains initial round data
- Only miner A is actively producing blocks, others are offline
- Current block height: 5 (within bootstrap window of 24 blocks)

**Attack Steps:**

**Step 1:** System transitions from round 1 to round 2 normally
- Miner A produces `NextRound` transaction: `NextRoundInput{RoundNumber: 2, ...}`
- Validation passes, `State.CurrentRoundNumber.Value = 2`
- `State.Rounds[2]` created with round 2 data

**Step 2:** Miner A crafts malicious transaction at block height 15
- Transaction: `NextRound(NextRoundInput{RoundNumber: 1, ...})`
- Validation executes:
  - Line 19: `TryToGetCurrentRoundInformation` returns round 2 as `baseRound`
  - Line 23-24: Conditions met (>1 miner in list, height 15 < 24)
  - Lines 28-41: Loop verifies only miner A produced blocks in all rounds
  - Line 43: **Returns success, bypassing round number validation**

**Step 3:** Transaction executes
- `ProcessNextRound` called with malicious input
- Line 156: `AddRoundInformation` overwrites `State.Rounds[1]`
- Line 158: `TryToUpdateRoundNumber(1)` called
  - Check: `if (1 != 1 && 2 + 1 != 1)` → `if (false && true)` → `false`
  - Does not return false, continues
  - **`State.CurrentRoundNumber.Value = 1` - round reset successful**

**Step 4:** Subsequent block production
- Miner B comes online, requests consensus command
- `GetConsensusCommand` executes
- Line 23: `TryToGetCurrentRoundInformation` returns round from `State.Rounds[1]`
- Line 28: Check `currentRound.RoundNumber == 1` evaluates to **TRUE**
- **Uses `FirstRoundCommandStrategy` incorrectly**

**Expected vs Actual Result:**
- **Expected:** Round 2 continues with `NormalBlockCommandStrategy`, sequential round progression
- **Actual:** Round reset to 1, `FirstRoundCommandStrategy` used, mining times calculated incorrectly, consensus fork when miner B's view diverges from miner A's corrupted state

**Success Condition:** 
After step 3, querying `GetCurrentRoundNumber()` returns 1 instead of 2, and subsequent consensus commands omit RoundId/PreviousRoundId fields, confirming the vulnerability exploitation.

### Notes

The bootstrap validation bypass was likely designed to allow network initialization when nodes start asynchronously, but it fails to account for the security implications of allowing arbitrary round transitions during this window. The vulnerability is particularly dangerous because it corrupts fundamental consensus state during the most critical phase of network operation when establishing initial block production patterns.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L22-44)
```csharp
        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L91-97)
```csharp
    private bool TryToUpdateRoundNumber(long roundNumber)
    {
        var oldRoundNumber = State.CurrentRoundNumber.Value;
        if (roundNumber != 1 && oldRoundNumber + 1 != roundNumber) return false;
        State.CurrentRoundNumber.Value = roundNumber;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-30)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L28-30)
```csharp
        if (currentRound.RoundNumber == 1 && behaviour == AElfConsensusBehaviour.UpdateValue)
            return new ConsensusCommandProvider(new FirstRoundCommandStrategy(currentRound, pubkey,
                currentBlockTime, behaviour)).GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/FirstRoundCommandStrategy.cs (L31-47)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var miningInterval = MiningInterval;
            var offset =
                _consensusBehaviour == AElfConsensusBehaviour.UpdateValue && Order == 1
                    ? miningInterval
                    : Order.Add(MinersCount).Sub(1).Mul(miningInterval);
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeMiningTimeWithOffset(CurrentBlockTime, offset);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint { Behaviour = _consensusBehaviour }.ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(miningInterval),
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L23-41)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeNormalBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);

            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                {
                    Behaviour = AElfConsensusBehaviour.UpdateValue,
                    RoundId = CurrentRound.RoundId,
                    PreviousRoundId = _previousRoundId
                }.ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                // Cancel mining after time slot of current miner because of the task queue.
                MiningDueTime = CurrentRound.GetExpectedMiningTime(Pubkey).AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
