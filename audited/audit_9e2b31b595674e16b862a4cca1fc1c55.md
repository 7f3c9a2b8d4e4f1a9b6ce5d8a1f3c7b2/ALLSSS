# Audit Report

## Title
Removed Proposers Retain Proposal Release Authority in Governance Contracts

## Summary
The Association, Parliament, and Referendum contracts' `Release()` functions only verify that the caller is the original proposer but do not re-check if that proposer is still authorized in the ProposerWhiteList. This allows proposers who have been removed from the whitelist after creating proposals to still release those proposals once approved, violating the governance security model that whitelist removal should revoke all associated permissions.

## Finding Description

The vulnerability exists in the proposal release authorization logic across all three governance contracts (Association, Parliament, Referendum).

**At Proposal Creation:**

When a proposal is created via `CreateProposal()`, the system verifies the proposer is authorized by checking the ProposerWhiteList: [1](#0-0) 

This calls the authorization helper: [2](#0-1) 

The proposal then permanently stores the proposer's address: [3](#0-2) 

**At Proposal Release:**

The `Release()` function only verifies that the caller is the original proposer, with no re-validation of ProposerWhiteList membership: [4](#0-3) 

Organizations can modify the ProposerWhiteList at any time: [5](#0-4) 

**The same vulnerability pattern exists in Parliament:** [6](#0-5) [7](#0-6) 

**And in Referendum:** [8](#0-7) [9](#0-8) 

This means if an organization removes a proposer via `ChangeOrganizationProposerWhiteList`, the removed proposer can still release any proposals they created before removal, as long as those proposals have met the approval threshold.

## Impact Explanation

**Governance Authority Bypass:**
- Organizations remove proposers from whitelists to revoke their authority, typically due to security concerns, organizational changes, or loss of trust
- Despite removal, these proposers retain the ability to trigger execution of any approved proposals they created before removal
- This creates a persistent attack surface where untrusted actors maintain partial control over governance execution

**Attack Scenarios:**
1. **Malicious Batch Proposals**: A proposer creates multiple proposals, some of which get approved without thorough review. After the proposer is removed for suspicious behavior, they can still release the approved malicious proposals
2. **Compromised Accounts**: If a proposer's account is compromised after proposals are approved but before release, the attacker can release proposals at strategically chosen times to maximize damage
3. **Timing Manipulation**: Removed proposers can wait for specific blockchain states (e.g., treasury balance peaks, governance transitions) before releasing proposals to maximize impact

**Severity Justification (Medium):**
- **Impact**: Unauthorized proposal execution violates the governance security model and allows removed proposers to retain execution authority
- **Constraint**: Proposals must still meet approval thresholds, limiting immediate exploitation to already-approved proposals
- **Scope**: Affects all three governance contracts system-wide (Association, Parliament, Referendum)

## Likelihood Explanation

**Attacker Capabilities:**
- Must initially be an authorized proposer (realistic - whitelists include multiple members)
- Must create proposals that get approved (requires convincing other members through normal voting, but feasible)
- Must be subsequently removed from whitelist (common in governance evolution and member management)

**Attack Complexity:**
- **Low complexity** - straightforward sequence: create proposal → get approval → get removed → call `Release()`
- No complex state manipulation or timing precision required beyond waiting for proposal approval
- Entry point (`Release()`) is publicly accessible and requires no special privileges beyond being the original proposer

**Feasibility Conditions:**
- All preconditions are realistic in normal governance operations
- Organizations frequently adjust member lists and permissions as part of regular governance
- Proposal approval happens through standard voting mechanisms
- No special privileges needed beyond initial whitelist membership

**Probability Assessment:**
- **Medium likelihood** due to realistic preconditions that occur in normal operations
- Higher probability in organizations with:
  - Frequent proposer whitelist changes
  - Multiple concurrent proposals
  - Long proposal expiration periods
  - Limited proposal review processes before approval

## Recommendation

Add a ProposerWhiteList re-validation check in the `Release()` function for all three governance contracts. The fix should verify that the proposer is still authorized at the time of release:

**For Association Contract (Association.cs):**
```csharp
public override Empty Release(Hash input)
{
    var proposalInfo = GetValidProposal(input);
    Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
    
    // Add this validation
    var organization = State.Organizations[proposalInfo.OrganizationAddress];
    Assert(organization.ProposerWhiteList.Contains(Context.Sender), "Proposer no longer authorized.");
    
    Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
    // ... rest of the function
}
```

Apply the same fix to Parliament and Referendum contracts' `Release()` functions. This ensures that whitelist removal immediately revokes all proposal release permissions, even for previously created proposals.

## Proof of Concept

```csharp
[Fact]
public async Task RemovedProposerCanStillReleaseApprovedProposal()
{
    // Setup: Create organization with proposer in whitelist
    var proposer = Accounts[1].Address;
    var member1 = Accounts[2].Address;
    var member2 = Accounts[3].Address;
    
    var organizationAddress = await AssociationContractStub.CreateOrganization.SendAsync(
        new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 2,
                MinimalVoteThreshold = 2,
                MaximalAbstentionThreshold = 0,
                MaximalRejectionThreshold = 0
            },
            ProposerWhiteList = new ProposerWhiteList { Proposers = { proposer } },
            OrganizationMemberList = new OrganizationMemberList 
            { 
                OrganizationMembers = { member1, member2 } 
            }
        });
    
    // Step 1: Proposer creates a proposal
    var proposalId = await AssociationContractStub.CreateProposal.SendAsync(
        new CreateProposalInput
        {
            OrganizationAddress = organizationAddress.Output,
            ToAddress = TokenContractAddress,
            ContractMethodName = nameof(TokenContract.Transfer),
            Params = new TransferInput { To = proposer, Amount = 100, Symbol = "ELF" }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
        });
    
    // Step 2: Members approve the proposal
    await AssociationContractStub.Approve.SendAsync(proposalId.Output);
    await AssociationContractStub.Approve.SendAsync(proposalId.Output);
    
    // Step 3: Organization removes proposer from whitelist
    await AssociationContractStub.ChangeOrganizationProposerWhiteList.SendAsync(
        new ProposerWhiteList { Proposers = { } }); // Empty whitelist
    
    // Step 4: Removed proposer can still release the approved proposal
    var releaseResult = await AssociationContractStub.Release.SendAsync(proposalId.Output);
    
    // Vulnerability: Release succeeded even though proposer was removed from whitelist
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

## Notes

This vulnerability affects the core governance security model across all three governance contract types (Association, Parliament, Referendum). The issue violates the fundamental expectation that removing a proposer from the whitelist should immediately revoke all their governance permissions, including the ability to release proposals they created while authorized.

The fix is straightforward: add a ProposerWhiteList membership check in the `Release()` function to ensure the proposer is still authorized at execution time. This aligns the release authorization with the proposal creation authorization model and properly enforces whitelist-based access control.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L157-157)
```csharp
            Proposer = Context.Sender,
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L162-177)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var defaultOrganizationAddress = State.DefaultOrganizationAddress.Value;
        Assert(defaultOrganizationAddress == Context.Sender, "No permission.");
        var organization = State.Organizations[defaultOrganizationAddress];
        Assert(
            input.Proposers.Count > 0 || !organization.ProposerAuthorityRequired ||
            organization.ParliamentMemberProposingAllowed, "White list can't be empty.");
        State.ProposerWhiteList.Value = input;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```
