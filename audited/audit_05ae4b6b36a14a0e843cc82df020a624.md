### Title
Privilege Escalation via Arbitrary Creator Assignment and Unrestricted Initial Minter List in NFT Protocol Creation

### Summary
The `Create()` function allows any caller to specify an arbitrary `input.Creator` address (including high-privilege addresses like Parliament) and populate the initial minter list with their own address, granting themselves unauthorized minting rights that can only be revoked by the spoofed creator address. This enables attackers to bypass normal authorization controls and gain irrevocable minting privileges.

### Finding Description

**Location**: [1](#0-0) 

**Root Cause**: The `Create()` function accepts `input.Creator` without validating that it equals `Context.Sender`: [2](#0-1) 

Additionally, the function allows callers to specify arbitrary addresses in `input.MinterList`, which are added to the minter list alongside the creator: [3](#0-2) 

**Why Protections Fail**:

1. **No Creator Validation**: There is no assertion to verify that `input.Creator` matches `Context.Sender`, allowing attackers to impersonate any address as the protocol creator.

2. **Unrestricted Minter List**: The initial `input.MinterList` can contain any addresses without validation, enabling attackers to add themselves as authorized minters.

3. **Minting Authorization Only Checks Minter List**: The `PerformMint()` function only verifies that `Context.Sender` is in the minter list: [4](#0-3) 

4. **Creator-Only Revocation**: The `RemoveMinters()` function requires that `Context.Sender` equals the stored creator, preventing the attacker from being removed except by the spoofed creator address: [5](#0-4) 

**Execution Path**:
1. Attacker calls `Create()` with `input.Creator = ParliamentAddress` and `input.MinterList = [AttackerAddress]`
2. Protocol is created with `protocolInfo.Creator = ParliamentAddress`
3. Minter list is set to `[AttackerAddress, ParliamentAddress]`
4. Token is registered in MultiToken contract with `Issuer = ParliamentAddress`: [6](#0-5) 
5. Attacker can now mint NFTs as they are in the authorized minter list
6. Only Parliament can remove the attacker via `RemoveMinters()`, but Parliament may be unaware of this rogue protocol

### Impact Explanation

**Concrete Impact**:
- **Unauthorized Minting Rights**: Attackers gain the ability to mint NFTs up to the `TotalSupply` limit specified during creation, creating tokens that appear to be issued by legitimate high-privilege entities.
- **Privilege Escalation**: By setting the creator to Parliament or other governance addresses, attackers create protocols that appear to be officially sanctioned while maintaining exclusive minting control.
- **Irrevocable Access**: The attacker's minting rights cannot be revoked by normal meansâ€”only the spoofed creator address (Parliament) can remove them, and Parliament may never discover these rogue protocols.
- **Protocol Damage**: Malicious NFTs can be created that appear to originate from trusted governance entities, damaging protocol reputation and user trust.

**Severity Justification**: **Critical**
- Direct compromise of token supply integrity
- Bypasses fundamental authorization controls
- Enables large-scale unauthorized token creation
- Creates persistent, difficult-to-detect backdoor access
- Affects core NFT protocol functionality

### Likelihood Explanation

**Attack Complexity**: **Low**
- The `Create()` function is a public method with no access controls: [7](#0-6) 
- Only requires knowledge of a high-privilege address (publicly known, e.g., Parliament default organization)
- Single transaction execution
- No complex preconditions or state setup required

**Attacker Capabilities**: **Minimal**
- Any address can call the `Create()` function
- Only requires transaction gas fees
- No prior authorizations or special permissions needed

**Feasibility**: **High**
- Attack can be executed immediately on any chain where the NFT contract is deployed
- No race conditions or timing requirements
- Deterministic outcome

**Detection Constraints**: **Poor**
- No event distinguishing legitimate vs. malicious protocol creation
- Parliament would need to actively monitor all NFT protocol creations to detect spoofing
- No automated alerts or validation mechanisms
- Protocols may remain undetected indefinitely until NFTs are minted

### Recommendation

**Immediate Fix**:

Add creator validation in the `Create()` function:

```csharp
// Line 22 of NFTContract_Create.cs - Replace with:
Assert(input.Creator == null || input.Creator == Context.Sender, 
    "Cannot set creator to a different address.");
var creator = input.Creator ?? Context.Sender;
```

**Alternative Approach** (Preferred):

Remove the ability to specify creator entirely and always use `Context.Sender`:

```csharp
// Line 22 of NFTContract_Create.cs - Replace with:
var creator = Context.Sender;
// Remove input.Creator from CreateInput protobuf definition
```

**Additional Hardening**:

1. Add validation for initial minter list to prevent unauthorized addresses:
```csharp
// After line 36 - Add validation:
foreach (var minter in input.MinterList?.Value ?? new List<Address>())
{
    Assert(minter == creator, "Only creator can be in initial minter list.");
}
```

2. Emit detailed event showing actual transaction sender vs. protocol creator for monitoring.

3. Add view function to query all protocols by actual creation transaction sender for auditing.

**Test Cases**:

1. Test that `Create()` fails when `input.Creator` is set to an address other than `Context.Sender`
2. Test that `Create()` succeeds when `input.Creator` is null or equals `Context.Sender`
3. Test that minter list cannot contain addresses other than the creator without explicit authorization
4. Regression test attempting the privilege escalation attack

### Proof of Concept

**Initial State**:
- Attacker has address `0xAttacker`
- Parliament default organization address is `0xParliament` (publicly known)
- NFT contract is deployed and operational

**Attack Transaction**:
```
Sender: 0xAttacker
Contract: NFTContract
Method: Create
Parameters:
  - NftType: "Art"
  - ProtocolName: "OfficialGovernanceNFT"
  - TotalSupply: 1000000
  - Creator: 0xParliament  // High-privilege address
  - IsBurnable: true
  - IssueChainId: [current chain]
  - MinterList: [0xAttacker]  // Attacker adds themselves
```

**Result**:
- Protocol created with symbol (e.g., "AR-1")
- `State.NftProtocolMap[symbol].Creator == 0xParliament`
- `State.MinterListMap[symbol] == [0xAttacker, 0xParliament]`
- Token registered in MultiToken contract with `Issuer = 0xParliament`

**Exploitation**:
```
Sender: 0xAttacker
Contract: NFTContract
Method: Mint
Parameters:
  - Symbol: "AR-1"
  - Alias: "Fake Official NFT"
  - Owner: 0xAttacker
```

**Expected vs. Actual**:
- **Expected**: Transaction should fail with "No permission to mint" because attacker is not the protocol creator
- **Actual**: Transaction succeeds because attacker is in the minter list (verified at [8](#0-7) )

**Success Condition**: 
Attacker successfully mints NFTs under a protocol that appears to be controlled by Parliament, but only Parliament can revoke the attacker's minting rights via `RemoveMinters()` (which requires `Context.Sender == protocolInfo.Creator` as enforced at [9](#0-8) ).

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-73)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);

        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;

        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
            ProtocolName = tokenCreateInput.TokenName,
            IsTokenIdReuse = input.IsTokenIdReuse,
            IssueChainId = tokenCreateInput.IssueChainId,
            IsBurnable = tokenCreateInput.IsBurnable,
            NftType = input.NftType
        };
        State.NftProtocolMap[symbol] = protocolInfo;

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = tokenCreateInput.Symbol,
            Creator = tokenCreateInput.Issuer,
            IsBurnable = tokenCreateInput.IsBurnable,
            IssueChainId = tokenCreateInput.IssueChainId,
            ProtocolName = tokenCreateInput.TokenName,
            TotalSupply = tokenCreateInput.TotalSupply,
            Metadata = protocolInfo.Metadata,
            BaseUri = protocolInfo.BaseUri,
            IsTokenIdReuse = protocolInfo.IsTokenIdReuse,
            NftType = protocolInfo.NftType
        });

        return new StringValue
        {
            Value = symbol
        };
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L355-358)
```csharp
    public override Empty RemoveMinters(RemoveMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L398-399)
```csharp
        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
```

**File:** protobuf/nft_contract.proto (L22-24)
```text
    // Create a new nft protocol.
    rpc Create (CreateInput) returns (google.protobuf.StringValue) {
    }
```
