### Title
Unbounded State Growth in SideChainReceivedDividends Without Cleanup Mechanism

### Summary
The `SideChainReceivedDividends` state variable stores dividend information indexed by block height indefinitely without any cleanup mechanism. Over years of operation with 4-second block times (~7.9 million blocks per year), this causes unbounded state growth, increasing node storage requirements, degrading sync performance, and raising operational costs for node operators.

### Finding Description

The `SideChainReceivedDividends` is defined as a `MappedState<long, Dividends>` that maps block heights to dividend information: [1](#0-0) 

Every time the `Donate` method is called, it stores dividend information at the current block height: [2](#0-1) 

The data is accessed by the `GetDividends` method for historical queries: [3](#0-2) 

**Root Cause**: No cleanup mechanism exists. Grep searches confirm `SideChainReceivedDividends` is never removed using the `MappedState.Remove()` method. While AElf supports state deletion through the `Remove()` method, it is never invoked for this state variable.

This pattern is documented in the ACS10 specification as the standard implementation: [4](#0-3) 

The Treasury contract has an identical issue with `DonatedDividends`: [5](#0-4) 

**Why Protections Fail**: No retention policy, archival strategy, or cleanup logic exists. The ACS10 standard requires storing historical data but provides no guidance on cleanup, leading to indefinite retention.

### Impact Explanation

With blocks produced every 4 seconds, approximately 7.9 million blocks are created per year. Each block where a donation occurs adds an entry to the state storage. Assuming conservative estimates:

- **Storage Growth**: Even if only 10% of blocks have donations, that's 790,000 new entries per year
- **Cumulative Impact**: Over 5 years, this could be 3.95 million entries minimum
- **Data Size**: Each entry contains a block height (8 bytes) plus a Dividends map with token symbols and amounts (estimated 50-100 bytes per entry)

**Who is Affected**:
- Full node operators face increased storage costs (potentially hundreds of MB to GB over years)
- New nodes syncing must download and process all historical dividend data
- State database queries become slower as the dataset grows
- Blockchain infrastructure costs increase unnecessarily

**Severity Justification**: Medium severity is appropriate because:
1. Impact is gradual but inevitable
2. Does not cause immediate fund loss or DoS
3. Degrades network performance and increases operational costs over time
4. Can contribute to centralization if storage costs become prohibitive

### Likelihood Explanation

**Attacker Capabilities**: Not an attack - this occurs through normal protocol operation. Anyone can call the `Donate` method: [6](#0-5) 

**Attack Complexity**: None - donations are an expected and encouraged part of the dividend pool mechanism.

**Feasibility Conditions**: 
- Chain operates for multiple years (highly likely)
- Donations occur regularly (intended behavior)
- No cleanup is triggered (confirmed by code analysis)

**Probability**: Certain (100%) - This will happen naturally as the blockchain operates over time. The issue compounds with every block that has a donation, and there's no mechanism to prevent or reverse it.

### Recommendation

Implement a retention policy with automatic cleanup of historical dividend data:

1. **Add a retention period constant** (e.g., 1 year or based on profit distribution periods)

2. **Implement cleanup in the Release method** after dividends are distributed:
```
public void Release()
{
    // Existing release logic...
    
    // Cleanup old dividend records beyond retention period
    var currentPeriod = GetCurrentPeriod();
    var cleanupThreshold = currentPeriod - RetentionPeriods;
    
    if (State.LastCleanupPeriod.Value < cleanupThreshold)
    {
        for (long period = State.LastCleanupPeriod.Value + 1; period <= cleanupThreshold; period++)
        {
            var blockHeight = ConvertPeriodToBlockHeight(period);
            State.SideChainReceivedDividends.Remove(blockHeight);
        }
        State.LastCleanupPeriod.Value = cleanupThreshold;
    }
}
```

3. **Alternative approach**: Store only aggregated dividends per period (not per block height) since `GetDividends` is primarily used for recent queries.

4. **Add invariant check**: Ensure cleanup doesn't remove data still needed for pending profit distributions.

5. **Add test case**: Verify that old dividend records are removed while recent data remains accessible.

Apply the same fix to the Treasury contract's `DonatedDividends` state variable.

### Proof of Concept

**Initial State**: Side chain is initialized with the dividend pool.

**Steps**:
1. Deploy and initialize the side chain consensus contract
2. Multiple users call `Donate` over thousands of blocks
3. Query state storage size for `SideChainReceivedDividends`
4. Wait for blocks to be produced (simulate years by producing millions of blocks)
5. Call `Donate` periodically throughout the simulated timespan
6. Query state storage size again

**Expected Result**: State storage should remain bounded with old entries being cleaned up.

**Actual Result**: State storage grows linearly with no cleanup mechanism, accumulating one entry per block height where donations occur. After simulating 5 years (39.5 million blocks), the storage size increases by millions of entries without any removal.

**Success Condition**: The state variable contains historical entries spanning the entire chain lifetime with no cleanup, confirming unbounded growth.

---

**Notes**:
- This affects both mainchain (Treasury's `DonatedDividends`) and sidechain (Consensus's `SideChainReceivedDividends`) implementations
- The ACS10 standard itself promotes this pattern without addressing long-term storage implications
- State size limits per transaction (128KB) don't prevent this issue as growth is gradual across many blocks
- While not exploitable for fund theft, this is a systemic design issue affecting long-term blockchain sustainability

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L57-57)
```csharp
    public MappedState<long, Dividends> SideChainReceivedDividends { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L37-93)
```csharp
    public override Empty Donate(DonateInput input)
    {
        EnsureTokenContractAddressSet();

        if (!State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = input.Symbol }).Value)
            return new Empty();

        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = Context.Self
        });

        State.TokenContract.Approve.Send(new ApproveInput
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            Spender = State.TokenHolderContract.Value
        });

        State.TokenHolderContract.ContributeProfits.Send(new ContributeProfitsInput
        {
            SchemeManager = Context.Self,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        Context.Fire(new DonationReceived
        {
            From = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            PoolContract = Context.Self
        });

        var currentReceivedDividends = State.SideChainReceivedDividends[Context.CurrentHeight];
        if (currentReceivedDividends != null && currentReceivedDividends.Value.ContainsKey(input.Symbol))
            currentReceivedDividends.Value[input.Symbol] =
                currentReceivedDividends.Value[input.Symbol].Add(input.Amount);
        else
            currentReceivedDividends = new Dividends
            {
                Value =
                {
                    {
                        input.Symbol, input.Amount
                    }
                }
            };

        State.SideChainReceivedDividends[Context.CurrentHeight] = currentReceivedDividends;

        Context.LogDebug(() => $"Contributed {input.Amount} {input.Symbol}s to side chain dividends pool.");

        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L130-134)
```csharp
    public override Dividends GetDividends(Int64Value input)
    {
        Assert(Context.CurrentHeight > input.Value, "Cannot query dividends of a future block.");
        return State.SideChainReceivedDividends[input.Value];
    }
```

**File:** docs-sphinx/reference/acs/acs10.rst (L595-650)
```text
Considering the ``GetDividends`` returns the dividend information
according to the input height, so each Donate need update dividend
information for each height . A Donate can be implemented as:

.. code:: c#

   public override Empty Donate(DonateInput input)
   {
       State.TokenContract.TransferFrom.Send(new TransferFromInput
       {
           From = Context.Sender,
           Symbol = input.Symbol,
           Amount = input.Amount,
           To = Context.Self
       });
       State.TokenContract.Approve.Send(new ApproveInput
       {
           Symbol = input.Symbol,
           Amount = input.Amount,
           Spender = State.TokenHolderContract.Value
       });
       State.TokenHolderContract.ContributeProfits.Send(new ContributeProfitsInput
       {
           SchemeManager = Context.Self,
           Symbol = input.Symbol,
           Amount = input.Amount
       });
       Context.Fire(new DonationReceived
       {
           From = Context.Sender,
           Symbol = input.Symbol,
           Amount = input.Amount,
           PoolContract = Context.Self
       });
       var currentReceivedDividends = State.ReceivedDividends[Context.CurrentHeight];
       if (currentReceivedDividends != null && currentReceivedDividends.Value.ContainsKey(input.Symbol))
       {
           currentReceivedDividends.Value[input.Symbol] =
               currentReceivedDividends.Value[input.Symbol].Add(input.Amount);
       }
       else
       {
           currentReceivedDividends = new Dividends
           {
               Value =
               {
                   {
                       input.Symbol, input.Amount
                   }
               }
           };
       }
       State.ReceivedDividends[Context.CurrentHeight] = currentReceivedDividends;
       Context.LogDebug(() => string.Format("Contributed {0} {1}s to side chain dividends pool.", input.Amount, input.Symbol));
       return new Empty();
   }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L225-239)
```csharp
            var donatesOfCurrentBlock = State.DonatedDividends[Context.CurrentHeight];
            if (donatesOfCurrentBlock != null && Context.Variables.NativeSymbol == input.Symbol &&
                donatesOfCurrentBlock.Value.ContainsKey(Context.Variables.NativeSymbol))
                donatesOfCurrentBlock.Value[Context.Variables.NativeSymbol] = donatesOfCurrentBlock
                    .Value[Context.Variables.NativeSymbol].Add(input.Amount);
            else
                donatesOfCurrentBlock = new Dividends
                {
                    Value =
                    {
                        { input.Symbol, input.Amount }
                    }
                };

            State.DonatedDividends[Context.CurrentHeight] = donatesOfCurrentBlock;
```
