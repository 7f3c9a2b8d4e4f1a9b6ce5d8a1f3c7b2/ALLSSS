# Audit Report

## Title
Vote Contract Storage Bomb via Unvalidated Options During Registration

## Summary
The `Register` method in the Vote contract fails to validate the `options` array against `MaximumOptionsCount` (64) and `OptionLengthLimit` (1024 bytes) during voting item creation. This validation gap allows any address to create unlimited voting items, each containing large option arrays up to the 128KB state size limit, enabling a storage bomb attack that permanently bloats blockchain state.

## Finding Description

The root cause is a validation inconsistency in the Vote contract where option constraints are enforced for post-registration modifications but not during initial registration.

The `Register` method directly assigns input options without validation: [1](#0-0) 

The validation helper `AssertValidNewVotingItem` only checks for duplicate voting items, timestamp validity, and snapshot numbers—it completely omits option validation: [2](#0-1) 

The constants that should constrain options are defined but not enforced during registration: [3](#0-2) 

In contrast, validation exists in the `AddOption` method which is called AFTER registration: [4](#0-3) 

And in the `AddOptions` method: [5](#0-4) 

Test evidence confirms this gap—a voting item can be successfully registered with exactly 64 options: [6](#0-5) 

While AElf enforces a per-entry 128KB state size limit, this only prevents individual voting items from exceeding that threshold, not the creation of thousands of items. The protobuf definition allows unlimited options in the repeated field: [7](#0-6) 

An attacker can exploit this by repeatedly calling `Register` with voting items containing options totaling ~64KB (e.g., 64 options × 1024 bytes = 65,536 bytes plus protobuf overhead), staying well under the 128KB limit. There is no rate limiting, cooldown period, or per-address restriction on voting item creation.

## Impact Explanation

**Operational Impact - Storage Bomb Attack:**
- Any address can create unlimited voting items without authorization or rate limiting
- Each voting item can store up to ~64KB of option data (constrained only by the 128KB state size limit)
- Conservative attack: 1,000 voting items × 64KB = 64MB of bloated state
- Aggressive attack: 10,000 voting items × 64KB = 640MB; 100,000 items = 6.4GB
- All full nodes must permanently sync, validate, and store this state
- No cleanup mechanism exists—voting items persist indefinitely in the state mapping
- Severely impacts blockchain operability, node sync times, and infrastructure costs

**Who is Affected:**
- All network participants (node operators, validators, developers)
- Blockchain infrastructure becomes increasingly expensive to maintain
- State pruning becomes necessary but difficult to implement

**Severity:** HIGH - This directly threatens blockchain operational integrity through permanent state bloat, affects all network participants, and has no built-in mitigation beyond transaction fees which scale linearly and are not prohibitive.

## Likelihood Explanation

**Attacker Capabilities:**
- Any address can call the public `Register` method—no special permissions required
- No authentication, authorization, or reputation requirements

**Attack Complexity:**
- Straightforward: repeatedly call `Register` with `VotingRegisterInput` containing large option arrays (e.g., 64 options of 1024 bytes each)
- Can create voting items with more than 64 options during registration (only limited by 128KB state size, not by `MaximumOptionsCount`)

**Economic Feasibility:**
- Transaction fees scale with transaction size but provide only linear cost increase
- A determined attacker with sufficient funds can execute the attack
- No exponential backoff or prohibitive economic barriers exist
- Attack can be distributed across multiple addresses to reduce individual cost

**Feasibility Conditions:**
- No rate limiting, cooldown periods, or per-address voting item limits
- No governance intervention required
- Compatible with all AElf execution semantics

**Likelihood:** HIGH - The combination of public access, missing validation, no rate limiting, straightforward execution, and economically feasible cost structure makes this attack highly probable for motivated attackers.

## Recommendation

Add option validation to the `Register` method before creating the voting item:

```csharp
public override Empty Register(VotingRegisterInput input)
{
    var votingItemId = AssertValidNewVotingItem(input);
    
    // Add validation for options
    Assert(input.Options.Count <= VoteContractConstants.MaximumOptionsCount,
        $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
    
    foreach (var option in input.Options)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, 
            "Invalid input.");
    }
    
    // Existing token whitelist check and voting item creation...
}
```

Additionally, consider implementing:
1. Rate limiting on voting item creation per address
2. A minimum time interval between voting item registrations
3. Governance-adjustable limits on total active voting items
4. A cleanup mechanism for expired voting items

## Proof of Concept

```csharp
[Fact]
public async Task StorageBomb_Via_Unvalidated_Options_During_Registration()
{
    // This test demonstrates that the Register method accepts voting items
    // with the maximum number of options without validation
    var startTime = TimestampHelper.GetUtcNow();
    
    // Create options array with 64 entries, each 1024 bytes (maximum allowed in constants)
    var largeOptions = new List<string>();
    for (int i = 0; i < VoteContractConstants.MaximumOptionsCount; i++)
    {
        largeOptions.Add(new string('A', VoteContractConstants.OptionLengthLimit));
    }
    
    var input = new VotingRegisterInput
    {
        TotalSnapshotNumber = 1,
        EndTimestamp = startTime.AddDays(10),
        StartTimestamp = startTime,
        Options = { largeOptions },
        AcceptedCurrency = TestTokenSymbol,
        IsLockToken = true
    };
    
    // This should fail with validation error but succeeds due to missing validation
    var transactionResult = (await VoteContractStub.Register.SendAsync(input)).TransactionResult;
    transactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // The voting item was successfully created with 64 options
    var votingItemId = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(input), 
        HashHelper.ComputeFrom(DefaultSender));
    var votingItem = await VoteContractStub.GetVotingItem.CallAsync(
        new GetVotingItemInput { VotingItemId = votingItemId });
    
    votingItem.Options.Count.ShouldBe(VoteContractConstants.MaximumOptionsCount);
    
    // Now if we try to add one more option, it correctly fails
    var transactionResult2 = (await VoteContractStub.AddOption.SendWithExceptionAsync(
        new AddOptionInput
        {
            Option = "NewOption",
            VotingItemId = votingItemId
        })).TransactionResult;
    
    transactionResult2.Error.ShouldContain(
        $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
    
    // This proves the validation gap: Register allows 64 options, but AddOption prevents exceeding 64
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L49-49)
```csharp
            Options = { input.Options },
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L285-286)
```csharp
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L320-321)
```csharp
        Assert(votingItem.Options.Count <= VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-6)
```csharp
    public const int MaximumOptionsCount = 64;
    public const int OptionLengthLimit = 1024;
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L342-352)
```csharp
            var registerItem = await RegisterVotingItemAsync(100, VoteContractConstant.MaximumOptionsCount, true,
                DefaultSender, 1);
            var newOption = Accounts[VoteContractConstant.MaximumOptionsCount].Address.ToBase58();
            var transactionResult = (await VoteContractStub.AddOption.SendWithExceptionAsync(new AddOptionInput
            {
                Option = newOption,
                VotingItemId = registerItem.VotingItemId
            })).TransactionResult;
            transactionResult.Error.ShouldContain(
                $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        }
```

**File:** protobuf/vote_contract.proto (L99-99)
```text
    repeated string options = 6;
```
