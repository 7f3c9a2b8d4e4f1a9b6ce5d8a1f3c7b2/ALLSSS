# Audit Report

## Title
Inconsistent Symbol Tracking Causes Permanent Profit Lock When Distributing Unregistered Token Symbols

## Summary
The Profit contract fails to maintain `ReceivedTokenSymbols` list consistency when `DistributeProfits` is called with symbols not previously registered via `ContributeProfits`. This causes `ClaimProfits` to skip these distributed profits, permanently locking funds in period virtual addresses while `GetProfitAmount` queries show them as available.

## Finding Description

The vulnerability stems from an inconsistency in how the `ReceivedTokenSymbols` list is maintained across different profit operations:

**Symbol Registration Paths:**

1. When `ContributeProfits` is called, it adds the symbol to the scheme's `ReceivedTokenSymbols`: [1](#0-0) 

2. When distributing to sub-schemes, the symbol is added to the **sub-scheme's** `ReceivedTokenSymbols`: [2](#0-1) 

3. However, `DistributeProfits` does **NOT** add symbols to the parent scheme's `ReceivedTokenSymbols`. The method accepts any symbol in `AmountsMap` and distributes it: [3](#0-2) 

**The Critical Flaw in Claims Processing:**

When beneficiaries call `ClaimProfits`, it invokes `ProfitAllPeriods` without passing a specific symbol: [4](#0-3) 

Inside `ProfitAllPeriods`, when no `targetSymbol` is provided, it only iterates through `ReceivedTokenSymbols`: [5](#0-4) 

**Why Query Methods Show Different Results:**

- `GetProfitAmount` accepts a specific symbol parameter and passes it through, bypassing `ReceivedTokenSymbols`: [6](#0-5) 

- `GetAllProfitsMap` without symbol parameter uses only `ReceivedTokenSymbols`: [7](#0-6) 

**Acknowledged Design Gap:**

The contract itself contains a comment acknowledging this issue: [8](#0-7) 

## Impact Explanation

**Direct Fund Lock:**
When a scheme manager calls `DistributeProfits` with a symbol not in `ReceivedTokenSymbols` (e.g., tokens received via direct transfer to virtual address), the following occurs:

1. Profits are successfully distributed and recorded in `DistributedProfitsInfo.AmountsMap` for that period
2. Beneficiaries calling `GetProfitAmount("SYMBOL")` see their correct profit amount
3. Beneficiaries calling `ClaimProfits()` cannot claim these profits because the claiming logic only iterates symbols in `ReceivedTokenSymbols`
4. The profits remain permanently locked in the period's virtual address with no recovery mechanism

**Affected Parties:**
All beneficiaries of schemes where this occurs lose permanent access to their rightful profit share for the unregistered token symbol.

**Severity:** Medium - Requires manager action to trigger, but results in permanent and irreversible fund loss for all beneficiaries with no contract-level recovery mechanism.

## Likelihood Explanation

**Triggering Scenarios:**

1. **Direct Token Transfers:** Users or contracts transfer tokens directly to a scheme's virtual address (bypassing `ContributeProfits`), then manager calls `DistributeProfits` with that symbol
2. **Multi-Token Introduction:** Manager distributes a new token type without first calling `ContributeProfits` for registration
3. **Cross-Contract Integration:** Other system contracts transfer reward tokens to scheme addresses for distribution

**Complexity:** Low
- Requires only: tokens in virtual address + manager calling `DistributeProfits` with the symbol
- No special conditions or race conditions needed
- Can occur accidentally during legitimate operations

**Detection Difficulty:** High
- Beneficiaries only discover the issue when comparing `GetProfitAmount(symbol)` vs actual claimed amounts
- Standard `GetAllProfitsMap()` queries won't show the missing symbol
- No events or errors signal the problem

**Probability:** Medium - While requiring manager action, the lack of validation makes accidental triggering likely when introducing new tokens or integrating with other contracts.

## Recommendation

Add symbol registration in `DistributeProfits` method:

```csharp
// After line 490 in PerformDistributeProfits method
foreach (var profits in profitsMap)
{
    var symbol = profits.Key;
    var amount = profits.Value;
    
    // Add symbol to ReceivedTokenSymbols if not already present
    if (!scheme.ReceivedTokenSymbols.Contains(symbol))
    {
        scheme.ReceivedTokenSymbols.Add(symbol);
    }
    
    var remainAmount = DistributeProfitsForSubSchemes(symbol, amount, scheme, totalShares);
    // ... rest of method
}
```

Update the scheme state after the loop to persist the changes.

## Proof of Concept

```csharp
[Fact]
public async Task SymbolNotInReceivedTokenSymbols_ClaimFails_Test()
{
    const long shares = 100;
    const long amount = 1000;
    const string unregisteredSymbol = "USDT"; // New symbol not in ReceivedTokenSymbols

    var creator = Creators[0];
    var beneficiary = Normal[0];
    var beneficiaryAddress = Address.FromPublicKey(NormalKeyPair[0].PublicKey);

    // 1. Create scheme
    var schemeId = await CreateSchemeAsync();
    
    // 2. Add beneficiary
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiaryAddress, Shares = shares },
        SchemeId = schemeId
    });

    // 3. Get scheme's virtual address
    var scheme = await creator.GetScheme.CallAsync(schemeId);
    var virtualAddress = scheme.VirtualAddress;

    // 4. Create and issue USDT token (simulating new token)
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = unregisteredSymbol,
        TokenName = "USDT Token",
        TotalSupply = 1000000,
        Decimals = 6,
        Issuer = Starter,
        IsBurnable = true
    });
    
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = unregisteredSymbol,
        Amount = amount,
        To = virtualAddress,
        Memo = "Direct transfer to scheme"
    });

    // 5. Verify USDT is NOT in ReceivedTokenSymbols
    scheme = await creator.GetScheme.CallAsync(schemeId);
    scheme.ReceivedTokenSymbols.Contains(unregisteredSymbol).ShouldBe(false);

    // 6. Manager distributes USDT (without prior ContributeProfits)
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        AmountsMap = { { unregisteredSymbol, amount } },
        Period = 1
    });

    // 7. Verify USDT STILL not in ReceivedTokenSymbols after distribution
    scheme = await creator.GetScheme.CallAsync(schemeId);
    scheme.ReceivedTokenSymbols.Contains(unregisteredSymbol).ShouldBe(false);

    // 8. Verify GetProfitAmount shows correct claimable amount
    var profitAmount = await beneficiary.GetProfitAmount.CallAsync(new GetProfitAmountInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiaryAddress,
        Symbol = unregisteredSymbol
    });
    profitAmount.Value.ShouldBe(amount); // Shows 1000 USDT claimable

    // 9. Verify GetAllProfitsMap DOES NOT include USDT
    var allProfitsMap = await beneficiary.GetAllProfitsMap.CallAsync(new GetAllProfitsMapInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiaryAddress
    });
    allProfitsMap.AllProfitsMap.ContainsKey(unregisteredSymbol).ShouldBe(false); // USDT missing!

    // 10. Beneficiary attempts to claim profits
    var balanceBefore = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = beneficiaryAddress,
        Symbol = unregisteredSymbol
    })).Balance;

    await beneficiary.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId
    });

    // 11. Verify USDT was NOT claimed (funds locked)
    var balanceAfter = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = beneficiaryAddress,
        Symbol = unregisteredSymbol
    })).Balance;
    
    balanceAfter.ShouldBe(balanceBefore); // Balance unchanged - funds locked!

    // 12. Verify funds remain in period virtual address
    var periodAddress = await creator.GetSchemeAddress.CallAsync(new SchemePeriod
    {
        SchemeId = schemeId,
        Period = 1
    });
    
    var lockedBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = periodAddress,
        Symbol = unregisteredSymbol
    })).Balance;
    
    lockedBalance.ShouldBe(amount); // Funds permanently locked
}
```

This test demonstrates the complete vulnerability: distributed profits remain permanently locked because `ClaimProfits` cannot access symbols not in `ReceivedTokenSymbols`, even though `GetProfitAmount` correctly shows them as claimable.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L432-460)
```csharp
        var profitsMap = new Dictionary<string, long>();
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
        else
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L640-645)
```csharp
            var subScheme = State.SchemeInfos[subSchemeShares.SchemeId];
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L715-716)
```csharp
        // If someone directly use virtual address to do the contribution, won't sense the token symbol he was using.
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L784-784)
```csharp
            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L851-851)
```csharp
        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L62-69)
```csharp
    public override Int64Value GetProfitAmount(GetProfitAmountInput input)
    {
        var allProfitsMapResult = GetAllProfitsMap(input.SchemeId, input.Beneficiary, input.Symbol);

        return new Int64Value
        {
            Value = allProfitsMapResult.AllProfitsMap.TryGetValue(input.Symbol, out var value) ? value : 0
        };
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L98-101)
```csharp
    public override GetAllProfitsMapOutput GetAllProfitsMap(GetAllProfitsMapInput input)
    {
        return GetAllProfitsMap(input.SchemeId, input.Beneficiary);
    }
```
