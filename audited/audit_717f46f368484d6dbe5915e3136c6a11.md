### Title
Authorization Bypass in MigrateConnectorTokens() Allows Unauthorized Critical State Migration

### Summary
The `MigrateConnectorTokens()` function lacks authorization checks, allowing any user to trigger the irreversible migration of connector token symbols from old format to new format. This bypasses the intended governance control that protects all other connector management operations, enabling attackers to control the timing of critical system state changes and potentially disrupt trading operations and upgrade procedures.

### Finding Description

The `MigrateConnectorTokens()` function is a public method that performs critical state modifications without any authorization check. [1](#0-0) 

**Root Cause**: Unlike all other administrative functions in the TokenConverter contract, `MigrateConnectorTokens()` does NOT call `AssertPerformedByConnectorController()` to verify the caller has proper authority.

**Comparison with Protected Functions**:
- `UpdateConnector` properly checks authorization [2](#0-1) 
- `AddPairConnector` properly checks authorization [3](#0-2) 
- `SetFeeRate` properly checks authorization [4](#0-3) 
- `ChangeConnectorController` properly checks authorization [5](#0-4) 

The authorization check implementation verifies that only the connector controller (default is Parliament organization) can perform these actions. [6](#0-5) 

**State Modifications**: The function modifies critical contract state including:
1. Connector `RelatedSymbol` mappings (line 329)
2. Connector objects stored under new symbol keys (lines 331-336)
3. `DepositBalance` mappings migrated to new symbols (line 338)

**Public Access**: The method is exposed as a public RPC endpoint with no access control annotations. [7](#0-6) 

### Impact Explanation

**Authorization Governance Bypass**: This vulnerability allows any user to execute a privileged operation that should only be callable by the connector controller (Parliament governance organization), directly violating the authorization invariant.

**Concrete Harm**:
1. **Timing Control**: Attacker controls WHEN the migration occurs, not the authorized governance. Premature migration can disrupt planned upgrade coordination.
2. **Irreversible State Change**: Once migrated, the function cannot be called again due to the "Already migrated" check (line 325), making the unauthorized migration permanent.
3. **Trading Disruption**: Changing connector `RelatedSymbol` relationships affects which token pairs can be traded via Buy/Sell operations, potentially breaking active trading flows.
4. **Integration Breakage**: External contracts or systems expecting the old connector symbol format will fail after unauthorized migration.
5. **Accounting Confusion**: Deposit balance mappings are migrated from old to new symbol keys, which can cause accounting issues if done at the wrong time.

**Affected Assets**: All resource tokens in PayTxFeeSymbolListName and PayRentalSymbolListName (typically CPU, RAM, DISK, NET tokens) and their associated deposit balances.

**Severity Justification**: Critical severity because:
- Zero authentication required
- Affects core protocol functionality (token conversion)
- Irreversible state modification
- Direct violation of governance authorization model
- Impacts all resource token connectors system-wide

### Likelihood Explanation

**Attacker Capabilities**: Any user with the ability to submit a transaction to the blockchain can exploit this vulnerability. No special permissions, tokens, or setup required.

**Attack Complexity**: Trivial - single transaction call to `MigrateConnectorTokens()` with empty parameter.

**Feasibility Conditions**:
- Contract must be initialized and have connectors set up (normal operating state)
- Migration must not have already occurred (one-time opportunity per deployment)
- Resource tokens must be in the system symbol lists (standard configuration)

**Detection Constraints**: The transaction will succeed without error, making it appear as a legitimate operation. Only off-chain monitoring would detect unauthorized caller.

**Probability**: HIGH - The attack requires minimal technical sophistication, costs only transaction fees, and can be discovered through simple contract interface exploration. The one-time nature creates urgency for attackers to exploit before authorized migration.

### Recommendation

**Immediate Fix**: Add authorization check at the beginning of `MigrateConnectorTokens()`:

```csharp
public override Empty MigrateConnectorTokens(Empty input)
{
    AssertPerformedByConnectorController();  // ADD THIS LINE
    foreach (var resourceTokenSymbol in Context.Variables.GetStringArray(PayTxFeeSymbolListName)
        // ... rest of function
}
```

**Placement**: Add the check immediately after line 312, following the same pattern used in other administrative functions. [8](#0-7) 

**Test Case**: Add authorization failure test following the pattern of existing tests:

```csharp
[Fact]
public async Task MigrateConnectorTokens_Without_Authority_Test()
{
    var migrateResult = await DefaultStub.MigrateConnectorTokens
        .SendWithExceptionAsync(new Empty());
    migrateResult.TransactionResult.Error.ShouldContain(
        "Only manager can perform this action.");
}
```

Reference existing authorization test patterns: [9](#0-8) 

### Proof of Concept

**Initial State**:
1. TokenConverter contract initialized with connectors for resource tokens (CPU, RAM, etc.)
2. Connectors using old "nt" prefix format (e.g., "ntCPU", "ntRAM")
3. Active trading operations expecting old format
4. Authorized migration planned for future governance-approved time

**Attack Steps**:
1. Attacker (any address) submits transaction: `TokenConverterContract.MigrateConnectorTokens(Empty)`
2. Function executes without authorization check
3. All resource token connectors migrate from "ntXXX" to "(NT)XXX" format
4. Deposit balances migrate to new symbol keys
5. Connector relationships permanently changed

**Expected vs Actual**:
- **Expected**: Transaction rejected with "Only manager can perform this action."
- **Actual**: Transaction succeeds, migration completes, state permanently modified

**Success Condition**: Query `GetPairConnector` for resource tokens shows `RelatedSymbol` changed to "(NT)" prefix format, confirming unauthorized migration completed.

**Test Evidence**: Existing tests demonstrate the function works when called by any user without checking authorization. [10](#0-9) 

No authorization failure test exists for this function, unlike other administrative functions. [11](#0-10) 

### Notes

The connector controller defaults to the Parliament contract's default organization address when not explicitly set, providing a governance-based authorization model. [12](#0-11) 

All connector management operations consistently use this authorization pattern except `MigrateConnectorTokens()`, indicating this is an oversight rather than intentional design.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-60)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-81)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L260-262)
```csharp
    public override Empty SetFeeRate(StringValue input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L303-305)
```csharp
    public override Empty ChangeConnectorController(AuthorityInfo input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L311-342)
```csharp
    public override Empty MigrateConnectorTokens(Empty input)
    {
        foreach (var resourceTokenSymbol in Context.Variables.GetStringArray(PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(PayRentalSymbolListName)))
        {
            var newConnectorTokenSymbol = NewNtTokenPrefix.Append(resourceTokenSymbol);

            if (State.Connectors[resourceTokenSymbol] == null)
            {
                continue;
            }

            var oldConnectorTokenSymbol = State.Connectors[resourceTokenSymbol].RelatedSymbol;

            Assert(!oldConnectorTokenSymbol.StartsWith(NewNtTokenPrefix), "Already migrated.");

            // Migrate

            State.Connectors[resourceTokenSymbol].RelatedSymbol = newConnectorTokenSymbol;

            if (State.Connectors[oldConnectorTokenSymbol] != null)
            {
                var connector = State.Connectors[oldConnectorTokenSymbol];
                connector.Symbol = newConnectorTokenSymbol;
                State.Connectors[newConnectorTokenSymbol] = connector;
            }

            State.DepositBalance[newConnectorTokenSymbol] = State.DepositBalance[oldConnectorTokenSymbol];
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L397-403)
```csharp
    private void AssertPerformedByConnectorController()
    {
        if (State.ConnectorController.Value == null) State.ConnectorController.Value = GetDefaultConnectorController();

        Assert(Context.Sender == State.ConnectorController.Value.OwnerAddress,
            "Only manager can perform this action.");
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L405-416)
```csharp
    private AuthorityInfo GetDefaultConnectorController()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        return new AuthorityInfo
        {
            ContractAddress = State.ParliamentContract.Value,
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty())
        };
    }
```

**File:** protobuf/token_converter_contract.proto (L55-56)
```text
    rpc MigrateConnectorTokens (google.protobuf.Empty) returns (google.protobuf.Empty) {
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConvertConnectorTest.cs (L116-125)
```csharp
    public async Task AddPairConnector_Without_Authority_Test()
    {
        var tokenSymbol = "NETT";
        var pairConnector = GetLegalPairConnectorParam(tokenSymbol);
        var addConnectorWithoutAuthorityRet =
            await DefaultStub.AddPairConnector.SendWithExceptionAsync(
                pairConnector);
        addConnectorWithoutAuthorityRet.TransactionResult.Error.ShouldContain(
            "Only manager can perform this action.");
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConvertConnectorTest.cs (L146-159)
```csharp
    public async Task UpdateConnector_Without_Authority_Test()
    {
        var tokenSymbol = "CWJ";
        await AddPairConnectorAsync(tokenSymbol);
        var updateConnector = new Connector
        {
            Symbol = tokenSymbol,
            Weight = "0.3"
        };
        var updateRet =
            await DefaultStub.UpdateConnector.SendWithExceptionAsync(
                updateConnector);
        updateRet.TransactionResult.Error.ShouldContain("Only manager can perform this action.");
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/ConnectorTokenMigrateTest.cs (L21-21)
```csharp
        await DefaultStub.MigrateConnectorTokens.SendAsync(new Empty());
```
