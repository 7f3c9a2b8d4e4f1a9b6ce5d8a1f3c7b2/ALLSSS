# Audit Report

## Title
Sponsor Can DOS Voters by Rapidly Exhausting Snapshots Regardless of EndTimestamp

## Summary
The Vote contract's `TakeSnapshot` function lacks time-based restrictions, allowing sponsors to prematurely terminate voting by exhausting all snapshots in rapid succession. Voting eligibility depends solely on snapshot count rather than the declared `EndTimestamp`, enabling sponsors to deny voter participation despite the advertised voting period.

## Finding Description

The vulnerability stems from the fundamental mismatch between how voting periods are declared versus how they are enforced in the Vote contract.

The `TakeSnapshot` function only validates sponsor authorization and snapshot count limits, with no time-based restrictions whatsoever: [1](#0-0) 

The function increments `CurrentSnapshotNumber` and sets the new snapshot's start time to the current block without validating against the voting item's `EndTimestamp`.

The critical flaw appears in `AssertValidVoteInput`, which determines voting eligibility based solely on snapshot count: [2](#0-1) 

The check at lines 382-383 compares `CurrentSnapshotNumber <= TotalSnapshotNumber`, making no reference to time. Once snapshots are exhausted, voting immediately fails with "Current voting item already ended."

During registration, `EndTimestamp` is stored but only validated to exceed `StartTimestamp`: [3](#0-2) 

The `EndTimestamp` field is never checked during subsequent voting or snapshot operations, rendering it purely informational rather than a security enforcement mechanism.

**Attack Scenario:**
1. Sponsor registers voting item with `EndTimestamp` 30 days in future and `TotalSnapshotNumber = 10`
2. Sponsor immediately calls `TakeSnapshot` 10 times in rapid succession (consecutive blocks or even same block if gas permits)
3. `CurrentSnapshotNumber` reaches 11, exceeding `TotalSnapshotNumber`
4. All voter attempts to participate fail, despite being well before the declared `EndTimestamp`
5. Governance outcome is determined only by votes cast in the brief window before snapshot exhaustion

## Impact Explanation

**Severity: High**

This vulnerability enables complete denial of the voting system's core functionality with severe governance implications:

1. **Operational DOS**: Voters are systematically denied their ability to participate in governance despite the declared voting period, violating the fundamental expectation that `EndTimestamp` defines when voting closes.

2. **Governance Manipulation**: Sponsors can strategically control voter participation windows to influence outcomes. By terminating voting prematurely, they can exclude late voters who might have different preferences, effectively rigging governance decisions.

3. **Trust Violation**: The voting system's inability to honor its time commitments undermines trust in the governance process. A 30-day voting period advertised to the community can be terminated in minutes.

4. **Unfair Advantage**: Early voters who manage to vote before snapshot exhaustion gain disproportionate influence, while late voters are completely excluded despite acting within the declared timeframe.

While no direct fund theft occurs, governance manipulation at this level can lead to protocol-level damage through unauthorized parameter changes, malicious proposals, or captured decision-making processes.

Test evidence confirms this behavior - when snapshots are exhausted, voting immediately fails: [4](#0-3) 

## Likelihood Explanation

**Likelihood: High**

This vulnerability has exceptionally high exploitability:

1. **Low Attack Complexity**: The entry point is the public `TakeSnapshot` method accessible to any sponsor. Execution requires only repeatedly calling `TakeSnapshot` with sequential snapshot numbers - no sophisticated techniques needed.

2. **No Special Privileges Required**: The sponsor role is part of normal operation, obtained simply by registering a voting item. This is not a compromised or privileged account scenario.

3. **Trivial Execution**: The attack can be executed in consecutive blocks or even within a single block (gas permitting). No economic barriers exist beyond negligible gas costs.

4. **Difficult Detection**: Rapid snapshots appear as legitimate sponsor activity with no on-chain indicators to distinguish malicious from legitimate snapshot progression. Voters only discover the DOS when their transactions fail.

Test evidence demonstrates snapshots can be taken in rapid succession without any time delays: [5](#0-4) 

The test takes 3 snapshots immediately in a for loop, proving no time-based restrictions exist.

## Recommendation

Implement time-based validation in the `TakeSnapshot` function to enforce minimum intervals between snapshots and respect the declared `EndTimestamp`:

```csharp
public override Empty TakeSnapshot(TakeSnapshotInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    
    Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");
    
    // NEW: Enforce EndTimestamp
    Assert(Context.CurrentBlockTime <= votingItem.EndTimestamp, 
        "Cannot take snapshot after voting end time.");
    
    Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
        "Current voting item already ended.");
    
    // NEW: Enforce minimum time interval between snapshots
    var minimumInterval = (votingItem.EndTimestamp.Seconds - votingItem.StartTimestamp.Seconds) 
        / votingItem.TotalSnapshotNumber;
    var timeSinceStart = Context.CurrentBlockTime.Seconds - votingItem.StartTimestamp.Seconds;
    var expectedMinimumSnapshot = timeSinceStart / minimumInterval;
    Assert(votingItem.CurrentSnapshotNumber <= expectedMinimumSnapshot + 1,
        "Cannot take snapshot too early - minimum time interval not elapsed.");
    
    // ... rest of function
}
```

Additionally, update `AssertValidVoteInput` to also check `EndTimestamp`:

```csharp
Assert(Context.CurrentBlockTime <= votingItem.EndTimestamp, 
    "Voting period has ended.");
Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
    "Current voting item already ended.");
```

## Proof of Concept

The existing test suite already demonstrates this vulnerability. The test at `BasicTests.cs` lines 92-102 shows that after exhausting snapshots via `TakeSnapshot`, voting immediately fails even though no time validation occurs. 

To explicitly demonstrate the DOS:

```csharp
[Fact]
public async Task Sponsor_Can_DOS_Voters_By_Exhausting_Snapshots()
{
    // Register voting item with 30-day EndTimestamp but only 3 snapshots
    var endTime = TimestampHelper.GetUtcNow().AddDays(30);
    var registerItem = await RegisterVotingItemAsync(30, 3, true, DefaultSender, 3, endTime);
    
    // Sponsor rapidly exhausts all snapshots in consecutive calls
    await TakeSnapshot(registerItem.VotingItemId, 1);
    await TakeSnapshot(registerItem.VotingItemId, 2);
    await TakeSnapshot(registerItem.VotingItemId, 3);
    
    // Voting is now terminated despite being well before EndTimestamp
    var voter = Accounts[11].KeyPair;
    var voteResult = await VoteWithException(voter, registerItem.VotingItemId, 
        registerItem.Options[0], 100);
    
    // Verify voting fails with "already ended" message
    voteResult.Status.ShouldBe(TransactionResultStatus.Failed);
    voteResult.Error.Contains("Current voting item already ended").ShouldBeTrue();
    
    // Verify we're still well before the declared EndTimestamp
    var currentTime = Context.CurrentBlockTime;
    Assert(currentTime < endTime, "Current time should be before end time");
}
```

## Notes

This vulnerability represents a fundamental design flaw where the Vote contract treats `EndTimestamp` as advisory information rather than an enforced security constraint. The protocol's governance integrity depends on voters' ability to participate during declared timeframes, but the current implementation allows sponsors to unilaterally override these guarantees.

The issue is particularly concerning because:
1. It affects a core governance primitive used throughout the AElf ecosystem
2. The attack is trivial to execute and difficult to detect
3. No on-chain mechanisms exist to punish or prevent this abuse
4. Voters have no way to know voting will be prematurely terminated until they attempt to vote

The recommended fix requires coordinated validation between time-based and snapshot-based termination conditions to ensure both constraints are respected.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L241-273)
```csharp
    public override Empty TakeSnapshot(TakeSnapshotInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);

        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");

        Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");

        // Update previous voting going information.
        var previousVotingResultHash = GetVotingResultHash(input.VotingItemId, votingItem.CurrentSnapshotNumber);
        var previousVotingResult = State.VotingResults[previousVotingResultHash];
        previousVotingResult.SnapshotEndTimestamp = Context.CurrentBlockTime;
        State.VotingResults[previousVotingResultHash] = previousVotingResult;

        Assert(votingItem.CurrentSnapshotNumber == input.SnapshotNumber,
            $"Can only take snapshot of current snapshot number: {votingItem.CurrentSnapshotNumber}, but {input.SnapshotNumber}");
        var nextSnapshotNumber = input.SnapshotNumber.Add(1);
        votingItem.CurrentSnapshotNumber = nextSnapshotNumber;
        State.VotingItems[votingItem.VotingItemId] = votingItem;

        // Initial next voting going information.
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L92-102)
```csharp
        //voting item have been out of date
        {
            var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1);
            await TakeSnapshot(registerItem.VotingItemId, 1);

            var voter = Accounts[11].KeyPair;
            var voteResult =
                await VoteWithException(voter, registerItem.VotingItemId, registerItem.Options[0], 100);
            voteResult.Status.ShouldBe(TransactionResultStatus.Failed);
            voteResult.Error.Contains("Current voting item already ended").ShouldBeTrue();
        }
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/SnapshotTests.cs (L78-101)
```csharp
    public async Task VoteContract_TakeSnapshot_Success_Test()
    {
        var registerItem = await RegisterVotingItemAsync(10, 4, true, DefaultSender, 3);
        for (var i = 0; i < 3; i++)
        {
            var transactionResult = (await VoteContractStub.TakeSnapshot.SendAsync(
                new TakeSnapshotInput
                {
                    VotingItemId = registerItem.VotingItemId,
                    SnapshotNumber = i + 1
                })).TransactionResult;

            transactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            var votingItem = await GetVoteItem(registerItem.VotingItemId);
            votingItem.CurrentSnapshotNumber.ShouldBe(i + 2);
            var voteResult = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
            {
                VotingItemId = registerItem.VotingItemId,
                SnapshotNumber = i + 2
            });
            voteResult.SnapshotNumber.ShouldBe(i + 2);
        }
    }
```
