### Title
Miner Collusion Can Delay Term Changes and Prevent Election Snapshot Creation

### Summary
Colluding miners controlling more than 1/3 of the mining power can deliberately prevent term transitions by forcing `NextRound` instead of `NextTerm`, which blocks the execution of `ElectionContract.TakeSnapshot`. This causes election vote data to remain stale, prevents reward distribution for those terms, and results in loss of historical election data.

### Finding Description

The vulnerability exists in the consensus behavior determination logic located in `GetConsensusBehaviourToTerminateCurrentRound()`. [1](#0-0) 

The function returns `NextTerm` only when `NeedToChangeTerm()` returns true, which requires at least `MinersCountOfConsent` (⌊count × 2/3⌋ + 1) miners to have their latest `ActualMiningTime` passing the term threshold check. [2](#0-1) 

**Root Cause:**
The `NeedToChangeTerm()` function filters miners by those who have any `ActualMiningTimes`, then checks if their **last** `ActualMiningTime` meets the term change threshold using `IsTimeToChangeTerm()`. [3](#0-2) 

Miners only get their `ActualMiningTimes` updated when they actively produce blocks. [4](#0-3) 

**Attack Path:**
1. More than 1/3 of miners coordinate to stop producing blocks just before the term threshold time
2. Their last `ActualMiningTime` remains from before the threshold
3. Less than 2/3 of miners have `ActualMiningTime` values indicating term change should occur
4. `NeedToChangeTerm()` returns false, causing `NextRound` to be returned instead of `NextTerm`
5. `ProcessNextRound()` is executed instead of `ProcessNextTerm()` [5](#0-4) 
6. `TakeSnapshot` is never called [6](#0-5) 

**Why Existing Protections Fail:**
Evil miner detection exists but operates with a high tolerance threshold of 4,320 missed time slots (3 days). [7](#0-6)  Evil miners are only detected during `ProcessNextRound`, not during the decision of which consensus behavior to use. [8](#0-7) 

### Impact Explanation

**Direct Harm:**
- Election snapshots are not created for affected terms, preventing term-based reward distribution [9](#0-8) 
- Historical election results (vote counts per candidate) are permanently lost [10](#0-9) 
- Vote contract snapshots are not taken, causing vote weight data to remain stale [11](#0-10) 
- Candidate information updates are skipped, preventing proper tracking of miner terms and continual appointment counts [12](#0-11) 
- Treasury profit releases for the affected term(s) do not occur [13](#0-12) 

**Affected Parties:**
- Token holders who voted receive no rewards for the duration of the attack
- Candidates lose historical voting records and term tracking
- The protocol loses term-based reward distribution accuracy

**Duration:** 
Attack can persist for up to 3 days (4,320 time slots) before colluding miners accumulate enough missed slots to trigger evil miner detection and potential replacement.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Control or coordination of more than 1/3 of the active miner set
- Ability to coordinate simultaneous cessation of block production
- Willingness to sacrifice block production rewards during attack period

**Attack Complexity:**
- Medium complexity - requires precise timing (stopping just before term threshold)
- Requires sustained coordination among multiple miners for up to 3 days
- Miners must accept accumulation of missed time slots leading to evil miner status

**Feasibility Constraints:**
- **Economic Irrationality:** Attacking miners forfeit all block rewards during the attack period, making this economically irrational under normal circumstances
- **Detection Risk:** Missed time slots accumulate and become visible on-chain [14](#0-13) 
- **Limited Duration:** Evil miner detection mechanism provides a natural timeout after 3 days
- **Reputational Damage:** Marked evil miners face banning and removal from candidate lists

**Probability Assessment:**
While technically feasible, this attack requires significant miner collusion (>33%) and has questionable economic motivation. The attack is most likely in scenarios where miners have alternative incentives beyond immediate block rewards (e.g., manipulating election outcomes, preventing specific candidates from receiving rewards, or during governance disputes).

### Recommendation

**Immediate Fix:**
Add a fallback mechanism in `GetConsensusBehaviourToTerminateCurrentRound()` to force `NextTerm` if the round number within the current term exceeds a reasonable threshold (e.g., 2,000 rounds per term for a 7-day period):

```csharp
protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
{
    var roundsSinceTermStart = CurrentRound.RoundNumber - _firstRoundOfCurrentTerm;
    var maxRoundsPerTerm = _periodSeconds / 60; // Assuming ~1 minute per round
    
    if (roundsSinceTermStart > maxRoundsPerTerm * 2) // 2x safety margin
        return AElfConsensusBehaviour.NextTerm;
        
    return CurrentRound.RoundNumber == 1 ||
           !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
               CurrentRound.TermNumber, _periodSeconds) ||
           CurrentRound.RealTimeMinersInformation.Keys.Count == 1
        ? AElfConsensusBehaviour.NextRound
        : AElfConsensusBehaviour.NextTerm;
}
```

**Additional Mitigations:**
1. Reduce `TolerableMissedTimeSlotsCount` from 4,320 to a lower value (e.g., 1,440 = 1 day) to detect and replace non-participating miners faster
2. Add a time-based check: if blockchain time exceeds `termStartTime + periodSeconds + gracePeriod`, force term change regardless of miner consensus
3. Implement alerts when `NeedToChangeTerm()` returns false for an extended period despite elapsed time indicating a term change should occur

**Test Cases:**
1. Verify term change is forced when round count exceeds maximum threshold
2. Test that time-based override triggers NextTerm after grace period
3. Confirm evil miner detection still functions with reduced threshold

### Proof of Concept

**Initial State:**
- Blockchain has 7 active miners (A, B, C, D, E, F, G)
- Current term number: 1
- Period seconds: 604,800 (7 days)
- Current blockchain time: T0 + 600,000 seconds
- `MinersCountOfConsent` = ⌊7 × 2/3⌋ + 1 = 5 miners required

**Attack Execution:**
1. At time T0 + 600,000 (just before T0 + 604,800 term threshold), miners A, B, and C coordinate to stop producing blocks
2. Their last `ActualMiningTime` remains at approximately T0 + 600,000
3. Miners D, E, F, G continue producing blocks normally
4. At time T0 + 605,000 (after term threshold):
   - Miners A, B, C: `IsTimeToChangeTerm(T0, T0+600000, 1, 604800)` → `600000/604800 = 0`, and `0 == (1-1)` → returns FALSE
   - Miners D, E, F, G: `IsTimeToChangeTerm(T0, T0+605000, 1, 604800)` → `605000/604800 = 1`, and `1 != (1-1)` → returns TRUE
   - Count of miners returning TRUE: 4
   - Required: 5
   - `NeedToChangeTerm()` returns FALSE
5. `GetConsensusBehaviourToTerminateCurrentRound()` returns `NextRound` instead of `NextTerm`
6. `ProcessNextRound()` executes, `ProcessNextTerm()` does not
7. `ElectionContract.TakeSnapshot()` is never called
8. Election snapshot for term 1 is never created

**Expected Result:**
Term should transition to term 2, and `TakeSnapshot` should be called to capture election results.

**Actual Result:**
Term remains at term 1, rounds continue incrementing, and no election snapshot is created. This continues until miners A, B, C accumulate 4,320 missed time slots (approximately 3 days) and are marked as evil miners.

**Success Condition:**
Query `State.Snapshots[1]` in the Election contract - it remains null/empty despite time progressing beyond the term threshold, confirming election vote data has not been captured.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L239-243)
```csharp
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-244)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L422-426)
```csharp
        State.VoteContract.TakeSnapshot.Send(new TakeSnapshotInput
        {
            SnapshotNumber = input.TermNumber,
            VotingItemId = State.MinerElectionVotingItemId.Value
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L442-447)
```csharp
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.SubsidyHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L459-479)
```csharp
    private void SavePreviousTermInformation(TakeElectionSnapshotInput input)
    {
        var snapshot = new TermSnapshot
        {
            MinedBlocks = input.MinedBlocks,
            EndRoundNumber = input.RoundNumber
        };

        if (State.Candidates.Value == null) return;

        foreach (var pubkey in State.Candidates.Value.Value)
        {
            var votes = State.CandidateVotes[pubkey.ToHex()];
            var validObtainedVotesAmount = 0L;
            if (votes != null) validObtainedVotesAmount = votes.ObtainedActiveVotedVotesAmount;

            snapshot.ElectionResult.Add(pubkey.ToHex(), validObtainedVotesAmount);
        }

        State.Snapshots[input.TermNumber] = snapshot;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L481-490)
```csharp
    private void UpdateCandidateInformation(string pubkey, long lastTermNumber,
        List<string> previousMiners)
    {
        var candidateInformation = State.CandidateInformationMap[pubkey];
        if (candidateInformation == null) return;
        candidateInformation.Terms.Add(lastTermNumber);
        var victories = GetVictories(previousMiners);
        candidateInformation.ContinualAppointmentCount = victories.Contains(ByteStringHelper.FromHexString(pubkey))
            ? candidateInformation.ContinualAppointmentCount.Add(1)
            : 0;
```
