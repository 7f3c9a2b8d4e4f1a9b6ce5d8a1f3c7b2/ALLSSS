### Title
Case-Insensitive Token Uniqueness Check Bypassed in Cross-Chain Token Creation

### Summary
The `CrossChainCreateToken` function uses a case-sensitive check to determine if a token already exists, while the normal `Create` flow uses a case-insensitive check. This inconsistency allows tokens with the same symbol but different casing (e.g., "ABC" and "abc") to coexist as separate tokens on the same chain, leading to balance fragmentation, user confusion, and potential SymbolSeedMap conflicts.

### Finding Description

**Root Cause:**

The normal token creation flow in `CreateToken` calls `CheckTokenExists` which performs a case-insensitive uniqueness check: [1](#0-0) 

This check uses `State.InsensitiveTokenExisting[symbol.ToUpper()]` to prevent creating tokens that differ only in case.

However, the cross-chain token creation flow in `CrossChainCreateToken` only performs a case-sensitive check: [2](#0-1) 

This check uses `State.TokenInfos[tokenInfo.Symbol]` directly without case normalization, bypassing the case-insensitive uniqueness enforcement.

**Storage Implementation:**

All token-related state maps (TokenInfos, Balances, Allowances) use the exact symbol string as the key without case normalization: [3](#0-2) [4](#0-3) 

This means "ABC" and "abc" are treated as completely separate keys, maintaining separate balances and token information.

**SymbolSeedMap Conflict:**

The SymbolSeedMap used for NFT creation consistently uses `.ToUpper()` for both reads and writes: [5](#0-4) [6](#0-5) 

If tokens "ABC" and "abc" both exist, they would conflict when used in SymbolSeedMap operations since both map to the same uppercase key.

### Impact Explanation

**Concrete Harm:**

1. **Balance Fragmentation**: Users' token holdings are split across different case variants (e.g., `State.Balances[user]["ABC"]` vs `State.Balances[user]["abc"]`), making it difficult to track total balances and potentially causing funds to appear "lost."

2. **Token Confusion**: Smart contracts and users expecting case-insensitive symbol handling will interact with the wrong token variant, leading to failed transactions, incorrect allowances, and operational errors.

3. **SymbolSeedMap Corruption**: When both "ABC" and "abc" tokens are used in SEED NFT operations, they share the same `SymbolSeedMap["ABC"]` entry, causing one to overwrite the other's seed mapping, potentially breaking NFT creation logic.

4. **Cross-Chain Inconsistency**: If a parent chain has token "ABC" and a child chain already has "abc", the cross-chain sync will create both tokens on the child chain, causing divergence from the parent chain's single-token state.

**Affected Parties:**
- Token holders whose balances become fragmented across case variants
- Smart contracts relying on case-insensitive symbol lookup
- NFT creators using SEED tokens with conflicting symbols
- Cross-chain bridge operators dealing with symbol mismatches

**Severity Justification:**
Medium severity due to operational disruption and potential for user fund confusion, though not direct theft. The vulnerability requires specific cross-chain conditions but has measurable impact on token accounting integrity.

### Likelihood Explanation

**Attack Preconditions:**

1. An attacker creates a token with specific casing (e.g., "abc") on a child chain through normal `Create()` flow
2. A token with different casing (e.g., "ABC") exists on a parent chain
3. Cross-chain token registration is initiated from parent to child chain

**Execution Path:**

1. Parent chain has token "ABC" registered via normal creation
2. Child chain has token "abc" registered via normal creation (different chain, different contract state)
3. User initiates cross-chain transfer or registration from parent to child
4. `CrossChainCreateToken` is called with symbol "ABC"
5. Check `State.TokenInfos["ABC"] == null` passes (only "abc" exists)
6. `RegisterTokenInfo` is called, creating duplicate token with different case
7. Both "ABC" and "abc" now exist as separate tokens on child chain

**Feasibility:**

- **Reachable**: `CrossChainCreateToken` is a public method callable by anyone with valid cross-chain proof
- **Practical**: Requires coordination between chains but no privileged access
- **Realistic**: Cross-chain token registration is a normal operation; attacker only needs to time token creation on child chain before cross-chain sync
- **Detectable**: The duplicate tokens would be visible in contract state but might go unnoticed without explicit case-sensitive queries

**Complexity:** Medium - requires cross-chain operation setup but follows normal protocol flows.

### Recommendation

**Immediate Fix:**

Add case-insensitive existence check before registering tokens in `CrossChainCreateToken`:

```csharp
// In CrossChainCreateToken, before line 506
Assert(!State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()], 
    "Token with same symbol (case-insensitive) already exists.");

if (State.TokenInfos[tokenInfo.Symbol] == null)
{
    RegisterTokenInfo(tokenInfo);
    // ... rest of the code
}
```

**Additional Safeguards:**

1. Add a helper method for case-insensitive token lookup:
```csharp
private TokenInfo GetTokenInfoCaseInsensitive(string symbol)
{
    var tokenInfo = GetTokenInfo(symbol);
    if (tokenInfo != null) return tokenInfo;
    
    // Check if case variant exists
    if (State.InsensitiveTokenExisting[symbol.ToUpper()])
    {
        // Symbol exists with different case
        Assert(false, "Token exists with different casing");
    }
    return null;
}
```

2. Normalize all symbols to uppercase at entry points before storage
3. Add integration test to verify cross-chain creation rejects case variants

**Test Cases:**

1. Create token "ABC" on chain A, then "abc" on chain A via normal flow - should fail
2. Create token "abc" on chain B, then cross-chain register "ABC" from chain A - should fail
3. Create token "ABC" on chain A, cross-chain register "ABC" to chain B - should succeed
4. Verify SymbolSeedMap consistency across case variants

### Proof of Concept

**Initial State:**
- Parent Chain A: Token "ABC" exists (created via normal `Create()` flow)
- Child Chain B: Empty token registry

**Attack Sequence:**

1. **Attacker creates lowercase variant on child chain:**
   ```
   Chain B: Call Create({Symbol: "abc", TokenName: "Test", ...})
   Result: Token "abc" registered
   - State.TokenInfos["abc"] = TokenInfo(...)
   - State.InsensitiveTokenExisting["ABC"] = true
   ```

2. **Legitimate cross-chain registration initiated:**
   ```
   Chain A: Call ValidateTokenInfoExists({Symbol: "ABC", ...})
   Result: Validation succeeds, merkle proof generated
   ```

3. **Cross-chain token creation on child chain:**
   ```
   Chain B: Call CrossChainCreateToken({
       TransactionBytes: <validated tx>,
       MerklePath: <proof>,
       ...
   })
   
   Execution:
   - CrossChainVerify passes (valid proof)
   - Check: State.TokenInfos["ABC"] == null â†’ TRUE (different case)
   - RegisterTokenInfo("ABC") executes
   - State.TokenInfos["ABC"] = TokenInfo(...)
   - State.InsensitiveTokenExisting["ABC"] = true (already true, no error)
   ```

**Expected Result:** 
Cross-chain creation should fail with "Token with same symbol already exists"

**Actual Result:**
Both "ABC" and "abc" exist as separate tokens:
- `State.TokenInfos["ABC"]` returns Token ABC info
- `State.TokenInfos["abc"]` returns Token abc info  
- `State.Balances[user]["ABC"]` is independent from `State.Balances[user]["abc"]`
- Both tokens share `State.SymbolSeedMap["ABC"]` causing conflicts

**Success Condition:**
Query both `GetTokenInfo("ABC")` and `GetTokenInfo("abc")` - both return non-null TokenInfo objects with different addresses/data, proving duplicate registration succeeded.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L124-124)
```csharp
        State.Balances[address][symbol] = target;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L232-233)
```csharp
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-508)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L51-51)
```csharp
            State.SymbolSeedMap[ownedSymbol.ToUpper()] = input.Symbol;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L59-59)
```csharp
        var oldSymbolSeed = State.SymbolSeedMap[ownedSymbol.ToUpper()];
```
