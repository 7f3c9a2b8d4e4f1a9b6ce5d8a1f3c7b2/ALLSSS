### Title
Unbounded Collection Iteration in Assemble/Disassemble Causes Economic Denial of Service

### Summary
The NFT contract's `Assemble` and `Disassemble` methods lack size validation on the `AssembledNfts` and `AssembledFts` collections, allowing users to create composite NFTs with thousands of components. While AElf's 15,000 branch count threshold prevents complete transaction failure, assembling NFTs with several thousand components creates an economic DOS where disassembly becomes prohibitively expensive, effectively locking user assets permanently.

### Finding Description

The vulnerability exists in the `Assemble` method which accepts unbounded `AssembledNfts` and `AssembledFts` map collections without size validation: [1](#0-0) 

The method iterates over all provided NFTs and FTs to lock them into the composite NFT: [2](#0-1) 

The collections are stored in state maps with no size constraints: [3](#0-2) 

When disassembling, the contract must iterate over all stored components to transfer them back: [4](#0-3) [5](#0-4) 

Each iteration performs expensive state operations (balance checks, transfers, external contract calls). With thousands of components, the cumulative gas cost becomes economically infeasible.

**Why Existing Protections Fail:**

AElf's execution observer enforces a 15,000 branch count limit: [6](#0-5) [7](#0-6) 

However, this only prevents technical failure at 15,000 iterations. An assembly with 2,000-10,000 components will execute successfully but consume excessive transaction fees, creating an economic barrier rather than a technical one.

The protobuf definitions show these collections are unbounded maps: [8](#0-7) 

No validation exists in the codebase to limit collection sizes before assembly.

### Impact Explanation

**Asset Lockup:** Users who assemble NFTs with large component counts (or receive such NFTs through transfer/purchase) cannot economically retrieve their locked assets. Disassembly requires iterating over all components, with each iteration performing:
- State reads for balance checks
- DoTransfer operations (2 balance updates per NFT)
- External TokenContract calls for FTs

With 5,000 components, this results in 10,000+ state operations, making the transaction cost prohibitively expensive or potentially exceeding block gas limits.

**Attack Scenarios:**
1. **Malicious Lock:** Attacker assembles an NFT with 5,000 cheap NFTs, sells it to a victim. Victim cannot disassemble to retrieve components.
2. **Griefing:** Attacker locks valuable NFTs/FTs of their own in an expensive-to-disassemble composite, griefing themselves or future buyers.
3. **Accidental Lock:** Honest user creates large assembly without realizing disassembly costs, permanently locking their assets.

**Affected Parties:**
- NFT holders who assembled or purchased large composite NFTs
- Secondary market participants who unknowingly buy locked NFTs
- Protocol reputation due to user asset lockup

**Severity Justification:** Medium severity because while it doesn't enable direct theft, it causes permanent economic DOS of the disassembly function, effectively confiscating user assets through prohibitive costs.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to mint or acquire multiple NFTs/FTs (can be low-value test tokens)
- Call the public `Assemble` method with large collections
- No special privileges or governance control needed

**Attack Complexity:** Low
- Single transaction to `Assemble` with large input collection
- No complex state manipulation or timing requirements
- Works within normal contract execution model

**Feasibility Conditions:**
- Attacker needs ownership of multiple tokens (easily achievable by minting cheap NFTs)
- No preconditions on chain state or timing
- Attack cost is minimal relative to potential damage

**Economic Rationality:**
- Cost to execute: Transaction fees for one Assemble call with ~5,000 items (estimated under 15,000 branch limit)
- Benefit: Locks victim's assets permanently or creates griefing scenario
- For malicious actor targeting specific victim NFTs: highly rational
- For protocol disruption/reputation damage: rational for motivated attacker

**Detection Constraints:** The assembled NFT appears normal until someone attempts disassembly. No on-chain indicator warns users that disassembly will be expensive.

### Recommendation

**Immediate Mitigation:**
Add collection size validation in the `Assemble` method:

```csharp
public override Hash Assemble(AssembleInput input)
{
    const int MaxAssembledItems = 100; // Reasonable limit based on gas costs
    
    var totalItems = input.AssembledNfts.Value.Count + input.AssembledFts.Value.Count;
    Assert(totalItems <= MaxAssembledItems, 
        $"Cannot assemble more than {MaxAssembledItems} total items. Attempted: {totalItems}");
    
    // ... rest of existing logic
}
```

**Recommended Limit:** Set MaxAssembledItems to a value that ensures disassembly remains economically feasible (suggested: 50-100 items based on testing actual gas costs).

**Additional Hardening:**
1. Add similar validation in `AddMinters` and `RemoveMinters` for MinterList size: [9](#0-8) 

2. Consider batch disassembly function that allows partial retrieval of components

3. Add view function to query assembled component count before purchase

**Test Cases:**
- Test assembling with MaxAssembledItems (should succeed)
- Test assembling with MaxAssembledItems + 1 (should fail with assertion)
- Test disassembly gas costs at various collection sizes to validate limit
- Test that existing assemblies below limit continue to work

### Proof of Concept

**Initial State:**
1. Attacker has minted 5,000 low-value NFTs from a protocol they control
2. Attacker has sufficient balance to pay transaction fees

**Exploitation Steps:**

**Step 1:** Attacker calls `Assemble` with 5,000 NFTs:
```
AssembleInput {
    Symbol: "MALICIOUS-NFT",
    AssembledNfts: {
        "hash1": 1,
        "hash2": 1,
        ... (5,000 entries)
    },
    AssembledFts: {},
    Owner: victim_address
}
```
Transaction succeeds (under 15,000 branch limit), composite NFT created and sent to victim.

**Step 2:** Victim attempts to disassemble:
```
DisassembleInput {
    Symbol: "MALICIOUS-NFT",
    TokenId: composite_token_id
}
```

**Expected Result:** Transaction succeeds, all components returned to victim.

**Actual Result:** 
- Transaction technically succeeds (if under branch limit)
- BUT transaction fee is extremely high (5,000 iterations Ã— ~100-1000 gas units each)
- Cost may exceed victim's balance or any reasonable economic threshold
- Victim cannot afford to retrieve their locked assets
- Assets effectively locked permanently

**Success Condition:** Victim unable to economically execute disassembly transaction, confirming economic DOS and asset lockup.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L113-132)
```csharp
    public override Hash Assemble(AssembleInput input)
    {
        if (input.Metadata != null && input.Metadata.Value.Any())
            AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var metadata = input.Metadata ?? new Metadata();

        if (input.AssembledNfts.Value.Any())
        {
            metadata.Value[AssembledNftsKey] = input.AssembledNfts.ToString();
            // Check owner.
            foreach (var pair in input.AssembledNfts.Value)
            {
                var nftHash = Hash.LoadFromHex(pair.Key);
                var nftInfo = GetNFTInfoByTokenHash(nftHash);
                Assert(State.BalanceMap[nftHash][Context.Sender] >= pair.Value,
                    $"Insufficient balance of {nftInfo.Symbol}{nftInfo.TokenId}.");
                DoTransfer(nftHash, Context.Sender, Context.Self, pair.Value);
            }
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L176-178)
```csharp
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;

        if (input.AssembledFts.Value.Any()) State.AssembledFtsMap[nftMinted.TokenHash] = input.AssembledFts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L203-209)
```csharp
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L212-224)
```csharp
        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
        if (assembledFts != null)
        {
            var fts = assembledFts;
            foreach (var pair in fts.Value)
                State.TokenContract.Transfer.Send(new MultiToken.TransferInput
                {
                    Symbol = pair.Key,
                    Amount = pair.Value,
                    To = receiver
                });

            State.AssembledFtsMap.Remove(tokenHash);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-343)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol] ?? new MinterList();

        foreach (var minter in input.MinterList.Value)
            if (!minterList.Value.Contains(minter))
                minterList.Value.Add(minter);
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L32-33)
```csharp
    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-7)
```csharp
    public const int ExecutionCallThreshold = 15000;

    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L29-36)
```csharp
    public void BranchCount()
    {
        if (_branchThreshold != -1 && _branchCount == _branchThreshold)
            throw new RuntimeBranchThresholdExceededException(
                $"Contract branch threshold {_branchThreshold} exceeded.");

        _branchCount++;
    }
```

**File:** protobuf/nft_contract.proto (L354-360)
```text
message AssembledNfts {
    map<string, int64> value = 1;
}

message AssembledFts {
    map<string, int64> value = 1;
}
```
