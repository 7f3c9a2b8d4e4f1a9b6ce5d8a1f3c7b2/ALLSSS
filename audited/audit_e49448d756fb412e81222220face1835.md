### Title
Integer Overflow in Fee Calculation with Quadratic Terms When ExecutionCallThreshold Exceeds Safe Limits

### Summary
The fee calculation formulas for READ, WRITE, STORAGE, TRAFFIC, and TX resources use quadratic (x²) terms that overflow when resource consumption exceeds ~242,964 operations or ~30-43 million bytes. While default protections (ExecutionCallThreshold=15,000, transaction size limit=5MB) prevent overflow, the ExecutionCallThreshold is governance-configurable with no validation, and the coefficient definitions explicitly use int.MaxValue as upper bounds, creating a latent overflow vulnerability that results in incorrect (artificially low or negative) fees when triggered.

### Finding Description

The fee calculation coefficients define piecewise polynomial functions with upper bounds of int.MaxValue for the final intervals [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) .

The actual fee calculation performs: `(x^power * divisor / dividend) * Precision` where Precision = 100,000,000, then casts to long [6](#0-5) .

For READ/WRITE fees using the formula x² * 25/16 [7](#0-6) , overflow occurs when:
- x² * 25/16 * 100,000,000 > long.MaxValue
- x > ~242,964 operations

The piecewise calculation passes the count within each interval to the formula [8](#0-7) , meaning if totalCount is large enough, the count for the final piece can reach these overflow thresholds.

Resource consumption is measured as:
- READ/WRITE: `transactionContext.Trace.StateSet.Reads.Count` and `Writes.Count` [9](#0-8) [10](#0-9) 
- STORAGE/TRAFFIC/TX: `transactionContext.Transaction.Size()` [11](#0-10) 

Default protections:
- Transaction size is limited to 5MB [12](#0-11) , which is below the 30-43 million byte overflow threshold, protecting transaction size-based fees.
- ExecutionCallThreshold defaults to 15,000 [13](#0-12) , which limits method calls during execution and indirectly limits state operations, protecting operation count-based fees.

However, ExecutionCallThreshold is governance-configurable via the Configuration contract [14](#0-13)  with no validation on the values [15](#0-14) . The ExecutionObserver explicitly supports -1 for unlimited execution [16](#0-15) .

The project does not have CheckForOverflowUnderflow enabled [17](#0-16) , meaning overflow wraps around silently in unchecked context, producing incorrect (likely negative or very small) fee values.

### Impact Explanation

When ExecutionCallThreshold is set to ≥242,964 or -1 (unlimited), transactions with sufficient state read/write operations will trigger integer overflow in fee calculation, resulting in:

1. **Broken Fee Economics**: Users pay far less than intended for resource-intensive operations. For example, a transaction with 250,000 state reads should cost proportional to 250,000² * 25/16 ≈ 976 billion (before precision), but overflow causes it to wrap to a negative or minimal value.

2. **Resource Token Inflation/Deflation**: READ and WRITE tokens are charged based on these calculations. Incorrect fees break the intended token economics and resource pricing model.

3. **Denial of Service Vector**: Attackers can perform extremely resource-intensive operations (massive state reads/writes) at artificially low cost, potentially exhausting node resources while paying minimal fees.

4. **System Integrity**: The coefficient definitions explicitly use int.MaxValue as "infinity" bounds, indicating the system was designed to handle large resource consumption, but the implementation cannot safely process values in that range.

The vulnerability affects all users and the entire blockchain's resource fee system once triggered by governance configuration.

### Likelihood Explanation

**Preconditions:**
1. Governance must change ExecutionCallThreshold to ≥242,964 or -1 via Parliament proposal and execution
2. A transaction must perform that many state operations (or governance sets -1 allowing unlimited operations)

**Feasibility:**
- Governance has legitimate reasons to adjust execution limits (performance testing, removing restrictions for specific use cases, benchmarking)
- Setting to -1 (unlimited) is explicitly supported in the code, suggesting it was intended as a valid configuration
- No warning or validation exists to prevent setting unsafe values
- The coefficient definitions using int.MaxValue upper bounds suggest large values were anticipated by the system designers
- Once configured, any normal transaction with sufficient complexity triggers the bug

**Attack Complexity:** Medium
- Requires governance proposal, approval, and execution
- Not a direct attack, but a configuration error or legitimate administrative action that exposes a latent math bug
- Governance may not realize the fee calculation limitation when adjusting execution limits

**Detection:** Difficult
- Silent overflow (unchecked context) produces no errors
- Fees appear to be calculated normally, just with incorrect values
- Would likely be discovered only after noticing unexpectedly low fees for complex transactions

This is a **design flaw** where the system's configuration capabilities exceed its mathematical implementation limits, creating a latent vulnerability waiting to be triggered by reasonable governance actions.

### Recommendation

1. **Add overflow protection** in the fee calculation:
```
In GetUnitExponentialCalculation (CalculateFeeCoefficientsExtensions.cs line 48):
    - Add checked context for the cast: return checked((long)(decimalResult * Precision));
    - This will throw OverflowException instead of silently wrapping
```

2. **Add validation** when setting ExecutionCallThreshold:
```
In ExecutionObserverThresholdConfigurationProcessor.ProcessConfigurationAsync:
    - Validate that ExecutionCallThreshold (if not -1) is <= safe limit (~240,000 for fee calculation)
    - Reject configuration changes that would enable overflow
```

3. **Reconsider coefficient bounds**: If int.MaxValue upper bounds are not realistic, replace with validated maximum values that the fee calculation can handle safely (e.g., 200,000 for operation-based fees).

4. **Add test cases**:
    - Test fee calculation with count values approaching overflow thresholds
    - Verify exception thrown or safe handling when limits exceeded
    - Test governance configuration validation

5. **Document the limitation**: Clearly document in ExecutionCallThreshold configuration that values >240,000 may cause fee calculation overflow.

### Proof of Concept

**Initial State:**
- System initialized with default ExecutionCallThreshold = 15,000
- Fee coefficients initialized with standard values

**Attack Sequence:**

1. **Governance Configuration Change:**
   - Parliament creates proposal to set ExecutionCallThreshold to 500,000 (for "performance testing")
   - Proposal approved and executed via ConfigurationContract.SetConfiguration
   - ExecutionObserverThreshold updated with new limit

2. **Trigger Transaction:**
   - Contract execution performs 250,000 state read operations (e.g., iterating over large mapped state)
   - READ fee calculation invoked with count = 250,000

3. **Overflow Occurs:**
   - Formula calculates: 250,000² * 25/16 * 100,000,000
   - Result: 976,562,500,000,000,000 (exceeds long.MaxValue of 9,223,372,036,854,775,807)
   - Unchecked cast wraps to negative or incorrect value
   - User charged incorrect (very low) READ token fee

**Expected Result:** Transaction charged proportional fee for 250,000 operations

**Actual Result:** Transaction charged minimal or negative fee due to overflow, breaking fee economics

**Success Condition:** Fee charged is orders of magnitude less than mathematically correct value, or negative value causes fee deduction to fail/behave incorrectly.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L163-163)
```csharp
                        int.MaxValue,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L164-165)
```csharp
                        2, 25, 16,
                        1, 1, 4
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L194-194)
```csharp
                        int.MaxValue,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L234-234)
```csharp
                        int.MaxValue,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L265-265)
```csharp
                        int.MaxValue,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L305-305)
```csharp
                        int.MaxValue,
```

**File:** src/AElf.Kernel.FeeCalculation/Extensions/CalculateFeeCoefficientsExtensions.cs (L64-68)
```csharp
            var powerResult = (decimal)Math.Pow(count, power);
            decimalResult = powerResult * divisor / dividend;
        }

        return (long)(decimalResult * Precision);
```

**File:** src/AElf.Kernel.FeeCalculation/Infrastructure/CalculateFunction.cs (L48-51)
```csharp
            var interval = pieceUpperBound - pieceStart;
            pieceStart = pieceUpperBound;
            var count = Math.Min(interval, remainCount);
            result += function(count);
```

**File:** src/AElf.Kernel.FeeCalculation/Infrastructure/ReadFeeProvider.cs (L17-17)
```csharp
        return transactionContext.Trace.StateSet.Reads.Count;
```

**File:** src/AElf.Kernel.FeeCalculation/Infrastructure/WriteFeeProvider.cs (L17-17)
```csharp
        return transactionContext.Trace.StateSet.Writes.Count;
```

**File:** src/AElf.Kernel.FeeCalculation/Infrastructure/StorageFeeProvider.cs (L17-17)
```csharp
        return transactionContext.Transaction.Size();
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L5-5)
```csharp
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-5)
```csharp
    public const int ExecutionCallThreshold = 15000;
```

**File:** src/AElf.Kernel.SmartContractExecution/ExecutionObserverThresholdConfigurationProcessor.cs (L19-27)
```csharp
    public string ConfigurationName => "ExecutionObserverThreshold";

    public async Task ProcessConfigurationAsync(ByteString byteString, BlockIndex blockIndex)
    {
        var executionObserverBranchThreshold = new ExecutionObserverThreshold();
        executionObserverBranchThreshold.MergeFrom(byteString);
        await _executionObserverThresholdProvider.SetExecutionObserverThresholdAsync(blockIndex,
            executionObserverBranchThreshold);
    }
```

**File:** src/AElf.Kernel.SmartContract/IExecutionObserverThreshold.cs (L11-12)
```csharp
    public int ExecutionCallThreshold { get; set; }
    public int ExecutionBranchThreshold { get; set; }
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L23-23)
```csharp
        if (_callThreshold != -1 && _callCount == _callThreshold)
```

**File:** src/AElf.Kernel.FeeCalculation/AElf.Kernel.FeeCalculation.csproj (L1-23)
```text
﻿<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <LangVersion>latest</LangVersion>
        <PackageId>AElf.Kernel.FeeCalculation</PackageId>
        <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
        <Description>Fee Calculation Project.</Description>
    </PropertyGroup>
    <ItemGroup>
        <ProjectReference Include="..\AElf.Kernel.SmartContract\AElf.Kernel.SmartContract.csproj" />
        <ProjectReference Include="..\AElf.Kernel.Token\AElf.Kernel.Token.csproj" />
    </ItemGroup>
    <ItemGroup>
        <ContractBase Include="..\..\protobuf\token_contract.proto">
            <Link>Protobuf\Proto\token_contract.proto</Link>
        </ContractBase>
        <ContractBase Include="..\..\protobuf\transaction_fee.proto">
            <Link>Protobuf\Proto\transaction_fee.proto</Link>
        </ContractBase>
    </ItemGroup>

</Project>
```
