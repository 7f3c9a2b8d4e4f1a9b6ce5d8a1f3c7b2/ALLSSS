### Title
Side Chain Miners Can Miss Time Slots Without Consequences Due to Bypassed Evil Miner Detection

### Summary
The `ProcessNextRound()` function in the AEDPoS consensus contract skips evil miner detection on side chains by checking `State.IsMainChain.Value` before executing detection logic. This allows miners to selectively miss time slots on side chains while behaving normally on the main chain, avoiding punishment and remaining in the miner rotation indefinitely. Side chains have no independent mechanism to detect, punish, or report such malicious behavior.

### Finding Description

The vulnerability exists in the `ProcessNextRound()` method where evil miner detection is conditionally executed: [1](#0-0) 

The detection logic uses `TryToDetectEvilMiners()` to identify miners whose `MissedTimeSlots` count exceeds the tolerance threshold of 4320 (3 days): [2](#0-1) [3](#0-2) 

On the main chain, detected evil miners are marked in the Election contract and banned: [4](#0-3) 

However, side chains receive their miner list from the main chain through cross-chain synchronization, not from independent elections: [5](#0-4) 

**Root Cause**: Side chains track `MissedTimeSlots` counters but never check them or take action. The `GenerateNextRoundInformation()` method only performs miner replacement on the main chain: [6](#0-5) 

The `UpdateCandidateInformation()` helper also returns early for side chains: [7](#0-6) 

**Why Protections Fail**: Side chains have no mechanism to report miner behavior to the main chain. The synchronization is one-directional (main chain â†’ side chain). A miner banned on the main chain will eventually be removed from side chains, but a miner who misbehaves only on side chains faces no consequences.

### Impact Explanation

**Operational Impact - DoS of Side Chain Consensus**:
- Malicious miners can intentionally miss their assigned time slots on side chains
- Each missed slot causes delays as other miners wait for the time slot to expire
- With multiple colluding miners or a single miner missing many consecutive slots, side chain block production can be severely degraded
- Side chain availability and reliability are compromised

**Reward Misallocation**:
- Malicious miners continue to receive resource token distributions intended for active miners: [8](#0-7) 

- They benefit from being in the miner list without fulfilling their responsibilities

**Consensus Integrity Violation**:
- The miner schedule integrity invariant is violated on side chains
- The system cannot guarantee that assigned time slots will be fulfilled
- Side chains become vulnerable to selective availability attacks

**Affected Parties**:
- Side chain users experience degraded service
- Honest miners on side chains must compensate for malicious miners
- Applications built on side chains face reliability issues

### Likelihood Explanation

**Attacker Capabilities**: 
- Attacker must be an existing miner in the miner list (shared between main chain and side chains)
- No special privileges beyond normal miner status required
- No stake or economic cost to execute the attack

**Attack Complexity**: 
- Extremely low - attacker simply needs to not produce blocks on target side chain(s)
- Simultaneously continue normal block production on main chain to avoid main chain detection
- No sophisticated attack infrastructure needed

**Feasibility Conditions**:
- Main chain miner list is synchronized to side chains by design
- No reporting mechanism exists from side chains to main chain
- Side chains cannot independently ban or replace miners

**Detection Constraints**:
- Main chain monitoring shows miner behaving normally (producing blocks)
- Side chain tracks `MissedTimeSlots` but takes no action (line 139 check prevents it)
- No alerts or events fired on side chains for excessive missed slots
- Cross-chain observers would need to manually analyze side chain behavior

**Probability**: HIGH
- Attack is trivial to execute for any miner
- Economically rational (no cost, continue receiving rewards)
- No technical barriers to exploitation
- Detection and response mechanisms are absent

### Recommendation

**Code-Level Mitigation**:

1. **Enable side chain-local evil miner tracking**: Modify `ProcessNextRound()` to detect evil miners on side chains and store them in side chain-specific state (not the main chain Election contract which doesn't exist on side chains):

```csharp
if (currentRound.TryToDetectEvilMiners(out var evilMiners))
{
    Context.LogDebug(() => "Evil miners detected.");
    foreach (var evilMiner in evilMiners)
    {
        // On side chains, track locally instead of updating Election contract
        if (!State.IsMainChain.Value)
        {
            State.SideChainBannedMiners[evilMiner] = true;
            Context.Fire(new EvilMinerDetected { Pubkey = evilMiner });
        }
        else
        {
            State.ElectionContract.UpdateCandidateInformation.Send(
                new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
        }
    }
}
```

2. **Implement side chain miner replacement**: In `GenerateNextRoundInformation()`, allow side chains to replace locally-detected evil miners with alternatives from the main chain miner list.

3. **Report side chain violations**: Implement a cross-chain reporting mechanism where side chains can submit evidence of miner misbehavior to the main chain for governance review.

**Invariant Checks to Add**:
- Side chains must enforce miner accountability for missed time slots
- Miners exceeding `TolerableMissedTimeSlotsCount` on any chain should face consequences
- Miner reputation should be tracked separately per chain but aggregated for main chain decisions

**Test Cases**:
- Test miner missing slots on side chain but not main chain
- Verify side chain can detect and respond to evil miner behavior
- Test cross-chain reporting of miner violations
- Verify that banned miners are removed from side chain rotation

### Proof of Concept

**Required Initial State**:
- Deployed side chain with active consensus
- Attacker is a valid miner in the shared miner list
- Side chain is receiving miner list updates from main chain

**Attack Steps**:

1. **Attacker becomes a miner**: Through the normal election process on the main chain, attacker becomes part of the miner list.

2. **Normal behavior on main chain**: Attacker produces blocks correctly on the main chain during their assigned time slots.
   - `MissedTimeSlots` on main chain remains low
   - No evil miner detection triggered on main chain

3. **Malicious behavior on side chain**: When assigned time slots on the side chain, attacker intentionally does not produce blocks.
   - `CountMissedTimeSlots()` increments the counter in `ProcessNextTerm()`
   - Counter exceeds 4320 (3 days worth of missed slots)

4. **Side chain processes next round**: `ProcessNextRound()` is called on the side chain.
   - Line 139 check evaluates to false (`State.IsMainChain.Value == false`)
   - `TryToDetectEvilMiners()` is never called
   - No evil miner detection occurs
   - No banning or replacement happens

5. **Main chain updates miner list**: Main chain continues normal term transitions.
   - Attacker's good main chain behavior means they're not detected as evil
   - `GetMinerReplacementInformation()` on main chain doesn't identify them as evil
   - Attacker remains in the miner list sent to side chains

6. **Side chain syncs miner list**: Side chain receives updated miner list from main chain.
   - `UpdateInformationFromCrossChain()` updates `State.MainChainCurrentMinerList.Value`
   - Attacker is still included in the miner list
   - Attacker continues to receive resource token distributions

**Expected vs Actual Result**:
- **Expected**: Miner missing 4320+ time slots should be detected as evil, banned, and replaced
- **Actual**: Miner continues in rotation indefinitely, receiving rewards despite not fulfilling duties on side chain

**Success Condition**: 
Attacker's `MissedTimeSlots` counter on side chain exceeds 4320, yet they remain in the side chain miner list and continue receiving resource token distributions without any punishment or replacement action taken.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-64)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L66-96)
```csharp
    private void DistributeResourceTokensToPreviousMiners()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
        foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
            var amount = balance.Div(minerList.Count);
            Context.LogDebug(() => $"Consensus Contract {symbol} balance: {balance}. Every miner can get {amount}");
            if (amount <= 0) continue;
            foreach (var pubkey in minerList)
            {
                var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
                Context.LogDebug(() => $"Will send {amount} {symbol}s to {pubkey}");
                State.TokenContract.Transfer.Send(new TransferInput
                {
                    To = address,
                    Amount = amount,
                    Symbol = symbol
                });
            }
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L285-347)
```csharp
    private void GenerateNextRoundInformation(Round currentRound, Timestamp currentBlockTime, out Round nextRound)
    {
        TryToGetPreviousRoundInformation(out var previousRound);
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();
        var isMinerListChanged = false;
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
        }

        currentRound.GenerateNextRoundInformation(currentBlockTime, blockchainStartTimestamp, out nextRound,
            isMinerListChanged);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L367-379)
```csharp
    private void UpdateCandidateInformation(string candidatePublicKey, long recentlyProducedBlocks,
        long recentlyMissedTimeSlots, bool isEvilNode = false)
    {
        if (!State.IsMainChain.Value) return;

        State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
        {
            Pubkey = candidatePublicKey,
            RecentlyProducedBlocks = recentlyProducedBlocks,
            RecentlyMissedTimeSlots = recentlyMissedTimeSlots,
            IsEvilNode = isEvilNode
        });
    }
```
