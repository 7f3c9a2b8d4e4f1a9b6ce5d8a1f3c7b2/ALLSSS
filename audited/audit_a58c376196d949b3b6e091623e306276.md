### Title
Cross-Chain Token Registration Bypasses Collection Symbol Namespace Reservation Leading to Token Creation DoS

### Summary
The `CheckTokenAndCollectionExists` function reserves the "{PREFIX}-0" collection symbol namespace when creating token "{PREFIX}", preventing collisions between regular tokens and NFT collections. However, `CrossChainCreateToken` bypasses this validation, allowing malicious cross-chain registration of tokens with "-0" suffix. This creates namespace pollution that permanently blocks legitimate token and NFT collection creation on the victim chain.

### Finding Description

**Root Cause:**

When creating a regular token through the normal `Create` method, `CheckTokenAndCollectionExists` validates and reserves both the token symbol and its corresponding collection symbol (by appending "-0"). [1](#0-0) 

The collection suffix is defined as "0": [2](#0-1) 

For example, creating token "ABC" checks that both "ABC" and "ABC-0" don't exist, reserving "ABC-0" for the future NFT collection.

**Why Protection Fails:**

The normal token creation path properly enforces this validation: [3](#0-2) [4](#0-3) 

However, the cross-chain token registration path (`CrossChainCreateToken`) completely bypasses this protection: [5](#0-4) 

The `AssertNftCollectionExist` call at line 491 only validates that NFT items have their parent collection; it returns null for regular tokens and collection symbols without performing the namespace reservation check: [6](#0-5) 

After verifying the cross-chain proof, the code directly calls `RegisterTokenInfo` (line 508) without calling `CheckTokenAndCollectionExists` or `CheckTokenExists`, allowing arbitrary symbols including "{PREFIX}-0" patterns.

### Impact Explanation

**Namespace Pollution DoS:**

An attacker can systematically block creation of any desired token on the victim chain by pre-registering "{PREFIX}-0" tokens via cross-chain. When legitimate users attempt to create token "{PREFIX}", the validation fails because "PREFIX-0" already exists: [7](#0-6) [8](#0-7) 

**Specific Impacts:**

1. **Token Creation DoS**: Legitimate users cannot create valuable/desired token symbols if the attacker pre-registers "{SYMBOL}-0" 
2. **NFT System Disruption**: NFT collections require the "-0" suffix. If tokens with "-0" exist from cross-chain, the entire NFT collection system for that prefix is blocked
3. **Namespace Squatting**: Attacker can preemptively occupy the namespace of anticipated high-value tokens
4. **Protocol Reputation**: Users experience unexplained failures when trying to create tokens with valid symbols

**Who is Affected:**
- All users on chains with cross-chain connectivity
- NFT collection creators whose prefix is blocked
- Projects planning to launch tokens with specific branding

### Likelihood Explanation

**Attacker Capabilities Required:**

1. Control or compromise a chain that is registered for cross-chain token transfer with the victim chain, OR
2. Exploit a chain with weaker validation rules that allows creating tokens with "-0" suffix

**Attack Complexity:**

The attack is straightforward:
1. Create token with symbol "{TARGET}-0" on controlled/compromised Chain A
2. Use the existing `CrossChainCreateToken` method to register it on victim Chain B
3. Cross-chain verification passes because it's a legitimate cross-chain transfer
4. Token "{TARGET}-0" is now registered on Chain B without namespace validation

**Feasibility Conditions:**

- Cross-chain must be enabled (common in production)
- Attacker needs one registered token contract on any connected chain
- No special privileges required beyond normal token creation on the source chain
- The cross-chain registration system is designed to be used, making this a normal operation

**Economic Rationality:**

- Cost: Minimal - just token creation fees on source chain + cross-chain transfer fees
- Benefit: High - can block valuable token symbols and potentially extort legitimate projects
- Detection: Difficult - appears as legitimate cross-chain token registration until collision occurs

### Recommendation

**Immediate Fix:**

Add namespace validation to `CrossChainCreateToken` before registering tokens. The validation should check if the symbol ends with "-0" and verify that the base prefix doesn't exist:

```csharp
// In CrossChainCreateToken, before line 508 RegisterTokenInfo:
// Validate namespace reservation for symbols ending in "-0"
var symbolParts = validateTokenInfoExistsInput.Symbol.Split(TokenContractConstants.NFTSymbolSeparator);
if (symbolParts.Length == 2 && symbolParts[1] == TokenContractConstants.CollectionSymbolSuffix)
{
    // This is a collection symbol, ensure base token doesn't exist
    CheckTokenExists(symbolParts[0]);
}
CheckTokenExists(validateTokenInfoExistsInput.Symbol);
```

**Additional Hardening:**

1. Apply the same validation logic in `RegisterTokenInfo` to centralize protection
2. Add a whitelist of verified cross-chain sources with stronger validation
3. Implement a governance review period for cross-chain tokens with "-0" suffix
4. Add monitoring/alerts for cross-chain registrations that could cause namespace conflicts

**Test Cases:**

1. Attempt cross-chain registration of "TEST-0" when "TEST" exists - should fail
2. Attempt cross-chain registration of "TEST-0" before local creation of "TEST" - should fail or require governance approval
3. Verify legitimate NFT collections can still be created after fix
4. Test with various symbol formats to ensure no bypass

### Proof of Concept

**Initial State:**
- Chain A (attacker controlled) and Chain B (victim) are connected via cross-chain
- Chain A's token contract is registered in Chain B's `CrossChainTransferWhiteList`
- Token "PREMIUM" does not exist on Chain B

**Attack Sequence:**

1. **On Chain A:** Attacker creates token with symbol "PREMIUM-0"
   - Chain A may have different validation rules or attacker controls the chain
   - Token "PREMIUM-0" is successfully created

2. **Cross-Chain Transfer:** Attacker calls `CrossChainCreateToken` on Chain B with:
   - Merkle proof of token "PREMIUM-0" creation on Chain A
   - Valid cross-chain verification data

3. **On Chain B:** `CrossChainCreateToken` executes:
   - Line 491: `AssertNftCollectionExist("PREMIUM-0")` returns null (no check performed)
   - Line 506: `State.TokenInfos["PREMIUM-0"]` is null (doesn't exist yet)
   - Line 508: `RegisterTokenInfo` directly registers "PREMIUM-0" 
   - **Result:** Token "PREMIUM-0" now exists on Chain B

4. **Victim Impact:** Legitimate user on Chain B tries to create token "PREMIUM":
   - `Create("PREMIUM")` is called
   - Line 281: `CheckTokenAndCollectionExists("PREMIUM")` is invoked
   - Line 289: Checks "PREMIUM" doesn't exist âœ“
   - Line 290-291: Constructs collectionSymbol = "PREMIUM-0"
   - Line 292: `CheckTokenExists("PREMIUM-0")` is called
   - Line 300: `GetTokenInfo("PREMIUM-0")` returns the cross-chain registered token
   - Line 300: Assertion fails: "Token already exists"
   - **Result:** Token "PREMIUM" cannot be created

**Expected vs Actual:**
- **Expected:** Cross-chain should respect namespace reservation rules
- **Actual:** Cross-chain bypasses validation, allowing namespace pollution

**Success Condition:**
Token "PREMIUM" creation permanently blocked on Chain B due to malicious "PREMIUM-0" registration from Chain A.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L285-293)
```csharp
    private void CheckTokenAndCollectionExists(string symbol)
    {
        var symbols = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        var tokenSymbol = symbols.First();
        CheckTokenExists(tokenSymbol);
        var collectionSymbol = symbols.First() + TokenContractConstants.NFTSymbolSeparator +
                               TokenContractConstants.CollectionSymbolSuffix;
        CheckTokenExists(collectionSymbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L22-22)
```csharp
    public const string CollectionSymbolSuffix = "0";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L48-50)
```csharp
    private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
    {
        AssertValidCreateInput(input, symbolType);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-508)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L163-170)
```csharp
    private TokenInfo AssertNftCollectionExist(string symbol)
    {
        var collectionSymbol = GetNftCollectionSymbol(symbol);
        if (collectionSymbol == null) return null;
        var collectionInfo = GetTokenInfo(collectionSymbol);
        Assert(collectionInfo != null, "NFT collection not exist");
        return collectionInfo;
    }
```
