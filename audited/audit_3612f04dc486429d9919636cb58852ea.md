### Title
Global Per-Block Execution Lock Creates Denial of Service for Consensus and Cross-Chain Operations

### Summary
The `EnsureTransactionOnlyExecutedOnceInOneBlock()` helper function enforces a global lock that allows only ONE transaction to execute per block across ALL methods that use it, rather than implementing per-method limits. This affects four critical consensus operations in AEDPoS (UpdateValue, UpdateTinyBlockInformation, NextRound, NextTerm) and two cross-chain operations (ProposeCrossChainIndexing, ReleaseCrossChainIndexingProposal), creating severe denial of service risks that can delay consensus progression and cross-chain communication.

### Finding Description

The root cause is the implementation of `EnsureTransactionOnlyExecutedOnceInOneBlock()` which uses a single global state variable: [1](#0-0) [2](#0-1) 

This helper is called by the shared `ProcessConsensusInformation()` method: [3](#0-2) 

Which is invoked by four different public consensus methods: [4](#0-3) [5](#0-4) [6](#0-5) [7](#0-6) 

The same vulnerability exists in the CrossChain contract with its own global state variable: [8](#0-7) [9](#0-8) 

Used by two cross-chain methods: [10](#0-9) [11](#0-10) 

The protection fails because it uses a single `long` state variable (`LatestExecutedHeight`) rather than a mapping that tracks execution per method. When the first method executes in a block, it sets `State.LatestExecutedHeight.Value = Context.CurrentHeight`, blocking ALL subsequent methods from executing in the same block regardless of which specific operation they perform.

### Impact Explanation

**Consensus DOS**: In the AEDPoS contract, only ONE of the four critical consensus operations can execute per block:
- `UpdateValue` - normal block production mining information updates
- `UpdateTinyBlockInformation` - tiny block production updates
- `NextRound` - critical round transitions needed for consensus progression
- `NextTerm` - critical term transitions for miner list updates and reward distribution

If a miner submits an `UpdateValue` or `UpdateTinyBlockInformation` transaction early in a block, it prevents `NextRound` or `NextTerm` from executing in the same block, delaying consensus progression by at least one block. Given that these operations serve different purposes and should be independent, this creates an artificial bottleneck.

**Cross-Chain DOS**: Only ONE of `ProposeCrossChainIndexing` or `ReleaseCrossChainIndexingProposal` can execute per block, delaying cross-chain communication and merkle path verification by at least one block per conflict.

**Race Conditions**: Even without malicious intent, if two honest miners legitimately submit different consensus operations (e.g., one submits NextRound while another submits UpdateValue), one transaction will fail unpredictably. This creates operational instability and potential consensus confusion.

The severity is Critical because it affects core protocol operations: consensus round/term progression, block production tracking, and cross-chain indexing. While the impact is limited to delaying operations by one block rather than permanent DOS, the frequency of occurrence (every time multiple consensus operations are needed in the same block) and the criticality of affected operations justify this rating.

### Likelihood Explanation

**Attacker Capabilities**: Only current miners can call these methods, as verified by permission checks: [12](#0-11) [13](#0-12) [14](#0-13) 

However, miners are the exact parties that need to execute these operations, making this a realistic attack surface.

**Attack Complexity**: Minimal - a miner simply needs to submit a consensus transaction early in their produced block to block other operations. No complex setup or state manipulation required.

**Feasibility**: High - this will occur naturally during normal operations when:
- A block producer needs to update their mining info AND the round needs to transition
- Cross-chain indexing proposals need to be proposed AND released in the same block
- Multiple miners submit different consensus operations simultaneously

**Detection**: The victim will see their transaction fail with "Cannot execute this tx." error, but this provides no actionable information about which other transaction blocked them.

**Probability**: High - given that consensus operations occur frequently and serve different purposes, conflicts will occur regularly in normal protocol operation, not just during intentional attacks.

### Recommendation

**Option 1 - Per-Method Tracking** (Recommended):
Replace the global `SingletonState<long> LatestExecutedHeight` with a method-specific mapping:
```
MappedState<string, long> LatestExecutedHeightPerMethod
```

Modify the helper to track per calling method:
```csharp
private void EnsureTransactionOnlyExecutedOnceInOneBlock([CallerMemberName] string callerMethodName = null)
{
    Assert(State.LatestExecutedHeightPerMethod[callerMethodName] != Context.CurrentHeight, 
           "Cannot execute this tx.");
    State.LatestExecutedHeightPerMethod[callerMethodName] = Context.CurrentHeight;
}
```

**Option 2 - Remove Restriction** (If Not Needed):
If the restriction is not necessary for each individual method, remove the call to `EnsureTransactionOnlyExecutedOnceInOneBlock()` from methods where multiple executions per block are safe.

**Option 3 - Explicit Global Intent**:
If the global restriction is intentional (to ensure only one consensus operation total per block), document this clearly and implement proper transaction ordering/priority mechanisms to avoid race conditions.

**Test Cases**:
- Verify multiple different consensus operations can execute in the same block
- Test that the same operation still cannot execute twice per block
- Verify cross-chain operations don't block each other unnecessarily

### Proof of Concept

**Initial State**:
- Block height: N
- Current miner: MinerA
- Round needs to transition (NextRound should be called)
- MinerA needs to update their value (UpdateValue should be called)

**Transaction Sequence**:

1. **Block N - Transaction 1**: MinerA calls `UpdateValue(input1)`
   - `ProcessConsensusInformation()` is invoked
   - `EnsureTransactionOnlyExecutedOnceInOneBlock()` checks: `State.LatestExecutedHeight.Value (0 or N-1) != Context.CurrentHeight (N)` ✓ Passes
   - Sets `State.LatestExecutedHeight.Value = N`
   - UpdateValue executes successfully

2. **Block N - Transaction 2**: MinerB calls `NextRound(input2)` in the same block
   - `ProcessConsensusInformation()` is invoked  
   - `EnsureTransactionOnlyExecutedOnceInOneBlock()` checks: `State.LatestExecutedHeight.Value (N) != Context.CurrentHeight (N)` ✗ Fails
   - **Assert fails with "Cannot execute this tx."**
   - NextRound is blocked from executing

**Expected Result**: Both UpdateValue and NextRound should succeed as they are different operations serving different purposes.

**Actual Result**: Only UpdateValue succeeds. NextRound is denied, delaying the round transition to block N+1 minimum.

**Success Condition for Attack**: The first consensus transaction in a block successfully blocks all other consensus transactions, regardless of their type or importance, creating a denial of service for critical consensus operations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L55-55)
```csharp
    public SingletonState<long> LatestExecutedHeight { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L21-23)
```csharp
    private void ProcessConsensusInformation(dynamic input, [CallerMemberName] string callerMethodName = null)
    {
        EnsureTransactionOnlyExecutedOnceInOneBlock();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L27-28)
```csharp
        /* Privilege check. */
        if (!PreCheck()) Assert(false, "No permission.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-101)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L108-112)
```csharp
    public override Empty UpdateTinyBlockInformation(TinyBlockInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-165)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-17)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L895-899)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContractState.cs (L28-28)
```csharp
    public SingletonState<long> LatestExecutedHeight { get; set; }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-286)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-296)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L297-297)
```csharp
        AssertAddressIsCurrentMiner(Context.Sender);
```
