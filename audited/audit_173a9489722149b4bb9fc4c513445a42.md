### Title
Self-Referential Method Fee Setting Enables Governance Lockout

### Summary
The `SetMethodFee` function lacks validation to prevent setting transaction fees for itself, allowing governance to configure a fee that must be paid to change any method fees. If the fee is set too high and the Parliament organization's virtual address lacks sufficient funds, governance becomes permanently locked out of all method fee management across the system.

### Finding Description
The `SetMethodFee` method in the Genesis contract does not validate whether `input.MethodName` refers to itself. [1](#0-0) 

When Parliament executes a proposal to call `SetMethodFee`, the transaction is sent from the organization's virtual address via `SendVirtualInlineBySystemContract`. [2](#0-1) 

Before any transaction executes, the pre-execution plugin generates a `ChargeTransactionFees` transaction that charges fees from `Context.Sender`. [3](#0-2) 

The fee is retrieved via `GetMethodFee` which returns whatever was stored in `State.TransactionFees[input.MethodName]`, with no special exemption for `SetMethodFee`. [4](#0-3) 

If fee charging fails due to insufficient balance, the main transaction is blocked. [5](#0-4) 

### Impact Explanation
Once a prohibitively high fee is set for `SetMethodFee`, all future method fee changes require paying that fee from the Parliament organization's virtual address. Since `SetMethodFee` is the only way to modify method fees for any contract method (including reducing its own fee), and `ChangeMethodFeeController` also requires the same authorization, governance becomes locked out if the organization cannot afford the fee.

This affects the entire system's fee management capability across all contracts. The organization must possess tokens equal to the configured fee amount to recover. If the fee is set extremely high (e.g., millions of ELF), recovery becomes economically infeasible, resulting in permanent loss of fee governance.

Tests confirm organizations must pre-fund their virtual addresses before releasing proposals. [6](#0-5) 

### Likelihood Explanation
This scenario requires Parliament governance approval, making it moderately likely rather than arbitrary. It could occur through:
1. Accidental misconfiguration during fee updates (human error setting wrong decimal places)
2. Malicious proposal if an attacker gains sufficient voting power
3. Lack of validation or warnings during proposal creation

The attack is practical as it requires only one successful governance proposal with `input.MethodName = "SetMethodFee"` and a high fee value. No complex exploitation or timing requirements exist. The precondition (governance approval) is realistic as Parliament votes on numerous fee adjustments during normal operations.

### Recommendation
Add validation in `SetMethodFee` to prevent self-referential fee setting:

```csharp
public override Empty SetMethodFee(MethodFees input)
{
    Assert(input.MethodName != nameof(SetMethodFee) && 
           input.MethodName != nameof(ChangeMethodFeeController),
           "Cannot set fees for method fee management functions.");
    
    foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
    RequiredMethodFeeControllerSet();
    Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
    State.TransactionFees[input.MethodName] = input;
    return new Empty();
}
```

Alternatively, mark `SetMethodFee` and `ChangeMethodFeeController` as permanently fee-free in `GetMethodFee`, similar to how `ReleaseApprovedUserSmartContract` is handled. [7](#0-6) 

Add test cases verifying that attempts to set fees for these methods are rejected.

### Proof of Concept
**Initial State:**
- Parliament default organization controls method fee management
- Organization virtual address has 100 ELF balance

**Exploitation Steps:**
1. Create Parliament proposal: `SetMethodFee({MethodName: "SetMethodFee", Fees: [{Symbol: "ELF", BasicFee: 1000000}]})`
2. Get miner approval and release proposal
3. `SetMethodFee` now requires 1,000,000 ELF fee to execute

**Lockout Demonstration:**
4. Create proposal to reduce fee: `SetMethodFee({MethodName: "SetMethodFee", Fees: [{Symbol: "ELF", BasicFee: 1}]})`
5. Get approval and attempt release
6. `ChargeTransactionFees` attempts to charge 1,000,000 ELF from organization (has only 100 ELF)
7. Charging fails, transaction blocked, cannot execute
8. Organization cannot change ANY method fees (all require calling `SetMethodFee`)

**Expected:** Fee setting should be rejected or methods should be fee-exempt
**Actual:** Lockout occurs, requiring 1,000,000 ELF transfer to organization to recover

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L9-18)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L34-47)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        var fees = State.TransactionFees[input.Value];
        if (fees == null && input.Value == nameof(ReleaseApprovedUserSmartContract))
        {
            fees = new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
        }

        return fees;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L138-140)
```csharp
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-52)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }

        // Record tx fee bill during current charging process.
        var bill = new TransactionFeeBill();
        var allowanceBill = new TransactionFreeFeeAllowanceBill();
        var fromAddress = Context.Sender;
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L123-129)
```csharp
    public bool IsStopExecuting(ByteString txReturnValue, out string preExecutionInformation)
    {
        var chargeTransactionFeesOutput = new ChargeTransactionFeesOutput();
        chargeTransactionFeesOutput.MergeFrom(txReturnValue);
        preExecutionInformation = chargeTransactionFeesOutput.ChargingInformation;
        return !chargeTransactionFeesOutput.Success;
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L728-728)
```csharp
        await TransferToOrganizationAddressAsync(organizationAddress);
```
