# Audit Report

## Title
Dictionary Key-Pubkey Mismatch Enables Consensus DoS via Corrupted Round Structure

## Summary
The AEDPoS consensus contract lacks validation to ensure that dictionary keys in `RealTimeMinersInformation` match their corresponding `MinerInRound.Pubkey` values. A malicious miner can exploit this by submitting `NextRoundInput` with mismatched key-Pubkey mappings, corrupting the round structure and preventing legitimate miners from producing blocks, resulting in consensus denial of service.

## Finding Description

The vulnerability exists because the consensus contract fails to validate a critical invariant: dictionary keys in `RealTimeMinersInformation` must equal their corresponding `MinerInRound.Pubkey` values.

**Vulnerable Code Paths:**

The `GetUpdateValueRound()` function propagates existing key-Pubkey mismatches without validation. When iterating through `RealTimeMinersInformation`, it uses `information.Key` as the dictionary key while setting `Pubkey = information.Value.Pubkey`, which may differ: [1](#0-0) 

The `ToRound()` conversion method blindly copies the dictionary structure without any validation: [2](#0-1) 

**Attack Entry Points:**

The `NextRound()` method is publicly accessible and processes user-provided round data: [3](#0-2) 

`ProcessNextRound()` converts the input via `ToRound()` and stores it directly without validating the dictionary structure: [4](#0-3) 

The corrupted round is stored directly via `AddRoundInformation()`: [5](#0-4) 

**Missing Validation:**

The validation framework includes seven providers that check various consensus properties, but NONE validate key-Pubkey consistency: [6](#0-5) 

The `NextRoundMiningOrderValidationProvider` only checks `FinalOrderOfNextRound` values: [7](#0-6) 

The `PreCheck()` method only verifies the sender is in the current miner list, not the structural integrity of the proposed round: [8](#0-7) 

**Exploitation Impact:**

Once a corrupted round is stored, `ProcessUpdateValue()` attempts to access the dictionary using the miner's actual pubkey, which will throw `KeyNotFoundException` if the pubkey is not a dictionary key: [9](#0-8) 

## Impact Explanation

**HIGH SEVERITY - Consensus Denial of Service:**

1. **Immediate Block Production Failure**: Legitimate miners whose actual pubkeys are not dictionary keys (because their `MinerInRound` objects are stored under different keys) will be unable to produce blocks. The dictionary access at line 242 will throw `KeyNotFoundException`, causing transaction failure.

2. **Consensus Halt**: If a malicious miner crafts input that affects enough miners (e.g., stores all legitimate miners under arbitrary keys like "MaliciousKey1", "MaliciousKey2", etc.), those miners cannot participate in consensus, potentially halting the blockchain entirely.

3. **Data Corruption Persistence**: The corrupted round structure persists in state and propagates through subsequent rounds via `GetUpdateValueRound()`, making recovery difficult without governance intervention or chain fork.

4. **Miner Disenfranchisement**: Legitimate miners lose their ability to participate in consensus and earn rewards despite being properly elected through the Election contract.

## Likelihood Explanation

**HIGH LIKELIHOOD:**

**Attacker Prerequisites:**
- Must be an elected miner in the current miner list
- This is achievable through the Election contract's normal voting process
- A single compromised or malicious miner is sufficient

**Attack Complexity: LOW**
1. Attacker crafts a `NextRoundInput` message with corrupted `RealTimeMinersInformation` where dictionary keys do not match the `Pubkey` fields within their corresponding `MinerInRound` values
2. Attacker calls `NextRound()` during their designated mining time slot
3. No cryptographic operations or signature forgery required
4. Validation passes because no validator checks key-Pubkey consistency
5. Corrupted round is stored and immediately affects other miners

**Economic Incentive: HIGH**
- Competitor miners can eliminate rivals from consensus
- Attacker can maintain their own mining capability while disabling others
- Low cost (single transaction) versus high impact (consensus disruption)
- Attack may go undetected initially until affected miners attempt to produce blocks

## Recommendation

Add validation to ensure dictionary keys match their corresponding `Pubkey` values at all critical points:

```csharp
// Add to NextRoundInput.ToRound() or as a validation provider
private bool ValidateRoundStructure(Round round)
{
    foreach (var kvp in round.RealTimeMinersInformation)
    {
        if (kvp.Key != kvp.Value.Pubkey)
        {
            return false; // Key-Pubkey mismatch detected
        }
    }
    return true;
}
```

Implement this validation in:
1. A new `RoundStructureValidationProvider` added to the validation provider list for `NextRound` and `NextTerm` behaviors
2. The `ToRound()` method to fail fast on invalid input
3. The `ProcessNextRound()` and `ProcessNextTerm()` methods as a final defensive check

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_WithMismatchedKeyPubkey_CausesConsensusDoS()
{
    // Arrange: Setup initial round with legitimate miners
    await InitializeConsensusContract();
    var currentRound = await GetCurrentRoundInformation();
    
    // Attacker is a legitimate miner
    var attackerKeyPair = SampleECKeyPairs.KeyPairs[0];
    var victimKeyPair = SampleECKeyPairs.KeyPairs[1];
    
    // Create corrupted NextRoundInput with mismatched key-pubkey
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        RealTimeMinersInformation = 
        {
            // Store victim's MinerInRound under arbitrary key
            ["MaliciousKey"] = new MinerInRound 
            { 
                Pubkey = victimKeyPair.PublicKey.ToHex(), // Real pubkey
                Order = 1,
                // ... other fields
            }
        },
        RandomNumber = GenerateRandomNumber()
    };
    
    // Act: Attacker submits corrupted NextRound
    var result = await AttackerStub.NextRound.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Assert: Victim miner cannot produce blocks
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        // Victim attempts to produce block via UpdateValue
        await VictimStub.UpdateValue.SendAsync(new UpdateValueInput
        {
            ActualMiningTime = TimestampHelper.GetUtcNow(),
            // ... other fields
        });
    });
    
    // Verify KeyNotFoundException was thrown
    exception.Message.ShouldContain("KeyNotFoundException");
    
    // Consensus is disrupted - victim cannot mine
}
```

## Notes

This vulnerability demonstrates a fundamental data structure integrity issue where the system assumes but does not enforce that dictionary keys match their corresponding object identifiers. The attack exploits the gap between normal round generation (which maintains the invariant) and manual round submission (which lacks validation). The severity is HIGH because it directly impacts consensus availability with minimal attacker requirements and low attack complexity.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L44-46)
```csharp
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L30-30)
```csharp
            RealTimeMinersInformation = { RealTimeMinersInformation },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-92)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
