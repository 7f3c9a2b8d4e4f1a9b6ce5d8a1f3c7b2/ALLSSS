# Audit Report

## Title
NFT Alias Symbol Collision Causes Incorrect Balance Reporting

## Summary
The MultiToken contract's alias system for NFTs contains a critical validation gap that allows regular tokens and NFT aliases to share the same symbol. When this collision occurs, balance queries using the alias return incorrect balances from the regular token instead of the intended NFT, breaking the alias functionality and violating data integrity guarantees.

## Finding Description

The vulnerability exists due to missing cross-validation between two independent symbol storage mappings: `TokenInfos` (for regular tokens) and `SymbolAliasMap` (for NFT aliases).

**The SetSymbolAlias Validation Gap:**

The `SetSymbolAlias` method only validates that the alias doesn't exist in `SymbolAliasMap`, but never checks if a regular token with that symbol already exists in `TokenInfos`. [1](#0-0) 

**The CreateToken Validation Gap:**

Token creation validates symbol uniqueness only against `TokenInfos` and `InsensitiveTokenExisting`, never checking `SymbolAliasMap` for existing aliases. [2](#0-1) 

**The Alias Constraint:**

The `CheckTokenAlias` validation enforces that NFT aliases MUST equal the collection prefix (e.g., for collection "TP-0", the alias MUST be "TP"). [3](#0-2)  This constraint makes collisions inevitable for popular symbol names.

**The Resolution Prioritization:**

When `GetBalance` queries a symbol, it calls `GetActualTokenSymbol`, which prioritizes direct `TokenInfos` lookup over alias resolution. If a symbol exists in `TokenInfos`, it returns that symbol immediately without checking `SymbolAliasMap`. [4](#0-3) 

This causes `GetBalance` to return the wrong balance when a regular token shadows an NFT alias. [5](#0-4)  The same issue affects `GetTokenInfo` which uses similar prioritization logic. [6](#0-5) 

**Attack Flow:**
1. User creates NFT collection "TP-0" with item "TP-31175"
2. User sets alias "TP" â†’ "TP-31175" (succeeds)
3. Attacker creates regular token "TP" (succeeds)
4. User queries balance with alias "TP"
5. System returns balance of regular token "TP" instead of NFT "TP-31175"

## Impact Explanation

**Medium Severity** - This vulnerability causes:

1. **Data Integrity Violation**: Balance queries return incorrect information, violating the core invariant that balance queries must be accurate
2. **Broken Functionality**: The NFT alias system becomes unreliable when collisions occur
3. **Operational Confusion**: NFT holders receive wrong balance information when using aliases
4. **Griefing Vector**: Attackers can intentionally create tokens to shadow NFT aliases, disrupting alias functionality for legitimate NFT projects
5. **Forced Workaround**: Users must use full NFT symbols (e.g., "TP-31175") instead of aliases (e.g., "TP"), eliminating the usability benefit

While this doesn't directly steal funds, it breaks a fundamental protocol guarantee (accurate balance reporting) and can be exploited to disrupt NFT projects and confuse users.

## Likelihood Explanation

**High Likelihood** due to:

1. **Low Attack Complexity**: Only requires two standard operations (create token, set alias) with no special permissions
2. **Inevitable Collisions**: The `CheckTokenAlias` constraint that enforces alias = collection prefix makes collisions predictable for popular symbols
3. **Standard Permissions**: Anyone with a seed NFT can create tokens; any NFT collection owner can set aliases
4. **Both Orderings Work**: Attack succeeds whether the alias or regular token is created first
5. **Difficult Detection**: Both operations are legitimate and succeed independently; the issue only manifests during balance queries
6. **High Probability**: Popular prefix names (like "TP", "NFT", common acronyms) will naturally collide either accidentally or intentionally

## Recommendation

Implement bidirectional validation between `TokenInfos` and `SymbolAliasMap`:

**In SetSymbolAlias:**
```
// After line 750, add:
Assert(State.TokenInfos[input.Alias] == null, 
    $"Cannot set alias {input.Alias}: a token with this symbol already exists.");
```

**In CheckTokenExists:**
```
// After line 302, add:
Assert(State.SymbolAliasMap[symbol] == null, 
    "Cannot create token: this symbol is already used as an NFT alias.");
```

This ensures mutual exclusivity between regular token symbols and NFT aliases, preventing collisions entirely.

## Proof of Concept

```csharp
[Fact]
public async Task NFTAlias_RegularToken_Collision_Test()
{
    // Create NFT collection "TP-0" and item "TP-31175"
    var symbols = await CreateNftCollectionAndNft();
    
    // Set alias "TP" for NFT item "TP-31175"
    await TokenContractStub.SetSymbolAlias.SendAsync(new SetSymbolAliasInput
    {
        Symbol = symbols[1], // "TP-31175"
        Alias = "TP"
    });
    
    // Issue NFT to user
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "TP-31175",
        Amount = 1,
        To = DefaultAddress
    });
    
    // Verify alias works before collision
    var balanceBeforeCollision = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultAddress,
        Symbol = "TP" // Using alias
    });
    balanceBeforeCollision.Balance.ShouldBe(1); // Correct: returns NFT balance
    
    // Attacker creates regular token "TP" (this should fail but doesn't)
    await CreateSeedNftAsync(TokenContractStub, new CreateInput
    {
        Symbol = "TP",
        TokenName = "Regular Token TP",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultAddress,
        Owner = DefaultAddress,
        IsBurnable = true
    });
    
    var createResult = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "TP",
        TokenName = "Regular Token TP",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = DefaultAddress,
        Owner = DefaultAddress,
        IsBurnable = true
    });
    createResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // BUG: Should fail
    
    // Query balance with alias after collision
    var balanceAfterCollision = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultAddress,
        Symbol = "TP" // Still using alias
    });
    
    // BUG: Returns 0 (regular token balance) instead of 1 (NFT balance)
    balanceAfterCollision.Balance.ShouldBe(0); // Wrong! Should be 1
    // The alias no longer resolves to the NFT, breaking the alias functionality
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L750-750)
```csharp
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L840-852)
```csharp
    private void CheckTokenAlias(string alias, string collectionSymbol)
    {
        if (collectionSymbol == null)
        {
            throw new AssertionException("Token alias can only be set for NFT Item.");
        }

        // Current Rule: Alias must be the seed name.
        var parts = collectionSymbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(parts.Length == 2, $"Incorrect collection symbol: {collectionSymbol}.");
        Assert(parts.Last() == TokenContractConstants.CollectionSymbolSuffix, "Incorrect collection symbol suffix.");
        Assert(alias == parts.First(), $"Alias for an item of {collectionSymbol} cannot be {alias}.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L39-47)
```csharp
    public override GetBalanceOutput GetBalance(GetBalanceInput input)
    {
        var symbol = GetActualTokenSymbol(input.Symbol);
        return new GetBalanceOutput
        {
            Symbol = input.Symbol,
            Owner = input.Owner,
            Balance = GetBalance(input.Owner, symbol)
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L286-294)
```csharp
    private string GetActualTokenSymbol(string aliasOrSymbol)
    {
        if (State.TokenInfos[aliasOrSymbol] == null)
        {
            return State.SymbolAliasMap[aliasOrSymbol] ?? aliasOrSymbol;
        }

        return aliasOrSymbol;
    }
```
