### Title
Consensus Commands Can Be Created with Mining Times in the Past, Violating Time-Ordering Invariants

### Summary
The `TerminateRoundCommandStrategy.GetAEDPoSConsensusCommand` method lacks validation to ensure that `arrangedMiningTime` is after `CurrentBlockTime`. This allows consensus commands to be created with mining times in the past when network delays cause the current time to advance past the scheduled extra block mining time, violating critical time-ordering invariants in the consensus system.

### Finding Description

The vulnerability exists in the consensus command generation flow for round termination: [1](#0-0) 

This strategy calls `MiningTimeArrangingService.ArrangeExtraBlockMiningTime`, which delegates to `Round.ArrangeAbnormalMiningTime`: [2](#0-1) 

The root cause is in `ArrangeAbnormalMiningTime`: [3](#0-2) 

When the node is the extra block producer, the code checks if `(GetExtraBlockMiningTime() + miningInterval) > currentBlockTime`. If true, it returns `GetExtraBlockMiningTime()` directly. However, this does **not** guarantee that `GetExtraBlockMiningTime() > currentBlockTime`.

**Vulnerable Window**: When `GetExtraBlockMiningTime() < currentBlockTime < GetExtraBlockMiningTime() + miningInterval`, the condition passes but returns a time in the past.

For example:
- `GetExtraBlockMiningTime()` = 1600ms (fixed when round was created)
- `currentBlockTime` = 1700ms (advanced due to delays)
- `miningInterval` = 200ms
- `distance` = (1600 + 200) - 1700 = 100ms > 0 ✓
- Returns 1600ms, which is **before** currentBlockTime (1700ms)

**Contrast with Normal Blocks**: The `NormalBlockCommandStrategy` correctly ensures time-ordering: [4](#0-3) 

It uses `Max(expectedMiningTime, currentBlockTime)` to prevent past timestamps.

**Impact on Scheduler**: The past timestamp flows to `ConsensusService`: [5](#0-4) 

This calculates `leftMilliseconds = ArrangedMiningTime - GetUtcNow()`, which becomes **negative**, then passes it to the scheduler: [6](#0-5) 

Both scheduler implementations use this negative value to schedule events at past times: [7](#0-6) [8](#0-7) 

### Impact Explanation

This vulnerability violates the critical consensus invariant that mining must be scheduled for future times, causing:

1. **Consensus Time-Ordering Violation**: Mining events scheduled with past timestamps break the fundamental assumption that blocks are produced in chronological order.

2. **Immediate Mining Trigger**: Schedulers receiving negative delays will either execute immediately or exhibit undefined behavior, causing premature block production outside the intended time slot.

3. **Round Transition Disruption**: Extra blocks are responsible for terminating rounds and starting new rounds/terms. Incorrect timing can cause:
   - Miners to produce blocks out of their designated time slots
   - Consensus state transitions to occur at wrong times
   - Potential forks if different nodes interpret the timing differently

4. **Chain Stability Risk**: While not directly stealing funds, this undermines consensus reliability, which is foundational to blockchain security.

**Severity**: High - This violates a critical consensus invariant and can naturally occur during normal operation under network delays.

### Likelihood Explanation

**High Likelihood** - This can occur naturally without any malicious intent:

1. **Reachable Entry Point**: `GetConsensusCommand` is called by all miners during normal consensus operation via the ACS4 interface: [9](#0-8) 

2. **Natural Trigger Conditions**: 
   - Network delays or high system load cause block production to fall behind schedule
   - The extra block producer requests a consensus command after their scheduled time has passed
   - This is particularly likely during network partitions, node restarts, or high transaction volume

3. **No Attacker Required**: This is a design flaw that manifests during normal operational stress, not requiring malicious actors.

4. **Execution Practicality**: The vulnerable code path executes whenever:
   - A miner needs to terminate a round (NextRound or NextTerm behavior)
   - The current time has advanced past the scheduled extra block time but within one mining interval
   - This window (`GetExtraBlockMiningTime() < currentBlockTime < GetExtraBlockMiningTime() + miningInterval`) is significant during any timing delays

5. **Detection Difficulty**: Since this appears as timing issues rather than explicit attacks, it may be misdiagnosed as network problems rather than a code bug.

### Recommendation

**Fix the ArrangeAbnormalMiningTime method** to ensure returned times are never in the past:

```csharp
public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
    bool mustExceededCurrentRound = false)
{
    var miningInterval = GetMiningInterval();
    var minerInRound = RealTimeMinersInformation[pubkey];

    if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
    {
        var extraBlockTime = GetExtraBlockMiningTime();
        var distance = (extraBlockTime.AddMilliseconds(miningInterval) - currentBlockTime).Milliseconds();
        
        // FIX: Ensure extraBlockTime is not in the past
        if (distance > 0 && extraBlockTime >= currentBlockTime)
        {
            return extraBlockTime;
        }
    }

    // Fallback: Calculate future round time
    var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
    var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
    var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
    return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
}
```

**Alternative approach** - Add the same `Max()` pattern used by NormalBlockCommandStrategy:

```csharp
public static Timestamp ArrangeExtraBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
{
    return TimestampExtensions.Max(round.ArrangeAbnormalMiningTime(pubkey, currentBlockTime), currentBlockTime);
}
```

**Add validation** in `TerminateRoundCommandStrategy.GetAEDPoSConsensusCommand`:

```csharp
var arrangedMiningTime = MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
Assert(arrangedMiningTime >= CurrentBlockTime, "Arranged mining time must not be in the past");
```

**Test cases to add**:
1. Test when `currentBlockTime` is between `GetExtraBlockMiningTime()` and `GetExtraBlockMiningTime() + miningInterval`
2. Test round termination with significant timing delays
3. Test that all consensus commands have `ArrangedMiningTime >= CurrentBlockTime`

### Proof of Concept

**Initial State**:
- Round initialized with 3 miners, 200ms mining interval
- Miner 1 time slot: 1000ms
- Miner 2 time slot: 1200ms  
- Miner 3 time slot: 1400ms
- Extra block time: 1600ms (calculated as 1400ms + 200ms)

**Exploit Sequence**:

1. **Round starts normally** at 1000ms
2. **Network delays occur** - Miners produce blocks slowly or miss their time slots
3. **Current time advances** to 1700ms due to accumulated delays
4. **Extra block producer** (Miner responsible for terminating round) calls `GetConsensusCommand`
5. **TerminateRoundCommandStrategy invoked** (NextRound or NextTerm behavior)
6. **ArrangeAbnormalMiningTime executes**:
   - `GetExtraBlockMiningTime()` returns 1600ms
   - `currentBlockTime` is 1700ms
   - `distance = (1600 + 200) - 1700 = 100ms > 0` ✓
   - Returns 1600ms (NO check that 1600 >= 1700)
7. **ConsensusCommand created** with `ArrangedMiningTime = 1600ms`
8. **ConsensusService processes command**:
   - `leftMilliseconds = 1600 - GetUtcNow()` (where GetUtcNow() ≈ 1700ms)
   - `leftMilliseconds = -100ms` (negative!)
9. **Scheduler receives negative delay**: Causes immediate or undefined execution

**Expected Result**: ArrangedMiningTime should be >= currentBlockTime (at least 1700ms)

**Actual Result**: ArrangedMiningTime is 1600ms (100ms in the past)

**Success Condition**: Consensus command created with past timestamp, violating time-ordering invariant. This is reproducible whenever timing delays place currentBlockTime in the vulnerable window between the scheduled extra block time and one mining interval later.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-39)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MiningTimeArrangingService.cs (L17-20)
```csharp
        public static Timestamp ArrangeNormalBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
        {
            return TimestampExtensions.Max(round.GetExpectedMiningTime(pubkey), currentBlockTime);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MiningTimeArrangingService.cs (L22-25)
```csharp
        public static Timestamp ArrangeExtraBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
        {
            return round.ArrangeAbnormalMiningTime(pubkey, currentBlockTime);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L26-31)
```csharp
        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L87-91)
```csharp
        _nextMiningTime = _consensusCommand.ArrangedMiningTime;
        var leftMilliseconds = _consensusCommand.ArrangedMiningTime - TimestampHelper.GetUtcNow();
        leftMilliseconds = leftMilliseconds.Seconds > ConsensusConstants.MaximumLeftMillisecondsForNextBlock
            ? new Duration { Seconds = ConsensusConstants.MaximumLeftMillisecondsForNextBlock }
            : leftMilliseconds;
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L108-108)
```csharp
        _consensusScheduler.NewEvent(leftMilliseconds.Milliseconds(), blockMiningEventData);
```

**File:** src/AElf.Kernel.Consensus.Scheduler.FluentScheduler/FluentSchedulerScheduler.cs (L30-32)
```csharp
        registry.Schedule(() => LocalEventBus.PublishAsync(consensusRequestMiningEventData))
            .ToRunOnceAt(TimestampHelper.GetUtcNow().AddMilliseconds(countingMilliseconds).ToDateTime());
        JobManager.Initialize(registry);
```

**File:** src/AElf.Kernel.Consensus.Scheduler.RxNet/RxNetScheduler.cs (L60-61)
```csharp
        return Observable.Timer(TimeSpan.FromMilliseconds(countingMilliseconds))
            .Select(_ => consensusRequestMiningEventData).Subscribe(this);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L39-44)
```csharp
            case AElfConsensusBehaviour.NextRound:
            case AElfConsensusBehaviour.NextTerm:
                return new ConsensusCommandProvider(
                        new TerminateRoundCommandStrategy(currentRound, pubkey, currentBlockTime,
                            behaviour == AElfConsensusBehaviour.NextTerm))
                    .GetConsensusCommand();
```
