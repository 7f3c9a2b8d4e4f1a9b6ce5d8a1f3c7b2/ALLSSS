### Title
Null Voting Record Handling Causes View Function Denial of Service

### Summary
The `GetElectorVoteWithAllRecords()` and similar view methods do not validate that voting records returned from the Vote contract are non-null before accessing their properties. When `State.VoteContract.GetVotingRecords.Call` returns null entries for non-existent vote IDs, the code throws a `NullReferenceException`, causing denial of service for querying voting records.

### Finding Description

The vulnerability exists in multiple view methods that retrieve voting records from the Vote contract: [1](#0-0) 

The Vote contract's `GetVotingRecords` implementation retrieves records using LINQ: [2](#0-1) 

**Root Cause**: When `State.VotingRecords[id]` is accessed for a non-existent ID, it returns `null`. The LINQ `Select` operation includes these null values in the returned collection, maintaining the same count as input IDs. The Election contract then iterates through the returned records without null-checking before passing them to `TransferVotingRecordToElectionVotingRecord`: [3](#0-2) 

This method immediately accesses properties of the `votingRecord` parameter (line 342: `votingRecord.Voter`, line 343: `votingRecord.Option`, etc.), causing a `NullReferenceException` if the record is null.

**Why Protections Fail**: The code assumes all vote IDs in `WithdrawnVotingRecordIds` correspond to existing records in the Vote contract. However, state inconsistency can occur during contract upgrades, state migrations, or if there are bugs in vote tracking logic.

**Note on Question Premise**: The question asks if "different number of records" causes index misalignment. In reality, `GetVotingRecords` returns the *same* count as input IDs (including null entries), so there is no count mismatch. The actual issue is accessing properties of null records.

The same vulnerability pattern exists in:
- `GetElectorVoteWithRecords` (lines 168-187) [4](#0-3) 

- `GetCandidateVoteWithRecords` (lines 268-286) [5](#0-4) 

- `GetCandidateVoteWithAllRecords` (lines 288-305) [6](#0-5) 

### Impact Explanation

**Harm**: Denial of service on critical view functions that users and applications rely on to query voting information. Users cannot retrieve their complete voting history or candidate vote details if any withdrawn vote ID lacks a corresponding record.

**Affected Parties**: All users (voters and candidates) who have withdrawn votes, and any applications querying election data.

**Severity**: Medium - This is a DoS of view functions that prevents information retrieval but does not:
- Allow theft or loss of funds
- Corrupt state or enable unauthorized actions  
- Affect the withdrawal operation itself (the `Withdraw` action method validates record existence)
- Impact consensus or token mechanics

The vulnerability prevents data access but does not compromise system integrity or assets.

### Likelihood Explanation

**Preconditions**: Requires `WithdrawnVotingRecordIds` or similar lists to contain vote IDs that don't exist in the Vote contract's state.

**Scenarios**:
1. **Contract Upgrades**: State migration issues where Election contract IDs aren't synchronized with Vote contract records
2. **State Corruption**: Storage layer issues causing record loss
3. **Historical Data**: Old vote IDs from previous contract versions that were never migrated
4. **Concurrent Operations**: Race conditions during cross-contract state updates

**Attacker Capabilities**: No attacker action required - this is a latent bug triggered by state inconsistency.

**Probability**: Low to Medium. Normal operations should maintain consistency as the withdrawal flow validates record existence: [7](#0-6) 

However, state desynchronization during upgrades or migrations is realistic in production environments.

### Recommendation

**Code-Level Fix**: Add null-checking before accessing voting records in all affected methods:

```csharp
public override ElectorVote GetElectorVoteWithAllRecords(StringValue input)
{
    var votes = GetElectorVoteWithRecords(input);
    
    if (!votes.WithdrawnVotingRecordIds.Any()) return votes;
    
    var votedWithdrawnRecords = State.VoteContract.GetVotingRecords.Call(new GetVotingRecordsInput
    {
        Ids = { votes.WithdrawnVotingRecordIds }
    }).Records;
    
    var index = 0;
    foreach (var record in votedWithdrawnRecords)
    {
        var voteId = votes.WithdrawnVotingRecordIds[index++];
        // Add null check
        if (record != null)
        {
            votes.WithdrawnVotesRecords.Add(TransferVotingRecordToElectionVotingRecord(record, voteId));
        }
    }
    
    return votes;
}
```

Apply similar fixes to `GetElectorVoteWithRecords`, `GetCandidateVoteWithRecords`, and `GetCandidateVoteWithAllRecords`.

**Alternative Approach**: Modify the Vote contract's `GetVotingRecords` to filter out null entries, but document that returned count may not match input count.

**Invariant Checks**: 
- Add validation that all IDs in `WithdrawnVotingRecordIds` have corresponding records during state migrations
- Add monitoring/logging for null record occurrences

**Test Cases**:
- Test view methods with non-existent vote IDs in withdrawn lists
- Test state migration scenarios ensuring ID-record consistency
- Test concurrent withdraw operations to detect race conditions

### Proof of Concept

**Initial State**:
1. User creates and withdraws a vote normally (ID exists in both contracts)
2. Simulate state inconsistency: manually add a non-existent vote ID to `ElectorVotes[userAddress].WithdrawnVotingRecordIds`

**Exploit Steps**:
1. Call `GetElectorVoteWithAllRecords(userAddress)`
2. The method retrieves `WithdrawnVotingRecordIds` containing the non-existent ID
3. Cross-contract call to `State.VoteContract.GetVotingRecords` returns collection with null entry
4. The foreach loop iterates to the null record
5. `TransferVotingRecordToElectionVotingRecord(null, voteId)` is called
6. Accessing `votingRecord.Voter` at line 342 throws `NullReferenceException`

**Expected Result**: Method returns voting records successfully, skipping or handling non-existent IDs gracefully.

**Actual Result**: Method throws `NullReferenceException` and fails, preventing any user from querying this voter's complete record.

**Success Condition**: The view method fails with an exception, making the voter's data inaccessible through this query path.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L168-187)
```csharp
    public override ElectorVote GetElectorVoteWithRecords(StringValue input)
    {
        var votes = GetElectorVote(input.Value);
        
        if (votes.Address == null && votes.Pubkey == null)
            return votes;
        
        var votedRecords = State.VoteContract.GetVotingRecords.Call(new GetVotingRecordsInput
        {
            Ids = { votes.ActiveVotingRecordIds }
        }).Records;
        var index = 0;
        foreach (var record in votedRecords)
        {
            var voteId = votes.ActiveVotingRecordIds[index++];
            votes.ActiveVotingRecords.Add(TransferVotingRecordToElectionVotingRecord(record, voteId));
        }

        return votes;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L204-222)
```csharp
    public override ElectorVote GetElectorVoteWithAllRecords(StringValue input)
    {
        var votes = GetElectorVoteWithRecords(input);

        if (!votes.WithdrawnVotingRecordIds.Any()) return votes;

        var votedWithdrawnRecords = State.VoteContract.GetVotingRecords.Call(new GetVotingRecordsInput
        {
            Ids = { votes.WithdrawnVotingRecordIds }
        }).Records;
        var index = 0;
        foreach (var record in votedWithdrawnRecords)
        {
            var voteId = votes.WithdrawnVotingRecordIds[index++];
            votes.WithdrawnVotesRecords.Add(TransferVotingRecordToElectionVotingRecord(record, voteId));
        }

        return votes;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L268-286)
```csharp
    public override CandidateVote GetCandidateVoteWithRecords(StringValue input)
    {
        var votes = State.CandidateVotes[input.Value];
        if (votes == null)
            return new CandidateVote();

        var obtainedRecords = State.VoteContract.GetVotingRecords.Call(new GetVotingRecordsInput
        {
            Ids = { votes.ObtainedActiveVotingRecordIds }
        }).Records;
        var index = 0;
        foreach (var record in obtainedRecords)
        {
            var voteId = votes.ObtainedActiveVotingRecordIds[index++];
            votes.ObtainedActiveVotingRecords.Add(TransferVotingRecordToElectionVotingRecord(record, voteId));
        }

        return votes;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L288-305)
```csharp
    public override CandidateVote GetCandidateVoteWithAllRecords(StringValue input)
    {
        var votes = GetCandidateVoteWithRecords(input);

        //get withdrawn records
        var obtainedWithdrawnRecords = State.VoteContract.GetVotingRecords.Call(new GetVotingRecordsInput
        {
            Ids = { votes.ObtainedWithdrawnVotingRecordIds }
        }).Records;
        var index = 0;
        foreach (var record in obtainedWithdrawnRecords)
        {
            var voteId = votes.ObtainedWithdrawnVotingRecordIds[index++];
            votes.ObtainedWithdrawnVotesRecords.Add(TransferVotingRecordToElectionVotingRecord(record, voteId));
        }

        return votes;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L337-355)
```csharp
    private ElectionVotingRecord TransferVotingRecordToElectionVotingRecord(VotingRecord votingRecord, Hash voteId)
    {
        var lockSeconds = State.LockTimeMap[voteId];
        return new ElectionVotingRecord
        {
            Voter = votingRecord.Voter,
            Candidate = GetNewestPubkey(votingRecord.Option),
            Amount = votingRecord.Amount,
            TermNumber = votingRecord.SnapshotNumber,
            VoteId = voteId,
            LockTime = lockSeconds,
            VoteTimestamp = votingRecord.VoteTimestamp,
            WithdrawTimestamp = votingRecord.WithdrawTimestamp,
            UnlockTimestamp = votingRecord.VoteTimestamp.AddSeconds(lockSeconds),
            IsWithdrawn = votingRecord.IsWithdrawn,
            Weight = GetVotesWeight(votingRecord.Amount, lockSeconds),
            IsChangeTarget = votingRecord.IsChangeTarget
        };
    }
```

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L8-13)
```csharp
    public override VotingRecords GetVotingRecords(GetVotingRecordsInput input)
    {
        var votingRecords = new VotingRecords();
        votingRecords.Records.AddRange(input.Ids.Select(id => State.VotingRecords[id]));
        return votingRecords;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L631-645)
```csharp
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input);

        var actualLockedTime = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockDays = State.LockTimeMap[input];
        Assert(actualLockedTime >= claimedLockDays,
            $"Still need {claimedLockDays.Sub(actualLockedTime).Div(86400)} days to unlock your token.");

        var voterPublicKey = Context.RecoverPublicKey();

        var voterVotes = GetElectorVote(voterPublicKey);

        Assert(voterVotes != null, $"Voter {Context.Sender.ToBase58()} never votes before");

        voterVotes.ActiveVotingRecordIds.Remove(input);
        voterVotes.WithdrawnVotingRecordIds.Add(input);
```
