### Title
Selective PreviousInValue Revelation Allows Mining Order Manipulation in AEDPoS Consensus

### Summary
The `ValidatePreviousInValue()` function contains early returns that allow miners to bypass validation by providing `Hash.Empty` for their `PreviousInValue`, even when they made a cryptographic commitment (OutValue) in the previous round. This enables miners to manipulate their mining order for the next round by strategically choosing whether to reveal their committed value, breaking the fairness guarantees of the commit-reveal consensus mechanism.

### Finding Description

The vulnerability exists in the validation logic: [1](#0-0) 

The function retrieves the miner's `previousOutValue` from state (the commitment they made in round N), but the early return at line 46 allows validation to pass if `previousInValue == Hash.Empty`, without checking whether `previousOutValue` exists and is non-empty. This bypasses the cryptographic verification at line 48 that would normally validate `Hash(previousInValue) == previousOutValue`.

When a miner provides `Hash.Empty` as `PreviousInValue`, the consensus extra data generation uses a fallback mechanism: [2](#0-1) 

A deterministic fake value is generated (line 96) or an appointed value from state is used (lines 99-100). This fake/appointed value is then used to calculate the miner's signature: [3](#0-2) 

The signature directly determines the mining order for the next round: [4](#0-3) 

**Root Cause:** The validation logic incorrectly treats "no revelation" (Hash.Empty) as acceptable even when a commitment exists, rather than enforcing that commitments must be revealed. The early return at line 46 should only pass validation if no commitment was made (`previousOutValue == null || previousOutValue == Hash.Empty`).

### Impact Explanation

**Consensus Integrity Impact:**
- Miners can calculate two different signatures before producing their block: one using their real `PreviousInValue` and one using the system-generated fake value
- Since `GetAbsModulus(signature.ToInt64(), minersCount) + 1` determines their position in the next round, different signatures yield different mining orders
- A strategic miner can choose whichever option gives them a more favorable position (e.g., mining earlier, mining before/after specific other miners)
- This breaks the randomness and fairness guarantees of the AEDPoS round-robin mechanism

**Who Is Affected:**
- All honest miners suffer reduced fairness in mining opportunities
- Block production becomes biased toward strategic miners who exploit this
- Consensus liveness and security properties degrade if multiple miners exploit this simultaneously

**Severity Justification:**
Medium severity because while it compromises consensus fairness, the manipulation is limited (binary choice, deterministic fake value) and requires specific conditions (secret sharing failure or timing).

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an active miner in the consensus set
- Can calculate both potential signatures off-chain before submitting their block
- No special privileges required beyond normal mining rights

**Attack Complexity:**
- LOW: The attacker simply provides `Hash.Empty` instead of their real `PreviousInValue` when it benefits them
- Calculation is straightforward: compute `CalculateSignature(realInValue)` vs `CalculateSignature(Hash(pubkey + height))`
- Compare resulting `GetAbsModulus` values and choose the better option

**Feasibility Conditions:**
- Most effective when secret sharing has not recovered the InValue (requires < 2/3 miners participating in decryption)
- Can also exploit timing by mining before secret sharing completes in a given block
- The comment "It is permissible for miners not publish their in values" suggests this bypass is treated as acceptable by the system: [5](#0-4) 

**Detection/Operational Constraints:**
- Difficult to detect as both choices (reveal vs. not reveal) are considered valid by the protocol
- No on-chain penalty for non-revelation
- Observable pattern: miners consistently not revealing when it benefits their position

**Probability:** MEDIUM-HIGH - Easy to implement programmatically once a miner understands the mechanism, requires only opportunistic exploitation.

### Recommendation

**Code-Level Mitigation:**

Modify the validation to enforce revelation when a commitment exists:

```csharp
private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;

    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
        return true;

    var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
    var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
    
    // If miner made a commitment (OutValue exists), they MUST reveal it
    if (previousOutValue != null && previousOutValue != Hash.Empty)
    {
        if (previousInValue == null || previousInValue == Hash.Empty)
            return false; // Reject blocks that don't reveal commitments
        
        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
    
    // No commitment was made, so no revelation required
    return true;
}
```

**Invariant Checks:**
1. If `previousRound[miner].OutValue` is set, then `currentRound[miner].PreviousInValue` must be provided and valid
2. Secret sharing recovery should be the fallback for missed revelations, not an excuse for optional revelation
3. Add monitoring to detect miners with unusually low revelation rates

**Test Cases:**
1. Test that miners who produced OutValue in round N cannot mine in round N+1 with `PreviousInValue = Hash.Empty`
2. Test that validation correctly rejects such blocks before consensus
3. Test that secret sharing recovery still works for miners who were offline
4. Test that new miners (not in previous round) can still mine without PreviousInValue

### Proof of Concept

**Initial State:**
- Miner M is in the active consensus set for rounds N and N+1
- Round N: Miner M produces block with `InValue_N`, publishes `OutValue_N = Hash(InValue_N)`
- Secret sharing fails to recover `InValue_N` (either insufficient decrypted pieces or timing)

**Attack Sequence:**

1. **Round N+1 - Preparation:**
   - Miner M's turn to produce block in round N+1
   - Off-chain calculation:
     * Option A: `signature_reveal = CalculateSignature(InValue_N)`
     * Option B: `signature_hide = CalculateSignature(Hash(pubkey + currentHeight))`
     * `order_A = GetAbsModulus(signature_reveal.ToInt64(), minersCount) + 1`
     * `order_B = GetAbsModulus(signature_hide.ToInt64(), minersCount) + 1`

2. **Round N+1 - Exploitation:**
   - If `order_B` gives better position than `order_A` (e.g., mines earlier in round N+2):
     * Submit `UpdateValueInput` with `PreviousInValue = Hash.Empty`
     * Validation passes via early return at line 46
     * System uses fake value: `Hash(pubkey + currentHeight)`
     * Signature calculated as `signature_hide`
   - Otherwise submit with real `InValue_N`

3. **Round N+2 - Result:**
   - Miner M mines at position `order_B` instead of `order_A`
   - Achieved mining order manipulation through selective revelation

**Expected vs Actual:**
- Expected: Miner must reveal `InValue_N` to prove their previous commitment
- Actual: Miner can choose to reveal or hide based on strategic advantage

**Success Condition:**
Mining order changes between the two scenarios, demonstrating that the early return at line 46 enables order manipulation by bypassing the commitment verification that should be enforced when a previous OutValue exists.

### Notes

The design appears to intentionally allow optional revelation (as evidenced by the comment at line 262-263), likely relying on secret sharing for InValue recovery. However, this creates a security-vs-usability tradeoff that favors strategic miners. The validation function's existence and its cryptographic check at line 48 suggest there was intent to validate revelations, but the early returns undermine this. A proper fix should distinguish between "no commitment existed" (legitimate skip) and "commitment existed but not revealed" (should fail validation).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L94-108)
```csharp
            else
            {
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```
