# Audit Report

## Title
Retroactive Miner Count Calculation Causes Sudden Jumps When MinerIncreaseInterval is Modified

## Summary
The `SetMinerIncreaseInterval()` function allows governance to decrease the miner increase interval, but the miner count calculation in `GetAutoIncreasedMinersCount()` retroactively applies the new interval to the entire blockchain history. This causes an immediate jump in the miner count instead of a gradual increase, disrupting consensus and diluting mining rewards.

## Finding Description

The vulnerability exists in how the auto-increased miner count is calculated when the miner increase interval is modified by governance.

The `SetMinerIncreaseInterval()` function updates the interval value after validating that it can only be decreased (not increased). [1](#0-0) 

However, `GetAutoIncreasedMinersCount()` uses the CURRENT interval value to divide the ENTIRE elapsed time since blockchain start. [2](#0-1) 

The formula is: `SupposedMinersCount + (elapsed_seconds / MinerIncreaseInterval) * 2`

When the interval decreases from 31,536,000 seconds (1 year) to 15,768,000 seconds (6 months) after 2 years have elapsed:
- **Before:** 17 + (63,072,000 / 31,536,000) × 2 = 21 miners
- **After:** 17 + (63,072,000 / 15,768,000) × 2 = 25 miners
- **Result:** Sudden jump of 4 miners

The same retroactive calculation exists in `GetMinersCount()`. [3](#0-2) 

This value propagates to the Election Contract via `UpdateMinersCountToElectionContract()` during term transitions [4](#0-3)  or when `SetMaximumMinersCount()` is called. [5](#0-4) 

The Election Contract stores this value [6](#0-5)  and uses it in `GetVictories()` to determine how many candidates should be selected as miners. [7](#0-6) 

## Impact Explanation

**Consensus Disruption:** The sudden addition of multiple miners (e.g., 4 in the example) changes the consensus participant set abruptly, violating the intended gradual decentralization mechanism that adds only 2 miners per interval. [8](#0-7) 

**Reward Dilution:** Existing miners suddenly experience a ~16% decrease in mining rewards when the count jumps from 21 to 25 miners, as rewards are distributed among all participants.

**Security Model Violation:** AEDPoS Byzantine fault tolerance calculations depend on the miner count, so sudden jumps affect security assumptions.

**Candidate Selection Error:** Less-qualified candidates who shouldn't yet be eligible become miners immediately, as `GetVictories()` selects based on the jumped count value.

**Severity:** MEDIUM - While this doesn't directly steal funds, it violates critical consensus invariants, causes reward misallocation, and disrupts the intended gradual decentralization mechanism.

## Likelihood Explanation

**Trigger Path:** Requires governance approval through `MaximumMinersCountController` (default: Parliament). [9](#0-8) 

**Feasibility:** The governance body may legitimately want to adjust the interval to accelerate decentralization or adapt to network conditions. The validation only allows decreasing the interval, making this a plausible governance action. [10](#0-9) 

**Deterministic:** Once `SetMinerIncreaseInterval()` is called, the bug triggers automatically on the next term transition or `SetMaximumMinersCount()` call.

**Detection:** The jump would be visible in query results, but governance may not realize the retroactive effect until after approval.

**Probability:** HIGH - If governance ever adjusts the interval for legitimate policy reasons, the bug will trigger with certainty.

## Recommendation

Track the historical miner increase schedule instead of performing a retroactive calculation. Maintain a state variable that records when intervals change and calculate the miner count based on actual elapsed intervals under each setting.

**Implementation approach:**
1. Store interval change history with timestamps
2. When calculating miner count, iterate through historical intervals and count how many actually elapsed
3. Add 2 miners for each completed interval period
4. This ensures the count increases gradually as originally intended

Alternatively, store the current calculated miner count as a state variable that only increments by 2 when the actual interval period elapses, rather than recalculating from blockchain start time.

## Proof of Concept

```csharp
// Test demonstrating the sudden jump
[Fact]
public async Task Test_MinerCountJumpOnIntervalDecrease()
{
    // Setup: Blockchain has been running for 2 years with 1-year interval
    var blockchainStartTime = TimestampHelper.GetUtcNow();
    var twoYearsLater = blockchainStartTime.AddSeconds(63072000); // 2 years
    
    // Initial interval: 1 year (31536000 seconds)
    var initialInterval = 31536000;
    
    // Expected: 17 + (2 years / 1 year) * 2 = 17 + 4 = 21 miners
    var initialCount = await ConsensusStub.GetMaximumMinersCount.CallAsync(new Empty());
    initialCount.Value.ShouldBe(21);
    
    // Governance decreases interval to 6 months (15768000 seconds)
    var newInterval = 15768000;
    await ConsensusStub.SetMinerIncreaseInterval.SendAsync(new Int64Value { Value = newInterval });
    
    // Bug: Retroactive calculation now shows 17 + (2 years / 6 months) * 2 = 17 + 8 = 25 miners
    var newCount = await ConsensusStub.GetMaximumMinersCount.CallAsync(new Empty());
    newCount.Value.ShouldBe(25); // Sudden jump of 4 miners
    
    // Expected behavior: Should still be 21 miners (gradual increase)
    // The count should only increase to 23 after 6 more months elapse
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L23-26)
```csharp
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L176-176)
```csharp
        UpdateMinersCountToElectionContract(nextRound);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```
