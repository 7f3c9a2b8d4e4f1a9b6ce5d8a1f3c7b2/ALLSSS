### Title
Unbounded Loop in GetAllProfitsMap() View Method Causes DoS for Users with Many Profit Details

### Summary
The `GetAllProfitsMap()` view method iterates through all profit details without any upper bound, unlike the equivalent state-changing method `ClaimProfits()` which limits processing to 10 details. Users who accumulate many profit details (e.g., through frequent voting in the Election contract) will exceed AElf's execution limits (15,000 branches/calls), causing the view call to fail and preventing them from querying their total claimable profits.

### Finding Description

**Location:** [1](#0-0) 

The root cause is an unbounded loop that processes all available profit details. At line 125, the method iterates through `availableDetails.Count` without any limit: [2](#0-1) 

While the method calculates a limited `profitableDetailCount` (max 10) at lines 119-120, this limit is only applied to the claimable profits calculation (line 132). The total profits calculation at line 130 is executed for **every** detail in the loop. [3](#0-2) 

Each iteration calls `ProfitAllPeriods()` which performs nested loops through token symbols and period ranges: [4](#0-3) 

This creates computational complexity of O(details × symbols × periods), with each period iteration performing state reads and calculations.

**Why Protections Fail:**

The equivalent state-changing method `ClaimProfits()` properly limits processing to only 10 details: [5](#0-4) 

However, `GetAllProfitsMap()` lacks this protection and processes all details.

**How Users Accumulate Many Details:**

In the Election contract, each vote creates one profit detail: [6](#0-5) 

Users who vote frequently accumulate dozens or hundreds of profit details over time.

**Execution Limits:**

AElf enforces execution limits on all contract methods, including view calls: [7](#0-6) [8](#0-7) 

### Impact Explanation

**Operational Impact - DoS of View Functionality:**

Users with many profit details cannot query their total profits using `GetAllProfitsMap()`, which is marked as a view method: [9](#0-8) 

This breaks UI/frontend functionality that relies on this method to display profit information. Users affected include:
- Frequent voters in the Election contract
- Long-term participants who haven't claimed profits regularly
- Any user with 50+ profit details across multiple periods

**Quantified Impact:**

With realistic parameters:
- 50 profit details (moderate voting activity)
- 5 token symbols (max per constant)
- 20 periods average per detail
- ~7 branches per period iteration

Total branches ≈ 50 × 5 × 20 × 7 = **35,000 branches**, which exceeds the 15,000 threshold by 2.3x. [10](#0-9) 

**Severity Justification (Low):**

This is Low severity because:
1. Only affects view calls, not state-changing operations
2. No fund loss or state corruption occurs
3. Users can still claim profits via `ClaimProfits()` which is properly protected
4. Workaround exists: use `GetProfitAmount()` with specific symbols
5. Only affects users with unusually high activity levels

### Likelihood Explanation

**Feasible Preconditions:**

The issue occurs naturally without any malicious intent. Users who:
- Vote frequently in elections (legitimate activity)
- Participate over extended time periods
- Don't claim profits regularly

...will organically accumulate enough profit details to trigger this issue.

**Execution Practicality:**

The exploitation path is straightforward:
1. User votes 50+ times over time (one detail per vote)
2. User attempts to query profits via `GetAllProfitsMap()`
3. View call exceeds execution limits and fails
4. User cannot see their profit amounts in UI

**Attack Complexity:**

No attack is required - this is an operational DoS that manifests through normal heavy usage. The probability increases over time as active users accumulate more profit details.

**Economic Rationality:**

Creating votes has legitimate economic benefits (earning voting rewards), so users naturally create the preconditions for this issue without additional cost.

### Recommendation

**Code-Level Mitigation:**

Apply the same limit used in `ClaimProfits()` to the main loop in `GetAllProfitsMap()`:

```csharp
// Change line 125 from:
for (var i = 0; i < availableDetails.Count; i++)

// To:
var maxDetailsToProcess = Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, availableDetails.Count);
for (var i = 0; i < maxDetailsToProcess; i++)
```

This ensures the view method has the same computational bounds as the state-changing method.

**Alternative Approach:**

Add pagination support to `GetAllProfitsMapInput` with `skip` and `take` parameters, allowing users to query profits in batches.

**Invariant Check:**

Document that view methods calculating profit totals are limited to processing at most 10 profit details at a time, consistent with the claiming limit.

**Test Case:**

Add a test that:
1. Creates 50+ profit details for a single beneficiary
2. Distributes profits across multiple periods
3. Calls `GetAllProfitsMap()` and verifies it completes within execution limits
4. Verifies results match expectations for the limited set of details

### Proof of Concept

**Initial State:**
1. Create a profit scheme with 5 token symbols
2. User votes 50 times in Election contract (creates 50 profit details)
3. Distribute profits for 20 periods

**Transaction Steps:**
1. User calls `GetAllProfitsMap()` view method with their address

**Expected Result:**
View call should complete and return profit amounts

**Actual Result:**
View call fails with execution limit exceeded (branch count > 15,000)

**Success Condition:**
The view call aborts due to exceeding `ExecutionBranchThreshold` constant, preventing the user from querying their total profits. This can be verified by monitoring the execution branch count, which will exceed 15,000 with the parameters above.

### Citations

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L119-121)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, availableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L125-135)
```csharp
        for (var i = 0; i < availableDetails.Count; i++)
        {
            var profitDetail = availableDetails[i];
            if (profitDetail.LastProfitPeriod == 0) profitDetail.LastProfitPeriod = profitDetail.StartPeriod;
            
            var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod),true, symbol);
            AddProfitToDict(allProfitsDict, totalProfitsDictForEachProfitDetail);
            if(i >= profitableDetailCount) continue;
            var claimableProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount,true, symbol);
            AddProfitToDict(claimableProfitsDict, claimableProfitsDictForEachProfitDetail);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L772-777)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
        // Only can get profit from last profit period to actual last period (profit.CurrentPeriod - 1),
        // because current period not released yet.
        for (var i = 0; i < profitableDetailCount; i++)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L845-920)
```csharp
    private Dictionary<string, long> ProfitAllPeriods(Scheme scheme, ProfitDetail profitDetail, Address beneficiary, long maxProfitReceivingPeriodCount,
        bool isView = false, string targetSymbol = null)
    {
        var profitsMap = new Dictionary<string, long>();
        var lastProfitPeriod = profitDetail.LastProfitPeriod;

        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }

            profitsMap.Add(symbol, totalAmount);
        }

        profitDetail.LastProfitPeriod = lastProfitPeriod;

        return profitsMap;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-382)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-7)
```csharp
    public const int ExecutionCallThreshold = 15000;

    public const int ExecutionBranchThreshold = 15000;
```

**File:** docs-sphinx/architecture/smart-contract/restrictions/others.rst (L13-15)
```text
- AElf's contract patcher will patch method call count observer for your contract. This is used to prevent infinitely method call like recursion. The number of method called in your contract will be counted during transaction execution. The observer will pause transaction execution if the number exceeds 15,000. The limit adjustment is governed by ``Parliament``.

- AElf's contract patcher will patch method branch count observer for your contract. This is used to prevent infinitely loop case. The number of code control transfer in your contract will be counted during transaction execution. The observer will pause transaction execution if the number exceeds 15,000. The limit adjustment is governed by ``Parliament``.
```

**File:** protobuf/profit_contract.proto (L110-113)
```text
    // Query all profit.
    rpc GetAllProfitsMap (GetAllProfitsMapInput) returns (GetAllProfitsMapOutput) {
        option (aelf.is_view) = true;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L5-9)
```csharp
    public const int ProfitReceivingLimitForEachTime = 10;
    public const int DefaultProfitReceivingDuePeriodCount = 10;
    public const int MaximumProfitReceivingDuePeriodCount = 1024;
    public const int TokenAmountLimit = 5;
    public const int DefaultMaximumProfitReceivingPeriodCountOfOneTime = 100;
```
