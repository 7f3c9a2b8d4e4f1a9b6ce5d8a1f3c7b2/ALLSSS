### Title
View Method State Mutation Causes Unintended Field Persistence in NFT State

### Summary
The `GetNFTInfoByTokenHash` view method modifies the cached NFT state object by populating protocol-level fields (`ProtocolName`, `Creator`, `BaseUri`, `NftType`). When this method is called internally by non-view methods (`Burn`, `Recast`), these modifications persist to storage, violating the design intention that these fields should only be computed on-demand from protocol state, not stored per-NFT.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:**
The `GetNFTInfoByTokenHash` method retrieves `nftInfo` from `State.NftInfoMap[input]`, which returns a reference to the cached protobuf message object (a reference type). The method then directly modifies this cached object by setting fields from the protocol info: [2](#0-1) 

Since `NFTInfo` is a protobuf message (reference type): [3](#0-2) 

And `MappedState` returns the cached value reference: [4](#0-3) 

**Why Protections Fail:**
When this view method is called internally by non-view methods, the modifications persist because:

1. `Burn` method calls the view function and later writes the modified object back: [5](#0-4) 

2. `Recast` method does the same: [6](#0-5) 

3. While view methods called as transactions have their state changes discarded: [7](#0-6) 

This protection does NOT apply when the view method is called internally within a non-view transaction. The cache modifications remain and get persisted when the calling method writes the state.

**Design Violation Evidence:**
The `PerformMint` method explicitly comments that these protocol fields should NOT be stored in NFT state: [8](#0-7) 

### Impact Explanation

**Data Integrity Violation:**
- NFT state stores protocol-level fields (`ProtocolName`, `Creator`, `BaseUri`, `NftType`) that should only exist in protocol state
- This creates duplicate, potentially stale data that violates the single-source-of-truth principle

**Storage Waste:**
- Each NFT unnecessarily stores ~100-200 bytes of redundant protocol information
- For protocols with thousands of NFTs, this multiplies storage requirements significantly

**Inconsistency Risk:**
- If protocol information changes (e.g., via a protocol update), existing NFTs retain old values
- Different NFTs minted at different times may show different protocol metadata
- Query results become inconsistent depending on when the NFT was last modified via `Burn` or `Recast`

**Who is Affected:**
- All NFT holders whose tokens are burned or recast
- Protocol creators expecting consistent protocol-level metadata
- Applications querying NFT data expecting accurate protocol information

**Severity: MEDIUM**
While this doesn't directly cause fund loss, it corrupts the data model and creates operational inconsistencies that undermine the contract's intended architecture.

### Likelihood Explanation

**Reachable Entry Points:**
- `Burn`: Public method callable by any NFT minter
- `Recast`: Public method callable by any NFT minter
- `Assemble`: Public method that may call `GetNFTInfoByTokenHash`

**Attack Complexity: NONE (Automatic)**
This is not an exploit but an architectural flaw that triggers automatically during normal operations:
- No special privileges needed beyond being a minter (legitimate role)
- No specific timing or state requirements
- Happens transparently during standard NFT lifecycle operations

**Feasibility: 100%**
Every `Burn` and `Recast` operation triggers this behavior: [9](#0-8) [10](#0-9) 

**Economic Rationality:**
- No additional cost to trigger
- Occurs during normal, intended use of the contract

**Detection:**
- State changes appear legitimate (no failed transactions)
- Only detectable by comparing stored NFT state against protocol state

### Recommendation

**Code-Level Mitigation:**

Create a separate internal method that returns NFT info without modifying the cached state:

```csharp
private NFTInfo GetNFTInfoInternal(Hash tokenHash)
{
    return State.NftInfoMap[tokenHash];
}

public override NFTInfo GetNFTInfoByTokenHash(Hash input)
{
    var nftInfo = State.NftInfoMap[input];
    if (nftInfo == null) return new NFTInfo();
    
    // Clone the object to avoid mutating the cached state
    var result = nftInfo.Clone();
    var nftProtocolInfo = State.NftProtocolMap[nftInfo.Symbol];
    result.ProtocolName = nftProtocolInfo.ProtocolName;
    result.Creator = nftProtocolInfo.Creator;
    result.BaseUri = nftProtocolInfo.BaseUri;
    result.NftType = nftProtocolInfo.NftType;
    return result;
}
```

Update internal callers to use `GetNFTInfoInternal`:
- Change `Burn` line 85 to use `GetNFTInfoInternal`
- Change `Recast` line 261 to use `GetNFTInfoInternal`
- Change `Assemble` line 127 to use `GetNFTInfoInternal`

**Invariant Checks:**
Add assertions to verify NFT state doesn't contain protocol fields:
```csharp
Assert(string.IsNullOrEmpty(nftInfo.ProtocolName), "NFT state should not store protocol name");
Assert(nftInfo.Creator == null, "NFT state should not store creator");
```

**Test Cases:**
1. Burn an NFT and verify stored state doesn't contain `ProtocolName`, `Creator`, `BaseUri`, `NftType`
2. Recast an NFT and verify the same
3. Query via `GetNFTInfoByTokenHash` and verify these fields ARE populated in the response

### Proof of Concept

**Initial State:**
1. Deploy NFT contract
2. Create protocol "TEST" with `ProtocolName = "TestProtocol"`, `Creator = AddressA`, `BaseUri = "https://test.com"`
3. Mint NFT with `symbol = "TEST"`, `tokenId = 1`
4. Query stored state: `State.NftInfoMap[tokenHash]` â†’ `ProtocolName` is empty/null

**Exploitation Steps:**
1. Call `Recast(symbol: "TEST", tokenId: 1, uri: "newuri", alias: "test", metadata: {})`
   - Internally calls `GetNFTInfoByTokenHash(tokenHash)` at line 261
   - View method modifies cached object: sets `ProtocolName`, `Creator`, `BaseUri`, `NftType`
   - `Recast` makes additional modifications
   - Writes back to state at line 282

**Expected vs Actual:**
- **Expected**: `State.NftInfoMap[tokenHash].ProtocolName` remains empty (as per design comments)
- **Actual**: `State.NftInfoMap[tokenHash].ProtocolName = "TestProtocol"` (protocol field persisted)

**Success Condition:**
After recast, directly query the state storage (not through the view method):
```csharp
var storedNftInfo = State.NftInfoMap[tokenHash];
Assert(storedNftInfo.ProtocolName != null && storedNftInfo.ProtocolName.Length > 0);
// This assertion passes, confirming the vulnerability
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L20-30)
```csharp
    public override NFTInfo GetNFTInfoByTokenHash(Hash input)
    {
        var nftInfo = State.NftInfoMap[input];
        if (nftInfo == null) return new NFTInfo();
        var nftProtocolInfo = State.NftProtocolMap[nftInfo.Symbol];
        nftInfo.ProtocolName = nftProtocolInfo.ProtocolName;
        nftInfo.Creator = nftProtocolInfo.Creator;
        nftInfo.BaseUri = nftProtocolInfo.BaseUri;
        nftInfo.NftType = nftProtocolInfo.NftType;
        return nftInfo;
    }
```

**File:** protobuf/nft_contract.proto (L287-312)
```text
message NFTInfo {
    // The symbol of the protocol this nft belongs to.
    string symbol = 1;
    // The name of the protocol this nft belongs to.
    string protocol_name = 2;
    // Actually is the order of this token.
    int64 token_id = 3;
    // The address that creat the base token.
    aelf.Address creator = 4;
    // The addresses that mint this token.
    repeated aelf.Address minters = 5;
    // The metadata of the token.
    Metadata metadata = 6;
    // Minted amount.
    int64 quantity = 7;
    // Token Uri.
    string uri = 8;
    // Base Uri.
    string base_uri = 9;
    // Alias
    string alias = 10;
    // Is burned.
    bool is_burned = 11;
    // NFT Type
    string nft_type = 12;
}
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L26-37)
```csharp
    public TEntity this[TKey key]
    {
        get
        {
            if (!Cache.TryGetValue(key, out var valuePair))
            {
                valuePair = LoadKey(key);
                Cache[key] = valuePair;
            }

            return valuePair.IsDeleted ? SerializationHelper.Deserialize<TEntity>(null) : valuePair.Value;
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-101)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L256-282)
```csharp
    public override Empty Recast(RecastInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(minterList.Value.Contains(Context.Sender), "No permission.");
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        Assert(nftInfo.Quantity != 0 && nftInfo.Quantity == State.BalanceMap[tokenHash][Context.Sender],
            "Do not support recast.");
        if (input.Alias != null) nftInfo.Alias = input.Alias;

        if (input.Uri != null) nftInfo.Uri = input.Uri;

        var oldMetadata = nftInfo.Metadata.Clone();
        var metadata = new Metadata();
        // Need to keep reserved metadata key.
        foreach (var reservedKey in GetNftMetadataReservedKeys())
        {
            if (oldMetadata.Value.ContainsKey(reservedKey))
                metadata.Value[reservedKey] = oldMetadata.Value[reservedKey];

            if (input.Metadata.Value.ContainsKey(reservedKey)) input.Metadata.Value.Remove(reservedKey);
        }

        metadata.Value.Add(input.Metadata.Value);
        nftInfo.Metadata = metadata;

        State.NftInfoMap[tokenHash] = nftInfo;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L415-431)
```csharp
        if (nftInfo == null)
        {
            nftInfo = new NFTInfo
            {
                Symbol = input.Symbol,
                Uri = input.Uri ?? string.Empty,
                TokenId = tokenId,
                Metadata = nftMetadata,
                Minters = { Context.Sender },
                Quantity = quantity,
                Alias = input.Alias

                // No need.
                //BaseUri = protocolInfo.BaseUri,
                //Creator = protocolInfo.Creator,
                //ProtocolName = protocolInfo.ProtocolName
            };
```

**File:** src/AElf.Runtime.CSharp/Executive.cs (L143-146)
```csharp
            if (!handler.IsView())
                CurrentTransactionContext.Trace.StateSet = GetChanges();
            else
                CurrentTransactionContext.Trace.StateSet = new TransactionExecutingStateSet();
```
