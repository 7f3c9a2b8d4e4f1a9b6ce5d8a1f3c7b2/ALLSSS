### Title
Cross-Chain NFT Type Metadata Desynchronization Leading to Protocol Info Corruption

### Summary
The `CrossChainCreate()` method in the NFT contract ignores the authoritative NFT type stored in `tokenInfo.ExternalInfo[NftTypeMetadataKey]` from the mainchain and instead derives the type from the symbol's first two characters using a local sidechain mapping. This causes protocol info corruption when custom NFT types are added via governance on the mainchain but not synchronized to sidechains, or when different chains maintain inconsistent NFT type mappings.

### Finding Description

**Root Cause:**

On the mainchain, when an NFT protocol is created via the `Create()` method, the NFT type is explicitly stored in the token's external info: [1](#0-0) 

This authoritative NFT type value is then passed to the MultiToken contract and becomes part of the cross-chain token information.

However, in the `CrossChainCreate()` method executed on sidechains, this authoritative value is completely ignored: [2](#0-1) 

Instead of reading `tokenInfo.ExternalInfo.Value[NftTypeMetadataKey]`, the method:
1. Extracts the first 2 characters from the symbol as a "short name"
2. Looks up this short name in the **local sidechain's** `State.NFTTypeFullNameMap`
3. Uses the locally mapped value as the NFT type

The NFT type mappings can be customized via the governance-controlled `AddNFTType` method: [3](#0-2) 

This method only modifies the **local chain's** state and does not trigger any cross-chain synchronization mechanism. Each chain maintains its own independent NFT type mapping.

**Why Existing Protections Fail:**

1. The `CrossChainCreateToken` method in MultiToken contract correctly preserves the external info containing the NFT type: [4](#0-3) 

2. However, the NFT contract's `CrossChainCreate` never validates that the locally derived NFT type matches the value in `tokenInfo.ExternalInfo[NftTypeMetadataKey]`

3. There is no mechanism to ensure NFT type mappings are synchronized across chains before `CrossChainCreate` is called

4. The constant defining the metadata key is present but unused in cross-chain creation: [5](#0-4) 

### Impact Explanation

**Concrete Harm:**

1. **DoS of Cross-Chain NFT Creation:** If parliament adds a custom NFT type on mainchain (e.g., "CustomArt" → "CA") and an NFT protocol is created with this type, calling `CrossChainCreate` on any sidechain without this mapping will fail with "Full name of CA not found", completely blocking legitimate cross-chain NFT protocol creation.

2. **Protocol Info Corruption:** If mainchain and sidechain have conflicting mappings for the same short name code (e.g., mainchain: "CT" → "CustomType", sidechain: "CT" → "CollectibleType"), the same NFT protocol will have **different types on different chains**. This breaks the fundamental cross-chain consistency requirement.

3. **Metadata Inconsistency:** The NFT protocol's metadata field will contain the correct mainchain NFT type from `ExternalInfo`, but the `NftType` field will contain the incorrect locally-derived type: [6](#0-5) 

This creates an internal data inconsistency where the same protocol has contradictory type information.

**Affected Parties:**
- NFT protocol creators who add custom types via governance
- Cross-chain applications relying on consistent NFT type classification
- Users and marketplaces querying NFT protocol information
- Indexers and explorers displaying NFT metadata

**Severity Justification:** HIGH - This violates critical cross-chain integrity invariants, causes permanent protocol data corruption, and can DoS legitimate cross-chain NFT functionality.

### Likelihood Explanation

**Attack Vector (No Attacker Needed):**

This is not an adversarial attack but a design flaw that manifests through normal operations:

1. **Reachable Entry Point:** `CrossChainCreate` is a public method callable by any user after the underlying token is cross-chain created: [7](#0-6) 

2. **Feasible Preconditions:** Only requires parliament on any chain to use the legitimate `AddNFTType` governance function, which is its intended purpose

3. **Execution Practicality:** 
   - Step 1: Parliament on mainchain adds custom NFT type via proposal
   - Step 2: User creates NFT protocol with this custom type
   - Step 3: Token is cross-chain created to sidechain (standard flow)
   - Step 4: Anyone calls `CrossChainCreate` on sidechain → immediate failure or corruption

4. **No Attack Cost:** This happens automatically through normal governance and cross-chain operations

5. **Detection Difficulty:** The corruption is silent - no error is thrown when types mismatch, and the inconsistent data persists permanently

**Probability:** HIGH - Any use of custom NFT types (an intended governance feature) combined with cross-chain operations (a core protocol feature) triggers this vulnerability.

### Recommendation

**Immediate Fix:**

Modify `CrossChainCreate` to use the authoritative NFT type from `tokenInfo.ExternalInfo[NftTypeMetadataKey]` instead of deriving it from local mappings:

```
Line 87-93: Replace the current logic with:
var nftType = tokenInfo.ExternalInfo.Value[NftTypeMetadataKey];
Assert(!string.IsNullOrEmpty(nftType), "NFT type not found in token external info.");
```

**Additional Validation:**

Add a check to ensure the derived short name matches the expected mapping:
```
var nftTypeShortName = input.Symbol.Substring(0, 2);
InitialNFTTypeNameMap();
var expectedShortName = State.NFTTypeShortNameMap[nftType];
Assert(nftTypeShortName == expectedShortName, 
    $"Symbol prefix {nftTypeShortName} does not match NFT type {nftType}");
```

**Long-term Solution:**

Implement a cross-chain NFT type synchronization mechanism or remove the dependence on chain-local mappings entirely by always using the external info as the source of truth.

**Regression Tests:**

1. Test custom NFT type creation on mainchain and cross-chain to sidechain without the mapping
2. Test conflicting NFT type mappings between chains
3. Verify `tokenInfo.ExternalInfo[NftTypeMetadataKey]` matches `NFTProtocolInfo.NftType` after cross-chain creation

### Proof of Concept

**Initial State:**
- Mainchain (AELF) has default 10 NFT types initialized
- Sidechain has default 10 NFT types initialized
- Both chains registered for cross-chain communication

**Transaction Sequence:**

1. **On Mainchain:** Parliament creates proposal to add custom NFT type
   - Input: `AddNFTTypeInput { FullName = "CustomArt", ShortName = "CA" }`
   - Parliament approves and releases proposal
   - Result: Mainchain now has "CA" → "CustomArt" mapping

2. **On Mainchain:** User creates NFT protocol with custom type
   - Input: `CreateInput { NftType = "CustomArt", ProtocolName = "Special Art", ... }`
   - Result: Symbol "CA123456789" created with `ExternalInfo["aelf_nft_type"] = "CustomArt"`

3. **Cross-Chain:** Token is validated and cross-chain created to sidechain
   - MultiToken's `CrossChainCreateToken` succeeds
   - Token info including `ExternalInfo["aelf_nft_type"] = "CustomArt"` now exists on sidechain

4. **On Sidechain:** User attempts to call `CrossChainCreate`
   - Input: `CrossChainCreateInput { Symbol = "CA123456789" }`
   - Execution reaches line 90: `var nftTypeFullName = State.NFTTypeFullNameMap["CA"];`
   - **Expected Result:** Protocol created with `NftType = "CustomArt"`
   - **Actual Result:** Transaction fails with "Full name of CA not found. Use AddNFTType to add this new pair."
   - **Success Condition for Vulnerability:** Transaction fails OR if sidechain has different "CA" mapping, protocol is created with wrong type

**Alternative Scenario (Mapping Conflict):**

If sidechain previously added "CA" → "CryptoAssets":
- Transaction succeeds
- Protocol created with `NftType = "CryptoAssets"` 
- But `Metadata.Value["aelf_nft_type"] = "CustomArt"`
- **Data corruption confirmed:** Same symbol has different types on different chains

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-75)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L87-93)
```csharp
        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L104-106)
```csharp
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L131-150)
```csharp
    public override Empty AddNFTType(AddNFTTypeInput input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        var fullName = input.FullName;
        Assert(input.ShortName.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.ShortName] == null, $"Short name {input.ShortName} already exists.");
        Assert(State.NFTTypeShortNameMap[fullName] == null, $"Full name {fullName} already exists.");
        State.NFTTypeFullNameMap[input.ShortName] = fullName;
        State.NFTTypeShortNameMap[fullName] = input.ShortName;
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Add(input.ShortName, fullName);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeAdded
        {
            ShortName = input.ShortName,
            FullName = input.FullName
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L196-196)
```csharp
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L501-501)
```csharp
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L7-7)
```csharp
    private const string NftTypeMetadataKey = "aelf_nft_type";
```
