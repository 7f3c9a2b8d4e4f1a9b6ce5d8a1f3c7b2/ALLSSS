### Title
Invalid Profit Detail Creation When EndPeriod Equals CurrentPeriod with Delayed Distribution

### Summary
When a scheme has `DelayDistributePeriodCount > 0` and `AddBeneficiary` is called with `EndPeriod = CurrentPeriod`, the beneficiary's `StartPeriod` is set to `CurrentPeriod + DelayDistributePeriodCount`, which exceeds `EndPeriod`. This creates an invalid profit detail where the beneficiary can never claim any profits, but their shares permanently count towards `TotalShares`, diluting all other beneficiaries' profit distributions indefinitely.

### Finding Description

The vulnerability occurs in the `AddBeneficiary` function where two validation gaps interact: [1](#0-0) 

This assertion only validates that `EndPeriod >= CurrentPeriod`, but fails to check if `EndPeriod` is sufficient given the scheme's delay settings. [2](#0-1) 

The `StartPeriod` is calculated as `CurrentPeriod + DelayDistributePeriodCount`. When `EndPeriod = CurrentPeriod` and `DelayDistributePeriodCount > 0`, this creates `StartPeriod > EndPeriod`. [3](#0-2) 

The beneficiary's shares are immediately added to `TotalShares`, affecting all future distributions.

During profit claiming, the invalid detail is filtered out: [4](#0-3) 

The condition `d.EndPeriod >= d.StartPeriod` evaluates to false for the invalid detail, preventing any profit claims. [5](#0-4) 

The cleanup mechanism only removes details where `LastProfitPeriod > EndPeriod`, which never occurs for unclaimed invalid details. The shares remain in `TotalShares` permanently.

This vulnerability is present in production: [6](#0-5) 

The Treasury Welfare scheme uses `DelayDistributePeriodCount = 1`.

### Impact Explanation

**Direct Fund Impact - Permanent Profit Misallocation:**
- When an invalid beneficiary is added with shares S to a scheme with total shares T, all future distributions allocate S/(T+S) of profits to an address that can never claim
- These unclaimed profits remain locked in the period's virtual address indefinitely
- Other beneficiaries receive reduced distributions: they get (their_shares)/(T+S) instead of (their_shares)/T

**Concrete Example:**
- Scheme has 100 existing shares across legitimate beneficiaries
- Manager adds invalid beneficiary with 100 shares (EndPeriod = CurrentPeriod = 5, DelayDistributePeriodCount = 1)
- TotalShares becomes 200
- On each distribution, 50% goes to legitimate beneficiaries (who should receive 100%), 50% is permanently locked
- If 1,000 tokens are distributed per period over 100 periods, 50,000 tokens are permanently lost

**Affected Parties:**
- All legitimate beneficiaries of schemes with `DelayDistributePeriodCount > 0`
- Treasury Welfare scheme beneficiaries in production
- No recovery mechanism exists; locked funds cannot be retrieved

### Likelihood Explanation

**Reachable Entry Point:**
`AddBeneficiary` is callable by scheme managers, a trusted but privileged role. [7](#0-6) 

**Feasible Preconditions:**
- Scheme must have `DelayDistributePeriodCount > 0` (exists in Treasury Welfare)
- Manager calls `AddBeneficiary` with `EndPeriod = CurrentPeriod`
- This could occur accidentally (user error not understanding delay semantics) or maliciously (manager locks profits to steal via alternate beneficiary)

**Execution Practicality:**
The attack requires only a single `AddBeneficiary` call with readily available parameters. No complex state manipulation or timing requirements.

**Economic Rationality:**
- Accidental: Likely during scheme migration or beneficiary updates when manager sets EndPeriod to "current" without accounting for delay
- Malicious: Manager could intentionally lock a portion of distributions, then claim them through a separate unaffected beneficiary, effectively stealing from other participants

**Probability:** Medium - requires manager action but no additional checks prevent this straightforward mistake.

### Recommendation

Add validation in `AddBeneficiary` to ensure `EndPeriod` accounts for the delay period:

```csharp
// After line 179, add:
var effectiveStartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount);
Assert(input.EndPeriod >= effectiveStartPeriod,
    $"Invalid end period. End period must be >= {effectiveStartPeriod} " +
    $"(CurrentPeriod {scheme.CurrentPeriod} + DelayDistributePeriodCount {scheme.DelayDistributePeriodCount})");
```

**Additional Mitigations:**
1. Add a cleanup mechanism in `ClaimProfits` to remove invalid details (where `EndPeriod < StartPeriod`) and deduct their shares from `TotalShares`
2. Add regression test combining `DelayDistributePeriodCount > 0` with `EndPeriod = CurrentPeriod` scenarios
3. Audit existing production schemes for invalid beneficiaries and provide migration path

### Proof of Concept

**Initial State:**
- Create scheme with `CurrentPeriod = 1`, `DelayDistributePeriodCount = 1`
- Add legitimate Beneficiary B with `Shares = 100`, `EndPeriod = 10`
- `TotalShares = 100`

**Exploit Transaction:**
```
AddBeneficiary(
    SchemeId: scheme_id,
    BeneficiaryShare: { Beneficiary: AttackerAddress, Shares: 100 },
    EndPeriod: 1  // Equals CurrentPeriod
)
```

**Result:**
- Invalid beneficiary created: `StartPeriod = 2`, `EndPeriod = 1`
- `TotalShares = 200` (both beneficiaries count)

**Distribution Transaction:**
```
DistributeProfits(SchemeId: scheme_id, Period: 1, Amount: 1000 tokens)
```

**Expected vs Actual:**
- **Expected:** Beneficiary B receives 100% (1000 tokens) since invalid beneficiary cannot claim
- **Actual:** Distribution allocates 50% (500 tokens) to each address based on shares
  - Beneficiary B can claim 500 tokens
  - Invalid beneficiary cannot claim (filtered at line 765-766), 500 tokens permanently locked
  
**Success Condition:**
Query virtual address balance for period 1 shows 500 tokens unclaimed. Query Beneficiary B's claimable amount shows 500 tokens instead of expected 1000 tokens. Invalid beneficiary's claim transaction fails with no available details.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L179-180)
```csharp
        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L182-184)
```csharp
        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);

        State.SchemeInfos[schemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-766)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-792)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L63-64)
```csharp
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
```
