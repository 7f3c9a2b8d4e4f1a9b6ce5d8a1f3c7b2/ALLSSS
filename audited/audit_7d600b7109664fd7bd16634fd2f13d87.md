### Title
Unprotected Dictionary Access in Consensus Transaction Generation Causes DoS During Miner Transitions

### Summary
The `GetConsensusExtraDataToPublishOutValue` and `GetConsensusExtraDataForTinyBlock` methods directly access `RealTimeMinersInformation[pubkey]` without validating key existence, causing `KeyNotFoundException` when a miner attempts to generate transactions after being removed from the round during term transitions or miner replacements. This prevents legitimate miners from producing blocks during their designated time slots.

### Finding Description

The vulnerability exists in the consensus transaction generation flow, specifically in the dictionary access patterns: [1](#0-0) [2](#0-1) 

**Root Cause:**
Both `GetConsensusExtraDataToPublishOutValue` and `GetConsensusExtraDataForTinyBlock` directly access the `RealTimeMinersInformation` dictionary using the provided pubkey without first checking if the key exists. In C#, accessing a dictionary with a non-existent key throws `KeyNotFoundException`.

**Why Existing Protections Fail:**
1. `GetConsensusCommand` validates miner list membership at an earlier time [3](#0-2) 

2. However, between getting the consensus command and generating transactions, the round state can change via `NextRound` or `NextTerm` operations that remove/replace miners [4](#0-3) 

3. The `MiningPermissionValidationProvider` checks mining permission during `ValidateConsensusBeforeExecution` [5](#0-4)  but this occurs AFTER transaction generation, making it too late to prevent the exception.

4. Notably, `GetConsensusExtraDataForNextRound` and `GetConsensusExtraDataForNextTerm` include proper key validation [6](#0-5)  and [7](#0-6)  but UpdateValue and TinyBlock behaviors lack this protection.

**Execution Path:**
1. Miner calls `GenerateConsensusTransactions` [8](#0-7) 
2. Invokes `GetConsensusBlockExtraData` [9](#0-8) 
3. Retrieves current round from state [10](#0-9) 
4. For UpdateValue behavior, calls `GetConsensusExtraDataToPublishOutValue` [11](#0-10) 
5. Throws `KeyNotFoundException` when accessing non-existent pubkey
6. Transaction generation fails without proper error handling [12](#0-11) 

**Note:** The original audit question focused on the null return in `ExtractInformationToUpdateConsensus` [13](#0-12) , but this code is never reached because the exception occurs earlier in the call stack at the dictionary access points.

### Impact Explanation

**Harm:**
A miner who was legitimately scheduled to produce blocks but was removed from the round (through miner replacement or term transition) cannot generate consensus transactions, resulting in:
- Failed block production for their designated time slot
- Loss of block rewards for that slot
- Potential consensus delays if multiple miners are affected
- Degraded network performance during term boundaries

**Affected Parties:**
- Miners undergoing replacement or term transition
- The consensus network (delayed block production)
- Users expecting consistent block times

**Severity Justification:**
Medium severity - This is an operational DoS that temporarily prevents block production during specific consensus state transitions. While it doesn't result in fund theft or permanent damage, it disrupts consensus operations during critical transition periods and causes financial loss to affected miners.

### Likelihood Explanation

**Attacker Capabilities:**
No malicious actor required - this occurs through normal consensus operation.

**Attack Complexity:**
Low - Happens automatically during:
1. Term transitions when miner list changes via elections
2. Miner replacements when evil miners are detected and replaced
3. Any scenario where a miner's GetConsensusCommand succeeds but the round changes before transaction generation

**Feasibility Conditions:**
High likelihood during:
- Election term boundaries (regular occurrence)
- Evil miner detection and replacement operations
- Network conditions causing delays between command and transaction generation

**Detection/Operational Constraints:**
The window is relatively small (milliseconds to seconds between getting command and generating transactions), but term transitions are predictable and scheduled events where this will reliably occur.

**Probability:**
Medium-High - While the timing window is narrow, term transitions happen regularly and predictably, making this scenario inevitable during normal operations.

### Recommendation

**Code-Level Mitigation:**

Add key existence validation before dictionary access in both methods:

In `GetConsensusExtraDataToPublishOutValue` (before line 58):
```csharp
if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
{
    // Miner was removed from round, return appropriate response
    return new AElfConsensusHeaderInformation
    {
        SenderPubkey = ByteStringHelper.FromHexString(pubkey),
        Round = currentRound,
        Behaviour = triggerInformation.Behaviour
    };
}
```

In `GetConsensusExtraDataForTinyBlock` (before line 158):
```csharp
if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
{
    return new AElfConsensusHeaderInformation
    {
        SenderPubkey = ByteStringHelper.FromHexString(pubkey),
        Round = currentRound,
        Behaviour = triggerInformation.Behaviour
    };
}
```

**Invariant Checks:**
Add assertion in `GenerateConsensusTransactions` to validate the extraction result before generating transactions.

**Test Cases:**
1. Test UpdateValue transaction generation when miner is removed between GetConsensusCommand and transaction generation
2. Test TinyBlock transaction generation during miner replacement
3. Test term transition scenarios with concurrent transaction generation attempts
4. Verify proper error handling and graceful degradation when miners are no longer in the round

### Proof of Concept

**Initial State:**
- Miner A is in round N with valid mining permissions
- Term boundary approaching or evil miner detection in progress

**Transaction Steps:**
1. Miner A calls `GetConsensusCommand` at time T1
   - Check at line 26-27 passes (miner is in current round)
   - Returns valid consensus command
2. Another miner produces block with `NextRound` or `NextTerm` at time T2
   - New round N+1 is created with updated miner list
   - Miner A is replaced or removed from `RealTimeMinersInformation`
3. Miner A attempts to generate transactions at time T3
   - Calls `GenerateConsensusTransactions` with their pubkey
   - `GetConsensusBlockExtraData` retrieves round N+1 (current state)
   - `GetConsensusExtraDataToPublishOutValue` accesses `RealTimeMinersInformation[pubkey]`
   - Throws `KeyNotFoundException` because pubkey no longer exists

**Expected Result:**
Transaction generation should handle miner removal gracefully and return appropriate error or empty result.

**Actual Result:**
Unhandled `KeyNotFoundException` causes transaction generation to fail, preventing block production and potentially crashing the consensus service depending on exception propagation.

**Success Condition:**
The exception is thrown and block production fails for the affected miner during their designated time slot.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L20-20)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L29-30)
```csharp
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L58-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L158-163)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L180-187)
```csharp
        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L211-212)
```csharp
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L61-75)
```csharp
    public override TransactionList GenerateConsensusTransactions(BytesValue input)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);
        // Some basic checks.
        Assert(triggerInformation.Pubkey.Any(),
            "Data to request consensus information should contain pubkey.");

        var pubkey = triggerInformation.Pubkey;
        var randomNumber = triggerInformation.RandomNumber;
        var consensusInformation = new AElfConsensusHeaderInformation();
        consensusInformation.MergeFrom(GetConsensusBlockExtraData(input, true).Value);
        var transactionList = GenerateTransactionListByExtraData(consensusInformation, pubkey, randomNumber);
        return transactionList;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L216-244)
```csharp
    public async Task<List<Transaction>> GenerateConsensusTransactionsAsync(ChainContext chainContext)
    {
        _blockTimeProvider.SetBlockTime(_nextMiningTime, chainContext.BlockHash);

        Logger.LogDebug(
            $"Block time of getting consensus system txs: {_nextMiningTime.ToDateTime():hh:mm:ss.ffffff}.");

        var contractReaderContext =
            await _consensusReaderContextService.GetContractReaderContextAsync(chainContext);
        var generatedTransactions =
            (await _contractReaderFactory
                .Create(contractReaderContext)
                .GenerateConsensusTransactions
                .CallAsync(_triggerInformationProvider.GetTriggerInformationForConsensusTransactions(
                    chainContext, _consensusCommand.ToBytesValue())))
            .Transactions
            .ToList();

        // Complete these transactions.
        foreach (var generatedTransaction in generatedTransactions)
        {
            generatedTransaction.RefBlockNumber = chainContext.BlockHeight;
            generatedTransaction.RefBlockPrefix =
                BlockHelper.GetRefBlockPrefix(chainContext.BlockHash);
            Logger.LogDebug($"Consensus transaction generated: \n{generatedTransaction.GetHash()}");
        }

        return generatedTransactions;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L18-18)
```csharp
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return null;
```
