# Audit Report

## Title
Stale BlockHeight Bypass in SetTransactionFeeDelegations Allows Immediate Use of Updated Delegations

## Summary

The `SetTransactionFeeDelegations()` method fails to update the `BlockHeight` field when modifying existing delegation amounts. This bypasses the intended confirmation period security control that prevents same-block delegation usage, allowing delegatees to immediately use increased delegation limits without the required time delay.

## Finding Description

In AElf's fee delegation system, the `SetTransactionFeeDelegations()` method allows a delegatee to register to pay transaction fees on behalf of a delegator. The system includes a security control that requires a confirmation period before delegations can be used - this is enforced by comparing the transaction's `RefBlockNumber` against the delegation's `BlockHeight`.

The vulnerability exists in the update path of `SetTransactionFeeDelegations()`. When a NEW delegatee is added, the method correctly sets the BlockHeight: [1](#0-0) 

However, when an EXISTING delegatee updates their delegation amounts (the else branch), the BlockHeight field is never updated: [2](#0-1) 

The security check in `ChargeFromDelegations()` relies on this BlockHeight field to prevent same-block usage: [3](#0-2) 

This check compares the transaction's RefBlockNumber against the delegation's BlockHeight. If the BlockHeight is stale (not updated during delegation modification), the check incorrectly passes, allowing immediate delegation usage.

The newer `SetTransactionFeeDelegateInfos()` method demonstrates the correct behavior by updating BlockHeight for BOTH add and update operations: [4](#0-3)  and [5](#0-4) 

The protobuf documentation confirms BlockHeight should track "height when added": [6](#0-5) 

## Impact Explanation

This vulnerability bypasses a critical security control designed to prevent same-block manipulation of fee delegations. When a delegatee increases their delegation limits (e.g., from 100 ELF to 10,000 ELF), the stale BlockHeight allows them to use the increased amount immediately in the same block, without waiting for the intended confirmation period.

Example exploit scenario:
- Block 100: Delegation created with {ELF: 100}, BlockHeight = 100
- Block 500: Delegation updated to {ELF: 10,000}, BlockHeight remains 100 (bug)
- Block 500: Transaction with RefBlockNumber = 498 passes the check (498 >= 100), allowing immediate use of 10,000 ELF delegation

This enables:
1. **Atomicity exploitation**: Operations that should require multiple blocks can execute atomically
2. **Front-running scenarios**: Coordinated delegation update and usage in the same block
3. **Security inconsistency**: Different behavior between old and new delegation methods

While this doesn't directly steal funds, it undermines the time-based security control that exists to prevent manipulation and allow for monitoring/intervention between delegation setup and usage.

## Likelihood Explanation

**Medium Likelihood** - The vulnerability is easily triggered through normal contract usage:

1. The method is publicly accessible via RPC: [7](#0-6) 

2. Any delegatee can call `SetTransactionFeeDelegations()` to update their existing delegation amounts

3. The updated delegation can be used immediately if the transaction's RefBlockNumber >= original BlockHeight

4. No special privileges or complex setup required

The inconsistency with `SetTransactionFeeDelegateInfos()` strongly indicates this is a bug rather than intentional design, as the newer method correctly updates BlockHeight in both add and update paths.

## Recommendation

Update the `SetTransactionFeeDelegations()` method to set BlockHeight to `Context.CurrentHeight` when updating existing delegations, matching the behavior of `SetTransactionFeeDelegateInfos()`.

Add the following line in the update path (else branch around line 66):

```csharp
else // This delegatee exists, so update
{
    var delegationsMap = allDelegateesMap[delegateeAddress].Delegations;
    foreach (var (key, value) in delegationsToInput)
    {
        if (value <= 0 && delegationsMap.ContainsKey(key))
        {
            delegationsMap.Remove(key);
        }
        else if (value > 0)
        {
            AssertValidToken(key, value);
            delegationsMap[key] = value;
        }
    }
    
    // ADD THIS LINE TO FIX THE VULNERABILITY
    allDelegateesMap[delegateeAddress].BlockHeight = currentHeight;
    
    // Set and Fire logEvent
    State.TransactionFeeDelegateesMap[input.DelegatorAddress] = allDelegatees;
    // ... rest of the code
}
```

## Proof of Concept

```csharp
[Fact]
public async Task SetTransactionFeeDelegations_Update_BlockHeight_Not_Updated_Test()
{
    // Setup: Create initial delegation at block 100
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "ELF",
        TokenName = "ELF Token",
        TotalSupply = 1000000000,
        Decimals = 8,
        Issuer = DefaultSender,
        IsBurnable = true
    });
    
    // Initial delegation with 100 ELF limit at block 100
    var initialResult = await TokenContractStub.SetTransactionFeeDelegations.SendAsync(
        new SetTransactionFeeDelegationsInput
        {
            DelegatorAddress = DefaultSender,
            Delegations = { {"ELF", 100} }
        });
    
    var initialBlockHeight = initialResult.TransactionResult.BlockNumber;
    
    // Verify BlockHeight is set correctly for initial delegation
    var initialDelegation = await TokenContractStub.GetTransactionFeeDelegationsOfADelegatee.CallAsync(
        new GetTransactionFeeDelegationsOfADelegateeInput
        {
            DelegatorAddress = DefaultSender,
            DelegateeAddress = DelegateeAddress
        });
    initialDelegation.BlockHeight.ShouldBe(initialBlockHeight);
    
    // Move forward 400 blocks
    for (int i = 0; i < 400; i++)
    {
        await TokenContractStub.Transfer.SendAsync(new TransferInput
        {
            To = Address.FromPublicKey(SampleECKeyPairs.KeyPairs[1].PublicKey),
            Symbol = "ELF",
            Amount = 1
        });
    }
    
    // Update delegation to 10000 ELF at block 500
    var updateResult = await TokenContractStub.SetTransactionFeeDelegations.SendAsync(
        new SetTransactionFeeDelegationsInput
        {
            DelegatorAddress = DefaultSender,
            Delegations = { {"ELF", 10000} }
        });
    
    var updateBlockHeight = updateResult.TransactionResult.BlockNumber;
    
    // VULNERABILITY: BlockHeight should be updated to current block (500)
    // but it remains at the original block (100)
    var updatedDelegation = await TokenContractStub.GetTransactionFeeDelegationsOfADelegatee.CallAsync(
        new GetTransactionFeeDelegationsOfADelegateeInput
        {
            DelegatorAddress = DefaultSender,
            DelegateeAddress = DelegateeAddress
        });
    
    // BUG: BlockHeight is still the old value
    updatedDelegation.BlockHeight.ShouldBe(initialBlockHeight); // Still 100, not 500!
    updatedDelegation.Delegations["ELF"].ShouldBe(10000); // Amount is updated
    
    // EXPLOIT: The updated delegation can be used immediately
    // because RefBlockNumber (498-499) >= stale BlockHeight (100)
    var chargeResult = await TokenContractStub.ChargeTransactionFees.SendAsync(
        new ChargeTransactionFeesInput
        {
            MethodName = "Transfer",
            ContractAddress = TokenContractAddress,
            TransactionSizeFee = 1000
        });
    
    // Transaction succeeds using the 10000 ELF delegation immediately
    // without waiting for the confirmation period
    chargeResult.Output.Success.ShouldBe(true);
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L54-54)
```csharp
                allDelegateesMap[delegateeAddress].BlockHeight = currentHeight;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L66-98)
```csharp
        else // This delegatee exists, so update
        {
            var delegationsMap = allDelegateesMap[delegateeAddress].Delegations;
            foreach (var (key, value) in delegationsToInput)
            {
                if (value <= 0 && delegationsMap.ContainsKey(key))
                {
                    delegationsMap.Remove(key);
                }
                else if (value > 0)
                {
                    AssertValidToken(key, value);
                    delegationsMap[key] = value;
                }
            }

            // Set and Fire logEvent
            State.TransactionFeeDelegateesMap[input.DelegatorAddress] = allDelegatees;

            // If a delegatee has no delegations, remove it!
            if (allDelegateesMap[delegateeAddress].Delegations.Count != 0)
                return new SetTransactionFeeDelegationsOutput()
                {
                    Success = true
                };
            State.TransactionFeeDelegateesMap[input.DelegatorAddress].Delegatees.Remove(delegateeAddress);
            Context.Fire(new TransactionFeeDelegationCancelled()
            {
                Caller = Context.Sender,
                Delegatee = Context.Sender,
                Delegator = input.DelegatorAddress
            });
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L263-263)
```csharp
        existDelegateeList.BlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L304-304)
```csharp
        existDelegateInfo.BlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L185-186)
```csharp
            // compare current block height with the block height when the delegatee added
            if (Context.Transaction.RefBlockNumber < delegations.BlockHeight) continue;
```

**File:** protobuf/token_contract.proto (L138-139)
```text
    rpc SetTransactionFeeDelegations (SetTransactionFeeDelegationsInput) returns (SetTransactionFeeDelegationsOutput){
    }
```

**File:** protobuf/token_contract.proto (L664-664)
```text
    // height when added
```
