### Title
Integer Division Rounding Allows Zero Transaction Fee Bypass

### Summary
The `GenerateBill()` function fails to prevent zero-fee transactions when integer division rounding causes `txSizeFeeAmount` to round down to 0. When users pay size fees in alternative tokens with unfavorable weight ratios, the fee conversion calculation can round to zero, allowing transactions to succeed without charging any fee despite users having sufficient balance.

### Finding Description

The vulnerability exists in the transaction size fee calculation and billing logic:

**Root Cause:** At lines 403-404, when converting the transaction size fee from the primary token to an alternative token, integer division is used without rounding protection: [1](#0-0) 

The `Div()` method uses standard integer division that truncates toward zero: [2](#0-1) 

**Why Protections Fail:** When the converted `txSizeFeeAmount` becomes 0 due to rounding, the `GenerateBill()` function at line 525 still succeeds because the condition `availableBalance.Add(availableAllowance) > txSizeFeeAmount` evaluates to true when the user has any balance: [3](#0-2) 

Both `chargeAmount` and `chargeAllowanceAmount` become 0 (lines 536 and 542), resulting in a bill with zero fees. The charging succeeds (returns true at line 417), but no actual fee is deducted because `ModifyBalance` skips amounts ≤ 0: [4](#0-3) 

**Execution Path:**
1. User submits transaction choosing alternative token with small AddedTokenWeight/BaseTokenWeight ratio
2. `ChargeSizeFee()` converts fee: `txSizeFeeAmount = originalFee * AddedTokenWeight / BaseTokenWeight`
3. Integer division rounds down to 0 for small fees or unfavorable ratios
4. `chargeResult = availableBalance + availableAllowance >= 0` evaluates to true (line 417)
5. `GenerateBill()` sets both charge amounts to 0
6. Transaction succeeds with zero fee charged

### Impact Explanation

**Direct Fund Impact:** Users can bypass transaction size fees entirely, breaking the economic model designed to prevent spam and fund network operations. The fee mechanism is a critical protocol invariant.

**Quantified Damage:** 
- For small transactions (< 10 units in primary token) with a 1:10 token ratio: fee rounds to 0
- For transactions (< 100 units) with a 1:100 ratio: fee rounds to 0
- Users retain 100% of intended fee amounts

**Affected Parties:** 
- Network: loses fee revenue and spam protection
- Legitimate users: potential DoS from free spam transactions
- Token economics: fee distribution mechanisms receive no funds

**Severity Justification:** Medium-High. While governance controls token weight ratios, even reasonable ratios (1:10 for lower-value tokens) enable fee bypass for small transactions. This breaks the fundamental fee model.

### Likelihood Explanation

**Attacker Capabilities:** Any user who can submit transactions. No special privileges required beyond choosing which configured token to pay fees with.

**Attack Complexity:** Trivial. User simply selects an alternative payment token and submits a transaction. The system automatically performs the vulnerable conversion.

**Feasibility Conditions:**
- Alternative tokens must be configured via `SetSymbolsToPayTxSizeFee()` (governance-controlled)
- Token weight ratios must cause rounding (e.g., AddedTokenWeight=1, BaseTokenWeight≥10)
- No minimum fee check exists after conversion [5](#0-4) 

**Detection/Operational Constraints:** The validation only checks weights are positive, not that ratios prevent rounding issues. Real-world deployments likely have alternative tokens configured (as shown in tests): [6](#0-5) 

**Probability:** Medium. Requires governance to configure alternative tokens (likely already done), then users simply select the favorable token. No additional attack steps needed.

### Recommendation

**Code-Level Mitigation:**

1. Add minimum fee validation after conversion in `ChargeSizeFee()`:
```csharp
// After line 404
if (txSizeFeeAmount == 0 && input.TransactionSizeFee > 0) {
    // Ensure at least 1 unit is charged if original fee was non-zero
    txSizeFeeAmount = 1;
}
```

2. Alternatively, use ceiling division or require minimum convertible fee amounts:
```csharp
// Replace lines 403-404 with ceiling division
txSizeFeeAmount = (txSizeFeeAmount.Mul(availableSymbol.AddedTokenWeight) 
    .Add(availableSymbol.BaseTokenWeight - 1))
    .Div(availableSymbol.BaseTokenWeight);
```

3. Add validation in `SetSymbolsToPayTxSizeFee()` to prevent ratios that could cause problematic rounding:
```csharp
// After line 635
Assert(tokenWeightInfo.AddedTokenWeight >= tokenWeightInfo.BaseTokenWeight / 100,
    $"Weight ratio too small, may cause rounding to zero");
```

**Invariant Checks:**
- `txSizeFeeAmount` after conversion must be > 0 if original fee > 0
- Total charged amount in bill must equal or exceed minimum fee threshold
- Add test cases with extreme weight ratios and small transaction sizes

### Proof of Concept

**Initial State:**
- Governance has configured alternative token "LOWVAL" with AddedTokenWeight=1, BaseTokenWeight=10
- User has 100 LOWVAL tokens
- Transaction size fee in primary token (ELF) = 9 units

**Attack Steps:**
1. User submits transaction specifying LOWVAL as fee payment token
2. System calculates: `txSizeFeeAmount = 9 * 1 / 10 = 0` (integer division)
3. `ChargeSizeFee()` checks: `100 + 0 >= 0` → true (line 417)
4. `GenerateBill()` checks: `100 + 0 > 0` → true (line 525)
5. Sets: `chargeAllowanceAmount = 0`, `chargeAmount = 0` (lines 535-536)
6. `ModifyBalance()` skips amount=0 (line 247)
7. Transaction completes successfully

**Expected Result:** User pays 9 ELF equivalent in LOWVAL (should be at least 1 LOWVAL rounded up)

**Actual Result:** User pays 0 LOWVAL, transaction succeeds, fee bypass complete

**Success Condition:** Transaction status = Success, user balance unchanged, no TransactionFeeCharged event emitted for LOWVAL

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L245-248)
```csharp
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            ModifyBalance(fromAddress, symbol, -amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L403-404)
```csharp
                txSizeFeeAmount = txSizeFeeAmount.Mul(availableSymbol.AddedTokenWeight)
                    .Div(availableSymbol.BaseTokenWeight);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L525-543)
```csharp
        if (availableBalance.Add(availableAllowance) > txSizeFeeAmount)
        {
            // Allowance > size fee, all allowance
            if (availableAllowance > txSizeFeeAmount)
            {
                chargeAllowanceAmount = txSizeFeeAmount;
            }
            else
            {
                // Allowance is not enough
                chargeAllowanceAmount = availableAllowance;
                chargeAmount = txSizeFeeAmount.Sub(chargeAllowanceAmount);
            }
        }
        else
        {
            chargeAllowanceAmount = availableAllowance;
            chargeAmount = availableBalance;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L634-635)
```csharp
            Assert(tokenWeightInfo.AddedTokenWeight > 0 && tokenWeightInfo.BaseTokenWeight > 0,
                $"symbol:{tokenWeightInfo.TokenSymbol} weight should be greater than 0");
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/ACS2_TokenResourceTests.cs (L109-114)
```csharp
        newSymbolList.SymbolsToPayTxSizeFee.Add(new SymbolToPayTxSizeFee
        {
            TokenSymbol = "CPU",
            AddedTokenWeight = 2,
            BaseTokenWeight = 1
        });
```
