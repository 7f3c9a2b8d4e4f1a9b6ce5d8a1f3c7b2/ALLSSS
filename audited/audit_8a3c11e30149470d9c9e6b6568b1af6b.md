### Title
Missing Array Size Limit in Batch Transfer Blacklist Operations Enables Resource Exhaustion DoS

### Summary
The `BatchRemoveFromTransferBlackList()` and `BatchAddToTransferBlackList()` functions lack maximum array size validation, unlike the similar `BatchApprove()` function which enforces a configurable limit. This inconsistency allows governance to accidentally approve excessively large batch operations that could exceed AElf's execution thresholds, causing transaction failures and operational DoS of critical blacklist management functionality.

### Finding Description
**Location:**
- `BatchRemoveFromTransferBlackList()` [1](#0-0) 
- `BatchAddToTransferBlackList()` [2](#0-1) 

**Root Cause:**
Both batch blacklist functions only validate that the input array is not null and has at least one element (`Count > 0`), but impose no upper bound. Each function performs:
1. A validation loop iterating through all addresses
2. A deduplication operation (`.Distinct().ToList()`)
3. A state update loop for all unique addresses

In contrast, `BatchApprove()` enforces a size limit [3](#0-2) , checking against a configurable maximum with a default of 100 [4](#0-3) .

**Why Existing Protections Fail:**
AElf enforces execution thresholds to prevent unbounded computation [5](#0-4) , with both call and branch thresholds set to 15,000. However, these thresholds only cause transaction failure when exceeded—they don't prevent governance from proposing operations that will fail. Without an explicit size check, a large array (e.g., 10,000+ addresses) could:
- Exceed execution call thresholds during iteration loops
- Consume excessive computational resources during deduplication
- Cause the governance transaction to fail after approval effort is wasted

**Execution Path:**
1. Governance (Parliament) creates a proposal containing a large address array
2. Proposal gets approved through standard governance process (2/3 miner approval)
3. Proposal execution attempts to process the large array
4. Transaction exceeds execution thresholds and fails
5. Blacklist management is blocked until a new proposal with smaller batches is created and approved

### Impact Explanation
**Operational Impact:**
- **Governance DoS**: Critical blacklist management operations fail when accidentally large batches are approved, requiring time-consuming re-proposals with smaller sizes
- **Resource Waste**: Miners waste computational resources and transaction fees on failed governance operations
- **Security Response Degradation**: Emergency blacklist operations (e.g., freezing compromised addresses) are delayed if initial batch size is too large

**Who is Affected:**
- Governance system (Parliament) attempting blacklist management
- Protocol operations requiring timely blacklist updates
- System security response capabilities

**Severity Justification (MEDIUM):**
While this requires governance approval rather than direct attacker exploitation, it represents a real operational risk with concrete impact. The inconsistency with `BatchApprove()` indicates this is an oversight rather than intentional design. The lack of protection could cause governance failures in production scenarios, particularly during emergency responses requiring large-scale blacklist updates.

### Likelihood Explanation
**Governance Capabilities Required:**
Both functions require authorized governance execution [6](#0-5)  and Parliament approval [7](#0-6) .

**Realistic Scenario:**
1. A governance proposal is created to batch-update blacklist entries
2. The proposal includes a large address list (e.g., from automated processing or bulk operations)
3. Miners review and approve the proposal through standard governance (2/3 approval)
4. Upon execution, the transaction fails due to exceeding execution thresholds
5. Governance must restart the process with smaller batches

**Feasibility:**
- **Attack Complexity**: None—this is a genuine operational risk, not an attack
- **Detection**: Transaction failure is observable but only after governance approval effort is wasted
- **Probability**: MEDIUM—governance operations with large datasets are realistic, especially during security incidents requiring bulk blacklist updates

**Operational Constraints:**
Existing tests only use small arrays (2-3 addresses) [8](#0-7) , indicating no consideration for large-scale batch operations or stress testing with realistic array sizes.

### Recommendation
**Code-Level Mitigation:**
Add explicit array size validation matching the `BatchApprove()` pattern:

```csharp
public override Empty BatchRemoveFromTransferBlackList(BatchRemoveFromTransferBlackListInput input)
{
    AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
    Assert(input != null && input.Addresses != null && input.Addresses.Count > 0, "Invalid input.");
    // ADD THIS CHECK:
    Assert(input.Addresses.Count <= GetMaxBatchApproveCount(), 
           "Exceeds the maximum batch operation count.");
    
    // ... rest of function
}
```

Apply the same check to `BatchAddToTransferBlackList()` at line 865.

**Invariant Checks:**
- Enforce maximum batch size constraint before processing
- Ensure consistency with other batch operations (`BatchApprove`)
- Consider making the limit configurable via governance if different from approve operations

**Test Cases:**
1. Test with array size at limit (should succeed)
2. Test with array size exceeding limit (should fail with clear error)
3. Stress test with maximum allowed size to verify execution threshold compliance
4. Test governance proposal flow with limit-respecting arrays

### Proof of Concept
**Initial State:**
- Parliament governance is initialized with default organization
- Multiple addresses need to be removed from transfer blacklist

**Exploitation Steps:**
1. Create governance proposal with `BatchRemoveFromTransferBlackList` containing 15,000 addresses
2. Get 2/3 miner approval through standard Parliament voting
3. Execute `ParliamentContract.Release()` on the approved proposal
4. Observe transaction failure due to exceeding `ExecutionCallThreshold` (15,000 iterations)

**Expected Result:** Transaction should succeed with all addresses removed from blacklist

**Actual Result:** Transaction fails with execution threshold exceeded error, governance effort wasted, blacklist management blocked until new proposal with smaller batches

**Success Condition:** With the recommended fix, the proposal creation would fail validation immediately, preventing wasted governance effort and clearly indicating the need for smaller batch sizes.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L283-298)
```csharp
    public override Empty BatchApprove(BatchApproveInput input)
    {
        Assert(input != null && input.Value != null && input.Value.Count > 0, "Invalid input .");
        Assert(input.Value.Count <= GetMaxBatchApproveCount(), "Exceeds the max batch approve count.");
        foreach (var approve in input.Value)
        {
            AssertValidInputAddress(approve.Spender);
            var actualSymbol = GetActualTokenSymbol(approve.Symbol);
            AssertValidApproveTokenAndAmount(actualSymbol, approve.Amount);
        }
        var approveInputList = input.Value.GroupBy(approve => approve.Symbol + approve.Spender, approve => approve)
            .Select(approve => approve.Last()).ToList();
        foreach (var approve in approveInputList)
            Approve(approve.Spender, approve.Symbol, approve.Amount);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L862-881)
```csharp
    public override Empty BatchAddToTransferBlackList(BatchAddToTransferBlackListInput input)
    {
        AssertControllerForTransferBlackList();
        Assert(input != null && input.Addresses != null && input.Addresses.Count > 0, "Invalid input.");
        
        // Validate all addresses first
        foreach (var address in input.Addresses)
        {
            Assert(address != null && !address.Value.IsNullOrEmpty(), "Invalid address.");
        }
        
        // Remove duplicates and add to blacklist
        var uniqueAddresses = input.Addresses.Distinct().ToList();
        foreach (var address in uniqueAddresses)
        {
            State.TransferBlackList[address] = true;
        }
        
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L893-914)
```csharp
    public override Empty BatchRemoveFromTransferBlackList(BatchRemoveFromTransferBlackListInput input)
    {
        // Removing from transfer blacklist requires higher security and response speed is not critical, 
        // so it should be controlled by Parliament.
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        Assert(input != null && input.Addresses != null && input.Addresses.Count > 0, "Invalid input.");
        
        // Validate all addresses first
        foreach (var address in input.Addresses)
        {
            Assert(address != null && !address.Value.IsNullOrEmpty(), "Invalid address.");
        }
        
        // Remove duplicates and remove from blacklist
        var uniqueAddresses = input.Addresses.Distinct().ToList();
        foreach (var address in uniqueAddresses)
        {
            State.TransferBlackList[address] = false;
        }
        
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L27-27)
```csharp
    public const int DefaultMaxBatchApproveCount = 100;
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-7)
```csharp
    public const int ExecutionCallThreshold = 15000;

    public const int ExecutionBranchThreshold = 15000;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L415-419)
```csharp
    private void AssertControllerForTransferBlackList()
    {
        var controller = GetTransferBlackListController();
        Assert(Context.Sender == controller.OwnerAddress, "No permission");
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenApplicationTests.cs (L2422-2428)
```csharp
        var batchRemoveProposalId = await CreateProposalAsync(TokenContractAddress, defaultParliament, 
            nameof(TokenContractStub.BatchRemoveFromTransferBlackList), new BatchRemoveFromTransferBlackListInput
            {
                Addresses = { User1Address, User2Address }
            });
        await ApproveWithMinersAsync(batchRemoveProposalId);
        await ParliamentContractStub.Release.SendAsync(batchRemoveProposalId);
```
