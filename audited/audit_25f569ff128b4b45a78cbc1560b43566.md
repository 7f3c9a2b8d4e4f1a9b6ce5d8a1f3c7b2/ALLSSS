### Title
State Size Limit Causes Side Chain Creation Failure with Large Miner Lists

### Summary
When the parent chain has approximately 2,500-3,500+ miners, the `ChainInitializationData` (which includes the serialized miner list) exceeds the 128KB state size limit, causing `CreateSideChain` transactions to fail with `StateOverSizeException`. This prevents legitimate side chain initialization even though the miner count itself is governance-approved, creating a denial-of-service condition for cross-chain functionality.

### Finding Description

The vulnerability occurs in the cross-chain side chain creation flow:

1. **Serialization occurs in GetChainInitializationInformation()**: The function serializes the current miner list into a `ByteString` using `ToByteString()` [1](#0-0) 

2. **Data is retrieved for side chain initialization**: The CrossChain contract calls `GetChainInitializationInformation` to obtain consensus information [2](#0-1) 

3. **Data is assembled into ChainInitializationData**: The serialized miner list becomes part of `ChainInitializationConsensusInfo` within the larger `ChainInitializationData` structure [3](#0-2) 

4. **State write exceeds size limit**: The complete `ChainInitializationData` is stored in contract state, which triggers size validation [4](#0-3) 

5. **StateOverSizeException is thrown**: The state size validation checks if the serialized object exceeds the 128KB limit (131,072 bytes) and throws an exception if it does [5](#0-4)  The state size limit is defined as 128KB [6](#0-5) 

**Size calculation**: Each compressed public key is 33 bytes. With protobuf overhead (~35 bytes per miner) and other data in `ChainInitializationData` (token info, resource info, ~40KB), the miner list can use approximately 90KB. This allows for roughly 2,500-2,600 miners before exceeding the 128KB limit.

**Root cause**: There is no validation in `SetMaximumMinersCount` to ensure the maximum won't break cross-chain functionality [7](#0-6)  The only check is that the value is greater than zero, with no upper bound validation.

Additionally, `CreateSideChain` does not validate the size of `ChainInitializationData` before attempting to store it [8](#0-7) 

### Impact Explanation

**Concrete harm**:
- Complete denial-of-service of side chain creation functionality on the parent chain
- Legitimate side chains cannot be initialized or bootstrapped
- No workaround exists except reducing the miner count (requires governance action and time)
- Breaks a core cross-chain capability of the AElf ecosystem

**Who is affected**:
- Users and projects attempting to create new side chains
- Existing governance that approved high miner counts for decentralization without awareness of this limitation
- The broader AElf cross-chain ecosystem's expansion capability

**Severity justification (Medium)**:
- **High Impact**: Completely breaks side chain creation functionality
- **Medium Likelihood**: Requires governance to set MaximumMinersCount to a value that leads to 2,500+ miners, which is not immediately obvious as problematic
- Current typical values (17-100 miners) are safe, but no preventative measures exist

### Likelihood Explanation

**Preconditions**:
1. Governance uses `SetMaximumMinersCount` to set a high maximum (e.g., 5,000 or 10,000) with the intention of supporting greater decentralization
2. The network grows over time to approach or exceed ~2,500-3,500 active miners
3. A user or project attempts to create a side chain via `RequestSideChainCreation` followed by governance approval and `CreateSideChain`

**Attacker capabilities**: This is not an attack by malicious actors, but rather an operational failure resulting from:
- Well-intentioned governance decisions to increase decentralization
- Lack of validation in the miner count setting mechanism
- Natural network growth over time

**Feasibility**: 
- **Reachable**: Yes, through normal governance and side chain creation flows
- **Practical**: The scenario becomes increasingly likely as the network scales and governance seeks greater decentralization
- **No immediate warning**: The issue only manifests when attempting side chain creation, not when setting MaximumMinersCount

**Detection**: The failure is visible (StateOverSizeException in transaction execution logs), but by the time it occurs, remediation requires governance action to reduce miner count.

### Recommendation

**Immediate mitigations**:

1. **Add size validation in CreateSideChain before state storage**:
   ```csharp
   var chainInitializationData = GetChainInitializationData(sideChainInfo, sideChainCreationRequest);
   var serializedSize = chainInitializationData.ToByteArray().Length;
   Assert(serializedSize <= SmartContractConstants.StateSizeLimit, 
          $"Chain initialization data size {serializedSize} exceeds state limit");
   State.SideChainInitializationData[sideChainInfo.SideChainId] = chainInitializationData;
   ```

2. **Add upper bound validation in SetMaximumMinersCount**:
   Calculate safe maximum based on state size limit (recommend ~2,000 miners as safe threshold):
   ```csharp
   Assert(input.Value <= 2000, "Maximum miners count exceeds safe limit for cross-chain operations");
   ```

3. **Add documentation**: Document the relationship between miner count and cross-chain data size limits in governance proposals.

**Test cases**:
- Test `CreateSideChain` with various miner list sizes (100, 1000, 2500, 3000)
- Test `SetMaximumMinersCount` rejects values above safe threshold
- Integration test simulating high miner count scenario end-to-end

### Proof of Concept

**Initial state**:
- Main chain operational with normal configuration
- Governance organization authorized to call `SetMaximumMinersCount`

**Exploit sequence**:

1. **Governance sets high maximum miners count**:
   - Parliament proposal to call `SetMaximumMinersCount` with value 5000
   - Proposal approved and released
   - Transaction executes successfully (no validation prevents this)

2. **Network grows to high miner count**:
   - Over time, the network naturally grows as `GetAutoIncreasedMinersCount()` increases based on `MinerIncreaseInterval`
   - Current miner count reaches ~3,000 miners
   - GetCurrentMinerList now returns a MinerList with 3,000 public keys

3. **Attempt to create side chain**:
   - User calls `RequestSideChainCreation` with valid parameters
   - Governance approves the proposal
   - User/governance calls `ReleaseSideChainCreation` which triggers `CreateSideChain`

**Expected result**: Side chain created successfully with ID returned

**Actual result**: Transaction fails with `StateOverSizeException`:
```
State size [~135000] exceeds limit of [131072]
```

The transaction reverts, no side chain is created, and the operation cannot succeed until the miner count is reduced through governance action.

**Success condition for vulnerability**: Transaction failure occurs due to state size exceeded, despite all other parameters being valid and governance-approved.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L17-21)
```csharp
            Value = new MinerListWithRoundNumber
            {
                MinerList = GetCurrentMinerList(new Empty()),
                RoundNumber = State.CurrentRoundNumber.Value
            }.ToByteString()
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L218-224)
```csharp
    private ByteString GetInitialConsensusInformation()
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var miners = State.CrossChainInteractionContract.GetChainInitializationInformation.Call(new BytesValue());
        return miners.Value;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L530-532)
```csharp
        var initialConsensusInfo = GetInitialConsensusInformation();
        res.ChainInitializationConsensusInfo = new ChainInitializationConsensusInfo
            { InitialConsensusData = initialConsensusInfo };
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L121-167)
```csharp
    public override Int32Value CreateSideChain(CreateSideChainInput input)
    {
        // side chain creation should be triggered by organization address.
        AssertSideChainLifetimeControllerAuthority(Context.Sender);

        var proposedSideChainCreationRequestState = State.ProposedSideChainCreationRequestState[input.Proposer];
        State.ProposedSideChainCreationRequestState.Remove(input.Proposer);
        var sideChainCreationRequest = input.SideChainCreationRequest;
        Assert(
            proposedSideChainCreationRequestState != null &&
            proposedSideChainCreationRequestState.SideChainCreationRequest.Equals(sideChainCreationRequest),
            "Side chain creation failed without proposed data.");
        AssertValidSideChainCreationRequest(sideChainCreationRequest, input.Proposer);

        State.SideChainSerialNumber.Value = State.SideChainSerialNumber.Value.Add(1);
        var serialNumber = State.SideChainSerialNumber.Value;
        var chainId = GetChainId(serialNumber);
        State.AcceptedSideChainCreationRequest[chainId] = sideChainCreationRequest;

        // lock token
        ChargeSideChainIndexingFee(input.Proposer, sideChainCreationRequest.LockedTokenAmount, chainId);

        var sideChainInfo = new SideChainInfo
        {
            Proposer = input.Proposer,
            SideChainId = chainId,
            SideChainStatus = SideChainStatus.Active,
            IndexingPrice = sideChainCreationRequest.IndexingPrice,
            IsPrivilegePreserved = sideChainCreationRequest.IsPrivilegePreserved,
            CreationTimestamp = Context.CurrentBlockTime,
            CreationHeightOnParentChain = Context.CurrentHeight,
            IndexingFeeController = CreateDefaultOrganizationForIndexingFeePriceManagement(input.Proposer)
        };
        State.SideChainInfo[chainId] = sideChainInfo;
        State.CurrentSideChainHeight[chainId] = 0;

        var chainInitializationData =
            GetChainInitializationData(sideChainInfo, sideChainCreationRequest);
        State.SideChainInitializationData[sideChainInfo.SideChainId] = chainInitializationData;

        Context.Fire(new SideChainCreatedEvent
        {
            ChainId = chainId,
            Creator = input.Proposer
        });
        return new Int32Value { Value = chainId };
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L148-159)
```csharp
    public object ValidateStateSize(object obj)
    {
        var stateSizeLimit = AsyncHelper.RunSync(() => _smartContractBridgeService.GetStateSizeLimitAsync(
            new ChainContext
            {
                BlockHash = _transactionContext.PreviousBlockHash,
                BlockHeight = _transactionContext.BlockHeight - 1
            }));
        var size = SerializationHelper.Serialize(obj).Length;
        if (size > stateSizeLimit)
            throw new StateOverSizeException($"State size {size} exceeds limit of {stateSizeLimit}.");
        return obj;
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```
