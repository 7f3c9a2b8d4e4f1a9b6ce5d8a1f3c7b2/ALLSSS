### Title
DepositBalance Accounting Underflow in Sell() Due to Virtual Balance Pricing Discrepancy

### Summary
The TokenConverter's `Sell()` function calculates return amounts using Bancor pricing that includes both virtual and real deposit balances, but only subtracts from the real `DepositBalance` state variable. When deposit connectors have large virtual balances (e.g., 10,000,000 tokens) and relatively small real deposits, the calculated `amountToReceive` can exceed the real `DepositBalance`, causing SafeMath to throw an `OverflowException` and reverting the transaction. This creates a denial-of-service condition where users cannot sell resource tokens even though the pricing mechanism suggests they should be able to.

### Finding Description

**Exact Location:** [1](#0-0) 

**Root Cause:**
Deposit connectors (where `IsDepositAccount=true`) are initialized with both a `VirtualBalance` and a real `DepositBalance`. The system uses virtual balances to bootstrap liquidity and affect pricing without requiring full token deposits. [2](#0-1) 

The critical flaw occurs in the Bancor pricing calculation. When calculating sell returns, `GetSelfBalance()` is called which returns the sum of virtual and real balances for deposit accounts: [3](#0-2) 

The Bancor formula uses this combined balance to calculate `amountToReceive`: [4](#0-3) 

However, the subsequent accounting update only subtracts from the **real** `DepositBalance`, completely ignoring that the virtual balance was included in the pricing: [1](#0-0) 

**Why Protections Fail:**
SafeMath's `Sub()` operation uses C#'s `checked` arithmetic, which throws an `OverflowException` when the subtraction would result in a negative value: [5](#0-4) 

While this prevents silent underflow corruption, it converts the accounting bug into a denial-of-service vulnerability where legitimate sell transactions revert.

**Execution Path:**
1. Deposit connector initialized with `VirtualBalance=10_000_000_00000000` and small real deposit (e.g., 1,000 from `GetNeededDeposit`)
2. User sells resource tokens
3. `GetSelfBalance(toConnector)` returns 10,000,000,001,000 (virtual + real)
4. Bancor calculates `amountToReceive` based on this inflated balance
5. If `amountToReceive > realDepositBalance`, the `Sub()` throws `OverflowException`
6. Transaction reverts with error

### Impact Explanation

**Operational Impact - Critical DoS:**
- **Sell Operations Blocked:** Users who purchased resource tokens cannot sell them back when the calculated return exceeds the real deposit balance. This creates a trap where tokens can be bought but not sold.
- **Fund Lockup:** User capital becomes locked in resource tokens with no exit path through the TokenConverter.
- **Protocol Functionality Broken:** The core buy/sell mechanism fails, preventing the Bancor-based resource token market from functioning properly.

**Affected Parties:**
- Resource token holders who cannot exit their positions
- The broader ecosystem relying on functional resource token markets
- System integrity as the virtual balance mechanism is fundamentally incompatible with the accounting system

**Severity Justification:**
This is **Critical** because it causes complete denial-of-service of a core protocol function (token selling) under normal operating conditions with standard configuration values. The virtual balances used in production are extremely large (10 million tokens), making this highly likely to occur. [6](#0-5) 

### Likelihood Explanation

**Reachable Entry Point:**
The `Sell()` function is a public method callable by any user with resource tokens: [7](#0-6) 

**Feasible Preconditions:**
- Deposit connectors are initialized with `IsVirtualBalanceEnabled=true` by default in production
- Virtual balances are set to 10,000,000 tokens (100 million with 8 decimals)
- Real deposit balances start small and grow only through buy operations
- No special attacker privileges required - any token holder can trigger this

**Execution Practicality:**
The vulnerability occurs naturally during normal protocol usage:
1. Initial state after `EnableConnector`: small real deposit (calculated by `GetNeededDeposit`), large virtual balance
2. User attempts to sell a moderate to large amount of resource tokens
3. If the Bancor-calculated return exceeds the real deposit balance, the transaction reverts
4. This can occur even with the contract holding sufficient base tokens for the transfer

**Economic Rationality:**
- No attack cost - occurs during legitimate use
- Affects all users equally
- Cannot be prevented by users since pricing is determined by the formula

**Detection:**
Transaction failures will be visible as `OverflowException` errors, making the issue easily detectable but difficult to resolve without a contract upgrade.

### Recommendation

**Immediate Fix:**
Modify the accounting to properly handle virtual balances. Either:

**Option 1 - Separate Virtual Balance Tracking:**
Track virtual balance consumption separately and ensure `DepositBalance` only reflects real deposits. Modify `GetSelfBalance()` to use a different calculation for pricing vs accounting.

**Option 2 - Add Validation Check:**
Before the subtraction, validate that `DepositBalance >= amountToReceive`:

```csharp
// In Sell() function, before line 193:
Assert(State.DepositBalance[toConnector.Symbol] >= amountToReceive, 
       "Insufficient deposit balance for sell operation");
```

However, this would still result in DoS, just with a clearer error message.

**Option 3 - Remove Virtual Balance from Sell Calculations (Recommended):**
Modify the pricing calculation to exclude virtual balance when computing sell returns, or adjust the virtual balance proportionally:

```csharp
// For sell operations, use only real balance or pro-rata adjust
long effectiveBalance = State.DepositBalance[toConnector.Symbol];
// If virtual balance is needed for liquidity bootstrapping,
// it should only apply to buy operations, not sells
```

**Invariant to Add:**
```csharp
// After any DepositBalance modification:
Assert(State.DepositBalance[connector.Symbol] >= 0, 
       "Deposit balance cannot be negative");
// Before subtraction:
Assert(State.DepositBalance[connector.Symbol] >= amountToSubtract,
       "Insufficient deposit balance");
```

**Test Cases:**
1. Test sell operations when `amountToReceive > DepositBalance` (should handle gracefully)
2. Test with large virtual balance (10M) and small real deposit (1000)
3. Test buy-sell cycles to ensure deposit balance remains consistent
4. Test boundary condition where deposit balance equals calculated return

### Proof of Concept

**Initial State:**
1. Deploy TokenConverter with deposit connector having:
   - `VirtualBalance = 10_000_000_00000000` (10 million tokens)
   - `IsVirtualBalanceEnabled = true`
   - `IsDepositAccount = true` [2](#0-1) 

2. Call `EnableConnector` which sets `State.DepositBalance[toConnector.Symbol]` to a small value (e.g., 1,000 tokens) based on `GetNeededDeposit` calculation [8](#0-7) 

**Exploitation Steps:**
1. User attempts to sell 50,000 resource tokens via `Sell()`
2. System calculates: `GetSelfBalance(toConnector) = 10_000_000_00000000 + 1000 = 10_000_000_00001000`
3. Bancor formula calculates `amountToReceive` based on this total (could be 5,000 tokens depending on weights)
4. Transfer of base tokens succeeds (contract has sufficient balance)
5. System attempts: `State.DepositBalance[toConnector.Symbol].Sub(5000)` where `DepositBalance = 1000`
6. SafeMath.Sub() throws `OverflowException` because `1000 - 5000 < 0`

**Expected Result:**
Transaction should succeed with proper accounting

**Actual Result:**
Transaction reverts with `OverflowException`, user cannot sell tokens, funds locked

**Success Condition for Exploit:**
Any sell operation where `BancorCalculatedReturn > RealDepositBalance` will fail, which occurs naturally with large virtual balances and small real deposits.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-161)
```csharp
    public override Empty Sell(SellInput input)
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L297-297)
```csharp
        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L240-249)
```csharp
            var nativeTokenConnector = new Connector
            {
                Symbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
                RelatedSymbol = resourceTokenSymbol,
                IsDepositAccount = true
            };
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-97)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L20-20)
```csharp
    public const long NativeTokenToResourceBalance = 10_000_000_00000000;
```
