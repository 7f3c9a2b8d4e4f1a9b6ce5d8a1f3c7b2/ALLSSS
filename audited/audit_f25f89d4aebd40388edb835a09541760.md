### Title
Token Issuer and Owner Modifications Never Persist to Storage

### Summary
The `ModifyTokenIssuerAndOwner()` function modifies the `tokenInfo.Issuer` and `tokenInfo.Owner` fields in memory but fails to call `SetTokenInfo()` to persist these changes to contract state. This renders the function completely non-operational, creating a DoS condition for token governance operations that depend on changing issuer or owner after token creation.

### Finding Description

The vulnerability exists in `ModifyTokenIssuerAndOwner()` function: [1](#0-0) 

The function retrieves `tokenInfo` from storage, modifies the `Issuer` and `Owner` fields at lines 655-656, but returns without persisting these changes. In AElf's contract state model, reading from `State.TokenInfos[symbol]` returns a deserialized copy. Modifications to this copy must be explicitly written back using either `SetTokenInfo(tokenInfo)` or direct state assignment. [2](#0-1) 

The `SetTokenInfo()` helper exists specifically for this persistence operation. The contract consistently follows this pattern in other functions that modify token information:

- `Issue()` calls `SetTokenInfo()` after modifying `Issued` and `Supply`: [3](#0-2) 

- `CrossChainReceiveToken()` calls `SetTokenInfo()` after modifying `Supply`: [4](#0-3) 

- `SetSymbolAlias()` calls `SetTokenInfo()` after modifying `ExternalInfo`: [5](#0-4) 

The state storage documentation explicitly warns about this requirement: [6](#0-5) 

The test suite only validates error conditions and never verifies the success case: [7](#0-6) 

### Impact Explanation

**Authorization Control Failure**: The `issuer` field (TokenInfo line 262) controls who can issue additional tokens, while the `owner` field (TokenInfo line 272) controls privileged token operations. The inability to modify these fields means tokens cannot transfer governance control after creation.

**Operational DoS**: Any operational flow depending on issuer/owner modification is completely blocked. For example, if a token is created with a temporary issuer address that will be deprecated, there is no functional way to update it to a permanent issuer.

**Bricked Tokens Scenario**: If a token issuer calls this function expecting it to work (it returns success with no error), then loses access to the old issuer address before discovering the change never persisted, the token becomes permanently stuck with an inaccessible issuer, preventing any future token issuance.

**Affected Parties**: All token creators who need to modify issuer or owner after creation, particularly in multi-sig or organizational governance scenarios where control transfer is required.

### Likelihood Explanation

**Certainty**: 100% - The function never persists changes under any circumstance. Every invocation fails to achieve its intended purpose.

**Reachability**: The function is a public RPC endpoint callable by any address that is the current token issuer for a token without an owner set.

**Preconditions**: Only requires that a token exists and the caller is its current issuer, with no owner previously set - these are normal operational conditions.

**Detection**: The bug is silent - the function returns success (Empty) with no error, making it appear to work while actually failing. Users only discover the failure later when attempting operations with the supposedly-updated issuer/owner.

**Complexity**: Zero complexity - simply calling the function demonstrates it doesn't work. No special attack sequence required.

### Recommendation

**Immediate Fix**: Add `SetTokenInfo(tokenInfo)` before the return statement:

```csharp
public override Empty ModifyTokenIssuerAndOwner(ModifyTokenIssuerAndOwnerInput input)
{
    // ... existing validation logic ...
    
    tokenInfo.Issuer = input.Issuer;
    tokenInfo.Owner = input.Owner;
    
    SetTokenInfo(tokenInfo);  // ADD THIS LINE
    
    return new Empty();
}
```

**Invariant Check**: Add assertion in test suite verifying that after calling `ModifyTokenIssuerAndOwner()`, subsequent `GetTokenInfo()` calls return the updated issuer and owner values.

**Regression Prevention**: Add integration test covering the success path:
1. Create token with issuer A and no owner
2. Call `ModifyTokenIssuerAndOwner()` to set issuer B and owner C
3. Verify `GetTokenInfo()` shows issuer B and owner C
4. Verify issuer B can now issue tokens while issuer A cannot

### Proof of Concept

**Initial State**: Token "TEST" exists with issuer = Alice, owner = null

**Transaction Steps**:
1. Alice calls `ModifyTokenIssuerAndOwner(symbol: "TEST", issuer: Bob, owner: Charlie)`
2. Transaction succeeds with status OK
3. Call `GetTokenInfo("TEST")`

**Expected Result**: TokenInfo shows issuer = Bob, owner = Charlie

**Actual Result**: TokenInfo shows issuer = Alice (unchanged), owner = null (unchanged)

**Success Condition**: After step 1, Bob should be able to call `Issue()` successfully while Alice should receive "Sender is not allowed to issue token" error. Currently Alice retains issuance rights because the issuer change never persisted.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L163-167)
```csharp
        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L620-622)
```csharp
        tokenInfo.Supply = tokenInfo.Supply.Add(amount);
        Assert(tokenInfo.Supply <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L642-659)
```csharp
    public override Empty ModifyTokenIssuerAndOwner(ModifyTokenIssuerAndOwnerInput input)
    {
        Assert(!State.TokenIssuerAndOwnerModificationDisabled.Value, "Set token issuer and owner disabled.");
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        Assert(input.Issuer != null && !input.Issuer.Value.IsNullOrEmpty(), "Invalid input issuer.");
        Assert(input.Owner != null && !input.Owner.Value.IsNullOrEmpty(), "Invalid input owner.");

        var tokenInfo = GetTokenInfo(input.Symbol);

        Assert(tokenInfo != null, "Token is not found.");
        Assert(tokenInfo.Issuer == Context.Sender, "Only token issuer can set token issuer and owner.");
        Assert(tokenInfo.Owner == null, "Can only set token which does not have owner.");
        
        tokenInfo.Issuer = input.Issuer;
        tokenInfo.Owner = input.Owner;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L763-766)
```csharp
        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L418-422)
```csharp
    private void SetTokenInfo(TokenInfo tokenInfo)
    {
        var symbol = tokenInfo.Symbol;
        State.TokenInfos[symbol] = tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L12-16)
```csharp
    /// <summary>
    /// WARNING: Use GetTokenInfo & SetTokenInfo to operate TokenInfos
    /// due to token symbol alias feature.
    /// </summary>
    public MappedState<string, TokenInfo> TokenInfos { get; set; }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenApplicationTests.cs (L1826-1900)
```csharp
    [Fact]
    public async Task TokenIssuerAndOwnerModification_Test()
    {
        var result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput());
        result.TransactionResult.Error.ShouldContain("Invalid input symbol.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = "TEST"
        });
        result.TransactionResult.Error.ShouldContain("Invalid input issuer.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = "TEST",
            Issuer = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Invalid input owner.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = "TEST",
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Token is not found.");
        
        result = await TokenContractStubUser.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = DefaultSymbol,
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Only token issuer can set token issuer and owner.");
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = DefaultSymbol,
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Can only set token which does not have owner.");
        
        var output = await TokenContractStub.GetTokenIssuerAndOwnerModificationEnabled.CallAsync(new Empty());
        output.Value.ShouldBeTrue();
        
        result = await TokenContractStub.SetTokenIssuerAndOwnerModificationEnabled.SendWithExceptionAsync(
            new SetTokenIssuerAndOwnerModificationEnabledInput
            {
                Enabled = false
            });
        result.TransactionResult.Error.ShouldContain("Unauthorized behavior.");
        
        var defaultParliament = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
        var proposalId = await CreateProposalAsync(TokenContractAddress,
            defaultParliament, nameof(TokenContractStub.SetTokenIssuerAndOwnerModificationEnabled),
            new SetTokenIssuerAndOwnerModificationEnabledInput
            {
                Enabled = false
            });
        await ApproveWithMinersAsync(proposalId);
        await ParliamentContractStub.Release.SendAsync(proposalId);
        
        output = await TokenContractStub.GetTokenIssuerAndOwnerModificationEnabled.CallAsync(new Empty());
        output.Value.ShouldBeFalse();
        
        result = await TokenContractStub.ModifyTokenIssuerAndOwner.SendWithExceptionAsync(new ModifyTokenIssuerAndOwnerInput
        {
            Symbol = DefaultSymbol,
            Issuer = DefaultAddress,
            Owner = DefaultAddress
        });
        result.TransactionResult.Error.ShouldContain("Set token issuer and owner disabled.");

    }
```
