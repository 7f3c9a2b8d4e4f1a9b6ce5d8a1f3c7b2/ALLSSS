### Title
Duplicate FinalOrderOfNextRound Values Bypass Validation Due to Incorrect Distinct() Usage

### Summary
The `NextRoundMiningOrderValidationProvider` uses `.Distinct()` on `MinerInRound` objects instead of their `FinalOrderOfNextRound` values, allowing multiple miners to have duplicate order assignments. This enables a malicious miner producing a NextRound block to corrupt consensus by causing multiple miners to mine at the same time slot, resulting in blockchain forks and consensus failure.

### Finding Description

**Root Cause Location:** [1](#0-0) 

The validation incorrectly applies `.Distinct()` to a collection of `MinerInRound` protobuf message objects. Since protobuf classes implement equality by comparing ALL fields (pubkey, OutValue, Signature, etc.), two miners with identical `FinalOrderOfNextRound` values but different pubkeys are considered distinct objects. The validation counts these as separate entries even though they have duplicate order values.

**What Should Be Validated:**
The code should verify that all `FinalOrderOfNextRound` VALUES are unique, not that the `MinerInRound` objects are distinct. Since dictionary values are always distinct object instances, the current check is ineffective.

**Attack Entry Point:** [2](#0-1) 

The public `NextRound` method accepts a `NextRoundInput` containing the round data, including all miners' `FinalOrderOfNextRound` values, which flows directly to processing without proper validation.

**Vulnerable Processing Path:** [3](#0-2) 

The `ProcessNextRound` method converts the malicious input to a Round object and adds it directly to state without detecting duplicate orders.

**Consensus Corruption:** [4](#0-3) 

When the corrupted round is used to generate the next round, miners with duplicate `FinalOrderOfNextRound` values are both assigned the same `Order` and `ExpectedMiningTime`, causing them to attempt block production simultaneously.

### Impact Explanation

**Consensus Integrity Violation:**
Multiple miners receive identical time slots (`Order` and `ExpectedMiningTime`) in the next round, causing:
- Both miners attempt to produce blocks at the exact same time
- Different nodes may accept different blocks, creating blockchain forks
- Consensus mechanism breaks down as nodes diverge on chain state
- Network splits into incompatible partitions

**Affected Parties:**
- All network participants experience consensus failure
- Validators cannot reach agreement on canonical chain
- Applications relying on chain finality are disrupted
- Cross-chain operations may fail due to inconsistent state

**Severity Justification:**
This is a **High severity** issue because:
1. It directly violates the "miner schedule integrity" critical invariant
2. Causes immediate consensus failure affecting the entire network
3. Requires only a single malicious miner to exploit during their NextRound turn
4. No recovery mechanism exists once corrupted round data enters state

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a miner in the current consensus round
- Must have the opportunity to produce a NextRound block (when terminating a round)
- Can craft arbitrary `NextRoundInput` data for their block

**Attack Complexity:**
Low - the attacker simply needs to:
1. Generate consensus extra data for NextRound behavior
2. Manually modify the `RealTimeMinersInformation` to set duplicate `FinalOrderOfNextRound` values
3. Submit the block with malicious consensus data

**Feasibility:**
Highly feasible because:
- NextRound blocks are produced regularly (at least once per round)
- The validation flaw guarantees the malicious data passes checks
- No additional privileges beyond being a current miner are required
- The exploit is deterministic and repeatable

**Detection Constraints:**
The attack is difficult to detect in advance because:
- The validation returns success for malicious data
- The corruption only manifests when the next round is generated
- By then, the corrupted round is already in immutable state

### Recommendation

**Code-Level Fix:**
Modify the validation in `NextRoundMiningOrderValidationProvider.cs` to check for duplicate `FinalOrderOfNextRound` values:

```csharp
var minersWithOrder = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .ToList();
var distinctOrderCount = minersWithOrder
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
    
if (distinctOrderCount != minersWithOrder.Count || 
    distinctOrderCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
{
    validationResult.Message = "Invalid FinalOrderOfNextRound: duplicates detected.";
    return validationResult;
}
```

**Additional Invariant Check:**
Add validation in `ProcessNextRound` to verify all miners in the provided round have unique `Order` values before adding to state.

**Regression Test:**
Create a test case that attempts to submit a NextRound with duplicate `FinalOrderOfNextRound` values and verifies it's rejected with appropriate error message.

### Proof of Concept

**Initial State:**
- Round N with 5 miners (A, B, C, D, E) in normal operation
- All miners have produced blocks with valid consensus data
- Miner A is designated to produce the NextRound block

**Attack Steps:**
1. Miner A (attacker) prepares to produce NextRound block
2. Instead of using legitimate `GenerateNextRoundInformation`, crafts malicious `NextRoundInput` where:
   - Miner B: `FinalOrderOfNextRound = 2`, `OutValue = Hash_B`
   - Miner C: `FinalOrderOfNextRound = 2`, `OutValue = Hash_C` (duplicate!)
   - Miner D: `FinalOrderOfNextRound = 4`, `OutValue = Hash_D`
   - Miner E: `FinalOrderOfNextRound = 5`, `OutValue = Hash_E`
3. Submits NextRound transaction with this malicious data

**Expected Result (With Fix):**
Validation rejects the block with message "Invalid FinalOrderOfNextRound: duplicates detected."

**Actual Result (Current Vulnerable Code):**
- Validation at line 15-17 computes: `distinctCount = 4` (four distinct MinerInRound objects)
- Validation at line 17 computes: miners with `OutValue != null` = 4
- Check `4 == 4` passes âœ“
- Malicious round N+1 is added to state with Miner B and C both having `FinalOrderOfNextRound = 2`

**Subsequent Failure:**
When round N+1 generates round N+2:
- Both Miner B and C are assigned `Order = 2` and identical `ExpectedMiningTime`
- Both attempt to mine simultaneously
- Network forks as different nodes accept different blocks
- Consensus failure occurs

**Notes**

While the security question specifically asked about "emergency consensus modes," the investigation revealed that the vulnerability is more fundamental and exists regardless of the bootstrap skip mechanism. The bootstrap validation skip [5](#0-4)  does bypass all validation providers including `NextRoundMiningOrderValidationProvider` during the initial rounds, but this is intentional for the single-miner bootstrap scenario and doesn't directly relate to the validation bug.

The core issue is that the `.Distinct()` method operates on `MinerInRound` object references rather than the `FinalOrderOfNextRound` integer values, making the uniqueness check ineffective. This allows consensus corruption through duplicate mining order assignments in any normal or transition round, not just emergency scenarios.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-165)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L22-44)
```csharp
        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }
```
