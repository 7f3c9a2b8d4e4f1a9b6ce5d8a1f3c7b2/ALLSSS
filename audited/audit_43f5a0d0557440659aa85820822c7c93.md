### Title
Consensus DoS via Malformed Hex Keys in NextRound Input

### Summary
The `NextRound()` method accepts protobuf input containing miner public keys as strings without validating their hex format. A malicious miner can submit a `NextRoundInput` with non-hex or odd-length keys in `real_time_miners_information`, which gets stored in state without validation. Subsequent calls to view methods like `GetCurrentMinerList()` and consensus methods like `NextRound()` or `NextTerm()` will throw exceptions when attempting hex-to-ByteString conversion, causing permanent DoS of consensus operations.

### Finding Description

**Root Cause**: The consensus contract stores round information with string keys representing miner public keys but only validates the hex format when converting to ByteString, not during input acceptance.

**Vulnerable Code Path**:

1. Entry point at `NextRound()` accepts `NextRoundInput` protobuf message: [1](#0-0) 

2. The protobuf message defines `real_time_miners_information` as a map with string keys (no hex validation): [2](#0-1) 

3. `ProcessNextRound()` converts input to Round and stores it without validating key format: [3](#0-2) [4](#0-3) 

4. `AddRoundInformation()` stores the round with malformed keys to state: [5](#0-4) 

5. Consensus validation providers check mining permissions and round numbers but NOT key format: [6](#0-5) 

**Failure Points After Malformed Keys Are Stored**:

1. `GetCurrentMinerList()` view method throws when converting keys: [7](#0-6) 

2. The hex conversion implementation throws `FormatException` for invalid hex characters or `ArgumentOutOfRangeException` for odd-length strings: [8](#0-7) 

3. Subsequent `NextRound()` calls fail in `RecordMinedMinerListOfCurrentRound()`: [9](#0-8) 

4. `NextTerm()` calls also fail at the same point and when storing new miner list: [10](#0-9) [11](#0-10) 

### Impact Explanation

**Operational Impact - CRITICAL**:

Once malformed keys are stored in a round:

1. **View Method DoS**: All public view methods that read current miner information fail with exceptions:
   - `GetCurrentMinerList()` - throws on line 38
   - `GetCurrentMinerPubkeyList()` - calls GetCurrentMinerList internally, also fails
   - External systems querying miner lists cannot function

2. **Consensus Halt**: All future consensus operations permanently fail:
   - `NextRound()` transactions throw in `RecordMinedMinerListOfCurrentRound()`
   - `NextTerm()` transactions throw at the same point
   - Blockchain cannot progress to new rounds/terms
   - Mining rewards cannot be distributed
   - No recovery path without manual intervention or rollback

3. **Cross-Chain Impact**: Side chains relying on parent chain miner lists cannot synchronize

**Affected Parties**:
- All network participants (consensus stops)
- Users querying miner information
- Applications depending on consensus state
- Cross-chain operations

**Severity**: CRITICAL - Complete consensus DoS requiring chain rollback or emergency intervention

### Likelihood Explanation

**Attacker Capabilities Required**:
- Must be an authorized miner (can call `NextRound()`)
- Authorization check happens in `PreCheck()`: [12](#0-11) 

**Attack Complexity**: LOW
- Craft a protobuf `NextRoundInput` message with malformed keys (e.g., "ZZZZ", "invalid", or odd-length like "abc")
- Submit via `NextRound()` during legitimate mining time slot
- No complex multi-step sequence required

**Feasibility Conditions**: HIGHLY FEASIBLE
- Any current miner can execute (insider threat)
- Compromised miner node can automate
- No detection mechanism exists before storage
- Single transaction achieves permanent DoS

**Detection/Operational Constraints**: MINIMAL
- Attack appears as normal NextRound transaction until view methods are called
- No pre-execution validation catches malformed keys
- Immediate impact on next query or consensus operation

**Probability Assessment**: MEDIUM-HIGH
- Requires insider access (miner)
- But high impact with low technical difficulty
- Realistic threat model for compromised or malicious miner

### Recommendation

**Immediate Fix**:

Add hex format validation before storing round information. Implement in `ProcessNextRound()` and `ProcessNextTerm()`:

```csharp
// In ProcessNextRound() before AddRoundInformation(nextRound)
private void ValidateRoundKeys(Round round)
{
    foreach (var key in round.RealTimeMinersInformation.Keys)
    {
        try
        {
            // Validate key is valid hex and can be converted
            ByteStringHelper.FromHexString(key);
        }
        catch (Exception)
        {
            Assert(false, $"Invalid miner public key format: {key}");
        }
    }
}
```

**Validation Provider**:

Add a new validation provider to check key format: [13](#0-12) 

Create `MinerKeyFormatValidationProvider` that validates all keys in `extraData.Round.RealTimeMinersInformation` are valid hex strings before accepting the round.

**Input Sanitization**:

Add validation in `ToRound()` method: [14](#0-13) 

Validate keys before copying to ensure only properly formatted hex strings are accepted.

**Test Cases**:

1. Test `NextRound()` with non-hex characters in keys (e.g., "ZZZZ") - should reject
2. Test `NextRound()` with odd-length hex strings (e.g., "abc") - should reject  
3. Test `NextRound()` with valid hex keys - should accept
4. Verify `GetCurrentMinerList()` doesn't throw after valid NextRound
5. Test recovery path if malformed data somehow enters state

### Proof of Concept

**Initial State**:
- Blockchain running normally with round N
- Attacker controls a miner node in the current miner list

**Attack Steps**:

1. Miner crafts malicious `NextRoundInput` protobuf message for round N+1:
   - Set `round_number = N+1`
   - Set `real_time_miners_information` with entries like:
     - Key: "INVALIDHEX" (non-hex characters)
     - Key: "abc" (odd-length)
     - Value: valid `MinerInRound` objects

2. Miner calls `NextRound(maliciousInput)` during their mining time slot:
   - Authorization passes (they are a valid miner)
   - Validation providers check round number, mining order - pass
   - No hex format validation occurs
   - `AddRoundInformation()` stores round N+1 with malformed keys
   - Transaction succeeds, round N+1 becomes current

3. Any user calls `GetCurrentMinerList()`:
   - Tries to convert "INVALIDHEX" via `ByteStringHelper.FromHexString()`
   - `Convert.ToByte("IN", 16)` throws `FormatException`
   - View method fails with exception

4. Next miner attempts `NextRound()` for round N+2:
   - `RecordMinedMinerListOfCurrentRound()` executes
   - Tries `ByteStringHelper.FromHexString(m.Pubkey)` on current round (N+1)
   - Throws exception on malformed keys
   - Transaction fails, consensus halts

**Expected Result**: Normal consensus operations continue

**Actual Result**: 
- Consensus permanently halted after round N+1 stored
- All view methods reading current miner list fail
- Blockchain cannot progress without manual intervention

**Success Condition**: 
- Round N+1 with malformed keys successfully stored via `NextRound()`
- Subsequent calls to `GetCurrentMinerList()` or `NextRound()` throw exceptions
- Consensus operations blocked

### Notes

The vulnerability exploits the gap between protobuf deserialization (which accepts any string) and hex validation (which only occurs during ByteString conversion). The consensus validation framework checks behavioral and numerical correctness but not data format integrity of string keys.

This is a realistic attack vector because:
1. Miners must be trusted to produce valid consensus data, but compromised/malicious miners exist
2. The attack is simple (single malformed transaction)
3. Impact is severe (consensus halt)
4. No automatic recovery mechanism exists

The fix must be applied at multiple layers: input validation in `ToRound()`, validation providers in the consensus validation pipeline, and defensive checks before state storage.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** protobuf/aedpos_contract.proto (L458-462)
```text
message NextRoundInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-112)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-159)
```csharp
        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-165)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L223-230)
```csharp
    private void RecordMinedMinerListOfCurrentRound()
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        State.MinedMinerListMap.Set(currentRound.RoundNumber, new MinerList
        {
            Pubkeys = { currentRound.GetMinedMiners().Select(m => ByteStringHelper.FromHexString(m.Pubkey)) }
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-92)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L31-42)
```csharp
    public override MinerList GetCurrentMinerList(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var round)
            ? new MinerList
            {
                Pubkeys =
                {
                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))
                }
            }
            : new MinerList();
    }
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-19)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```
