# Audit Report

## Title
Assembled NFTs Can Be Burned Directly, Permanently Locking Component NFTs

## Summary
The NFT contract's `Burn` method can destroy assembled NFTs without returning their locked component assets. When users who are protocol minters burn assembled NFTs instead of using `Disassemble`, the component NFTs and fungible tokens remain permanently trapped in the contract with no recovery mechanism. This breaks the fundamental invariant that locked assets must be retrievable.

## Finding Description

The NFT contract implements an assembly mechanism where NFTs and fungible tokens can be locked into composite "assembled" NFTs. The `Assemble` method transfers component NFTs to the contract itself (`Context.Self`) and stores the mapping for later retrieval. [1](#0-0) 

The locked components are recorded in state: [2](#0-1) 

The intended flow for retrieving locked assets is through `Disassemble`, which burns the assembled NFT and transfers components back to the receiver: [3](#0-2) 

**Root Cause:** The `Burn` method validates caller permissions and balance, but does NOT check if the NFT being burned has locked components in `AssembledNftsMap`: [4](#0-3) 

The `Burn` method performs no check for assembled NFTs, does not return locked assets, and does not clean up the `AssembledNftsMap` entry. When a protocol minter calls `Burn` on an assembled NFT:
- The assembled NFT is destroyed (balance reduced, quantity decreased)
- The `AssembledNftsMap[tokenHash]` entry remains orphaned
- Component NFTs/FTs stay locked in the contract forever
- No mechanism exists to recover these assets

**Attack Vector:** Any user can create their own NFT protocol and become its minter automatically: [5](#0-4) 

They can then assemble NFTs from any protocol into their own protocol (the assembly accepts any token hash), then burn their protocol's assembled NFT to permanently lock the components.

## Impact Explanation

**Severity: HIGH**

**Direct Fund Loss:** Component NFTs and fungible tokens locked during assembly become permanently inaccessible. The locked assets remain in the contract's balance but cannot be retrieved by anyone, including the contract owner or governance. The value depends on what was assembled but could include rare NFTs or significant fungible token amounts.

**Broken Invariants:** The assembly/disassembly mechanism creates an explicit expectation that locked assets can be retrieved. This vulnerability violates that core guarantee, as burning assembled NFTs bypasses the retrieval flow entirely.

**Affected Parties:**
- Users who accidentally call `Burn` instead of `Disassemble` (user error)
- Victims of malicious actors who intentionally burn assembled NFTs (griefing)
- The protocol itself accumulates unrecoverable locked assets in perpetuity

**No Recovery Path:** There is no admin function, governance mechanism, or emergency procedure to rescue locked assets from orphaned `AssembledNftsMap` entries. The loss is permanent and irreversible.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Entry Point:** The `Burn` method is publicly accessible to any protocol minter with sufficient balance of the NFT being burned.

**Preconditions:**
1. Attacker creates an NFT protocol (any user can do this via `Create`)
2. Attacker is automatically added as protocol minter upon creation
3. Attacker assembles NFTs from other protocols into their protocol
4. Protocol must be burnable (can be set during creation)

**Attack Complexity:** LOW - The attack requires only standard protocol operations:
- Create a burnable protocol (single transaction)
- Assemble NFTs into the protocol (single transaction)  
- Burn the assembled NFT (single transaction)

**Real-World Scenarios:**
1. **User Error:** Users may confuse `Burn` and `Disassemble` methods, especially if wallet interfaces don't clearly distinguish them
2. **Malicious Griefing:** Attackers can intentionally burn assembled NFTs to cause fund loss at minimal cost (only transaction fees)
3. **Integration Bugs:** External dApps or contracts that incorrectly call `Burn` on assembled NFTs

**Economic Rationality:** While there's no direct profit for attackers, the attack is cheap to execute and causes permanent harm, making it attractive for griefing purposes.

## Recommendation

Add a check in the `Burn` method to prevent burning assembled NFTs:

```csharp
public override Empty Burn(BurnInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    
    // Prevent burning assembled NFTs
    Assert(State.AssembledNftsMap[tokenHash] == null && State.AssembledFtsMap[tokenHash] == null,
        "Cannot burn assembled NFTs directly. Use Disassemble instead.");
    
    var nftInfo = GetNFTInfoByTokenHash(tokenHash);
    // ... rest of existing burn logic
}
```

This forces users to call `Disassemble` for assembled NFTs, ensuring locked components are properly returned. The fix is minimal, adds no gas overhead for non-assembled NFTs, and completely prevents the vulnerability.

Alternatively, the `Burn` method could be enhanced to automatically handle disassembly if the NFT has locked components, though this increases complexity and gas costs.

## Proof of Concept

```csharp
[Fact]
public async Task BurnAssembledNFT_LocksComponentsPermanently()
{
    // Setup: Create protocol and mint an NFT to be locked
    var componentSymbol = await CreateNFTProtocol();
    var componentTokenHash = await MintNFT(componentSymbol);
    
    // Verify user owns the component NFT
    var balanceBefore = await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = componentSymbol,
        TokenId = 1,
        Owner = DefaultSender
    });
    balanceBefore.Balance.ShouldBe(1);
    
    // Create a burnable protocol for assembled NFT
    var assembledSymbol = await CreateBurnableNFTProtocol();
    
    // Assemble the component NFT into a new assembled NFT
    await NFTContractStub.Assemble.SendAsync(new AssembleInput
    {
        Symbol = assembledSymbol,
        AssembledNfts = new AssembledNfts
        {
            Value = { [componentTokenHash.ToHex()] = 1 }
        }
    });
    
    // Verify component NFT is now locked in contract
    var contractBalance = await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = componentSymbol,
        TokenId = 1,
        Owner = NFTContractAddress
    });
    contractBalance.Balance.ShouldBe(1);
    
    // VULNERABILITY: Burn the assembled NFT directly instead of disassembling
    await NFTContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = assembledSymbol,
        TokenId = 1,
        Amount = 1
    });
    
    // Component NFT remains permanently locked in contract
    var contractBalanceAfter = await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = componentSymbol,
        TokenId = 1,
        Owner = NFTContractAddress
    });
    contractBalanceAfter.Balance.ShouldBe(1); // Still locked!
    
    // User cannot retrieve it - permanently lost
    var userBalanceAfter = await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = componentSymbol,
        TokenId = 1,
        Owner = DefaultSender
    });
    userBalanceAfter.Balance.ShouldBe(0); // Lost forever
}
```

This test demonstrates that burning an assembled NFT leaves the component NFT permanently locked in the contract with no way to retrieve it, confirming the vulnerability.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L120-131)
```csharp
        if (input.AssembledNfts.Value.Any())
        {
            metadata.Value[AssembledNftsKey] = input.AssembledNfts.ToString();
            // Check owner.
            foreach (var pair in input.AssembledNfts.Value)
            {
                var nftHash = Hash.LoadFromHex(pair.Key);
                var nftInfo = GetNFTInfoByTokenHash(nftHash);
                Assert(State.BalanceMap[nftHash][Context.Sender] >= pair.Value,
                    $"Insufficient balance of {nftInfo.Symbol}{nftInfo.TokenId}.");
                DoTransfer(nftHash, Context.Sender, Context.Self, pair.Value);
            }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L176-178)
```csharp
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;

        if (input.AssembledFts.Value.Any()) State.AssembledFtsMap[nftMinted.TokenHash] = input.AssembledFts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-224)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });

        var receiver = input.Owner ?? Context.Sender;

        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
        }

        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
        if (assembledFts != null)
        {
            var fts = assembledFts;
            foreach (var pair in fts.Value)
                State.TokenContract.Transfer.Send(new MultiToken.TransferInput
                {
                    Symbol = pair.Key,
                    Amount = pair.Value,
                    To = receiver
                });

            State.AssembledFtsMap.Remove(tokenHash);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L36-38)
```csharp
        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;
```
