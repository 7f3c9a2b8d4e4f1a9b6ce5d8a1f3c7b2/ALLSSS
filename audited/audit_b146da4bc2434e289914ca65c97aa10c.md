### Title
Quadratic Voting Completely Bypassed Due to Unique VoteId Generation Per Vote Transaction

### Summary
The quadratic voting implementation in the Vote contract is fundamentally broken for voting items with `IsQuadratic=true` and `IsLockToken=true`. Each vote transaction generates a unique VoteId, causing the quadratic vote counter to always be 1, resulting in constant voting cost instead of the intended increasing cost. This completely defeats the purpose of quadratic voting, allowing malicious actors to cast unlimited votes at constant cost and dominate voting outcomes.

### Finding Description

The quadratic voting logic is located in the `Vote()` method, where the amount is calculated: [1](#0-0) 

The critical flaw occurs because for locked-token voting (`IsLockToken=true`), the VoteId is auto-generated using: [2](#0-1) 

Since `votingResult.VotesAmount` changes with each vote, every vote transaction receives a **unique VoteId**. The `QuadraticVotesCountMap` state variable is keyed by VoteId: [3](#0-2) 

Therefore, when a voter casts multiple votes on the same quadratic voting item:
1. Each vote gets a new unique VoteId
2. `QuadraticVotesCountMap[newVoteId]` is initialized to 0
3. After incrementing, `currentVotesCount` becomes 1
4. `amount = TicketCost * 1` (always constant)

The calculated amount is then stored in the VotingRecord: [4](#0-3) 

The `GetVotingRecord()` view function simply returns this stored (incorrectly calculated) amount: [5](#0-4) 

**Why existing protections fail**: There are no checks to prevent the same voter from voting multiple times, as confirmed by test cases showing voters can vote multiple times on the same item. The validation logic only checks basic constraints like option validity and voting period: [6](#0-5) 

No tests exist for quadratic voting functionality, as the test helper doesn't support `IsQuadratic` or `TicketCost` parameters: [7](#0-6) 

### Impact Explanation

**Direct Harm**: Quadratic voting is a mechanism designed to prevent vote concentration by making each successive vote more expensive. By bypassing this mechanism, wealthy actors can:
- Cast unlimited votes at constant cost (TicketCost per vote)
- Dominate voting outcomes without the quadratic cost penalty
- Unfairly influence governance decisions, candidate elections, or other voting activities

**Quantified Damage**: If `TicketCost = 100 tokens`, a malicious actor should pay:
- 1st vote: 100 tokens
- 2nd vote: 200 tokens (cumulative 300)
- 3rd vote: 300 tokens (cumulative 600)
- 10th vote: 1,000 tokens (cumulative 5,500)

Instead, they pay only 100 tokens per vote (cumulative 1,000 for 10 votes) - an 82% cost reduction.

**Who is Affected**: All participants in voting items with `IsQuadratic=true` and `IsLockToken=true`. The Election contract and other governance systems that rely on fair quadratic voting are compromised.

**Severity**: MEDIUM-HIGH - While not directly stealing funds, this completely breaks a critical fairness mechanism in governance and voting systems.

### Likelihood Explanation

**Attacker Capabilities**: Any address with sufficient tokens can exploit this. No special privileges required.

**Attack Complexity**: Trivial - simply call `Vote()` multiple times with the same `VotingItemId` but different transaction contexts.

**Feasibility**: 
- Bug exists in deployed code
- Affects all quadratic voting items with `IsLockToken=true`
- Voters are explicitly allowed to vote multiple times (no restrictions)
- Cost is minimal compared to intended quadratic cost

**Detection Constraints**: The bug can be detected by calling `GetVotingRecord()` for multiple votes from the same voter and observing constant amounts instead of increasing amounts. However, this requires active monitoring.

**Probability**: HIGH - The vulnerability is always exploitable whenever a quadratic voting item exists.

### Recommendation

**Code-Level Mitigation**:

1. Change the quadratic vote counter key from `VoteId` to a composite key of `(Voter, VotingItemId)`:

```csharp
// In VoteContractState.cs, change:
public MappedState<Hash, Hash, long> QuadraticVotesCountMap { get; set; }
// First Hash: VotingItemId, Second Hash: Voter address hash
```

2. Update the Vote() method calculation:

```csharp
// Lines 100-103 should become:
var voterKey = Context.ConvertVirtualAddressToContractAddress(input.Voter);
var countKey = HashHelper.ConcatAndCompute(input.VotingItemId, voterKey.Value);
var currentVotesCount = State.QuadraticVotesCountMap[input.VotingItemId][voterKey].Add(1);
State.QuadraticVotesCountMap[input.VotingItemId][voterKey] = currentVotesCount;
amount = votingItem.TicketCost.Mul(currentVotesCount);
```

3. Implement proper quadratic formula (n² instead of n):

```csharp
amount = votingItem.TicketCost.Mul(currentVotesCount).Mul(currentVotesCount);
```

**Invariant Checks**:
- Assert that for quadratic voting, subsequent votes from the same voter have strictly increasing amounts
- Add validation: `Assert(amount >= previousAmount, "Quadratic voting cost must increase")`

**Test Cases**:
- Test voter casting multiple votes on quadratic voting item
- Verify amounts are: TicketCost×1², TicketCost×2², TicketCost×3², etc.
- Test token locking accumulates correctly
- Test withdrawal returns proper amounts

### Proof of Concept

**Initial State**:
1. Register voting item with `IsQuadratic=true`, `IsLockToken=true`, `TicketCost=100`
2. Voter has 10,000 tokens

**Attack Steps**:
1. Voter calls `Vote(votingItemId, option, amount=0)` → VoteId1 generated, Amount stored = 100
2. Voter calls `Vote(votingItemId, option, amount=0)` → VoteId2 generated, Amount stored = 100
3. Voter calls `Vote(votingItemId, option, amount=0)` → VoteId3 generated, Amount stored = 100
4. Call `GetVotingRecord(VoteId1)` → Returns `Amount = 100`
5. Call `GetVotingRecord(VoteId2)` → Returns `Amount = 100`
6. Call `GetVotingRecord(VoteId3)` → Returns `Amount = 100`

**Expected Result (Correct Quadratic Voting)**:
- VoteId1: Amount = 100 (1² × 100)
- VoteId2: Amount = 400 (2² × 100)
- VoteId3: Amount = 900 (3² × 100)
- Total cost: 1,400 tokens

**Actual Result (Broken Implementation)**:
- VoteId1: Amount = 100
- VoteId2: Amount = 100
- VoteId3: Amount = 100
- Total cost: 300 tokens (79% discount)

**Success Condition**: Attacker casts multiple votes at constant cost, paying far less than intended quadratic cost, enabling cheap vote manipulation.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L100-103)
```csharp
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L105-117)
```csharp
        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L30-33)
```csharp
    /// <summary>
    ///     Vote Id -> Votes Count
    /// </summary>
    public MappedState<Hash, long> QuadraticVotesCountMap { get; set; }
```

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L20-25)
```csharp
    public override VotingRecord GetVotingRecord(Hash input)
    {
        var votingRecord = State.VotingRecords[input];
        Assert(votingRecord != null, "Voting record not found.");
        return votingRecord;
    }
```

**File:** test/AElf.Contracts.Vote.Tests/VoteContractTestHelper.cs (L28-41)
```csharp
    private async Task<VotingItem> RegisterVotingItemAsync(int lastingDays, int optionsCount, bool isLockToken,
        Address sender,
        int totalSnapshotNumber = int.MaxValue)
    {
        var startTime = TimestampHelper.GetUtcNow();
        var input = new VotingRegisterInput
        {
            TotalSnapshotNumber = totalSnapshotNumber,
            EndTimestamp = startTime.AddDays(lastingDays),
            StartTimestamp = startTime,
            Options = { GenerateOptions(optionsCount) },
            AcceptedCurrency = TestTokenSymbol,
            IsLockToken = isLockToken
        };
```
