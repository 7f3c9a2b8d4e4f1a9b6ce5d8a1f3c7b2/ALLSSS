# Audit Report

## Title
NextTerm Transaction Lacks Validation of Miner List Against Election Contract Results

## Summary
The AEDPoS consensus contract's NextTerm transaction flow accepts arbitrary miner lists without validating them against election results from the Election contract. A malicious extra block producer can inject unauthorized miners for the next term, achieving complete consensus takeover and bypassing the democratic election process.

## Finding Description

The vulnerability exists in the term transition mechanism where the miner list for a new term is accepted without cryptographic or on-chain validation against election results.

**Root Cause - Blind Copy Without Validation:**

The `NextTermInput.Create()` method directly copies `RealTimeMinersInformation` from the provided `Round` object without any validation: [1](#0-0) 

This method simply transfers all miner information from the input Round, including the complete miner list, with zero verification that these miners are legitimate election winners.

**Missing Pre-Execution Validation:**

During pre-execution validation, the `ValidateBeforeExecution` method only adds `RoundTerminateValidationProvider` for NextTerm behavior: [2](#0-1) 

The `RoundTerminateValidationProvider` only validates that round and term numbers are incremented correctly: [3](#0-2) 

Notably absent is any validation provider that queries `ElectionContract.GetVictories()` and compares the result against the miner list in the transaction input.

**No Validation During Execution:**

The `ProcessNextTerm` method directly extracts miners from the input Round and stores them via `SetMinerList`: [4](#0-3) 

At no point does this execution path call `GetVictories()` from the Election contract to verify that the miners being installed are the legitimate election winners.

**SetMinerList Provides No Security:**

The `SetMinerList` method only prevents duplicate updates for the same term, but performs no validation of miner legitimacy: [5](#0-4) 

**Honest Path Not Enforced:**

While the honest code path does query the Election contract to obtain legitimate miners: [6](#0-5) [7](#0-6) 

This is only used during honest transaction generation. There is no validation code that enforces this same query must produce the same miners as those in the transaction input. A malicious miner can bypass `GenerateFirstRoundOfNextTerm` entirely and craft a `Round` object with arbitrary miners.

**Attack Execution Path:**

1. Malicious miner waits until they become the extra block producer when `NeedToChangeTerm()` returns true
2. Instead of calling `GetConsensusExtraDataForNextTerm` honestly, they craft a malicious `Round` with chosen miners
3. They call `NextTermInput.Create(maliciousRound, randomNumber)` to generate the transaction input
4. They broadcast the NextTerm block with this transaction
5. Validation passes (only round/term numbers checked)
6. Execution accepts and stores the arbitrary miner list
7. Attacker's chosen miners control consensus for the entire next term

## Impact Explanation

**Consensus Integrity Catastrophic Failure:**
- A malicious extra block producer gains the ability to unilaterally determine which miners control the blockchain for the next term (typically 7 days)
- The attacker can inject themselves, colluding parties, or even non-existent public keys as the complete miner set
- All legitimate election winners can be excluded from consensus participation
- This constitutes a complete consensus takeover violating the fundamental "Delegated" aspect of DPoS

**Democratic Process Bypass:**
- All token holder votes become meaningless as election results are ignored
- Voters lose their governance rights over block producer selection
- The election contract's `GetVictories()` results have no binding effect on actual consensus participation

**Cascading Permanent Control:**
- Malicious miners controlling term N can inject themselves again into term N+1
- Creates a self-perpetuating consensus capture with no recovery mechanism
- All subsequent blocks, transactions, and state transitions fall under attacker control
- Even if honest miners win future elections, they can be perpetually excluded

**Affected Parties:**
- All token holders whose votes are nullified
- Legitimate candidates who won elections but are denied participation
- All blockchain users whose transactions depend on honest consensus
- The entire network's security model and liveness guarantees

## Likelihood Explanation

**Attack Prerequisites:**
- Attacker must be an extra block producer when `NeedToChangeTerm()` returns true (this rotates among miners approximately every ~7 days)
- Attacker must control their node software to modify consensus transaction generation
- Both prerequisites are realistic: any miner in the current set can eventually be the extra block producer, and miners control their own node software

**Execution Feasibility:**
- Attack requires a single malicious NextTerm transaction at the scheduled term boundary
- No complex state manipulation, race conditions, or timing attacks needed
- No economic cost beyond normal block production
- The `PreCheck()` method only verifies the sender is in the current or previous miner list, which the attacker satisfies: [8](#0-7) 

**Detection Difficulty:**
- The malicious NextTerm transaction appears identical to legitimate ones in structure
- No on-chain validation failures occur
- Off-chain observers would need to independently query `GetVictories()` and compare against the executed miner list to detect the attack
- By the time detection occurs, the malicious miners already control consensus

**Attack Complexity: LOW**
**Likelihood: HIGH** (once an attacker becomes extra block producer at term boundary)

## Recommendation

Implement miner list validation during NextTerm transaction processing:

1. **Add Election Result Validation in ProcessNextTerm:**
   - Query `ElectionContract.GetVictories()` to get legitimate election winners
   - Compare the result against `nextRound.RealTimeMinersInformation.Keys`
   - Assert they match exactly (same set of public keys)
   - Add this validation before calling `SetMinerList()`

2. **Add Validation Provider for NextTerm:**
   - Create `NextTermMinerListValidationProvider` that queries the Election contract
   - Add this provider in `ValidateBeforeExecution` for `AElfConsensusBehaviour.NextTerm` cases
   - Validate that input miner list matches election winners

3. **Strengthen SetMinerList:**
   - Add a parameter for expected election winners
   - Validate the provided `MinerList` matches expected winners before storing

Example fix in ProcessNextTerm:
```csharp
// After line 163: var nextRound = input.ToRound();
// Add validation:
if (State.IsMainChain.Value && State.ElectionContract.Value != null)
{
    var victories = State.ElectionContract.GetVictories.Call(new Empty());
    var expectedMiners = victories.Value.Select(v => v.ToHex()).OrderBy(k => k).ToList();
    var actualMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    
    Assert(expectedMiners.Count == actualMiners.Count && 
           expectedMiners.SequenceEqual(actualMiners),
           "NextTerm miner list does not match election results");
}
```

## Proof of Concept

A malicious miner can execute the attack as follows:

```csharp
// Attacker becomes extra block producer at term boundary
// Instead of honest GenerateFirstRoundOfNextTerm call:

// 1. Craft malicious Round with attacker-controlled miners
var maliciousRound = new Round
{
    RoundNumber = currentRound.RoundNumber + 1,
    TermNumber = currentRound.TermNumber + 1,
    RealTimeMinersInformation = 
    {
        // Add only attacker's miners, excluding legitimate election winners
        ["AttackerPubkey1"] = new MinerInRound { Order = 1, ... },
        ["AttackerPubkey2"] = new MinerInRound { Order = 2, ... },
        ["ColludingMiner1"] = new MinerInRound { Order = 3, ... }
    },
    // ... other required fields
};

// 2. Create NextTermInput with malicious Round
var maliciousInput = NextTermInput.Create(maliciousRound, randomNumber);

// 3. Generate and broadcast NextTerm transaction
var tx = GenerateTransaction(nameof(NextTerm), maliciousInput);

// Result: Transaction passes validation (only checks round/term numbers)
//         Execution stores attacker's miners as legitimate
//         Attacker controls next term's consensus
```

To test this vulnerability, create a unit test that:
1. Simulates a term boundary where NeedToChangeTerm returns true
2. Has the extra block producer call NextTerm with a crafted miner list different from GetVictories() results
3. Verifies the transaction succeeds and stores the malicious miner list
4. Confirms no validation error occurs despite miner list mismatch

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-191)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```
