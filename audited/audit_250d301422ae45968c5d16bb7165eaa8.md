### Title
Consensus Permanent DoS via Unconstrained LIB Injection in NextTerm/NextRound Transactions

### Summary
The `NextTerm` and `NextRound` transaction processing paths lack `LibInformationValidationProvider` validation, allowing a malicious miner to inject arbitrarily high `ConfirmedIrreversibleBlockHeight` values into consensus state. Once corrupted, all subsequent `UpdateValue` transactions fail validation, permanently halting block production and requiring a hard fork to recover.

### Finding Description

**Root Cause**: The validation logic in `ValidateBeforeExecution` applies `LibInformationValidationProvider` only to `UpdateValue` behavior but not to `NextTerm` or `NextRound` behaviors. [1](#0-0) 

For `NextTerm`, only `RoundTerminateValidationProvider` is applied, which validates round/term number increments and InValue nullness but does NOT validate LIB values: [2](#0-1) 

**Execution Path**: When processing `NextTerm`, the transaction input's LIB values are directly copied to the new round without validation: [3](#0-2) [4](#0-3) 

The malicious round is saved to state via `AddRoundInformation` at line 196, persisting the corrupted LIB values. Additionally, the `GenerateFirstRoundOfNewTerm` function copies LIB values from the current round without validation: [5](#0-4) 

**Why Protections Fail**: Once corrupted LIB is in state, subsequent `UpdateValue` transactions calculate the real LIB (e.g., 15,000) but fail validation because `LibInformationValidationProvider` rejects backward LIB movement: [6](#0-5) 

If `baseRound.ConfirmedIrreversibleBlockHeight` is corrupted to a very high value (e.g., Int64.MaxValue - 1000), and `providedRound.ConfirmedIrreversibleBlockHeight` is the correctly calculated LIB (e.g., 15,000), the check `baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight` evaluates to true, failing validation.

### Impact Explanation

**Consensus DoS**: Once the LIB is corrupted, miners cannot produce blocks because:
1. `UpdateValue` is mandatory for first block in time slot (when `OutValue == null`): [7](#0-6) 

2. All `UpdateValue` transactions fail `LibInformationValidationProvider` validation
3. Without `UpdateValue`, `OutValue` remains null
4. `TinyBlock` cannot be produced (requires `OutValue != null`)
5. **Complete consensus halt** - no blocks can be produced until hard fork

**Severity**: CRITICAL
- Entire blockchain permanently halted
- All transactions blocked
- Protocol requires emergency hard fork to recover
- Single malicious miner can execute attack
- No automated recovery mechanism exists

### Likelihood Explanation

**Attacker Capabilities**: 
- Must be an active miner in current consensus round
- Miners are elected through governance, making this a semi-privileged but realistic threat model
- Multiple miners exist in typical deployments

**Attack Complexity**: LOW
1. Wait for legitimate term transition period
2. Call `GenerateConsensusTransactions` to get valid `NextTermInput`
3. Modify `ConfirmedIrreversibleBlockHeight` field to high value (e.g., Int64.MaxValue - 1000)
4. Submit modified transaction

**Feasibility**: HIGH
- No cryptographic challenges
- No complex timing requirements
- Validation gaps are systematic, not race conditions
- Attack is deterministic and repeatable

**Detection**: Transaction appears valid until corruption manifests in next round

**Economic Cost**: Minimal (only transaction gas fees)

### Recommendation

**Immediate Fix**: Add `LibInformationValidationProvider` to `NextTerm` and `NextRound` validation pipelines in `ValidateBeforeExecution`:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

**Additional Safeguards**:
1. Add upper bound checks for `ConfirmedIrreversibleBlockHeight` relative to current blockchain height
2. Add unit tests verifying LIB validation in all consensus behaviors
3. Consider adding LIB monotonicity invariant checks in `AddRoundInformation`

### Proof of Concept

**Initial State**:
- Current term 100, round 5000
- Current LIB height: 14,500
- Attacker is elected miner with address `ATTACKER_ADDRESS`
- Term period expires, triggering NextTerm

**Attack Steps**:
1. Attacker calls off-chain: `GetConsensusExtraData` to get legitimate round data
2. Attacker modifies returned `NextTermInput`:
   - `ConfirmedIrreversibleBlockHeight = Int64.MaxValue - 1000`
   - `ConfirmedIrreversibleBlockRoundNumber = Int64.MaxValue - 1000`
3. Attacker submits transaction: `NextTerm(modifiedInput)`
4. Validation passes (no LIB check for NextTerm)
5. `ProcessNextTerm` executes, saves corrupted round to `State.Rounds[5001]`
6. Transaction completes successfully

**Verification of Exploit Success**:
7. Next miner attempts `UpdateValue` for round 5001
8. Contract calculates real LIB â‰ˆ 14,800 via `LastIrreversibleBlockHeightCalculator`
9. `ValidateConsensusBeforeExecution` runs `LibInformationValidationProvider`
10. Check fails: `(Int64.MaxValue - 1000) > 14800` = true
11. Validation returns: `{Success: false, Message: "Incorrect lib information"}`
12. **All subsequent UpdateValue transactions rejected**
13. **Consensus permanently halted**

**Expected**: LIB validation should prevent corrupted values in NextTerm
**Actual**: No LIB validation, corruption persists, consensus DoS achieved

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L47-54)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval, Timestamp currentBlockTime, Round currentRound)
    {
        var round = GenerateFirstRoundOfNewTerm(miningInterval, currentBlockTime, currentRound.RoundNumber,
            currentRound.TermNumber);
        round.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        round.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-56)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
```
