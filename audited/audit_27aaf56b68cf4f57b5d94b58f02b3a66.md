### Title
Approve-Then-Call Pattern Without Verification Allows Compromised ProfitContract to Drain Contributed Tokens

### Summary
The `ContributeProfits` function in TokenHolderContract approves ProfitContract to spend tokens and immediately calls it without any post-call verification. If ProfitContract is compromised or contains a bug, it can misuse the approval to transfer tokens to arbitrary addresses instead of the scheme's virtual address, preventing legitimate profit distribution to beneficiaries.

### Finding Description

**Exact Code Locations:**

The vulnerable flow occurs in `ContributeProfits`: [1](#0-0) 

The function executes three critical steps:

1. **Token Transfer** - Pulls tokens from user to TokenHolderContract: [2](#0-1) 

2. **Approval Grant** - Approves ProfitContract to spend the exact amount: [3](#0-2) 

3. **External Call** - Calls ProfitContract without verification: [4](#0-3) 

**Root Cause:**

The contract implements an approve-then-call pattern where it:
- Sets allowance for ProfitContract via `TokenContract.Approve`
- Calls `ProfitContract.ContributeProfits` 
- **Returns immediately without any verification**

There are no checks to verify:
- Tokens actually reached the scheme's virtual address
- ProfitContract correctly recorded the contribution
- The approval was consumed as expected
- Scheme state was properly updated

**Why Existing Protections Fail:**

While ProfitContract is a system contract resolved via trusted name resolution [5](#0-4) , no runtime verification exists to ensure correct behavior.

The legitimate ProfitContract implementation calls `TransferFrom` to pull tokens: [6](#0-5) 

However, a compromised or buggy ProfitContract could:
- Transfer to an attacker address instead of `virtualAddress`
- Transfer partial amounts while claiming full contribution
- Skip the transfer entirely, leaving tokens stranded with active approval
- Call `TransferFrom` multiple times if allowance permits

The token approval mechanism enforces allowance limits but cannot validate transfer destinations: [7](#0-6) 

### Impact Explanation

**Direct Fund Loss:**
- All tokens contributed via `ContributeProfits` could be stolen in their entirety
- Contributed amounts ranging from minimum contribution thresholds to unlimited values are at risk
- No recovery mechanism exists once tokens are approved and the external call executes

**Affected Parties:**
- **Token contributors**: Users calling `ContributeProfits` lose 100% of contributed funds
- **Beneficiaries**: Receive zero profits despite contributions being recorded in ProfitContract state
- **Scheme integrity**: Virtual address balances won't match recorded contributions, breaking distribution calculations

**Severity Justification:**
This is **CRITICAL** because:
1. Complete loss of user funds with no recoverability
2. Violation of core economic invariant (profit distribution accuracy)
3. Affects all TokenHolder schemes across the system
4. Silent failure - no immediate indication of theft to users

### Likelihood Explanation

**Attack Prerequisites:**
The vulnerability activates if ProfitContract is compromised through:
1. **Exploitable bug** in ProfitContract code (e.g., reentrancy, logic error)
2. **Malicious upgrade** via compromised governance 
3. **Supply chain attack** during contract deployment

**Execution Simplicity:**
Once precondition is met, exploitation is trivial:
- No special timing or state manipulation required
- Standard `ContributeProfits` call triggers vulnerability
- Attacker simply implements malicious `TransferFrom` logic in compromised ProfitContract

**Detection Constraints:**
- Exploitation appears as legitimate cross-contract interaction
- No on-chain events indicate theft (only `Approved` event from TokenContract)
- Victims only discover theft when checking virtual address balances or claiming profits

**Probability Reasoning:**
While system contracts are trusted components, defense-in-depth security principles suggest protecting against:
- Undiscovered bugs in ProfitContract (all code has potential bugs)
- Future protocol upgrades introducing vulnerabilities
- Governance key compromise scenarios

The approve-without-verification pattern is widely recognized as risky in blockchain security, regardless of callee trust assumptions.

### Recommendation

**Immediate Mitigation - Add Post-Call Verification:**

```csharp
public override Empty ContributeProfits(ContributeProfitsInput input)
{
    var scheme = GetValidScheme(input.SchemeManager);
    if (State.TokenContract.Value == null)
        State.TokenContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

    // Transfer tokens to self
    State.TokenContract.TransferFrom.Send(new TransferFromInput
    {
        From = Context.Sender,
        To = Context.Self,
        Symbol = input.Symbol,
        Amount = input.Amount
    });

    // Get scheme virtual address BEFORE call
    var profitScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
    var expectedDestination = profitScheme.VirtualAddress;
    
    // Record balance before
    var balanceBefore = State.TokenContract.GetBalance.Call(new GetBalanceInput
    {
        Owner = expectedDestination,
        Symbol = input.Symbol
    }).Balance;

    State.TokenContract.Approve.Send(new ApproveInput
    {
        Spender = State.ProfitContract.Value,
        Symbol = input.Symbol,
        Amount = input.Amount
    });

    State.ProfitContract.ContributeProfits.Send(new Profit.ContributeProfitsInput
    {
        SchemeId = scheme.SchemeId,
        Symbol = input.Symbol,
        Amount = input.Amount
    });

    // VERIFICATION: Ensure tokens reached correct destination
    var balanceAfter = State.TokenContract.GetBalance.Call(new GetBalanceInput
    {
        Owner = expectedDestination,
        Symbol = input.Symbol
    }).Balance;
    
    Assert(balanceAfter >= balanceBefore.Add(input.Amount), 
        "Profit contribution failed: tokens did not reach scheme virtual address");

    return new Empty();
}
```

**Alternative Mitigation - Eliminate Approval:**

Instead of approve-then-call, transfer directly to virtual address and notify ProfitContract:
1. Query scheme virtual address first
2. Transfer tokens directly to virtual address
3. Call ProfitContract to record the contribution (read-only or with minimal trust)

**Invariant Checks:**
- Pre-condition: TokenHolderContract holds `input.Amount` of `input.Symbol`
- Post-condition: Scheme virtual address balance increased by exactly `input.Amount`
- Post-condition: TokenHolderContract approval for ProfitContract is zero or minimal

**Regression Test:**
Create test with mock malicious ProfitContract that attempts to drain tokens to attacker address, verify transaction reverts with appropriate error message.

### Proof of Concept

**Initial State:**
- User has 1000 ELF tokens
- User has approved TokenHolderContract for 1000 ELF
- TokenHolder scheme exists with SchemeId = SCHEME_X
- ProfitContract is compromised with malicious code

**Malicious ProfitContract Behavior:**
```csharp
// Instead of legitimate transfer to virtualAddress:
public override Empty ContributeProfits(ContributeProfitsInput input)
{
    // Malicious: transfer to attacker instead
    State.TokenContract.TransferFrom.Send(new TransferFromInput
    {
        From = Context.Sender, // TokenHolderContract
        To = ATTACKER_ADDRESS,  // NOT virtualAddress!
        Symbol = input.Symbol,
        Amount = input.Amount,
        Memo = "Drained"
    });
    
    // Optionally: still update scheme state to hide theft
    // ...legitimate state updates...
    
    return new Empty();
}
```

**Attack Sequence:**
1. User calls `TokenHolderContract.ContributeProfits(schemeManager=MANAGER, symbol="ELF", amount=1000)`
2. TokenHolderContract executes lines 107-113: 1000 ELF transferred to TokenHolderContract
3. TokenHolderContract executes lines 115-120: Approves ProfitContract for 1000 ELF
4. TokenHolderContract executes line 122: Calls malicious `ProfitContract.ContributeProfits`
5. Malicious ProfitContract calls `TransferFrom` to move 1000 ELF to attacker address
6. Transaction completes successfully (no reversion)

**Expected vs Actual Result:**
- **Expected**: 1000 ELF in scheme virtual address, available for beneficiary distribution
- **Actual**: 1000 ELF in attacker address, zero ELF in virtual address

**Success Condition:**
- Attacker balance increases by 1000 ELF
- Virtual address balance remains unchanged
- TokenHolderContract balance returns to zero
- No transaction revert occurs
- User loses all contributed tokens with no recovery path

**Notes:**

This vulnerability follows the classic approve-then-call pattern that has caused numerous exploits in blockchain systems. While ProfitContract is a system contract with high trust assumptions, defense-in-depth security principles dictate that critical fund flows should include verification steps regardless of callee trust level. The absence of post-call verification creates unnecessary risk exposure if ProfitContract contains bugs or is compromised through governance or other means.

The severity is elevated because the vulnerability affects a core economic primitive (profit distribution) and the impact is total fund loss with no recovery mechanism. The recommended mitigation adds minimal gas cost while significantly reducing blast radius in the event of ProfitContract compromise.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L16-18)
```csharp
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L100-129)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.Self,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        State.TokenContract.Approve.Send(new ApproveInput
        {
            Spender = State.ProfitContract.Value,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        State.ProfitContract.ContributeProfits.Send(new Profit.ContributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Symbol = input.Symbol,
            Amount = input.Amount
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L673-680)
```csharp
            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = virtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount,
                Memo = $"Add {input.Amount} dividends."
            });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```
