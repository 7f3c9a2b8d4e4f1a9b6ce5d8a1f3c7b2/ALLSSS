# Audit Report

## Title
3-Miner Configuration Creates Zero Fault Tolerance for Last Irreversible Block Advancement

## Summary
The AEDPoS consensus contract allows configuring exactly 3 miners, which requires unanimous consent for Last Irreversible Block (LIB) advancement. When any single miner goes offline, the LIB stops advancing indefinitely, halting transaction finality and blocking cross-chain operations.

## Finding Description

The Byzantine Fault Tolerance (BFT) threshold is calculated by the `MinersCountOfConsent` property, which implements the formula: count × 2 ÷ 3 + 1. [1](#0-0) 

For exactly 3 miners: 3 × 2 ÷ 3 + 1 = 2 + 1 = 3, requiring unanimous participation from all miners.

The `LastIrreversibleBlockHeightCalculator` determines LIB advancement by counting miners who participated in the current round. [2](#0-1)  It retrieves their implied irreversible block heights from the previous round. If the count of participating miners falls below `MinersCountOfConsent`, the calculator sets `libHeight = 0`, preventing any blocks from becoming irreversible. [3](#0-2) 

During block production, the `ProcessUpdateValue` method calculates the new LIB height and only advances it if the calculated height exceeds the current confirmed irreversible block height. [4](#0-3) 

The `SetMaximumMinersCount` method only validates that the input value is positive, with no minimum threshold requirement. [5](#0-4)  Test cases explicitly validate 3-miner configurations as acceptable. [6](#0-5) 

While `SolitaryMinerDetection` prevents a single miner from continuing indefinitely when all others are offline, [7](#0-6)  it does not address the scenario where 2 out of 3 miners continue producing blocks but cannot reach the unanimous consensus threshold required for LIB advancement.

## Impact Explanation

**Operational Denial of Service on Transaction Finality:**

When the LIB stops advancing, no new blocks become irreversible, leaving all transactions in an unfinalized state indefinitely. This creates operational uncertainty for users and applications requiring finality guarantees.

**Cross-Chain Operations Blocked:**

Cross-chain indexing mechanisms depend on LIB heights for safety guarantees. The system checks if blocks have reached irreversibility before allowing cross-chain data indexing. [8](#0-7) [9](#0-8)  When LIB advancement halts, all cross-chain operations that require irreversible block proofs are blocked.

**Severity Justification:**

This is a **Medium severity** availability issue. The system maintains safety (no invalid blocks are accepted, no funds are at risk), but loses liveness (no blocks can achieve finality). While block production continues with 2 out of 3 miners, the inability to finalize blocks creates cascading operational impacts on dependent protocols and cross-chain infrastructure.

## Likelihood Explanation

**High Likelihood in 3-Miner Configurations:**

The configuration is explicitly permitted without warnings or minimum validation requirements. Single-node failures are common operational events in distributed systems, including:

- Hardware failures or crashes
- Software updates requiring restarts
- Network partitions isolating a single node
- Scheduled maintenance windows
- Resource exhaustion (CPU, memory, disk)

**No Attacker Required:**

This is not an attack scenario—it is a natural operational failure mode. Any production system configured with exactly 3 miners will experience this issue whenever a single miner becomes unavailable, which is a realistic and expected event in any distributed system deployment.

**Immediate Detection:**

The issue manifests immediately when any miner goes offline, observable through monitoring systems tracking `ConfirmedIrreversibleBlockHeight`. Recovery requires all 3 miners to be operational and producing blocks again.

## Recommendation

Implement a minimum miners count validation in `SetMaximumMinersCount`:

```csharp
Assert(input.Value >= 4, "Minimum 4 miners required for fault tolerance.");
```

This ensures at least f = 1 Byzantine fault tolerance, where the system can continue advancing LIB even if one miner fails.

Alternatively, add clear warnings in documentation and governance interfaces when configuring 3 or fewer miners, explaining the zero-fault-tolerance implications.

For existing deployments with 3 miners, increase the miner count through governance proposals using the Parliament contract.

## Proof of Concept

The mathematical proof is straightforward:

**BFT Formula:** MinersCountOfConsent = ⌊n × 2/3⌋ + 1

**For n = 3 miners:**
- MinersCountOfConsent = ⌊3 × 2/3⌋ + 1 = ⌊2⌋ + 1 = 2 + 1 = 3
- Fault tolerance: f = ⌊(n-1)/3⌋ = ⌊2/3⌋ = 0

**For n = 4 miners:**
- MinersCountOfConsent = ⌊4 × 2/3⌋ + 1 = ⌊2.67⌋ + 1 = 2 + 1 = 3
- Fault tolerance: f = ⌊(n-1)/3⌋ = ⌊1⌋ = 1

**Scenario:**
1. System configured with 3 miners (Miner A, B, C)
2. Miner C goes offline (hardware failure, maintenance, etc.)
3. Miners A and B continue producing blocks (2 out of 3 is sufficient for basic consensus)
4. `LastIrreversibleBlockHeightCalculator` counts participating miners: 2
5. Check fails: 2 < 3 (MinersCountOfConsent)
6. Result: libHeight = 0, LIB stops advancing
7. Impact: No blocks become finalized, cross-chain operations blocked

The existing test suite validates 3-miner configurations as acceptable, confirming this is an allowed configuration that creates the described vulnerability.

---

## Notes

This is a design-level configuration vulnerability in the consensus mechanism. The BFT formula implementation is mathematically correct, but the lack of minimum validation allows operationally risky configurations. The issue affects **availability and liveness** guarantees without compromising **safety** (no invalid state transitions occur). Production deployments should use a minimum of 4 miners to ensure at least one Byzantine fault tolerance.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-29)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-280)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L14-14)
```csharp
        Assert(input.Value > 0, "Invalid max miners count.");
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L28-28)
```csharp
    [InlineData(3)]
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L70-70)
```csharp
        if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
```

**File:** src/AElf.CrossChain.Core/Extensions/LocalLibExtensions.cs (L14-14)
```csharp
        if (chain.LastIrreversibleBlockHeight < height + CrossChainConstants.LibHeightOffsetForCrossChainIndex)
```

**File:** src/AElf.CrossChain.Core/CrossChainConstants.cs (L7-7)
```csharp
    public const int LibHeightOffsetForCrossChainIndex = 0;
```
