# Audit Report

## Title
Unhandled KeyNotFoundException in RecoverFromUpdateValue During Miner Replacement Causes Block Validation DoS

## Summary
The `RecoverFromUpdateValue` method contains an unprotected dictionary access in a foreach loop that causes a `KeyNotFoundException` when a miner replacement transaction executes in the same block as UpdateValue consensus behavior. This results in block validation failure and consensus disruption.

## Finding Description

The vulnerability exists in the `RecoverFromUpdateValue` method where a foreach loop iterates over all miners in the provided round and directly accesses them in the current round's dictionary without existence checks. [1](#0-0) 

While lines 10-12 protect the specific `pubkey` parameter, the foreach loop at lines 22-30 assumes all miners from `providedRound` exist in the current round's `RealTimeMinersInformation` dictionary. This assumption breaks when miner replacement occurs.

The attack sequence:

1. **Miner replacement execution**: When `ReplaceCandidatePubkey` is called, it triggers `RecordCandidateReplacement` in the consensus contract. [2](#0-1) [3](#0-2) 

2. **State modification**: The consensus contract removes the old pubkey and adds the new pubkey to the current round. [4](#0-3) 

3. **Post-execution validation**: After transactions execute, `ValidateConsensusAfterExecution` retrieves the modified state and attempts to recover the header round (which contains the old pubkey). [5](#0-4) 

4. **Exception before detection**: The `KeyNotFoundException` is thrown at line 91 during `RecoverFromUpdateValue`, before the replacement detection logic at lines 99-124 can execute. [6](#0-5) 

The replacement detection logic exists but is unreachable because the exception occurs first.

## Impact Explanation

**Consensus Availability Impact:**
- Blocks containing miner replacement transactions with UpdateValue behavior fail validation with an unhandled exception
- Block validation failure prevents block acceptance by the network
- Affects consensus reliability and chain availability
- The failure occurs after transaction execution, potentially leaving state in an inconsistent condition between the executing node and validating nodes

**Affected Operations:**
- Any legitimate miner replacement operation during UpdateValue blocks
- Normal consensus operations if replacement transactions are broadcast during active mining periods
- Network validators that attempt to validate affected blocks

**Severity Justification:** Medium-High. While not directly causing fund loss, this vulnerability:
- Disrupts core consensus operations
- Can cause legitimate blocks to be rejected
- Affects network availability
- Can be triggered during normal operational procedures (miner key rotation)

## Likelihood Explanation

**Access Control Requirements:**
The vulnerability requires being the admin of a currently active miner's pubkey. [7](#0-6) 

Admins are set through legitimate governance mechanisms: [8](#0-7) 

**Triggering Conditions:**
1. Actor must be (or control) the admin of a current miner's candidate pubkey
2. Submit `ReplaceCandidatePubkey` transaction during or just before the target miner's time slot
3. The mining node includes the transaction in their block with UpdateValue behavior
4. Post-execution validation fails with `KeyNotFoundException`

**Feasibility Assessment:**
- **Intentional Attack**: Requires the attacker to be an active miner or control a miner's admin rights (medium barrier)
- **Accidental Trigger**: More likely - legitimate miners performing key rotation could unknowingly trigger this during their mining period
- **No Special Conditions**: Once access is achieved, the vulnerability is reliably triggerable

**Probability:** Medium. The access requirement (active miner admin) is a moderate barrier, but once achieved, the vulnerability is deterministically triggerable. More importantly, this can occur accidentally during legitimate miner key rotation operations.

## Recommendation

Add existence checks before accessing miners in the foreach loop:

```csharp
foreach (var information in providedRound.RealTimeMinersInformation)
{
    // Check if the miner exists in current round before accessing
    if (!RealTimeMinersInformation.ContainsKey(information.Key))
        continue;
        
    RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
        information.Value.SupposedOrderOfNextRound;
    RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
        information.Value.FinalOrderOfNextRound;
    RealTimeMinersInformation[information.Key].PreviousInValue =
        information.Value.PreviousInValue;
}
```

Alternatively, restructure the validation to handle replacement scenarios before attempting recovery, or use TryGetValue patterns throughout.

## Proof of Concept

```csharp
// POC Test: Demonstrates KeyNotFoundException during miner replacement in UpdateValue block
[Fact]
public async Task MinerReplacementInUpdateValueBlock_ShouldThrowKeyNotFoundException()
{
    // Setup: Initialize consensus with active miners
    var initialMiners = GenerateInitialMiners(3);
    await InitializeConsensus(initialMiners);
    
    // Step 1: Register first miner as candidate with admin rights
    var oldPubkey = initialMiners[0];
    var newPubkey = GenerateNewPubkey();
    var adminAccount = Accounts[0];
    
    await SetCandidateAdmin(oldPubkey, adminAccount.Address);
    
    // Step 2: Produce a block with UpdateValue behavior
    var currentRound = await GetCurrentRound();
    var blockTime = currentRound.RealTimeMinersInformation[oldPubkey].ExpectedMiningTime;
    
    // Step 3: Include ReplaceCandidatePubkey transaction in the block
    var replaceResult = await ExecuteTransaction(
        adminAccount,
        ElectionContractAddress,
        nameof(ReplaceCandidatePubkey),
        new ReplaceCandidatePubkeyInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        }
    );
    
    Assert.True(replaceResult.Status == TransactionResultStatus.Mined);
    
    // Step 4: Attempt post-execution validation with UpdateValue header
    var headerInfo = CreateUpdateValueHeader(oldPubkey, currentRound);
    
    // Step 5: Validation should throw KeyNotFoundException
    var exception = await Assert.ThrowsAsync<KeyNotFoundException>(async () =>
    {
        await ValidateConsensusAfterExecution(headerInfo);
    });
    
    // Verify the exception occurs during RecoverFromUpdateValue
    Assert.Contains("RealTimeMinersInformation", exception.Message);
}
```

## Notes

This vulnerability represents a **timing-based consensus disruption** where the order of operations (state modification before validation) combined with incomplete defensive checks creates a denial-of-service condition. The issue is particularly concerning because:

1. **Legitimate Use Case Affected**: Normal miner key rotation operations can accidentally trigger this
2. **Exception Location**: The exception occurs before replacement detection logic can handle it properly
3. **Partial Solution Exists**: The code at lines 99-124 attempts to detect replacements but is unreachable

The root cause is architectural - the validation logic attempts to reconcile pre-execution and post-execution states without accounting for state-modifying transactions that change the miner set during block execution.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-146)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-92)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L99-124)
```csharp
            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-42)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;
```
