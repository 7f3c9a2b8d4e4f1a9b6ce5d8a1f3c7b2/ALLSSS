### Title
Stale Admin Privileges After Parliament-Initiated Admin Change Allows Unauthorized Governance Voting

### Summary
When Parliament changes a candidate's admin via `SetCandidateAdmin`, the function fails to remove the candidate from the old admin's `ManagedCandidatePubkeysMap` entry, creating a bidirectional consistency violation. This allows the revoked admin to continue voting on Parliament proposals on behalf of the candidate, bypassing the intended admin change and enabling unauthorized governance actions.

### Finding Description

The vulnerability exists in the `SetCandidateAdmin` method which manages the bidirectional mapping between candidates and their admins: [1](#0-0) 

When Parliament calls `SetCandidateAdmin` to change a candidate's admin from A to B, the permission check is bypassed for Parliament: [2](#0-1) 

The function correctly updates `CandidateAdmins[pubkey]` to point to the new admin and adds the pubkey to the new admin's managed list: [3](#0-2) 

However, the critical bug occurs in the cleanup logic which attempts to remove the pubkey from the old admin's list but instead removes it from `Context.Sender` (Parliament's address): [4](#0-3) 

Since Parliament's `ManagedCandidatePubkeysMap` is empty or doesn't contain this pubkey, no removal occurs from the actual old admin A's list. This creates an inconsistent state where:
- `CandidateAdmins[X] = B` (correct)
- `ManagedCandidatePubkeysMap[A] = [X]` (stale!)
- `ManagedCandidatePubkeysMap[B] = [X]` (correct)

The Parliament contract's authorization mechanism relies on `GetManagedPubkeys` to allow admins to vote on behalf of their managed candidates: [5](#0-4) 

This authorization check is used in critical governance methods: [6](#0-5) 

Because the old admin A still has the stale entry in `ManagedCandidatePubkeysMap[A]`, the authorization check at line 129 (`GetManagedPubkeys.Call(Context.Sender)`) returns the candidate's pubkey, allowing A to pass all checks and vote on proposals as if they were still the legitimate admin.

### Impact Explanation

**Governance Authorization Bypass:** The revoked admin retains the ability to vote (Approve/Reject/Abstain) on Parliament proposals on behalf of a miner they should no longer control. Both the old admin A and new admin B can simultaneously vote on behalf of the same miner, effectively giving one miner two votes.

**Affected Parties:**
- **Protocol Governance:** Compromised admin changes fail to revoke access, allowing potentially malicious or compromised former admins to continue participating in critical decisions
- **New Admins:** The intended admin change is undermined as the old admin retains full voting privileges
- **Parliament Members:** Proposal outcomes can be manipulated by unauthorized voters

**Concrete Harm:**
- Unauthorized approval/rejection of system contract upgrades
- Manipulation of economic parameters (mining rewards, fees, inflation)
- Unauthorized cross-chain management decisions
- Compromise of any governance-controlled protocol parameters

**Severity Justification:** HIGH - This is a direct governance authorization bypass that affects the core decision-making mechanism of the protocol. While it requires Parliament to trigger the bug (not an external attacker directly), the scenario of changing a compromised or lost admin is a legitimate operational need, making this vulnerability practically exploitable in real-world situations.

### Likelihood Explanation

**Attacker Capabilities:** The "attacker" is a former admin (A) whose privileges were supposed to be revoked. They only need to control their original admin address and know how to call Parliament contract methods.

**Attack Complexity:** Very low. The vulnerability is triggered automatically when Parliament changes an admin via `SetCandidateAdmin`. No sophisticated exploitation technique is required - the old admin simply calls `Parliament.Approve/Reject/Abstain` as they would normally.

**Feasibility Conditions:**
1. Parliament must change a candidate's admin (legitimate operational scenario when admin keys are compromised or organizational changes occur)
2. The candidate must be a current miner/parliament member
3. The old admin must still control their address

**Precondition Realism:** All preconditions are realistic and expected to occur in normal operations. Changing admins due to security incidents (compromised keys) or organizational restructuring is a standard governance operation.

**Detection Constraints:** The bug is silent - no error is thrown, and the inconsistent state is not easily detectable without explicitly querying both `GetCandidateAdmin` and `GetManagedPubkeys` and comparing results.

**Probability Assessment:** High likelihood. Every admin change initiated by Parliament creates this vulnerability, and former admins may not realize their access should have been revoked, leading to accidental or intentional exploitation.

### Recommendation

**Immediate Fix:** Modify `SetCandidateAdmin` to track and remove from the actual old admin's list:

1. Before line 42, store the old admin address: `var oldAdmin = State.CandidateAdmins[pubkey];`
2. After updating the new admin (line 42), check if `oldAdmin` exists and is different from `input.Admin`
3. If so, remove the pubkey from `State.ManagedCandidatePubkeysMap[oldAdmin]` instead of from `Context.Sender`
4. Only remove from `Context.Sender` when the caller is the actual old admin (non-Parliament case)

**Specific Code Change Location:** [7](#0-6) 

**Invariant Check to Add:** After any admin change operation, assert that `ManagedCandidatePubkeysMap[oldAdmin]` does not contain the pubkey and `ManagedCandidatePubkeysMap[newAdmin]` does contain it.

**Test Cases to Add:**
1. Test Parliament changing an admin and verify old admin cannot vote
2. Test that `GetManagedPubkeys(oldAdmin)` returns empty list after admin change
3. Test that old admin's `Approve` call fails with "Unauthorized sender" after admin change
4. Test bidirectional consistency after every admin change operation

### Proof of Concept

**Initial State:**
- Candidate X with pubkey "0xABC..." is a current parliament member (miner)
- Admin A (address 0x123...) manages X
- `CandidateAdmins["0xABC..."] = 0x123...`
- `ManagedCandidatePubkeysMap[0x123...] = ["0xABC..."]`

**Transaction Steps:**

1. **Parliament changes admin:**
   - Caller: Parliament default organization
   - Method: `Election.SetCandidateAdmin({Pubkey: "0xABC...", Admin: 0x456...})`
   - Expected: A loses access, B gains access
   - Actual state after:
     - `CandidateAdmins["0xABC..."] = 0x456...` ✓
     - `ManagedCandidatePubkeysMap[0x123...] = ["0xABC..."]` ✗ (should be empty)
     - `ManagedCandidatePubkeysMap[0x456...] = ["0xABC..."]` ✓

2. **Old admin A attempts to vote on proposal:**
   - Caller: Admin A (0x123...)
   - Method: `Parliament.Approve(proposalId)`
   - Expected: Transaction fails with "Unauthorized sender"
   - Actual: Transaction succeeds, vote is counted
   - Reason: `GetManagedPubkeys(0x123...)` still returns `["0xABC..."]`, passing authorization checks

3. **Verification:**
   - Query `GetCandidateAdmin("0xABC...")` returns 0x456... (correct)
   - Query `GetManagedPubkeys(0x123...)` returns `["0xABC..."]` (incorrect - stale)
   - Both admin A and admin B can vote on behalf of X
   - Proposal state shows X's vote recorded from A's transaction

**Success Condition:** The old admin A successfully calls `Parliament.Approve/Reject/Abstain` after being replaced, and their vote is counted, demonstrating unauthorized governance participation.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L68-73)
```csharp
    public MappedState<string, Address> CandidateAdmins { get; set; }

    /// <summary>
    ///     Admin address -> Pubkey
    /// </summary>
    public MappedState<Address, PubkeyList> ManagedCandidatePubkeysMap { get; set; }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-57)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;

        var pubkeyByteString = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey));

        var newAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[input.Admin] ?? new PubkeyList();
        if (!newAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            newAdminManagedPubkeys.Value.Add(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[input.Admin] = newAdminManagedPubkeys;

        var oldAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[Context.Sender] ?? new PubkeyList();
        if (oldAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            oldAdminManagedPubkeys.Value.Remove(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[Context.Sender] = oldAdminManagedPubkeys;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L112-140)
```csharp
    private Address GetAndCheckActualParliamentMemberAddress()
    {
        var currentParliament = GetCurrentMinerList();

        if (currentParliament.Any(r => r.Equals(Context.Sender))) return Context.Sender;

        if (State.ElectionContract.Value == null)
        {
            var electionContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName);
            if (electionContractAddress == null)
                // Election Contract not deployed - only possible in test environment.
                throw new AssertionException("Unauthorized sender.");

            State.ElectionContract.Value = electionContractAddress;
        }

        var managedPubkey = State.ElectionContract.GetManagedPubkeys.Call(Context.Sender);
        if (!managedPubkey.Value.Any()) throw new AssertionException("Unauthorized sender.");

        if (managedPubkey.Value.Count > 1)
            throw new AssertionException("Admin with multiple managed pubkeys cannot handle proposal.");

        var actualMemberAddress = Address.FromPublicKey(managedPubkey.Value.Single().ToByteArray());
        if (!currentParliament.Any(r => r.Equals(actualMemberAddress)))
            throw new AssertionException("Unauthorized sender.");

        return actualMemberAddress;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L78-93)
```csharp
    public override Empty Approve(Hash input)
    {
        var parliamentMemberAddress = GetAndCheckActualParliamentMemberAddress();
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedByMember(proposal, parliamentMemberAddress);
        proposal.Approvals.Add(parliamentMemberAddress);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = parliamentMemberAddress,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
```
