### Title
Long-Range Attack: Missing Fork Point Validation Against Last Irreversible Block Height

### Summary
The block synchronization and attachment logic validates that incoming blocks have heights above the Last Irreversible Block (LIB), but fails to verify that the block's previous block (fork point) is also above LIB. This allows an attacker with compromised historical miner keys or sufficient miner collusion to create alternate chains forking from before the finality checkpoint, potentially rewriting finalized history.

### Finding Description

**Root Cause:**

The system has two separate validations that together create a gap:

1. **Block Sync Validation** - checks incoming block height but not fork point: [1](#0-0) 

This validation only checks if `blockWithTransactions.Height <= chain.LastIrreversibleBlockHeight`, rejecting blocks at or below LIB height. However, it does NOT validate that the block's `PreviousBlockHash` points to a block above LIB.

2. **Block Attachment Logic** - accepts any linked previous block regardless of LIB: [2](#0-1) 

When attaching a block, the system retrieves the previous block from the database and checks only if it exists and is linked (`previousChainBlockLink.IsLinked`), without verifying `previousChainBlockLink.Height > chain.LastIrreversibleBlockHeight`.

3. **Blocks below LIB persist in database:** [3](#0-2) 

The cleanup process removes branch references and state sets but does not delete the actual block headers/bodies, leaving them available as potential fork points.

4. **In-value/out-value validation is independent of chain position:** [4](#0-3) 

This validation only verifies the cryptographic relationship `HashHelper.ComputeFrom(previousInValue) == previousOutValue` without checking whether these values belong to the canonical post-LIB chain.

**Exploitation Path:**

1. Attacker identifies a block below LIB (e.g., height 90, when LIB is at 100)
2. Attacker creates fork blocks 91', 92', ..., 150' with valid consensus data
3. Attacker submits blocks starting from 91' onward
4. Each block passes `ValidateBlockBeforeSyncAsync` because height > LIB (e.g., 150 > 100)
5. Each block passes `AttachBlockToChainAsync` because previous blocks exist and are linked
6. In-value/out-value chains validate correctly if properly constructed
7. If fork reaches sufficient length (≥8 blocks longer or extends longest chain), it becomes the new longest chain: [5](#0-4) 

### Impact Explanation

**Consensus/Cross-Chain Integrity:**
- Violates the fundamental finality guarantee of the Last Irreversible Block mechanism
- LIB is critical for cross-chain operations which rely on irreversible heights for merkle proof verification
- A successful long-range attack could invalidate cross-chain transactions that referenced the original chain

**Direct Financial Impact:**
- Enables double-spending attacks if the alternate chain contains different transactions than the finalized chain
- Could reverse token transfers, contract executions, and governance decisions that occurred after the fork point
- Treasury and profit distributions could be recalculated based on alternate history

**Operational Impact:**
- Forces chain reorganization below what should be the immutable checkpoint
- Could cause inconsistencies in validator rewards and election results
- May require manual intervention to recover consensus

### Likelihood Explanation

**Attacker Capabilities Required:**

1. **Historical Miner Key Compromise**: Attacker needs access to private keys of miners who were active at the fork point (below LIB). This could occur through:
   - Stolen/leaked historical key material
   - Compromised key management systems
   - Social engineering of former validators

2. **Miner Collusion**: Alternatively, attacker could collude with sufficient current miners to produce valid signatures for the alternate chain

3. **Consensus Data Construction**: Attacker must create valid:
   - Round progressions matching AEDPoS rules
   - Time slot allocations
   - Cryptographic in-value/out-value chains
   - Miner signatures for each block

**Feasibility Conditions:**
- Blocks below LIB remain in database (confirmed)
- No validation prevents referencing them as previous blocks (confirmed)
- Attacker has resources to build chain to sufficient height (high computational cost)
- Network will accept and propagate the fork blocks (depends on peer validation)

**Detection Constraints:**
- Honest nodes would detect sudden long reorganizations below LIB
- However, no automatic rejection mechanism exists at the protocol level
- Manual intervention would be required to reject the malicious fork

**Probability Assessment:**
- Medium-to-Low practical likelihood due to significant resource requirements
- Higher risk in scenarios where historical keys have been compromised or miners are corrupted
- The architectural flaw exists regardless of current practical exploitability

### Recommendation

**Immediate Fix:**

Add explicit fork point validation in `ChainManager.AttachBlockToChainAsync` before accepting a block:

```csharp
// After line 210 in IChainManager.cs
var previousChainBlockLink = await GetChainBlockLinkAsync(chainBlockLink.PreviousBlockHash);
if (previousChainBlockLink != null && previousChainBlockLink.IsLinked)
{
    // ADD THIS CHECK:
    if (previousChainBlockLink.Height <= chain.LastIrreversibleBlockHeight)
    {
        Logger.LogWarning(
            $"Rejecting block {chainBlockLink.BlockHash} at height {chainBlockLink.Height} " +
            $"because it forks from height {previousChainBlockLink.Height} " +
            $"which is below LIB {chain.LastIrreversibleBlockHeight}");
        status = BlockAttachOperationStatus.NewBlockNotLinked;
        break;
    }
    
    chain.Branches[previousChainBlockLink.BlockHash.ToStorageKey()] = previousChainBlockLink.Height;
    continue;
}
```

**Additional Hardening:**

1. Add validation in `BlockSyncValidationService.ValidateBlockBeforeSyncAsync`:
```csharp
// Check that previous block height is above LIB
var previousBlock = await _blockchainService.GetBlockHeaderByHashAsync(blockWithTransactions.Header.PreviousBlockHash);
if (previousBlock != null && previousBlock.Height <= chain.LastIrreversibleBlockHeight)
{
    Logger.LogDebug($"Rejecting block {blockWithTransactions} forking from below LIB.");
    return Task.FromResult(false);
}
```

2. Consider periodically pruning ChainBlockLinks for blocks significantly below LIB (not just branch references) to reduce attack surface

3. Add monitoring/alerting for attempted chain reorganizations below LIB height

**Test Cases:**

1. Test that blocks forking from exactly LIB height are rejected
2. Test that blocks forking from LIB-1, LIB-10, etc. are rejected
3. Test that legitimate blocks extending from above LIB are still accepted
4. Test edge case where LIB advances while fork blocks are being processed

### Proof of Concept

**Initial State:**
- Chain at height 150, LIB at height 100
- Block at height 90 exists in database (below LIB)
- Attacker has compromised miner keys from height 90 era

**Attack Sequence:**

1. Attacker constructs block 91' forking from block 90:
   - `PreviousBlockHash` = hash of block 90
   - Valid miner signature using compromised key
   - Valid consensus round data continuing from block 90's state
   - Height = 91

2. Attacker submits block 91' via network sync:
   - Passes `ValidateBlockBeforeSyncAsync`: 91 > 100 (LIB) ✓
   - Passes `ValidateBlockBeforeAttachAsync`: structure valid ✓
   - `AttachBlockToChainAsync` retrieves block 90 from database
   - Block 90 exists and `IsLinked = true` ✓
   - Block 91' is added to chain branches

3. Attacker continues with blocks 92', 93', ..., 158' (each forking from previous):
   - All blocks pass height check (> LIB)
   - All blocks have valid previous blocks in the fork chain
   - In-value/out-value chains validate correctly within the fork

4. At block 158', fork height (158) ≥ current longest chain height (150) + 8:
   - `AttachBlockToChainAsync` sets fork as new longest chain
   - Fork blocks start executing
   - Chain reorganizes to alternate history from block 90

**Expected Result:** Block 91' should be rejected because previous block (90) is below LIB

**Actual Result:** Block 91' is accepted because only the incoming block's height is checked against LIB, not the previous block's height

**Success Condition:** Chain reorganizes to fork starting from block 90, violating finality guarantee of LIB mechanism

### Notes

The vulnerability represents an architectural gap in the LIB enforcement mechanism. While the Last Irreversible Block concept provides finality guarantees in theory, the implementation only validates that new blocks are above LIB, not that their fork points are above LIB. This allows sophisticated attackers with compromised historical keys or sufficient miner collusion to bypass finality protections.

The practical exploitability is constrained by the need for valid consensus data and miner signatures, but the protocol-level weakness exists regardless. The fix is straightforward: add explicit validation that previous block height exceeds `LastIrreversibleBlockHeight` before accepting any block attachment.

### Citations

**File:** src/AElf.OS/BlockSync/Application/BlockSyncValidationService.cs (L52-59)
```csharp
    public Task<bool> ValidateBlockBeforeSyncAsync(Chain chain, BlockWithTransactions blockWithTransactions,
        string senderPubKey)
    {
        if (blockWithTransactions.Height <= chain.LastIrreversibleBlockHeight)
        {
            Logger.LogDebug($"Receive lower block {blockWithTransactions} ignore.");
            return Task.FromResult(false);
        }
```

**File:** src/AElf.Kernel.Core/Blockchain/Domain/IChainManager.cs (L180-186)
```csharp
                if ((isLinkedToLongestChain && chainBlockLink.Height > chain.LongestChainHeight)
                    || chainBlockLink.Height >= chain.LongestChainHeight + 8)
                {
                    chain.LongestChainHeight = chainBlockLink.Height;
                    chain.LongestChainHash = chainBlockLink.BlockHash;
                    status |= BlockAttachOperationStatus.LongestChainFound;
                }
```

**File:** src/AElf.Kernel.Core/Blockchain/Domain/IChainManager.cs (L207-215)
```csharp
            else
            {
                //check database to ensure whether it can be a branch
                var previousChainBlockLink = await GetChainBlockLinkAsync(chainBlockLink.PreviousBlockHash);
                if (previousChainBlockLink != null && previousChainBlockLink.IsLinked)
                {
                    chain.Branches[previousChainBlockLink.BlockHash.ToStorageKey()] = previousChainBlockLink.Height;
                    continue;
                }
```

**File:** src/AElf.Kernel/NewIrreversibleBlockFoundEventHandler.cs (L53-76)
```csharp
    private void CleanChain(Hash irreversibleBlockHash, long irreversibleBlockHeight)
    {
        _taskQueueManager.Enqueue(async () =>
        {
            // Clean BlockStateSet
            var discardedBlockHashes = _chainBlockLinkService.GetCachedChainBlockLinks()
                .Where(b => b.Height <= irreversibleBlockHeight).Select(b => b.BlockHash).ToList();
            await _blockchainStateService.RemoveBlockStateSetsAsync(discardedBlockHashes);

            // Clean chain branch
            var chain = await _blockchainService.GetChainAsync();
            var discardedBranch = await _blockchainService.GetDiscardedBranchAsync(chain);

            _taskQueueManager.Enqueue(
                async () =>
                {
                    if (discardedBranch.BranchKeys.Count > 0 || discardedBranch.NotLinkedKeys.Count > 0)
                        await _blockchainService.CleanChainBranchAsync(discardedBranch);

                    await LocalEventBus.PublishAsync(new CleanBlockExecutedDataChangeHeightEventData
                    {
                        IrreversibleBlockHeight = irreversibleBlockHeight
                    });
                    _chainBlockLinkService.CleanCachedChainBlockLinks(irreversibleBlockHeight);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```
