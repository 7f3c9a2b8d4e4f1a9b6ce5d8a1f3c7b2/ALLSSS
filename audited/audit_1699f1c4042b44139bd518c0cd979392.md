# Audit Report

## Title
Permanent Loss of Fungible Tokens When Assembled NFTs Are Burned Directly

## Summary
The NFT contract's `Burn` method allows destruction of assembled NFTs without cleaning up the `AssembledFtsMap` state or returning locked fungible tokens to their owners. This results in permanent and irreversible loss of the FTs that were locked during assembly, as no recovery mechanism exists in the contract.

## Finding Description

The root cause lies in the `Burn` method's lack of validation for assembled NFTs. [1](#0-0) 

The method only validates three conditions: whether the NFT protocol is burnable, whether the caller is in the minter list, and whether the caller has sufficient balance. Critically, it does NOT check whether the NFT has associated fungible tokens stored in `AssembledFtsMap`, nor does it clean up or return these locked tokens.

When an NFT is assembled with fungible tokens, the `Assemble` method transfers FTs from the user to the contract address and stores the mapping. [2](#0-1)  The mapping is then persisted in state: [3](#0-2) 

The state variable is defined as: [4](#0-3) 

The correct flow to retrieve these FTs is through the `Disassemble` method, which burns the NFT, retrieves the locked FTs, transfers them back to the receiver, and removes the mapping entry. [5](#0-4) 

However, if a minter directly calls `Burn` on an assembled NFT, the NFT is destroyed but the `AssembledFtsMap` entry persists orphaned. Since `Disassemble` requires the NFT to exist (it calls `Burn` internally which checks balance), and the contract provides no admin recovery functions [6](#0-5) , the locked FTs become permanently inaccessible.

## Impact Explanation

**High Severity - Direct Fund Loss**

The impact is severe and irreversible:

1. **Permanent Fund Lock**: When an assembled NFT is burned directly, fungible tokens transferred during assembly remain locked in the contract address forever. For example, if 100 ELF tokens are assembled into an NFT and the NFT is subsequently burned via `Burn()`, those 100 ELF are permanently lost.

2. **No Recovery Path**: 
   - The `AssembledFtsMap` entry persists but becomes inaccessible since the tokenHash no longer corresponds to an existing NFT
   - `Disassemble` cannot be called because it requires NFT ownership
   - The contract interface confirms no emergency withdrawal or admin recovery methods exist
   - The tokens are effectively removed from circulation without proper accounting

3. **Protocol-Level Impact**: 
   - Unexpected reduction in circulating token supply
   - Breaks the invariant that assembled tokens should always be retrievable
   - Affects protocol integrity and user trust

4. **Affected Parties**: NFT holders who accidentally burn assembled NFTs lose all locked FTs. Given that minters typically have elevated privileges and may assemble high-value NFTs, potential losses could be substantial.

## Likelihood Explanation

**Medium-High Likelihood**

The vulnerability has realistic preconditions and low execution complexity:

**Preconditions** (all realistic):
1. Caller must be a minter (authorized but trusted roles can err or be compromised)
2. Caller must own the assembled NFT (normal operational state)
3. The NFT protocol must have `IsBurnable` set to true (common configuration)

**Attack Complexity**: LOW
- Single direct function call with no complex setup
- Can occur accidentally (user error selecting wrong method)
- Can occur intentionally (malicious or compromised minter)
- No cryptographic or timing requirements

**Feasibility**: HIGH
- No protective logic exists in the code to prevent this scenario
- The test suite demonstrates assembly functionality but lacks validation tests for burning assembled NFTs [7](#0-6) 
- Minters are trusted but human error is inevitable, especially in complex operations

**Detection**: Post-incident only. The loss is only discovered when attempting to retrieve the FTs, by which time recovery is impossible.

## Recommendation

Add validation in the `Burn` method to prevent burning assembled NFTs, or automatically trigger disassembly:

**Option 1 - Prevent Direct Burning (Safer):**
```csharp
public override Empty Burn(BurnInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    
    // Add check for assembled NFTs
    Assert(State.AssembledFtsMap[tokenHash] == null && 
           State.AssembledNftsMap[tokenHash] == null,
           "Cannot burn assembled NFT directly. Use Disassemble method instead.");
    
    // ... rest of existing logic
}
```

**Option 2 - Auto-Disassemble (More Complex):**
Modify `Burn` to check for assembled assets and automatically return them before burning, similar to the `Disassemble` logic.

**Option 3 - Emergency Recovery Function:**
Add an admin-controlled recovery function that can retrieve orphaned FTs (though this introduces centralization concerns).

**Recommendation**: Implement Option 1 as it's the simplest, safest solution that enforces correct usage patterns and prevents fund loss.

## Proof of Concept

```csharp
[Fact]
public async Task BurnAssembledNFT_CausesPermamentFTLoss()
{
    // Setup: Create NFT protocol and mint a base NFT
    var symbol = await CreateTest();
    await AddMinterAsync(symbol);
    var baseTokenHash = (await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        Owner = MinterAddress
    })).Output;

    // Approve ELF tokens for assembly
    await MinterTokenContractStub.Approve.SendAsync(new MultiToken.ApproveInput
    {
        Spender = NFTContractAddress,
        Symbol = "ELF",
        Amount = 1000
    });

    // Check initial ELF balance
    var initialBalance = (await MinterTokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = MinterAddress, Symbol = "ELF" })).Balance;
    
    // Assemble NFT with 100 ELF tokens
    var assembledTokenHash = (await MinterNFTContractStub.Assemble.SendAsync(new AssembleInput
    {
        Symbol = symbol,
        AssembledNfts = new AssembledNfts { Value = { [baseTokenHash.ToHex()] = 1 } },
        AssembledFts = new AssembledFts { Value = { ["ELF"] = 100 } }
    })).Output;

    // Verify FTs were transferred to contract
    var balanceAfterAssembly = (await MinterTokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = MinterAddress, Symbol = "ELF" })).Balance;
    balanceAfterAssembly.ShouldBe(initialBalance - 100);

    // VULNERABILITY: Burn assembled NFT directly instead of disassembling
    await MinterNFTContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = symbol,
        TokenId = /* assembled token id */,
        Amount = 1
    });

    // PROOF: The 100 ELF tokens are permanently locked
    // User cannot call Disassemble (NFT no longer exists)
    // User's ELF balance never recovers
    var finalBalance = (await MinterTokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = MinterAddress, Symbol = "ELF" })).Balance;
    
    // Expected: finalBalance == initialBalance (if properly disassembled)
    // Actual: finalBalance == initialBalance - 100 (FUNDS LOST PERMANENTLY)
    finalBalance.ShouldBe(initialBalance - 100); // Proves permanent loss
    
    // Contract now holds orphaned 100 ELF with no recovery mechanism
    var contractBalance = (await MinterTokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = NFTContractAddress, Symbol = "ELF" })).Balance;
    contractBalance.ShouldBeGreaterThanOrEqualTo(100); // Locked forever
}
```

## Notes

This vulnerability represents a critical flaw in the NFT contract's asset management logic. The separation between `Burn` and `Disassemble` creates an unsafe path where users (particularly minters who have both permissions) can inadvertently or maliciously lock funds permanently. The lack of any validation or recovery mechanism makes this a high-priority security issue requiring immediate remediation.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L134-162)
```csharp
        if (input.AssembledFts.Value.Any())
        {
            metadata.Value[AssembledFtsKey] = input.AssembledFts.ToString();
            // Check balance and allowance.
            foreach (var pair in input.AssembledFts.Value)
            {
                var symbol = pair.Key;
                var amount = pair.Value;
                var balance = State.TokenContract.GetBalance.Call(new MultiToken.GetBalanceInput
                {
                    Owner = Context.Sender,
                    Symbol = symbol
                }).Balance;
                Assert(balance >= amount, $"Insufficient balance of {symbol}");
                var allowance = State.TokenContract.GetAllowance.Call(new MultiToken.GetAllowanceInput
                {
                    Owner = Context.Sender,
                    Spender = Context.Self,
                    Symbol = symbol
                }).Allowance;
                Assert(allowance >= amount, $"Insufficient allowance of {symbol}");
                State.TokenContract.TransferFrom.Send(new MultiToken.TransferFromInput
                {
                    From = Context.Sender,
                    To = Context.Self,
                    Symbol = symbol,
                    Amount = amount
                });
            }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L178-178)
```csharp
        if (input.AssembledFts.Value.Any()) State.AssembledFtsMap[nftMinted.TokenHash] = input.AssembledFts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-236)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });

        var receiver = input.Owner ?? Context.Sender;

        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
        }

        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
        if (assembledFts != null)
        {
            var fts = assembledFts;
            foreach (var pair in fts.Value)
                State.TokenContract.Transfer.Send(new MultiToken.TransferInput
                {
                    Symbol = pair.Key,
                    Amount = pair.Value,
                    To = receiver
                });

            State.AssembledFtsMap.Remove(tokenHash);
        }

        Context.Fire(new Disassembled
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            DisassembledNfts = assembledNfts ?? new AssembledNfts(),
            DisassembledFts = assembledFts ?? new AssembledFts()
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L33-33)
```csharp
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }
```

**File:** protobuf/nft_contract.proto (L18-101)
```text
service NFTContract {
    option (aelf.csharp_state) = "AElf.Contracts.NFT.NFTContractState";
    option (aelf.base) = "acs1.proto";

    // Create a new nft protocol.
    rpc Create (CreateInput) returns (google.protobuf.StringValue) {
    }
    rpc CrossChainCreate (CrossChainCreateInput) returns (google.protobuf.Empty) {
    }
    // Mint (Issue) an amount of nft.
    rpc Mint (MintInput) returns (aelf.Hash) {
    }
    // Transfer nft to another address.
    rpc Transfer (TransferInput) returns (google.protobuf.Empty) {
    }
    // Transfer nft from one address to another.
    rpc TransferFrom (TransferFromInput) returns (google.protobuf.Empty) {
    }
    // Approve another address to transfer nft from own account.
    rpc Approve (ApproveInput) returns (google.protobuf.Empty) {
    }
    // De-approve.
    rpc UnApprove (UnApproveInput) returns (google.protobuf.Empty) {
    }
    // Approve or de-approve another address as the operator of all NFTs of a certain protocol.
    rpc ApproveProtocol (ApproveProtocolInput) returns (google.protobuf.Empty) {
    }
    // Destroy nfts.
    rpc Burn (BurnInput) returns (google.protobuf.Empty) {
    }
    // Lock several nfts and fts to mint one nft.
    rpc Assemble (AssembleInput) returns (aelf.Hash) {
    }
    // Disassemble one assembled nft to get locked nfts and fts back.
    rpc Disassemble (DisassembleInput) returns (google.protobuf.Empty) {
    }
    // Modify metadata of one nft.
    rpc Recast (RecastInput) returns (google.protobuf.Empty) {
    }

    rpc AddMinters (AddMintersInput) returns (google.protobuf.Empty) {
    }
    rpc RemoveMinters (RemoveMintersInput) returns (google.protobuf.Empty) {
    }
    
    rpc AddNFTType (AddNFTTypeInput) returns (google.protobuf.Empty) {
    }
    rpc RemoveNFTType (google.protobuf.StringValue) returns (google.protobuf.Empty) {
    }

    rpc GetNFTProtocolInfo (google.protobuf.StringValue) returns (NFTProtocolInfo) {
        option (aelf.is_view) = true;
    }
    rpc GetNFTInfo (GetNFTInfoInput) returns (NFTInfo) {
        option (aelf.is_view) = true;
    }
    rpc GetNFTInfoByTokenHash (aelf.Hash) returns (NFTInfo) {
        option (aelf.is_view) = true;
    }
    rpc GetBalance (GetBalanceInput) returns (GetBalanceOutput) {
        option (aelf.is_view) = true;
    }
    rpc GetBalanceByTokenHash (GetBalanceByTokenHashInput) returns (GetBalanceOutput) {
        option (aelf.is_view) = true;
    }
    rpc GetAllowance (GetAllowanceInput) returns (GetAllowanceOutput) {
        option (aelf.is_view) = true;
    }
    rpc GetAllowanceByTokenHash (GetAllowanceByTokenHashInput) returns (GetAllowanceOutput) {
        option (aelf.is_view) = true;
    }
    rpc GetMinterList (google.protobuf.StringValue) returns (MinterList) {
        option (aelf.is_view) = true;
    }
    rpc CalculateTokenHash (CalculateTokenHashInput) returns (aelf.Hash) {
        option (aelf.is_view) = true;
    }
    rpc GetNFTTypes (google.protobuf.Empty) returns (NFTTypes) {
        option (aelf.is_view) = true;
    }
    rpc GetOperatorList (GetOperatorListInput) returns (AddressList) {
        option (aelf.is_view) = true;
    }
}
```

**File:** test/AElf.Contracts.NFT.Tests/NFTContractTests.cs (L230-261)
```csharp
    [Fact]
    public async Task AssembleTest()
    {
        var (symbol, tokenHash) = await MintTest();

        await TokenContractStub.Approve.SendAsync(new MultiToken.ApproveInput
        {
            Spender = NFTContractAddress,
            Symbol = "ELF",
            Amount = long.MaxValue
        });

        await NFTContractStub.Assemble.SendAsync(new AssembleInput
        {
            Symbol = symbol,
            AssembledNfts = new AssembledNfts
            {
                Value = { [tokenHash.ToHex()] = 1 }
            },
            AssembledFts = new AssembledFts
            {
                Value = { ["ELF"] = 100 }
            },
            Metadata = new Metadata
            {
                Value =
                {
                    ["Advanced Property"] = "whatever"
                }
            }
        });
    }
```
