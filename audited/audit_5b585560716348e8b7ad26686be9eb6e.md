# Audit Report

## Title
NextTerm Validation Bypasses Election Results Allowing Unauthorized Miner List Manipulation

## Summary
The `ValidationForNextTerm` function in the AEDPoS consensus contract only validates that term and round numbers increment correctly but fails to verify that the provided miner list matches the election winners from `ElectionContract.GetVictories`. This allows a malicious block producer to include an arbitrary miner list during term transitions, completely bypassing the democratic election mechanism.

## Finding Description

The vulnerability exists in the consensus validation logic for term transitions. The honest path for generating NextTerm data calls `GenerateFirstRoundOfNextTerm` which fetches election winners via `TryToGetVictories` from the Election Contract. [1](#0-0) 

However, the validation performed by `ValidationForNextTerm` only checks that the term number increments by 1, without verifying the miner list validity: [2](#0-1) 

During execution, `ProcessNextTerm` blindly extracts the miner list from the provided input and sets it as the official miner list for the new term without any validation against election results: [3](#0-2) 

The `SetMinerList` method only checks if a miner list has already been set for that term, but does not verify whether the provided miners are legitimate election winners: [4](#0-3) 

The post-execution validation in `ValidateConsensusAfterExecution` compares round hashes, but retrieves the `currentRound` from state AFTER the malicious round has already been written, creating a Time-of-Check-Time-of-Use (TOCTOU) vulnerability: [5](#0-4) 

A malicious miner producing a NextTerm block can modify the `Round.RealTimeMinersInformation` to include arbitrary miners. Since validation only checks term/round number increments and the `MiningPermissionValidationProvider` validates against the CURRENT term (not the next term), the attack bypasses all guards: [6](#0-5) 

## Impact Explanation

This vulnerability breaks the fundamental security assumption of the AEDPoS consensus mechanism: that miners must be elected by token holders through a democratic voting process. The impact is **critical** because:

1. **Election Bypass**: Miners who lose elections can remain in power indefinitely by manipulating the miner list during term transitions
2. **Consensus Integrity Violation**: The blockchain's security model depends on elected, trusted miners - breaking this assumption compromises all consensus guarantees
3. **Centralization Risk**: A small group of colluding miners can maintain permanent control without being subject to token holder governance
4. **Governance Capture**: The entire democratic election and voting mechanism becomes meaningless as results can be ignored
5. **Chain-wide Impact**: All network participants are affected as the consensus layer's integrity is the foundation of the system's security

## Likelihood Explanation

The likelihood is **high** because:

1. **Low Privilege Requirements**: Any current miner can execute this attack when they produce a NextTerm block
2. **Regular Opportunities**: Term transitions happen periodically, providing multiple attack windows
3. **Low Complexity**: The attack only requires modifying data structures in the consensus data before block production
4. **No Detection Mechanism**: There is no validation to detect when a miner list doesn't match election results
5. **High Motivation**: Miners facing election loss have strong economic incentives (mining rewards, power) to retain their position

The attack is feasible if a miner runs modified node software that allows manipulation of consensus data structures between generation and block inclusion. While honest node implementations may not allow this, the smart contract is the ultimate arbiter and should enforce this security constraint regardless of node behavior.

## Recommendation

Add explicit validation that the provided miner list matches the election winners during NextTerm transitions. The fix should be implemented in the validation logic:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Check term number
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // NEW: Validate miner list matches election results
    if (State.IsMainChain.Value)
    {
        var expectedWinners = State.ElectionContract.GetVictories.Call(new Empty());
        var providedMiners = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        var electionWinners = expectedWinners.Value.Select(p => p.ToHex()).OrderBy(k => k).ToList();
        
        if (!providedMiners.SequenceEqual(electionWinners))
            return new ValidationResult { Message = "Miner list does not match election results." };
    }
    
    return new ValidationResult { Success = true };
}
```

This ensures that before any NextTerm execution, the contract verifies that the provided miner list exactly matches the election winners, preventing unauthorized miner list manipulation.

## Proof of Concept

A complete proof-of-concept would require setting up an AElf test environment with:
1. Multiple miners in term N
2. An election where miner M loses
3. Miner M producing the NextTerm block with a modified miner list including themselves
4. Verification that the malicious miner list is accepted and set as the official miner list for term N+1

The test would demonstrate that `ValidationForNextTerm` passes despite the miner list not matching `GetVictories()` results, and that `ProcessNextTerm` successfully sets the fraudulent miner list without rejection.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-256)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-195)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
