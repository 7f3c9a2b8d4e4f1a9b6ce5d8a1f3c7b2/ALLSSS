# Audit Report

## Title
Association Contract Member List Manipulation Allows Retroactive Vote Invalidation

## Summary
The Association contract's vote counting mechanism uses the current organization member list at release time rather than preserving a snapshot from voting time, allowing votes cast by members to be retroactively invalidated by removing those members before proposal release. This fundamentally breaks the governance invariant that votes should be immutable once cast.

## Finding Description

The Association contract stores votes as address lists but counts them by filtering against the **current** member list at release time, not the member list at voting time.

**Vote Storage During Voting:**
When members vote, their addresses are added to the proposal's vote lists and membership is verified at that time. [1](#0-0) 

**Vote Counting at Release:**
When determining if a proposal can be released, the contract filters votes against the **current** member list dynamically. The rejection counting filters rejections: [2](#0-1) 

The abstention counting filters abstentions: [3](#0-2) 

The approval counting filters approvals: [4](#0-3) 

**Member List Modification:**
The organization can modify its member list through methods that only the organization address itself can call: [5](#0-4) 

**Root Cause:**
The proposal structure only stores the organization address reference, not a snapshot of the member list: [6](#0-5) 

The vote counting at release time queries the current organization state: [7](#0-6) 

## Impact Explanation

This vulnerability breaks the fundamental governance invariant that votes are immutable once cast. 

**Attack Scenario 1 - Denying Legitimate Proposals:**
- Organization with members [A, B, C, D] requires 3 approvals
- Proposal X receives approvals from A, B, C (threshold met)
- Before release, organization removes members A and B via governance
- Proposal X now counts only C's approval (1 vote), failing threshold
- Legitimate proposal blocked despite proper approval

**Attack Scenario 2 - Enabling Rejected Proposals:**
- Organization with max rejection threshold of 1
- Proposal Y receives rejection from member A
- Organization removes member A
- Proposal Y now has 0 counted rejections, can pass

This affects any association-based governance including contract upgrades, treasury management, and system parameter changes. The impact is **Critical** because it enables manipulation of governance outcomes and undermines trust in the entire governance system.

## Likelihood Explanation

**Attacker Requirements:**
- Must control an association organization (either as creator with member support, or by gaining control through legitimate governance)
- Must have enough compliant members to pass member modification proposals

**Attack Complexity:** Low to Medium
1. Create/control an association organization
2. Create a target proposal
3. Wait for voting to occur
4. Pass a proposal to modify the member list
5. Release the original proposal with manipulated vote counts

**Feasibility:** High for organizations with centralized control or insufficient member vigilance. The time window between voting completion and proposal release provides opportunity for manipulation. Member list changes emit events but events alone do not prevent the attack. [8](#0-7) 

## Recommendation

Implement a snapshot mechanism that preserves the organization member list at proposal creation time. The proposal should store either:

1. **Member List Snapshot:** Store a complete copy of the member list in the ProposalInfo at creation time
2. **Block Height Reference:** Store the block height at proposal creation and implement historical member list queries
3. **Merkle Root:** Store a merkle root of the member list at proposal creation for verification

Recommended implementation:
- Add `organization_member_list_snapshot` field to ProposalInfo
- Populate this field during proposal creation from the current member list
- Use the snapshot (not current member list) for all vote counting operations

Additionally, consider adding governance safeguards:
- Time locks between member list changes and proposal releases
- Minimum delay periods for member removals
- Warnings when member lists are modified while active proposals exist

## Proof of Concept

```csharp
[Fact]
public async Task VoteInvalidation_ByMemberRemoval_Test()
{
    // Setup: Create organization with 3 members, requiring 2 approvals
    var minimalApprovalThreshold = 2;
    var minimalVoteThreshold = 2;
    var organizationAddress = await CreateOrganizationAsync(
        minimalApprovalThreshold, 
        minimalVoteThreshold,
        0, // maxAbstention
        0, // maxRejection
        Reviewer1
    );
    
    // Step 1: Create proposal
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // Step 2: Two members approve (meets threshold)
    await ApproveAsync(Reviewer1KeyPair, proposalId);
    await ApproveAsync(Reviewer2KeyPair, proposalId);
    
    // Verify proposal is ready to release
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBeTrue(); // Should pass with 2 approvals
    
    // Step 3: Organization removes one of the approvers
    var organizationStub = GetAssociationContractTester(organizationAddress);
    await organizationStub.RemoveMember.SendAsync(Reviewer1);
    
    // Step 4: Check proposal status again
    var proposalAfterRemoval = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposalAfterRemoval.ApprovalCount.ShouldBe(1); // Only Reviewer2's vote counts now
    proposalAfterRemoval.ToBeReleased.ShouldBeFalse(); // No longer meets threshold!
    
    // Demonstrate: Release will fail despite originally meeting approval threshold
    var releaseResult = await GetAssociationContractTester(Reviewer1KeyPair)
        .Release.SendWithExceptionAsync(proposalId);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
}
```

This test demonstrates that removing a member after they voted causes their vote to no longer count, breaking the proposal release despite it originally meeting the required threshold.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-280)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }

    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
    }

    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** protobuf/association_contract.proto (L76-103)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```

**File:** protobuf/association_contract.proto (L124-148)
```text
message MemberAdded{
    option (aelf.is_event) = true;
    // The added member address.
    aelf.Address member = 1;
    // The organization address.
    aelf.Address organization_address = 2 [(aelf.is_indexed) = true];    
}

message MemberRemoved{
    option (aelf.is_event) = true;
    // The removed member address.
    aelf.Address member = 1;
    // The organization address.
    aelf.Address organization_address = 2 [(aelf.is_indexed) = true];
}

message MemberChanged{
    option (aelf.is_event) = true;
    // The old member address.
    aelf.Address old_member = 1;
    // The new member address.
    aelf.Address new_member = 2;
    // The organization address.
    aelf.Address organization_address = 3 [(aelf.is_indexed) = true];
}
```
