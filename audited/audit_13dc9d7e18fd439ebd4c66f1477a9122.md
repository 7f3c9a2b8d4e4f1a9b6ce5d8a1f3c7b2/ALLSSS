### Title
Vote Count Corruption Due to Incorrect State Carryover in TakeSnapshot()

### Summary
The `TakeSnapshot()` function incorrectly carries over `VotersCount` and `VotesAmount` from the previous snapshot when creating a new snapshot, while correctly resetting the `Results` map to empty. This creates inconsistent state where aggregate vote counts are cumulative across snapshots, while individual option votes start fresh, leading to permanently corrupted voting tallies that misrepresent actual voting activity.

### Finding Description

In the `TakeSnapshot()` function, when creating a new `VotingResult` for the next snapshot, the code copies `VotersCount` and `VotesAmount` from the previous snapshot but leaves the `Results` map uninitialized (empty): [1](#0-0) 

This contrasts with how the first snapshot is initialized during `Register()`, where all counts start at zero/empty: [2](#0-1) 

The `VotingResult` structure contains three vote-related fields:
- `results` - map of option -> vote amounts (starts empty in new snapshot)
- `voters_count` - total voter count (incorrectly carried over)
- `votes_amount` - total vote amount (incorrectly carried over) [3](#0-2) 

When new votes are cast in the new snapshot, the `UpdateVotingResult()` function increments these already-inflated counts: [4](#0-3) 

This creates a fundamental inconsistency: the `Results` map correctly shows only votes from the current snapshot, but `VotersCount` and `VotesAmount` incorrectly accumulate across all previous snapshots plus the current one.

### Impact Explanation

**Concrete Harm:**
1. **Data Corruption**: Voting results become permanently corrupted with inflated counts that don't reflect actual voting activity in each snapshot
2. **Governance Manipulation**: Any governance decisions relying on `VotersCount` or `VotesAmount` thresholds will be based on false data
3. **Trust Violation**: The voting system's integrity is compromised as reported numbers don't match reality

**Quantified Example:**
- Snapshot 1: 3 voters cast 450 total votes → `VotersCount=3, VotesAmount=450`
- TakeSnapshot() called → Snapshot 2 starts with `VotersCount=3, VotesAmount=450` (incorrect carryover)
- Snapshot 2: 4 new votes cast for 400 votes → Final counts show `VotersCount=7, VotesAmount=850`
- **Reality**: Only 4 votes for 400 tokens occurred in snapshot 2
- **Reported**: 7 votes for 850 tokens

This exact behavior is validated by the test suite: [5](#0-4) 

**Affected Parties:**
- Voting sponsors making decisions based on vote counts
- Voters whose participation is misrepresented
- External systems querying voting results
- Any governance logic using these metrics

**Severity**: HIGH - This is a critical logic error affecting core voting functionality with no workaround.

### Likelihood Explanation

**Certainty**: This vulnerability triggers deterministically every time `TakeSnapshot()` is called on a voting item with multiple snapshots.

**Entry Point**: The `TakeSnapshot()` function is a public RPC method callable by the voting item sponsor: [6](#0-5) 

**Preconditions**: 
- A voting item registered with `TotalSnapshotNumber > 1`
- At least one vote cast in the first snapshot
- Sponsor calls `TakeSnapshot()` to advance to the next snapshot

**Execution**: No special permissions or complex setup required beyond normal voting flow. The sponsor legitimately calls `TakeSnapshot()` as part of the intended multi-snapshot voting process.

**Detection**: The corrupted state is permanent and visible via the `GetVotingResult` query method, making detection straightforward.

**Probability**: 100% - This occurs in every multi-snapshot voting scenario, which is a core feature of the Vote contract.

### Recommendation

**Code-level Fix:**
Initialize `VotersCount` and `VotesAmount` to zero when creating a new snapshot, matching the behavior of the initial snapshot creation:

```csharp
State.VotingResults[currentVotingGoingHash] = new VotingResult
{
    VotingItemId = input.VotingItemId,
    SnapshotNumber = nextSnapshotNumber,
    SnapshotStartTimestamp = Context.CurrentBlockTime,
    VotersCount = 0,  // Changed from previousVotingResult.VotersCount
    VotesAmount = 0   // Changed from previousVotingResult.VotesAmount
};
```

**Invariant Check:**
Add validation that each snapshot's vote counts represent only that snapshot's activity, not cumulative totals.

**Test Cases:**
1. Create a test that votes in snapshot 1, takes snapshot, then verifies snapshot 2 starts with zero counts
2. Add assertion: `votingResult.VotesAmount.ShouldBe(actualVotesInSnapshot)` not cumulative
3. Update existing test at line 94 of VoteForBestLanguageTests.cs to expect correct count of 4, not 7 [7](#0-6) 

### Proof of Concept

**Initial State:**
1. Register voting item with `TotalSnapshotNumber = 2`
2. Three users vote in snapshot 1:
   - User A: 100 votes for Option X
   - User B: 150 votes for Option X  
   - User C: 200 votes for Option Y
3. Query snapshot 1 result: `VotersCount = 3, VotesAmount = 450, Results = {X:250, Y:200}`

**Exploit Steps:**
1. Sponsor calls `TakeSnapshot(votingItemId, snapshotNumber: 1)`
2. Query snapshot 2 result immediately: `VotersCount = 3, VotesAmount = 450, Results = {}` (INCORRECT - should be 0,0,{})
3. User D votes 100 for Option Z in snapshot 2
4. Query snapshot 2 result: `VotersCount = 4, VotesAmount = 550, Results = {Z:100}`

**Expected Result:**
Snapshot 2 should show: `VotersCount = 1, VotesAmount = 100, Results = {Z:100}`

**Actual Result:**  
Snapshot 2 shows: `VotersCount = 4, VotesAmount = 550, Results = {Z:100}`

**Success Condition:**
The discrepancy between `Results` totals (100 votes) and `VotesAmount` (550 votes) proves the corruption. The 450-vote difference is the incorrectly carried-over amount from snapshot 1.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L57-63)
```csharp
        var votingResultHash = GetVotingResultHash(votingItemId, 1);
        State.VotingResults[votingResultHash] = new VotingResult
        {
            VotingItemId = votingItemId,
            SnapshotNumber = 1,
            SnapshotStartTimestamp = input.StartTimestamp
        };
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L241-245)
```csharp
    public override Empty TakeSnapshot(TakeSnapshotInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);

        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L264-271)
```csharp
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
```

**File:** protobuf/vote_contract.proto (L162-177)
```text
message VotingResult {
    // The voting activity id.
    aelf.Hash voting_item_id = 1;
    // The voting result, option -> amount of votes,
    map<string, int64> results = 2;
    // The snapshot number.
    int64 snapshot_number = 3;
    // The total number of voters.
    int64 voters_count = 4;
    // The start time of this snapshot.
    google.protobuf.Timestamp snapshot_start_timestamp = 5;
    // The end time of this snapshot.
    google.protobuf.Timestamp snapshot_end_timestamp = 6;
    // Total votes received during the process of this snapshot.
    int64 votes_amount = 7;
}
```

**File:** test/AElf.Contracts.Vote.Tests/Full/VoteForBestLanguageTests.cs (L93-98)
```csharp
            var votingResult = await GetVotingResult(registerItem.VotingItemId, 2);
            votingResult.VotersCount.ShouldBe(7);
            votingResult.Results.Count.ShouldBe(3);
            votingResult.Results[options[0]].ShouldBe(100);
            votingResult.Results[options[1]].ShouldBe(100);
            votingResult.Results[options[2]].ShouldBe(200);
```
