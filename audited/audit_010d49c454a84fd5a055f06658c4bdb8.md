### Title
Signature Manipulation in First Round of Term Allows Mining Order Prediction

### Summary
During the first round of a new consensus term, miners can arbitrarily choose their InValue to manipulate the signature calculation at line 69, allowing them to predict and control their mining order in the subsequent round. This breaks the intended randomness of the AEDPoS consensus mechanism and enables strategic positioning for potential MEV extraction or transaction ordering advantages.

### Finding Description

The vulnerability exists in the `GetConsensusExtraDataToPublishOutValue` function where the initial signature is calculated: [1](#0-0) 

The signature recalculation logic is conditionally bypassed for the first round of a term: [2](#0-1) 

The condition `IsFirstRoundOfCurrentTerm` returns true when the term has just changed: [3](#0-2) 

This signature directly determines the mining order in the next round: [4](#0-3) 

The order assignment uses this signature-derived value: [5](#0-4) 

The next round generation uses FinalOrderOfNextRound to determine actual mining sequence: [6](#0-5) 

Critically, the validation logic does not verify that InValue or signature was correctly computed: [7](#0-6) 

The validation only checks that OutValue/Signature are non-empty and PreviousInValue is valid: [8](#0-7) 

In the first round of a term, SecretSharingInformation events are not fired due to miner list changes: [9](#0-8) 

This means proper InValue generation through secret sharing does not occur: [10](#0-9) 

When InValue is not in cache, it returns Hash.Empty, allowing arbitrary manipulation: [11](#0-10) 

### Impact Explanation

**Consensus Integrity Impact**: An attacker can break the randomness guarantee of the AEDPoS consensus ordering mechanism. By manipulating their signature through InValue selection, they can deterministically position themselves in the mining order for round 2 of each new term.

**Strategic Advantage**: The attacker gains first-miner advantage in round 2, enabling:
- Priority transaction selection and ordering (MEV extraction)
- Front-running opportunities
- Preferential block production timing
- Unfair competitive advantage over honest miners

**Protocol Fairness**: The vulnerability undermines the fundamental fairness assumption that mining order is unpredictable and randomly determined, violating a core security property of the consensus mechanism.

**Scope**: While limited to the first round of each term, this occurs at every term transition (typically during validator set changes), making it a recurring exploitable condition.

### Likelihood Explanation

**Attacker Capabilities**: The attacker must be an active miner in the first round of a term. Since term transitions occur during validator elections, any elected validator can exploit this.

**Technical Feasibility**: 
- Computational cost is trivial: brute-forcing InValue to find desired signature takes milliseconds on consumer hardware
- No cryptographic barriers: the signature formula is deterministic and publicly known
- Node modification is straightforward: bypass InValueCache.GetInValue() and inject custom InValue

**Execution Practicality**:
1. Attacker runs modified node software (open-source, easily modified)
2. During first round of term, pre-compute: for each candidate InValue, calculate signature = ConcatAndCompute(ComputeFrom(InValue), InValue)
3. Find InValue where GetAbsModulus(signature.ToInt64(), minersCount) + 1 == 1 (or preferred order)
4. Submit block with chosen InValue
5. Validation passes (no InValue verification exists)
6. Attacker receives order 1 in round 2

**Detection Difficulty**: No on-chain mechanism exists to detect that InValue was manipulated versus legitimately generated, as there's no validation of its correctness.

**Economic Rationality**: The benefit (first-miner advantage) exceeds the cost (trivial computation) by orders of magnitude, especially for high-value transaction ordering.

### Recommendation

**Immediate Fix**: Add signature verification in UpdateValueValidationProvider:

For first round of term, validate that:
```
signature == HashHelper.ConcatAndCompute(
    HashHelper.ComputeFrom(inValue), 
    inValue
)
```

For subsequent rounds, validate that:
```
signature == previousRound.CalculateSignature(previousInValue)
```

**InValue Commitment**: Implement a commitment-reveal scheme for first round of term:
1. Miners commit to hash of InValue in block N
2. Reveal actual InValue in block N+1
3. Validate revealed InValue matches commitment
4. Use revealed InValue for signature calculation

**Alternative Approach**: Use verifiable random function (VRF) for InValue generation in first round of term, where InValue must be a valid VRF proof that can be verified on-chain.

**Test Cases**:
- Test that manipulated InValue in first round of term is rejected
- Test that signature verification passes for honest InValue
- Test that order manipulation attempt fails validation
- Fuzz test with various malicious InValue inputs

### Proof of Concept

**Initial State**:
- Term 1 has just ended, Term 2 is beginning
- Attacker is elected validator for Term 2
- First round of Term 2 (Round N) is starting
- Attacker has first time slot in Round N

**Attack Sequence**:

1. **Pre-computation Phase** (off-chain):
   - Attacker iterates InValue candidates: InValue₁, InValue₂, ..., InValueₖ
   - For each: compute OutValue = ComputeFrom(InValue)
   - Compute: Signature = ConcatAndCompute(OutValue, InValue)
   - Compute: Order = GetAbsModulus(Signature.ToInt64(), 21) + 1
   - Find InValue* where Order == 1

2. **Block Production** (on-chain):
   - Attacker's node bypasses InValueCache.GetInValue()
   - Injects chosen InValue* into AElfConsensusTriggerInformation
   - Produces block with manipulated consensus data
   - Contract executes GetConsensusExtraDataToPublishOutValue()
   - Line 67: OutValue = ComputeFrom(InValue*)
   - Line 69: Signature = ConcatAndCompute(OutValue, InValue*)
   - Line 72: Condition fails (IsFirstRoundOfCurrentTerm == true)
   - Lines 73-109: SKIPPED (no recalculation)
   - Line 111: ApplyNormalConsensusData() called with manipulated signature

3. **Order Manipulation**:
   - ApplyNormalConsensusData() computes: supposedOrderOfNextRound = GetAbsModulus(signature.ToInt64(), 21) + 1 = 1
   - FinalOrderOfNextRound = 1
   - Round N+1 generation assigns attacker Order 1
   - Attacker mines first block in Round N+1

**Expected Result**: Signature recalculated based on previous round signatures, unpredictable order

**Actual Result**: Attacker successfully manipulates signature, guarantees Order 1 in next round

**Success Validation**: 
- Attacker's FinalOrderOfNextRound == 1 in Round N consensus data
- Attacker's Order == 1 in Round N+1 
- Attacker's ExpectedMiningTime is earliest in Round N+1

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L67-69)
```csharp
        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L72-109)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound) && !IsFirstRoundOfCurrentTerm(out _))
        {
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
            else
            {
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L27-34)
```csharp
    private bool IsFirstRoundOfCurrentTerm(out long termNumber)
    {
        termNumber = 1;
        return (TryToGetTermNumber(out termNumber) &&
                TryToGetPreviousRoundInformation(out var previousRound) &&
                previousRound.TermNumber != termNumber) ||
               (TryToGetRoundNumber(out var roundNumber) && roundNumber == 1);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L107-115)
```csharp
        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-49)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L186-191)
```csharp
    private async Task<Hash> GenerateInValueAsync(IMessage message)
    {
        var data = HashHelper.ComputeFrom(message.ToByteArray());
        var bytes = await _accountService.SignAsync(data.ToByteArray());
        return HashHelper.ComputeFrom(bytes);
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IInValueCache.cs (L23-33)
```csharp
    public Hash GetInValue(long roundId)
    {
        // Remove old in values. (Keep 10 in values.)
        const int keepInValuesCount = 10;
        if (_inValues.Keys.Count > keepInValuesCount)
            foreach (var id in _inValues.Keys.OrderByDescending(id => id).Skip(keepInValuesCount))
                _inValues.Remove(id);

        _inValues.TryGetValue(roundId, out var inValue);
        return inValue ?? Hash.Empty;
    }
```
