### Title
Unbounded Rental Debt Accumulation Can Exceed Total Token Supply Making Debt Mathematically Unpayable

### Summary
The `State.OwningRental[symbol]` mapping accumulates rental debt indefinitely without any ceiling validation when side chain creators cannot pay their resource rental fees. Over time, this debt can exceed the total supply of resource tokens (500,000,000 tokens), creating a mathematically impossible debt that can never be repaid even if the creator obtained all tokens in existence.

### Finding Description
The `PayRental()` method in [1](#0-0)  accumulates rental debt when a side chain creator has insufficient balance to pay for resource tokens (CPU, RAM, DISK, NET). 

The core vulnerability occurs at [2](#0-1)  where debt is accumulated without any ceiling check:

The rental amount is calculated at [3](#0-2)  as `duration × ResourceAmount[symbol] × Rental[symbol]`, where duration is in minutes since last payment. When the creator's balance is insufficient at [4](#0-3) , the shortfall is added to `OwningRental` without validating against total supply.

Resource tokens have a fixed total supply of 500,000,000 tokens as defined in [5](#0-4) . However, no code validates that `OwningRental[symbol]` stays below this ceiling.

The `OwningRental` state variable is defined at [6](#0-5)  as a simple `MappedState<string, long>` with no constraints.

### Impact Explanation
**Direct Financial Impact**: When `OwningRental[symbol]` exceeds the total supply of 500,000,000 tokens, the debt becomes mathematically unpayable. Even if the side chain creator obtained 100% of all tokens in circulation, they could not clear the debt.

**Quantified Example**: Using test parameters from [7](#0-6) :
- CPU: 4 units at 100 tokens/minute = 400 tokens/minute
- Daily accumulation: 400 × 60 × 24 = 576,000 tokens
- Annual accumulation: 210,240,000 tokens
- **Time to exceed total supply: ~2.4 years without payment**

**Who is Affected**: Side chain creators become permanently indebted with no recovery mechanism. The consensus contract expects payment but can never receive it, potentially affecting cross-chain operations and resource accounting integrity.

**Severity Justification**: This violates the critical invariant that token supply constraints must be enforced. Once debt exceeds total supply, the side chain's rental obligations become a logical impossibility within the token economics system.

### Likelihood Explanation
**Attacker Capabilities**: No attacker required - this is a natural scenario when a side chain creator's balance depletes (e.g., abandoned project, economic downturn, token price crash).

**Attack Complexity**: Trivial - simply requires:
1. Side chain initialized via [8](#0-7) 
2. Creator balance depletes to zero
3. Time passes (months/years) while `PayRental()` executes during block production via [9](#0-8) 

**Feasibility**: Highly feasible. Test case [10](#0-9)  demonstrates debt accumulation when balance is zero. The test shows debt growing every minute without any ceiling validation.

**Detection**: Observable via [11](#0-10)  and the `RentalAccountBalanceInsufficient` event fired at [12](#0-11) , but no automatic protection exists.

**Probability**: Medium-to-High over long time periods. Any long-running side chain experiencing financial difficulties will hit this issue.

### Recommendation
**Immediate Fix**: Add debt ceiling validation in `PayRental()`:

```csharp
// After line 1074, before line 1075:
var tokenInfo = State.TokenInfos[symbol];
Assert(tokenInfo != null, $"Token {symbol} not found");
var maxDebt = tokenInfo.TotalSupply.Mul(95).Div(100); // 95% of total supply as ceiling
var newOwingRental = State.OwningRental[symbol].Add(own);
Assert(newOwingRental <= maxDebt, 
    $"Rental debt would exceed maximum allowed ({maxDebt}). Current: {State.OwningRental[symbol]}, Adding: {own}");
State.OwningRental[symbol] = newOwingRental;
```

**Invariant Check**: Add validation in `UpdateRental()` at [13](#0-12)  to ensure rental rates cannot create debt accumulation faster than economically reasonable.

**Governance Control**: Add administrative function to forgive or cap debt when it approaches total supply:
```csharp
public override Empty ForgiveRentalDebt(ForgiveRentalDebtInput input) {
    AssertControllerForSideChainRental();
    Assert(input.Amount > 0, "Amount must be positive");
    var currentDebt = State.OwningRental[input.Symbol];
    var amountToForgive = Math.Min(input.Amount, currentDebt);
    State.OwningRental[input.Symbol] = currentDebt.Sub(amountToForgive);
    return new Empty();
}
```

**Test Cases**: Add regression tests verifying:
1. Debt cannot exceed 95% of total supply
2. Rental rate changes are validated against debt accumulation speed
3. Debt forgiveness mechanism functions correctly

### Proof of Concept
**Initial State**:
1. Side chain initialized with resource allocation (CPU: 4 units, Rental: 100 tokens/minute) as shown in [14](#0-13) 
2. Total supply = 500,000,000 tokens (8 decimals: 500_000_000_00000000)
3. Creator balance = 0

**Execution Steps**:
1. Block production continues, calling `DonateResourceToken()` which invokes `PayRental()` at [15](#0-14) 
2. Each call with insufficient balance adds debt at [16](#0-15) 
3. Debt accumulates: 400 tokens/minute × 60 × 24 × 365 = 210,240,000 tokens/year
4. After ~2.4 years: `OwningRental["CPU"]` = ~504,576,000 tokens

**Expected vs Actual Result**:
- **Expected**: Transaction should revert when debt would exceed total supply with error "Rental debt would exceed total supply"
- **Actual**: Debt accumulates to 504,576,000+ tokens, exceeding the 500,000,000 total supply. Query via [11](#0-10)  returns unpayable debt amount.

**Success Condition**: `GetOwningRental()` returns debt > total supply (500,000,000_00000000), proving mathematical impossibility of repayment.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L949-950)
```csharp
            PayRental();
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1019-1097)
```csharp
    private void PayRental()
    {
        var creator = State.SideChainCreator.Value;
        if (creator == null) return;
        if (State.LastPayRentTime.Value == null)
        {
            // Initial LastPayRentTime first calling DonateResourceToken.
            State.LastPayRentTime.Value = Context.CurrentBlockTime;
            return;
        }

        // We need minutes.
        var duration = (Context.CurrentBlockTime - State.LastPayRentTime.Value).Seconds.Div(60);
        if (duration == 0)
        {
            return;
        }

        // Update LastPayRentTime if it is ready to charge rental.
        State.LastPayRentTime.Value += new Duration { Seconds = duration.Mul(60) };

        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName))
        {
            var donates = 0L;

            var availableBalance = GetBalance(creator, symbol);

            // Try to update owning rental.
            var owningRental = State.OwningRental[symbol];
            if (owningRental > 0)
            {
                // If Creator own this symbol and current balance can cover the debt, pay the debt at first.
                if (availableBalance > owningRental)
                {
                    donates = owningRental;
                    // Need to update available balance,
                    // cause existing balance not necessary equals to available balance.
                    availableBalance = availableBalance.Sub(owningRental);
                    State.OwningRental[symbol] = 0;
                }
            }

            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
            if (availableBalance >= rental) // Success
            {
                donates = donates.Add(rental);
                ModifyBalance(creator, symbol, -donates);
            }
            else // Fail
            {
                // Donate all existing balance. Directly reset the donates.
                donates = GetBalance(creator, symbol);
                State.Balances[creator][symbol] = 0;

                // Update owning rental to record a new debt.
                var own = rental.Sub(availableBalance);
                State.OwningRental[symbol] = State.OwningRental[symbol].Add(own);

                Context.Fire(new RentalAccountBalanceInsufficient
                {
                    Symbol = symbol,
                    Amount = own
                });
            }

            // Side Chain donates.
            var consensusContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
            ModifyBalance(consensusContractAddress, symbol, donates);

            Context.Fire(new RentalCharged()
            {
                Symbol = symbol,
                Amount = donates,
                Payer = creator,
                Receiver = consensusContractAddress
            });
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1099-1112)
```csharp
    public override Empty UpdateRental(UpdateRentalInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.Rental)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.Rental[pair.Key] = pair.Value;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L11-11)
```csharp
    public const long ResourceTokenTotalSupply = 500_000_000_00000000;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState_ChargeFee.cs (L36-36)
```csharp
    public MappedState<string, long> OwningRental { get; set; }
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainSideChainRentFeeTest.cs (L19-26)
```csharp
    private const int CpuAmount = 4;
    private const int RamAmount = 8;
    private const int DiskAmount = 512;
    private const int NetAmount = 1000;

    private const long ResourceSupply = 1_0000_0000_00000000;

    private const long Rental = 100;
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainSideChainRentFeeTest.cs (L96-119)
```csharp
    public async Task OwnResourceTest()
    {
        await InitialTokenContractAsync(false);

        // Check balance before mining
        {
            var cpuBalance = await GetCreatorBalanceOfAsync("CPU");
            cpuBalance.ShouldBe(0);
            var ramBalance = await GetCreatorBalanceOfAsync("RAM");
            ramBalance.ShouldBe(0);
            var diskBalance = await GetCreatorBalanceOfAsync("DISK");
            diskBalance.ShouldBe(0);
            var netBalance = await GetCreatorBalanceOfAsync("NET");
            netBalance.ShouldBe(0);
        }

        await DelayOneMinuteAsync();

        var owningRental = await TokenContractStub.GetOwningRental.CallAsync(new Empty());
        owningRental.ResourceAmount["CPU"].ShouldBe(CpuAmount * Rental);
        owningRental.ResourceAmount["RAM"].ShouldBe(RamAmount * Rental);
        owningRental.ResourceAmount["DISK"].ShouldBe(DiskAmount * Rental);
        owningRental.ResourceAmount["NET"].ShouldBe(NetAmount * Rental);
    }
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainSideChainRentFeeTest.cs (L303-332)
```csharp
        var setSideChainCreatorProposalInput = new InitializeFromParentChainInput
        {
            ResourceAmount =
            {
                { "CPU", CpuAmount },
                { "RAM", RamAmount },
                { "DISK", DiskAmount },
                { "NET", NetAmount }
            },
            Creator = Creator
        };
        await ParliamentReachAnAgreementAsync(TokenContractAddress, defaultParliamentOrganization,
            nameof(TokenContractImplContainer.TokenContractImplStub.InitializeFromParentChain),
            setSideChainCreatorProposalInput);

        var updateRentalInput = new UpdateRentalInput
        {
            Rental =
            {
                { "CPU", Rental },
                { "RAM", Rental },
                { "DISK", Rental },
                { "NET", Rental }
            }
        };
        await TokenContractStub.SetPrimaryTokenSymbol.SendAsync(new SetPrimaryTokenSymbolInput
            { Symbol = NativeTokenSymbol });
        await TokenContractStub.InitializeAuthorizedController.SendAsync(new Empty());
        await UpdateSideChainRentalDefaultProposalAsync(
            nameof(TokenContractImplContainer.TokenContractImplStub.UpdateRental), updateRentalInput);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L14-26)
```csharp
    public override Empty InitializeFromParentChain(InitializeFromParentChainInput input)
    {
        Assert(!State.InitializedFromParentChain.Value, "MultiToken has been initialized");
        State.InitializedFromParentChain.Value = true;
        Assert(input.Creator != null, "creator should not be null");
        foreach (var pair in input.ResourceAmount) State.ResourceAmount[pair.Key] = pair.Value;

        foreach (var pair in input.RegisteredOtherTokenContractAddresses)
            State.CrossChainTransferWhiteList[pair.Key] = pair.Value;

        SetSideChainCreator(input.Creator);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L161-168)
```csharp
    public override OwningRental GetOwningRental(Empty input)
    {
        var owingRental = new OwningRental();
        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName))
            owingRental.ResourceAmount[symbol] = State.OwningRental[symbol];

        return owingRental;
    }
```
