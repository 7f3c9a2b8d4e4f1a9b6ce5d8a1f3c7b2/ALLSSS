# Audit Report

## Title
Empty Method-Specific Delegation Blocks Fallback to Global Delegatees Causing Transaction Fee Payment DoS

## Summary
The transaction fee delegation system uses the `??` null-coalescing operator to fallback from method-specific delegations to global delegations. However, when a method-specific `TransactionFeeDelegatees` entry exists but has an empty `Delegatees` map (a non-null protobuf object with zero entries), the `??` operator fails to trigger the fallback. This causes permanent DoS of transaction fee payment for specific contract-method combinations, even when valid global delegatees exist.

## Finding Description

The vulnerability exists in the delegation lookup logic in `TryToChargeTransactionFee`: [1](#0-0) 

The `??` operator only checks for null references, not empty collections. In C# protobuf implementations, a `TransactionFeeDelegatees` object with an empty `Delegatees` dictionary (defined at line 671 of the proto file) is not null—it's a valid object with `Count == 0`. [2](#0-1) 

**Root Cause 1 - Incomplete Cleanup in SetTransactionFeeDelegateInfos:**

When updating method-specific delegations, the code removes individual delegatees when their delegations are exhausted but fails to remove the entire `TransactionFeeDelegatees` object when all delegatees are removed: [3](#0-2) 

At line 236, individual delegatees are removed from the map, but at lines 244-245, the potentially-empty `TransactionFeeDelegatees` object is saved back to state without checking if `Delegatees.Count == 0`.

**Root Cause 2 - No Cleanup in ModifyDelegation:**

When delegations are consumed during fee charging, amounts are decremented but no cleanup occurs: [4](#0-3) 

The code decrements delegation amounts at lines 222 and 233 but never removes entries when they reach zero, never removes delegatees when all their delegations are exhausted, and never removes the `TransactionFeeDelegatees` object when it becomes empty.

**Root Cause 3 - No Cleanup in RemoveTransactionFeeDelegateInfo:**

Even explicit removal operations fail to clean up empty objects: [5](#0-4) 

Line 383 removes the delegatee, but lines 385-386 save the object back without checking if the `Delegatees` map is now empty.

**Execution Path:**

When attempting to charge fees with an empty method-specific entry: [6](#0-5) 

At line 103, `transactionFeeDelegatees` is non-null (but empty), so the condition passes. At lines 105-106, the foreach loop over `Delegatees` executes zero iterations since the map is empty. No fees are charged, `chargingResult` remains false, and the transaction fails.

The same issue exists in `ChargeFromDelegations`: [7](#0-6) 

Although this uses `?.Delegatees`, if the method-specific entry exists with an empty `Delegatees` map, it returns an empty (non-null) map, and the `??` operator doesn't trigger.

## Impact Explanation

**Medium Severity - Operational DoS:**

Users who configure method-specific delegations for certain contract methods permanently lose the ability to use their global delegatees as a fallback for those methods once the method-specific delegations are exhausted or removed:

1. User sets both global delegatees (via `SetTransactionFeeDelegations`) and method-specific delegatees (via `SetTransactionFeeDelegateInfos`) for Contract X, Method Y
2. Method-specific delegations get consumed through normal transaction fee charging
3. An empty `TransactionFeeDelegatees` object persists in state for that contract-method combination
4. All future transactions to Contract X, Method Y cannot use the global delegatees
5. Transactions fail with "Transaction fee not enough" even though valid global delegatees exist

The severity is Medium because:
- It's a denial-of-service condition, not direct fund theft
- Users retain the ability to pay their own fees directly
- Only affects specific contract-method combinations, not all transactions  
- Requires explicit user actions to recover (calling removal functions)
- Violates the expected fallback behavior designed into the system

## Likelihood Explanation

**High Likelihood:**

The vulnerability triggers through normal system usage without requiring any malicious actor:

1. **Reachable Entry Point:** Users call the public method `SetTransactionFeeDelegateInfos` to configure method-specific delegations, then execute transactions that consume those delegations
2. **Feasible Preconditions:** Only requires a user to have both global and method-specific delegations configured—a legitimate use case
3. **Execution Practicality:** Delegations are naturally consumed during normal transaction execution via the `ChargeTransactionFees` flow: [8](#0-7) 

The `ModifyDelegation` call decrements amounts without cleanup, leading to the empty state over time.

4. **No Special Capabilities Required:** No attacker needed—the bug triggers through intended functionality
5. **High Probability:** Any user with method-specific delegations will eventually encounter this as delegations are consumed

## Recommendation

Add cleanup logic to remove empty parent objects whenever the last delegatee is removed:

**Fix 1 - In SetTransactionFeeDelegateInfos:** After line 245, add:
```csharp
// Clean up empty parent object
if (existDelegateeInfoList.Delegatees.Count == 0)
{
    State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
        .Remove(delegateInfo.MethodName);
}
```

**Fix 2 - In RemoveTransactionFeeDelegateInfo:** After line 386, add:
```csharp
// Clean up empty parent object
if (delegateeInfo.Delegatees.Count == 0)
{
    State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateTransaction.ContractAddress]
        .Remove(delegateTransaction.MethodName);
}
```

**Fix 3 - In ModifyDelegation:** Add cleanup logic to remove zero-value entries and empty delegatees, and remove the parent object if all delegatees are gone.

## Proof of Concept

```csharp
[Fact]
public async Task MethodSpecificDelegation_EmptyFallbackDoS_Test()
{
    // Setup: Create test tokens
    await Initialize();
    
    // Step 1: User sets global delegatees
    await TokenContractStub.SetTransactionFeeDelegations.SendAsync(
        new SetTransactionFeeDelegationsInput
        {
            DelegatorAddress = User1Address,
            Delegations = { { "ELF", 1000 } }
        });
    
    // Verify global delegation exists
    var globalDelegation = await TokenContractStub.GetTransactionFeeDelegationsOfADelegatee.CallAsync(
        new GetTransactionFeeDelegationsOfADelegateeInput
        {
            DelegateeAddress = DefaultAddress,
            DelegatorAddress = User1Address
        });
    globalDelegation.Delegations["ELF"].ShouldBe(1000);
    
    // Step 2: User sets method-specific delegatees for Contract X, Method Y
    await TokenContractStub.SetTransactionFeeDelegateInfos.SendAsync(
        new SetTransactionFeeDelegateInfosInput
        {
            DelegatorAddress = User1Address,
            DelegateInfoList = 
            {
                new DelegateInfo
                {
                    ContractAddress = BasicFunctionContractAddress,
                    MethodName = "TestMethod",
                    Delegations = { { "ELF", 100 } },
                    IsUnlimitedDelegate = false
                }
            }
        });
    
    // Step 3: Remove the method-specific delegation (simulates exhaustion)
    await TokenContractStub.SetTransactionFeeDelegateInfos.SendAsync(
        new SetTransactionFeeDelegateInfosInput
        {
            DelegatorAddress = User1Address,
            DelegateInfoList = 
            {
                new DelegateInfo
                {
                    ContractAddress = BasicFunctionContractAddress,
                    MethodName = "TestMethod",
                    Delegations = { { "ELF", -1 } }, // Remove all
                    IsUnlimitedDelegate = false
                }
            }
        });
    
    // Step 4: Verify empty TransactionFeeDelegatees object exists but fallback fails
    var methodSpecificInfo = await TokenContractStub.GetTransactionFeeDelegateeList.CallAsync(
        new GetTransactionFeeDelegateeListInput
        {
            DelegatorAddress = User1Address,
            ContractAddress = BasicFunctionContractAddress,
            MethodName = "TestMethod"
        });
    
    // Bug: Empty list persists, blocking fallback to global delegatees
    // This causes transaction fee charging to fail even though global delegation exists
    methodSpecificInfo.DelegateeAddresses.Count.ShouldBe(0); // Empty but object exists
    
    // Expected: Should fallback to global delegation and succeed
    // Actual: Transaction fee charging will fail because ?? operator doesn't trigger
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L100-102)
```csharp
            var transactionFeeDelegatees =
                State.TransactionFeeDelegateInfoMap[fromAddress][input.ContractAddress][input.MethodName] ??
                State.TransactionFeeDelegateesMap[fromAddress];
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L103-116)
```csharp
            if (transactionFeeDelegatees != null)
            {
                var delegateeAddress = transactionFeeDelegatees.Delegatees;
                foreach (var (delegatee, _) in delegateeAddress)
                {
                    chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                        isSizeFeeFree, Address.FromBase58(delegatee));
                    if (chargingResult)
                    {
                        break;
                    }
                }
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L174-181)
```csharp
        var delegationInfo =
            State.TransactionFeeDelegateInfoMap[delegatorAddress][input.ContractAddress][input.MethodName]?.Delegatees ?? 
            State.TransactionFeeDelegateesMap[delegatorAddress]?.Delegatees;

        if (delegationInfo == null)
        {
            return false;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L200-204)
```csharp
            if (!delegations.IsUnlimitedDelegate)
            {
                ModifyDelegation(delegateeBill, delegateeAllowanceBill, fromAddress, input.ContractAddress,
                    input.MethodName, delegatorAddress);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L212-235)
```csharp
    private void ModifyDelegation(TransactionFeeBill bill, TransactionFreeFeeAllowanceBill allowanceBill,
        Address delegateeAddress, Address contractAddress, string methodName, Address delegatorAddress)
    {
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            var delegateInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][contractAddress][methodName] ??
                State.TransactionFeeDelegateesMap[delegatorAddress];
            delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol] =
                delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol].Sub(amount);
        }

        foreach (var (symbol, amount) in allowanceBill.FreeFeeAllowancesMap)
        {
            if (amount <= 0) continue;

            var delegateInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][contractAddress][methodName] ??
                State.TransactionFeeDelegateesMap[delegatorAddress];
            delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol] =
                delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol].Sub(amount);
        }
    }
```

**File:** protobuf/token_contract.proto (L670-672)
```text
message TransactionFeeDelegatees{
    map<string,TransactionFeeDelegations> delegatees = 1;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L233-245)
```csharp
            if (existDelegateeInfoList.Delegatees[delegateeAddress].Delegations.Count == 0 &&
                !existDelegateeInfoList.Delegatees[delegateeAddress].IsUnlimitedDelegate)
            {
                existDelegateeInfoList.Delegatees.Remove(delegateeAddress);
                toCancelTransactionList.Value.Add(new DelegateTransaction
                {
                    ContractAddress = delegateInfo.ContractAddress,
                    MethodName = delegateInfo.MethodName
                });
            }

            State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
                [delegateInfo.MethodName] = existDelegateeInfoList;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L379-386)
```csharp
            var delegateeInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateTransaction.ContractAddress][
                    delegateTransaction.MethodName];
            if (delegateeInfo == null || !delegateeInfo.Delegatees.ContainsKey(delegateeAddress)) continue;
            delegateeInfo.Delegatees.Remove(delegateeAddress);
            toCancelTransactionList.Value.Add(delegateTransaction);
            State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateTransaction.ContractAddress][
                delegateTransaction.MethodName] = delegateeInfo;
```
