### Title
Broken Post-Execution Consensus Validation Allows Round State Corruption

### Summary
The `ValidateConsensusAfterExecution` method contains a critical logic flaw where it compares an object reference with itself, rendering the validation completely ineffective. This allows malicious block producers to inject arbitrary corrupted consensus round state (including manipulated LIB heights, mining orders, signatures, and out values) without detection, compromising the integrity of the entire AEDPoS consensus mechanism.

### Finding Description

The root cause is in the `ValidateConsensusAfterExecution` method where the validation logic is fundamentally broken: [1](#0-0) 

The `RecoverFromUpdateValue` and `RecoverFromTinyBlock` methods modify the `currentRound` object **in-place** and return `this`: [2](#0-1) [3](#0-2) 

After lines 89-97 execute, `headerInformation.Round` is reassigned to the **same object reference** as `currentRound` (since `RecoverFromUpdateValue` returns `this`). The subsequent hash comparison at lines 100-101 compares an object with itself, which will **always** return equal: [4](#0-3) 

The hash is computed from the object's serialized bytes: [5](#0-4) [6](#0-5) 

The hash includes critical consensus fields like `ProducedBlocks`, `ProducedTinyBlocks`, `OutValue`, `Signature`, `ImpliedIrreversibleBlockHeight`, and `FinalOrderOfNextRound` which are supposed to be validated.

**Attack Path:**

1. Malicious miner modifies round state in `GetConsensusBlockExtraData` before returning: [7](#0-6) 

2. Modified round is used to generate transaction input via `ExtractInformationToUpdateConsensus`: [8](#0-7) 

3. During execution, `ProcessUpdateValue` applies the corrupted values to state: [9](#0-8) 

4. The broken validation in `ValidateConsensusAfterExecution` fails to detect the corruption because it compares an object with itself, always passing.

5. Corrupted state is persisted via `TryToUpdateRoundInformation`: [10](#0-9) 

### Impact Explanation

**Consensus Integrity Compromise:**
- **LIB Manipulation**: Attacker can set arbitrary `ImpliedIrreversibleBlockHeight` values to manipulate Last Irreversible Block calculations, potentially enabling double-spend attacks or preventing finality
- **Mining Order Manipulation**: By modifying `FinalOrderOfNextRound` and `SupposedOrderOfNextRound`, attacker controls block producer scheduling in subsequent rounds, enabling censorship or unfair advantage
- **Random Number Manipulation**: Corrupted `OutValue` and `Signature` fields poison the random hash generation used for consensus, breaking unpredictability guarantees
- **Secret Sharing Corruption**: Injected fake `PreviousInValue` data in secret sharing undermines the cryptographic randomness foundation

**Affected Parties:**
- All network validators whose consensus state becomes corrupted
- Users whose transactions may be censored or delayed
- Cross-chain operations relying on accurate LIB heights
- Economic participants affected by manipulated mining rewards

**Severity: CRITICAL** - This breaks the fundamental consensus integrity invariant and allows arbitrary state corruption by any block producer without detection.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be a current block producer (miner in the active round)
- Can modify code in consensus contract deployment OR intercept block generation process
- No additional privileges beyond being a scheduled miner

**Attack Complexity: LOW**
- Single modification point in `GetConsensusBlockExtraData` or transaction generation
- No complex timing requirements
- No multi-step coordination needed

**Feasibility: HIGH**
- Any miner in rotation can execute this attack during their time slot
- Block production is a normal, expected operation
- No special network conditions required
- Attack is undetectable due to broken validation

**Detection: NONE**
- The validation that should detect this is completely broken
- No other validation checks these fields comprehensively
- State corruption persists silently across rounds

**Economic Rationality:**
- Zero cost to execute (normal block production)
- High potential gain from manipulating mining order, LIB, or random values
- No risk of detection or punishment due to broken validation

### Recommendation

**Immediate Fix:**

Fix the validation logic in `ValidateConsensusAfterExecution` to properly compare header against state:

```csharp
public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
{
    var headerInformation = new AElfConsensusHeaderInformation();
    headerInformation.MergeFrom(input.Value);
    if (TryToGetCurrentRoundInformation(out var currentRound))
    {
        // Create a COPY of currentRound for comparison
        var expectedRound = currentRound.Clone();
        
        if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
            expectedRound.RecoverFromUpdateValue(headerInformation.Round,
                headerInformation.SenderPubkey.ToHex());

        if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
            expectedRound.RecoverFromTinyBlock(headerInformation.Round,
                headerInformation.SenderPubkey.ToHex());

        var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
        // Now compare expectedRound (recovered from header) with currentRound (from state)
        if (expectedRound.GetHash(isContainPreviousInValue) !=
            currentRound.GetHash(isContainPreviousInValue))
        {
            // ... existing error handling
        }
    }
    return new ValidationResult { Success = true };
}
```

**Additional Safeguards:**

1. Add explicit field-level validation in `ProcessUpdateValue` and `ProcessTinyBlock` to verify critical values match expected calculations
2. Implement unit tests that verify `ValidateConsensusAfterExecution` actually rejects corrupted round data
3. Add monitoring to detect hash comparison failures in production
4. Consider making `RecoverFromUpdateValue` and `RecoverFromTinyBlock` immutable (return new object instead of modifying `this`)

### Proof of Concept

**Initial State:**
- Blockchain running with multiple miners in rotation
- Attacker is scheduled to produce a block during their time slot
- Current round has `CurrentRound.RoundNumber = N`

**Attack Sequence:**

1. Attacker's node generates block during their time slot, calling `GetConsensusExtraData`

2. In `GetConsensusExtraDataToPublishOutValue`, attacker modifies the round object before returning:
   - Set `ImpliedIrreversibleBlockHeight = CurrentHeight + 1000` (far future)
   - Set arbitrary `FinalOrderOfNextRound` values for all miners to control next round order
   - Inject fake `PreviousInValue` for other miners

3. Modified round is used to create `UpdateValueInput` transaction via `ExtractInformationToUpdateConsensus`

4. Block is validated with `ValidateConsensusBeforeExecution` (passes - only checks time slots, permissions)

5. Block executes, `ProcessUpdateValue` applies corrupted values from input to state

6. `ValidateConsensusAfterExecution` is called:
   - Loads `currentRound` from state (now has corrupted values)
   - Calls `currentRound.RecoverFromUpdateValue(headerInformation.Round, pubkey)`
   - This modifies `currentRound` and returns it
   - Assigns result to `headerInformation.Round` (same object now)
   - Compares `headerInformation.Round.GetHash()` with `currentRound.GetHash()`
   - **Both are the same object reference, hash comparison always succeeds**

7. Block is accepted, corrupted state persists

**Expected Result:** Validation should reject block with error "Current round information is different with consensus extra data"

**Actual Result:** Validation passes, corrupted LIB height, mining orders, and random values are permanently written to state, compromising consensus integrity

**Success Condition:** After attack, `State.Rounds[N]` contains attacker's arbitrary values for `ImpliedIrreversibleBlockHeight` and `FinalOrderOfNextRound`, which will be used in subsequent LIB calculations and next round scheduling.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-97)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L60-63)
```csharp
    public Hash GetHash(bool isContainPreviousInValue = true)
    {
        return HashHelper.ComputeFrom(GetCheckableRound(isContainPreviousInValue));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L55-134)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataToPublishOutValue(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        Assert(triggerInformation.InValue != null, "In value should not be null.");

        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
        var previousInValue = Hash.Empty; // Just initial previous in value.

        if (TryToGetPreviousRoundInformation(out var previousRound) && !IsFirstRoundOfCurrentTerm(out _))
        {
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
            else
            {
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
            }
        }

        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);

        Context.LogDebug(
            () => "Previous in value after ApplyNormalConsensusData: " +
                  $"{updatedRound.RealTimeMinersInformation[pubkey].PreviousInValue}");

        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;

        // Update secret pieces of latest in value.
        
        if (IsSecretSharingEnabled())
        {
            UpdateLatestSecretPieces(updatedRound, pubkey, triggerInformation);
        }

        // To publish Out Value.
        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = updatedRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L16-51)
```csharp
    public UpdateValueInput ExtractInformationToUpdateConsensus(string pubkey, ByteString randomNumber)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return null;

        var minerInRound = RealTimeMinersInformation[pubkey];

        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);

        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);

        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L126-132)
```csharp
    private bool TryToUpdateRoundInformation(Round round)
    {
        var ri = State.Rounds[round.RoundNumber];
        if (ri == null) return false;
        State.Rounds[round.RoundNumber] = round;
        return true;
    }
```
