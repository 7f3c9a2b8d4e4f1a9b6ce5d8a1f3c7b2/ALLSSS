### Title
Side Chain Term Number State Inconsistency Causes Consensus Validation Bypass

### Summary
The `SideChainConsensusBehaviourProvider` unconditionally returns `NextRound` behavior when terminating rounds, but when side chain miner lists change from main chain updates, the generated `Round` objects contain incremented `TermNumber` values. Since `ProcessNextRound` does not update `State.CurrentTermNumber.Value` (unlike `ProcessNextTerm`), this creates a persistent state inconsistency that corrupts the `IsFirstRoundOfCurrentTerm` logic, allowing miners to bypass time slot validation and produce blocks outside their assigned time slots.

### Finding Description [1](#0-0) 

The root cause is that `SideChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()` unconditionally returns `NextRound` behavior, which prevents side chains from using the `NextTerm` transaction path that updates `State.CurrentTermNumber.Value`.

When a side chain detects a miner list change from the main chain: [2](#0-1) 

It calls `GenerateFirstRoundOfNewTerm`, which increments the `TermNumber`: [3](#0-2) 

This `Round` with incremented `TermNumber` is then passed to a `NextRound` transaction (not `NextTerm`), which executes `ProcessNextRound`: [4](#0-3) 

Critically, `ProcessNextRound` stores the `Round` via `AddRoundInformation` and updates the round number via `TryToUpdateRoundNumber`, but **does NOT call `TryToUpdateTermNumber`** to update `State.CurrentTermNumber.Value`. In contrast, `ProcessNextTerm` does update the term number: [5](#0-4) 

This creates a state inconsistency where:
- `State.CurrentTermNumber.Value` remains at 1 (set during initialization)
- Stored `Round` objects in `State.Rounds[roundNumber]` have incrementing `TermNumber` values (2, 3, 4...) [6](#0-5) 

The inconsistency corrupts `IsFirstRoundOfCurrentTerm` logic: [7](#0-6) 

When `previousRound.TermNumber` (e.g., 2) differs from `State.CurrentTermNumber.Value` (always 1), the function incorrectly returns `true`, identifying rounds as "first round of current term" when they are not.

### Impact Explanation

The state inconsistency directly impacts consensus validation. In `TimeSlotValidationProvider.CheckMinerTimeSlot`: [8](#0-7) 

When `IsFirstRoundOfCurrentTerm` incorrectly returns `true`, the function returns `true` immediately at line 39, **bypassing all time slot validation checks**. This allows miners to:
- Produce blocks outside their assigned time slots
- Mine continuously without respecting the mining interval
- Violate the consensus schedule that ensures fair block production

This breaks the critical consensus invariant: "Correct round transitions and time-slot validation, miner schedule integrity." The impact is **High** because:
- **Consensus Integrity Violation**: Miners can mine blocks at arbitrary times, breaking the AEDPoS consensus protocol
- **Unfair Block Production**: Malicious miners can produce more blocks than their fair share
- **Chain Security Degradation**: Time slot validation is a core security mechanism preventing continuous mining attacks

All side chains are affected whenever their miner list changes based on main chain updates.

### Likelihood Explanation

The vulnerability is **highly likely** to manifest:

**Reachable Entry Point**: The public `GetConsensusCommand` method is called regularly during block production: [9](#0-8) 

**Feasible Preconditions**: The vulnerability triggers automatically when:
1. Main chain updates its miner list (happens during term changes)
2. Cross-chain consensus information is shared with side chain via `UpdateInformationFromCrossChain`
3. Side chain detects miner list change via `IsMainChainMinerListChanged`
4. Normal block production continues [10](#0-9) 

**No Special Attacker Capabilities Required**: This is a design flaw that occurs during normal operation. Any miner on the side chain can exploit the time slot validation bypass once the state inconsistency exists.

**Persistence**: Once the inconsistency is created (after first miner list change), it persists permanently since `State.CurrentTermNumber.Value` is never updated on side chains.

**Detection Difficulty**: The inconsistency is subtle and would not be immediately obvious in monitoring, as blocks continue to be produced normally but with incorrect validation rules.

### Recommendation

**Immediate Fix**: Modify `ProcessNextRound` to update the term number when the input round's `TermNumber` differs from the current state:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    RecordMinedMinerListOfCurrentRound();
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // NEW: Update term number if it changed (for side chain miner list updates)
    if (nextRound.TermNumber != currentRound.TermNumber)
    {
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), 
            "Failed to update term number in NextRound.");
        
        // Set miner list for the new term on side chains
        if (!State.IsMainChain.Value)
        {
            var minerList = nextRound.GetMinerList();
            SetMinerList(minerList, nextRound.TermNumber);
            State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;
        }
    }
    
    // ... rest of existing code
}
```

**Alternative Fix**: Modify `GenerateNextRoundInformation` for side chains to NOT increment term number when using `NextRound` behavior, maintaining term number consistency:

```csharp
if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
{
    nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
        currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber,
        currentRound.TermNumber); // Pass current term number, not incremented
    nextRound.IsMinerListJustChanged = true; // Still mark as changed
    // ... rest of code
}
```

**Invariant Checks**:
1. Add assertion: `Assert(State.CurrentTermNumber.Value == currentRound.TermNumber)` at the start of consensus methods
2. Add validation in `IsFirstRoundOfCurrentTerm` to check both state and round term numbers match
3. Add monitoring to detect term number drift between state and rounds

**Test Cases**:
1. Test side chain miner list change updates `State.CurrentTermNumber.Value`
2. Test `IsFirstRoundOfCurrentTerm` returns correct values after miner list changes
3. Test time slot validation is not bypassed after miner list changes on side chains

### Proof of Concept

**Initial State**:
- Side chain initialized with `State.CurrentTermNumber.Value = 1`
- Initial miner list: [Miner A, Miner B, Miner C]

**Attack Steps**:

1. **Main chain updates miner list** (term changes from 1 to 2)
   - New miner list: [Miner A, Miner D, Miner E]

2. **Side chain receives update** via `UpdateInformationFromCrossChain`: [11](#0-10) 

3. **Next block production** on side chain:
   - `GetConsensusCommand` detects miner list changed
   - Calls `GenerateFirstRoundOfNewTerm` which creates Round with `TermNumber = 2`
   - Returns `NextRound` behavior (not `NextTerm`)
   - Generates `NextRound` transaction with Round containing `TermNumber = 2`

4. **Transaction execution**:
   - `NextRound` method calls `ProcessNextRound`
   - `ProcessNextRound` stores Round with `TermNumber = 2` but does NOT update `State.CurrentTermNumber.Value`
   - **Result**: `State.CurrentTermNumber.Value = 1`, but `State.Rounds[currentRound].TermNumber = 2`

5. **Validation bypass**:
   - Next validation calls `IsFirstRoundOfCurrentTerm`
   - Reads `State.CurrentTermNumber.Value = 1`
   - Reads `previousRound.TermNumber = 2`
   - Returns `true` (incorrectly, since `2 != 1`)
   - `TimeSlotValidationProvider.CheckMinerTimeSlot` returns `true` immediately, bypassing time slot checks

**Expected Result**: Time slot validation should enforce mining intervals.

**Actual Result**: Time slot validation is bypassed, miners can produce blocks at any time.

**Success Condition**: State inconsistency persists indefinitely, allowing continuous validation bypass on all subsequent blocks until next miner list change, where the inconsistency worsens (term number 3, 4, etc. in rounds while state remains at 1).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L20-23)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-294)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L40-42)
```csharp
        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-174)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L74-84)
```csharp
    public override Empty FirstRound(Round input)
    {
        /* Basic checks. */
        Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");

        /* Initial settings. */
        State.CurrentTermNumber.Value = 1;
        State.CurrentRoundNumber.Value = 1;
        State.FirstRoundNumberOfEachTerm[1] = 1;
        State.MiningInterval.Value = input.GetMiningInterval();
        SetMinerList(input.GetMinerList(), 1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L27-40)
```csharp
    private bool IsFirstRoundOfCurrentTerm(out long termNumber)
    {
        termNumber = 1;
        return (TryToGetTermNumber(out termNumber) &&
                TryToGetPreviousRoundInformation(out var previousRound) &&
                previousRound.TermNumber != termNumber) ||
               (TryToGetRoundNumber(out var roundNumber) && roundNumber == 1);
    }

    private bool TryToGetTermNumber(out long termNumber)
    {
        termNumber = State.CurrentTermNumber.Value;
        return termNumber != 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-64)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };

        return new Empty();
    }
```
