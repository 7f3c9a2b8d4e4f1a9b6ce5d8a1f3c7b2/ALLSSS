# Audit Report

## Title
Sponsor Fund Lock in AnnounceElectionFor Due to Admin/Sponsor Separation Without Recovery Mechanism

## Summary
The `AnnounceElectionFor()` function allows a sponsor to lock 100,000 ELF while designating a different address as admin. Since only the admin can unlock these funds via `QuitElection()`, a sponsor who specifies an admin different from themselves permanently loses control over their locked capital if the admin becomes unresponsive or malicious. No recovery mechanism exists for this scenario.

## Finding Description

The vulnerability exists in the design of the `AnnounceElectionFor()` function where admin and sponsor roles are decoupled without proper safeguards.

When `AnnounceElectionFor()` is called, the admin address is set to either the provided `input.Admin` or defaults to `Context.Sender`, while the sponsor is always recorded as `Context.Sender`: [1](#0-0) [2](#0-1) 

The sponsor's 100,000 ELF tokens are locked via `LockCandidateNativeToken()`, which transfers tokens from `Context.Sender` (the sponsor) to a virtual address: [3](#0-2) [4](#0-3) 

The lock amount is defined as 100,000 ELF (10^8 precision): [5](#0-4) 

The ONLY mechanism to unlock these funds is through `QuitElection()`, which requires the caller to be the admin: [6](#0-5) 

The unlocked tokens are returned to the sponsor (not the admin): [7](#0-6) 

**Critical Gap:** The sponsor cannot change the admin unless they are:
1. The Parliament default address (trusted governance role)
2. The current admin (which they explicitly are not)
3. The candidate's own address (if admin was never set) [8](#0-7) 

When admin ≠ sponsor, the sponsor has none of these privileges and therefore cannot recover their funds if the admin refuses to cooperate.

## Impact Explanation

**Direct Financial Impact:**
- Each vulnerable transaction locks 100,000 ELF permanently if the admin doesn't cooperate
- Sponsors lose complete control over their locked capital
- No timeout or expiration mechanism exists
- No emergency withdrawal capability for sponsors

**Affected Parties:**
- Organizations/DAOs that want to sponsor candidates while delegating operational control
- Scenarios where trust relationships break down between sponsor and admin
- Any legitimate user who separates payment responsibility from management authority

**Severity:** This is a **Medium** severity issue because:
- Requires specific user configuration (admin ≠ sponsor)
- Not exploitable by external attackers
- Creates permanent fund loss for legitimate users
- Affects reasonable use cases with no protocol-level protection
- Impact is concrete (100,000 ELF) and quantifiable

## Likelihood Explanation

**Reachability:** The function is public and callable by any user: [9](#0-8) 

**Feasibility:**
- Single transaction execution required
- No complex preconditions needed
- Legitimate use case: organizations wanting to sponsor candidates while delegating management
- The protocol explicitly supports admin specification separate from the caller

**Probability Factors:**
- No validation prevents admin ≠ sponsor configuration
- Test suite only covers cases where admin cooperates (returns funds) [10](#0-9) 

- No documentation warnings exist about this risk
- Higher likelihood in organizational contexts where separation of concerns is standard practice

## Recommendation

Implement one or more of the following safeguards:

1. **Require admin to equal sponsor:**
```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var admin = input.Admin ?? Context.Sender;
    Assert(admin == Context.Sender, "Admin must be the sponsor for fund safety.");
    // ... rest of implementation
}
```

2. **Add sponsor emergency withdrawal after timeout:**
```csharp
public override Empty SponsorEmergencyWithdraw(StringValue input)
{
    var pubkey = input.Value;
    var sponsor = State.CandidateSponsorMap[pubkey];
    Assert(Context.Sender == sponsor, "Only sponsor can emergency withdraw.");
    
    var candidateInfo = State.CandidateInformationMap[pubkey];
    var lockTime = Context.CurrentBlockTime - candidateInfo.AnnouncementTime;
    Assert(lockTime > 90 * 24 * 60 * 60, "Must wait 90 days before emergency withdrawal."); // 90 days
    
    // Unlock and return tokens to sponsor
    // ... implementation
}
```

3. **Allow sponsor to change admin:**
```csharp
// In SetCandidateAdmin, add:
var sponsor = State.CandidateSponsorMap[input.Pubkey];
if (sponsor != null && Context.Sender == sponsor)
{
    // Allow sponsor to change admin
    State.CandidateAdmins[pubkey] = input.Admin;
    // ... update mappings
    return new Empty();
}
```

4. **Add multi-signature requirement:** Require both admin and sponsor to sign off on configuration where they differ.

## Proof of Concept

```csharp
[Fact]
public async Task SponsorFundLock_AdminRefusesToQuit_FundsPermanentlyLocked()
{
    // Setup: Sponsor and Admin are different addresses
    var sponsorKeyPair = ValidationDataCenterKeyPairs.Last();
    var adminKeyPair = ValidationDataCenterKeyPairs.First();
    var candidateKeyPair = ValidationDataCenterKeyPairs[1];
    
    // Get sponsor's initial balance
    var initialBalance = await GetNativeTokenBalance(sponsorKeyPair.PublicKey);
    
    // Sponsor calls AnnounceElectionFor with different admin
    var sponsorStub = GetElectionContractTester(sponsorKeyPair);
    await sponsorStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Admin = Address.FromPublicKey(adminKeyPair.PublicKey),
        Pubkey = candidateKeyPair.PublicKey.ToHex()
    });
    
    // Verify: Sponsor's balance decreased by 100,000 ELF
    var balanceAfterLock = await GetNativeTokenBalance(sponsorKeyPair.PublicKey);
    balanceAfterLock.ShouldBe(initialBalance - ElectionContractConstants.LockTokenForElection);
    
    // Verify: Sponsor cannot call QuitElection (only admin can)
    var quitResult = await sponsorStub.QuitElection.SendWithExceptionAsync(
        new StringValue { Value = candidateKeyPair.PublicKey.ToHex() });
    quitResult.TransactionResult.Error.ShouldContain("Only admin can quit election");
    
    // Verify: Sponsor cannot change admin to themselves
    var setAdminResult = await sponsorStub.SetCandidateAdmin.SendWithExceptionAsync(
        new SetCandidateAdminInput
        {
            Pubkey = candidateKeyPair.PublicKey.ToHex(),
            Admin = Address.FromPublicKey(sponsorKeyPair.PublicKey)
        });
    setAdminResult.TransactionResult.Error.ShouldContain("No permission");
    
    // Result: If admin refuses to cooperate, sponsor's 100,000 ELF is permanently locked
    // No recovery mechanism exists for the sponsor
}
```

## Notes

This vulnerability represents a design flaw rather than a traditional exploit. It affects legitimate users who reasonably want to separate capital provision from operational management. The protocol provides no safeguards against this configuration, creating systemic risk for organizations using the election system. While requiring Parliament intervention is theoretically possible, this is not a practical recovery mechanism for individual users and represents an inappropriate escalation for what should be a user-level fund recovery operation.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L27-40)
```csharp
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-121)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L127-128)
```csharp
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L132-132)
```csharp
        LockCandidateNativeToken();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L140-140)
```csharp
        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L186-194)
```csharp
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L242-249)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** test/AElf.Contracts.Election.Tests/BVT/SponsorTests.cs (L52-64)
```csharp
    public async Task ElectionContract_QuitElection_Sponsor_Test()
    {
        await ElectionContract_AnnounceElectionFor_State_Test();

        var candidatesKeyPair = ValidationDataCenterKeyPairs.First();
        var sponsorKeyPair = ValidationDataCenterKeyPairs.Last();
        var balanceBeforeAnnouncing = await GetNativeTokenBalance(sponsorKeyPair.PublicKey);

        await QuitElectionAsync(candidatesKeyPair);

        var balanceAfterAnnouncing = await GetNativeTokenBalance(sponsorKeyPair.PublicKey);
        balanceAfterAnnouncing.ShouldBe(balanceBeforeAnnouncing + ElectionContractConstants.LockTokenForElection);
    }
```
