### Title
Scheme Metadata Overwrite Causes Permanent Token Lock Due to LockId Collision

### Summary
The `RegisterForProfits()` function generates lockIds using only the scheme manager address and user address, without including the specific scheme identifier. When a manager creates multiple schemes, the TokenHolder contract overwrites the previous scheme's metadata, causing a symbol mismatch during withdrawal. This results in users being unable to withdraw their locked tokens, leading to permanent fund loss.

### Finding Description

The vulnerability exists in the lockId generation and scheme storage mechanism:

**LockId Generation (Lines 157-158):** [1](#0-0) 

The lockId is generated using `Context.GenerateId(Context.Self, SchemeManager || Sender)`, which does NOT include any scheme-specific identifier. This means all schemes managed by the same address will produce the same lockId for a given user.

**Single Scheme Storage per Manager (Line 27):** [2](#0-1) 

When `CreateScheme()` is called, it stores the scheme at `State.TokenHolderProfitSchemes[Context.Sender]`, which is overwritten if called multiple times by the same manager.

**Profit Contract Supports Multiple Schemes (Lines 62-71):** [3](#0-2) 

The underlying Profit contract explicitly supports multiple schemes per manager, appending each new scheme to the manager's list.

**Scheme Resolution Uses FirstOrDefault (Lines 290-293):** [4](#0-3) 

When resolving the scheme, the contract takes the FIRST scheme from the manager's list, which may not correspond to the overwritten metadata.

**Withdrawal Uses Current Scheme Symbol (Lines 220-225):** [5](#0-4) 

During withdrawal, `GetLockedAmount` is called with `scheme.Symbol` from the current (potentially overwritten) scheme.

**GetLockedAmount Returns Zero for Wrong Symbol (Lines 101-115):** [6](#0-5) 

The function queries the virtual address balance for the specified symbol. If the symbol doesn't match what was originally locked, it returns 0.

### Impact Explanation

**Direct Fund Loss:**
- Users who registered for profits before a scheme overwrite will have their tokens permanently locked
- When attempting withdrawal, `GetLockedAmount` returns 0 for the mismatched symbol
- The unlock operation executes with amount=0, leaving the original locked tokens inaccessible
- All affected users lose 100% of their locked tokens

**Scope:**
- Affects ALL users who registered under a manager who subsequently creates a new scheme
- No time limit or recovery mechanism exists
- The manager cannot reverse this even if they detect the issue

**Severity Justification:**
- HIGH severity due to permanent, irreversible fund loss
- User funds are completely inaccessible
- No admin function exists to recover locked tokens
- The vulnerability violates the critical invariant of "lock/unlock correctness"

### Likelihood Explanation

**Attacker Capabilities:**
- Requires control of a scheme manager address
- Can be triggered accidentally by a legitimate manager attempting to "update" their scheme
- No special privileges or exploits required beyond normal scheme creation

**Attack Complexity:**
- LOW complexity: Just requires calling `CreateScheme` twice with the same manager address
- No timing constraints or race conditions needed
- Deterministic outcome

**Feasibility Conditions:**
- Entry point is public: `CreateScheme` is callable by any address
- No rate limiting or access controls prevent multiple scheme creation
- The Profit contract explicitly supports and tests multiple schemes per manager [7](#0-6) 

**Probability:**
- MEDIUM-HIGH: Managers may legitimately want to create multiple schemes for different tokens
- Accidental triggering is highly plausible (manager tries to "fix" initial scheme by creating new one)
- No warnings or documentation prevent this pattern

### Recommendation

**Immediate Fix:**
1. Include the SchemeId in lockId generation:
```
var lockId = Context.GenerateId(Context.Self, 
    ByteArrayHelper.ConcatArrays(scheme.SchemeId.ToByteArray(), 
        input.SchemeManager.ToByteArray(), 
        Context.Sender.ToByteArray()));
```

2. Prevent scheme overwrites by checking if a scheme already exists:
```
Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
    "Scheme already exists for this manager.");
```

3. Store the locked symbol alongside the lockId:
```
State.LockedSymbols[input.SchemeManager][Context.Sender] = scheme.Symbol;
```
And use it during withdrawal instead of the current scheme's symbol.

**Additional Invariant Checks:**
- Assert that the symbol used for unlock matches the symbol used for lock
- Add a view function to query which scheme a user is registered for
- Emit events when schemes are created to track manager scheme history

**Test Cases:**
- Test that calling CreateScheme twice with same manager reverts
- Test that users registered to Scheme X cannot be affected by creation of Scheme Y
- Test withdrawal after scheme metadata changes

### Proof of Concept

**Initial State:**
- Manager M has no schemes
- User A has 1000 ELF tokens

**Transaction Sequence:**

1. Manager M calls `CreateScheme(symbol="ELF", minimumLockMinutes=100)`
   - Creates SchemeId_X in Profit contract
   - Stores {symbol:"ELF", minimumLockMinutes:100} at State.TokenHolderProfitSchemes[M]

2. User A calls `RegisterForProfits(schemeManager=M, amount=1000)`
   - Locks 1000 ELF tokens with lockId = hash(M||A)
   - User added as beneficiary to SchemeId_X

3. Manager M calls `CreateScheme(symbol="USDT", minimumLockMinutes=200)`
   - Creates SchemeId_Y in Profit contract  
   - OVERWRITES State.TokenHolderProfitSchemes[M] = {symbol:"USDT", minimumLockMinutes:200}

4. User A waits 100 minutes, then calls `Withdraw(M)`
   - GetValidScheme returns {symbol:"USDT", ...}
   - GetLockedAmount(lockId, address=A, symbol="USDT") returns 0 (locked tokens are ELF)
   - Unlock executes with amount=0
   - User A's 1000 ELF remain locked FOREVER

**Expected Result:**
User A should be able to withdraw their 1000 ELF tokens after 100 minutes.

**Actual Result:**
User A's tokens remain permanently locked because GetLockedAmount returns 0 for the wrong symbol (USDT instead of ELF).

**Success Condition:**
User A cannot access their locked tokens, confirming permanent fund loss.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L157-158)
```csharp
        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L220-225)
```csharp
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L290-293)
```csharp
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-115)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
```

**File:** test/AElf.Contracts.Profit.Tests/ProfitTests.cs (L290-293)
```csharp
        var schemeId = await CreateSchemeAsync();
        var creatorWithoutAuthority = Creators[1];
        var removeSubSchemeResult = await creatorWithoutAuthority.RemoveSubScheme.SendWithExceptionAsync(
            new RemoveSubSchemeInput
```
