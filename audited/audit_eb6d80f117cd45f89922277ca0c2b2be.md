### Title
State Corruption in TokenHolder Scheme Initialization - Writes to Wrong Address

### Summary
The `UpdateTokenHolderProfitScheme` method incorrectly writes scheme initialization data to `Context.Sender` instead of the scheme manager's address. When users interact with newly created TokenHolder schemes through `ClaimProfits`, `ContributeProfits`, `RegisterForProfits`, or `Withdraw`, the scheme's `SchemeId` and `Period` fields get written to the caller's address instead of the manager's address, causing permanent state corruption and rendering view functions unusable.

### Finding Description

The vulnerability exists in the `UpdateTokenHolderProfitScheme` private method. [1](#0-0) 

**Root Cause**: At line 298, the method writes the updated scheme to `Context.Sender` instead of the `manager` parameter that was passed to the function. [2](#0-1) 

**Execution Path**:
1. When a scheme is created via `CreateScheme`, it stores basic information (Symbol, MinimumLockMinutes, AutoDistributeThreshold) but leaves `SchemeId` as null. [3](#0-2) 

2. When any user calls `ClaimProfits` for this scheme, `GetValidScheme` is invoked with the scheme manager's address. [4](#0-3) 

3. Inside `GetValidScheme`, it reads the scheme from the manager's address and calls `UpdateTokenHolderProfitScheme`. [5](#0-4) 

4. Since `SchemeId` is null, the update logic executes fully (line 289 condition fails), fetching the real scheme from the Profit contract using the `manager` parameter. [6](#0-5) 

5. **Bug**: The updated scheme is written to `Context.Sender` (the claimer) instead of `manager` (the scheme owner).

**Why Protections Fail**: There are no checks to ensure the scheme state is written to the correct address. Other functions like `DistributeProfits` and `RegisterForProfits` correctly write to the manager's address, but `UpdateTokenHolderProfitScheme` does not follow this pattern. [7](#0-6) 

### Impact Explanation

**Operational Impact - State Corruption and DoS**:

1. **View Functions Fail**: The `GetProfitsMap` function directly reads the scheme from the manager's address without validation. [8](#0-7)  When the scheme at the manager's address has `SchemeId=null`, it passes null to the Profit contract, causing failures or incorrect results.

2. **Permanent Corruption**: The manager's scheme remains uninitialized indefinitely. Every subsequent operation that calls `GetValidScheme` repeats the bug, writing to different callers' addresses but never updating the manager's scheme.

3. **Cross-Contamination**: If a caller is also a scheme manager, their own scheme configuration gets overwritten with another manager's scheme data, corrupting multiple schemes.

4. **Inconsistent State**: Scheme data becomes scattered - basic configuration (Symbol, MinimumLockMinutes) at the manager's address, but critical fields (SchemeId, Period) at various callers' addresses.

**Affected Parties**: All scheme managers whose schemes are interacted with before initialization, and all users who query or interact with these corrupted schemes.

**Severity**: Medium - Causes operational DoS and state corruption affecting protocol functionality, but does not directly lead to fund theft since actual profit distribution is handled by the underlying Profit contract based on beneficiary shares.

### Likelihood Explanation

**Reachable Entry Point**: Multiple public functions trigger this bug:
- `ClaimProfits` [4](#0-3) 
- `ContributeProfits` [9](#0-8) 
- `RegisterForProfits` [10](#0-9) 
- `Withdraw` [11](#0-10) 

**Feasible Preconditions**: 
- A TokenHolder scheme must be newly created (via `CreateScheme`)
- External users interact with it before the manager performs operations like `AddBeneficiary` (which writes to `Context.Sender` who happens to be the manager)
- This is realistic since schemes can be created and immediately used by beneficiaries

**Execution Practicality**: The exploit requires no special permissions - any user can call these public functions. The bug triggers automatically through normal contract usage.

**Attack Complexity**: Low - No sophisticated techniques needed, just normal contract interaction with a newly created scheme.

**Likelihood**: Medium-High - While the bug requires specific timing (interaction before initialization), it's a natural usage pattern and affects core contract functionality.

### Recommendation

**Code-Level Mitigation**: Fix line 298 in `UpdateTokenHolderProfitScheme` to write to the correct address:

```csharp
// Change line 298 from:
State.TokenHolderProfitSchemes[Context.Sender] = scheme;

// To:
State.TokenHolderProfitSchemes[manager] = scheme;
```

**Invariant Checks**: Add validation to ensure scheme initialization writes to the intended manager address, consistent with other state update patterns in the contract. [12](#0-11) 

**Test Cases**: Add regression tests that:
1. Create a scheme
2. Have a different user call `ClaimProfits` immediately
3. Verify the manager's scheme state is properly initialized (SchemeId is not null)
4. Verify `GetProfitsMap` works correctly for the manager's address
5. Verify the caller's scheme state is not modified

### Proof of Concept

**Initial State**:
1. Alice creates a TokenHolder scheme: `CreateScheme(Symbol="ELF", MinimumLockMinutes=0)`
2. State after creation: `State.TokenHolderProfitSchemes[Alice] = {Symbol="ELF", SchemeId=NULL, Period=0}`
3. The Profit contract has created a corresponding scheme with Alice as manager

**Exploitation Steps**:
1. Bob calls: `ClaimProfits(SchemeManager=Alice, Beneficiary=Bob)`
2. Execution flow:
   - `GetValidScheme(Alice)` is called
   - Reads Alice's scheme (SchemeId=NULL)
   - Calls `UpdateTokenHolderProfitScheme(ref scheme, Alice, false)`
   - Since SchemeId is null, fetches real scheme from Profit contract
   - **Bug triggers**: Writes to `State.TokenHolderProfitSchemes[Bob]` instead of `State.TokenHolderProfitSchemes[Alice]`

**Expected Result**: 
- `State.TokenHolderProfitSchemes[Alice].SchemeId` should be populated with the real scheme ID

**Actual Result**:
- `State.TokenHolderProfitSchemes[Alice].SchemeId` remains NULL (corrupted)
- `State.TokenHolderProfitSchemes[Bob].SchemeId` is populated (wrong location)
- Subsequent calls to `GetProfitsMap(SchemeManager=Alice)` fail because it reads SchemeId=NULL from Alice's address
- Alice's scheme is permanently corrupted

**Success Condition**: The vulnerability is confirmed when `GetScheme(Alice)` returns a scheme with `SchemeId=NULL` after Bob's claim, while the scheme should have been initialized.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L100-129)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.Self,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        State.TokenContract.Approve.Send(new ApproveInput
        {
            Spender = State.ProfitContract.Value,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        State.ProfitContract.ContributeProfits.Send(new Profit.ContributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Symbol = input.Symbol,
            Amount = input.Amount
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L143-146)
```csharp
        State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
        scheme.Period = scheme.Period.Add(1);
        State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-209)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

        // Check auto-distribute threshold.
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-245)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L247-257)
```csharp
    public override Empty ClaimProfits(ClaimProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
        var beneficiary = input.Beneficiary ?? Context.Sender;
        State.ProfitContract.ClaimProfits.Send(new Profit.ClaimProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = beneficiary
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L264-276)
```csharp
    public override ReceivedProfitsMap GetProfitsMap(ClaimProfitsInput input)
    {
        var scheme = State.TokenHolderProfitSchemes[input.SchemeManager];
        var profitsMap = State.ProfitContract.GetProfitsMap.Call(new Profit.ClaimProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary ?? Context.Sender
        });
        return new ReceivedProfitsMap
        {
            Value = { profitsMap.Value }
        };
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-284)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```
