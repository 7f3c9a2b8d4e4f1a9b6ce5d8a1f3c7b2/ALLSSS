### Title
Fee Atomicity Violation: Partial Charge Applied on Transaction Failure

### Summary
When base fee charging fails but a token symbol is identified, the `ChargeBaseFee` function adds the user's existing balance and allowance to the transaction bill as a partial charge. This bill is then unconditionally processed by `ModifyBalance`, deducting funds from the user even when the transaction ultimately fails. This breaks the fundamental fee atomicity requirement that users should only be charged when transactions successfully execute.

### Finding Description

The vulnerability exists in the fee charging flow across multiple functions:

**Root Cause Location:** [1](#0-0) 

When `ChargeFirstSufficientToken` returns false (insufficient funds), but `symbolToChargeBaseFee` is not null, the code adds the user's entire existing balance and allowance to the bill as a partial charge. This occurs regardless of whether these amounts are sufficient to cover the required fee.

**Unconditional Bill Processing:** [2](#0-1) 

The `ModifyBalance` function is called unconditionally after all charging attempts (direct + delegations), regardless of whether `chargingResult` is true or false. This processes whatever amounts exist in the bill.

**Balance Deduction:** [3](#0-2) 

The `ModifyBalance` function iterates through the bill and deducts all positive amounts from the user's balance, firing `TransactionFeeCharged` events for each deduction.

**Transaction Failure Flow:** [4](#0-3) 

When charging fails, the output is set to `Success = false` with the message "Transaction fee not enough", but the partial charges have already been applied.

**Pre-Execution Plugin:** [5](#0-4) 

The `IsStopExecuting` method checks the `ChargeTransactionFeesOutput.Success` value and returns true when it's false, preventing the main transaction from executing. However, the fee deductions from the pre-transaction have already been committed.

**Execution Flow:**
1. User initiates transaction requiring 10 ELF base fee + 1 ELF size fee
2. User has only 5 ELF balance
3. `ChargeBaseFee` fails to find sufficient funds
4. Lines 349-353 add 5 ELF (existingBalance) to bill as partial charge
5. All delegation attempts also fail
6. Line 118 calls `ModifyBalance` with bill containing 5 ELF
7. User's 5 ELF is deducted and `TransactionFeeCharged` event fired
8. Function returns `Success = false`
9. Pre-execution plugin stops main transaction from executing
10. **Result: User loses 5 ELF but transaction never executes**

### Impact Explanation

**Direct Fund Impact:**
Users lose funds (their available balance up to the required fee amount) even when transactions fail due to insufficient fees. This violates the fundamental transaction fee semantics where fees should only be charged for successfully executed transactions.

**Affected Parties:**
- Any user with insufficient funds for transaction fees
- Common scenario when fee prices increase or user balance decreases
- No special conditions required - happens naturally in normal operation

**Quantified Impact:**
- For a user with balance B and required fee F where B < F:
  - User loses: min(B, F) tokens
  - User receives: Nothing (transaction doesn't execute)
  - Net loss: min(B, F) tokens with zero benefit

**Severity Justification:**
This is a HIGH severity issue because:
1. Direct, permanent fund loss for users
2. Affects core transaction processing mechanism (every transaction)
3. Violates fundamental blockchain invariant (atomicity of fee charging)
4. No recovery mechanism - funds are permanently deducted
5. Can be triggered unintentionally by normal users

### Likelihood Explanation

**Reachable Entry Point:** [6](#0-5) 

The `ChargeTransactionFees` method is a public contract method called automatically by the ACS1 pre-execution plugin for every transaction.

**Feasible Preconditions:**
- User simply needs insufficient balance for transaction fees
- No malicious intent required - occurs naturally when:
  - User balance is depleted
  - Fee prices increase
  - User miscalculates required fees
  - Multiple transactions drain balance simultaneously

**Execution Practicality:**
The vulnerability triggers automatically in normal transaction flow. No special transactions or contract calls needed.

**Attack Complexity:**
None - this is not an attack but a systemic flaw in fee charging logic. Users are affected without any attacker involvement.

**Economic Rationality:**
Not applicable - users lose funds without any gain to an attacker. This is a protocol-level defect, not an exploit.

**Probability:**
HIGH - Every transaction with insufficient fees triggers this behavior. Given the frequency of transactions and inevitable cases of insufficient balances, this affects users regularly.

### Recommendation

**Immediate Fix:**

Modify the `TryToChargeTransactionFee` function to only call `ModifyBalance` when charging succeeds:

```csharp
// Line 118 should be conditional
if (chargingResult)
{
    ModifyBalance(fromAddress, bill, allowanceBill);
}
```

**Alternative Fix:**

Remove the partial charge logic from `ChargeBaseFee` (lines 349-353). When charging fails, the bill should remain empty:

```csharp
// Lines 349-353 should be removed or commented out
// Do not add partial charges to bill on failure
if (symbolToChargeBaseFee != null)
{
    // bill.FeesMap.Add(symbolToChargeBaseFee, existingBalance);  // REMOVE
    // allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, existingAllowance);  // REMOVE
}
```

**Invariant Check:**
Add assertion before `ModifyBalance` call:
```csharp
Assert(chargingResult || (bill.FeesMap.Count == 0 && allowanceBill.FreeFeeAllowancesMap.Count == 0), 
    "Bill must be empty when charging fails");
```

**Test Cases:**
1. Test transaction with insufficient base fee - verify no deduction occurs
2. Test transaction with sufficient allowance but insufficient balance - verify correct handling
3. Test transaction with failed direct charge but successful delegation - verify only delegatee charged
4. Test transaction with multiple fee tokens where partial balance exists - verify all-or-nothing behavior

### Proof of Concept

**Initial State:**
- User Alice address: 0x123...
- Alice's ELF balance: 5 ELF
- Alice's ELF free fee allowance: 0 ELF
- Method base fee requirement: 10 ELF
- Transaction size fee requirement: 1 ELF
- No delegatees configured for Alice

**Transaction Steps:**
1. Alice submits transaction to call any contract method
2. Pre-execution plugin generates `ChargeTransactionFees` transaction
3. `ChargeTransactionFees` executes with Alice as sender
4. `ChargeBaseFee` attempts to charge 10 ELF base fee
5. `ChargeFirstSufficientToken` finds only 5 ELF available
6. Returns false with `existingBalance = 5`, `existingAllowance = 0`
7. Lines 349-353 execute: `bill.FeesMap.Add("ELF", 5)`
8. `ChargeSizeFee` also fails (insufficient remaining balance)
9. `ChargeTransactionFeesToBill` returns false
10. Delegation attempts fail (no delegatees)
11. Line 118 executes: `ModifyBalance(Alice, bill, allowanceBill)`
12. Alice's balance deducted: 5 ELF â†’ 0 ELF
13. Event fired: `TransactionFeeCharged(symbol="ELF", amount=5, chargingAddress=Alice)`
14. Function returns: `{Success: false, ChargingInformation: "Transaction fee not enough."}`
15. Main transaction stopped by pre-execution plugin

**Expected Result:**
- Alice's balance: 5 ELF (unchanged)
- Transaction status: Failed
- Fee charged: 0 ELF

**Actual Result:**
- Alice's balance: 0 ELF (5 ELF deducted)
- Transaction status: Failed
- Fee charged: 5 ELF (partial charge applied)
- Alice loses funds despite transaction not executing

**Success Condition:**
The vulnerability is confirmed when the `TransactionFeeCharged` event is fired with a positive amount while `ChargeTransactionFeesOutput.Success` is false.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-53)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }

        // Record tx fee bill during current charging process.
        var bill = new TransactionFeeBill();
        var allowanceBill = new TransactionFreeFeeAllowanceBill();
        var fromAddress = Context.Sender;
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L118-118)
```csharp
        ModifyBalance(fromAddress, bill, allowanceBill);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L119-121)
```csharp
        var chargingOutput = new ChargeTransactionFeesOutput { Success = chargingResult };
        if (!chargingResult)
            chargingOutput.ChargingInformation = "Transaction fee not enough.";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L245-254)
```csharp
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            ModifyBalance(fromAddress, symbol, -amount);
            Context.Fire(new TransactionFeeCharged
            {
                Symbol = symbol,
                Amount = amount,
                ChargingAddress = fromAddress
            });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L349-353)
```csharp
            if (symbolToChargeBaseFee != null)
            {
                bill.FeesMap.Add(symbolToChargeBaseFee, existingBalance);
                allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, existingAllowance);
            } // If symbol == 
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L123-129)
```csharp
    public bool IsStopExecuting(ByteString txReturnValue, out string preExecutionInformation)
    {
        var chargeTransactionFeesOutput = new ChargeTransactionFeesOutput();
        chargeTransactionFeesOutput.MergeFrom(txReturnValue);
        preExecutionInformation = chargeTransactionFeesOutput.ChargingInformation;
        return !chargeTransactionFeesOutput.Success;
    }
```
