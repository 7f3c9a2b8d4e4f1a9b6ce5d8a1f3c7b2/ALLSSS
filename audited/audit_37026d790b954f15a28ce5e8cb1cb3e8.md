### Title
Insufficient DefaultBlockMiningLimit Can Cause Consensus Stall Due to Missing Minimum Bounds Validation

### Summary
The `DefaultBlockMiningLimit` calculation in `TinyBlockCommandStrategy` can produce values insufficient for actual block production if `MiningInterval` is misconfigured too small at genesis. With no minimum bounds validation on `MiningInterval` or the configuration override `LimitMillisecondsOfMiningBlock`, the mining validation logic will consistently reject block production attempts, causing complete consensus stall.

### Finding Description

The `DefaultBlockMiningLimit` property calculates the time allocation for block execution: [1](#0-0) 

The calculation is: `DefaultBlockMiningLimit = (MiningInterval / 8) * 3 / 5`

For the default `MiningInterval = 4000ms`, this yields `300ms`. However, if `MiningInterval` is set to a small value at genesis (e.g., `300ms`), the resulting `DefaultBlockMiningLimit ≈ 22.5ms` becomes insufficient.

The validation logic in `MiningRequestService.ValidateBlockMiningTime` checks: [2](#0-1) 

For mining to proceed, the condition `miningDueTime - 250ms >= blockTime + blockExecutionDuration` must hold. When `DefaultBlockMiningLimit` is too small relative to `MiningInterval`, this validation fails immediately. Mathematical analysis shows that if `MiningInterval < 324ms`, even the first block validation fails.

The only validation on `MiningInterval` checks if it's non-positive, not if it meets a practical minimum: [3](#0-2) 

Additionally, the configuration override `LimitMillisecondsOfMiningBlock` only validates against negative values: [4](#0-3) 

When validation fails, `RequestMiningAsync` returns `null`: [5](#0-4) 

This triggers a re-attempt, but if the underlying condition persists, the miner enters an infinite loop of failed validation attempts. If all miners experience this (global misconfiguration), no blocks are produced.

### Impact Explanation

**Complete Consensus Stall**: If `MiningInterval` is misconfigured below the critical threshold (~324ms) at genesis, or if `LimitMillisecondsOfMiningBlock` is set too low via governance, all miners will fail the `ValidateBlockMiningTime` check. No blocks can be produced, halting the entire blockchain.

**Degraded Consensus**: With moderately small values, later tiny blocks in each time slot may fail validation, severely reducing throughput from 8 tiny blocks per slot to potentially 1-2 blocks, or causing intermittent stalls.

**Affected Parties**: All network participants - validators cannot produce blocks, users cannot submit transactions, and the chain becomes non-functional.

**Severity Justification**: This represents a critical availability failure with complete loss of consensus functionality.

### Likelihood Explanation

**Attack Vectors**:
1. **Genesis Misconfiguration**: Node operator sets `MiningInterval` too small in `appsettings.json` during chain initialization. Likelihood: LOW (operator error, but `MiningInterval` cannot be changed after genesis). [6](#0-5) 

2. **Governance Attack**: Malicious governance proposal via Parliament contract to set `LimitMillisecondsOfMiningBlock` to a dangerously small value (e.g., 1-10ms). This requires compromising 2/3 of production nodes. Likelihood: LOW. [7](#0-6) 

**Feasibility**: The default `MiningInterval = 4000ms` produces `DefaultBlockMiningLimit = 300ms`, which is reasonable for most hardware. However, the vulnerability exists because:
- No code-level validation prevents problematic values
- Configuration errors at genesis are permanent (no `SetMiningInterval` method exists)
- Hardware degradation or state bloat could eventually make even default values insufficient

**Probability**: LOW overall, but the impact severity (complete DoS) and lack of protective validation make this a significant risk.

### Recommendation

**1. Add Minimum Bounds Validation for MiningInterval**:

In `Round.CheckRoundTimeSlots()`, add validation:
```csharp
if (baseMiningInterval < 500) // Minimum 500ms for 8 tiny blocks
    return new ValidationResult { Message = "Mining interval too small. Must be >= 500ms." };
```

**2. Add Minimum Bounds Validation for LimitMillisecondsOfMiningBlock**:

In `MiningTimeConfigurationProcessor.ProcessConfigurationAsync()`:
```csharp
if (limit.Value > 0 && limit.Value < 100) // Minimum 100ms for block execution
{
    Logger.LogWarning($"Rejected too-small mining time limit: {limit.Value}ms");
    return;
}
```

**3. Add Invariant Checks**:
- Validate that `MiningInterval >= 8 * (minimum_execution_time + 250ms + TinyBlockMinimumInterval)`
- For default assumptions (min execution = 100ms): `MiningInterval >= 8 * (100 + 250 + 50) = 3200ms`

**4. Test Cases**:
- Test genesis initialization with `MiningInterval < 324ms` and verify rejection
- Test governance proposal to set `LimitMillisecondsOfMiningBlock = 10ms` and verify rejection
- Test consensus behavior when execution time consistently exceeds the limit

### Proof of Concept

**Initial State**:
- Deploy chain with `MiningInterval = 300ms` in `appsettings.json`
- This produces `DefaultBlockMiningLimit = (300/8) * 3/5 = 22.5ms`

**Execution Steps**:
1. Chain starts, genesis block is created
2. First miner attempts to produce block 2:
   - `TinyBlockCommandStrategy` calculates `arrangedMiningTime = currentTime + 50ms`
   - `MiningDueTime = timeSlotStart + 300ms`
   - `LimitMillisecondsOfMiningBlock = 22.5ms`
3. `ValidateBlockMiningTime` checks: `300 - 250 >= 50 + 22.5` → `50 >= 72.5` → **FAILS**
4. `RequestMiningAsync` returns `null`
5. `ConsensusRequestMiningEventHandler` triggers consensus again
6. Same validation fails repeatedly
7. Time slot expires, next miner faces identical issue
8. All miners fail validation with this configuration

**Expected Result**: Consensus proceeds with blocks being produced

**Actual Result**: No blocks produced after genesis, complete consensus stall

**Success Condition**: With proper bounds validation (e.g., `MiningInterval >= 500ms`), the misconfiguration is rejected at initialization, preventing the chain from starting in an unrecoverable state.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L46-49)
```csharp
        /// <summary>
        ///     Give 3/5 of producing time for mining by default.
        /// </summary>
        protected int DefaultBlockMiningLimit => TinyBlockSlotInterval.Mul(3).Div(5);
```

**File:** src/AElf.Kernel/Miner/Application/IMiningRequestService.cs (L32-45)
```csharp
    public async Task<Block> RequestMiningAsync(ConsensusRequestMiningDto requestMiningDto)
    {
        if (!ValidateBlockMiningTime(requestMiningDto.BlockTime, requestMiningDto.MiningDueTime,
                requestMiningDto.BlockExecutionTime))
            return null;

        var blockExecutionDuration =
            CalculateBlockMiningDuration(requestMiningDto.BlockTime, requestMiningDto.BlockExecutionTime);

        var block = (await _minerService.MineAsync(requestMiningDto.PreviousBlockHash,
            requestMiningDto.PreviousBlockHeight, requestMiningDto.BlockTime, blockExecutionDuration)).Block;

        return block;
    }
```

**File:** src/AElf.Kernel/Miner/Application/IMiningRequestService.cs (L47-64)
```csharp
    private bool ValidateBlockMiningTime(Timestamp blockTime, Timestamp miningDueTime,
        Duration blockExecutionDuration)
    {
        if (miningDueTime - Duration.FromTimeSpan(TimeSpan.FromMilliseconds(250)) <
            blockTime + blockExecutionDuration)
        {
            Logger.LogDebug(
                "Mining canceled because mining time slot expired. MiningDueTime: {MiningDueTime}, BlockTime: {BlockTime}, Duration: {BlockExecutionDuration}",
                miningDueTime, blockTime, blockExecutionDuration);
            return false;
        }

        if (blockTime + blockExecutionDuration >= TimestampHelper.GetUtcNow()) return true;
        Logger.LogDebug(
            "Will cancel mining due to timeout: Actual mining time: {BlockTime}, execution limit: {BlockExecutionDuration} ms",
            blockTime, blockExecutionDuration.Milliseconds());
        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L46-47)
```csharp
        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```

**File:** src/AElf.Kernel.Consensus.Core/Application/MiningTimeConfigurationProcessor.cs (L20-26)
```csharp
    public async Task ProcessConfigurationAsync(ByteString byteString, BlockIndex blockIndex)
    {
        var limit = new Int64Value();
        limit.MergeFrom(byteString);
        if (limit.Value < 0) return;
        await _miningTimeProvider.SetLimitMillisecondsOfMiningBlockAsync(blockIndex, limit.Value);
    }
```

**File:** src/AElf.Launcher/appsettings.json (L26-32)
```json
  "Consensus": {
    "InitialMinerList": [],
    "MiningInterval": 4000,
    "StartTimestamp": 0,
    "PeriodSeconds": 604800,
    "MinerIncreaseInterval": 31536000
  },
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L93-100)
```csharp
        var configuredMiningTime = await _miningTimeProvider.GetLimitMillisecondsOfMiningBlockAsync(new BlockIndex
        {
            BlockHeight = chainContext.BlockHeight,
            BlockHash = chainContext.BlockHash
        });
        var limitMillisecondsOfMiningBlock = configuredMiningTime == 0
            ? _consensusCommand.LimitMillisecondsOfMiningBlock
            : configuredMiningTime;
```
