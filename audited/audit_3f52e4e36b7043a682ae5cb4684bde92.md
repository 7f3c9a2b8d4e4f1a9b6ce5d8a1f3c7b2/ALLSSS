# Audit Report

## Title
Signature Manipulation Vulnerability in Extra Block Producer Selection

## Summary
A miner with the first mining order in a round can manipulate the signature calculation by providing an invalid `PreviousInValue`. While validation detects the invalid value and stores `Hash.Empty`, the signature is still calculated using the attacker-supplied value. This manipulated signature directly determines the extra block producer for the next round, allowing attackers to systematically bias reward distribution in their favor.

## Finding Description

The vulnerability exists in the consensus data generation and validation flow, specifically in how `PreviousInValue` validation failures are handled during signature calculation.

**The Attack Flow:**

When a miner produces a block, they provide `triggerInformation.PreviousInValue` which undergoes a self-check. [1](#0-0) 

If this self-check fails (the provided value doesn't hash to the miner's previous `OutValue`), the code sets `previousInValue = Hash.Empty`. However, critically, the signature calculation occurs outside this validation block and unconditionally uses the unvalidated `triggerInformation.PreviousInValue`: [2](#0-1) 

The method then stores the manipulated signature alongside `Hash.Empty` as the previousInValue: [3](#0-2) 

The validation system explicitly allows `Hash.Empty` as a valid `PreviousInValue`, enabling the bypass: [4](#0-3) 

The manipulated signature is stored in the round data: [5](#0-4) 

When generating the next round, this signature determines the extra block producer through modulo arithmetic: [6](#0-5) 

The signature calculation uses XOR operations: [7](#0-6) 

**Root Cause:** The signature calculation at line 92 of `GetConsensusExtraDataToPublishOutValue` occurs unconditionally after the validation check, using `triggerInformation.PreviousInValue` even when it fails validation. This creates a disconnect where the stored `previousInValue` (Hash.Empty) differs from the value used to calculate the signature.

## Impact Explanation

**Reward Misallocation:**
Extra block producers receive additional mining opportunities beyond their regular time slot, producing "tiny blocks" at round boundaries. Since reward distribution is proportional to blocks produced, extra block producers accumulate higher reward shares. [8](#0-7) 

The selection mechanism is supposed to be unpredictable, based on the first miner's signature which should derive from their secret `InValue`. However, attackers can manipulate this by trying different `PreviousInValue` inputs offline until finding one that produces a favorable modulo result.

**Consensus Fairness Violation:**
The AEDPoS consensus mechanism relies on unpredictability in extra block producer selection to ensure fair reward distribution. By manipulating the signature used in this selection, attackers undermine the core fairness guarantee. Over multiple rounds, this creates cumulative advantage for attackers and their colluding allies.

**Systemic Effect:**
Every time an attacker has the first mining order in a round, they can execute this attack. With typical miner counts of 20-50, each miner has approximately 2-5% probability per round. Across hundreds of rounds, attackers systematically accumulate unfair advantages.

## Likelihood Explanation

**Attacker Capabilities:**
Any legitimate miner can execute this attack when assigned the first mining order. The only requirement is normal mining privileges - no special access or compromised keys needed.

**Computational Feasibility:**
The attack is trivially computable:
1. Retrieve all previous round signatures (public blockchain data)
2. Compute `aggregated_sigs = XOR(all_previous_signatures)`
3. For candidate values X, calculate `sig = XOR(X, aggregated_sigs)`
4. Test if `(sig.ToInt64() % minerCount) + 1` equals desired position
5. Use any X that produces favorable result

With 20-50 possible outcomes, finding a suitable X requires testing only dozens of valuesâ€”achievable in milliseconds.

**Detection Impossibility:**
The attack produces identical on-chain state to legitimate scenarios where miners didn't participate in the previous round. `PreviousInValue = Hash.Empty` is a valid state with no distinguishing features. No monitoring system can differentiate malicious from legitimate Hash.Empty usage.

**Execution Frequency:**
Attackers can exploit this every round where they have Order 1, which occurs with probability 1/minerCount. Over extended operation, this provides numerous exploitation opportunities.

## Recommendation

Move the signature calculation inside the validation conditional block to ensure it uses validated inputs:

```csharp
if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
    previousRound.RealTimeMinersInformation[pubkey].OutValue)
{
    Context.LogDebug(() => "Failed to produce block at previous round?");
    previousInValue = Hash.Empty;
    // Calculate signature with fake value when validation fails
    var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
    signature = previousRound.CalculateSignature(fakePreviousInValue);
}
else
{
    previousInValue = triggerInformation.PreviousInValue;
    signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
}
```

This ensures the signature is always calculated from the same value that gets stored, preventing the manipulation vector.

## Proof of Concept

```csharp
[Fact]
public void SignatureManipulation_AllowsExtraBlockProducerControl()
{
    // Setup: Get previous round with all miner signatures
    var previousRound = GetPreviousRoundWithSignatures();
    
    // Attacker is miner with Order 1
    var attackerPubkey = "attacker_pubkey";
    
    // Step 1: Calculate aggregated signatures from previous round (public data)
    var aggregatedSig = previousRound.RealTimeMinersInformation.Values
        .Aggregate(Hash.Empty, (current, m) => 
            HashHelper.XorAndCompute(current, m.Signature));
    
    // Step 2: Try different PreviousInValue candidates to find one that produces desired order
    var desiredExtraBlockProducerOrder = 5; // Attacker wants position 5 to be extra block producer
    var minerCount = previousRound.RealTimeMinersInformation.Count;
    
    Hash manipulatedPreviousInValue = null;
    for (int i = 0; i < 100; i++)
    {
        var testValue = HashHelper.ComputeFrom($"test_{i}");
        var testSig = HashHelper.XorAndCompute(testValue, aggregatedSig);
        var resultingOrder = Math.Abs(testSig.ToInt64() % minerCount) + 1;
        
        if (resultingOrder == desiredExtraBlockProducerOrder)
        {
            manipulatedPreviousInValue = testValue;
            break;
        }
    }
    
    Assert.NotNull(manipulatedPreviousInValue); // Should find a value quickly
    
    // Step 3: Provide manipulated value that fails validation
    var triggerInfo = new AElfConsensusTriggerInformation
    {
        PreviousInValue = manipulatedPreviousInValue,
        InValue = Hash.FromString("current_in_value"),
        Pubkey = ByteString.CopyFromUtf8(attackerPubkey)
    };
    
    // Step 4: Signature is calculated with manipulated value despite validation failure
    var signature = previousRound.CalculateSignature(manipulatedPreviousInValue);
    
    // Step 5: This signature determines extra block producer
    var extraBlockProducerOrder = Math.Abs(signature.ToInt64() % minerCount) + 1;
    
    // Verify attacker successfully manipulated the selection
    Assert.Equal(desiredExtraBlockProducerOrder, extraBlockProducerOrder);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L80-86)
```csharp
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L13-13)
```csharp
        RealTimeMinersInformation[pubkey].Signature = signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-122)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
