### Title
Missing Authorization Check in SetTreasurySchemeIds Allows Unauthorized Treasury Scheme ID Initialization

### Summary
The `SetTreasurySchemeIds()` function in the Election contract lacks authorization checks, allowing any address to set critical treasury profit scheme IDs on a first-caller-wins basis. This enables an attacker to frontrun the legitimate initialization by the Economic contract, permanently breaking the profit distribution system.

### Finding Description

The `SetTreasurySchemeIds()` method contains only a duplicate-initialization check but no authorization validation: [1](#0-0) 

The method is intended to be called exclusively by the Economic contract during system initialization: [2](#0-1) 

However, unlike other sensitive methods in the same contract, `SetTreasurySchemeIds()` performs no sender verification. Compare with `UpdateCandidateInformation()`: [3](#0-2) 

And `UpdateMinersCount()`: [4](#0-3) 

And `TakeSnapshot()`: [5](#0-4) 

The method is publicly exposed as an RPC endpoint: [6](#0-5) 

Existing test coverage only validates duplicate setting prevention, not authorization: [7](#0-6) 

### Impact Explanation

**Concrete Harm:**
1. An attacker can set arbitrary Hash values for all five treasury scheme IDs (TreasuryHash, WelfareHash, SubsidyHash, WelcomeHash, FlexibleHash)
2. These IDs control the entire profit distribution mechanism used in `TakeSnapshot()`: [8](#0-7) 

3. Once set by an attacker, legitimate initialization by the Economic contract will fail, blocking the entire economic system from functioning
4. The values cannot be corrected or resetâ€”the system is permanently broken

**Affected Parties:**
- All network participants dependent on mining rewards and profit distribution
- System operators unable to complete chain initialization
- Economic contract unable to establish correct treasury integration

**Severity Justification:**
CRITICAL - Single unauthorized call causes permanent, irreversible system failure with no recovery mechanism.

### Likelihood Explanation

**Attack Scenarios:**

1. **Genesis Block Race Condition**: If external transactions can execute between Election contract deployment (position 22) and Economic contract initialization (position 33): [9](#0-8) 

2. **Initialization Failure**: If `InitialEconomicSystem()` fails or is omitted during deployment: [10](#0-9) 

3. **Side Chain Misconfiguration**: Test networks or side chains deploying Election contract without proper Economic contract initialization sequence: [11](#0-10) 

**Attacker Capabilities:**
- Can submit transaction to any publicly accessible node
- Requires no special privileges or tokens
- Zero economic cost (minimal gas fees)
- Timing window exists in non-atomic initialization scenarios

**Feasibility:** HIGH - Method is public, no preconditions beyond uninitialized state, attack is trivial to execute.

### Recommendation

Add sender authorization check matching the pattern used in other sensitive methods:

```csharp
public override Empty SetTreasurySchemeIds(SetTreasurySchemeIdsInput input)
{
    Assert(
        Context.GetContractAddressByName(SmartContractConstants.EconomicContractSystemName) == Context.Sender,
        "Only economic contract can set treasury scheme ids.");
    Assert(State.TreasuryHash.Value == null, "Treasury profit ids already set.");
    State.TreasuryHash.Value = input.TreasuryHash;
    State.WelfareHash.Value = input.WelfareHash;
    State.SubsidyHash.Value = input.SubsidyHash;
    State.WelcomeHash.Value = input.WelcomeHash;
    State.FlexibleHash.Value = input.FlexibleHash;
    return new Empty();
}
```

**Additional Hardening:**
1. Add authorization test case verifying only Economic contract can call the method
2. Consider making the method internal or removing from public RPC interface
3. Add integration test validating complete initialization sequence atomicity

### Proof of Concept

**Initial State:**
- Election contract deployed and initialized via `InitialElectionContract()`
- Economic contract deployed but `InitialEconomicSystem()` not yet executed
- `State.TreasuryHash.Value == null` (uninitialized)

**Attack Steps:**
1. Attacker calls `SetTreasurySchemeIds()` with arbitrary Hash values before legitimate initialization
2. Transaction succeeds (no authorization check blocks it)
3. State variables set to attacker-controlled values
4. Economic contract attempts initialization via `SetTreasurySchemeIdsToElectionContract()`
5. Legitimate call fails with "Treasury profit ids already set."

**Expected Result:** Only Economic contract can set treasury scheme IDs

**Actual Result:** First caller (attacker) successfully sets values, blocking legitimate initialization permanently

**Success Condition:** Transaction returns Empty, all five state variables contain attacker-supplied Hash values, subsequent legitimate calls fail

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L83-88)
```csharp
    public override Empty UpdateCandidateInformation(UpdateCandidateInformationInput input)
    {
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) ==
            Context.Sender || Context.Sender == GetEmergencyResponseOrganizationAddress(),
            "Only consensus contract can update candidate information.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L162-171)
```csharp
    public override Empty SetTreasurySchemeIds(SetTreasurySchemeIdsInput input)
    {
        Assert(State.TreasuryHash.Value == null, "Treasury profit ids already set.");
        State.TreasuryHash.Value = input.TreasuryHash;
        State.WelfareHash.Value = input.WelfareHash;
        State.SubsidyHash.Value = input.SubsidyHash;
        State.WelcomeHash.Value = input.WelcomeHash;
        State.FlexibleHash.Value = input.FlexibleHash;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L402-408)
```csharp
    public override Empty TakeSnapshot(TakeElectionSnapshotInput input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        Assert(State.AEDPoSContract.Value == Context.Sender, "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L442-454)
```csharp
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.SubsidyHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.WelfareHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L16-40)
```csharp
    public override Empty InitialEconomicSystem(InitialEconomicSystemInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");

        State.TokenContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Context.LogDebug(() => "Will create tokens.");
        CreateNativeToken(input);
        CreateResourceTokens();
        CreateElectionTokens();

        Context.LogDebug(() => "Finished creating tokens.");

        InitialMiningReward(input.MiningRewardTotalAmount);

        RegisterElectionVotingEvent();
        SetTreasurySchemeIdsToElectionContract();

        InitializeTokenConverterContract();
        State.TokenContract.InitialCoefficients.Send(new Empty());
        State.TokenContract.InitializeAuthorizedController.Send(new Empty());
        State.Initialized.Value = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L187-209)
```csharp
    private void SetTreasurySchemeIdsToElectionContract()
    {
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
        var schemeIdsManagingByTreasuryContract = State.ProfitContract.GetManagingSchemeIds.Call(
            new GetManagingSchemeIdsInput
            {
                Manager = Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)
            }).SchemeIds;
        var schemeIdsManagingByElectionContract = State.ProfitContract.GetManagingSchemeIds.Call(
            new GetManagingSchemeIdsInput
            {
                Manager = Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName)
            }).SchemeIds;
        State.ElectionContract.SetTreasurySchemeIds.Send(new SetTreasurySchemeIdsInput
        {
            TreasuryHash = schemeIdsManagingByTreasuryContract[0],
            WelcomeHash = schemeIdsManagingByTreasuryContract[3],
            FlexibleHash = schemeIdsManagingByTreasuryContract[4],
            SubsidyHash = schemeIdsManagingByElectionContract[0],
            WelfareHash = schemeIdsManagingByElectionContract[1]
        });
    }
```

**File:** protobuf/election_contract.proto (L72-74)
```text
    // Set the treasury profit ids.
    rpc SetTreasurySchemeIds (SetTreasurySchemeIdsInput) returns (google.protobuf.Empty) {
    }
```

**File:** test/AElf.Contracts.Election.Tests/GQL/ElectionTests.cs (L39-52)
```csharp
    [Fact]
    public async Task ElectionContract_SetTreasurySchemeIds_SetTwice_Test()
    {
        var setSchemeIdRet = await ElectionContractStub.SetTreasurySchemeIds.SendAsync(new SetTreasurySchemeIdsInput
        {
            SubsidyHash = HashHelper.ComputeFrom("Subsidy"),
            TreasuryHash = HashHelper.ComputeFrom("Treasury"),
            WelfareHash = HashHelper.ComputeFrom("Welfare"),
            WelcomeHash = HashHelper.ComputeFrom("Welcome"),
            FlexibleHash = HashHelper.ComputeFrom("Flexible")
        });
        setSchemeIdRet.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        setSchemeIdRet.TransactionResult.Error.ShouldContain("Treasury profit ids already set.");
    }
```

**File:** src/AElf.ContractTestBase/MainChainContractDeploymentListProvider.cs (L16-35)
```csharp
    public List<Hash> GetDeployContractNameList()
    {
        return new List<Hash>
        {
            VoteSmartContractAddressNameProvider.Name,
            ProfitSmartContractAddressNameProvider.Name,
            ElectionSmartContractAddressNameProvider.Name,
            TreasurySmartContractAddressNameProvider.Name,
            ParliamentSmartContractAddressNameProvider.Name,
            AssociationSmartContractAddressNameProvider.Name,
            ReferendumSmartContractAddressNameProvider.Name,
            TokenSmartContractAddressNameProvider.Name,
            CrossChainSmartContractAddressNameProvider.Name,
            ConfigurationSmartContractAddressNameProvider.Name,
            ConsensusSmartContractAddressNameProvider.Name,
            TokenConverterSmartContractAddressNameProvider.Name,
            TokenHolderSmartContractAddressNameProvider.Name,
            EconomicSmartContractAddressNameProvider.Name
        };
    }
```

**File:** test/AElf.Contracts.Economic.TestBase/ContractsPreparation.cs (L369-397)
```csharp
    protected async Task InitializeElection()
    {
        var minerList = InitialCoreDataCenterKeyPairs.Select(o => o.PublicKey.ToHex()).ToArray();
        var result = await ElectionContractStub.InitialElectionContract.SendAsync(new InitialElectionContractInput
        {
            MaximumLockTime = 1080 * 86400,
            MinimumLockTime = 7 * 86400,
            TimeEachTerm = EconomicContractsTestConstants.PeriodSeconds,
            MinerList = { minerList },
            MinerIncreaseInterval = EconomicContractsTestConstants.MinerIncreaseInterval
        });
        CheckResult(result.TransactionResult);
    }

    protected async Task InitializeEconomicContract()
    {
        //create native token
        {
            var result = await EconomicContractStub.InitialEconomicSystem.SendAsync(new InitialEconomicSystemInput
            {
                NativeTokenDecimals = EconomicContractsTestConstants.Decimals,
                IsNativeTokenBurnable = EconomicContractsTestConstants.IsBurnable,
                NativeTokenSymbol = EconomicContractsTestConstants.NativeTokenSymbol,
                NativeTokenTotalSupply = EconomicContractsTestConstants.TotalSupply,
                MiningRewardTotalAmount = EconomicContractsTestConstants.TotalSupply / 5
            });
            CheckResult(result.TransactionResult);
        }
    }
```
