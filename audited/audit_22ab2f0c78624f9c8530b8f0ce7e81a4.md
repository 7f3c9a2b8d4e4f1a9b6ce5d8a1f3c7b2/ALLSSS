### Title
Missing Validation of Revealed Secret-Shared InValues Enables Miner DoS via PreviousInValue Poisoning

### Summary
The AEDPoS consensus contract fails to validate that revealed `PreviousInValue` entries computed via secret sharing match the on-chain decrypted pieces. A malicious block producer can inject incorrect revealed values into consensus extra data, which get unconditionally written to round state. When victim miners miss a round, their `InValue` is poisoned with the incorrect value, permanently preventing them from mining in future rounds due to signature validation failures.

### Finding Description

The vulnerability spans multiple code locations in the secret sharing mechanism:

**Primary Issue - Lack of Validation:** [1](#0-0) 

The `UpdateLatestSecretPieces` method sets `PreviousInValue` from `triggerInformation.RevealedInValues` without verifying these values match what can be reconstructed from on-chain `DecryptedPieces` using the secret sharing algorithm. The only check is whether the value is currently null/empty, not whether it's correct.

**Unconditional Propagation:** [2](#0-1) 

The `PerformSecretSharing` method unconditionally overwrites `PreviousInValue` from `input.MinersPreviousInValues`, propagating any incorrect values that were previously set. No validation occurs here.

**Vulnerable Usage:** [3](#0-2) 

When transitioning rounds, `SupplyCurrentRoundInformation` uses the stored `PreviousInValue` to fill `InValue` for miners who didn't produce blocks. If this value is incorrect, the miner's `OutValue` becomes Hash(incorrect_value), permanently corrupting their consensus state.

**Insufficient Validation:** [4](#0-3) 

The `ValidatePreviousInValue` method only validates the sender's own `PreviousInValue` against their previous `OutValue`. It does not validate revealed values for OTHER miners, allowing malicious values to be injected without detection.

**Note on Original Question:** [5](#0-4) 

The unconditional write at line 52 in `RevealSharedInValues` operates on a local copy of `currentRound` that is never persisted to state (the function is called from `GetConsensusExtraDataForNextRound` but the modified round is discarded). This specific line is dead code, but the broader secret sharing mechanism has the vulnerability described above.

### Impact Explanation

**Direct Consensus Impact:**
- Victim miners become permanently unable to produce blocks after their `InValue` is poisoned
- With 2/3 threshold for secret sharing, an attacker controlling 1 malicious miner can target any other miner
- Multiple victims cause consensus failure as insufficient miners remain to produce blocks

**Operational Harm:**
- Targeted DoS of specific miners by corrupting their consensus state
- Loss of mining rewards for affected miners (economic damage)
- Potential chain halt if enough miners are compromised
- No recovery mechanism exists - victims cannot correct their poisoned `InValue`

**Affected Parties:**
- Victim miners who miss a round become permanently disabled
- Network suffers from reduced block production capacity
- Users experience degraded service or complete chain halt

**Severity Justification:**
HIGH severity due to:
- Permanent consensus disruption with no recovery
- Single malicious miner can attack any other miner
- No mining rewards required for attack (zero cost)
- Breaks fundamental consensus integrity invariant

### Likelihood Explanation

**Attacker Capabilities:**
- Any miner can become the attacker (authorized miners only, but no special privileges needed beyond being in miner list)
- Attacker constructs `AElfConsensusTriggerInformation` with arbitrary `RevealedInValues` map when producing blocks [6](#0-5) 

**Attack Complexity:**
- LOW - Attacker simply includes incorrect Hash values in `triggerInformation.RevealedInValues` for target miners
- No cryptographic breaking required
- Single malicious block sufficient to poison victim's state

**Feasibility Conditions:**
- Attacker must be elected miner (but this is normal for consensus participants)
- Victim must not produce block in the round where poisoning occurs (allows `SupplyCurrentRoundInformation` to use revealed value)
- No other preconditions required

**Detection Constraints:**
- Honest nodes cannot detect incorrect revealed values during validation because there's no validation comparing revealed values against on-chain decrypted pieces
- Attack succeeds silently until victim attempts to mine in later rounds

**Probability:**
HIGH - Attack is trivial to execute for any malicious miner, requires only one missed round by victim, and has zero cost. The lack of validation makes detection impossible during block validation.

### Recommendation

**Primary Fix - Add Revealed InValue Validation:**

Add a new validation provider that reconstructs `PreviousInValue` from on-chain `DecryptedPieces` and compares against claimed revealed values:

1. In `ValidateBeforeExecution`, add a `RevealedInValuesValidationProvider` for `UpdateValue` behavior
2. The provider should:
   - Retrieve previous round's `DecryptedPieces` from state
   - For each revealed value in consensus extra data, reconstruct it using `SecretSharingHelper.DecodeSecret`
   - Compare reconstructed value against claimed value
   - Reject block if mismatch detected

**Secondary Fix - Remove Unconditional Write:**

Modify `PerformSecretSharing` to check if `PreviousInValue` already exists before overwriting: [2](#0-1) 

Change line 296 to only set if currently null/empty, matching the pattern in `UpdateLatestSecretPieces`.

**Invariant Checks:**
- Assert: All revealed `PreviousInValue` entries must hash correctly when reconstructed from on-chain `DecryptedPieces` using threshold secret sharing
- Assert: `PreviousInValue` can only be set once per round per miner (prevent overwrites)
- Assert: Revealed values require minimum 2/3 threshold of decrypted pieces before acceptance

**Test Cases:**
1. Test malicious miner providing incorrect revealed value - should be rejected during validation
2. Test victim miner successfully mining after correct revealed value with missed round
3. Test multiple miners providing conflicting revealed values - should reject all
4. Test edge cases: exactly threshold pieces, all pieces, single malicious piece

### Proof of Concept

**Initial State:**
- Round N: Miners A, B, M (malicious) are active
- All miners produce blocks and share encrypted pieces of their `InValue`
- Secret sharing threshold: 2/3 (requires 2 out of 3 decrypted pieces)

**Attack Steps:**

1. **Round N completes** - All miners produce blocks with valid `EncryptedPieces` and `DecryptedPieces`

2. **Round N+1, Block 1** - Malicious miner M produces first block:
   - M's off-chain service computes correct revealed values but M modifies trigger information
   - M sets `triggerInformation.RevealedInValues["B"]` to `Hash.FromString("fake")` instead of correct value
   - M calls `GetConsensusExtraData` which calls `UpdateLatestSecretPieces`
   - B's `PreviousInValue` is set to fake value (passes null check at line 150-151)
   - M's block is accepted because no validation checks revealed values against on-chain decrypted pieces

3. **Round N+1, Block 2** - Honest miner A produces block:
   - A's trigger information has correct revealed value for B
   - But `UpdateLatestSecretPieces` skips writing it (line 150-151 check fails - already non-null)
   - Fake value persists in state

4. **Round N+1 â†’ N+2 transition** - Victim B doesn't mine in Round N+1:
   - `NextRound` transaction calls `SupplyCurrentRoundInformation`
   - Line 191 reads B's `PreviousInValue` (the fake value)
   - Line 213 sets B's `InValue` to fake value
   - B's `OutValue` becomes `Hash(fake)` in round state

5. **Round N+2** - Victim B attempts to mine:
   - B provides their actual `PreviousInValue` (correct value, not fake)
   - Validation checks: `HashHelper.ComputeFrom(B.PreviousInValue)` vs `B.PreviousRound.OutValue`
   - But `B.PreviousRound.OutValue` is `Hash(fake)`, not `Hash(correct)`
   - Validation fails - B cannot produce blocks

**Expected Result:** B should be able to mine with correct `PreviousInValue` validated against their actual previous `OutValue`

**Actual Result:** B is permanently blocked from mining because their `OutValue` in state was corrupted by malicious revealed value

**Success Condition:** Attack succeeds when B's `OutValue` is `Hash(fake)` instead of `Hash(correct)`, preventing B from mining in all future rounds until manual intervention/contract upgrade.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L186-193)
```csharp
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L52-52)
```csharp
            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L112-114)
```csharp
            var revealedInValues = _secretSharingService.GetRevealedInValues(hint.RoundId);
            foreach (var revealedInValue in revealedInValues)
                trigger.RevealedInValues.Add(revealedInValue.Key, revealedInValue.Value);
```
