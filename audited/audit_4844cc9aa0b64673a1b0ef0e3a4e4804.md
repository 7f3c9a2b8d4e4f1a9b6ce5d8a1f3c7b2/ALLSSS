### Title
Hash Collision Vulnerability in NFT Token Hash Calculation Due to Ambiguous String Concatenation

### Summary
The `CalculateTokenHash` function concatenates NFT protocol symbols and token IDs without a separator, allowing hash collisions between different NFTs when one protocol's symbol is a numerical prefix of another's. This enables denial of service or data corruption depending on the `IsTokenIdReuse` setting, potentially allowing attackers to block legitimate NFT minting or corrupt NFT ownership data.

### Finding Description

The vulnerability exists in the token hash calculation mechanism: [1](#0-0) 

NFT protocol symbols are generated with a format of 2 letters followed by N digits (where N ≥ 9), and this length increases over time: [2](#0-1) [3](#0-2) 

The symbol length increases as more protocols are created: [4](#0-3) 

**Root Cause**: String concatenation without separator creates ambiguity. When Protocol A has symbol "AB100000001" (11 chars: 2 letters + 9 digits) and Protocol B has symbol "AB1000000012" (12 chars: 2 letters + 10 digits), the following collision occurs:
- Protocol A: "AB100000001" + TokenId "23" → "AB10000000123"
- Protocol B: "AB1000000012" + TokenId "3" → "AB10000000123"

Both produce identical hash inputs, resulting in the same `tokenHash`.

**Why Protections Fail**: The uniqueness check in `PerformMint` only validates within a single protocol context: [5](#0-4) 

This check uses `tokenHash` as the key but doesn't distinguish between collisions from the same protocol versus collisions across different protocols. When Protocol B attempts to mint TokenId "3", it retrieves Protocol A's NFT data (due to hash collision) and either fails with a misleading error (if `IsTokenIdReuse = false`) or corrupts the data (if `IsTokenIdReuse = true`).

**Note on Original Question**: The question incorrectly identifies "integer overflow" as the root cause. String concatenation in C# (`$"{symbol}{tokenId}"`) converts the long to its string representation without arithmetic operations, so no integer overflow occurs even with values near `Int64.MaxValue`. The actual vulnerability is ambiguous concatenation.

### Impact Explanation

**Scenario 1 - When IsTokenIdReuse = false (DoS)**:
- Protocol B's legitimate minting attempts fail with error "Token id 3 already exists"
- The error message is misleading (suggests duplicate within same protocol)
- Blocks valid NFT creation, causing operational disruption

**Scenario 2 - When IsTokenIdReuse = true (Data Corruption)**:
The else branch executes, corrupting NFT data: [6](#0-5) 

This modifies Protocol A's NFT by:
- Adding Protocol B's minter to Protocol A's minter list
- Increasing Protocol A's NFT quantity with Protocol B's mint
- Crediting balances to Protocol B's owner under the shared tokenHash
- Result: Mixed ownership data, incorrect quantities, corrupted NFT metadata

**Affected Parties**:
- NFT protocol owners whose symbols become prefixes of later protocols
- Users attempting to mint legitimate NFTs under affected protocols
- NFT owners whose balance/ownership data gets corrupted

**Severity Justification**: High - corrupts fundamental NFT ownership invariants, enables cross-protocol data manipulation, and compromises token uniqueness guarantees.

### Likelihood Explanation

**Attacker Capabilities Required**:
- Must be a minter for Protocol A (the protocol with shorter symbol)
- Can observe all protocol symbols on-chain
- Can calculate colliding TokenIds deterministically

**Attack Complexity**:
1. Monitor for protocol pairs where one symbol is a numerical prefix of another
2. Calculate: For Protocol B's TokenId `T2`, mint `T1 = suffix(B) + T2` under Protocol A
   - Example: If SymbolA = "AB100000001", SymbolB = "AB1000000012" (suffix "2"), then T1 = "2" + T2
3. Execute mint transaction under Protocol A with calculated TokenId

**Feasibility Conditions**:
- Symbol collision probability: With random N-digit and (N+1)-digit numbers, probability that longer symbol has shorter as prefix ≈ 1/10
- As protocol count grows (birthday paradox), collision probability increases
- Once symbols exist, exploitation is deterministic
- Minter permission is protocol-specific, often granted to creators/designated addresses

**Detection Constraints**:
- Collision is not immediately apparent from transaction logs
- Manifests as failed mints or data inconsistencies
- Difficult to distinguish from legitimate uniqueness violations

**Probability Assessment**: Medium-High
- Random symbol generation makes specific collisions unlikely
- However, over hundreds/thousands of protocols, prefix collisions become probable
- Once collision exists, exploitation is straightforward for malicious minters

### Recommendation

**Immediate Fix**: Add an unambiguous separator in `CalculateTokenHash`:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}:{tokenId}");
}
```

The separator (e.g., `:`) ensures "AB100000001:23" ≠ "AB1000000012:3", eliminating ambiguity.

**Invariant Check**: Add cross-protocol collision detection in `PerformMint`:

```csharp
var nftInfo = State.NftInfoMap[tokenHash];
if (nftInfo != null) 
{
    Assert(nftInfo.Symbol == input.Symbol, 
        $"Hash collision detected between protocols {input.Symbol} and {nftInfo.Symbol}");
    // existing IsTokenIdReuse check
}
```

**Migration Strategy**:
- Deploy fixed contract version
- For existing NFTs, maintain backward compatibility or implement migration
- Add tests covering collision scenarios with varying symbol lengths

**Test Cases**:
1. Create Protocol A with 9-digit symbol, Protocol B with 10-digit symbol where B's symbol starts with A's
2. Mint under Protocol A with TokenId that would collide with Protocol B
3. Verify Protocol B's mint fails with clear collision error
4. Test with `IsTokenIdReuse = true/false`

### Proof of Concept

**Initial State**:
- NFT Contract deployed and initialized
- NumberMinLength = 9 (initial symbol length)

**Step 1**: Create Protocol A (early protocol, 9-digit number)
```
Symbol generated: "AB100000001" (2 letters + 9 digits)
Protocol A created with IsTokenIdReuse = false
Attacker is added as minter for Protocol A
```

**Step 2**: Create Protocol B (later protocol, 10-digit number after threshold)
```
Symbol generated: "AB1000000012" (2 letters + 10 digits)
Note: "AB1000000012" has "AB100000001" as prefix
Protocol B created with IsTokenIdReuse = true (or false for DoS scenario)
```

**Step 3**: Attacker mints under Protocol A with collision-inducing TokenId
```
Mint(symbol: "AB100000001", tokenId: 23, owner: AttackerAddress)
TokenHash = Hash("AB10000000123")
NFT created and stored at State.NftInfoMap[Hash("AB10000000123")]
```

**Step 4**: Legitimate user attempts mint under Protocol B
```
Mint(symbol: "AB1000000012", tokenId: 3, owner: UserAddress)
TokenHash = Hash("AB10000000123")  ← SAME HASH

If IsTokenIdReuse = false:
  → Transaction fails: "Token id 3 already exists"
  → DoS: User cannot mint legitimate NFT

If IsTokenIdReuse = true:
  → Loads Protocol A's NFT data
  → Adds UserAddress's balance to shared tokenHash
  → Corrupts Protocol A's NFT with Protocol B's mint data
  → Data corruption: Mixed protocol metadata and ownership
```

**Success Condition**: 
- With `IsTokenIdReuse = false`: Protocol B's mint transaction reverts
- With `IsTokenIdReuse = true`: Protocol A's NFT data is modified to include Protocol B's mint, corrupting ownership and quantity data

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L392-396)
```csharp
        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L433-441)
```csharp
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }

        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L87-116)
```csharp
    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```
