### Title
Term Change Bypassed When Miners with Null OutValue Use UpdateValue Behavior

### Summary
The consensus command generation logic incorrectly returns `UpdateValue` behavior for miners who haven't mined in the current round (OutValue == null) even when a term change is due. This bypasses the term transition mechanism, causing delayed treasury releases, stale election snapshots, and incorrect miner state management.

### Finding Description
**Root Cause Location:** [1](#0-0) 

The vulnerability exists in `GetConsensusBehaviour()` method. When a miner's `OutValue == null` (indicating they haven't mined in the current round), the code calls `HandleMinerInNewRound()` at line 51: [2](#0-1) 

The `HandleMinerInNewRound()` method returns `UpdateValue` at line 114 if the miner's time slot hasn't passed (`!_isTimeSlotPassed`), without checking whether a term change is needed.

The critical issue is that when line 55 returns early (behaviour != Nothing), the code never reaches line 82 where `GetConsensusBehaviourToTerminateCurrentRound()` would check `NeedToChangeTerm()`: [3](#0-2) 

This causes `NormalBlockCommandStrategy` to be instantiated with `UpdateValue` behavior: [4](#0-3) 

Which generates a consensus command with `Behaviour = UpdateValue`: [5](#0-4) 

**Why Existing Protections Fail:**

The validation logic only verifies that the chosen behavior is internally consistent, not whether the correct behavior was chosen. When `UpdateValue` is provided, the validator checks UpdateValue-specific constraints but doesn't verify if `NextTerm` should have been used instead: [6](#0-5) 

The term change check via `NeedToChangeTerm()`: [7](#0-6) 

is only invoked when `GetConsensusBehaviourToTerminateCurrentRound()` is called, which never happens for miners with `OutValue == null` in their time slot.

### Impact Explanation
**Consensus State Inconsistency:**
When a miner with `OutValue == null` produces a block using `UpdateValue` behavior instead of `NextTerm`, `ProcessUpdateValue()` executes: [8](#0-7) 

This updates the current round but doesn't trigger term transition. The correct behavior should invoke `ProcessNextTerm()`: [9](#0-8) 

**Specific Harms:**

1. **Treasury Release Delayed**: Line 205-208 in `ProcessNextTerm()` calls `State.TreasuryContract.Release.Send()` - this doesn't execute, delaying reward distributions to stakeholders.

2. **Election Snapshot Stale**: Line 213-218 takes election snapshots with `State.ElectionContract.TakeSnapshot.Send()` - without this, election state becomes inconsistent with actual blockchain state.

3. **Miner Statistics Not Reset**: Lines 179-183 reset `MissedTimeSlots` and `ProducedBlocks` for new term - these remain stale, affecting miner performance tracking.

4. **Miner List Not Updated**: Lines 188-190 update the miner list for the new term from election results - the old miner set persists incorrectly.

5. **Term Number Not Incremented**: Line 173 updates term number - it remains stale, breaking all term-dependent logic.

**Affected Parties:**
- Voters/stakeholders expecting treasury distributions
- Election contract with stale snapshots
- Miners with incorrect statistics and outdated miner lists
- Treasury contract with pending releases

### Likelihood Explanation
**Attack Vector**: Natural Occurrence (No Attacker Required)

This vulnerability triggers automatically under normal consensus operation when:
1. Two-thirds of miners have `ActualMiningTimes` meeting the term change threshold (determined by `NeedToChangeTerm()`)
2. A miner who hasn't produced blocks in the current round (OutValue == null) is next in the mining rotation
3. The current block time is within that miner's time slot

**Probability**: HIGH

In a typical scenario with 5 miners (A, B, C, D, E) where term change is due:
- If miners A and B have `OutValue == null` in the new round, they'll both use `UpdateValue` incorrectly
- Only when a miner with `OutValue != null` reaches line 82 will term change be triggered
- With 21 production nodes (common in AEDPoS), multiple blocks could be produced with wrong behavior before correction

**Feasibility**: 
- Entry point is public: `GetConsensusCommand()` RPC method
- No special permissions required
- Occurs during normal block production flow
- No economic cost to trigger (happens naturally)

**Detection**: Difficult - the blockchain continues operating normally, but term-dependent operations are silently delayed without obvious errors.

### Recommendation
**Code-Level Fix:**

Modify `ConsensusBehaviourProviderBase.GetConsensusBehaviour()` to check for term/round termination before returning from `HandleMinerInNewRound()`:

```csharp
public AElfConsensusBehaviour GetConsensusBehaviour()
{
    // First, check if round/term should terminate regardless of miner state
    var terminateBehaviour = GetConsensusBehaviourToTerminateCurrentRound();
    if (terminateBehaviour != AElfConsensusBehaviour.UpdateValue)
    {
        return terminateBehaviour; // NextRound or NextTerm takes precedence
    }

    // Then handle miner-specific logic
    if (_minerInRound.OutValue == null)
    {
        var behaviour = HandleMinerInNewRound();
        if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
    }
    else if (!_isTimeSlotPassed)
    {
        // ... existing tiny block logic ...
    }

    return terminateBehaviour; // Return UpdateValue or termination behavior
}
```

**Invariant to Enforce:**
Add validation to check that when `NeedToChangeTerm()` returns true, only `NextTerm` or `NextRound` behaviors are allowed (not `UpdateValue` or `TinyBlock`).

**Test Cases:**
1. Create test where term change threshold is met with miner having `OutValue == null`
2. Verify `NextTerm` behavior is returned, not `UpdateValue`
3. Verify `ProcessNextTerm()` executes and treasury releases, election snapshots occur
4. Test with multiple sequential miners having `OutValue == null` to ensure first miner triggers term change

### Proof of Concept
**Initial State:**
- Blockchain running for 7+ days (PeriodSeconds = 604800)
- Current term: 1, current round: 50
- Term change threshold met: 2/3+ miners have `ActualMiningTimes` satisfying `IsTimeToChangeTerm()`
- Round has 5 miners: A, B, C, D, E
- Miner A has `OutValue == null` (hasn't mined in round 50 yet)
- Current time is within Miner A's time slot

**Execution Steps:**
1. Miner A calls `GetConsensusCommand()` via normal block production
2. `MainChainConsensusBehaviourProvider.GetConsensusBehaviour()` invoked
3. Check at line 49: `_minerInRound.OutValue == null` â†’ TRUE
4. `HandleMinerInNewRound()` called at line 51
5. Returns `UpdateValue` at line 114 (time slot not passed)
6. `GetConsensusCommand(UpdateValue, ...)` creates `NormalBlockCommandStrategy`
7. Block produced with `UpdateValue` behavior
8. `ProcessUpdateValue()` executes, updating round but not term

**Expected Result:**
- Behavior should be `NextTerm`
- `ProcessNextTerm()` should execute
- Term number incremented to 2
- Treasury release for term 1
- Election snapshot taken
- Miner list updated

**Actual Result:**
- Behavior is `UpdateValue`
- `ProcessUpdateValue()` executes
- Term number remains 1
- No treasury release
- No election snapshot
- Miner list not updated
- Term transition bypassed

**Success Condition:** 
Verify by checking `State.CurrentTermNumber.Value` remains 1 after block, and `State.TreasuryContract.Release` was not called (check event logs for missing `ReleaseInput` transaction).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L92-115)
```csharp
        private AElfConsensusBehaviour HandleMinerInNewRound()
        {
            if (
                // For first round, the expected mining time is incorrect (due to configuration),
                CurrentRound.RoundNumber == 1 &&
                // so we'd better prevent miners' ain't first order (meanwhile he isn't boot miner) from mining fork blocks
                _minerInRound.Order != 1 &&
                // by postpone their mining time
                CurrentRound.FirstMiner().OutValue == null
            )
                return AElfConsensusBehaviour.NextRound;

            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;

            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L34-37)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                TryToGetPreviousRoundInformation(out var previousRound);
                return new ConsensusCommandProvider(new NormalBlockCommandStrategy(currentRound, pubkey,
                    currentBlockTime, previousRound.RoundId)).GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L23-41)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeNormalBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);

            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                {
                    Behaviour = AElfConsensusBehaviour.UpdateValue,
                    RoundId = CurrentRound.RoundId,
                    PreviousRoundId = _previousRoundId
                }.ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                // Cancel mining after time slot of current miner because of the task queue.
                MiningDueTime = CurrentRound.GetExpectedMiningTime(Pubkey).AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```
