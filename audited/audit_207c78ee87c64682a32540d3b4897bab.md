# Audit Report

## Title
Inconsistent Vote Counting After Member Replacement Allows Governance Threshold Bypass

## Summary
The Association contract's `ChangeMember()` function fails to invalidate votes from removed members on active proposals. Due to inconsistent vote counting logic in threshold verification, removed members' votes still count toward `MinimalVoteThreshold` while being excluded from approval/rejection/abstention counts, enabling proposals to pass with fewer current members participating than governance rules require.

## Finding Description

The vulnerability stems from the interaction between member replacement and vote threshold validation in the Association contract.

When `ChangeMember()` is called, it removes the old member from the organization's member list and adds the new member, but does NOT clear any votes the old member cast on active proposals. [1](#0-0) 

The vote lists (`approvals`, `rejections`, `abstentions`) in `ProposalInfo` are defined as repeated address fields that persist independently of the organization member list. [2](#0-1) 

During proposal release verification via `IsReleaseThresholdReached()`, the system employs inconsistent counting logic:

**For approval threshold checking (FILTERED by current membership):**
The approval count uses `.Count(organization.OrganizationMemberList.Contains)` which filters out votes from removed members. [3](#0-2) 

**For rejection threshold checking (FILTERED by current membership):**
The rejection count also uses `.Count(organization.OrganizationMemberList.Contains)`. [4](#0-3) 

**For abstention threshold checking (FILTERED by current membership):**
The abstention count also uses `.Count(organization.OrganizationMemberList.Contains)`. [5](#0-4) 

**For total vote threshold checking (UNFILTERED - THE VULNERABILITY):**
The total vote count concatenates all vote lists and counts without membership filtering, meaning removed members' votes still count toward `MinimalVoteThreshold`. [6](#0-5) 

This inconsistency violates the governance invariant that requires a minimum number of **current** organization members to participate in voting before a proposal can be released.

## Impact Explanation

**Severity: HIGH**

This vulnerability directly undermines the Association governance mechanism by allowing proposals to pass without the required level of current member participation. 

**Concrete Attack Scenario:**
1. Organization configured with `MinimalVoteThreshold = 7` and `MinimalApprovalThreshold = 5`
2. A proposal is created requiring both thresholds to be met
3. 5 current members approve the proposal
4. 2 members vote (abstain or reject - doesn't matter which)
5. Those 2 members are replaced via `ChangeMember()` proposals
6. The proposal now passes because:
   - `approvalCount` = 5 (only current members) ≥ 5 ✓
   - `totalVoteCount` = 7 (includes removed members) ≥ 7 ✓
   - Only 5 current members participated, violating the 7-member participation requirement

**Who is affected:**
- All Association-based governance organizations
- Particularly critical for organizations with member rotation policies
- High-value organizations controlling funds, configuration, or system parameters

**Potential consequences:**
- Unauthorized proposal releases with insufficient current member oversight
- Governance threshold requirements effectively lowered below configured values
- Malicious coalitions can strategically replace members to manipulate vote counts
- Legitimate member rotation inadvertently enables premature proposal releases

## Likelihood Explanation

**Likelihood: HIGH**

**Required Capabilities:**
`ChangeMember()` requires `Context.Sender` to be the organization address itself, meaning it can only be executed via a governance proposal. [7](#0-6) 

**Attack Path:**
1. Coalition controls enough votes to pass `ChangeMember()` proposals
2. Target proposal is created and members vote on it
3. Coalition passes `ChangeMember()` proposals to replace members who already voted
4. Target proposal now meets thresholds with fewer current members

**Feasibility Factors:**
- **Intentional Exploit**: A malicious coalition with majority control can deliberately orchestrate member replacement to manipulate vote counts
- **Unintentional Trigger**: Routine member rotation during active proposals naturally triggers this vulnerability without malicious intent
- **Detection Difficulty**: The inconsistency is not visible in events or easily queryable state
- **No Special Privileges**: Only requires normal governance participation rights
- **Low Cost**: Only transaction fees for governance proposals

**Realistic Scenarios:**
- Organizations with scheduled member rotations (term limits, role changes)
- Emergency member replacements due to compromised keys
- Natural member turnover in DAOs
- Strategic manipulation by majority coalitions

## Recommendation

**Fix the inconsistent vote counting by filtering the total vote count by current membership:**

In `contract/AElf.Contracts.Association/Association_Helper.cs`, modify the `CheckEnoughVoteAndApprovals()` method to filter all vote counts by current organization membership:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter total vote count by current membership
    var totalCurrentMemberVotes = 
        proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
        proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
        proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
    
    var isVoteThresholdReached =
        totalCurrentMemberVotes >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

**Alternative Solution**: Clear votes from removed members during `ChangeMember()`, `RemoveMember()`, and `AddMember()` operations by iterating through active proposals, though this is more gas-intensive.

## Proof of Concept

```csharp
[Fact]
public async Task Vulnerability_ChangeMember_VoteCountingInconsistency()
{
    // Setup: Organization with 7 members, requiring 7 votes and 5 approvals
    var minimalApprovalThreshold = 5;
    var minimalVoteThreshold = 7;
    var organizationAddress = await CreateOrganizationAsync(
        minimalApprovalThreshold, 
        minimalVoteThreshold,
        0, 0, Reviewer1);

    // Create a proposal
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);

    // 5 current members approve
    await ApproveAsync(Reviewer1KeyPair, proposalId);
    await ApproveAsync(Reviewer2KeyPair, proposalId);
    await ApproveAsync(Reviewer3KeyPair, proposalId);
    // Assume we have Reviewer4 and Reviewer5 as members
    await ApproveAsync(Reviewer4KeyPair, proposalId);
    await ApproveAsync(Reviewer5KeyPair, proposalId);

    // 2 members abstain
    await AbstainAsync(Reviewer6KeyPair, proposalId);
    await AbstainAsync(Reviewer7KeyPair, proposalId);

    // Verify proposal can be released (7 total votes, 5 approvals)
    var proposal1 = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal1.ToBeReleased.ShouldBeTrue();

    // Now replace the 2 members who abstained via ChangeMember
    var changeMemberProposal1 = await CreateChangeMemberProposal(organizationAddress, Reviewer6, NewMember1);
    await PassProposal(changeMemberProposal1);
    
    var changeMemberProposal2 = await CreateChangeMemberProposal(organizationAddress, Reviewer7, NewMember2);
    await PassProposal(changeMemberProposal2);

    // VULNERABILITY: Proposal still shows ToBeReleased = true
    // Even though only 5 CURRENT members participated
    // The 2 removed members' votes still count toward MinimalVoteThreshold
    var proposal2 = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal2.ToBeReleased.ShouldBeTrue(); // Still true! Only 5 current members voted
    proposal2.ApprovalCount.ShouldBe(5); // Correct: filtered by current membership
    
    // The total vote count (approval + rejection + abstention) should be 5
    // but the contract counts 7 because removed members' votes still count
    // This allows Release() to succeed
    var releaseResult = await GetAssociationContractTester(Reviewer1KeyPair)
        .Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // EXPECTED: Release should FAIL because only 5 current members voted (< 7 required)
    // ACTUAL: Release SUCCEEDS because removed members' votes count toward threshold
}
```

---

## Notes

This vulnerability demonstrates a critical flaw in the Association contract's vote accounting logic where the same data (vote lists) is counted differently depending on which threshold is being checked. The filtering by current membership is correctly applied to approval/rejection/abstention thresholds but incorrectly omitted from the total vote threshold check. This creates an exploitable inconsistency that undermines the governance participation requirements.

The issue affects all Association organizations and can be triggered both intentionally by malicious actors and unintentionally through routine member management operations during active proposals.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L248-264)
```csharp
    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
    }
```

**File:** protobuf/association_contract.proto (L76-96)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-53)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-58)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
```
