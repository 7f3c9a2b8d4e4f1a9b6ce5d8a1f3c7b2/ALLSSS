### Title
Fee Truncation Vulnerability Allows Complete Fee Avoidance Through Transaction Splitting

### Summary
The TokenConverter contract's `Buy()` and `Sell()` functions calculate fees using `Convert.ToInt64()` which truncates decimal values toward zero. [1](#0-0)  This allows users to completely avoid paying fees by splitting large transactions into many small ones where the calculated fee rounds down to zero, undermining the protocol's fee collection mechanism that funds Treasury donations and token burns.

### Finding Description

The vulnerability exists in two locations where transaction fees are calculated:

1. **Buy() function**: Fee calculation at line 124 uses `var fee = Convert.ToInt64(amountToPay * GetFeeRate());` [2](#0-1) 

2. **Sell() function**: Identical fee calculation pattern at line 174 [3](#0-2) 

**Root Cause**: C#'s `Convert.ToInt64()` truncates decimal values toward zero. When `amountToPay * GetFeeRate()` produces a value less than 1.0, the result is 0. The fee rate is stored as a decimal between 0 and 1 [4](#0-3) , and parsed back as decimal for calculations [5](#0-4) .

**Why Protections Fail**: The contract has no minimum transaction amount enforcement. The only limit check is `PayLimit` which serves as a maximum cost protection for buyers, not a minimum [6](#0-5) .

**Fee Handling**: Collected fees are split equally - half donated to Treasury and half burned [7](#0-6) . When fees are avoided, both mechanisms receive nothing.

### Impact Explanation

**Direct Financial Impact**: 
- Users can completely avoid paying fees on any size transaction by strategic splitting
- With a typical fee rate of 0.005 (0.5%) as shown in tests [8](#0-7) , any transaction where `amountToPay < 200` pays zero fee
- For a 10,000 token transaction: single transaction pays 50 tokens fee, but 51 transactions of ~196 tokens each pay 0 total fee - **100% fee avoidance**

**Protocol Damage**:
- Treasury loses donation revenue that funds dividends and protocol operations
- Token burn mechanism fails to reduce supply, affecting tokenomics
- Unfair advantage to sophisticated users who automate transaction splitting
- Economic model assumes fee collection for sustainability

**Affected Parties**:
- Protocol/Treasury: Direct revenue loss
- Honest users: Subsidizing those who avoid fees
- Token holders: Reduced burn rate affects supply dynamics

**Severity Justification (Medium)**:
- Direct, quantifiable financial loss
- Does not compromise token security or consensus
- Requires user effort but easily automatable
- Impact scales with transaction volume
- Undermines but doesn't break core protocol functionality

### Likelihood Explanation

**Attacker Capabilities**: Any user with tokens to trade can exploit this - no special permissions needed.

**Attack Complexity**: Trivial to execute:
1. Calculate truncation threshold: `threshold = ceil(1 / feeRate)` (e.g., 200 for 0.5% fee)
2. Split desired amount into transactions below threshold
3. Execute multiple Buy/Sell calls

**Feasibility Conditions**: 
- Always feasible for any transaction size
- Gas costs for multiple transactions typically far lower than fee savings on large amounts
- Can be fully automated with a simple script

**Economic Rationality**: 
- For 10,000 token transaction with 0.5% fee: save 50 tokens, pay ~5-10 transactions worth of gas
- Break-even at relatively small transaction sizes
- Highly profitable for larger transactions
- Arbitrage bots and sophisticated traders will systematically exploit this

**Detection/Operational Constraints**: 
- Difficult to distinguish from legitimate small transactions
- No on-chain mechanism to detect or prevent the pattern
- Protocol has no recourse once transactions are executed

**Probability**: **High** - The exploit is simple, profitable, and has no effective countermeasures in place.

### Recommendation

**Immediate Fix** - Implement proper fee rounding that prevents truncation loss:

```csharp
// In Buy() function, replace line 124:
var feeDecimal = amountToPay * GetFeeRate();
var fee = (long)Math.Ceiling(feeDecimal); // Always round UP

// In Sell() function, replace line 174 similarly
var feeDecimal = amountToReceive * GetFeeRate();
var fee = (long)Math.Ceiling(feeDecimal);
```

**Alternative Approach** - Implement minimum transaction amounts:

```csharp
// Add validation after fee calculation:
var minTransactionAmount = (long)Math.Ceiling(1 / GetFeeRate());
Assert(amountToPay >= minTransactionAmount, "Transaction amount too small");
```

**Invariant Checks**:
- Fee must be > 0 when feeRate > 0 and transaction amount > 0
- Total fees collected should track within expected range based on volume

**Test Cases**:
1. Test transaction at truncation boundary (e.g., amountToPay = 199 with 0.5% fee should pay fee = 1)
2. Test multiple small transactions vs one large transaction - fees should be comparable
3. Test with various fee rates to ensure rounding works correctly
4. Add integration test that verifies Treasury receives expected fees over multiple transactions

### Proof of Concept

**Initial State**:
- Fee rate set to 0.005 (0.5%)
- User wants to buy tokens requiring 10,000 base tokens
- User has sufficient balance and approvals

**Attack Sequence**:

1. **Calculate Truncation Threshold**: 
   - For fee ≥ 1: need `amountToPay * 0.005 ≥ 1`
   - Threshold: `amountToPay ≥ 200`
   - Safe amount per transaction: 199

2. **Execute Multiple Small Buys**:
   - Transaction 1: Buy tokens costing 199 base tokens → fee = `Convert.ToInt64(199 * 0.005)` = 0
   - Transaction 2: Buy tokens costing 199 base tokens → fee = 0
   - ...
   - Transaction 51: Buy tokens costing 199 base tokens → fee = 0
   - Total cost: ~10,149 base tokens, Total fees: 0

3. **Compare to Single Large Buy**:
   - Transaction: Buy tokens costing 10,000 base tokens → fee = `Convert.ToInt64(10000 * 0.005)` = 50
   - Total cost: 10,050 base tokens, Total fees: 50

**Expected Result**: Single transaction pays 50 tokens fee to Treasury/burn

**Actual Result**: 51 small transactions pay 0 tokens fee

**Success Condition**: User saves 50 tokens (100% of fees) by transaction splitting, Treasury and burn mechanism receive nothing despite significant trading volume.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L36-38)
```csharp
        var feeRate = AssertedDecimal(input.FeeRate);
        Assert(IsBetweenZeroAndOne(feeRate), "Fee rate has to be a decimal between 0 and 1.");
        State.FeeRate.Value = feeRate.ToString(CultureInfo.InvariantCulture);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-130)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-184)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L214-258)
```csharp
    private void HandleFee(long fee)
    {
        var donateFee = fee.Div(2);
        var burnFee = fee.Sub(donateFee);

        // Donate 0.5% fees to Treasury
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = donateFee
            });
        if (State.DividendPoolContract.Value == null)
            State.DividendPoolContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
        State.TokenContract.Approve.Send(new ApproveInput
        {
            Symbol = State.BaseTokenSymbol.Value,
            Spender = State.DividendPoolContract.Value,
            Amount = donateFee
        });
        State.DividendPoolContract.Donate.Send(new DonateInput
        {
            Symbol = State.BaseTokenSymbol.Value,
            Amount = donateFee
        });

        // Transfer to self contract then burn
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = burnFee
            });
        State.TokenContract.Burn.Send(
            new BurnInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                Amount = burnFee
            });
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L369-372)
```csharp
    private decimal GetFeeRate()
    {
        return decimal.Parse(State.FeeRate.Value);
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConverterContractTests.cs (L178-178)
```csharp
        var fee = Convert.ToInt64(amountToPay * 5 / 1000);
```
