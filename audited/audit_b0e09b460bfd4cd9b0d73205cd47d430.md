### Title
Unvalidated Miner Order Manipulation via TuneOrderInformation Allows Consensus Schedule Disruption

### Summary
Miners can submit arbitrary `TuneOrderInformation` values during `UpdateValue` that directly modify other miners' `FinalOrderOfNextRound` without validation. This allows malicious miners to set invalid order values (zero, negative, or exceeding miner count) or duplicate orders, causing mining time slot manipulation and potential consensus disruption in the next round.

### Finding Description

The vulnerability exists in the consensus order determination mechanism across multiple files:

**Root Cause:** In `ProcessUpdateValue`, the `TuneOrderInformation` dictionary is applied without any validation: [1](#0-0) 

Any miner can call the public `UpdateValue` method: [2](#0-1) 

The only authorization check is that the caller must be in the current or previous miner list: [3](#0-2) 

The `UpdateValueValidationProvider` only validates consensus data presence and previous in-values, but NOT the `TuneOrderInformation` content: [4](#0-3) 

When the next round is generated, these unvalidated `FinalOrderOfNextRound` values are directly used to set mining orders and time slots: [5](#0-4) 

The `NextRoundMiningOrderValidationProvider` only checks count equality, not value validity or uniqueness: [6](#0-5) 

The `CheckRoundTimeSlots` validation only verifies time interval consistency, not order value bounds: [7](#0-6) 

**Why Protections Fail:** There is no validation that `TuneOrderInformation` values are within [1, minerCount], unique, or sensible. The protobuf definition shows it's simply a map with no constraints: [8](#0-7) 

### Impact Explanation

**Consensus Schedule Manipulation:**
- Setting `FinalOrderOfNextRound = 0` causes `ExpectedMiningTime = currentBlockTime`, allowing immediate mining out of turn
- Setting negative values causes past timestamps, enabling time slot violations
- Setting very large values (e.g., 1000000) makes affected miners unable to mine as their slots are unreachably far in the future

**Denial of Service:**
- Setting duplicate order values for multiple miners creates time slot conflicts and can break the `ableOrders` calculation logic in round generation
- If all miners who mined are assigned the same `FinalOrderOfNextRound`, the round generation may fail or produce invalid schedules

**Severity:** High - This directly violates the "Correct round transitions and time-slot validation, miner schedule integrity" critical invariant. Malicious miners can manipulate who mines when, potentially controlling block production or preventing specific miners from participating.

### Likelihood Explanation

**Attacker Capabilities:** Any active miner can execute this attack during their legitimate mining slot when calling `UpdateValue`.

**Attack Complexity:** Low - The attacker simply needs to include a `TuneOrderInformation` dictionary in their `UpdateValueInput` with arbitrary order values for target miners.

**Feasibility:** Very High - The attack requires:
1. Being an active miner (normal operational requirement)
2. Submitting `UpdateValue` with custom `TuneOrderInformation` (no additional permissions needed)
3. No economic cost beyond normal mining operations

**Detection:** Difficult to detect proactively since `TuneOrderInformation` is a legitimate feature intended for order conflict resolution. The malicious use only becomes apparent when the next round starts with invalid schedules.

### Recommendation

**Immediate Fix:** Add validation in `ProcessUpdateValue` before applying `TuneOrderInformation`:

```csharp
// In ProcessUpdateValue, before line 259
var minersCount = currentRound.RealTimeMinersInformation.Count;
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    // Validate miner exists
    Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key), 
        $"Invalid miner pubkey in TuneOrderInformation: {tuneOrder.Key}");
    
    // Validate order is in valid range [1, minersCount]
    Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount,
        $"Invalid order value {tuneOrder.Value}, must be between 1 and {minersCount}");
    
    // Validate no duplicate orders (check if another miner already has this order)
    var existingMinerWithOrder = currentRound.RealTimeMinersInformation.Values
        .FirstOrDefault(m => m.Pubkey != tuneOrder.Key && m.FinalOrderOfNextRound == tuneOrder.Value);
    Assert(existingMinerWithOrder == null,
        $"Order {tuneOrder.Value} already assigned to miner {existingMinerWithOrder?.Pubkey}");
    
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}
```

**Additional Enhancement:** Add validation in `NextRoundMiningOrderValidationProvider` to verify order values are within bounds and unique.

**Test Cases:** Create tests for:
- Rejecting TuneOrderInformation with values < 1 or > minerCount
- Rejecting duplicate order assignments
- Rejecting orders for non-existent miners

### Proof of Concept

**Initial State:**
- 5 active miners: M1, M2, M3, M4, M5
- Current round in progress with normal mining schedule

**Attack Steps:**
1. M1's mining time slot arrives
2. M1 calls `UpdateValue` with legitimate consensus data but includes malicious `TuneOrderInformation`:
   ```
   TuneOrderInformation = {
     "M2_pubkey": 0,           // Will mine immediately in next round
     "M3_pubkey": 1000000,     // Effectively banned from mining
     "M4_pubkey": 1            // Same order as M1 will have
   }
   ```
3. `ProcessUpdateValue` executes without validation, directly updating:
   - M2.FinalOrderOfNextRound = 0
   - M3.FinalOrderOfNextRound = 1000000  
   - M4.FinalOrderOfNextRound = 1

4. When extra block producer generates next round via `GenerateNextRoundInformation`:
   - M2 gets Order=0, ExpectedMiningTime=currentTime (mines immediately)
   - M3 gets Order=1000000, ExpectedMiningTime far in future (can't mine)
   - M4 gets Order=1, potentially same as another miner (schedule conflict)

5. All validations pass because they only check count equality, not value validity

**Expected Result:** Transaction should revert with validation error

**Actual Result:** Transaction succeeds, next round has manipulated mining schedule with M2 able to mine out of turn and M3 effectively unable to participate

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```
