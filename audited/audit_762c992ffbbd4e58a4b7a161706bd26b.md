# Audit Report

## Title
Missing Delegation State Paths in ACS2 Resource Declaration Allows Parallel Execution Race Condition

## Summary
The `AddPathForDelegatees` function in the MultiToken contract's ACS2 implementation fails to declare `TransactionFeeDelegateInfoMap` and `TransactionFeeDelegateesMap` state paths in WritePaths or ReadPaths. These state variables are read during resource info collection and written during transaction fee charging, but their omission from the declared paths allows the parallel execution engine to incorrectly execute conflicting transactions concurrently, enabling delegation allowance over-spending through race conditions.

## Finding Description
AElf's ACS2 (parallel execution standard) requires contracts to declare all state paths they will read or write in the `GetResourceInfo` method. The parallel execution engine uses these declarations to group transactions: those with overlapping paths execute sequentially, while those without overlap can execute in parallel.

The vulnerability exists in the delegation fee payment flow:

**During Resource Info Collection (Pre-execution):**
The `AddPathForDelegatees` function is called to declare state paths for delegatee transactions. [1](#0-0) 

This function calls `GetDelegateeList` which reads from the delegation state maps. [2](#0-1) 

However, `AddPathForDelegatees` only adds paths for delegatee balances and allowances—it never declares the delegation maps themselves as ReadPaths or WritePaths.

**During Actual Execution:**
When charging fees from delegations with limited allowances, the `ModifyDelegation` function is invoked. [3](#0-2) 

This function directly modifies the delegation state maps by decrementing the allowance. [4](#0-3) 

The state variables being accessed are defined as: [5](#0-4) 

**Parallel Execution Decision:**
The parallel execution engine groups transactions based on their declared paths. [6](#0-5) 

Since the delegation map paths are never declared, two transactions from the same delegator using the same delegatee will have no overlapping state path declarations, causing them to be placed in different parallel execution groups.

## Impact Explanation
This vulnerability breaks the delegation allowance tracking invariant, allowing multiple impacts:

1. **Delegation Allowance Over-spending**: If a delegatee has a 100 ELF delegation allowance, two parallel transactions each requiring 60 ELF could both successfully charge from the delegation (total 120 ELF), exceeding the authorized limit. The delegator intended to limit delegatee fee coverage to 100 ELF, but the race condition allows overspending.

2. **State Corruption**: Concurrent write operations to the same delegation allowance field create a classic race condition. The final state depends on execution order and may be incorrect (neither properly decremented nor properly reflecting the total fees charged).

3. **Unauthorized Fee Payment**: Users can exploit this to receive more transaction fee coverage from delegatees than they authorized, effectively stealing fee payment services.

The severity is Medium (not High) because:
- Impact is limited to delegation tracking, not direct token balance theft
- Requires specific conditions (limited delegation, concurrent transactions)
- Delegatees can monitor and remove delegation to mitigate
- The overspending is bounded by transaction timing windows

However, it represents a clear state integrity violation and authorization bypass.

## Likelihood Explanation
The exploitability is Medium because:

**Preconditions (All Achievable):**
- Parallel execution must be enabled (it is—this is ACS2's purpose)
- Delegator must use limited delegation rather than unlimited (common for risk management)
- Multiple transactions must be submitted within the same block or close timing (achievable by any user)

**Attack Complexity: Low**
A delegator can simply:
1. Set up limited delegation (normal contract operation)
2. Submit multiple transactions rapidly to the network
3. The parallel execution engine automatically processes them concurrently
4. No special tools or knowledge required beyond normal transaction submission

**Detection: Difficult**
The issue manifests as normal transaction execution. Only detailed delegation allowance auditing comparing authorized vs. actual spending would reveal the over-spending, and even then it might appear as legitimate usage without understanding the race condition.

**Reproducibility: High**
Under the right conditions (limited delegation + concurrent transactions), this will reliably occur due to the deterministic parallel execution logic.

## Recommendation
Add the delegation state map paths to the ResourceInfo in `AddPathForDelegatees`:

```csharp
private void AddPathForDelegatees(ResourceInfo resourceInfo, Address from, Address to, string methodName)
{
    var delegateeList = new List<string>();
    
    // Declare delegation map paths as WritePaths since they may be modified
    resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.TransactionFeeDelegateInfoMap), 
        from.ToBase58(), to.ToBase58(), methodName));
    resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.TransactionFeeDelegateesMap), 
        from.ToBase58()));
    
    // ... rest of existing logic
}
```

This ensures the parallel execution engine recognizes that transactions modifying the same delegation state must execute sequentially, preventing the race condition.

## Proof of Concept
```csharp
[Fact]
public async Task DelegationAllowanceOverspending_ParallelExecutionRaceCondition()
{
    // Setup: Delegator authorizes delegatee with 100 ELF limited delegation
    await SetupLimitedDelegation(delegatorAddress, delegateeAddress, 100_00000000);
    
    // Create two transactions that each require 60 ELF in fees
    var tx1 = CreateTransferTransaction(delegatorAddress, 60_00000000);
    var tx2 = CreateTransferTransaction(delegatorAddress, 60_00000000);
    
    // Submit both transactions simultaneously
    var results = await ExecuteTransactionsInParallel(new[] { tx1, tx2 });
    
    // Both transactions succeed despite exceeding the 100 ELF limit
    Assert.True(results[0].Success);
    Assert.True(results[1].Success);
    
    // Verify overspending: 60 + 60 = 120 ELF charged, but only 100 ELF authorized
    var remainingAllowance = await GetDelegationAllowance(delegatorAddress, delegateeAddress);
    Assert.True(remainingAllowance < 0 || remainingAllowance != 40_00000000); // Expected 40, but corrupted
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L113-132)
```csharp
    private void AddPathForDelegatees(ResourceInfo resourceInfo, Address from, Address to, string methodName)
    {
        var delegateeList = new List<string>();
        //get and add first-level delegatee list
        delegateeList.AddRange(GetDelegateeList(from, to, methodName));
        if (delegateeList.Count <= 0) return;
        var secondDelegateeList = new List<string>();
        //get and add second-level delegatee list
        foreach (var delegateeAddress in delegateeList.Select(a => Address.FromBase58(a)))
        {
            //delegatee of the first-level delegate is delegator of the second-level delegate
            secondDelegateeList.AddRange(GetDelegateeList(delegateeAddress, to, methodName));
        }
        delegateeList.AddRange(secondDelegateeList);
        foreach (var delegatee in delegateeList.Distinct())
        {
            AddPathForTransactionFee(resourceInfo, delegatee, methodName);
            AddPathForTransactionFeeFreeAllowance(resourceInfo, Address.FromBase58(delegatee));
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L134-146)
```csharp
    private List<string> GetDelegateeList(Address delegator, Address to, string methodName)
    {
        var delegateeList = new List<string>();
        var allDelegatees = State.TransactionFeeDelegateInfoMap[delegator][to][methodName] 
                            ?? State.TransactionFeeDelegateesMap[delegator];
            
        if (allDelegatees != null)
        {
            delegateeList.AddRange(allDelegatees.Delegatees.Keys.ToList());
        } 

        return delegateeList;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L200-204)
```csharp
            if (!delegations.IsUnlimitedDelegate)
            {
                ModifyDelegation(delegateeBill, delegateeAllowanceBill, fromAddress, input.ContractAddress,
                    input.MethodName, delegatorAddress);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L212-235)
```csharp
    private void ModifyDelegation(TransactionFeeBill bill, TransactionFreeFeeAllowanceBill allowanceBill,
        Address delegateeAddress, Address contractAddress, string methodName, Address delegatorAddress)
    {
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            var delegateInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][contractAddress][methodName] ??
                State.TransactionFeeDelegateesMap[delegatorAddress];
            delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol] =
                delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol].Sub(amount);
        }

        foreach (var (symbol, amount) in allowanceBill.FreeFeeAllowancesMap)
        {
            if (amount <= 0) continue;

            var delegateInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][contractAddress][methodName] ??
                State.TransactionFeeDelegateesMap[delegatorAddress];
            delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol] =
                delegateInfo.Delegatees[delegateeAddress.ToBase58()].Delegations[symbol].Sub(amount);
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L64-69)
```csharp
    public MappedState<Address, TransactionFeeDelegatees> TransactionFeeDelegateesMap { get; set; }
    
    /// <summary>
    /// delegator address -> contract address -> method name -> delegatee info
    /// </summary>
    public MappedState<Address, Address, string, TransactionFeeDelegatees> TransactionFeeDelegateInfoMap { get; set; }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/TransactionGrouper.cs (L128-130)
```csharp
            foreach (var resource in transactionResourceInfo.WritePaths.Concat(transactionResourceInfo.ReadPaths)
                         .Where(p => !readOnlyPaths.Contains(p))
                         .Select(p => p.GetHashCode()))
```
