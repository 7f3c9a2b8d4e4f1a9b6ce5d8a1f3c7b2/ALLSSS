### Title
Cross-Term Secret Sharing Corruption in NextRound Consensus Behavior

### Summary
The `RevealSharedInValues` function is called during `NextRound` consensus behavior without validating that `currentRound` and `previousRound` belong to the same term. When a term change occurs and miner lists differ, the function uses secret sharing data from the old term with parameters calculated from the new term, causing threshold mismatches that corrupt `PreviousInValue` fields and subsequent consensus signatures.

### Finding Description

**Exact Code Locations:**
- Vulnerable call site: [1](#0-0) 
- Missing validation: [2](#0-1) 

**Root Cause:**
In `GetConsensusExtraDataForNextRound`, `RevealSharedInValues(currentRound, pubkey)` is called without checking whether `currentRound` is the first round of a new term. Inside `RevealSharedInValues`, it retrieves `previousRound` via [3](#0-2) , which simply gets the previous round by number without term validation.

**Threshold Parameter Mismatch:**
The function calculates parameters from the NEW term's miner count: [4](#0-3) 

But uses encrypted/decrypted pieces from the OLD term: [5](#0-4) 

The validation at line 36 checks `DecryptedPieces.Count < minersCount` where `minersCount` is from the new term, but the pieces were generated for the old term's miner count. This creates a threshold mismatch when calling `SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount)`.

**Missing Protection:**
The similar function `GetConsensusExtraDataToPublishOutValue` DOES have proper term validation: [6](#0-5) 

This check uses: [7](#0-6) 

The `IsMinerListJustChanged` flag exists in Round: [8](#0-7) 

And is used by `AddRoundInformation` to skip secret sharing generation for miner list changes: [9](#0-8) 

However, this only prevents NEW secret sharing generation; it does NOT prevent `RevealSharedInValues` from USING old cross-term secret sharing data.

### Impact Explanation

**Consensus Integrity Corruption:**
The incorrectly decoded `PreviousInValue` is stored at: [10](#0-9) 

This corrupted value is then used in signature calculation via: [11](#0-10) 

**Concrete Harms:**
1. **Signature Chain Corruption**: Signatures are XORed with the previousInValue, so incorrect values break the cryptographic chain
2. **Randomness Manipulation**: Signatures are converted to mining orders through deterministic operations, so corrupted signatures affect block producer selection fairness
3. **Consensus Instability**: Multiple miners receiving incorrect previousInValue values can cause consensus divergence

**Who is Affected:**
- All miners present in both the old and new terms
- The entire blockchain network relying on consensus integrity
- Any features depending on consensus-generated randomness

**Severity Justification:**
This is a **Medium-High** severity finding because:
- Directly impacts consensus integrity (critical invariant violation)
- Occurs automatically during periodic term transitions
- No fund theft but corrupts core security properties
- Can lead to unfair block producer selection and compromised randomness

### Likelihood Explanation

**Reachable Entry Point:**
The public method `NextRound` triggers this path: [12](#0-11) 

**Feasible Preconditions:**
1. A term change has occurred via `ProcessNextTerm`: [13](#0-12) 
2. The first round of the new term (with `TermNumber` = N+1) is now current
3. A miner triggers `NextRound` to advance from the first round to the second round of the new term
4. The miner list changed between terms (different sizes or members)

**Execution Practicality:**
- Term changes are periodic and automatic in AEDPoS
- No special attacker privileges required beyond being a miner
- The vulnerability triggers naturally during normal consensus operation
- No complex timing or race conditions needed

**Detection/Operational Constraints:**
- The corruption manifests as incorrect signatures in the consensus round data
- May cause subtle consensus irregularities that are difficult to diagnose
- Affects all nodes processing the block

**Probability:** High - Occurs on every term transition where miner list size changes and NextRound is triggered during the first round of the new term.

### Recommendation

**Add Term Validation Check:**
Modify `GetConsensusExtraDataForNextRound` to include the same term validation as `GetConsensusExtraDataToPublishOutValue`:

```csharp
private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
    string pubkey, AElfConsensusTriggerInformation triggerInformation)
{
    GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

    nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

    if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };

    // ADD THIS CHECK:
    if (!IsFirstRoundOfCurrentTerm(out _))
    {
        RevealSharedInValues(currentRound, pubkey);
    }
    // Rest of the method...
}
```

**Alternative: Check Inside RevealSharedInValues:**
Add validation at the start of `RevealSharedInValues`:

```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    Context.LogDebug(() => "About to reveal shared in values.");

    if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

    if (!TryToGetPreviousRoundInformation(out var previousRound)) return;
    
    // ADD THIS CHECK:
    if (TryToGetTermNumber(out var currentTermNumber) && 
        previousRound.TermNumber != currentTermNumber) return;
    
    // Rest of the method...
}
```

**Test Cases:**
1. Test term transition with miner list size change (increase and decrease)
2. Verify RevealSharedInValues is NOT called when currentRound.TermNumber != previousRound.TermNumber
3. Test that secret sharing continues normally within the same term
4. Verify signatures remain consistent across term boundaries

### Proof of Concept

**Initial State:**
1. System is in Term N with 5 miners at Round R_N (last round of term)
2. Round R_N has completed secret sharing with threshold = 5 * 2 / 3 = 3

**Attack Sequence:**
1. Election occurs, new miner list has 7 miners
2. `NextTerm` is called, creating Round R_{N+1} with `TermNumber = N+1`, `IsMinerListJustChanged = true`
3. Round R_{N+1} is added to state via `AddRoundInformation`, which correctly skips firing `SecretSharingInformation` event due to miner list change
4. Miners produce blocks in Round R_{N+1} (first round of Term N+1)
5. When it's time to advance, a miner calls `NextRound`
6. `GetConsensusBlockExtraData` is called with `Behaviour = NEXT_ROUND`
7. `GetConsensusExtraDataForNextRound` is invoked
8. At line 189, `RevealSharedInValues(currentRound, pubkey)` is called where:
   - `currentRound = Round R_{N+1}` (TermNumber = N+1, 7 miners)
   - Inside function, `previousRound = Round R_N` (TermNumber = N, 5 miners)
9. Function calculates:
   - `minersCount = 7` (from currentRound)
   - `minimumCount = 7 * 2 / 3 = 4` (new threshold)
10. Function checks `DecryptedPieces.Count < 7` (line 36) - may fail for old term data
11. If it passes, calls `SecretSharingHelper.DecodeSecret(sharedParts, orders, 4)` using pieces generated with threshold 3
12. Incorrectly decoded secret is set as `PreviousInValue`
13. Corrupted `PreviousInValue` affects subsequent signature calculations

**Expected vs Actual Result:**
- **Expected**: RevealSharedInValues should not use cross-term secret sharing data
- **Actual**: Function processes cross-term data with mismatched thresholds, corrupting consensus signatures

**Success Condition:**
Examination of the resulting round data shows `PreviousInValue` fields set to values that don't match `Hash(actual_previous_in_value)`, breaking the cryptographic chain.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L72-72)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound) && !IsFirstRoundOfCurrentTerm(out _))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L27-34)
```csharp
    private bool IsFirstRoundOfCurrentTerm(out long termNumber)
    {
        termNumber = 1;
        return (TryToGetTermNumber(out termNumber) &&
                TryToGetPreviousRoundInformation(out var previousRound) &&
                previousRound.TermNumber != termNumber) ||
               (TryToGetRoundNumber(out var roundNumber) && roundNumber == 1);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L56-64)
```csharp
    private bool TryToGetPreviousRoundInformation(out Round previousRound)
    {
        previousRound = new Round();
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        if (roundNumber < 2) return false;
        var targetRoundNumber = roundNumber.Sub(1);
        previousRound = State.Rounds[targetRoundNumber];
        return !previousRound.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L107-115)
```csharp
        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```

**File:** protobuf/aedpos_contract.proto (L261-261)
```text
    bool is_miner_list_just_changed = 9;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```
