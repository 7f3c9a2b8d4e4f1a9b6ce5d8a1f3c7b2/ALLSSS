### Title
Unbounded Response Size in GetElectorVoteWithAllRecords Enables DOS Attack

### Summary
The `GetElectorVoteWithAllRecords()` view method fetches all active and withdrawn voting records for an elector without pagination or size limits, allowing attackers or users with extensive voting history to trigger extremely large response payloads. Since view methods are free to call, this enables a practical DOS attack through repeated queries forcing nodes to process and serialize multi-megabyte responses.

### Finding Description

The vulnerability exists in the `GetElectorVoteWithAllRecords()` method which constructs responses containing all voting records without any bounds checking: [1](#0-0) 

This method calls `GetElectorVoteWithRecords()` to fetch all active records: [2](#0-1) 

Both methods invoke the Vote contract's `GetVotingRecords()` with ALL vote IDs without any pagination: [3](#0-2) 

The Vote contract simply returns all requested records without checking the count or total size.

**Root Cause**: 
- No limit on the number of times a user can vote, so `ActiveVotingRecordIds` accumulates unbounded entries
- When votes are withdrawn, IDs move to `WithdrawnVotingRecordIds` but never removed
- Both lists can grow to thousands of entries over time through normal operation [4](#0-3) [5](#0-4) 

**Why Protections Fail**:
- The 128KB state size limit only applies to state writes, not view method return values
- No pagination mechanism exists for fetching voting records
- No explicit response size validation for view methods beyond the 100MB gRPC limit [6](#0-5) 

### Impact Explanation

**Concrete Harm**:
- **Memory Exhaustion**: Nodes must load and serialize thousands of `ElectionVotingRecord` objects (each ~200+ bytes with addresses, timestamps, amounts, etc.)
- **CPU Exhaustion**: Repeated serialization of large protobuf messages degrades node performance
- **Network Bandwidth**: Multi-megabyte responses consume significant bandwidth
- **Service Degradation**: Legitimate users experience slower response times and potential timeouts

**Quantified Impact**:
- 10,000 voting records × ~200 bytes = ~2MB response (realistic scenario)
- 50,000 voting records × ~200 bytes = ~10MB response (power user scenario)
- Since view methods incur no transaction fees, attackers can repeatedly query without cost

**Who is Affected**:
- All blockchain nodes serving RPC queries
- Users attempting to query their own voting history
- Other API consumers competing for node resources

**Severity Justification**: Medium severity because while the impact is significant (service degradation), it requires either:
1. Time to accumulate many voting records through normal operation, OR
2. Transaction fees to rapidly create many votes (economic cost)

However, once records accumulate, the DOS is trivial to execute and free to repeat.

### Likelihood Explanation

**Attacker Capabilities**:
- Any user can vote multiple times without limit (only capital requirement is locking tokens, which can be reused)
- View methods require no transaction fees to execute
- Multiple accounts can be created to distribute voting records

**Attack Complexity**: Low
1. Vote multiple times over days/weeks (costs only transaction fees, tokens are recoverable)
2. Optionally withdraw votes to populate `WithdrawnVotingRecordIds`
3. Repeatedly call `GetElectorVoteWithAllRecords()` without fees to DOS nodes

**Feasibility Conditions**:
- No special permissions required
- Exploitable through standard RPC interfaces
- Works against all nodes simultaneously

**Economic Rationality**:
- Initial cost: transaction fees for voting (modest)
- Attack cost: Zero (view methods are free)
- Even legitimate users with extensive voting history inadvertently trigger this without malicious intent

**Probability**: High - legitimate power users voting in dozens of elections over months will naturally accumulate thousands of records, making this a real operational risk even without malicious actors.

### Recommendation

**Immediate Mitigation**:
1. Add pagination parameters to `GetElectorVoteWithAllRecords()` and `GetElectorVoteWithRecords()`:
```
message GetElectorVoteInput {
    string pubkey_or_address = 1;
    int32 active_start = 2;
    int32 active_length = 3;
    int32 withdrawn_start = 4;
    int32 withdrawn_length = 5;
}
```

2. Implement maximum page size (e.g., 100 records per call) in ViewMethods.cs:
```csharp
public override ElectorVote GetElectorVoteWithRecords(GetElectorVoteInput input)
{
    const int MaxPageSize = 100;
    var activeLength = Math.Min(input.ActiveLength, MaxPageSize);
    var activeIds = votes.ActiveVotingRecordIds
        .Skip(input.ActiveStart)
        .Take(activeLength);
    // Fetch only paginated IDs
}
```

3. Add response size validation before returning from view methods

**Long-term Solution**:
- Implement archival/pruning of old withdrawn voting records after a retention period
- Add metrics to monitor view method response sizes
- Consider implementing rate limiting for view method calls per address

**Test Cases**:
1. Create 10,000 voting records for a single elector
2. Verify `GetElectorVoteWithAllRecords()` with pagination returns expected subsets
3. Verify unpaginated calls are rejected or limited to max page size
4. Performance test with realistic loads (1,000+ concurrent queries)

### Proof of Concept

**Initial State**:
- Deploy Election and Vote contracts
- Fund test account with native tokens

**Exploitation Steps**:
1. Execute 5,000 Vote transactions with different amounts/lock times:
   ```
   for i in 1..5000:
       Vote(candidate_pubkey, amount=100, lock_time=90days)
   ```

2. Wait for lock periods to expire, then withdraw 4,000 votes:
   ```
   for i in 1..4000:
       Withdraw(vote_id[i])
   ```

3. Now elector has 1,000 active + 4,000 withdrawn = 5,000 total records

4. Call view method repeatedly (no fees):
   ```
   while true:
       GetElectorVoteWithAllRecords(elector_address)
   ```

**Expected Result**: Each call should be paginated or limited to reasonable size

**Actual Result**: Each call returns ~1MB response (5,000 records × ~200 bytes), causing:
- Node memory spikes
- Increased CPU usage for serialization
- Network congestion
- Degraded response times for other users

**Success Condition**: Monitoring shows sustained high memory/CPU usage on nodes and degraded API performance during the attack period.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L168-187)
```csharp
    public override ElectorVote GetElectorVoteWithRecords(StringValue input)
    {
        var votes = GetElectorVote(input.Value);
        
        if (votes.Address == null && votes.Pubkey == null)
            return votes;
        
        var votedRecords = State.VoteContract.GetVotingRecords.Call(new GetVotingRecordsInput
        {
            Ids = { votes.ActiveVotingRecordIds }
        }).Records;
        var index = 0;
        foreach (var record in votedRecords)
        {
            var voteId = votes.ActiveVotingRecordIds[index++];
            votes.ActiveVotingRecords.Add(TransferVotingRecordToElectionVotingRecord(record, voteId));
        }

        return votes;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L204-222)
```csharp
    public override ElectorVote GetElectorVoteWithAllRecords(StringValue input)
    {
        var votes = GetElectorVoteWithRecords(input);

        if (!votes.WithdrawnVotingRecordIds.Any()) return votes;

        var votedWithdrawnRecords = State.VoteContract.GetVotingRecords.Call(new GetVotingRecordsInput
        {
            Ids = { votes.WithdrawnVotingRecordIds }
        }).Records;
        var index = 0;
        foreach (var record in votedWithdrawnRecords)
        {
            var voteId = votes.WithdrawnVotingRecordIds[index++];
            votes.WithdrawnVotesRecords.Add(TransferVotingRecordToElectionVotingRecord(record, voteId));
        }

        return votes;
    }
```

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L8-13)
```csharp
    public override VotingRecords GetVotingRecords(GetVotingRecordsInput input)
    {
        var votingRecords = new VotingRecords();
        votingRecords.Records.AddRange(input.Ids.Select(id => State.VotingRecords[id]));
        return votingRecords;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L498-520)
```csharp
    private void UpdateElectorInformation(byte[] recoveredPublicKey, long amount, Hash voteId)
    {
        var voterVotes = GetElectorVote(recoveredPublicKey);

        if (voterVotes == null)
        {
            voterVotes = new ElectorVote
            {
                Address = Context.Sender,
                ActiveVotingRecordIds = { voteId },
                ActiveVotedVotesAmount = amount,
                AllVotedVotesAmount = amount
            };
        }
        else
        {
            voterVotes.ActiveVotingRecordIds.Add(voteId);
            voterVotes.ActiveVotedVotesAmount = voterVotes.ActiveVotedVotesAmount.Add(amount);
            voterVotes.AllVotedVotesAmount = voterVotes.AllVotedVotesAmount.Add(amount);
        }

        State.ElectorVotes[Context.Sender.ToBase58()] = voterVotes;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L629-679)
```csharp
    public override Empty Withdraw(Hash input)
    {
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input);

        var actualLockedTime = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockDays = State.LockTimeMap[input];
        Assert(actualLockedTime >= claimedLockDays,
            $"Still need {claimedLockDays.Sub(actualLockedTime).Div(86400)} days to unlock your token.");

        var voterPublicKey = Context.RecoverPublicKey();

        var voterVotes = GetElectorVote(voterPublicKey);

        Assert(voterVotes != null, $"Voter {Context.Sender.ToBase58()} never votes before");

        voterVotes.ActiveVotingRecordIds.Remove(input);
        voterVotes.WithdrawnVotingRecordIds.Add(input);
        voterVotes.ActiveVotedVotesAmount = voterVotes.ActiveVotedVotesAmount.Sub(votingRecord.Amount);

        State.ElectorVotes[Context.Sender.ToBase58()] = voterVotes;

        // Update Candidate's Votes information.
        var newestPubkey = GetNewestPubkey(votingRecord.Option);
        var candidateVotes = State.CandidateVotes[newestPubkey];

        Assert(candidateVotes != null, $"Newest pubkey {newestPubkey} is invalid. Old pubkey is {votingRecord.Option}");

        candidateVotes.ObtainedActiveVotingRecordIds.Remove(input);
        candidateVotes.ObtainedWithdrawnVotingRecordIds.Add(input);
        candidateVotes.ObtainedActiveVotedVotesAmount =
            candidateVotes.ObtainedActiveVotedVotesAmount.Sub(votingRecord.Amount);
        State.CandidateVotes[newestPubkey] = candidateVotes;

        UnlockTokensOfVoter(input, votingRecord.Amount);
        RetrieveTokensFromVoter(votingRecord.Amount);
        WithdrawTokensOfVoter(input);
        if (!State.WeightsAlreadyFixedMap[input])
        {
            RemoveBeneficiaryOfVoter();
            State.WeightsAlreadyFixedMap.Remove(input);
        }

        var rankingList = State.DataCentersRankingList.Value;
        if (!rankingList.DataCenters.ContainsKey(newestPubkey)) return new Empty();
        rankingList.DataCenters[newestPubkey] =
            rankingList.DataCenters[newestPubkey].Sub(votingRecord.Amount);
        UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, newestPubkey);
        State.DataCentersRankingList.Value = rankingList;

        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```
