# Audit Report

## Title
Race Condition in Mining Order Assignment Allows Duplicate FinalOrderOfNextRound Values

## Summary
A time-of-check-time-of-use (TOCTOU) race condition in the AEDPoS consensus mechanism allows multiple miners to be assigned identical `FinalOrderOfNextRound` values. Conflict detection occurs off-chain on local copies during block generation, but transaction execution directly assigns orders without re-validating uniqueness, and the validators fail to prevent this.

## Finding Description

The vulnerability exists across two distinct execution phases:

**Phase 1 - Block Generation (Off-chain):**
During block generation, `GetConsensusExtraDataToPublishOutValue()` invokes `ApplyNormalConsensusData()` on a local copy of the round state. [1](#0-0) 

The conflict detection logic identifies existing miners with matching `FinalOrderOfNextRound` values and reassigns them. [2](#0-1) 

However, this check operates on the miner's local copy of round state. In distributed systems with network latency, if two miners generate blocks based on state that doesn't yet reflect each other's updates (due to propagation delays or state synchronization issues), both will see no conflicts and both will claim the same order.

The `UpdateValueInput` is populated with `TuneOrderInformation` containing only conflicts detected in the local copy. [3](#0-2) 

**Phase 2 - Transaction Execution (On-chain):**
When `ProcessUpdateValue()` executes, it directly assigns the order from the input without re-validating uniqueness. [4](#0-3) 

It then applies `TuneOrderInformation`, but if both miners detected no conflicts in their respective local copies, both have empty tuning maps, resulting in no order adjustments. [5](#0-4) 

**Why Existing Protections Fail:**

1. The `UpdateValueValidationProvider` only validates OutValue/Signature correctness and PreviousInValue, not order uniqueness. [6](#0-5) 

2. The `NextRoundMiningOrderValidationProvider` contains a critical bug - it calls `.Distinct()` on `MinerInRound` objects rather than on the `FinalOrderOfNextRound` integer values, making it ineffective at detecting duplicates since object reference equality is used instead of value comparison. [7](#0-6) 

3. Moreover, this validator is only registered for `NextRound` behavior, not `UpdateValue` behavior. [8](#0-7) 

4. `EnsureTransactionOnlyExecutedOnceInOneBlock()` only prevents duplicate execution of the same transaction within one block by checking block height, not concurrent execution of different miners' transactions. [9](#0-8) 

## Impact Explanation

**Direct Consensus Integrity Violation:**
When two miners have identical `FinalOrderOfNextRound` values, the consensus mechanism's round transition logic is broken. The next round generation depends on each miner having a unique order to properly assign time slots. Duplicate orders cause:
- Ambiguous time slot assignments with undefined behavior
- Miners potentially missing their designated slots
- Inability to properly transition to the next round
- Broken miner rotation mechanism

This violates a critical consensus invariant: **each miner must have a unique mining order in the next round**. The consensus mechanism's integrity fundamentally depends on this invariant.

The order calculation uses `GetAbsModulus(signature.ToInt64(), minersCount) + 1`, distributing orders across N positions. [10](#0-9) 

With 17 miners (typical AEDPoS configuration), any two miners have approximately 1/17 (~5.9%) probability of collision per round. Over multiple blocks within a round, collisions become highly probable.

## Likelihood Explanation

**No Attacker Required:**
This vulnerability triggers naturally during normal consensus operation through probabilistic hash collisions combined with distributed system timing characteristics. No malicious actor is needed.

**Triggering Conditions:**
1. Two miners calculate the same `supposedOrderOfNextRound` (probabilistic event with ~1/N chance per pair)
2. Both generate their blocks based on state that hasn't yet reflected each other's committed orders (inherent timing window in distributed systems)

**Feasibility:**
- Occurs naturally in multi-miner environments with network latency
- More likely with higher block production rates and geographic distribution of miners
- Probability compounds across multiple blocks: With N miners over M blocks, cumulative collision probability approaches: 1 - (1 - 1/N)^(MÃ—(M-1)/2)
- For 17 miners over 100 blocks in a round, collision probability exceeds 95%

**Detection Constraints:**
The duplicate orders may not manifest as immediate failures. Issues only become apparent during next round generation when the system attempts to use the conflicting orders for time slot assignments, potentially causing delayed or cascading failures in round transitions.

## Recommendation

Implement strict uniqueness validation during transaction execution:

1. **Add re-validation in `ProcessUpdateValue()`**: Before assigning `FinalOrderOfNextRound`, check that no other miner in the current round already has that value:
```csharp
// Check for duplicates before assignment
var existingMinerWithOrder = currentRound.RealTimeMinersInformation.Values
    .FirstOrDefault(m => m.Pubkey != _processingBlockMinerPubkey && 
                         m.FinalOrderOfNextRound == updateValueInput.SupposedOrderOfNextRound);
Assert(existingMinerWithOrder == null, 
       $"Order {updateValueInput.SupposedOrderOfNextRound} already assigned to {existingMinerWithOrder?.Pubkey}");
```

2. **Fix `NextRoundMiningOrderValidationProvider`**: Change `.Distinct()` to operate on the integer values:
```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
```

3. **Register order validation for UpdateValue**: Add `NextRoundMiningOrderValidationProvider` (after fixing) to the `UpdateValue` behavior validation chain, not just `NextRound`.

## Proof of Concept

The vulnerability can be demonstrated by simulating concurrent block generation where two miners calculate the same order before seeing each other's committed state, resulting in both being assigned identical `FinalOrderOfNextRound` values after their transactions execute sequentially, breaking the consensus invariant that requires unique orders per miner.

**Notes**

This is a classic TOCTOU race condition in distributed consensus. The off-chain conflict detection on local copies cannot guarantee atomicity with the on-chain state updates. The lack of re-validation during execution, combined with the validator bugs and missing checks, creates a vulnerability window. While perfect state synchronization would prevent this, distributed systems inherently have propagation delays, making timing-based race conditions realistic concerns that require defensive validation at execution time.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L23-40)
```csharp
        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-88)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```
