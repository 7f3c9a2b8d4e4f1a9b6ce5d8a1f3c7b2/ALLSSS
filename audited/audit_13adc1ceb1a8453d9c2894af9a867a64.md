# Audit Report

## Title
Integer Overflow in Association Organization Threshold Validation Allows Bypass of Voting Safeguards

## Summary
The Association contract's `Validate` function performs unchecked integer addition when validating threshold parameters. When `MaximalAbstentionThreshold` is set to `int64.MaxValue` (9,223,372,036,854,775,807) and `MinimalApprovalThreshold` is set to 1, the addition overflows to `int64.MinValue`, bypassing validation checks. This enables creation of organizations where proposals can never be blocked by abstentions or rejections, undermining the multi-signature governance model.

## Finding Description

The vulnerability exists in the threshold validation logic. [1](#0-0) 

The validation performs unchecked addition: `MaximalAbstentionThreshold + MinimalApprovalThreshold <= organizationMemberCount`. In C#, integer arithmetic is unchecked by default, meaning overflow wraps to negative values without exception.

When an attacker sets:
- `MaximalAbstentionThreshold = 9223372036854775807` (int64.MaxValue)
- `MinimalApprovalThreshold = 1`

The addition `int64.MaxValue + 1` overflows to `int64.MinValue` (-9,223,372,036,854,775,808). The validation check becomes: `-9223372036854775808 <= organizationMemberCount`, which always passes for positive member counts.

The `CreateOrganization` method is public with no access controls, allowing any user to create such an organization. [2](#0-1) 

The thresholds are defined as `int64` in the protobuf specification, confirming overflow potential. [3](#0-2) 

During proposal release, the check for abstentions becomes impossible to satisfy. [4](#0-3) 

With `MaximalAbstentionThreshold = int64.MaxValue`, the condition `abstentionMemberCount > int64.MaxValue` can never be true, as vote counts cannot exceed int64.MaxValue in practice.

The same validation is used in `ChangeOrganizationThreshold`, though that requires passing a proposal first. [5](#0-4) 

## Impact Explanation

This vulnerability breaks the fundamental security guarantee of multi-signature governance. An organization with overflowed thresholds can:
- Execute arbitrary proposals with as few as 1 approval
- Completely ignore abstentions and rejections from all other members
- Bypass the intended voting safeguards

If such a malicious organization is granted governance authority over:
- Token contracts (MultiToken) - unauthorized minting, burning, transfers
- Treasury contract - unauthorized fund distributions
- Cross-chain contracts - manipulation of cross-chain indexing
- System configuration - changing critical parameters

The entire ecosystem's security model is compromised. Organization members' votes become meaningless, violating the core principle that proposals require consensus to execute.

## Likelihood Explanation

**Attack Feasibility**: HIGH
- The `CreateOrganization` method is public with no authorization checks
- Attack complexity is minimal - attacker simply provides extreme threshold values
- No special privileges or preconditions required

**Example Attack Configuration**:
- `MinimalApprovalThreshold = 1`
- `MinimalVoteThreshold = 1`
- `MaximalAbstentionThreshold = 9223372036854775807` (int64.MaxValue)
- `MaximalRejectionThreshold = 9223372036854775806`
- `OrganizationMemberList`: attacker-controlled addresses plus victims

**Detection Difficulty**: The overflow is not obvious from the stored values. Users or automated systems granting authority to such organizations would not easily detect the malicious configuration. The existing test suite validates normal threshold scenarios but lacks int64 boundary condition tests. [6](#0-5) 

## Recommendation

Wrap the arithmetic operations in a `checked` block to detect overflow:

```csharp
private bool Validate(Organization organization)
{
    // ... existing checks ...
    
    try
    {
        checked
        {
            return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
                   proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
                   proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
                   proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
                   proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
                   proposalReleaseThreshold.MaximalAbstentionThreshold +
                   proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
                   proposalReleaseThreshold.MaximalRejectionThreshold +
                   proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
        }
    }
    catch (OverflowException)
    {
        return false;
    }
}
```

Alternatively, perform explicit overflow checks before addition:
```csharp
if (proposalReleaseThreshold.MaximalAbstentionThreshold > organizationMemberCount - proposalReleaseThreshold.MinimalApprovalThreshold)
    return false;
if (proposalReleaseThreshold.MaximalRejectionThreshold > organizationMemberCount - proposalReleaseThreshold.MinimalApprovalThreshold)
    return false;
```

## Proof of Concept

```csharp
[Fact]
public async Task CreateOrganization_IntegerOverflow_BypassValidation_Test()
{
    // Create malicious organization with int64.MaxValue thresholds
    var createOrganizationInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { Reviewer1, Reviewer2, Reviewer3 }
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 1,
            MinimalVoteThreshold = 1,
            MaximalAbstentionThreshold = long.MaxValue, // int64.MaxValue
            MaximalRejectionThreshold = long.MaxValue - 1
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { Reviewer1 }
        }
    };
    
    // Organization creation should fail but succeeds due to overflow
    var result = await AssociationContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var organizationAddress = result.Output;
    
    // Create a proposal
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // All members abstain
    await AbstainAsync(Reviewer1KeyPair, proposalId);
    await AbstainAsync(Reviewer2KeyPair, proposalId);
    await AbstainAsync(Reviewer3KeyPair, proposalId);
    
    // Check proposal status - should NOT be releasable due to abstentions
    // But due to overflow, abstentions are ignored
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    
    // This demonstrates the vulnerability: proposal is releasable despite all members abstaining
    // In a properly functioning system, this should be false
    proposal.ToBeReleased.ShouldBeTrue(); // Vulnerability confirmed
}
```

## Notes

This vulnerability affects the core governance mechanism of AElf. The same pattern should be audited in Parliament and Referendum contracts. The overflow occurs because C# uses unchecked arithmetic by default, and the validation logic does not anticipate extreme boundary values being used maliciously. Any existing organizations with these malicious thresholds should be identified and their authorities revoked immediately.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-44)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L77-80)
```csharp
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-83)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-208)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
```

**File:** protobuf/acs3.proto (L128-137)
```text
message ProposalReleaseThreshold {
    // The value for the minimum approval threshold.
    int64 minimal_approval_threshold = 1;
    // The value for the maximal rejection threshold.
    int64 maximal_rejection_threshold = 2;
    // The value for the maximal abstention threshold.
    int64 maximal_abstention_threshold = 3;
    // The value for the minimal vote threshold.
    int64 minimal_vote_threshold = 4;
}
```

**File:** test/AElf.Contracts.Association.Tests/AssociationContractTests.cs (L248-278)
```csharp
        //invalid maximalAbstentionThreshold
        {
            var minimalApproveThreshold = 1;
            var minimalVoteThreshold = 3;
            var maximalAbstentionThreshold = 4;
            var maximalRejectionThreshold = 0;

            var createOrganizationInput = GenerateCreateOrganizationInput(minimalApproveThreshold,
                minimalVoteThreshold,
                maximalAbstentionThreshold, maximalRejectionThreshold, Reviewer1);
            var transactionResult =
                await AssociationContractStub.CreateOrganization.SendWithExceptionAsync(createOrganizationInput);
            transactionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
            transactionResult.TransactionResult.Error.Contains("Invalid organization.").ShouldBeTrue();
        }

        //invalid minimalVoteThreshold + maximalAbstentionThreshold
        {
            var minimalApproveThreshold = 3;
            var minimalVoteThreshold = 3;
            var maximalAbstentionThreshold = 1;
            var maximalRejectionThreshold = 0;

            var createOrganizationInput = GenerateCreateOrganizationInput(minimalApproveThreshold,
                minimalVoteThreshold,
                maximalAbstentionThreshold, maximalRejectionThreshold, Reviewer1);
            var transactionResult =
                await AssociationContractStub.CreateOrganization.SendWithExceptionAsync(createOrganizationInput);
            transactionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
            transactionResult.TransactionResult.Error.Contains("Invalid organization.").ShouldBeTrue();
        }
```
