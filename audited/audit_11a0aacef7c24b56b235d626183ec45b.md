# Audit Report

## Title
NextRound Validation Checks Wrong Round Allowing Consensus Manipulation

## Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` method incorrectly validates the provided next round instead of the current round from state. This causes the validation to always pass (0 == 0) since newly generated rounds have all `FinalOrderOfNextRound = 0` and `OutValue = null` by default. This allows any miner acting as extra block producer to provide arbitrary next round data with manipulated mining order that gets stored directly to blockchain state, breaking consensus integrity and enabling unfair reward distribution.

## Finding Description

**Root Cause - Validator Checks Wrong Round:**

The validation logic checks `providedRound` (the proposed next round from block header) instead of `baseRound` (the current round from state): [1](#0-0) 

The validator's comment states "Miners that have determined the order of the next round should be equal to miners that mined blocks during current round", but it checks the provided next round instead.

**Why baseRound is Not Modified for NextRound Behavior:**

In the validation setup, `RecoverFromUpdateValue` is only called for UpdateValue and TinyBlock behaviors, NOT for NextRound behavior, meaning `baseRound` remains the unmodified current round from state: [2](#0-1) 

**Next Round Generation Leaves Critical Fields Unset:**

When `GenerateNextRoundInformation` creates a new round, it only sets specific fields (`Pubkey`, `Order`, `ExpectedMiningTime`, `ProducedBlocks`, `MissedTimeSlots`). The `FinalOrderOfNextRound` and `OutValue` fields remain at their default values (0 and null): [3](#0-2) 

**Result - Validation Always Passes:**

For any newly generated next round (legitimate or malicious):
- Count of miners with `FinalOrderOfNextRound > 0` = 0
- Count of miners with `OutValue != null` = 0  
- Check: `0 != 0` evaluates to false, validation passes

**Malicious Round Stored Directly:**

The provided round is converted and stored directly to state without regeneration or additional validation of the `Order` values: [4](#0-3) 

The storage happens via: [5](#0-4) 

**Attack Execution:**

When a miner becomes the extra block producer (which happens regularly in round-robin fashion), instead of honestly generating next round data, they craft a malicious `NextRoundInput` with arbitrary `Order` values positioning themselves favorably. The broken validation passes, and the malicious round is persisted to blockchain state.

This violates the fundamental AEDPoS consensus guarantee that mining order should be determined cryptographically based on miners' signatures during the current round (via `FinalOrderOfNextRound` values set during UpdateValue operations): [6](#0-5) 

## Impact Explanation

**Severity: Critical - Consensus Integrity Compromise**

An attacker can manipulate the mining order in the next round, allowing them to:

1. **Position themselves as first miner**: Maximize block production opportunities and rewards by claiming `Order = 1`

2. **Assign unfavorable positions to competitors**: Place competing miners at disadvantageous positions (higher Order values) to reduce their mining opportunities

3. **Manipulate timing**: Set arbitrary `ExpectedMiningTime` values to create timing advantages

4. **Break cryptographic randomness**: Bypass the signature-based randomness mechanism that should determine mining order fairly

**Quantified Damage:**
- Attacker gains repeated first-miner advantage across multiple rounds
- Unfair reward distribution heavily favoring the attacker
- Honest miners lose expected mining opportunities and associated block rewards
- Complete breakdown of the signature-based mining order determination
- Undermines fairness and decentralization properties of AEDPoS consensus

**Affected Parties:** All network participants suffer from compromised consensus integrity. Non-malicious miners lose expected block production opportunities and rewards, while the attacker gains unfair advantages repeatedly.

This directly violates the "Correct round transitions and miner schedule integrity" invariant that is fundamental to AEDPoS consensus security.

## Likelihood Explanation

**Probability: High**

**Attacker Capabilities Required:**
- Must be in the current miner set (standard requirement for any block producer)
- Must be selected as extra block producer (happens routinely in normal consensus operation through round-robin mechanism)
- No special permissions or trusted roles required beyond normal miner status

**Attack Complexity: Low**

The attacker simply needs to craft a `NextRoundInput` with manipulated `Order` values. The input structure is defined at: [7](#0-6) 

Instead of calling the honest generation method, the attacker creates a malicious round with arbitrary orders and calls `NextRound()`: [8](#0-7) 

**Feasibility:** Every miner eventually becomes the extra block producer, providing repeated attack opportunities. The malicious round appears valid to all validators since the broken validation passes. Only forensic analysis comparing expected versus actual mining orders would reveal the manipulation.

## Recommendation

**Fix the validator to check the current round (baseRound) instead of the provided next round:**

Change the validation logic to verify that in the current round from state, all miners who mined blocks (have `OutValue != null`) have properly set their `FinalOrderOfNextRound` values (> 0), and that the count matches:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var baseRound = validationContext.BaseRound; // Check CURRENT round, not provided
    
    var minersWithFinalOrder = baseRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0).Distinct().Count();
    var minersWhoMined = baseRound.RealTimeMinersInformation.Values
        .Count(m => m.OutValue != null);
    
    if (minersWithFinalOrder != minersWhoMined)
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound.";
        return validationResult;
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

This ensures that the current round has proper consensus data (miners who mined have determined their next round order via signature-based mechanism) before allowing the next round transition.

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_WithMaliciousOrder_ShouldBeRejected()
{
    // Setup: Complete a normal round with miners producing blocks
    await InitializeConsensusAndMineBlocks();
    
    var currentRound = await GetCurrentRound();
    var maliciousMinerPubkey = currentRound.RealTimeMinersInformation.Keys.First();
    
    // Attacker crafts malicious next round with manipulated Order values
    var maliciousRound = new Round
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        RealTimeMinersInformation = new Dictionary<string, MinerInRound>()
    };
    
    // Attacker positions themselves as first miner (Order = 1)
    maliciousRound.RealTimeMinersInformation[maliciousMinerPubkey] = new MinerInRound
    {
        Pubkey = maliciousMinerPubkey,
        Order = 1, // Manipulated to be first!
        ExpectedMiningTime = currentBlockTime.AddMilliseconds(4000),
        IsExtraBlockProducer = false
    };
    
    // Other miners get unfavorable positions
    int order = 2;
    foreach (var minerPubkey in currentRound.RealTimeMinersInformation.Keys.Skip(1))
    {
        maliciousRound.RealTimeMinersInformation[minerPubkey] = new MinerInRound
        {
            Pubkey = minerPubkey,
            Order = order++,
            ExpectedMiningTime = currentBlockTime.AddMilliseconds(4000 * order)
        };
    }
    
    var maliciousInput = NextRoundInput.Create(maliciousRound, GenerateRandomNumber());
    
    // Execute attack: Call NextRound with malicious input
    var result = await ConsensusStub.NextRound.SendAsync(maliciousInput);
    
    // BUG: Transaction succeeds when it should fail
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed); // FAILS - actually succeeds
    
    // Verify malicious round was stored
    var storedRound = await GetCurrentRound();
    var firstMiner = storedRound.RealTimeMinersInformation.Values.First(m => m.Order == 1);
    
    // Attacker successfully manipulated themselves to be first miner
    firstMiner.Pubkey.ShouldBe(maliciousMinerPubkey); // PASSES - attack successful
}
```

The test demonstrates that a malicious miner can craft arbitrary mining orders, the validation passes incorrectly, and the manipulated round is stored to blockchain state, confirming the vulnerability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-60)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-56)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L242-260)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
