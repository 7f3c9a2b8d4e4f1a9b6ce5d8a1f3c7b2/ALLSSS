### Title
Unbounded State Bloat via Unlimited Profit Scheme Creation in TokenHolderContract

### Summary
The `CreateScheme()` function in TokenHolderContract lacks authorization controls and duplicate prevention checks, allowing any user to repeatedly create unlimited profit schemes. Each invocation creates a new scheme in ProfitContract while only the latest scheme is tracked in TokenHolderContract, causing permanent state bloat through orphaned scheme objects that consume storage indefinitely.

### Finding Description

**Entry Point:**
The `CreateScheme()` function is publicly accessible without any authorization check. [1](#0-0) 

**Root Cause - Storage Overwrite:**
TokenHolderContract stores only ONE scheme per address in `State.TokenHolderProfitSchemes[Context.Sender]`. When called multiple times by the same address, this storage slot is overwritten. [2](#0-1) 

**Root Cause - Scheme Accumulation:**
Each `CreateScheme` call to ProfitContract creates a NEW unique scheme because the schemeId is generated using an incrementing counter based on existing schemes. [3](#0-2) 

The ProfitContract stores each scheme permanently and adds it to the manager's scheme list without limit. [4](#0-3) 

The duplicate check only prevents identical schemeIds, not multiple schemes per manager. [5](#0-4) 

**Storage Structure:**
The state mapping only supports one scheme per address. [6](#0-5) 

Each Scheme object consumes significant storage including addresses, hashes, maps, and repeated fields. [7](#0-6) 

**Lack of Protection:**
No validation exists in TokenHolderContract to check if a scheme already exists for the sender before creating a new one. Grep search confirmed no assertions on `TokenHolderProfitSchemes` being null.

### Impact Explanation

**State Bloat Attack:**
- An attacker can call `CreateScheme()` thousands of times from a single address
- Each call creates a permanent Scheme object in ProfitContract (minimum ~126+ bytes plus virtual address allocation)
- Previous schemes become orphaned—they exist in ProfitContract but are not tracked by TokenHolderContract
- Orphaned schemes cannot be removed or cleaned up through any existing mechanism
- Multiple attacker addresses can amplify the attack exponentially

**DoS Consequences:**
- Unbounded growth of ProfitContract state storage
- Increased node synchronization time as state grows
- Degraded query performance for scheme lookups
- Potential blockchain bloat affecting all validators

**Affected Parties:**
- All blockchain nodes must store the bloated state
- Chain operators face increased storage and maintenance costs
- Legitimate users experience degraded performance

**Severity:** HIGH - This is an operational DoS attack with permanent storage impact, requiring only transaction fees to execute at scale.

### Likelihood Explanation

**Attacker Capabilities:**
- No special permissions required—any address can call the function
- No token holdings, approvals, or stake required
- Attack can be executed from multiple addresses simultaneously

**Attack Complexity:**
- Extremely simple: repeatedly call `TokenHolderContract.CreateScheme()` with varying input parameters
- No complex transaction sequencing or timing requirements
- No need to bypass authentication or circumvent access controls

**Economic Feasibility:**
- Attack cost is only transaction fees (no tokens locked or burned)
- In typical blockchain economics, creating thousands of schemes costs minimal fees relative to the permanent storage damage inflicted
- Cost-to-damage ratio heavily favors the attacker

**Detection/Mitigation:**
- Attack is visible on-chain but difficult to prevent without protocol-level rate limiting
- No mechanism exists to clean up orphaned schemes after attack
- Damage is permanent once schemes are created

**Probability:** HIGH - The attack is trivial to execute, economically rational, and has no technical barriers.

### Recommendation

**Immediate Fix:**
Add a check in `CreateScheme()` to prevent duplicate scheme creation:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add this check at the beginning
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists for this address.");
    
    // ... rest of existing code
}
```

**Location to modify:** [8](#0-7) 

**Additional Protections:**
1. Add rate limiting for scheme creation per address
2. Implement a cleanup mechanism for unused schemes
3. Consider requiring a minimum token stake to create schemes
4. Add scheme creation events for monitoring

**Test Cases to Add:**
1. Test that calling `CreateScheme()` twice from same address fails with appropriate error
2. Test that different addresses can each create one scheme
3. Load test to verify scheme creation limits are effective

### Proof of Concept

**Initial State:**
- Attacker has account with sufficient balance for transaction fees
- TokenHolderContract is deployed and operational

**Attack Steps:**

1. **Transaction 1:** Attacker calls `TokenHolderContract.CreateScheme({Symbol: "ELF", MinimumLockMinutes: 10})`
   - Result: scheme_0 created in ProfitContract with schemeId based on counter=0
   - TokenHolderContract stores scheme at `State.TokenHolderProfitSchemes[attacker_address]`

2. **Transaction 2:** Same attacker calls `TokenHolderContract.CreateScheme({Symbol: "ELF", MinimumLockMinutes: 20})`
   - Result: scheme_1 created in ProfitContract with schemeId based on counter=1
   - TokenHolderContract OVERWRITES storage at `State.TokenHolderProfitSchemes[attacker_address]`
   - scheme_0 is now orphaned (exists in ProfitContract but not tracked by TokenHolder)

3. **Repeat 1000 times:** Execute transactions with varying parameters
   - Result: 1000 schemes created in ProfitContract
   - Only the last scheme tracked in TokenHolderContract
   - 999 orphaned schemes consuming permanent storage

**Verification:**
- Query `ProfitContract.GetManagingSchemeIds(attacker_address)` returns 1000 schemeIds
- Query `TokenHolderContract.GetScheme(attacker_address)` returns only the last scheme
- Check blockchain state size increases by ~126KB+ per 1000 schemes
- Verify no cleanup mechanism can remove the orphaned schemes

**Success Condition:** 
State bloat confirmed when orphaned schemes persist indefinitely in ProfitContract storage while being inaccessible through TokenHolderContract, with no recovery mechanism available.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L56-71)
```csharp
        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
        State.SchemeInfos[schemeId] = scheme;

        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L10-10)
```csharp
    public MappedState<Address, TokenHolderProfitScheme> TokenHolderProfitSchemes { get; set; }
```

**File:** protobuf/profit_contract.proto (L135-160)
```text
message Scheme {
    // The virtual address of the scheme.
    aelf.Address virtual_address = 1;
    // The total weight of the scheme.
    int64 total_shares = 2;
    // The manager of the scheme.
    aelf.Address manager = 3;
    // The current period.
    int64 current_period = 4;
    // Sub schemes information.
    repeated SchemeBeneficiaryShare sub_schemes = 5;
    // Whether you can directly remove the beneficiary.
    bool can_remove_beneficiary_directly = 6;
    // Period of profit distribution.
    int64 profit_receiving_due_period_count = 7;
    // Whether all the schemes balance will be distributed during distribution each period.
    bool is_release_all_balance_every_time_by_default = 8;
    // The is of the scheme.
    aelf.Hash scheme_id = 9;
    // Delay distribute period.
    int32 delay_distribute_period_count = 10;
    // Record the scheme's current total share for deferred distribution of benefits, period -> total shares.
    map<int64, int64> cached_delay_total_shares = 11;
    // The received token symbols.
    repeated string received_token_symbols = 12;
}
```
