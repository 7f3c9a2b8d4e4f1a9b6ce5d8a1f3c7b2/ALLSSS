### Title
Token Supply State Inconsistency After Burn Operations Causes Cross-Chain Transfer DoS

### Summary
The `Burn()` method modifies the local `tokenInfo.Supply` field but fails to persist the change to `State.TokenInfos`, while `Issue()` and `CrossChainReceiveToken()` correctly persist their Supply updates. This causes `GetTokenInfo()` to return stale (higher) Supply values after burn operations, leading to incorrect "Total supply exceeded" failures in `CrossChainReceiveToken()` that block legitimate cross-chain token receives.

### Finding Description

The vulnerability exists in the `Burn()` method implementation: [1](#0-0) 

The method retrieves `tokenInfo`, decrements the local `Supply` field at line 328, but never calls `SetTokenInfo()` to persist this change back to `State.TokenInfos`. This contrasts with the correct implementation in `Issue()`: [2](#0-1) 

The `Issue()` method correctly calls `SetTokenInfo(tokenInfo)` after modifying Supply. Similarly, `CrossChainReceiveToken()` also correctly persists Supply updates: [3](#0-2) 

The `GetTokenInfo()` helper method reads directly from `State.TokenInfos`: [4](#0-3) 

Since `Burn()` never updates `State.TokenInfos`, subsequent `GetTokenInfo()` calls return the outdated Supply value. The critical impact occurs in `CrossChainReceiveToken()` which performs a supply limit check: [5](#0-4) 

This check uses the stale (non-decremented) Supply value from `GetTokenInfo()`, causing it to incorrectly reject legitimate cross-chain receives after tokens have been burned.

### Impact Explanation

**Direct Operational Impact - Cross-Chain Transfer DoS:**

After burn operations, the `CrossChainReceiveToken()` function will incorrectly fail with "Total supply exceeded" error even when the actual circulating supply is well below the limit.

**Concrete Scenario:**
1. Token has `TotalSupply = 1000`, `Supply = 1000` (all tokens issued)
2. User burns 500 tokens via `Burn()`
3. Real circulating supply is now 500, but `State.TokenInfos` still shows `Supply = 1000`
4. User attempts `CrossChainReceiveToken(100)` 
5. The check evaluates: `1000 + 100 <= 1000` → **FAILS**
6. Should evaluate: `500 + 100 <= 1000` → **PASSES**
7. Legitimate cross-chain receive is blocked

**Affected Operations:**
- All cross-chain token receives after any burn operations
- Token metadata queries returning incorrect circulating supply
- Any external contracts or services relying on accurate Supply data

**Severity:** This is a **Medium severity** issue causing operational DoS of the cross-chain transfer functionality, a core protocol feature. While no direct fund loss occurs, it blocks legitimate user operations and disrupts cross-chain interoperability.

### Likelihood Explanation

**Attacker Capabilities:** Any user with burnable tokens can trigger this issue simply by calling the public `Burn()` method. [6](#0-5) 

**Attack Complexity:** Trivial - just burn tokens and attempt cross-chain receive.

**Preconditions:**
- Token must have `IsBurnable = true` 
- User must have token balance to burn
- Cross-chain functionality must be in use

**Execution Steps:**
1. Call `Burn()` with any amount
2. Attempt `CrossChainReceiveToken()`
3. Observe incorrect "Total supply exceeded" failure

**Detection:** This bug would be immediately apparent in any test that verifies `GetTokenInfo().Supply` after burning, such as: [7](#0-6) 

The test expects `Supply = 0` after burning, which would fail with the current implementation.

**Probability:** High - affects all burnable tokens with cross-chain functionality enabled.

### Recommendation

**Code Fix:** Add `SetTokenInfo(tokenInfo)` call after modifying Supply in the `Burn()` method:

```csharp
private Empty Burn(Address address, string symbol, long amount)
{
    var tokenInfo = AssertValidToken(symbol, amount);
    Assert(tokenInfo.IsBurnable, "The token is not burnable.");
    ModifyBalance(address, symbol, -amount);
    tokenInfo.Supply = tokenInfo.Supply.Sub(amount);
    SetTokenInfo(tokenInfo);  // ADD THIS LINE
    
    Context.Fire(new Burned
    {
        Burner = address,
        Symbol = symbol,
        Amount = amount
    });
    return new Empty();
}
```

**Invariant Check:** Ensure all methods that modify `TokenInfo` fields call `SetTokenInfo()` to persist changes.

**Test Cases:** Add regression test that verifies `GetTokenInfo().Supply` returns correct value after `Burn()` operation and validates that `CrossChainReceiveToken()` succeeds when real supply is below limit post-burn.

### Proof of Concept

**Initial State:**
- Token "TEST" created with `TotalSupply = 1000`, `IsBurnable = true`
- All 1000 tokens issued: `Supply = 1000`, `Issued = 1000`
- Cross-chain functionality registered

**Transaction Sequence:**

1. **Burn tokens:**
   ```
   Burn(symbol: "TEST", amount: 600)
   ```
   Expected: `Supply = 400`
   Actual: Balance reduced correctly, but `State.TokenInfos["TEST"].Supply = 1000` (unchanged)

2. **Query token info:**
   ```
   GetTokenInfo(symbol: "TEST")
   ```
   Expected: Returns `Supply = 400`
   Actual: Returns `Supply = 1000` (stale value)

3. **Attempt cross-chain receive:**
   ```
   CrossChainReceiveToken(
     symbol: "TEST",
     amount: 200,
     from_chain: side_chain_id
   )
   ```
   Expected: Success (400 + 200 = 600 ≤ 1000)
   Actual: **FAILS** with "Total supply exceeded" (check sees 1000 + 200 = 1200 > 1000)

**Success Condition:** Transaction 3 fails with "Total supply exceeded" error despite actual supply being 600 ≤ 1000, confirming the stale state issue causes incorrect rejection of legitimate cross-chain receives.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L163-167)
```csharp
        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L318-321)
```csharp
    public override Empty Burn(BurnInput input)
    {
        return Burn(Context.Sender, input.Symbol, input.Amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L323-336)
```csharp
    private Empty Burn(Address address, string symbol, long amount)
    {
        var tokenInfo = AssertValidToken(symbol, amount);
        Assert(tokenInfo.IsBurnable, "The token is not burnable.");
        ModifyBalance(address, symbol, -amount);
        tokenInfo.Supply = tokenInfo.Supply.Sub(amount);

        Context.Fire(new Burned
        {
            Burner = address,
            Symbol = symbol,
            Amount = amount
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L620-622)
```csharp
        tokenInfo.Supply = tokenInfo.Supply.Add(amount);
        Assert(tokenInfo.Supply <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/NftApplicationTests.cs (L623-626)
```csharp
        var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = symbols[1] });
        tokenInfo.Issued.ShouldBe(1);
        tokenInfo.TotalSupply.ShouldBe(1);
        tokenInfo.Supply.ShouldBe(0);
```
