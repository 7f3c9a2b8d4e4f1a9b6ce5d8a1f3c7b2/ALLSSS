### Title
Critical Consensus Validation Bypass Due to Object Reference Aliasing in ValidateConsensusAfterExecution

### Summary
The `ValidateConsensusAfterExecution` method contains a critical flaw where the hash comparison always compares an object to itself, completely bypassing after-execution validation. The `RecoverFromUpdateValue` method modifies `currentRound` in place and returns the same object reference, which is then assigned to `headerInformation.Round`, causing both variables to point to the same object. This renders the hash-based validation meaningless and allows any consensus data that passes before-execution checks to be accepted without proper after-execution verification.

### Finding Description

The vulnerability exists in the consensus validation flow: [1](#0-0) 

The `RecoverFromUpdateValue` method modifies the `currentRound` object in place: [2](#0-1) 

The execution flow is:
1. `currentRound` is retrieved from state (after block execution)
2. `currentRound.RecoverFromUpdateValue(headerInformation.Round, ...)` is called
3. This method modifies `currentRound` directly (via `this.RealTimeMinersInformation[pubkey]`) and returns `this` (the modified `currentRound`)
4. The result is assigned back: `headerInformation.Round = currentRound.RecoverFromUpdateValue(...)`
5. Now both `headerInformation.Round` and `currentRound` reference the SAME object
6. The hash comparison `headerInformation.Round.GetHash() != currentRound.GetHash()` compares the hash of an object to itself
7. This comparison will ALWAYS return equal (false for !=), causing validation to always pass

The `GetHash()` method implementation shows it creates a checkable round but the comparison logic is fundamentally broken: [3](#0-2) [4](#0-3) 

The same issue exists for tiny block validation: [5](#0-4) 

### Impact Explanation

**Consensus Integrity Compromise:**
- The after-execution validation is completely bypassed for all consensus operations (UpdateValue, TinyBlock)
- Any block that passes before-execution validation will be accepted regardless of actual state consistency
- Malicious or buggy miners could produce blocks with inconsistent consensus data that would not be detected by after-execution validation

**Defense-in-Depth Failure:**
- The validation architecture intended two layers: before-execution and after-execution checks
- The after-execution validation was meant to verify that executing the consensus transaction produced the expected state changes
- This critical defense layer is non-functional, leaving only before-execution validation

**Potential Attack Vectors:**
- Miners could exploit race conditions or state inconsistencies that only manifest after execution
- Consensus data that appears valid before execution but creates invalid state after execution would be accepted
- This undermines the integrity of round transitions, LIB calculations, and miner schedule management

**Severity Justification:**
This is CRITICAL because it completely disables a fundamental security check in the consensus mechanism, potentially allowing invalid blockchain state to be accepted by all nodes.

### Likelihood Explanation

**Certainty of Exploitation:**
- The bug triggers on EVERY block validation after execution
- No special attacker capabilities required - the validation is always broken
- 100% reproducible - the object aliasing happens deterministically

**Attacker Requirements:**
- Must be a current miner to produce blocks
- No additional privileges needed beyond normal block production

**Attack Complexity:**
- LOW - The attacker doesn't need to do anything special; the validation is already broken
- Any block produced will bypass after-execution validation automatically
- An attacker only needs to identify state inconsistencies that before-execution checks don't catch

**Detection:**
- The bug is not directly observable in transaction logs or events
- Would only be detected through detailed code review or if suspicious consensus behavior is investigated

**Operational Constraints:**
- None - the bug exists in production code and affects all block validations

### Recommendation

**Immediate Fix:**
Modify `RecoverFromUpdateValue` and `RecoverFromTinyBlock` to work on a clone rather than modifying `this`:

```csharp
public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
{
    var recoveredRound = this.Clone(); // Create a clone instead of modifying this
    if (!recoveredRound.RealTimeMinersInformation.ContainsKey(pubkey) ||
        !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
        return recoveredRound;

    var minerInRound = recoveredRound.RealTimeMinersInformation[pubkey];
    var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
    // ... apply updates to recoveredRound ...
    return recoveredRound;
}
```

**Alternative Fix:**
Clone `currentRound` before calling `RecoverFromUpdateValue` in `ValidateConsensusAfterExecution`:

```csharp
var currentRoundClone = currentRound.Clone();
if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
    headerInformation.Round = currentRoundClone.RecoverFromUpdateValue(
        headerInformation.Round, headerInformation.SenderPubkey.ToHex());
```

**Test Cases Required:**
1. Test that `headerInformation.Round` and `currentRound` are different objects after recovery
2. Test that validation fails when header round differs from state round in meaningful fields
3. Test that validation passes when header round correctly matches state round
4. Add regression tests for various consensus behaviors (UpdateValue, TinyBlock, NextRound, NextTerm)

**Additional Validation:**
Review all other uses of the Recover methods to ensure no similar issues exist elsewhere in the codebase.

### Proof of Concept

**Initial State:**
- Blockchain is running with AEDPoS consensus
- Multiple miners are active
- Normal block production is occurring

**Attack Sequence:**
1. A miner produces a block with consensus transaction (UpdateValue or TinyBlock)
2. The block includes `AElfConsensusHeaderInformation` in the header extra data
3. Block execution processes the consensus transaction and updates state
4. `ValidateConsensusAfterExecution` is called via the validation pipeline: [6](#0-5) 

5. Inside `ValidateConsensusAfterExecution`:
   - `currentRound` is retrieved from state (already updated by execution)
   - `RecoverFromUpdateValue` modifies `currentRound` in place
   - `headerInformation.Round` is set to the same object reference as `currentRound`
   - Hash comparison compares object to itself → always equal → validation passes

**Expected Result:**
Validation should detect discrepancies between header-claimed round state and actual post-execution round state.

**Actual Result:**
Validation always passes because it compares an object's hash to itself, making the check meaningless.

**Success Condition for Fix:**
After implementing the recommended fix, create a test that:
1. Produces a block with slightly modified consensus data in the header
2. Verifies that `ValidateConsensusAfterExecution` correctly rejects the block
3. Confirms that `headerInformation.Round` and `currentRound` are distinct objects with potentially different hashes

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L87-101)
```csharp
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L60-63)
```csharp
    public Hash GetHash(bool isContainPreviousInValue = true)
    {
        return HashHelper.ComputeFrom(GetCheckableRound(isContainPreviousInValue));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusValidationProvider.cs (L80-99)
```csharp
    public async Task<bool> ValidateBlockAfterExecuteAsync(IBlock block)
    {
        if (block.Header.Height == AElfConstants.GenesisBlockHeight)
            return true;

        var consensusExtraData = _consensusExtraDataExtractor.ExtractConsensusExtraData(block.Header);
        if (consensusExtraData == null || consensusExtraData.IsEmpty)
        {
            Logger.LogDebug($"Invalid consensus extra data {block}");
            return false;
        }

        var isValid = await _consensusService.ValidateConsensusAfterExecutionAsync(new ChainContext
        {
            BlockHash = block.GetHash(),
            BlockHeight = block.Header.Height
        }, consensusExtraData.ToByteArray());

        return isValid;
    }
```
