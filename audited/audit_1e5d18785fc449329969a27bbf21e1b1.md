### Title
Early Loop Termination in GetAvailableSymbolToPayTxFee Prevents Primary Token Fallback for Delegations

### Summary
The `GetAvailableSymbolToPayTxFee()` function uses a `break` statement instead of `continue` when a delegation check fails, causing premature loop termination before evaluating all available tokens including the required primary token. When the function returns null for delegation scenarios, transaction fee charging fails immediately without attempting to use the primary token as a fallback, even when sufficient delegation allowance and balance exist in unevaluated tokens.

### Finding Description [1](#0-0) 

In `GetAvailableSymbolToPayTxFee()`, when processing tokens for delegation scenarios, the code checks if delegation is sufficient for each token. At line 480, if `IsDelegationEnoughBaseOnPrimaryToken` returns false, the loop executes a `break` statement, terminating iteration entirely instead of continuing to check remaining tokens. [2](#0-1) 

The primary token is mandated to be in the `SymbolsToPayTxSizeFee` list: [3](#0-2) 

However, there is no requirement about the primary token's position in the list. If the primary token appears after other tokens in the list and an earlier token fails the delegation check, the loop breaks before reaching the primary token. All four tracking variables remain null, and the function returns null. [4](#0-3) 

When called from `ChargeSizeFee()`, a null return for delegation scenarios causes immediate failure: [5](#0-4) 

### Impact Explanation
**Operational Impact - DoS of Transaction Fee Payment:**
- Users with valid delegation allowances and sufficient token balances cannot execute transactions because fee charging fails prematurely
- The primary token (required by line 642 to be in the list) may never be evaluated due to early loop termination
- This violates the design invariant that the primary token should always be available for fee payment

**Affected Users:**
- Any user utilizing delegation-based transaction fee payment with multiple tokens configured in `SymbolsToPayTxSizeFee`
- Impact severity depends on token list ordering - if non-primary tokens are listed first and lack delegation allowance, all transactions fail

**Severity Justification - HIGH:**
- Breaks core functionality: users with sufficient funds cannot pay transaction fees
- Violates critical invariant: primary token must be evaluable but isn't
- No workaround available to affected users
- Affects transaction execution, a fundamental blockchain operation

### Likelihood Explanation
**Reachable Entry Point:**
- Public method `ChargeTransactionFees()` is called by ACS1 plugin for every transaction [6](#0-5) 

**Feasible Preconditions:**
1. Multi-token fee payment is configured via `SetSymbolsToPayTxSizeFee()` with 2+ tokens
2. Delegation is set up for transaction fees (`TransactionFeeDelegations` exists)
3. Token list ordering places primary token after other token(s)
4. Earlier token(s) in list lack sufficient delegation allowance
5. Primary token has sufficient delegation allowance and balance

**Execution Practicality:**
- All preconditions are realistic and occur in normal protocol operation
- Token list ordering is controlled by governance but not restricted
- Delegation limits can be set per-token, making mixed sufficiency scenarios common
- No special privileges required

**Detection Constraints:**
- Issue manifests as transaction fee payment failures
- Users perceive this as "insufficient funds" but may actually have sufficient delegation in unevaluated tokens
- Difficult to diagnose without understanding the early break behavior

**Probability: HIGH** - Conditions are realistic and will occur in production environments with multi-token fee configurations and delegations.

### Recommendation
**Code-Level Mitigation:**
Replace the `break` statement with `continue` at line 480 to allow evaluation of all tokens in the list:

```csharp
if (delegations != null)
{
    var delegationEnough = IsDelegationEnoughBaseOnPrimaryToken(symbolToPlayTxSizeFee,
        symbolChargedForBaseFee, amountChargedForBaseFee.Add(amountChargedForBaseAllowance),
        txSizeFeeAmount, delegations);
    if (!delegationEnough) continue;  // CHANGE: use continue instead of break
}
```

**Invariant Checks:**
- Add assertion that primary token is evaluated: track whether primary token was processed in the loop
- Consider enforcing primary token as first element in the list during `SetSymbolsToPayTxSizeFee()`

**Test Cases:**
1. Test delegation scenario with token list `["USDT", "ELF"]` where USDT has zero delegation but ELF has sufficient delegation - should succeed
2. Test that primary token is always evaluated regardless of list position
3. Test early break doesn't occur when any token fails delegation check

### Proof of Concept
**Initial State:**
- Chain primary token: "ELF"
- `SymbolsToPayTxSizeFee` configured with list: `["USDT", "ELF"]`
- User has delegation setup with delegatee address
- Delegatee's delegation allowances: `{"USDT": 0, "ELF": 100}`
- Delegatee's token balances: `{"USDT": 0, "ELF": 1000}`
- Transaction size fee required: 10 ELF

**Transaction Steps:**
1. User submits transaction that triggers `ChargeTransactionFees()`
2. `ChargeSizeFee()` is called with delegation object
3. `GetAvailableSymbolToPayTxFee()` iterates through `["USDT", "ELF"]`
4. Loop processes "USDT" first:
   - `IsDelegationEnoughBaseOnPrimaryToken()` checks if delegation["USDT"] >= 10 (converted)
   - Returns false because delegation allowance is 0
   - Line 480: `break` executes
5. Loop terminates without processing "ELF"
6. All tracking variables remain null
7. Function returns null
8. Back in `ChargeSizeFee()`, line 411: condition `delegations != null && availableSymbol == null` is true
9. Returns false

**Expected Result:**
Transaction fee charging should succeed using 10 ELF from the 100 ELF delegation allowance

**Actual Result:**
Transaction fee charging fails, transaction cannot execute, despite delegatee having sufficient ELF delegation allowance (100) and balance (1000)

**Success Condition:**
The vulnerability is confirmed if the charging fails when it should succeed. The fix (changing `break` to `continue`) would allow "ELF" to be evaluated, selected, and used for fee payment successfully.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-53)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }

        // Record tx fee bill during current charging process.
        var bill = new TransactionFeeBill();
        var allowanceBill = new TransactionFreeFeeAllowanceBill();
        var fromAddress = Context.Sender;
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L410-414)
```csharp
            //For delegation,if there is no available token,return false,no need to generate bill
            if (delegations != null && availableSymbol == null)
            {
                return false;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L462-517)
```csharp
    private SymbolToPayTxSizeFee GetAvailableSymbolToPayTxFee(List<SymbolToPayTxSizeFee> allSymbolToTxFee,
        Address fromAddress, long txSizeFeeAmount, TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap,
        string symbolChargedForBaseFee, long amountChargedForBaseFee, long amountChargedForBaseAllowance,
        TransactionFeeDelegations delegations = null)
    {
        SymbolToPayTxSizeFee availableSymbol = null;
        SymbolToPayTxSizeFee availableSymbolWithAnything = null;
        SymbolToPayTxSizeFee availableSymbolWithEnoughBalance = null;
        SymbolToPayTxSizeFee availableSymbolWithEnoughBalancePlusAllowance = null;

        // get 1st Allowance > size fee, else, get 1st Balance + Allowance > 0, else get 1st > 0
        foreach (var symbolToPlayTxSizeFee in allSymbolToTxFee)
        {
            if (delegations != null)
            {
                var delegationEnough = IsDelegationEnoughBaseOnPrimaryToken(symbolToPlayTxSizeFee,
                    symbolChargedForBaseFee, amountChargedForBaseFee.Add(amountChargedForBaseAllowance),
                    txSizeFeeAmount, delegations);
                if (!delegationEnough) break;
            }

            var allowance = GetAllowanceCalculatedBaseOnPrimaryToken(symbolToPlayTxSizeFee,
                transactionFeeFreeAllowancesMap, symbolChargedForBaseFee, amountChargedForBaseAllowance);
            var balance = GetBalanceCalculatedBaseOnPrimaryToken(fromAddress, symbolToPlayTxSizeFee,
                symbolChargedForBaseFee, amountChargedForBaseFee);
            
            var balancePlusAllowance = balance.Add(allowance);

            if (allowance >= txSizeFeeAmount)
            {
                availableSymbol = symbolToPlayTxSizeFee;
                break;
            }

            if (delegations == null && balancePlusAllowance > 0)
            {
                availableSymbolWithAnything ??= symbolToPlayTxSizeFee;
            }

            if (balancePlusAllowance < txSizeFeeAmount) continue;

            if (allowance > 0)
            {
                availableSymbolWithEnoughBalancePlusAllowance ??= symbolToPlayTxSizeFee;
            }
            else
            {
                availableSymbolWithEnoughBalance ??= symbolToPlayTxSizeFee;
            }
        }

        availableSymbol ??= availableSymbolWithEnoughBalancePlusAllowance ??
                            availableSymbolWithEnoughBalance ?? availableSymbolWithAnything;

        return availableSymbol;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L621-642)
```csharp
        var isPrimaryTokenExist = false;
        var symbolList = new List<string>();
        var primaryTokenSymbol = GetPrimaryTokenSymbol(new Empty());
        Assert(!string.IsNullOrEmpty(primaryTokenSymbol.Value), "primary token does not exist");
        foreach (var tokenWeightInfo in input.SymbolsToPayTxSizeFee)
        {
            if (tokenWeightInfo.TokenSymbol == primaryTokenSymbol.Value)
            {
                isPrimaryTokenExist = true;
                Assert(tokenWeightInfo.AddedTokenWeight == 1 && tokenWeightInfo.BaseTokenWeight == 1,
                    $"symbol:{tokenWeightInfo.TokenSymbol} weight should be 1");
            }

            Assert(tokenWeightInfo.AddedTokenWeight > 0 && tokenWeightInfo.BaseTokenWeight > 0,
                $"symbol:{tokenWeightInfo.TokenSymbol} weight should be greater than 0");
            Assert(!symbolList.Contains(tokenWeightInfo.TokenSymbol),
                $"symbol:{tokenWeightInfo.TokenSymbol} repeat");
            AssertSymbolToPayTxFeeIsValid(tokenWeightInfo.TokenSymbol, out var addedTokenTotalSupply);
            symbolList.Add(tokenWeightInfo.TokenSymbol);
        }

        Assert(isPrimaryTokenExist, $"primary token:{primaryTokenSymbol.Value} not included");
```
