### Title
Missing Cross-Contract State Paths in ACS2 Resource Declaration Enables DoS via Transfer Callbacks

### Summary
The `GetResourceInfo` implementation for `Transfer` and `TransferFrom` methods only declares state paths within the MultiToken contract, but these methods can trigger cross-contract calls via `Context.SendInline` when tokens have transfer callbacks configured. This causes the parallel execution system to incorrectly group conflicting transactions together, leading to post-execution conflict detection that permanently marks the entire MultiToken contract as non-parallelizable, effectively DoS'ing all token operations on the blockchain.

### Finding Description

The vulnerability exists in the ACS2 state path provider implementation. [1](#0-0) 

The `GetResourceInfo` method only declares `WritePaths` scoped to the MultiToken contract address (`Context.Self`), including balance paths and transaction fee paths. [2](#0-1) 

However, the `Transfer` method calls `DealWithExternalInfoDuringTransfer` which can invoke external contract callbacks. [3](#0-2) 

When a token's `ExternalInfo` contains `TransferCallbackExternalInfoKey`, the system calls `Context.SendInline` to invoke a callback contract method, which modifies state in that external contract. [4](#0-3) 

The callback constant is defined as a public feature. [5](#0-4) 

During parallel execution, transactions are grouped based on declared resource paths. [6](#0-5) 

Since cross-contract paths aren't declared, multiple Transfer transactions with callbacks to the same contract are grouped for parallel execution. The system tracks actual state accesses including those from inline transactions. [7](#0-6) 

After execution, conflict detection compares declared paths against actual accessed paths. [8](#0-7) 

When actual accesses exceed declared paths, the MultiToken contract is marked as non-parallelizable. [9](#0-8) 

### Impact Explanation

**Operational Impact - DoS of Entire Token System:**

Once triggered, the MultiToken contract is permanently marked as non-parallelizable, forcing ALL token operations to execute sequentially rather than in parallel. This affects:
- All Transfer, TransferFrom, Approve, Burn operations across ALL tokens
- Cross-chain token transfers
- Token issuance and creation
- NFT transfers and approvals

The attack degrades blockchain throughput by orders of magnitude since token operations are among the most frequent transaction types. The marking persists across blocks, causing permanent performance degradation until manual intervention.

All blockchain users are affected, not just users of the attacker's token. The attacker achieves system-wide DoS with minimal cost.

### Likelihood Explanation

**High Exploitability:**

**Attacker Capabilities Required:**
- Create a token with ExternalInfo containing transfer callback configuration (publicly accessible Create method)
- Deploy a simple callback contract that modifies state
- Submit multiple Transfer transactions for that token

**Attack Complexity:** Low
- No special permissions needed beyond normal token creation
- Attack execution is straightforward: create token â†’ submit parallel transfers
- Callback configuration is a documented feature with defined constants

**Feasibility Conditions:**
- Token creation is unrestricted for addresses in the whitelist or with SEED NFTs
- ExternalInfo accepts arbitrary key-value pairs with no validation on callback addresses
- Transfer is a public method callable by any token holder

**Detection Difficulty:**
- Attack appears as normal token transfers initially
- Only detected after execution when conflicts emerge
- By then, the non-parallelizable marking is already applied

**Economic Rationality:**
- Attack cost: token creation fee + a few transfer transaction fees
- Impact: system-wide token operation slowdown
- Cost-benefit heavily favors the attacker

### Recommendation

**Immediate Fix:**

1. **Declare Cross-Contract Paths:** Modify `GetResourceInfo` in `TokenContract_ACS2_StatePathsProvider.cs` to declare state paths for callback contracts when tokens have transfer callbacks configured:

```csharp
// In GetResourceInfo for Transfer/TransferFrom
var tokenInfo = GetTokenInfo(args.Symbol);
if (tokenInfo?.ExternalInfo?.Value?.ContainsKey(
    TokenContractConstants.TransferCallbackExternalInfoKey) == true)
{
    var callbackInfo = JsonParser.Default.Parse<CallbackInfo>(
        tokenInfo.ExternalInfo.Value[TransferCallbackExternalInfoKey]);
    // Add ScopedStatePath with callbackInfo.ContractAddress
    resourceInfo.WritePaths.Add(new ScopedStatePath
    {
        Address = callbackInfo.ContractAddress,
        Path = new StatePath { Parts = { "*" } } // Or specific paths if determinable
    });
}
```

2. **Alternative - Mark as Non-Parallelizable:** If callback target paths cannot be determined statically, mark Transfer/TransferFrom as non-parallelizable when callbacks exist:

```csharp
var tokenInfo = GetTokenInfo(args.Symbol);
if (tokenInfo?.ExternalInfo?.Value?.ContainsKey(
    TokenContractConstants.TransferCallbackExternalInfoKey) == true)
{
    return new ResourceInfo { NonParallelizable = true };
}
```

3. **Add Validation:** Restrict callback configuration to authorized addresses only, or maintain a whitelist of approved callback contracts.

4. **Test Coverage:** Add integration tests that verify parallel execution of Transfer transactions with callbacks correctly handles conflicts without marking the contract non-parallelizable.

### Proof of Concept

**Initial State:**
- MultiToken contract is deployed and parallelizable
- Blockchain processes token transfers in parallel

**Attack Sequence:**

1. **Token Creation:** Attacker creates a token with ExternalInfo:
   - Key: `"aelf_transfer_callback"`
   - Value: `{"contract_address":"<callback_contract>","method_name":"OnTransfer"}`

2. **Deploy Callback Contract:** Simple contract that writes to its state on `OnTransfer` method call

3. **Submit Parallel Transfers:** Attacker submits 5 Transfer transactions for the callback-enabled token in a single block

4. **Execution:** TransactionGrouper sees no conflicting paths (only MultiToken paths declared), groups all 5 for parallel execution

5. **Inline Callbacks:** Each Transfer executes its callback, modifying callback contract state

6. **Conflict Detection:** System detects actual state accesses in callback contract weren't declared

7. **Contract Marked:** ConflictingTransactionsFoundInParallelGroupsEventHandler marks MultiToken as non-parallelizable

**Expected Result:** Transfers execute in parallel without conflicts

**Actual Result:** 
- Conflicting transactions marked with CONFLICT status
- MultiToken contract marked non-parallelizable
- All subsequent token operations execute sequentially
- Blockchain throughput severely degraded

**Success Condition:** Query `INonparallelContractCodeProvider` for MultiToken contract address - it will be listed as non-parallelizable.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L15-38)
```csharp
            case nameof(Transfer):
            {
                var args = TransferInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), txn.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol)
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };

                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L98-111)
```csharp
    private ScopedStatePath GetPath(params string[] parts)
    {
        return new ScopedStatePath
        {
            Address = Context.Self,
            Path = new StatePath
            {
                Parts =
                {
                    parts
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-13)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/TransactionGrouper.cs (L128-130)
```csharp
            foreach (var resource in transactionResourceInfo.WritePaths.Concat(transactionResourceInfo.ReadPaths)
                         .Where(p => !readOnlyPaths.Contains(p))
                         .Select(p => p.GetHashCode()))
```

**File:** src/AElf.Kernel.Types/Transaction/TransactionTrace.cs (L53-67)
```csharp
    public IEnumerable<KeyValuePair<string, bool>> GetFlattenedReads()
    {
        foreach (var trace in PreTraces)
        foreach (var kv in trace.GetFlattenedReads())
            yield return kv;

        foreach (var kv in StateSet.Reads) yield return kv;

        foreach (var trace in InlineTraces)
        foreach (var kv in trace.GetFlattenedReads())
            yield return kv;

        foreach (var trace in PostTraces)
        foreach (var kv in trace.GetFlattenedReads())
            yield return kv;
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/ConflictingTransactionIdentificationService.cs (L63-68)
```csharp
            var extracted = new HashSet<string>(txnWithResource.TransactionResourceInfo.WritePaths
                .Concat(txnWithResource.TransactionResourceInfo.ReadPaths).Select(p => p.ToStateKey()));
            extracted.ExceptWith(readOnlyKeys);
            var actual = GetKeys(returnSetLookup[txnWithResource.Transaction.GetHash()]);
            actual.ExceptWith(extracted);
            if (actual.Count == 0) continue;
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Application/ConflictingTransactionsFoundInParallelGroupsEventHandler.cs (L39-49)
```csharp
        var dic = wrongTxWithResources.GroupBy(t => t.Transaction.To)
            .ToDictionary(g => g.Key, g => new NonparallelContractCode
            {
                CodeHash = g.First().TransactionResourceInfo.ContractHash
            });

        await _nonparallelContractCodeProvider.SetNonparallelContractCodeAsync(new BlockIndex
        {
            BlockHash = eventData.BlockHeader.GetHash(),
            BlockHeight = eventData.BlockHeader.Height
        }, dic);
```
