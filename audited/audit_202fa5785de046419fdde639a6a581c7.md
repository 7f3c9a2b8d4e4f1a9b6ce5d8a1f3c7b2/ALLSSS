### Title
State Bloat DOS Through Unlimited TokenHolder Scheme Creation

### Summary
The `CreateScheme()` function in TokenHolderContract allows any user to repeatedly create profit schemes without checking if one already exists, causing orphaned schemes to accumulate in the Profit contract. While each call costs 10 ELF as a transaction fee, a motivated attacker can create hundreds or thousands of schemes, causing permanent state bloat that affects all validators and cannot be cleaned up.

### Finding Description

The vulnerability exists in the `CreateScheme()` method which performs two critical operations without proper coordination: [1](#0-0) 

First, it calls the Profit contract to create a new scheme with the sender as manager: [2](#0-1) 

Then it stores the scheme configuration in TokenHolder's state using `Context.Sender` as the key: [3](#0-2) 

The root cause is that TokenHolder only maintains ONE scheme reference per sender address in its state mapping: [4](#0-3) 

However, each call to Profit's `CreateScheme` generates a unique scheme ID based on the manager's current scheme count and creates a NEW scheme in the Profit contract: [5](#0-4) 

The scheme ID generation increments with each call: [6](#0-5) 

All schemes are permanently stored with no deletion mechanism: [7](#0-6) 

And the manager's scheme list grows indefinitely: [8](#0-7) 

When `CreateScheme` is called multiple times by the same sender:
1. Each call creates a NEW scheme in Profit contract with a unique ID
2. TokenHolder overwrites its single reference, losing track of previous schemes
3. Old schemes become orphaned - they exist in Profit contract state but are unreferenced by TokenHolder
4. No cleanup or deletion mechanism exists to remove these orphaned schemes

There is no validation to prevent repeated calls or limit the number of schemes per manager. The only protection is the method fee: [9](#0-8) 

### Impact Explanation

**Permanent State Bloat:**
- Each orphaned scheme consumes storage in `State.SchemeInfos[schemeId]` 
- The `State.ManagingSchemeIds[manager].SchemeIds` list grows indefinitely
- State bloat is permanent as there is no scheme deletion functionality
- Affects all validators who must maintain the full state

**Quantified Impact:**
- Each scheme stores: scheme ID, virtual address, manager, settings, beneficiary lists, profit distribution history
- 1,000 orphaned schemes could consume megabytes of state storage
- 10,000 schemes would cost the attacker 100,000 ELF (~$100k-$1M USD depending on price) but causes permanent storage burden across entire validator network

**Affected Parties:**
- All validators bear increased storage and sync costs
- Network performance degrades as state size grows
- Future users face slower queries when interacting with Profit contract

**Severity Justification (Medium):**
- Attack requires significant capital (10 ELF per scheme) providing economic deterrent
- Impact is cumulative and permanent but doesn't directly steal funds or break consensus
- Could degrade network performance over time if exploited at scale

### Likelihood Explanation

**Reachability:** The `CreateScheme` method is a public function callable by any address without special permissions.

**Attacker Capabilities:**
- Requires only an account with sufficient ELF balance
- No special privileges or contract control needed
- Simple repeated transaction submission

**Attack Complexity:**
- Trivial to execute: repeatedly call `CreateScheme()` with same parameters
- Can be automated with a simple script
- No complex timing or state manipulation required

**Economic Feasibility:**
- Cost: 10 ELF per scheme creation
- Creating 1,000 schemes = 10,000 ELF
- Creating 10,000 schemes = 100,000 ELF
- While expensive, this is within reach of a well-funded attacker or malicious actor
- The permanent state bloat imposed on the network may exceed attacker's costs

**Detection:** Repeated `CreateScheme` calls from the same address would be visible on-chain but may not trigger immediate response if executed slowly over time.

### Recommendation

**Immediate Fix:**
Add a check in `TokenHolderContract.CreateScheme()` to prevent creating multiple schemes for the same sender:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Check if scheme already exists for this sender
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists for this address.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

**Additional Hardening:**
1. Consider implementing a scheme update function instead of allowing recreation
2. Add a maximum limit per address in Profit contract (similar to `MaximumProfitReceivingDuePeriodCount`)
3. Implement scheme cleanup/deletion functionality if schemes become truly unused
4. Add monitoring for addresses creating excessive schemes

**Test Cases:**
1. Verify `CreateScheme` succeeds on first call
2. Verify `CreateScheme` fails with assertion on second call from same address
3. Verify different addresses can each create one scheme
4. Test that existing scheme can be queried after failed second creation attempt

### Proof of Concept

**Initial State:**
- Attacker has address `ATTACKER_ADDR` with 10,000 ELF balance
- No existing TokenHolder scheme for `ATTACKER_ADDR`

**Attack Sequence:**

1. **First Call:** `ATTACKER_ADDR` calls `CreateScheme({Symbol: "ELF", MinimumLockMinutes: 1})`
   - Profit contract creates scheme with ID = `Hash_1` (based on count = 0)
   - TokenHolder stores: `State.TokenHolderProfitSchemes[ATTACKER_ADDR] = {scheme_id: null, symbol: "ELF"}`
   - Profit contract stores: `State.ManagingSchemeIds[ATTACKER_ADDR].SchemeIds = [Hash_1]`
   - Cost: 10 ELF

2. **Second Call:** `ATTACKER_ADDR` calls `CreateScheme({Symbol: "APP", MinimumLockMinutes: 1})`
   - Profit contract creates NEW scheme with ID = `Hash_2` (based on count = 1)
   - TokenHolder OVERWRITES: `State.TokenHolderProfitSchemes[ATTACKER_ADDR] = {scheme_id: null, symbol: "APP"}`
   - Profit contract stores: `State.ManagingSchemeIds[ATTACKER_ADDR].SchemeIds = [Hash_1, Hash_2]`
   - Scheme `Hash_1` is now orphaned - exists in Profit but unreferenced by TokenHolder
   - Cost: 10 ELF

3. **Repeat N times:** Continue calling `CreateScheme` with varying parameters
   - Each call creates scheme `Hash_3`, `Hash_4`, ... `Hash_N`
   - All previous schemes become orphaned
   - `State.ManagingSchemeIds[ATTACKER_ADDR].SchemeIds` grows to N entries
   - Total orphaned schemes: N-1
   - Total cost: N Ã— 10 ELF

**Expected Result:** Only ONE scheme reference exists in TokenHolder, but N schemes exist in Profit contract state.

**Actual Result:** N schemes are created in Profit contract, N-1 are orphaned, consuming permanent state storage with no cleanup mechanism. Attack succeeds in creating state bloat proportional to number of calls.

**Success Condition:** Query `ProfitContract.GetManagingSchemeIds(ATTACKER_ADDR)` returns list with N scheme IDs, but `TokenHolderContract.GetScheme(ATTACKER_ADDR)` only references the last one, confirming N-1 orphaned schemes exist.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L10-10)
```csharp
    public MappedState<Address, TokenHolderProfitScheme> TokenHolderProfitSchemes { get; set; }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L56-71)
```csharp
        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
        State.SchemeInfos[schemeId] = scheme;

        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractState.cs (L9-9)
```csharp
    public MappedState<Hash, Scheme> SchemeInfos { get; set; }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractState.cs (L15-15)
```csharp
    public MappedState<Address, CreatedSchemeIds> ManagingSchemeIds { get; set; }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L42-49)
```csharp
            case nameof(CreateScheme):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
```
