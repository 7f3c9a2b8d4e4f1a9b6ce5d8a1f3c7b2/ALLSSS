### Title
Missing Authorization Check in Secret Sharing Allows Malicious Miners to Corrupt Consensus InValue Reconstruction

### Summary
The `PerformSecretSharing` function does not validate whether a miner was authorized to decrypt secret pieces from other miners before accepting their `DecryptedPieces` input. A malicious miner can inject arbitrary decrypted values for any miner, corrupting the Shamir's Secret Sharing reconstruction process and causing incorrect InValue revelation, which disrupts consensus integrity and can falsely implicate honest miners as malicious actors.

### Finding Description

The vulnerability exists in the `PerformSecretSharing` function where `input.DecryptedPieces` is processed without authorization validation: [1](#0-0) 

**Root Cause**: The contract blindly accepts any entries in `input.DecryptedPieces` without verifying that the target miner (the key) actually provided an encrypted piece for the current miner (publicKey) in the previous round. The expected validation would check if `previousRound.RealTimeMinersInformation[targetMinerKey].EncryptedPieces.ContainsKey(publicKey)` before accepting the decrypted piece.

**Why Existing Protections Fail**: 
- The `PreCheck` function only validates that the sender is in the current/previous miner list, not whether specific decryption operations are authorized: [2](#0-1) 

- The off-chain `SecretSharingService` correctly checks authorization when generating legitimate decrypted pieces: [3](#0-2) 

However, the on-chain contract does not enforce this same check, allowing malicious miners to bypass the off-chain validation by crafting custom `UpdateValueInput` transactions.

**Execution Path**:
1. Honest miners encrypt secret shares in Round N and store them in `EncryptedPieces`
2. In Round N+1, malicious miner submits `UpdateValue` with fabricated `DecryptedPieces` entries
3. Contract stores these without validation via `PerformSecretSharing`
4. Later, `RevealSharedInValues` uses all accumulated `DecryptedPieces` (including bogus ones) to reconstruct InValues: [4](#0-3) 

5. The Shamir's Secret Sharing reconstruction produces incorrect results when bogus pieces are included: [5](#0-4) 

6. The incorrect InValue fails validation against the victim's previous OutValue: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Violation**: A malicious miner can inject false decrypted pieces for any victim miner, causing the Shamir's Secret Sharing reconstruction to produce an incorrect InValue. This corrupted InValue will fail the validation check `HashHelper.ComputeFrom(previousInValue) == previousOutValue`, making the honest victim miner appear to have provided invalid consensus data.

**Concrete Harm**:
- **Consensus Disruption**: Incorrect InValue reconstruction breaks the secret sharing protocol and consensus validation for affected rounds
- **Randomness Corruption**: Since InValues feed into random number generation, this compromises the randomness source for consensus
- **False Accusations**: Honest miners appear malicious due to validation failures, potentially triggering penalties or evil node marking: [7](#0-6) 

- **Operational DoS**: Systematic attacks across multiple rounds could prevent consensus progress

**Who Is Affected**: All honest miners in the consensus set can be victims. The protocol's consensus integrity and randomness guarantees are compromised.

**Severity Justification**: HIGH - This violates a critical consensus invariant (correct InValue reconstruction) and allows any miner to disrupt consensus and falsely implicate honest participants without detection at submission time.

### Likelihood Explanation

**Attacker Capabilities**: Any miner in the consensus set can execute this attack. No special privileges, contract ownership, or governance control is required beyond being an active miner.

**Attack Complexity**: LOW
- Attacker simply crafts an `UpdateValueInput` with arbitrary `DecryptedPieces` entries
- The attack leverages the public `UpdateValue` method that all miners use: [8](#0-7) 

- No complex state manipulation or timing requirements

**Feasibility Conditions**: 
- Attacker must be a valid miner (passes PreCheck)
- Secret sharing must be enabled (checked at line 254): [9](#0-8) 

- Attack is repeatable every round

**Detection Constraints**: The attack is undetectable at transaction submission time because:
- The contract accepts any `DecryptedPieces` values without validation
- There's no way to verify decryption correctness on-chain without the original encrypted pieces and private keys
- The corruption only becomes apparent later during InValue reconstruction

**Economic Rationality**: The attack costs no more than a normal UpdateValue transaction. The attacker gains the ability to disrupt consensus and harm competitors' reputations at minimal cost.

### Recommendation

**Immediate Fix**: Add authorization validation in `PerformSecretSharing` to verify that each target miner actually provided an encrypted piece for the current miner:

```csharp
private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
    string publicKey, Round previousRound)
{
    minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
    
    foreach (var decryptedPreviousInValue in input.DecryptedPieces)
    {
        var targetMinerKey = decryptedPreviousInValue.Key;
        
        // CRITICAL: Validate that targetMiner encrypted a piece for publicKey in previous round
        if (previousRound?.RealTimeMinersInformation != null &&
            previousRound.RealTimeMinersInformation.ContainsKey(targetMinerKey))
        {
            var targetMinerPreviousRound = previousRound.RealTimeMinersInformation[targetMinerKey];
            if (!targetMinerPreviousRound.EncryptedPieces.ContainsKey(publicKey))
            {
                // Target miner never encrypted a piece for current miner - reject
                continue; // or Assert(false, "Unauthorized decryption attempt")
            }
        }
        else
        {
            continue; // Target miner not in previous round
        }
        
        round.RealTimeMinersInformation[targetMinerKey].DecryptedPieces
            .Add(publicKey, decryptedPreviousInValue.Value);
    }

    foreach (var previousInValue in input.MinersPreviousInValues)
        round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
}
```

**Required Changes**:
1. Pass `previousRound` as parameter to `PerformSecretSharing`
2. Retrieve previous round before calling: [10](#0-9) 
3. Add the authorization check before storing decrypted pieces

**Invariant to Enforce**: A miner can only provide decrypted pieces for miners who previously encrypted pieces specifically for them in the prior round.

**Test Cases**: 
- Test that legitimate decrypted pieces are accepted
- Test that DecryptedPieces for non-existent miners are rejected
- Test that DecryptedPieces for miners who didn't encrypt for the sender are rejected
- Test that malicious UpdateValueInput with unauthorized DecryptedPieces fails or is ignored

### Proof of Concept

**Initial State**:
- 4 miners in Round N: Alice, Bob, Charlie, Mallory (malicious)
- Bob generates InValue and encrypts shares: `Bob.EncryptedPieces = {"Alice": enc_A, "Charlie": enc_C, "Mallory": enc_M}`
- Bob does NOT encrypt anything for a fifth party "Eve"

**Attack Sequence**:
1. Round N+1 begins, miners submit UpdateValue transactions
2. Alice submits legitimate `UpdateValue` with `DecryptedPieces["Bob"] = validly_decrypted_piece`
3. Charlie submits legitimate `UpdateValue` with `DecryptedPieces["Bob"] = validly_decrypted_piece`
4. **Mallory submits malicious UpdateValue**:
   ```
   UpdateValueInput {
     DecryptedPieces: {
       "Bob": <arbitrary_bogus_32_bytes>  // Invalid decryption
     }
   }
   ```
5. Contract processes Mallory's transaction via `PerformSecretSharing` (line 291-293)
6. Contract stores without validation: `Bob.DecryptedPieces["Mallory"] = <bogus_bytes>`
7. Later, `RevealSharedInValues` is called (line 189 of GetConsensusBlockExtraData)
8. Function checks: `Bob.DecryptedPieces.Count >= minersCount` (line 36 of SecretSharing)
9. Now Bob has pieces from Alice, Charlie, Mallory (including bogus one)
10. `SecretSharingHelper.DecodeSecret` reconstructs using all pieces including bogus one (line 49-50)

**Expected Result**: Only DecryptedPieces from miners who received EncryptedPieces should be accepted. Mallory's entry should be rejected.

**Actual Result**: Mallory's bogus DecryptedPiece is accepted, causing Bob's reconstructed InValue to be incorrect, which later fails validation and marks Bob as providing invalid consensus data.

**Success Condition**: Bob's InValue is corrupted, consensus validation fails for Bob's previous round data, and Bob may be marked as an evil node despite being honest.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-267)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L125-138)
```csharp
            if (!secretSharingInformation.PreviousRound.RealTimeMinersInformation.ContainsKey(pubkey)) continue;

            var encryptedShares =
                secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].EncryptedPieces;
            if (!encryptedShares.Any() || !encryptedShares.ContainsKey(selfPubkey)) continue;
            var interestingMessage = encryptedShares[selfPubkey];
            var senderPublicKey = ByteArrayHelper.HexStringToByteArray(pubkey);

            var decryptedPiece =
                await _accountService.DecryptMessageAsync(senderPublicKey, interestingMessage.ToByteArray());
            decryptedPieces[pubkey] = decryptedPiece;
            secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].DecryptedPieces[selfPubkey]
                = ByteString.CopyFrom(decryptedPiece);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-50)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L44-48)
```csharp
        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** protobuf/aedpos_contract.proto (L29-31)
```text
    // Update consensus information.
    rpc UpdateValue (UpdateValueInput) returns (google.protobuf.Empty) {
    }
```
