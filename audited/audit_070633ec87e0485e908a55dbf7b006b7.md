### Title
Decimal Overflow in TokenConverter Bancor Price Calculation Causes Buy Function DoS

### Summary
The `GetAmountToPayFromReturn()` function in BancorHelper can encounter decimal overflow when calculating token swap prices with large weight ratios and purchase amounts approaching 50% of available supply. The multiplication `bf * (Exp(y * Ln(x)) - decimal.One)` at line 93 can exceed decimal.MaxValue (~7.9×10²⁸), causing the transaction to revert with OverflowException and rendering the Buy function inoperable for affected connector pairs.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:**

The Bancor formula calculates the amount to pay as: `amountToPay = fromConnectorBalance * (x^y - 1)` where:
- `x = toConnectorBalance / (toConnectorBalance - amountToReceive)` 
- `y = toConnectorWeight / fromConnectorWeight`

The calculation at line 93 performs: `bf * (Exp(y * Ln(x)) - decimal.One)` without bounds checking on intermediate or final results.

**Why Protections Fail:**

1. **Connector weights** are validated to be between 0 and 1, but their *ratio* `y = wt/wf` can be very large (e.g., 0.99/0.01 = 99). [2](#0-1) 

2. **Ln function constraint** limits `x` to values less than 2 (meaning users cannot buy more than ~50% of supply in one transaction), but this still allows `Ln(x)` ≈ 0.693. [3](#0-2) 

3. **No overflow validation** before calling `Exp()` or performing the multiplication. The product `y * Ln(x)` can exceed ~66.3, causing `Exp(y * Ln(x))` to overflow decimal.MaxValue.

4. **CheckForOverflowUnderflow is enabled**, so overflow throws OverflowException instead of wrapping, causing transaction revert. [4](#0-3) 

**Execution Path:**

The Buy function calls GetAmountToPayFromReturn with connector parameters: [5](#0-4) 

### Impact Explanation

**Harm:**
- **Denial of Service**: The Buy function becomes completely unusable for affected connector pairs when users attempt large purchases
- **Operational disruption**: Token conversion functionality is disabled until governance reconfigures connectors or users limit purchase amounts
- **No direct fund loss**: Transactions revert before any state changes, so no tokens are stolen or minted incorrectly

**Who is Affected:**
- Users attempting to purchase tokens through affected connector pairs
- The protocol's token conversion liquidity and utility
- Any services depending on reliable token conversion

**Severity Justification:**
High severity due to complete DoS of core token conversion functionality, though no direct fund theft occurs.

### Likelihood Explanation

**Attacker Capabilities:**
- No special privileges required - any user can trigger by calling Buy()
- Governance can inadvertently create vulnerable configurations through normal connector management

**Attack Complexity:**
Low complexity - single transaction calling Buy() with calculated amount approaching 50% of supply

**Feasibility Conditions:**

1. **Governance configures connectors with large weight ratio** - Example from production initialization shows weights like 0.5 and 0.005 are used: [6](#0-5) 
   Governance can add pairs via AddPairConnector with arbitrary weights in valid (0,1) range: [7](#0-6) 

2. **Balances accumulate over time** - As tokens are traded, balances naturally grow toward long.MaxValue (~9.2×10¹⁸)

3. **User purchases large amount** - Requesting ~40-50% of available supply is economically rational for whales or arbitrageurs

**Probability:**
Medium-to-High. While extreme weight ratios (99:1) are less likely in practice, moderate ratios (10:1 to 20:1) combined with natural balance growth make this exploitable over time.

### Recommendation

**Code-Level Mitigation:**

Add overflow protection before expensive calculations in GetAmountToPayFromReturn:

```csharp
public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
    long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
{
    // ... existing validation ...
    
    var x = bt / (bt - a);
    var y = wt / wf;
    
    // ADD: Validate y * Ln(x) is within safe bounds before calling Exp
    var exponentInput = y * Ln(x);
    if (exponentInput > 65m) // ln(decimal.MaxValue / max_expected_bf)
        throw new InvalidValueException("Purchase amount too large - would cause overflow");
    
    var expResult = Exp(exponentInput);
    
    // ADD: Validate multiplication won't overflow
    if (expResult > decimal.MaxValue / bf)
        throw new InvalidValueException("Price calculation overflow - reduce purchase amount");
    
    return (long)(bf * (expResult - decimal.One));
}
```

**Invariant Checks:**

1. Add maximum weight ratio constraint in connector validation: `y = wt/wf < 20` (configurable threshold)
2. Add purchase amount limit relative to available supply: `amountToReceive < 0.4 * toConnectorBalance` (40% limit)
3. Add connector balance limits to prevent accumulation near long.MaxValue

**Test Cases:**

1. Test with maximum valid weight ratio (e.g., 0.99/0.01 = 99) and large purchase amounts
2. Test with maximum connector balances (near long.MaxValue) and moderate weight ratios  
3. Test boundary conditions where `y * Ln(x)` ≈ 66
4. Verify appropriate error messages for rejected transactions

### Proof of Concept

**Required Initial State:**

Governance configures connector pair via AddPairConnector:
- `fromConnector` (ntRESOURCE): weight = "0.01", virtual balance = 10,000,000,000,000,000 (1×10¹⁶ satoshi)
- `toConnector` (RESOURCE): weight = "0.99", balance = 10,000,000,000,000,000 (1×10¹⁶ satoshi)

**Transaction Steps:**

1. User calls `Buy()` with:
   - `symbol`: "RESOURCE"
   - `amount`: 4,995,000,000,000,000 (49.95% of available supply)
   - `payLimit`: 0 (no limit)

2. Function calculates at line 93:
   - `bf` = 1×10¹⁶
   - `x` = 1×10¹⁶ / (1×10¹⁶ - 4.995×10¹⁵) ≈ 1.998
   - `y` = 0.99 / 0.01 = 99
   - `y * Ln(x)` = 99 × 0.692 ≈ 68.5
   - `Exp(68.5)` ≈ 1.5×10²⁹

**Expected vs Actual Result:**

- **Expected**: Function returns calculated amountToPay and completes purchase
- **Actual**: OverflowException thrown during Exp(68.5) calculation or subsequent multiplication, transaction reverts

**Success Condition:**

Transaction reverts with System.OverflowException, demonstrating that Buy() function is inoperable for this connector configuration when large purchase amounts are requested.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L67-94)
```csharp
    public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = amountToReceive;
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }

        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L124-143)
```csharp
    private static decimal Ln(decimal a)
    {
        /*
        ln(a) = log(1-x) = - x - x^2/2 - x^3/3 - ...   (where |x| < 1)
            x: a = 1-x    =>   x = 1-a = 1 - 1.004 = -.004
        */
        var x = 1 - a;
        if (Math.Abs(x) >= 1)
            throw new InvalidValueException("must be 0 < a < 2");

        decimal result = 0;
        uint iteration = _LOOPS;
        while (iteration > 0)
        {
            result -= Pow(x, iteration) / iteration;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-110)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-127)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** contract/AElf.Contracts.TokenConverter/AElf.Contracts.TokenConverter.csproj (L11-16)
```text
    <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
    <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L220-250)
```csharp
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.5",
                VirtualBalance = EconomicContractConstants.NativeTokenConnectorInitialVirtualBalance
            }
        };
        foreach (var resourceTokenSymbol in Context.Variables
                     .GetStringArray(EconomicContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(EconomicContractConstants.PayRentalSymbolListName)))
        {
            var resourceTokenConnector = new Connector
            {
                Symbol = resourceTokenSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.ResourceTokenInitialVirtualBalance,
                RelatedSymbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsDepositAccount = false
            };
            var nativeTokenConnector = new Connector
            {
                Symbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
                RelatedSymbol = resourceTokenSymbol,
                IsDepositAccount = true
            };
            connectors.Add(resourceTokenConnector);
```
