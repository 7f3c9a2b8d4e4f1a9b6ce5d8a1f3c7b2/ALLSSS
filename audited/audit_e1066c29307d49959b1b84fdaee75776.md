### Title
No Rollback Mechanism for MainChainCurrentMinerList and MainChainRoundNumber After Parent Chain Reorganization

### Summary
The side chain consensus contract lacks any mechanism to rollback or update `MainChainCurrentMinerList` and `MainChainRoundNumber` if the parent chain experiences a reorganization after the side chain has already indexed and applied parent chain consensus data. The update logic only permits increases in round numbers, creating a one-way synchronization that cannot recover from parent chain reorganizations, hard forks, or consensus failures.

### Finding Description

The cross-chain consensus synchronization flow operates as follows:

1. **Parent chain data serving**: The parent chain serves only irreversible blocks (LIB) to side chains via the gRPC interface. [1](#0-0) 

2. **Parent chain data retrieval**: Blocks are retrieved via `GetNotIndexedIrreversibleBlockByHeightAsync`, which only returns blocks that have reached irreversible status. [2](#0-1) 

3. **Side chain indexing**: After miners propose and release cross-chain indexing proposals, the cross-chain contract calls `IndexParentChainBlockData`, which extracts consensus extra data from the last parent chain block and calls `UpdateConsensusInformation`. [3](#0-2) 

4. **Consensus state update**: The `UpdateInformationFromCrossChain` method updates the consensus state with parent chain data. [4](#0-3) 

**Root Cause**: The critical vulnerability is in the update guard condition that only allows updates when the round number strictly increases: [5](#0-4) 

This one-way check prevents any rollback or correction if the parent chain reorganizes to a state with a lower or equal round number. The state variables are only written in this single location (for cross-chain updates): [6](#0-5) 

The state variables are defined as persistent contract state with no reset mechanism: [7](#0-6) 

**Why existing protections fail**:
- The side chain's own blockchain reorganization mechanism (`ResetChainToLibAsync`) only resets chain structure metadata (marks blocks as unexecuted/unlinked, resets chain pointers) but does not rollback already-merged contract state. [8](#0-7) 
- Once the side chain's block containing the cross-chain indexing transaction becomes irreversible and its state is merged from `BlockStateSet` to `VersionedState`, the consensus state becomes permanent.
- There is no mechanism to detect or respond to parent chain reorganizations.

### Impact Explanation

**Consensus Integrity Impact**:
The side chain consensus logic uses `MainChainCurrentMinerList` to detect when the parent chain's miner set has changed, which can trigger term transitions on the side chain. [9](#0-8) 

If the parent chain undergoes an exceptional reorganization (hard fork, consensus failure, emergency rollback, or network partition resulting in multiple chains with different LIBs), the side chain will:
- Continue operating with stale/invalid parent chain miner list data
- Fail to detect legitimate parent chain miner list changes on the new canonical fork
- Potentially make incorrect consensus decisions based on outdated parent chain state
- Be unable to synchronize with the parent chain's actual current state due to the round number guard

**Affected parties**: All side chain validators and users whose consensus security depends on accurate parent chain state synchronization.

**Severity justification**: While parent chain reorganizations of irreversible blocks are extremely rare in normal operation, the complete lack of any recovery mechanism represents a critical design gap. The system cannot recover from exceptional but possible scenarios including hard forks, critical consensus bugs, or coordinated emergency rollbacks.

### Likelihood Explanation

**Preconditions required**:
This vulnerability manifests in exceptional scenarios where the parent chain experiences a reorganization affecting previously irreversible blocks. This can occur due to:
- Hard forks (intentional protocol upgrades or contentious splits)
- Critical consensus mechanism bugs causing LIB regression
- Emergency coordinated rollbacks to recover from attacks or bugs
- Network partitions creating multiple chains with different LIB progressions

**Execution complexity**: This is not an active attack vector. The vulnerability manifests passively when the exceptional parent chain scenario occurs. No attacker action is required beyond the parent chain reorganization itself.

**Probability assessment**: 
- In normal operation: Very low (irreversible blocks should not revert)
- In exceptional scenarios: Possible and has historical precedent in blockchain systems
- Risk increases with: longer parent chain LIB confirmation times, parent chain consensus vulnerabilities, contentious governance situations

**Detection**: Currently no monitoring exists to detect parent chain reorganizations or state synchronization divergence.

### Recommendation

**Immediate mitigations**:

1. **Add administrative override function** to allow authorized governance to manually reset `MainChainRoundNumber` and `MainChainCurrentMinerList` in emergency situations:
```csharp
public override Empty ResetMainChainConsensusInformation(ResetMainChainConsensusInput input)
{
    // Only allow parliament or specific emergency controller
    AssertControllerAuthority(Context.Sender);
    
    State.MainChainRoundNumber.Value = input.RoundNumber;
    State.MainChainCurrentMinerList.Value = input.MinerList;
    
    Context.Fire(new MainChainConsensusReset { 
        NewRoundNumber = input.RoundNumber 
    });
    
    return new Empty();
}
```

2. **Modify the update guard** to allow same-or-decreasing round numbers if accompanied by proof of parent chain reorganization or emergency flag:
```csharp
// Instead of strict greater-than check, allow updates with reorganization proof
if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value && 
    !consensusInformation.IsReorganization)
    return new Empty();
```

3. **Add state synchronization verification** that periodically validates the side chain's stored `MainChainRoundNumber` matches the actual parent chain state at that height.

4. **Implement monitoring** to detect divergence between side chain's stored parent chain state and actual parent chain state.

**Long-term improvements**:
- Design a cross-chain reorganization detection and recovery protocol
- Add versioning/fork detection mechanisms for parent chain state
- Implement automated reconciliation when parent chain reorganizations are detected
- Add circuit breakers to pause side chain consensus if parent chain divergence is detected

**Test cases**:
- Test emergency reset function with proper authorization
- Test rejection of unauthorized reset attempts
- Simulate parent chain reorganization scenarios
- Verify monitoring correctly detects state divergence

### Proof of Concept

**Initial state**:
1. Parent chain at height 1000, round 500, with miner list [A, B, C] reaches LIB
2. Side chain successfully indexes this data via cross-chain indexing
3. Side chain state: `MainChainRoundNumber = 500`, `MainChainCurrentMinerList = [A, B, C]`
4. Side chain's indexing transaction becomes irreversible and state is merged to VersionedState

**Exceptional scenario occurs**:
5. Parent chain experiences hard fork or emergency rollback
6. New canonical parent chain at height 1000 has round 495 with miner list [A, B, D]
7. Parent chain continues operating on new fork, new data becomes irreversible

**Expected result**: Side chain should be able to update to new parent chain state

**Actual result**: 
8. Parent chain serves new block data with round 495
9. Side chain's `UpdateInformationFromCrossChain` is called
10. Update is **rejected** because `495 <= 500` (guard at line 46)
11. Side chain remains with `MainChainRoundNumber = 500`, `MainChainCurrentMinerList = [A, B, C]`
12. Side chain cannot synchronize with actual parent chain state
13. No mechanism exists to rollback or correct the stale state

**Success condition**: The vulnerability is confirmed when the side chain cannot update its parent chain consensus state after a parent chain reorganization results in a lower or equal round number at the same height.

**Notes**:
- This finding focuses on the lack of resilience mechanisms for exceptional but possible parent chain reorganization scenarios
- The vulnerability exists in the design assumption that parent chain irreversible blocks will never be reverted
- While the likelihood of parent chain LIB reorganizations is low in normal operation, the complete absence of recovery mechanisms represents a critical gap in cross-chain security architecture
- The impact severity depends on how critical accurate parent chain miner list synchronization is for side chain consensus decisions

### Citations

**File:** src/AElf.CrossChain.Core/Application/CrossChainResponseService.cs (L45-63)
```csharp
    public async Task<ParentChainBlockData> ResponseParentChainBlockDataAsync(long requestHeight, int remoteSideChainId)
    {
        var block = await _crossChainIndexingDataService.GetNonIndexedBlockAsync(requestHeight);
        if (block == null)
            return null;
        var parentChainBlockData = new ParentChainBlockData
        {
            Height = block.Height, ChainId = block.Header.ChainId
        };
        parentChainBlockData = FillExtraDataInResponse(parentChainBlockData, block.Header);

        if (parentChainBlockData.CrossChainExtraData == null) return parentChainBlockData;

        var indexedSideChainBlockDataResult = await GetIndexedSideChainBlockDataResultAsync(block);
        var enumerableMerklePath = GetEnumerableMerklePath(indexedSideChainBlockDataResult, remoteSideChainId);
        foreach (var kv in enumerableMerklePath) parentChainBlockData.IndexedMerklePath.Add(kv.Key, kv.Value);

        return parentChainBlockData;
    }
```

**File:** src/AElf.CrossChain.Core/Indexing/Infrastructure/IrreversibleBlockStateProvider.cs (L17-23)
```csharp
    public async Task<Block> GetNotIndexedIrreversibleBlockByHeightAsync(long height)
    {
        var libExistenceValidationResult = await ValidateIrreversibleBlockExistingAsync();
        if (!libExistenceValidationResult)
            return null;
        return await _blockchainService.GetIrreversibleBlockByHeightAsync(height);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L782-788)
```csharp
            // send consensus data shared from main chain  
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-64)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L34-36)
```csharp
    public Int64State MainChainRoundNumber { get; set; }

    public SingletonState<MinerList> MainChainCurrentMinerList { get; set; }
```

**File:** src/AElf.Kernel.Core/Blockchain/Domain/IChainManager.cs (L460-497)
```csharp
    public async Task<Chain> ResetChainToLibAsync(Chain chain)
    {
        var libHash = chain.LastIrreversibleBlockHash;
        var libHeight = chain.LastIrreversibleBlockHeight;

        foreach (var branch in chain.Branches)
        {
            var hash = Hash.LoadFromBase64(branch.Key);
            var chainBlockLink = await GetChainBlockLinkAsync(hash);

            while (chainBlockLink != null && chainBlockLink.Height > libHeight)
            {
                chainBlockLink.ExecutionStatus = ChainBlockLinkExecutionStatus.ExecutionNone;
                chainBlockLink.IsLinked = false;
                await SetChainBlockLinkAsync(chainBlockLink);

                chainBlockLink = await GetChainBlockLinkAsync(chainBlockLink.PreviousBlockHash);
            }
        }

        chain.Branches.Clear();
        chain.NotLinkedBlocks.Clear();

        chain.Branches[libHash.ToStorageKey()] = libHeight;

        chain.BestChainHash = libHash;
        chain.BestChainHeight = libHeight;
        chain.LongestChainHash = libHash;
        chain.LongestChainHeight = libHeight;

        Logger.LogInformation($"Rollback to height {chain.BestChainHeight}, hash {chain.BestChainHash}.");
        await _chains.SetAsync(chain.Id.ToStorageKey(), chain);

        // Update the cache.
        _chainCache[ChainId] = chain;

        return chain;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L349-354)
```csharp
    private bool IsMainChainMinerListChanged(Round currentRound)
    {
        return State.MainChainCurrentMinerList.Value.Pubkeys.Any() &&
               GetMinerListHash(currentRound.RealTimeMinersInformation.Keys) !=
               GetMinerListHash(State.MainChainCurrentMinerList.Value.Pubkeys.Select(p => p.ToHex()));
    }
```
