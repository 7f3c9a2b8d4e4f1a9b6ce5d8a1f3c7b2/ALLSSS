### Title
NFT Metadata Loss When Re-minting Burned Tokens with IsTokenIdReuse Enabled

### Summary
When `IsTokenIdReuse` is true and all tokens of a specific token ID are burned (quantity reaches 0), subsequent re-minting of the same token ID ignores the new minter's Uri, Metadata, and Alias inputs, causing permanent loss of intended NFT data. Additionally, the `NFTMinted` event emits the new metadata values while the actual on-chain state retains the old metadata, creating a critical state-event inconsistency.

### Finding Description

The vulnerability exists in the `PerformMint` function. [1](#0-0) 

**Root Cause:**

When `IsTokenIdReuse` is true (ERC-1155 style), the contract allows the same token ID to be minted multiple times. The `NftInfoMap` state stores NFT information keyed by token hash. [2](#0-1) 

The `IsTokenIdReuse` flag is defined in the protocol info. [3](#0-2) 

**Execution Path:**

1. When burning tokens, if quantity reaches 0 and `IsTokenIdReuse` is true, the NFTInfo entry remains in `NftInfoMap` with quantity=0 (the `IsBurned` flag is only set when `IsTokenIdReuse` is false). [4](#0-3) 

2. On re-minting, `PerformMint` retrieves the existing NFTInfo from state. [5](#0-4) 

3. The uniqueness check is skipped when `IsTokenIdReuse` is true. [6](#0-5) 

4. Since `nftInfo` is not null, the code enters the else block which ONLY updates Quantity and Minters list, completely ignoring the input's Uri, Metadata, and Alias. [7](#0-6) 

5. The updated NFTInfo (with old metadata) is saved back to state. [8](#0-7) 

6. However, the `NFTMinted` event fired includes the NEW metadata, Uri, and Alias from the input, creating a critical discrepancy between event logs and actual on-chain state. [9](#0-8) 

**Why Protections Fail:**

The code prepares fresh metadata from protocol and input (lines 409-413) but never applies it to existing NFTInfo entries. There is no check for whether the existing NFTInfo has quantity=0 (fully burned), which would require different handling than normal quantity additions.

### Impact Explanation

**Direct Harm:**
- **Data Loss:** Minters lose their intended NFT metadata, URI, and alias completely. This data cannot be recovered through normal minting operations.
- **Financial Loss:** Users pay gas fees to mint NFTs but receive tokens with incorrect/unintended metadata that doesn't match their expectations.
- **State-Event Inconsistency:** Off-chain systems, marketplaces, and explorers reading `NFTMinted` events will display different metadata than what exists on-chain, causing widespread confusion and potential market manipulation.

**Attack Scenario:**
1. Attacker creates an NFT protocol with `IsTokenIdReuse = true`
2. Attacker mints tokenId 1 with malicious/misleading metadata (e.g., fake rarity claims, inappropriate content URLs)
3. Attacker burns all tokens (quantity = 0)
4. Victim attempts to mint tokenId 1 with legitimate metadata
5. Victim's mint succeeds but inherits attacker's malicious metadata
6. Events show victim's metadata, but on-chain queries return attacker's metadata

**Affected Parties:**
- NFT minters who re-mint burned token IDs
- NFT marketplaces displaying inconsistent data
- NFT holders receiving misrepresented assets
- Protocol reputation and user trust

**Severity Justification:** Medium severity due to guaranteed data loss on a realistic user flow (burn-then-remint), with potential for malicious exploitation and market manipulation.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Minting permissions in the NFT protocol (normal user privilege)
- Ability to burn tokens (standard protocol feature)
- No special privileges or governance control needed

**Attack Complexity:**
- Simple 3-step process: mint → burn all → wait for victim to remint
- No timing requirements or complex state manipulation
- Executable through standard contract methods

**Feasibility Conditions:**
- Protocols with `IsTokenIdReuse = true` are affected (ERC-1155 style is common)
- Token IDs being fully burned and re-minted is a realistic scenario
- Multiple minters in a protocol can accidentally trigger this

**Detection Constraints:**
- The inconsistency between events and state makes detection difficult
- No error or warning is generated
- Contract execution succeeds normally

**Probability:** HIGH - This occurs naturally whenever anyone re-mints a fully burned token ID in protocols with `IsTokenIdReuse = true`. No attack is necessary; normal operations trigger the vulnerability.

### Recommendation

**Code-level Mitigation:**

In `PerformMint`, add a check after retrieving `nftInfo` to detect if the token was fully burned (quantity = 0) and treat it as a new mint:

```csharp
var nftInfo = State.NftInfoMap[tokenHash];
if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
    Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");

// Add this check:
bool isFullyBurned = nftInfo != null && nftInfo.Quantity == 0;
```

Then modify the conditional logic:

```csharp
if (nftInfo == null || isFullyBurned)
{
    nftInfo = new NFTInfo
    {
        Symbol = input.Symbol,
        Uri = input.Uri ?? string.Empty,
        TokenId = tokenId,
        Metadata = nftMetadata,
        Minters = { Context.Sender },
        Quantity = quantity,
        Alias = input.Alias
    };
}
else
{
    nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
    if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
}
```

**Invariant Checks:**
- Assert that NFTInfo metadata matches NFTMinted event data
- Validate that quantity=0 NFTs are treated as "available for remint with new metadata"

**Test Cases:**
1. Test: Mint token with metadata A → Burn all → Mint same tokenId with metadata B → Verify on-chain state has metadata B
2. Test: Verify NFTMinted event data matches GetNFTInfo query results
3. Test: Multiple sequential burn-remint cycles with different metadata

### Proof of Concept

**Initial State:**
- NFT Protocol "ART-0" created with `IsTokenIdReuse = true`, `IsBurnable = true`
- Alice has minting permissions

**Transaction Sequence:**

1. **Alice mints tokenId 1:**
   - Input: `{ tokenId: 1, quantity: 10, uri: "ipfs://original", metadata: {"rarity": "legendary"}, alias: "Genesis" }`
   - Result: NFTInfo created with uri="ipfs://original", metadata={"rarity":"legendary"}, quantity=10

2. **Alice burns all 10 tokens:**
   - Input: `{ tokenId: 1, amount: 10 }`
   - Result: NFTInfo.quantity = 0, IsBurned remains false (due to IsTokenIdReuse=true)

3. **Bob mints tokenId 1:**
   - Input: `{ tokenId: 1, quantity: 5, uri: "ipfs://newart", metadata: {"rarity": "common"}, alias: "Second Edition" }`
   - **Expected:** New NFTInfo with uri="ipfs://newart", metadata={"rarity":"common"}
   - **Actual:** NFTInfo.quantity=5 but retains uri="ipfs://original", metadata={"rarity":"legendary"}
   - NFTMinted event shows uri="ipfs://newart", metadata={"rarity":"common"} (INCONSISTENT)

**Success Condition:**
Query `GetNFTInfo(tokenId=1)` returns metadata={"rarity":"legendary"} (Alice's old data) even though Bob just minted with metadata={"rarity":"common"} and the event logs show the new metadata.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L99-99)
```csharp
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L383-463)
```csharp
    private NFTMinted PerformMint(MintInput input, bool isTokenIdMustBeUnique = false)
    {
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        if (protocolInfo == null) throw new AssertionException($"Invalid NFT Token symbol: {input.Symbol}");

        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");

        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Incorrect chain.");

        var quantity = input.Quantity > 0 ? input.Quantity : 1;
        protocolInfo.Supply = protocolInfo.Supply.Add(quantity);
        protocolInfo.Issued = protocolInfo.Issued.Add(quantity);
        Assert(protocolInfo.Issued <= protocolInfo.TotalSupply, "Total supply exceeded.");
        State.NftProtocolMap[input.Symbol] = protocolInfo;

        // Inherit from protocol info.
        var nftMetadata = protocolInfo.Metadata.Clone();
        if (input.Metadata != null)
            foreach (var pair in input.Metadata.Value)
                if (!nftMetadata.Value.ContainsKey(pair.Key))
                    nftMetadata.Value[pair.Key] = pair.Value;

        if (nftInfo == null)
        {
            nftInfo = new NFTInfo
            {
                Symbol = input.Symbol,
                Uri = input.Uri ?? string.Empty,
                TokenId = tokenId,
                Metadata = nftMetadata,
                Minters = { Context.Sender },
                Quantity = quantity,
                Alias = input.Alias

                // No need.
                //BaseUri = protocolInfo.BaseUri,
                //Creator = protocolInfo.Creator,
                //ProtocolName = protocolInfo.ProtocolName
            };
        }
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }

        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);

        var nftMinted = new NFTMinted
        {
            Symbol = input.Symbol,
            ProtocolName = protocolInfo.ProtocolName,
            TokenId = tokenId,
            Metadata = nftMetadata,
            Owner = owner,
            Minter = Context.Sender,
            Quantity = quantity,
            Alias = input.Alias,
            BaseUri = protocolInfo.BaseUri,
            Uri = input.Uri ?? string.Empty,
            Creator = protocolInfo.Creator,
            NftType = protocolInfo.NftType,
            TotalQuantity = nftInfo.Quantity,
            TokenHash = tokenHash
        };
        Context.Fire(nftMinted);

        return nftMinted;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L17-17)
```csharp
    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }
```

**File:** protobuf/nft_contract.proto (L283-283)
```text
    bool is_token_id_reuse = 11;
```
