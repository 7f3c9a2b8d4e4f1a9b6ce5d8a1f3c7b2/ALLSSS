### Title
Parliament Single Point of Failure in User Fee Governance Due to Trivial Referendum Threshold

### Summary
The referendum organization for UserFeeController is configured with a ProposerWhiteList containing only parliament and requires just 1 token for approval, enabling parliament to unilaterally control user transaction fee coefficients without meaningful token holder consensus. This defeats the intended multi-layer governance design where both parliament and token holders should independently approve fee changes.

### Finding Description
The `GetReferendumControllerCreateInputForUserFee()` function creates a referendum organization with critically weak parameters: [1](#0-0) 

The referendum organization is configured with:
- ProposerWhiteList containing only `parliamentAddress` (line 136)
- `MinimalApprovalThreshold = 1` token (line 145)
- `MinimalVoteThreshold = 1` token (line 146)

This referendum organization is part of the UserFeeController governance structure: [2](#0-1) 

The UserFeeController's RootController is an Association requiring approval from both parliament and referendum organizations: [3](#0-2) 

However, the Association's dual-approval requirement provides no additional security because:

1. **Proposal Control**: Only parliament can create referendum proposals (ProposerWhiteList restriction at line 150-153)
2. **Trivial Approval**: Any entity with 1 token can approve the referendum proposal
3. **Parliament Voting**: The referendum Approve method allows anyone with token allowance to vote, including parliament-controlled addresses: [4](#0-3) 

The UserFeeController protects the `UpdateCoefficientsForSender` method which controls transaction fee coefficients for all users: [5](#0-4) 

### Impact Explanation
**Direct Governance Impact**: Parliament gains unilateral control over user transaction fee coefficients, affecting all network users. The multi-layer governance structure becomes security theater, providing no meaningful check on parliament power.

**Affected Functionality**: The `UpdateCoefficientsForSender` method can modify fee calculation formulas that determine transaction costs for all users. Parliament can:
- Increase transaction fees arbitrarily
- Manipulate fee structures to favor certain actors
- Change economic parameters without token holder consensus

**Severity Justification**: HIGH - This violates the fundamental governance invariant that critical economic parameters should require multi-stakeholder approval. Token holders are denied meaningful participation in decisions that directly impact their transaction costs.

### Likelihood Explanation
**Attacker Capabilities**: Parliament (default parliament organization controlled by miners) needs only 1 token of the primary token symbol to execute this attack.

**Attack Complexity**: LOW
1. Parliament creates proposal to update fee coefficients
2. Parliament creates sub-proposal to referendum organization (allowed via ProposerWhiteList)
3. Parliament-controlled address approves allowance of 1 token to referendum proposal
4. Parliament-controlled address calls referendum Approve to lock 1 token
5. Parliament approves in parliament organization
6. Association RootController sees both approvals and releases proposal
7. Fee coefficients updated

**Feasibility**: The test suite demonstrates this exact pattern: [6](#0-5) 

**Economic Rationality**: Cost of attack = 1 locked token (reclaimable after proposal expires). This is trivially affordable for parliament.

**Detection Constraints**: On-chain, this appears as legitimate governance activity. No off-chain alerts would trigger.

### Recommendation
**Immediate Fix**: Increase the referendum approval threshold to require meaningful token holder participation. Modify `GetReferendumControllerCreateInputForUserFee()`:

```csharp
ProposalReleaseThreshold = new ProposalReleaseThreshold
{
    MinimalApprovalThreshold = 1000000, // Require substantial token backing
    MinimalVoteThreshold = 1000000,     // Ensure minimum participation
    MaximalRejectionThreshold = 500000, // Allow token holders to veto
    MaximalAbstentionThreshold = 500000
}
```

**Structural Fix**: Allow token holders to initiate proposals by expanding ProposerWhiteList or removing it entirely for referendum organizations:

```csharp
ProposerWhiteList = new ProposerWhiteList() // Empty = anyone can propose
```

**Invariant Checks**: Add validation that referendum organizations for critical controllers must have thresholds that prevent single-entity approval:
- MinimalApprovalThreshold >= 1% of token supply
- MaximalRejectionThreshold > 0 to allow vetoes
- ProposerWhiteList either empty or contains diverse stakeholders

**Test Cases**: Add tests verifying that parliament alone cannot push through UserFeeController changes without significant token holder support:
- Test that 1 token approval fails to meet threshold
- Test that token holders can reject parliament proposals
- Test that token holders can initiate counter-proposals

### Proof of Concept
**Initial State**:
- UserFeeController initialized with default referendum organization
- Parliament holds/controls at least 1 unit of primary token
- Current fee coefficients set to initial values

**Exploitation Steps**:
1. Parliament creates proposal to Association RootController targeting `UpdateCoefficientsForSender` with malicious coefficient changes
2. Parliament creates sub-proposal to ReferendumController (via parliament's CreateProposal call)
3. Parliament-controlled address approves token allowance to referendum proposal virtual address: `TokenContract.Approve(proposalVirtualAddress, symbol, 1)`
4. Parliament-controlled address votes: `ReferendumContract.Approve(referendumProposalId)`
5. Referendum proposal now has 1 token approval, meeting MinimalApprovalThreshold of 1
6. Parliament approves referendum proposal in parliament organization
7. Parliament releases referendum proposal
8. Parliament approves Association RootController proposal
9. Association sees both parliament and referendum approval, releases proposal
10. `UpdateCoefficientsForSender` executes with malicious coefficients

**Expected Result**: Multi-layer governance should prevent unilateral parliament control, requiring independent token holder consensus.

**Actual Result**: Parliament successfully modifies user fee coefficients using only 1 token, bypassing the intended token holder protection.

**Success Condition**: User fee coefficients changed to parliament's desired values without meaningful token holder participation, demonstrating complete parliament control over supposedly multi-stakeholder governance.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L133-156)
```csharp
    private CreateOrganizationBySystemContractInput GetReferendumControllerCreateInputForUserFee(
        Address parliamentAddress)
    {
        var whiteList = new List<Address> { parliamentAddress };
        var tokenSymbol = GetPrimaryTokenSymbol(new Empty()).Value;
        return new CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new CreateOrganizationInput
            {
                TokenSymbol = tokenSymbol,
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1,
                    MinimalVoteThreshold = 1,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { whiteList }
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L158-184)
```csharp
    private Association.CreateOrganizationBySystemContractInput GetAssociationControllerCreateInputForUserFee(
        Address parliamentAddress, Address referendumAddress)
    {
        var proposers = new List<Address>
            { referendumAddress, parliamentAddress };
        return new Association.CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new Association.CreateOrganizationInput
            {
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { proposers }
                },
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = proposers.Count,
                    MinimalVoteThreshold = proposers.Count,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { proposers }
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L324-352)
```csharp
    private UserFeeController GetDefaultUserFeeController(AuthorityInfo defaultParliamentController)
    {
        if (State.AssociationContract.Value == null)
            State.AssociationContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);

        if (State.ReferendumContract.Value == null)
            State.ReferendumContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);

        var userFeeController = new UserFeeController
        {
            RootController = new AuthorityInfo(),
            ParliamentController = new AuthorityInfo(),
            ReferendumController = new AuthorityInfo()
        };
        userFeeController.ParliamentController = defaultParliamentController;
        userFeeController.ReferendumController.ContractAddress = State.ReferendumContract.Value;
        userFeeController.ReferendumController.OwnerAddress =
            State.ReferendumContract.CalculateOrganizationAddress.Call(
                GetReferendumControllerCreateInputForUserFee(defaultParliamentController.OwnerAddress)
                    .OrganizationCreationInput);
        userFeeController.RootController.ContractAddress = State.AssociationContract.Value;
        userFeeController.RootController.OwnerAddress = State.AssociationContract.CalculateOrganizationAddress.Call(
            GetAssociationControllerCreateInputForUserFee(defaultParliamentController.OwnerAddress,
                    userFeeController.ReferendumController.OwnerAddress)
                .OrganizationCreationInput);
        return userFeeController;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L70-83)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        var organization = State.Organizations[proposal.OrganizationAddress];
        var allowance = GetAllowance(Context.Sender, organization.TokenSymbol, input);

        proposal.ApprovalCount = proposal.ApprovalCount.Add(allowance);
        State.Proposals[input] = proposal;
        var referendumReceiptCreated = LockToken(organization.TokenSymbol, allowance, input, Context.Sender,
            proposal.OrganizationAddress);
        referendumReceiptCreated.ReceiptType = nameof(Approve);
        Context.Fire(referendumReceiptCreated);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L25-32)
```csharp
    public override Empty UpdateCoefficientsForSender(UpdateCoefficientsInput input)
    {
        Assert(input.Coefficients != null, "Invalid input coefficients.");
        AssertUserFeeController();
        input.Coefficients.FeeTokenType = (int)FeeTypeEnum.Tx; // The only possible for now.
        UpdateCoefficients(input);
        return new Empty();
    }
```

**File:** test/AElf.Contracts.MultiTokenCrossChainTransfer.Tests/MultiTokenContractReferenceFeeTest.cs (L918-962)
```csharp
    private async Task VoteToReferendumAsync(Hash input, string primaryTokenSymbol)
    {
        var organizations = await GetControllerForUserFeeAsync();

        var referendumProposal = new CreateProposalInput
        {
            ToAddress = AssociationContractAddress,
            Params = input.ToByteString(),
            OrganizationAddress = organizations.ReferendumController.OwnerAddress,
            ContractMethodName = nameof(AuthorizationContractContainer.AuthorizationContractStub.Approve),
            ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
        };

        var parliamentProposal = new CreateProposalInput
        {
            ToAddress = ReferendumContractAddress,
            Params = referendumProposal.ToByteString(),
            OrganizationAddress = organizations.ParliamentController.OwnerAddress,
            ContractMethodName = nameof(AuthorizationContractContainer.AuthorizationContractStub.CreateProposal),
            ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
        };
        var ret = await MainChainTesterCreatApproveAndReleaseProposalForParliamentAsync(parliamentProposal);
        var referendumProposalId = ProposalCreated.Parser
            .ParseFrom(ret.Logs.First(l => l.Name.Contains(nameof(ProposalCreated)))
                .NonIndexed).ProposalId;
        var proposalVirtualAddress =
            await ReferendumContractStub.GetProposalVirtualAddress.CallAsync(referendumProposalId);
        var approveResult = await TokenContractStub.Approve.SendAsync(new ApproveInput
        {
            Spender = proposalVirtualAddress,
            Symbol = primaryTokenSymbol,
            Amount = 100000
        });
        await ReferendumContractStub.Approve.SendAsync(referendumProposalId);

        parliamentProposal = new CreateProposalInput
        {
            ToAddress = ReferendumContractAddress,
            Params = referendumProposalId.ToByteString(),
            OrganizationAddress = organizations.ParliamentController.OwnerAddress,
            ContractMethodName = nameof(AuthorizationContractContainer.AuthorizationContractStub.Release),
            ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
        };
        await MainChainTesterCreatApproveAndReleaseProposalForParliamentAsync(parliamentProposal);
    }
```
