### Title
Transaction Splitting Exploit in Storage Fee Piecewise Pricing Model

### Summary
The storage fee calculation uses a piecewise polynomial with a sharp boundary at 1MB, charging linear fees for [0, 1M] bytes but quadratic fees for bytes exceeding 1M. Attackers can exploit this by splitting large data across multiple sub-1MB transactions, paying only linear costs and avoiding the quadratic penalty entirely. This results in up to 640x cost savings compared to single large transactions, defeating the economic incentive structure designed to discourage large data storage.

### Finding Description

The storage fee coefficient initialization [1](#0-0)  defines two pricing pieces:
- Piece 1 [0, 1,000,000 bytes]: `x/4 + 1/100000` STORAGE tokens (linear)  
- Piece 2 (1,000,000, ∞): `x²/20000 + x/64` STORAGE tokens (quadratic on excess)

The piecewise calculation [2](#0-1)  applies each formula to its respective interval count. For a transaction exceeding 1MB, it charges linear fees for the first 1MB and quadratic fees only on the excess bytes.

Storage fees are calculated based on transaction size in bytes [3](#0-2) , and transactions can be up to 5MB [4](#0-3) .

**Root Cause:** The sharp pricing boundary at 1MB creates a cost arbitrage opportunity. There is no mechanism to aggregate or penalize sequential transactions from the same sender, allowing unlimited transaction splitting without additional cost.

**Why Protections Fail:** The fee calculation treats each transaction independently with no cross-transaction accumulation. The quadratic pricing intended to discourage large data storage can be completely bypassed through simple transaction splitting.

### Impact Explanation

**Quantified Cost Savings:**
- Storing 5MB in one transaction: First 1MB costs 250,000 STORAGE + remaining 4MB costs ~800,062,500 STORAGE = **800,312,500 STORAGE total**
- Storing 5MB in five 1MB transactions: 250,000 STORAGE × 5 = **1,250,000 STORAGE total**  
- **Attacker savings: 640x reduction** (800.3M vs 1.25M STORAGE tokens)

**Protocol Damage:**
- Economic model integrity broken: Progressive pricing fails to discourage large data storage when split
- Blockchain bloat at subsidized rates: Attackers can store arbitrary amounts of data at linear cost by staying under 1MB per transaction
- Unfair advantage: Sophisticated users who understand the fee structure pay dramatically less than naive users for equivalent data storage
- Resource exhaustion risk: Cheap mass data storage threatens node storage capacity and sync times

**Who Is Affected:**
- Protocol sustainability: Long-term blockchain growth becomes economically uncontrolled
- Honest users: Pay up to 640x more for equivalent data storage if they don't split transactions
- Node operators: Bear storage costs not adequately compensated by collected fees

### Likelihood Explanation

**Attacker Capabilities:**
- Requires only basic understanding of the fee structure (publicly visible in contract code)
- Needs STORAGE tokens (acquirable via TokenConverter [5](#0-4) )
- No special permissions or trusted roles required

**Attack Complexity:** 
- **Very Low**: Simply split large payloads across multiple transactions under 1MB each
- Automation trivial: Script can automatically chunk data and submit sequential transactions
- No timing constraints or race conditions involved

**Feasibility Conditions:**
- Transaction size limit of 5MB enables the exploit window
- No rate limiting or sender-based fee aggregation exists
- Each transaction is evaluated independently [6](#0-5) 

**Economic Rationality:**
- **Highly Rational**: 640x cost reduction makes exploitation economically compelling for any significant data storage
- Transaction fee overhead (ELF) is minor compared to STORAGE fee savings (also benefits from splitting: 10x savings)
- Break-even point is very low (any storage >1MB benefits from splitting)

**Probability:** High - The exploit is discoverable through basic fee analysis, requires minimal technical sophistication, and provides massive economic incentive.

### Recommendation

**Code-Level Mitigation:**

1. **Implement Rolling Window Fee Accumulation:**
   - Track cumulative byte count per sender over a sliding time window (e.g., per block or N blocks)
   - Apply quadratic pricing based on accumulated storage, not individual transaction size
   - Requires new state storage: `mapping(address => RollingByteCount)`

2. **Smooth Pricing Transition:**
   - Replace sharp 1MB boundary with gradual coefficient transition
   - Example: Blend linear and quadratic terms across 500KB-1.5MB range using weighted average
   - Reduces arbitrage opportunity at specific thresholds

3. **Add Minimum Quadratic Component:**
   - Modify first piece formula from `x/4 + 1/100000` to `x²/C + x/4 + 1/100000` where C is large (e.g., 10M)
   - Ensures some quadratic cost even in lower ranges
   - Update coefficients in [7](#0-6) 

**Invariant Checks:**
- Assert: Total fee for N bytes in 1 transaction ≥ Total fee for N bytes split optimally across multiple transactions
- Validate: Fee function is convex (second derivative ≥ 0) across all ranges to prevent splitting advantage

**Test Cases:**
- Compare fee for 5MB in 1 tx vs 5×1MB vs 50×100KB
- Verify quadratic penalty applies regardless of splitting strategy  
- Test boundary conditions at 999,999 bytes, 1,000,000 bytes, 1,000,001 bytes

### Proof of Concept

**Initial State:**
- Attacker has sufficient STORAGE tokens and ELF
- Needs to store 5MB of data on-chain
- STORAGE token has 8 decimals [8](#0-7) 

**Exploitation Steps:**

1. **Naive Approach (Single 5MB Transaction):**
   - Submit one transaction with 5,000,000 byte payload
   - Storage fee calculated: Piece 1 (1M bytes) = 250,000 STORAGE, Piece 2 (4M bytes) = 800,062,500 STORAGE
   - Total charged: 800,312,500 STORAGE tokens

2. **Optimized Attack (Five 1MB Transactions):**
   - Split data into 5 chunks of 1,000,000 bytes each
   - Submit 5 sequential transactions, each with 1MB payload
   - Storage fee per transaction: 1,000,000/4 + 1/100000 = 250,000.00001 STORAGE
   - Total charged: 5 × 250,000 = 1,250,000 STORAGE tokens

**Expected vs Actual Result:**
- Expected (by fee design): Large data storage should incur quadratic costs
- Actual: Attacker pays 1.25M STORAGE instead of 800.3M STORAGE
- **Success Condition:** Attacker stores 5MB for 640x less cost, demonstrating complete bypass of quadratic pricing mechanism

**Verification:**
- Check attacker's STORAGE token balance before and after
- Confirm data stored on-chain totals 5MB across transactions
- Calculate effective cost per byte: 1.25M/5M = 0.25 STORAGE/byte (linear) vs expected 160 STORAGE/byte (quadratic) for single large transaction

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L172-201)
```csharp
    private CalculateFeeCoefficients GetStorageFeeInitialCoefficient()
    {
        return new CalculateFeeCoefficients
        {
            FeeTokenType = (int)FeeTypeEnum.Storage,
            PieceCoefficientsList =
            {
                new CalculateFeePieceCoefficients
                {
                    // Interval [0, 1000000]: x / 4 + 1 / 100000
                    Value =
                    {
                        1000000,
                        1, 1, 4,
                        0, 1, 100000
                    }
                },
                new CalculateFeePieceCoefficients
                {
                    // Interval (1000000, +∞): x ^ 2 / 20000 + x / 64
                    Value =
                    {
                        int.MaxValue,
                        2, 1, 20000,
                        1, 1, 64
                    }
                }
            }
        };
    }
```

**File:** src/AElf.Kernel.FeeCalculation/Infrastructure/CalculateFunction.cs (L34-58)
```csharp
    public long CalculateFee(int totalCount)
    {
        if (CalculateFeeCoefficients.PieceCoefficientsList.Count != _currentCalculateFunctions.Count)
            throw new ArgumentOutOfRangeException(nameof(_currentCalculateFunctions),
                "Coefficients count not match.");

        var remainCount = totalCount;
        var result = 0L;
        var pieceStart = 0;
        for (var i = 0; i < _currentCalculateFunctions.Count; i++)
        {
            var function = _currentCalculateFunctions[i];
            var pieceCoefficient = CalculateFeeCoefficients.PieceCoefficientsList[i].Value;
            var pieceUpperBound = pieceCoefficient[0];
            var interval = pieceUpperBound - pieceStart;
            pieceStart = pieceUpperBound;
            var count = Math.Min(interval, remainCount);
            result += function(count);
            if (pieceUpperBound > totalCount) break;

            remainCount -= interval;
        }

        return result;
    }
```

**File:** src/AElf.Kernel.FeeCalculation/Infrastructure/StorageFeeProvider.cs (L15-18)
```csharp
    protected override int GetCalculateCount(ITransactionContext transactionContext)
    {
        return transactionContext.Transaction.Size();
    }
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L1-6)
```csharp
namespace AElf.Kernel.TransactionPool;

public class TransactionPoolConsts
{
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
}
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L84-94)
```csharp
            State.TokenContract.Create.Send(new CreateInput
            {
                Symbol = resourceTokenSymbol,
                TokenName = $"{resourceTokenSymbol} Token",
                TotalSupply = EconomicContractConstants.ResourceTokenTotalSupply,
                Decimals = EconomicContractConstants.ResourceTokenDecimals,
                Issuer = Context.Self,
                LockWhiteList = { lockWhiteList },
                IsBurnable = true,
                Owner = Context.Self
            });
```

**File:** src/AElf.Kernel.FeeCalculation/Infrastructure/TokenFeeProviderBase.cs (L24-37)
```csharp
    public Task<long> CalculateFeeAsync(ITransactionContext transactionContext, IChainContext chainContext)
    {
        var functionDictionary = _calculateFunctionProvider.GetCalculateFunctions(chainContext);
        var targetKey = ((FeeTypeEnum)_tokenType).ToString().ToUpper();
        if (!functionDictionary.ContainsKey(targetKey))
        {
            var currentKeys = string.Join(" ", functionDictionary.Keys);
            throw new InvalidOperationException($"Function not found. Current keys: {currentKeys}");
        }

        var function = functionDictionary[targetKey];
        var count = GetCalculateCount(transactionContext);
        return Task.FromResult(function.CalculateFee(count));
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L13-13)
```csharp
    public const int ResourceTokenDecimals = 8;
```
