### Title
Delegated Voting VoteId Overwrite Enables Vote Double-Counting and Record Corruption

### Summary
In delegated voting mode (`IsLockToken = false`), the Vote contract allows the voting sponsor to supply a user-controlled `VoteId`, which is unconditionally overwritten in `State.VotingRecords` with no uniqueness check. This permits overwriting previous voting records for the same `VoteId`, resulting in double-counting of votes, loss of original vote data, and confusion on withdrawal eligibility. The vulnerability occurs at line 117 of the `Vote` function.

### Finding Description
- In the `Vote` function, the contract writes `State.VotingRecords[input.VoteId] = votingRecord;` without any check for existing records at that key. 
- When `IsLockToken` is `false`, the sponsor can pass _any_ `VoteId`, and there is no validation that the `VoteId` has not been used before by another voter. 
- As a result, prior voting records can be overwritten, and `UpdateVotingResult` will count freshly added votes again, inflating voting totals.
- This action also corrupts voter tracking lists, since multiple voters (e.g., Alice and Bob) can have the same `VoteId` in their `ActiveVotes` set, but only the last record stored persists.
- Only the final record can be withdrawn, making withdrawal logic unreliable for all but the last overwritten voter.

**Critical code locations:**
- `contract/AElf.Contracts.Vote/VoteContract.cs`, line 117: unconditional overwrite
- `contract/AElf.Contracts.Vote/VoteContract.cs`, lines 384–389: only sponsor may vote; sponsor supplies arbitrary `VoteId` 
- `contract/AElf.Contracts.Vote/VoteContract.cs`, lines 386–388: explicit checks for delegated voting (but not for duplicate VoteId)

### Impact Explanation
- **Governance Impact**: The sponsor (or buggy sponsor contract) can arbitrarily overwrite and double-count votes, manipulating governance outcomes.
- **Operational Impact**: Voting record and withdrawal tracking losses induce irreversible data corruption, operational confusion, and possible disputes or stuck withdrawals.
- **Protocol Integrity**: Total votes and voters become inaccurate, directly violating governance and economic invariants.
- **Severity**: Critical, restricted to delegated voting, but damages trust and operations.

### Likelihood Explanation
- **Attacker Capabilities**: Only the voting sponsor can trigger this bug, either maliciously or inadvertently (via a contract bug).
- **Attack Complexity**: Simple to perform—call `Vote()` multiple times with the same `VoteId` for different users.
- **Feasibility**: Fully feasible when sponsor is compromised or implemented incorrectly. Impactful as soon as two votes reuse the same `VoteId`.
- **Detection Constraints**: Subtle and difficult to audit post hoc; record and tally inconsistencies may not be detected until disputes arise.
- **Probability**: Non-trivial in deployed settings if sponsors are untrusted contracts or contain bugs; less likely if all sponsors are thoroughly audited trusted actors.

### Recommendation
- **Mitigation**: Immediately prevent delegated voting if a supplied `VoteId` is already present in `State.VotingRecords` by adding an assertion to ensure uniqueness.
- **Minting/Id Guidance**: Strongly recommend only allowing contract-generated IDs, or including (voter, VotingItemId) in VoteId derivation in the delegated design.
- **Test Cases**: Add negative tests covering duplicate `VoteId`, overwriting, and cross-user vote/withdraw interactions.

### Proof of Concept
1. **Setup**: Register a delegated voting item (`IsLockToken = false`), options A and B.
2. **Step 1**: Sponsor votes for Alice, `VoteId=X`, option=A, amount=100.
3. **Step 2**: Sponsor votes for Bob, `VoteId=X`, option=B, amount=50.
4. **Effect**: Both Alice/Bob have `VoteId=X` in their records, but only Bob's record is stored. `VotesAmount` tallies both votes (150) and `VotersCount` increments twice.
5. **Step 3**: Alice tries to withdraw; fails or corrupts state. Bob withdraws; only his vote is processed.
6. **Attack Success**: Demonstrates double-count and persistent record/data corruption, fully within contract logic.

--- [1](#0-0) [2](#0-1)

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L90-144)
```csharp
    public override Empty Vote(VoteInput input)
    {
        var votingItem = AssertValidVoteInput(input);
        var amount = 0L;
        if (!votingItem.IsQuadratic)
        {
            amount = input.Amount;
        }
        else
        {
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }

        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;

        UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
        UpdateVotedItems(input.VoteId, votingRecord.Voter, votingItem);

        if (votingItem.IsLockToken)
            // Lock voted token.
            State.TokenContract.Lock.Send(new LockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                LockId = input.VoteId,
                Amount = amount
            });

        Context.Fire(new Voted
        {
            VoteId = input.VoteId,
            VotingItemId = votingRecord.VotingItemId,
            Voter = votingRecord.Voter,
            Amount = votingRecord.Amount,
            Option = votingRecord.Option,
            SnapshotNumber = votingRecord.SnapshotNumber,
            VoteTimestamp = votingRecord.VoteTimestamp
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```
