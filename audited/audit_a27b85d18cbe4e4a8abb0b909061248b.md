### Title
Continuous Block Limit Bypass Through Coordinated Multi-Identity Mining

### Summary
An attacker controlling multiple miner identities can coordinate them to bypass the per-miner continuous block limit by rotating between different identities. The `ContinuousBlocksValidationProvider` only enforces the limit per individual public key and resets the counter when a different miner produces a block, allowing colluding miners with consecutive time slots to each produce the maximum blocks (8 in normal conditions), resulting in significantly more continuous blocks than intended and defeating the fork prevention mechanism.

### Finding Description

The continuous block limit mechanism is designed to prevent excessive continuous blocks that could cause forks, as documented in the code comment "Adjust (mainly reduce) the count of tiny blocks produced by a miner each time to avoid too many forks" [1](#0-0) . However, the implementation has a critical flaw in how it tracks and enforces this limit.

The validation logic in `ContinuousBlocksValidationProvider` checks if a miner has produced too many continuous blocks [2](#0-1) , but this check only applies when the current sender's pubkey matches the tracked pubkey AND the BlocksCount is negative [3](#0-2) .

The root cause lies in `ResetLatestProviderToTinyBlocksCount`, which resets the BlocksCount to `minersCountInTheory - 1` whenever a different pubkey produces a block [4](#0-3) . Specifically, when a different miner takes over, the counter resets [5](#0-4) , while the same miner continuing simply decrements the counter [6](#0-5) .

Additionally, the consensus command generation forces NextRound only for the specific miner whose BlocksCount went negative [7](#0-6) , checking that the pubkey matches before forcing the round transition.

The maximum blocks count defaults to 8 [8](#0-7)  and is used in normal conditions [9](#0-8) .

Miner orders are determined pseudo-randomly through VRF signatures [10](#0-9) , and while the `BreakContinuousMining` function prevents some continuous mining scenarios [11](#0-10) , it only addresses the extra block producer edge cases and does not prevent general consecutive mining by different colluding miners.

### Impact Explanation

The vulnerability allows an attacker controlling multiple miner identities to produce significantly more continuous blocks than the intended limit, directly defeating the fork prevention mechanism. If an attacker controls 3 miners with consecutive or near-consecutive time slot orders (e.g., orders 5, 6, 7), they can:

- Miner A produces 8 blocks (BlocksCount goes from 7 to -1)
- Miner B produces 8 blocks (BlocksCount resets to 7, then goes to -1)  
- Miner C produces 8 blocks (BlocksCount resets to 7, then goes to -1)
- Total: 24 continuous blocks from attacker-controlled entities

This represents a 3x increase over the intended limit of 8 blocks, with the multiplier scaling with the number of controlled miners that have consecutive orders. The excessive continuous blocks increase fork probability, which can lead to:

1. **Blockchain instability**: More forks mean slower consensus finality and potential chain reorganizations
2. **Network disruption**: Honest nodes must handle and resolve more fork scenarios
3. **Transaction confirmation delays**: Users experience longer wait times for transaction finality
4. **Reduced security**: The irreversible block height calculation may be delayed

The impact affects the entire blockchain network's stability and security, undermining the core consensus mechanism's reliability.

### Likelihood Explanation

The attack is realistically exploitable under the following conditions:

**Attacker Capabilities Required:**
- Control of multiple miner identities (typically requires 3+ miners for significant impact)
- Miners are elected through the Election contract, requiring substantial voting power/stake
- Coordination capability between controlled miners (trivial through off-chain communication)

**Attack Complexity:**
- **Medium complexity**: Requires initial investment to gain control of multiple miners but straightforward execution once achieved
- Miner orders are randomized each round based on VRF signatures, so consecutive orders are probabilistic but become increasingly likely with more controlled miners
- With 3 controlled miners out of 17 total (~17.6% control), probability calculations suggest consecutive or near-consecutive orders will occur regularly across multiple rounds

**Feasibility Conditions:**
- The attack exploits the standard consensus flow without requiring any special conditions
- Time slot enforcement is respected (each miner produces during their assigned time), making detection difficult
- No transaction reverts or validation failures occur during normal attack execution
- The validation logic permits the behavior as "valid" consensus operations

**Economic Rationality:**
- More blocks produced = more block rewards for the attacker
- The cost is primarily the initial investment to control multiple miners
- The ongoing cost per attack is minimal (just coordination)
- Return on investment is positive as long as the attacker can maintain miner positions

**Detection Constraints:**
- Individual miner behaviors appear normal (each produces ≤8 blocks)
- Only cross-miner analysis would reveal the pattern
- No on-chain alerts or automatic detection mechanisms exist
- The behavior could be dismissed as normal probabilistic miner ordering

The likelihood is **HIGH** for attackers with sufficient resources to control multiple miners, which is a realistic scenario for well-funded adversaries or entities with significant stake in the network.

### Recommendation

**Primary Mitigation - Track Global Continuous Block Count:**

Modify the continuous block tracking to enforce a global limit across all miners, not just per-miner:

1. In `ResetLatestProviderToTinyBlocksCount`, track cumulative continuous blocks across all miners within a time window or round segment:
   - Maintain a global counter that tracks total continuous blocks produced
   - Only reset the global counter when a NextRound occurs or after a configurable threshold time
   - When a different miner produces a block, decrement but don't reset to full quota
   - Force NextRound when global counter exceeds a threshold (e.g., 2x MaximumTinyBlocksCount)

2. Update `ContinuousBlocksValidationProvider` to check both per-miner and global limits:
   - Reject blocks if either the per-miner limit is exceeded OR the global continuous block limit is exceeded
   - Include the global counter in the validation context

**Alternative Mitigation - Stricter Order Shuffling:**

Enhance `BreakContinuousMining` to prevent any consecutive orders for miners from the same entity:
   - Implement identity tracking across multiple pubkeys (requires additional verification mechanism)
   - Shuffle orders to maximize distance between potentially related miners
   - However, this requires a way to link multiple identities, which may not be feasible

**Immediate Hardening:**

1. Reduce `MaximumTinyBlocksCount` to a lower value (e.g., 4 instead of 8) to limit the impact multiplier
2. Add monitoring and alerting for patterns of consecutive maximum block production
3. Implement stricter adjustments in `GetMaximumBlocksCount` that reduce the limit more aggressively when consecutive patterns are detected

**Test Cases to Add:**

1. Test scenario with 3+ colluding miners producing maximum blocks consecutively
2. Verify global limit enforcement across miner rotations
3. Test that fork rate doesn't exceed threshold under coordinated mining
4. Validate that NextRound triggers appropriately with global tracking

### Proof of Concept

**Initial State:**
- Network has 17 miners total
- Attacker controls Miner A (order 5), Miner B (order 6), and Miner C (order 7) in current round
- MaximumTinyBlocksCount = 8
- BlocksCount initialization: MaximumTinyBlocksCount - 1 = 7

**Attack Sequence:**

**Round N, Time Slot 5 (Miner A):**
1. Miner A produces Block 1 → BlocksCount = 7 (initial) [12](#0-11) 
2. Miner A produces Blocks 2-8 → BlocksCount decrements to 0 [6](#0-5) 
3. Miner A attempts Block 9 → BlocksCount would be -1
4. Validation check: pubkey matches && BlocksCount < 0 → FAILS [3](#0-2) 
5. Command generation forces NextRound for Miner A [7](#0-6) 

**Round N, Time Slot 6 (Miner B):**
1. Miner B produces Block 9 → BlocksCount RESETS to 7 (different pubkey) [5](#0-4) 
2. Validation check: pubkey doesn't match previous OR BlocksCount not negative → PASSES [3](#0-2) 
3. Miner B produces Blocks 10-16 → BlocksCount decrements to 0
4. Miner B cannot produce Block 17 (BlocksCount would be -1)

**Round N, Time Slot 7 (Miner C):**
1. Miner C produces Block 17 → BlocksCount RESETS to 7 (different pubkey)
2. Miner C produces Blocks 18-24 → BlocksCount decrements to 0
3. Miner C cannot produce Block 25

**Expected Result:** Maximum 8 continuous blocks per round segment (fork prevention)

**Actual Result:** 24 continuous blocks produced (8 + 8 + 8) by coordinated attacker-controlled miners before NextRound is required

**Success Condition:** Total continuous blocks = 3 × MaximumTinyBlocksCount = 24, which is 3x the intended limit, demonstrating successful bypass of the continuous block limit through identity rotation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L19-19)
```csharp
    ///     Adjust (mainly reduce) the count of tiny blocks produced by a miner each time to avoid too many forks.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L33-33)
```csharp
        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L8-28)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Is sender produce too many continuous blocks?
        var validationResult = new ValidationResult();

        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-108)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }

        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
    }
```
