### Title
InValue Grinding Attack Enables Mining Order Manipulation in AEDPoS Consensus

### Summary
Miners can grind InValues offline to predetermine their mining order in future rounds, breaking the fairness guarantees of the commit-reveal randomness scheme. The deterministic signature and order calculation, combined with publicly visible previous round signatures, allows miners to try multiple InValue candidates and select one that yields a favorable position, gaining unfair economic advantages.

### Finding Description

The AEDPoS consensus uses a commit-reveal scheme where miners commit to OutValue = Hash(InValue) in round N, then reveal InValue in round N+1. The mining order for round N+1 is calculated deterministically from the revealed InValue: [1](#0-0) [2](#0-1) 

The signature for round N+1 is calculated as: `XOR(InValue_N, XOR_of_all_Round_N_signatures)`, and the order is: `(signature.ToInt64() % minersCount) + 1`.

**Root Cause:**

1. **Deterministic Hash Function**: HashHelper uses SHA256 which is deterministic [3](#0-2) 

2. **Public Previous Signatures**: All signatures from round N are visible in the blockchain state (Round.RealTimeMinersInformation)

3. **Weak Validation**: The validation only checks hash equality, not the generation process [4](#0-3) 

4. **Optional InValue Revelation**: Miners can skip revealing if conditions are unfavorable [5](#0-4) 

**Attack Execution Path:**

A malicious miner operating a modified node can:

1. During round N, observe all current signatures (public in Round.RealTimeMinersInformation)
2. Generate thousands of candidate InValue variations (by modifying the node's InValue generation logic in SecretSharingService or using different random sources) [6](#0-5) 

3. For each candidate, calculate:
   - The resulting signature using CalculateSignature
   - The resulting order_N+1 using the modulo calculation
4. Select the InValue that produces order 1 or 2 (early mining position)
5. Commit OutValue = Hash(chosen_InValue) when producing their round N block [7](#0-6) 

6. In round N+1, reveal the chosen InValue which passes validation and grants the predetermined favorable order

**Why Existing Protections Fail:**

The commit-reveal scheme protects against predicting OTHER miners' InValues, but does NOT prevent a miner from grinding their OWN InValue choice. The validation at line 48 only verifies `Hash(previousInValue) == previousOutValue`, making all InValues equally valid regardless of how they were selected.

### Impact Explanation

**Concrete Harm:**
- **Economic Advantage**: Earlier mining positions (order 1-2) typically collect more transaction fees as they process transactions first in each round
- **Consensus Unfairness**: Breaks the randomized order selection mechanism that ensures fair distribution of mining opportunities
- **Centralization Risk**: Grinding miners consistently gain better positions, accumulating more rewards over time, creating a "rich get richer" dynamic
- **Protocol Integrity**: Violates the security assumptions of the commit-reveal scheme designed to prevent manipulation

**Who is Affected:**
- Honest miners lose revenue as grinding miners monopolize favorable positions
- Network decentralization is compromised
- Users face reduced network fairness

**Severity Justification:**
High severity because it undermines the core fairness guarantees of the consensus mechanism, enabling systematic economic exploitation by any miner willing to run modified software.

### Likelihood Explanation

**Attacker Capabilities:**
- Any miner running their own node can modify the InValue generation code
- Requires basic software development skills to alter SecretSharingService
- No special privileges beyond being an active miner

**Attack Complexity:**
- LOW: Grinding is computationally cheap (SHA256 hashing is fast, can try 100K+ candidates per second)
- All required information (previous round signatures) is publicly available on-chain
- No cryptographic barriers to trying multiple InValues
- Deterministic ECDSA (RFC 6979) used in AElf means signatures are reproducible, but miners can still use different input messages [8](#0-7) 

**Feasibility Conditions:**
- EASILY SATISFIED: Only requires running a modified node
- No on-chain detection possible (validation cannot distinguish ground InValues from legitimate ones)
- No economic penalty for grinding (happens off-chain)

**Detection/Operational Constraints:**
- UNDETECTABLE: The on-chain contract cannot determine if an InValue was ground or randomly generated
- Miners control their own node software execution
- Statistical analysis might detect suspiciously favorable orders over time, but cannot prove grinding

**Probability:**
HIGH - The attack is economically rational (increases revenue), technically simple, undetectable, and has zero cost/risk.

### Recommendation

**Immediate Mitigations:**

1. **Add Unpredictable Randomness Source**: Incorporate VRF (Verifiable Random Function) output into the signature calculation to prevent grinding:

```
signature = XOR(VRF_output, InValue_N, XOR_of_all_Round_N_signatures)
```

The VRF proof should be verified on-chain, ensuring the randomness cannot be ground. The current VRF mechanism exists for random number generation but is not used in the order calculation. [9](#0-8) 

2. **Use Previous Block Hash in Order Calculation**: Include the unpredictable previous block hash in the signature calculation:

```
signature = XOR(Context.PreviousBlockHash, InValue_N, XOR_of_all_Round_N_signatures)
```

This makes the order unpredictable at commit time since the block hash depends on all transactions in the previous block.

3. **Multi-Round Commitment**: Require miners to commit InValues for multiple future rounds simultaneously, making selective grinding exponentially harder.

**Invariant Checks to Add:**

- Monitor statistical distribution of miner orders over time; flag miners who consistently achieve early positions beyond statistical probability
- Implement slashing for miners with suspicious order patterns (though detection is imperfect)

**Test Cases:**

- Simulate grinding attack where modified SecretSharingService tries 10,000 InValues and selects optimal order
- Verify that recommended mitigations make order unpredictable at commit time
- Test that order distribution remains fair across all miners over many rounds

### Proof of Concept

**Initial State:**
- Network has 7 active miners (minersCount = 7)
- Current Round N with all miners having published signatures
- Attacker is miner with pubkey "AttackerPubkey" preparing to produce block in Round N

**Attack Steps:**

1. **Observe Public State** (Round N):
   - Read all signatures from `Round.RealTimeMinersInformation` (publicly available)
   - Calculate `previousSignaturesXOR = XOR of all Round N signatures`

2. **Offline Grinding** (Attacker's modified node):
   ```
   For i = 0 to 100,000:
       candidateInValue = Hash(Sign(Hash("candidate_" + i)))
       candidateOutValue = Hash(candidateInValue)
       
       // Simulate what order this would give in Round N+1
       candidateSignature = XOR(candidateInValue, previousSignaturesXOR)
       candidateOrder = (candidateSignature.ToInt64() % 7) + 1
       
       If candidateOrder == 1 or candidateOrder == 2:
           chosenInValue = candidateInValue
           chosenOutValue = candidateOutValue
           break
   ```

3. **Commit Phase** (Round N block production):
   - Publish `chosenOutValue` in UpdateValue transaction
   - Store `chosenInValue` in local cache

4. **Reveal Phase** (Round N+1 block production):
   - Submit `UpdateValueInput` with `PreviousInValue = chosenInValue`
   - Validation passes: `Hash(chosenInValue) == chosenOutValue` ✓
   - Order calculation executes: `order = (signature % 7) + 1 = 1` ✓

**Expected vs Actual Result:**
- **Expected (Honest)**: Random order between 1-7 (each ~14.3% probability)
- **Actual (Attack)**: Predetermined order 1 or 2 (100% probability for attacker)

**Success Condition:**
Attacker consistently receives early mining positions (orders 1-2) across multiple rounds, far exceeding the expected 28.6% probability, demonstrating systematic order manipulation through InValue grinding.

**Notes:**

The vulnerability exists because the commit-reveal scheme only prevents predicting OTHER miners' InValues, not grinding one's own. The validation mechanism cannot distinguish between legitimately generated and ground InValues since both satisfy `Hash(InValue) == OutValue`. The deterministic nature of HashHelper combined with public previous signatures creates a predictable system that enables systematic exploitation by any miner willing to modify their node software.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-114)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-21)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** src/AElf.Types/Helper/HashHelper.cs (L15-18)
```csharp
        public static Hash ComputeFrom(byte[] bytes)
        {
            return Hash.LoadFromByteArray(bytes.ComputeHash());
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L186-191)
```csharp
    private async Task<Hash> GenerateInValueAsync(IMessage message)
    {
        var data = HashHelper.ComputeFrom(message.ToByteArray());
        var bytes = await _accountService.SignAsync(data.ToByteArray());
        return HashHelper.ComputeFrom(bytes);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L67-69)
```csharp
        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
```

**File:** src/AElf.Cryptography/Core/Secp256k1Curve.cs (L13-20)
```csharp
        {
            _inner = new Secp256k1();
        }

        public IECPoint MultiplyScalar(IECPoint point, IECScalar scalar)
        {
            var output = point.Representation;
            if (!_inner.PublicKeyMultiply(output, scalar.Representation))
```
