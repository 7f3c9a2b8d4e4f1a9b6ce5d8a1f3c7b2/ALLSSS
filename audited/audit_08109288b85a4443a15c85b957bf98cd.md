### Title
Unbounded Miner Count Enables Consensus DoS Through Resource Exhaustion

### Summary
The `GetUpdateValueRound()` function processes all miners in `RealTimeMinersInformation` without any size limit, and the maximum miner count can be set to arbitrarily large values through governance with no upper bound validation. If governance sets an extremely large miner count (e.g., 100,000+), the unbounded loop in the consensus critical path can cause out-of-memory errors, execution limit violations, or transaction timeouts, halting blockchain consensus.

### Finding Description

The vulnerability exists in the `GetUpdateValueRound()` method which loops through all miners in the `RealTimeMinersInformation` dictionary without any bounds checking: [1](#0-0) 

This function is called during consensus block production in the critical path: [2](#0-1) 

The root cause is that `SetMaximumMinersCount` only validates that the input value is greater than zero, with no upper bound check: [3](#0-2) 

Similarly, the Election contract's `UpdateMinersCount` method accepts the miner count value without any validation: [4](#0-3) 

The actual miner count is determined by the minimum of the auto-increased count and the configured maximum: [5](#0-4) 

The auto-increase formula grows the miner count over time based on `MinerIncreaseInterval`, which can be reduced (but not increased) through governance: [6](#0-5) 

With no upper bounds on either parameter, governance can configure the system to support an extremely large miner count that causes resource exhaustion during consensus operations.

### Impact Explanation

**Severity: HIGH**

An extremely large miner count (e.g., 100,000 or higher) would cause:

1. **Memory Exhaustion**: The loop creates a new `MinerInRound` object for each miner and adds it to a dictionary. With 100,000 miners, this allocates massive memory that could exceed available resources.

2. **Execution Limit Violations**: AElf enforces branch and call thresholds through `ExecutionObserver`. A loop with 100,000 iterations would likely exceed these limits: [7](#0-6) 

3. **Transaction Timeout**: Processing 100,000 miners with object creation and dictionary operations would exceed reasonable transaction execution time limits.

4. **Consensus Halt**: Since `GetUpdateValueRound()` is called in the consensus block production path, failure of this function prevents miners from producing blocks, halting the entire blockchain.

**Affected Parties**: All network participants lose access to the blockchain when consensus fails.

### Likelihood Explanation

**Severity: MEDIUM**

The attack requires governance control through the `MaximumMinersCountController` (default: Parliament contract): [8](#0-7) 

**Attack Scenario**:
1. Malicious governance proposal or severe misconfiguration sets `MaximumMinersCount` to 100,000+
2. (Optional) Governance reduces `MinerIncreaseInterval` to accelerate growth to the maximum
3. Over time, the auto-increase formula grows the miner count toward the configured maximum
4. When `GetVictories()` is called during term changes, it returns up to `MinersCount` candidates: [9](#0-8) 

5. These candidates populate `RealTimeMinersInformation` through `GenerateFirstRoundOfNewTerm`: [10](#0-9) 

6. During block production, `GetUpdateValueRound()` attempts to process all miners and fails due to resource exhaustion

**Feasibility**: While this requires governance approval (typically multi-signature Parliament), governance attacks or severe misconfigurations are realistic threat scenarios. The lack of any sanity checks on miner count values makes this easier to exploit through social engineering or operational errors.

### Recommendation

**1. Add Upper Bound Validation in SetMaximumMinersCount**:

Add a reasonable maximum limit (e.g., 1,000 or 2,000 miners) to prevent extreme values:

```csharp
public override Empty SetMaximumMinersCount(Int32Value input)
{
    EnsureElectionContractAddressSet();
    
    Assert(input.Value > 0, "Invalid max miners count.");
    Assert(input.Value <= REASONABLE_MAX_MINER_COUNT, "Max miners count exceeds reasonable limit.");
    
    // ... rest of method
}
```

**2. Add Validation in UpdateMinersCount**:

Add a defensive check in the Election contract:

```csharp
public override Empty UpdateMinersCount(UpdateMinersCountInput input)
{
    Assert(
        Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
        "Only consensus contract can update miners count.");
    Assert(input.MinersCount > 0 && input.MinersCount <= REASONABLE_MAX_MINER_COUNT, 
        "Miners count out of valid range.");
    State.MinersCount.Value = input.MinersCount;
    SyncSubsidyInfoAfterReduceMiner();
    return new Empty();
}
```

**3. Consider Pagination or Batching**:

For very large miner sets, consider refactoring `GetUpdateValueRound()` to use pagination or batching instead of processing all miners in a single call.

**4. Add Test Cases**:

Add regression tests that verify:
- `SetMaximumMinersCount` rejects values above the reasonable maximum
- Consensus operations complete successfully with the maximum allowed miner count
- System behavior is tested at boundary conditions

### Proof of Concept

**Initial State**: 
- Blockchain initialized with default miner count (17)
- Parliament governance contract deployed and functional

**Attack Steps**:

1. **Governance Proposal #1**: Create and approve Parliament proposal to set `MaximumMinersCount` to 100,000:
   - Call `SetMaximumMinersCount` with value 100,000
   - Proposal passes through Parliament governance

2. **Governance Proposal #2** (optional, to accelerate): Create and approve proposal to reduce `MinerIncreaseInterval` to 60 seconds:
   - Call `SetMinerIncreaseInterval` with value 60
   - Auto-increase formula now adds 2 miners every minute

3. **Wait for Auto-Increase**: After approximately 50,000 minutes (~34 days with 60-second interval), the auto-increased count reaches 100,000

4. **Term Change Trigger**: During next term change, `GetVictories()` returns up to 100,000 candidates (if available)

5. **Consensus Failure**: When any miner attempts to produce a block:
   - `GetConsensusBlockExtraData` is called
   - `GetUpdateValueRound()` attempts to loop through 100,000 miners
   - Function exceeds execution limits, memory limits, or times out
   - Block production fails
   - Consensus halts

**Expected Result**: Block production continues normally

**Actual Result**: Transaction fails with resource exhaustion error, consensus halts, blockchain stops producing blocks

**Success Condition**: Blockchain becomes unable to produce new blocks, demonstrating complete consensus DoS.

### Notes

This vulnerability demonstrates a critical gap in governance parameter validation. While governance-controlled parameters are generally trusted, the lack of sanity checks on miner count values creates a single point of failure that could halt the entire blockchain either through malicious governance attacks or operational mistakes. The severity is classified as MEDIUM (not HIGH) only because it requires governance control, but the impact is clearly HIGH (complete consensus failure). Defense-in-depth principles suggest adding reasonable upper bounds even for governance-controlled parameters.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L35-53)
```csharp
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L28-31)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-28)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L29-35)
```csharp
    public void BranchCount()
    {
        if (_branchThreshold != -1 && _branchCount == _branchThreshold)
            throw new RuntimeBranchThresholdExceededException(
                $"Contract branch threshold {_branchThreshold} exceeded.");

        _branchCount++;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-83)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L23-38)
```csharp
        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }
```
