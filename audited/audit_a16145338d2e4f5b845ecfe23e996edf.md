# Audit Report

## Title
Consensus Takeover via Missing Miner List Validation in NextRound Transitions

## Summary
A critical vulnerability in the AEDPoS consensus validation allows any legitimate miner to craft a malicious NextRound block containing only themselves in the miner list, permanently excluding all other miners from consensus. The vulnerability stems from the absence of validation that verifies the ProvidedRound miner list matches the BaseRound miner list during NextRound transitions.

## Finding Description

The vulnerability exists in the consensus validation flow when processing NextRound transitions. The attack exploits two weaknesses:

**Issue 1: Single-Miner Bypass in Time Slot Validation**

The `CheckRoundTimeSlots()` method contains an early return for single-node scenarios that bypasses all time slot equality validation. [1](#0-0) 

When `miners.Count == 1`, the method returns success immediately without executing the validation loop that checks time slot equality between miners.

**Issue 2: Missing Miner List Validation**

The `TimeSlotValidationProvider` calls `CheckRoundTimeSlots()` on the ProvidedRound when validating a new round. [2](#0-1) 

The ProvidedRound originates from the block producer's consensus extra data. [3](#0-2) 

**Why Existing Protections Fail:**

1. The `MiningPermissionValidationProvider` only checks that the sender exists in BaseRound (current state), not that ProvidedRound contains the correct miners. [4](#0-3) 

2. The `NextRoundMiningOrderValidationProvider` only validates internal consistency within ProvidedRound, not that it matches BaseRound. [5](#0-4) 

3. The `RoundTerminateValidationProvider` only checks round number increment and that InValue is null. [6](#0-5) 

4. The `ContinuousBlocksValidationProvider` checks BaseRound.Count, not ProvidedRound.Count. [7](#0-6) 

None of the validation providers verify that ProvidedRound.RealTimeMinersInformation.Count matches BaseRound.RealTimeMinersInformation.Count or that their Keys match.

The validation orchestration confirms these are the only validators applied for NextRound behavior. [8](#0-7) 

Once validation passes, the malicious round is stored directly to state. [9](#0-8) [10](#0-9) 

## Impact Explanation

**Consensus Integrity Compromise:**
- Complete consensus takeover by a single malicious miner
- All legitimate miners (N-1 miners) are permanently excluded from block production
- Loss of decentralization - network becomes centralized under attacker control
- Attacker gains ability to censor any transaction indefinitely
- Enables double-spending attacks as attacker controls all block production
- Network becomes vulnerable to chain reorganizations controlled by single entity

**Operational Impact:**
- Consensus mechanism completely broken
- Network safety and liveness properties violated
- Requires hard fork or emergency governance action to recover
- All staked value of excluded miners becomes unusable
- Economic incentives of consensus completely undermined

**Affected Parties:**
- All legitimate miners lose block production rewards
- Token holders face double-spend risk
- DApp users face transaction censorship
- Entire ecosystem loses trust in consensus mechanism

**Severity: CRITICAL** - Violates the fundamental invariant that miner schedule integrity must be maintained across round transitions, and allows complete consensus takeover by a single malicious actor.

## Likelihood Explanation

**Attacker Capabilities:**
- Must be a current legitimate miner (in BaseRound.RealTimeMinersInformation)
- No additional privileges required beyond normal miner status
- Attacker controls their own node and can produce arbitrary block content

**Attack Complexity:**
- LOW - Requires creating a single malicious NextRound block
- During attacker's regular time slot for block production
- Craft NextRoundInput with RealTimeMinersInformation containing only attacker's public key
- Set FinalOrderOfNextRound = 1 and OutValue to any non-null value for internal consistency
- Set RoundNumber = BaseRound.RoundNumber + 1
- All other fields set to valid values

**Feasibility Conditions:**
- Network must have multiple miners (N > 1) in current round
- Attacker waits for their legitimate turn to produce a block
- No special timing requirements or race conditions
- No need to compromise other nodes or steal keys

**Detection/Operational Constraints:**
- Attack is difficult to detect before execution (appears as normal NextRound)
- Once executed, effect is immediate and irreversible without intervention
- Block validation succeeds, so attack propagates through network
- Recovery requires emergency governance action or hard fork

**Probability: HIGH** - Any current miner can execute this attack at will during their next block production turn with minimal technical complexity and guaranteed success.

## Recommendation

Add a new validation provider `MinerListConsistencyValidationProvider` that validates the ProvidedRound miner list matches the BaseRound miner list for NextRound transitions:

```csharp
public class MinerListConsistencyValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        
        // Get miner keys from both rounds
        var baseRoundMiners = validationContext.BaseRound.RealTimeMinersInformation.Keys.ToHashSet();
        var providedRoundMiners = validationContext.ProvidedRound.RealTimeMinersInformation.Keys.ToHashSet();
        
        // Check counts match
        if (baseRoundMiners.Count != providedRoundMiners.Count)
        {
            validationResult.Message = $"Miner count mismatch: BaseRound has {baseRoundMiners.Count}, ProvidedRound has {providedRoundMiners.Count}";
            return validationResult;
        }
        
        // Check all miners from BaseRound exist in ProvidedRound
        if (!baseRoundMiners.SetEquals(providedRoundMiners))
        {
            validationResult.Message = "Miner list mismatch: ProvidedRound contains different miners than BaseRound";
            return validationResult;
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Register this validator in `AEDPoSContract_Validation.cs` for NextRound behavior:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new MinerListConsistencyValidationProvider()); // Add this line
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanTakeoverConsensus_ByExcludingOtherMiners()
{
    // Setup: Initialize consensus with 3 miners
    var initialMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensusWithMiners(initialMiners);
    
    // Get current round (BaseRound) with all 3 miners
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.Equal(3, currentRound.RealTimeMinersInformation.Count);
    
    // Malicious miner1 crafts NextRound with only themselves
    var maliciousNextRound = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        RealTimeMinersInformation = 
        {
            ["miner1"] = new MinerInRound
            {
                Pubkey = "miner1",
                Order = 1,
                FinalOrderOfNextRound = 1,
                OutValue = Hash.FromString("malicious_outvalue"),
                ExpectedMiningTime = TimestampHelper.GetUtcNow()
            }
        }
    };
    
    // Execute malicious NextRound - this should fail but currently succeeds
    var result = await ConsensusStub.NextRound.SendAsync(maliciousNextRound);
    
    // Verify attack succeeded: new round has only 1 miner
    var newRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.Equal(1, newRound.RealTimeMinersInformation.Count); // VULNERABILITY: Only attacker remains
    Assert.True(newRound.RealTimeMinersInformation.ContainsKey("miner1"));
    Assert.False(newRound.RealTimeMinersInformation.ContainsKey("miner2")); // Excluded
    Assert.False(newRound.RealTimeMinersInformation.ContainsKey("miner3")); // Excluded
    
    // Consensus is now under complete control of miner1
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L36-38)
```csharp
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-30)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-14)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```
