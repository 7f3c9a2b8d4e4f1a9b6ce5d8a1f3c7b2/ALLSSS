### Title
Referendum Organizations Can Be Created with Mathematically Impossible Threshold Combinations Leading to Permanent Governance Deadlock

### Summary
The `Validate` function in the Referendum contract fails to verify that the sum of minimum approval threshold and maximum rejection/abstention thresholds can fit within the minimum vote threshold. This allows creation of organizations where proposals can never mathematically pass, resulting in permanent governance failure for those organizations. Once created, these broken organizations cannot be fixed since threshold changes require passing a proposal.

### Finding Description

The vulnerability exists in the threshold validation logic [1](#0-0) . The validation only checks:
1. MinimalApprovalThreshold ≤ MinimalVoteThreshold
2. MinimalApprovalThreshold > 0
3. MaximalAbstentionThreshold ≥ 0
4. MaximalRejectionThreshold ≥ 0

However, it fails to validate that `MinimalApprovalThreshold + MaximalRejectionThreshold + MaximalAbstentionThreshold ≥ MinimalVoteThreshold`. This missing constraint allows impossible-to-satisfy threshold combinations.

The release threshold check logic [2](#0-1)  requires:
- Total votes (Approval + Rejection + Abstention) ≥ MinimalVoteThreshold
- RejectionCount ≤ MaximalRejectionThreshold
- AbstentionCount ≤ MaximalAbstentionThreshold
- ApprovalCount ≥ MinimalApprovalThreshold

When the sum constraint is violated, no vote distribution can satisfy all four conditions simultaneously. The entry point is the public `CreateOrganization` method [3](#0-2)  which calls the flawed validation. The same vulnerability also affects `ChangeOrganizationThreshold` [4](#0-3) .

Existing test cases [5](#0-4)  validate other threshold constraints but do not test for this sum constraint violation.

### Impact Explanation

This vulnerability causes complete governance failure with the following impacts:

**Governance Deadlock**: Organizations created with invalid threshold combinations become permanently unusable. All proposals submitted to these organizations can never pass, blocking any governance actions including:
- Treasury fund releases
- Contract upgrades
- Parameter changes
- Threshold corrections (requires passing a proposal, which is impossible)

**Permanent State**: Once an organization is created with invalid thresholds, it cannot be fixed through normal mechanisms since fixing requires executing `ChangeOrganizationThreshold` via a proposal that can never pass.

**Affected Parties**: 
- Organization creators lose governance capabilities
- Token holders who lock tokens for voting cannot unlock until proposal expiration
- Any contracts or systems depending on that organization's proposals are blocked

**Severity**: HIGH - While no direct fund theft occurs, this represents a critical governance failure that permanently breaks organizational decision-making capabilities and can trap locked voting tokens.

### Likelihood Explanation

**Attack Complexity**: LOW - Requires only a single transaction with carefully chosen threshold values that pass the weak validation.

**Attacker Capabilities**: ANY user can call `CreateOrganization` [6](#0-5) . No special privileges needed.

**Economic Feasibility**: Attack cost is minimal - only gas fees for creating an organization. Could be used to:
- Grief competitors by creating look-alike broken organizations
- Accidentally create unusable organizations through misconfiguration
- Block critical governance flows if legitimate organizations are updated with invalid thresholds

**Detection**: Organizations appear valid until someone attempts to release a proposal and discovers it's mathematically impossible to pass.

**Probability**: HIGH - The validation passes for invalid configurations, making this easily exploitable either maliciously or accidentally.

### Recommendation

**1. Add Constraint Check in Validation Function**

Modify the `Validate` function to include the sum constraint:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    
    // Add this new check
    var minimalRequiredVotes = proposalReleaseThreshold.MinimalApprovalThreshold + 
                               proposalReleaseThreshold.MaximalRejectionThreshold + 
                               proposalReleaseThreshold.MaximalAbstentionThreshold;
    if (minimalRequiredVotes < proposalReleaseThreshold.MinimalVoteThreshold)
        return false;
    
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

**2. Add Test Cases**

Add test cases to verify the constraint is enforced:
```csharp
// MinimalApprovalThreshold + MaximalRejectionThreshold + MaximalAbstentionThreshold < MinimalVoteThreshold
{
    var validInput = GetValidCreateOrganizationInput();
    validInput.ProposalReleaseThreshold.MinimalVoteThreshold = 100;
    validInput.ProposalReleaseThreshold.MinimalApprovalThreshold = 80;
    validInput.ProposalReleaseThreshold.MaximalRejectionThreshold = 10;
    validInput.ProposalReleaseThreshold.MaximalAbstentionThreshold = 5;
    // Sum = 95 < 100, should fail
    var ret = await ReferendumContractStub.CreateOrganization.SendWithExceptionAsync(validInput);
    ret.TransactionResult.Error.ShouldContain("Invalid organization data");
}
```

**3. Migration Plan**

For existing organizations with invalid thresholds (if any), implement an emergency fix mechanism or administrative override to correct thresholds without requiring proposal passage.

### Proof of Concept

**Initial State**: AElf blockchain with Referendum contract deployed

**Attack Sequence**:

1. **Create Organization with Invalid Thresholds**:
   - MinimalVoteThreshold = 100 (tokens)
   - MinimalApprovalThreshold = 80 (tokens)
   - MaximalRejectionThreshold = 10 (tokens)
   - MaximalAbstentionThreshold = 5 (tokens)
   - Sum = 80 + 10 + 5 = 95 < 100 ✗
   
2. **Call CreateOrganization**: Transaction succeeds, organization created

3. **Attempt to Pass Any Proposal**: 
   - Need total votes ≥ 100
   - Need approval ≥ 80
   - Need rejection ≤ 10
   - Need abstention ≤ 5
   - With 80 approvals, have 20 votes remaining for rejection+abstention
   - But max allowed is 10+5=15
   - **Mathematical impossibility**: Cannot allocate remaining 20 votes without violating constraints

**Expected Result**: Organization validation should fail in step 2

**Actual Result**: Organization created successfully, proposals can never pass

**Success Condition**: The organization accepts the invalid threshold configuration and all subsequent proposals fail the release check permanently.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L12-40)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            TokenSymbol = input.TokenSymbol,
            OrganizationHash = organizationHash,
            ProposerWhiteList = input.ProposerWhiteList,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization data.");

        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;

        State.Organizations[organizationAddress] = organization;
        Context.Fire(new OrganizationCreated
        {
            OrganizationAddress = organizationAddress
        });

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-137)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Referendum.Tests/ReferendumContractTest.cs (L1127-1177)
```csharp
    public async Task CreateOrganization_With_Invalid_Input_Test()
    {
        // token symbol is null or empty
        {
            var validInput = GetValidCreateOrganizationInput();
            validInput.TokenSymbol = string.Empty;
            var ret = await ReferendumContractStub.CreateOrganization.SendWithExceptionAsync(validInput);
            ret.TransactionResult.Error.ShouldContain("Invalid organization data");
        }

        // no proposer in proposeWhiteList
        {
            var validInput = GetValidCreateOrganizationInput();
            validInput.ProposerWhiteList.Proposers.Clear();
            var ret = await ReferendumContractStub.CreateOrganization.SendWithExceptionAsync(validInput);
            ret.TransactionResult.Error.ShouldContain("Invalid organization data");
        }

        //MinimalApprovalThreshold > MinimalVoteThreshold
        {
            var validInput = GetValidCreateOrganizationInput();
            validInput.ProposalReleaseThreshold.MinimalApprovalThreshold =
                validInput.ProposalReleaseThreshold.MinimalVoteThreshold + 1;
            var ret = await ReferendumContractStub.CreateOrganization.SendWithExceptionAsync(validInput);
            ret.TransactionResult.Error.ShouldContain("Invalid organization data");
        }

        //MinimalApprovalThreshold == 0
        {
            var validInput = GetValidCreateOrganizationInput();
            validInput.ProposalReleaseThreshold.MinimalApprovalThreshold = 0;
            var ret = await ReferendumContractStub.CreateOrganization.SendWithExceptionAsync(validInput);
            ret.TransactionResult.Error.ShouldContain("Invalid organization data");
        }

        //MaximalAbstentionThreshold < 0
        {
            var validInput = GetValidCreateOrganizationInput();
            validInput.ProposalReleaseThreshold.MaximalAbstentionThreshold = -1;
            var ret = await ReferendumContractStub.CreateOrganization.SendWithExceptionAsync(validInput);
            ret.TransactionResult.Error.ShouldContain("Invalid organization data");
        }

        //MaximalRejectionThreshold < 0
        {
            var validInput = GetValidCreateOrganizationInput();
            validInput.ProposalReleaseThreshold.MaximalRejectionThreshold = -1;
            var ret = await ReferendumContractStub.CreateOrganization.SendWithExceptionAsync(validInput);
            ret.TransactionResult.Error.ShouldContain("Invalid organization data");
        }
    }
```

**File:** protobuf/referendum_contract.proto (L23-25)
```text
    // Create an organization and return its address.  
    rpc CreateOrganization (CreateOrganizationInput) returns (aelf.Address) {
    }
```
