### Title
Insufficient Validation of Next Round Miner Information Allows Consensus Manipulation

### Summary
The `ValidationForNextRound()` function only validates that `InValue` fields are null in the next round, but fails to validate that `OutValue`, `Signature`, `PreviousInValue`, `FinalOrderOfNextRound`, and other critical consensus fields are also in their initial state. This allows a malicious miner to pre-fill these cryptographically-derived fields with arbitrary values, enabling manipulation of mining order, bypassing consensus protocol integrity, and potentially influencing extra block producer selection.

### Finding Description

**Exact Code Location:** [1](#0-0) 

**Root Cause:**
The validation only checks that `InValue` is null for all miners in the next round, but does not verify that other consensus-critical fields are also in their expected initial state (null/empty/zero). [2](#0-1) 

The `MinerInRound` structure contains multiple consensus-critical fields (`OutValue`, `Signature`, `PreviousInValue`, `FinalOrderOfNextRound`, `ActualMiningTimes`, etc.) that should all be uninitialized in a newly created round.

**Why Existing Protections Fail:**

1. The `NextRoundMiningOrderValidationProvider` only checks that the count of miners with `FinalOrderOfNextRound > 0` equals the count with non-null `OutValue`: [3](#0-2) 

This check can be satisfied by an attacker pre-filling both fields consistently, rather than enforcing that both should be zero/null for a new round.

2. When a legitimate next round is generated, these fields are left uninitialized: [4](#0-3) 

3. The `ProcessNextRound` method directly converts the input to a Round and stores it without sanitization: [5](#0-4) [6](#0-5) 

The `ToRound()` conversion simply copies all fields including any pre-filled malicious values.

**Relevant Execution Path:** [7](#0-6) 

### Impact Explanation

**Consensus Integrity Violation:**
The `OutValue` and `Signature` fields are meant to be cryptographically derived during the consensus process. `OutValue` should equal `Hash(InValue)` and `Signature` should be calculated from `InValue` and previous round signatures. Pre-filling these values breaks this cryptographic chain and allows fake consensus states.

**Mining Order Manipulation:**
The `FinalOrderOfNextRound` field directly determines mining order in the new round: [8](#0-7) 

An attacker can arbitrarily assign mining positions to specific miners, potentially:
- Placing colluding miners in advantageous positions
- Disrupting the intended random order distribution
- Affecting block production timing and round progression

**Extra Block Producer Influence:**
Pre-filled `Signature` values can influence extra block producer selection in subsequent rounds: [9](#0-8) 

The calculation uses the signature of the first miner who produced a block. If an attacker pre-fills signatures for miners likely to be in early orders, they can influence this selection.

**Protocol-Wide Impact:**
This affects all nodes following the consensus, as the manipulated round becomes the canonical state used for subsequent consensus decisions.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an active miner in the current round (mining permission)
- Must be the miner designated to trigger `NextRound` (typically the extra block producer)
- No additional privileges required beyond standard miner role

**Attack Complexity:**
1. Attacker's node generates legitimate next round via `GenerateNextRoundInformation`
2. Attacker modifies the generated round to pre-fill `OutValue`, `Signature`, `FinalOrderOfNextRound` for selected miners (ensuring counts match for validation bypass)
3. Attacker submits `NextRoundInput` with manipulated data
4. Validation passes all checks
5. Manipulated round is stored in state

**Feasibility:**
The attack is straightforward and requires only standard miner capabilities. The validation logic can be analyzed from the open-source code, and the bypass technique (matching counts) is deterministic.

**Detection Constraints:**
- No logging or events specifically detect field manipulation in next round
- The manipulated values appear structurally valid to the validation providers
- Detection would require external monitoring of whether consensus values match expected cryptographic derivations

**Probability Assessment:** HIGH - Attack requires only being a miner at the right time with no complex preconditions.

### Recommendation

**Immediate Fix:**
Add comprehensive validation in `ValidationForNextRound()` to ensure all consensus-critical fields are in their initial state:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Check round number increment
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // Check all miners have uninitialized consensus fields
    foreach (var miner in extraData.Round.RealTimeMinersInformation.Values)
    {
        if (miner.InValue != null)
            return new ValidationResult { Message = "InValue must be null in next round." };
        
        if (miner.OutValue != null)
            return new ValidationResult { Message = "OutValue must be null in next round." };
        
        if (miner.Signature != null)
            return new ValidationResult { Message = "Signature must be null in next round." };
        
        if (miner.PreviousInValue != null && miner.PreviousInValue != Hash.Empty)
            return new ValidationResult { Message = "PreviousInValue must be null in next round." };
        
        if (miner.FinalOrderOfNextRound != 0 || miner.SupposedOrderOfNextRound != 0)
            return new ValidationResult { Message = "Next round order fields must be zero in next round." };
        
        if (miner.ActualMiningTimes.Any())
            return new ValidationResult { Message = "ActualMiningTimes must be empty in next round." };
        
        if (miner.EncryptedPieces.Any() || miner.DecryptedPieces.Any())
            return new ValidationResult { Message = "Secret sharing pieces must be empty in next round." };
    }
    
    return new ValidationResult { Success = true };
}
```

**Additional Safeguards:**
1. Add unit tests verifying that validation rejects next rounds with any pre-filled consensus fields
2. Add integration tests attempting to exploit this validation gap
3. Document the expected initial state invariants for each field in a new round
4. Consider adding event logging when unusual field patterns are detected during validation

### Proof of Concept

**Initial State:**
- Current round N with miners A, B, C, D
- Miner A is the extra block producer designated to trigger NextRound
- Miner A is malicious

**Attack Sequence:**

1. **Round Generation Phase:**
   - Miner A's node calls `GenerateNextRoundInformation` to create legitimate Round N+1
   - Generated round has all miners with: `InValue=null`, `OutValue=null`, `Signature=null`, `FinalOrderOfNextRound=0`

2. **Manipulation Phase:**
   - Miner A modifies the generated Round N+1 before submission:
     - Sets `miner_B.OutValue = Hash_X` (arbitrary value)
     - Sets `miner_B.Signature = Hash_Y` (chosen to manipulate extra block producer selection)
     - Sets `miner_B.FinalOrderOfNextRound = 1` (place miner B first)
     - Sets `miner_C.OutValue = Hash_Z`
     - Sets `miner_C.Signature = Hash_W`
     - Sets `miner_C.FinalOrderOfNextRound = 2`

3. **Submission & Validation:**
   - Miner A submits `NextRound(modified_round_N+1)`
   - `RoundTerminateValidationProvider`: Checks `InValue == null` for all miners → PASS ✓
   - `NextRoundMiningOrderValidationProvider`: Checks `Count(FinalOrderOfNextRound > 0) == Count(OutValue != null)` → 2 == 2 → PASS ✓
   - All other basic validators pass

4. **Result:**
   - Modified Round N+1 is stored in state with manipulated values
   - When Round N+2 is generated, `CalculateNextExtraBlockProducerOrder` uses the fake `Signature` value from miner B
   - Mining order in Round N+1 follows the attacker's chosen `FinalOrderOfNextRound` values rather than legitimate consensus-derived orders

**Expected vs Actual:**
- **Expected:** Validation rejects next round with any non-null consensus fields
- **Actual:** Validation accepts next round with pre-filled `OutValue`, `Signature`, `FinalOrderOfNextRound` as long as counts match

**Success Condition:**
Query the stored Round N+1 from state and observe that miners B and C have non-null `OutValue`, `Signature`, and non-zero `FinalOrderOfNextRound` values despite never having mined in that round yet.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L32-34)
```csharp
        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-28)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-112)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```
