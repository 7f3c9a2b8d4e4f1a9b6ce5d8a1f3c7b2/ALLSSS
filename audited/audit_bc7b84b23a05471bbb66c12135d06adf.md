### Title
NFT Contract Governance Bypass - Method Fee Management Silently Non-Functional

### Summary
The NFT contract implements ACS1 governance interfaces for method fee management (`SetMethodFee`, `ChangeMethodFeeController`) but with empty implementations that perform no operations. Parliament proposals to modify NFT contract fees will execute successfully but have zero effect, permanently hardcoding the Create method fee at 100 ELF and completely bypassing governance control over fee parameters.

### Finding Description

The NFT contract provides non-functional implementations of ACS1 method fee governance methods: [1](#0-0) 

Both `SetMethodFee()` and `ChangeMethodFeeController()` simply return empty objects without performing any state changes. The contract state file lacks the required infrastructure to support fee governance: [2](#0-1) 

Notably absent are the `TransactionFees` (MappedState<string, MethodFees>) and `MethodFeeController` (SingletonState<AuthorityInfo>) state variables that all other system contracts use to implement ACS1 governance. Compare this to the proper implementation in the Election contract: [3](#0-2) 

The NFT contract's `GetMethodFee()` returns a hardcoded 100 ELF fee for the Create method: [4](#0-3) 

The `GetMethodFeeController()` returns an empty AuthorityInfo instead of the Parliament default organization: [5](#0-4) 

According to the ACS1 standard documentation, contracts using hardcoded fees should not implement the governance methods at all: [6](#0-5) 

The test suite contains no verification of ACS1 governance functionality for the NFT contract: [7](#0-6) 

In contrast, other system contracts have comprehensive ACS1 governance tests: [8](#0-7) 

### Impact Explanation

**Governance Impact**: Parliament governance over NFT contract fees is completely bypassed. When governance participants create proposals to adjust NFT fees (e.g., reducing the 100 ELF Create fee during market downturns or increasing it to prevent spam), the proposals will:
1. Pass validation and be created successfully
2. Receive miner approvals
3. Execute without errors upon release
4. Produce zero actual effect on contract behavior

**Operational Impact**: The Create method fee remains permanently hardcoded at 100 ELF (10,000,000,000 base units), modifiable only through contract upgrade. This prevents:
- Dynamic fee adjustment based on ELF token price volatility
- Governance response to spam attacks or economic conditions
- Fair fee structure evolution as the NFT ecosystem matures

**Trust Impact**: The violation of the principle of least surprise undermines trust in the governance system. Governance participants will be misled into believing they control NFT fees when they have no actual control.

**Affected Parties**: 
- Parliament members wasting time/resources on proposals that appear successful but are ineffective
- NFT creators paying potentially inappropriate fees without governance recourse
- Protocol administrators unable to respond to economic conditions without contract upgrades

**Severity Justification**: Medium - While no funds are directly at risk, governance authority over a fee-generating contract is completely bypassed, violating the Authorization & Governance invariant. The issue affects protocol operations and governance legitimacy.

### Likelihood Explanation

**Attacker Capabilities**: No special attacker capabilities required. Any governance participant can:
1. Observe the ACS1 interface methods in the NFT contract
2. Create a Parliament proposal to change fees using standard governance workflow
3. Follow normal approval and release processes
4. Observe proposal success without actual fee changes

**Attack Complexity**: Low - The "attack" is simply normal governance operation that fails silently. The execution path is:
1. Governance participant calls `ParliamentContract.CreateProposal()` targeting `NFTContract.SetMethodFee()`
2. Proposal receives miner approvals
3. Proposal is released via `ParliamentContract.Release()`
4. `NFTContract.SetMethodFee()` executes successfully (returns Empty)
5. Query `NFTContract.GetMethodFee("Create")` still returns hardcoded 100 ELF

**Feasibility**: 100% - This is not a theoretical vulnerability but a current operational gap. Any attempt to use governance to change NFT fees will encounter this issue.

**Detection Constraints**: The silent failure makes detection difficult:
- Proposals execute without errors (status: Mined, no transaction failures)
- No events indicate the operation was ineffective
- Only subsequent queries reveal fees unchanged
- No existing tests validate end-to-end governance functionality

**Probability**: High - As governance participants discover the NFT contract implements ACS1, attempts to adjust fees through governance are inevitable and will all fail silently.

### Recommendation

**Option 1 - Implement Full ACS1 Governance Support** (Recommended if fees need governance control):

1. Add required state variables to `NFTContractState.cs`:
```csharp
public MappedState<string, MethodFees> TransactionFees { get; set; }
public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
```

2. Implement `SetMethodFee()` with authorization and validation: [9](#0-8) 

3. Implement `ChangeMethodFeeController()` with proper checks: [10](#0-9) 

4. Update `GetMethodFee()` to return stored state instead of hardcoded values: [11](#0-10) 

5. Update `GetMethodFeeController()` to return actual controller with Parliament default: [12](#0-11) 

6. Add helper methods for controller initialization and validation: [13](#0-12) 

**Option 2 - Remove Misleading Empty Implementations** (If hardcoded fees are intentional):

Following ACS1 documentation guidance, if fees should remain hardcoded, remove the non-functional methods entirely. Only implement `GetMethodFee()` with hardcoded values. [14](#0-13) 

**Required Test Coverage**:

Add comprehensive ACS1 governance tests similar to other contracts: [15](#0-14) 

Test cases must verify:
- `ChangeMethodFeeController` with invalid authority fails appropriately
- `ChangeMethodFeeController` via Parliament proposal succeeds and persists
- `ChangeMethodFeeController` without authorization fails
- `SetMethodFee` with invalid input fails appropriately  
- `SetMethodFee` without authorization fails
- `SetMethodFee` via Parliament proposal succeeds and fees are actually changed end-to-end

### Proof of Concept

**Required Initial State**:
- NFT contract deployed with current implementation
- Parliament contract active with default organization
- Test account has sufficient ELF for operations

**Transaction Sequence**:

1. Query current Create method fee:
   ```
   Call: NFTContract.GetMethodFee("Create")
   Expected: Returns 100 ELF (10,000,000,000 base units)
   ```

2. Query method fee controller:
   ```
   Call: NFTContract.GetMethodFeeController()
   Expected: Returns empty AuthorityInfo (no owner address, no contract address)
   ```

3. Create Parliament proposal to reduce Create fee to 50 ELF:
   ```
   Call: ParliamentContract.CreateProposal({
     ToAddress: NFTContractAddress,
     ContractMethodName: "SetMethodFee",
     Params: MethodFees { MethodName: "Create", Fees: [{ Symbol: "ELF", BasicFee: 50_00000000 }] }
   })
   Expected: Proposal created successfully, returns proposalId
   ```

4. Miners approve the proposal:
   ```
   Call: ParliamentContract.Approve(proposalId) [by each miner]
   Expected: Approvals recorded successfully
   ```

5. Release the proposal:
   ```
   Call: ParliamentContract.Release(proposalId)
   Expected: TransactionResult.Status = Mined, no errors
   ```

6. Query Create method fee again:
   ```
   Call: NFTContract.GetMethodFee("Create")
   EXPECTED: Returns 50 ELF (if governance worked)
   ACTUAL: Returns 100 ELF (unchanged, governance had no effect)
   ```

**Success Condition**: The proof of concept succeeds in demonstrating the vulnerability when step 6 shows the fee remains at 100 ELF despite the successful governance proposal, proving that Parliament governance over NFT fees is non-functional despite appearing to succeed.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-16)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }

    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L39-43)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        return new AuthorityInfo();
    }

```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L6-46)
```csharp
public partial class NFTContractState : ContractState
{
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
}
```

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L11-30)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }

    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L34-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        return State.TransactionFees[input.Value];
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L39-43)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L49-73)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = GetParliamentDefaultAddress(),
            ContractAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName)
        };

        State.MethodFeeController.Value = defaultAuthority;
    }

    private void AssertSenderAddressWith(Address address)
    {
        Assert(Context.Sender == address, "Unauthorized behavior.");
    }

    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }

```

**File:** docs-sphinx/reference/acs/acs1.rst (L237-277)
```text
later, they can be implemented as follows:

.. code:: c#

   public override MethodFees GetMethodFee(StringValue input)
   {
       if (input.Value == nameof(Foo1) || input.Value == nameof(Foo2))
       {
           return new MethodFees
           {
               MethodName = input.Value,
               Fees =
               {
                   new MethodFee
                   {
                       BasicFee = 1_00000000,
                       Symbol = Context.Variables.NativeSymbol
                   }
               }
           };
       }
       if (input.Value == nameof(Bar1) || input.Value == nameof(Bar2))
       {
           return new MethodFees
           {
               MethodName = input.Value,
               Fees =
               {
                   new MethodFee
                   {
                       BasicFee = 2_00000000,
                       Symbol = Context.Variables.NativeSymbol
                   }
               }
           };
       }
       return new MethodFees();
   }

This implementation can modify the transaction fee only by upgrading the
contract, without implementing the other three interfaces.
```

**File:** test/AElf.Contracts.NFT.Tests/NFTContractTests.cs (L10-274)
```csharp
public partial class NFTContractTests : NFTContractTestBase
{
    private const string BaseUri = "ipfs://aelf/";

    [Fact]
    public async Task<string> CreateTest()
    {
        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Symbol = "ELF",
            Amount = 1_00000000_00000000,
            To = DefaultAddress
        });
        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Symbol = "ELF",
            Amount = 1_00000000_00000000,
            To = MinterAddress
        });

        var executionResult = await NFTContractStub.Create.SendAsync(new CreateInput
        {
            BaseUri = BaseUri,
            Creator = DefaultAddress,
            IsBurnable = true,
            Metadata = new Metadata
            {
                Value =
                {
                    { "Description", "Stands for the human race." }
                }
            },
            NftType = NFTType.VirtualWorlds.ToString(),
            ProtocolName = "HUMAN",
            TotalSupply = 1_000_000_000 // One billion
        });
        var symbol = executionResult.Output.Value;

        symbol.Length.ShouldBe(11);

        var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue
        {
            Value = symbol
        });
        protocolInfo.Symbol.ShouldBe(symbol);
        protocolInfo.Metadata.Value.ShouldContainKey("Description");
        protocolInfo.Creator.ShouldBe(DefaultAddress);
        protocolInfo.NftType.ShouldBe(NFTType.VirtualWorlds.ToString());
        protocolInfo.TotalSupply.ShouldBe(1_000_000_000);

        var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
        {
            Symbol = symbol
        });

        tokenInfo.Decimals.ShouldBe(0);
        tokenInfo.Symbol.ShouldBe(symbol);
        tokenInfo.Issuer.ShouldBe(DefaultAddress);
        tokenInfo.ExternalInfo.Value["Description"].ShouldBe("Stands for the human race.");
        tokenInfo.ExternalInfo.Value["aelf_nft_type"].ShouldBe("VirtualWorlds");
        tokenInfo.ExternalInfo.Value["aelf_nft_base_uri"].ShouldBe(BaseUri);

        return symbol;
    }

    [Fact]
    public async Task<(string, Hash)> MintTest()
    {
        var symbol = await CreateTest();
        await AddMinterAsync(symbol);

        var tokenHash = (await MinterNFTContractStub.Mint.SendAsync(new MintInput
        {
            Symbol = symbol,
            Alias = "could be anything",
            Metadata = new Metadata
            {
                Value =
                {
                    { "Special Property", "A Value" }
                }
            },
            Owner = DefaultAddress,
            Uri = $"{BaseUri}foo"
        })).Output;

        {
            var nftInfo = await NFTContractStub.GetNFTInfoByTokenHash.CallAsync(tokenHash);
            nftInfo.Creator.ShouldBe(DefaultAddress);
            nftInfo.Minters.ShouldContain(MinterAddress);
        }

        {
            var nftInfo = await NFTContractStub.GetNFTInfo.CallAsync(new GetNFTInfoInput
            {
                Symbol = symbol,
                TokenId = 1
            });
            nftInfo.Creator.ShouldBe(DefaultAddress);
            nftInfo.Minters.ShouldContain(MinterAddress);
        }

        {
            var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue
            {
                Value = symbol
            });
            protocolInfo.Metadata.Value.ShouldNotContainKey("Special Property");
        }

        return (symbol, tokenHash);
    }

    [Fact(Skip = "Dup in TransferTest")]
    public async Task<string> MintMultiTokenTest()
    {
        var symbol = await CreateTest();
        await AddMinterAsync(symbol);

        await MinterNFTContractStub.Mint.SendAsync(new MintInput
        {
            Symbol = symbol,
            Alias = "could be anything",
            Metadata = new Metadata
            {
                Value =
                {
                    { "Max Health Points", "0" },
                    { "Max Mana Points", "0" },
                    { "Skill Points", "0" },
                    { "Level", "0" },
                    { "Experience", "0" }
                }
            },
            Quantity = 100,
            Uri = $"{BaseUri}foo"
        });

        return symbol;
    }

    [Fact]
    public async Task<string> TransferTest()
    {
        var symbol = await MintMultiTokenTest();
        await MinterNFTContractStub.Transfer.SendAsync(new TransferInput
        {
            To = User1Address,
            Symbol = symbol,
            TokenId = 1,
            Amount = 10
        });

        {
            var balance = (await MinterNFTContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Owner = User1Address,
                Symbol = symbol,
                TokenId = 1
            })).Balance;
            balance.ShouldBe(10);
        }

        {
            var balance = (await MinterNFTContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Owner = MinterAddress,
                Symbol = symbol,
                TokenId = 1
            })).Balance;
            balance.ShouldBe(90);
        }

        return symbol;
    }

    [Fact]
    public async Task ApproveTest()
    {
        var symbol = await TransferTest();

        await MinterNFTContractStub.Approve.SendAsync(new ApproveInput
        {
            Spender = DefaultAddress,
            Symbol = symbol,
            TokenId = 1,
            Amount = 10
        });

        {
            var allowance = (await NFTContractStub.GetAllowance.CallAsync(new GetAllowanceInput
            {
                Owner = MinterAddress,
                Spender = DefaultAddress,
                Symbol = symbol,
                TokenId = 1
            })).Allowance;
            allowance.ShouldBe(10);
        }

        await NFTContractStub.TransferFrom.SendAsync(new TransferFromInput
        {
            To = User1Address,
            Symbol = symbol,
            TokenId = 1,
            Amount = 9,
            From = MinterAddress
        });

        {
            var balance = (await MinterNFTContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Owner = User1Address,
                Symbol = symbol,
                TokenId = 1
            })).Balance;
            balance.ShouldBe(19);
        }
    }

    [Fact]
    public async Task AssembleTest()
    {
        var (symbol, tokenHash) = await MintTest();

        await TokenContractStub.Approve.SendAsync(new MultiToken.ApproveInput
        {
            Spender = NFTContractAddress,
            Symbol = "ELF",
            Amount = long.MaxValue
        });

        await NFTContractStub.Assemble.SendAsync(new AssembleInput
        {
            Symbol = symbol,
            AssembledNfts = new AssembledNfts
            {
                Value = { [tokenHash.ToHex()] = 1 }
            },
            AssembledFts = new AssembledFts
            {
                Value = { ["ELF"] = 100 }
            },
            Metadata = new Metadata
            {
                Value =
                {
                    ["Advanced Property"] = "whatever"
                }
            }
        });
    }

    private async Task AddMinterAsync(string symbol)
    {
        await NFTContractStub.AddMinters.SendAsync(new AddMintersInput
        {
            Symbol = symbol,
            MinterList = new MinterList
            {
                Value = { MinterAddress }
            }
        });
    }
}
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ACS1ImplTest.cs (L17-92)
```csharp
    [Fact]
    public async Task ChangeMethodFeeController_With_Invalid_Authority_Test()
    {
        var newController = new AuthorityInfo
        {
            OwnerAddress = ElectionContractAddress,
            ContractAddress = ParliamentContractAddress
        };
        var methodFeeController = await ElectionContractStub.GetMethodFeeController.CallAsync(new Empty());
        var proposalCreationMethodName = nameof(ElectionContractStub.ChangeMethodFeeController);
        var proposalId = await CreateProposalAsync(ElectionContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName, newController);
        await ApproveWithMinersAsync(proposalId);
        var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId);
        releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        releaseResult.TransactionResult.Error.ShouldContain("Invalid authority input");
    }

    [Fact]
    public async Task ChangeMethodFeeController_Test()
    {
        var createOrganizationResult =
            await ParliamentContractStub.CreateOrganization.SendAsync(
                new CreateOrganizationInput
                {
                    ProposalReleaseThreshold = new ProposalReleaseThreshold
                    {
                        MinimalApprovalThreshold = 1000,
                        MinimalVoteThreshold = 1000
                    }
                });
        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.TransactionResult.ReturnValue);

        var methodFeeController = await ElectionContractStub.GetMethodFeeController.CallAsync(new Empty());
        var defaultOrganization = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
        methodFeeController.OwnerAddress.ShouldBe(defaultOrganization);

        const string proposalCreationMethodName = nameof(ElectionContractStub.ChangeMethodFeeController);
        var proposalId = await CreateProposalAsync(ElectionContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName, new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = ParliamentContractAddress
            });
        await ApproveWithMinersAsync(proposalId);
        var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId);
        releaseResult.TransactionResult.Error.ShouldBeNullOrEmpty();
        releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var newMethodFeeController = await ElectionContractStub.GetMethodFeeController.CallAsync(new Empty());
        newMethodFeeController.OwnerAddress.ShouldBe(organizationAddress);
    }

    [Fact]
    public async Task ChangeMethodFeeController_WithoutAuth_Test()
    {
        var createOrganizationResult =
            await ParliamentContractStub.CreateOrganization.SendAsync(
                new CreateOrganizationInput
                {
                    ProposalReleaseThreshold = new ProposalReleaseThreshold
                    {
                        MinimalApprovalThreshold = 1000,
                        MinimalVoteThreshold = 1000
                    }
                });
        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.TransactionResult.ReturnValue);
        var result = await ElectionContractStub.ChangeMethodFeeController.SendAsync(new AuthorityInfo
        {
            OwnerAddress = organizationAddress,
            ContractAddress = ParliamentContractAddress
        });

        result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        result.TransactionResult.Error.Contains("Unauthorized behavior.").ShouldBeTrue();
    }
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ACS1ImplTest.cs (L157-188)
```csharp
    public async Task SetMethodFee_Success_Test()
    {
        var tokenSymbol = "ELF";
        var methodName = "Test";
        var basicFee = 111;
        var methodFeeController = await ElectionContractStub.GetMethodFeeController.CallAsync(new Empty());
        const string proposalCreationMethodName = nameof(ElectionContractStub.SetMethodFee);
        var proposalId = await CreateProposalAsync(ElectionContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName, new MethodFees
            {
                MethodName = methodName,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = tokenSymbol,
                        BasicFee = basicFee
                    }
                }
            });
        await ApproveWithMinersAsync(proposalId);
        var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId);
        releaseResult.TransactionResult.Error.ShouldBeNullOrEmpty();
        releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        var getMethodFee = await ElectionContractStub.GetMethodFee.CallAsync(new StringValue
        {
            Value = methodName
        });
        getMethodFee.Fees.Count.ShouldBe(1);
        getMethodFee.Fees[0].Symbol.ShouldBe(tokenSymbol);
        getMethodFee.Fees[0].BasicFee.ShouldBe(basicFee);
    }
```
