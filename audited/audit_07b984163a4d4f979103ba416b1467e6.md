# Audit Report

## Title
Vote Contract Allows Unrestricted Post-Registration Option Manipulation Enabling Vote Outcome Manipulation

## Summary
The Vote contract's `AddOption` and `RemoveOption` methods lack timestamp or voting status validation, allowing sponsors to manipulate vote outcomes by removing leading options or adding new options during active voting periods. This design compromises voting integrity for time-bound governance votes while existing as intended functionality for the Election contract's unlimited-duration use case.

## Finding Description

The Vote contract generates voting item IDs by hashing registration inputs WITHOUT including options, enabling stable IDs despite option changes. [1](#0-0) 

The `AddOption` method only validates sponsor authorization, option length/uniqueness, and maximum count - with no checks against the voting period's start/end timestamps or current voting status. [2](#0-1) 

Similarly, `RemoveOption` only verifies sponsor authorization and option existence, without any temporal validation. [3](#0-2) 

The `Vote` method enforces that voters can only vote for currently-existing options, meaning removed options cannot receive new votes while their existing vote counts remain frozen in the `VotingResult.Results` map. [4](#0-3) 

Registration validation only checks that `EndTimestamp > StartTimestamp`, establishing no expectation of option immutability. [5](#0-4) 

Test cases confirm this behavior is operational, demonstrating options being added during active voting in phase 2 after votes were cast in phase 1, with no time restrictions. [6](#0-5) 

The VotingItem structure includes `start_timestamp` and `end_timestamp` fields, indicating intent for time-bounded voting periods where option stability would be expected. [7](#0-6) 

## Impact Explanation

**For Generic Voting Items (High Severity)**:
- **Vote Outcome Manipulation**: Sponsors can remove options with high vote counts, freezing those votes while competing options continue accumulating votes unrestricted
- **Democratic Fairness Violation**: Late-added options weren't available to early voters, creating unfair advantage
- **Governance Integrity Breach**: For time-bound governance/funding votes, this violates the fundamental principle that ballot options should be fixed once voting begins

**Concrete Attack Scenario**:
1. DAO creates treasury allocation vote with options ["Project A", "Project B", "Project C"], 10-day voting period
2. Days 1-6: Community participates, Project A receives 10,000 votes, B receives 5,000, C receives 3,000
3. Day 7: Sponsor calls `RemoveOption("Project A")` (no timestamp check prevents this)
4. Days 7-10: Only Project B and C can receive new votes; Project B reaches 11,000 votes
5. Outcome: Project B declared winner despite Project A legitimately leading with 10,000 votes

**For Election Contract (Medium Severity)**:
The Election contract uses these methods for candidate management and has partial mitigation through pubkey replacement tracking. [8](#0-7)  However, `QuitElection` removes candidates without replacement, remaining vulnerable. [9](#0-8) 

## Likelihood Explanation

**Reachable Entry Points**: Both `AddOption` and `RemoveOption` are public RPC methods defined in the contract interface. [10](#0-9) 

**Feasible Preconditions**:
- Attacker must be the voting item sponsor OR compromise sponsor account
- Sponsor role is easily obtainable - anyone can register voting items and become sponsor
- Many governance scenarios have sponsors with conflicts of interest (e.g., competing project proposers)
- Multi-sig sponsors increase compromise surface area

**Execution Practicality**:
- Single transaction call with minimal gas fees
- No complex state manipulation required
- The Election contract actively demonstrates this functionality is operational and in production use

**Detection Constraints**:
- Option modifications are recorded on-chain but no events are emitted for option changes
- Users typically don't monitor option lists continuously during voting
- Removed options remain in `VotingResult.Results` making manipulation subtle
- By the time manipulation is discovered, voting period may have ended

**Probability Assessment**: Medium-High. While requiring sponsor privileges, the ease of obtaining sponsor role combined with inherent conflicts of interest in governance scenarios makes this realistically exploitable.

## Recommendation

Implement timestamp-based validation in `AddOption` and `RemoveOption` to prevent option modification during active voting periods:

```csharp
public override Empty AddOption(AddOptionInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
    
    // NEW: Prevent option modification during active voting
    Assert(Context.CurrentBlockTime < votingItem.StartTimestamp, 
        "Cannot add options after voting has started.");
    
    AssertOption(votingItem, input.Option);
    Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
        $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
    votingItem.Options.Add(input.Option);
    State.VotingItems[votingItem.VotingItemId] = votingItem;
    return new Empty();
}
```

Apply similar validation to `RemoveOption`, `AddOptions`, and `RemoveOptions` methods.

**Alternative**: For contracts requiring dynamic options (like Election), implement a flag in `VotingRegisterInput` to explicitly opt-in to mutable options, with strict immutability as the default for time-bound votes.

## Proof of Concept

```csharp
[Fact]
public async Task Vote_Option_Manipulation_During_Active_Voting()
{
    // Register voting item with 10-day period
    var votingItem = await RegisterVotingItemAsync(10, 3, true, DefaultSender, 1);
    var voteItemId = votingItem.VotingItemId;
    
    // Phase 1: Users vote for option[0] - "Project A"
    var voter1 = Accounts[1].KeyPair;
    var voter2 = Accounts[2].KeyPair;
    await Vote(voter1, voteItemId, votingItem.Options[0], 10000);
    await Vote(voter2, voteItemId, votingItem.Options[1], 5000);
    
    // Verify Project A is leading
    var resultBeforeManipulation = await VoteContractStub.GetVotingResult.CallAsync(
        new GetVotingResultInput { VotingItemId = voteItemId, SnapshotNumber = 1 });
    resultBeforeManipulation.Results[votingItem.Options[0]].ShouldBe(10000);
    resultBeforeManipulation.Results[votingItem.Options[1]].ShouldBe(5000);
    
    // ATTACK: Sponsor removes leading option during active voting
    var removeResult = await VoteContractStub.RemoveOption.SendAsync(
        new RemoveOptionInput { VotingItemId = voteItemId, Option = votingItem.Options[0] });
    removeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Succeeds!
    
    // Phase 2: Option[1] continues receiving votes while option[0] is frozen
    var voter3 = Accounts[3].KeyPair;
    await Vote(voter3, voteItemId, votingItem.Options[1], 6000);
    
    // Attempt to vote for removed option fails
    var voteForRemovedOption = await VoteWithException(voter3, voteItemId, votingItem.Options[0], 1000);
    voteForRemovedOption.Status.ShouldBe(TransactionResultStatus.Failed);
    voteForRemovedOption.Error.ShouldContain("Option");
    
    // Result: Option[1] "wins" with 11000 despite option[0] originally leading with 10000
    var finalResult = await VoteContractStub.GetLatestVotingResult.CallAsync(voteItemId);
    finalResult.Results[votingItem.Options[1]].ShouldBe(11000);
    finalResult.Results[votingItem.Options[0]].ShouldBe(10000); // Frozen, cannot receive new votes
}
```

This test demonstrates that a sponsor can successfully remove a leading option during active voting, freezing its vote count while competing options continue accumulating votes, enabling outcome manipulation that violates voting integrity.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteExtensions.cs (L7-12)
```csharp
    public static Hash GetHash(this VotingRegisterInput votingItemInput, Address sponsorAddress)
    {
        var input = votingItemInput.Clone();
        input.Options.Clear();
        return HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(input), HashHelper.ComputeFrom(sponsorAddress));
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L280-290)
```csharp
    public override Empty AddOption(AddOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        AssertOption(votingItem, input.Option);
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        votingItem.Options.Add(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L303-312)
```csharp
    public override Empty RemoveOption(RemoveOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
        votingItem.Options.Remove(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-365)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-381)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
```

**File:** test/AElf.Contracts.Vote.Tests/Full/VoteForBestLanguageTests.cs (L63-77)
```csharp
        //phase 2
        {
            //add some more option
            var options = new[]
            {
                Accounts[3].Address.ToBase58(),
                Accounts[4].Address.ToBase58(),
                Accounts[5].Address.ToBase58()
            };
            var optionResult = (await VoteContractStub.AddOptions.SendAsync(new AddOptionsInput
            {
                VotingItemId = registerItem.VotingItemId,
                Options = { options }
            })).TransactionResult;
            optionResult.Status.ShouldBe(TransactionResultStatus.Mined);
```

**File:** protobuf/vote_contract.proto (L35-41)
```text
    // Add an option to a voting activity.
    rpc AddOption (AddOptionInput) returns (google.protobuf.Empty) {
    }

    // Remove an option from a voting activity.
    rpc RemoveOption (RemoveOptionInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/vote_contract.proto (L106-124)
```text
message VotingItem {
    // The voting activity id.
    aelf.Hash voting_item_id = 1;
    // The token symbol which will be accepted.
    string accepted_currency = 2;
    // Whether the vote will lock token.
    bool is_lock_token = 3;
    // The current snapshot number.
    int64 current_snapshot_number = 4;
    // The total snapshot number.
    int64 total_snapshot_number = 5;
    // The list of options.
    repeated string options = 6;
    // The register time of the voting activity.
    google.protobuf.Timestamp register_timestamp = 7;
    // The start time of the voting.
    google.protobuf.Timestamp start_timestamp = 8;
    // The end time of the voting.
    google.protobuf.Timestamp end_timestamp = 9;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L306-318)
```csharp
        if (!State.InitialMiners.Value.Value.Contains(oldPubkeyByteString))
        {
            State.VoteContract.RemoveOption.Send(new RemoveOptionInput
            {
                VotingItemId = State.MinerElectionVotingItemId.Value,
                Option = oldPubkey
            });
            State.VoteContract.AddOption.Send(new AddOptionInput
            {
                VotingItemId = State.MinerElectionVotingItemId.Value,
                Option = newPubkey
            });
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L257-261)
```csharp
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
```
