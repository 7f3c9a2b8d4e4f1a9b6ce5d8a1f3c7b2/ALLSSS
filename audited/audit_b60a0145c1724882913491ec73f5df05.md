### Title
Consensus Term Transition Bypass via NextRound with Incremented TermNumber

### Summary
A malicious miner can bypass critical term transition logic by crafting consensus extra data with `NEXT_ROUND` behaviour while including a `Round` object with both `RoundNumber` and `TermNumber` incremented. The validation logic only verifies round number correctness for `NEXT_ROUND` behaviour without checking term number consistency, allowing the attacker to skip miner list updates, reward distributions, and treasury releases while creating state inconsistency.

### Finding Description

The vulnerability exists in the consensus validation and processing flow. When a round termination occurs, the validation logic distinguishes between `NextRound` and `NextTerm` behaviours: [1](#0-0) 

For `NEXT_ROUND` behaviour, validation only checks round number increment and that InValues are null. It does NOT validate the term number field. [2](#0-1) 

For `NEXT_TERM` behaviour, validation calls `ValidationForNextRound` first, then additionally checks term number increment.

The root cause is that validation never checks whether the chosen behaviour (NEXT_ROUND vs NEXT_TERM) is appropriate for the current state. The `NeedToChangeTerm` condition is only evaluated during command generation: [3](#0-2) 

But this check is NOT enforced during validation. An attacker can ignore the returned behaviour and craft malicious consensus extra data.

When `ProcessNextRound` executes with a Round containing an incremented term number: [4](#0-3) 

It stores the round via `AddRoundInformation` and only calls `TryToUpdateRoundNumber`, never `TryToUpdateTermNumber`. This creates state inconsistency where `State.Rounds[newRoundNumber].TermNumber` is incremented but `State.CurrentTermNumber` remains unchanged.

Compare with the correct `ProcessNextTerm` flow: [5](#0-4) 

This calls `TryToUpdateTermNumber`, updates miner lists, resets statistics, distributes rewards, releases treasury funds, and takes election snapshots—all of which are bypassed in the attack.

### Impact Explanation

**Consensus Integrity Compromise:**
- State inconsistency: `GetCurrentRoundInformation()` returns a Round with `TermNumber = N+1` while `GetCurrentTermNumber()` returns `N` [6](#0-5) 

**Miner List Manipulation:**
- New elected miners never join because `SetMinerList` is not called [7](#0-6) 
- Current miners maintain indefinite control over block production

**Economic Impact:**
- Mining rewards are not distributed via `DonateMiningReward` [8](#0-7) 
- Treasury release never occurs, breaking economic cycles
- Election snapshots are not taken, corrupting voting/staking records

**Operational DoS:**
- The blockchain cannot recover from this state without hard fork
- All dependent contracts (Election, Treasury, Profit) receive inconsistent data
- Term-based logic across the ecosystem fails

This is a **CRITICAL** severity issue as it allows a single malicious miner to permanently compromise consensus integrity, maintain unauthorized control, and halt economic operations.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a current miner (one of the extra block producer candidates)
- Can craft arbitrary consensus extra data in blocks they produce
- Requires no special privileges beyond normal mining permissions

**Attack Complexity:**
- Low: Simply craft consensus header information with `Behaviour = NEXT_ROUND` instead of `NEXT_TERM`
- Include a Round object with both `RoundNumber` and `TermNumber` incremented
- The transaction generation uses the behaviour field directly: [9](#0-8) 

**Feasibility Conditions:**
- Attack window: Every term transition (e.g., every 7 days by default)
- The attacker must be scheduled as the extra block producer when term change is due
- With rotating miner schedules, any miner can eventually execute this attack

**Detection Constraints:**
- The malicious block passes all validation checks
- The inconsistency may not be immediately obvious to observers
- By the time the issue is detected, recovery requires coordinated intervention

**Economic Rationality:**
- Cost: Only the cost of producing one block
- Benefit: Maintain mining privileges indefinitely, control reward distribution, prevent competitor miners from joining
- Attack is highly profitable for a malicious miner

Likelihood assessment: **HIGH** - The attack is technically simple, has regular opportunities, passes validation, and is economically rational for any miner seeking to maintain control.

### Recommendation

**Immediate Fix:**
Add validation in `RoundTerminateValidationProvider` to enforce that when `NeedToChangeTerm` is true, the behaviour MUST be `NEXT_TERM`:

```csharp
// In RoundTerminateValidationProvider.ValidateHeaderInformation
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var extraData = validationContext.ExtraData;
    
    // NEW CHECK: Enforce NextTerm when required
    if (ShouldBeNextTerm(validationContext) && 
        extraData.Behaviour != AElfConsensusBehaviour.NextTerm)
    {
        return new ValidationResult { 
            Message = "Term change required but behaviour is not NextTerm." 
        };
    }
    
    if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) 
        return ValidationForNextRound(validationContext);
    
    if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) 
        return ValidationForNextTerm(validationContext);
    
    validationResult.Success = true;
    return validationResult;
}

private bool ShouldBeNextTerm(ConsensusValidationContext validationContext)
{
    return validationContext.BaseRound.NeedToChangeTerm(
        GetBlockchainStartTimestamp(),
        validationContext.CurrentTermNumber,
        State.PeriodSeconds.Value);
}
```

**Additional Check:**
In `ValidationForNextRound`, add explicit term number consistency check:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // NEW CHECK: Term number must not change in NextRound
    if (validationContext.BaseRound.TermNumber != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Term number cannot change in NextRound." };
    
    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

**Test Cases:**
1. Verify that NextRound with incremented TermNumber is rejected
2. Verify that NextRound when NeedToChangeTerm is true is rejected
3. Verify that NextTerm is enforced when period threshold is reached
4. Verify state consistency after term transitions

### Proof of Concept

**Initial State:**
- Current term: 5, Current round: 100
- Blockchain age: 604800 seconds (7 days)
- Period seconds: 604800
- Term transition is due (NeedToChangeTerm returns true)
- Attacker is the extra block producer for round 100

**Attack Steps:**

1. GetConsensusCommand returns NextTerm behaviour as expected

2. Attacker crafts malicious consensus extra data:
   - `Behaviour = AElfConsensusBehaviour.NextRound` (instead of NextTerm)
   - `Round.RoundNumber = 101`
   - `Round.TermNumber = 6` (incremented!)
   - All other fields properly set

3. Block validation occurs via `ValidateConsensusBeforeExecution`

4. `RoundTerminateValidationProvider.ValidationForNextRound` executes:
   - Checks: `100 + 1 == 101` ✓
   - Checks: InValues are null ✓
   - **Does NOT check term number**
   - Validation passes ✓

5. `GenerateConsensusTransactions` creates `NextRound` transaction with `NextRoundInput.Create(round, randomNumber)`

6. `NextRound` method executes → `ProcessNextRound` is called

7. `ProcessNextRound` executes:
   - `AddRoundInformation(nextRound)` stores Round{RoundNumber=101, TermNumber=6}
   - `TryToUpdateRoundNumber(101)` sets `State.CurrentRoundNumber = 101`
   - **`TryToUpdateTermNumber` is NEVER called**

**Result:**
- `State.CurrentTermNumber.Value = 5` (unchanged!)
- `State.CurrentRoundNumber.Value = 101`
- `State.Rounds[101].TermNumber = 6`
- `GetCurrentTermNumber()` returns 5
- `GetCurrentRoundInformation().TermNumber` returns 6
- **State inconsistency achieved**
- Miner list never updated
- Rewards never distributed
- Treasury never released
- Election snapshot never taken

**Success Condition:**
The attack succeeds if after the malicious block, `GetCurrentTermNumber() != GetCurrentRoundInformation().TermNumber`, demonstrating the state inconsistency and bypassed term transition logic.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L16-24)
```csharp
    public override Int64Value GetCurrentRoundNumber(Empty input)
    {
        return new() { Value = State.CurrentRoundNumber.Value };
    }

    public override Round GetCurrentRoundInformation(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var currentRound) ? currentRound : new Round();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L164-179)
```csharp
            case AElfConsensusBehaviour.NextRound:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextRound), NextRoundInput.Create(round,randomNumber))
                    }
                };
            case AElfConsensusBehaviour.NextTerm:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextTerm), NextTermInput.Create(round,randomNumber))
                    }
                };
```
