### Title
Unvalidated RevealedInValues Injection Breaking VRF Chain and Secret Sharing Protocol

### Summary
The `UpdateLatestSecretPieces` function accepts arbitrary `RevealedInValues` from block producers without validating that these values match the expected VRF chain (i.e., `Hash(revealedInValue) == previousOutValue`). This allows malicious miners to inject fake `previousInValue` values for other miners, breaking the secret sharing protocol's integrity and compromising the VRF chain used for consensus randomness.

### Finding Description

The vulnerability exists in the consensus data update flow where revealed InValues are processed without proper validation:

**Primary Vulnerable Code Location:** [1](#0-0) 

In `UpdateLatestSecretPieces`, the function iterates through `triggerInformation.RevealedInValues` and sets other miners' `PreviousInValue` fields without any validation. The only check is whether the value is currently empty or null - there is no cryptographic verification that the revealed value is correct.

**Insufficient Validation:** [2](#0-1) 

The `ValidatePreviousInValue` method only validates the sender's own `previousInValue` by checking `HashHelper.ComputeFrom(previousInValue) == previousOutValue`. It does not iterate through or validate the `RevealedInValues` for other miners that were injected via the trigger information.

**Exploitation Path:** [3](#0-2) 

When `ApplyNormalConsensusData` is called, it accepts `previousInValue` as a parameter and sets it without validation (only checking if empty). [4](#0-3) 

**Propagation of Fake Values:** [5](#0-4) 

In `SupplyCurrentRoundInformation`, for miners who didn't mine, the function retrieves `previousInValue` from the current round (which could be a fake injected value) and uses it to calculate signatures. These signatures influence consensus state. [6](#0-5) 

The `CalculateSignature` method XORs the `inValue` with existing signatures, meaning fake values affect the consensus randomness computation.

### Impact Explanation

**VRF Chain Integrity Broken:**
The consensus protocol relies on a verifiable random function chain where each `OutValue` is `Hash(InValue)`, and the `previousInValue` in round N+1 must equal the `InValue` from round N. Without validating `Hash(revealedInValue) == previousOutValue`, this chain integrity is compromised.

**Secret Sharing Protocol Compromised:**
The secret sharing mechanism assumes that revealed InValues are authentic. Injecting arbitrary values breaks this fundamental assumption, allowing attackers to manipulate the state of miners who didn't produce blocks.

**Consensus State Manipulation:**
Fake `previousInValue` entries are stored in miners' InValue fields and used in signature calculations, which aggregate into the consensus randomness. While this may not directly control mining order for active miners, it corrupts the consensus state and undermines protocol security assumptions.

**Affected Parties:**
- Miners who miss time slots have their consensus data corrupted
- The entire network suffers from compromised randomness integrity
- Protocol security guarantees are violated

**Severity: HIGH** - This breaks a critical security invariant (VRF chain validation) that the entire consensus mechanism depends upon for its security properties.

### Likelihood Explanation

**Attacker Capabilities:**
Any miner can exploit this vulnerability by modifying their node software to inject arbitrary `RevealedInValues` in the consensus trigger information.

**Attack Complexity:**
Low - The attacker simply needs to:
1. Modify their node's `SecretSharingService` to return fake values in `GetRevealedInValues()`
2. Produce a block with the malicious trigger information
3. The fake values are automatically accepted on-chain without validation

**Feasibility Conditions:**
- Attacker must be an active miner (can produce blocks)
- Target miners must have empty/null `PreviousInValue` (e.g., miners who missed their slots)
- No additional prerequisites required

**Detection Constraints:**
The attack is difficult to detect because:
- RevealedInValues are expected to vary based on secret sharing reconstruction
- No on-chain mechanism exists to verify their correctness
- The fake values appear structurally valid (proper Hash format)

**Probability: HIGH** - The attack is straightforward for any miner with modified node software, and the AEDPoS consensus model explicitly considers adversarial miners.

### Recommendation

**Immediate Fix:**
Add validation in `UpdateLatestSecretPieces` to verify each revealed InValue:

```csharp
foreach (var revealedInValue in triggerInformation.RevealedInValues)
{
    if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
        (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
         updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
    {
        // ADD VALIDATION HERE
        if (TryToGetPreviousRoundInformation(out var prevRound) && 
            prevRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
        {
            var expectedOutValue = prevRound.RealTimeMinersInformation[revealedInValue.Key].OutValue;
            if (expectedOutValue != null && expectedOutValue != Hash.Empty)
            {
                // Verify: Hash(revealedInValue) == expectedOutValue
                if (HashHelper.ComputeFrom(revealedInValue.Value) != expectedOutValue)
                {
                    Context.LogDebug(() => $"Invalid revealed in value for {revealedInValue.Key}");
                    continue; // Skip invalid revealed value
                }
            }
        }
        
        updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
    }
}
```

**Invariant to Enforce:**
`∀ miner ∈ RevealedInValues: Hash(PreviousInValue_N) == OutValue_{N-1}`

**Test Cases:**
1. Test that RevealedInValues with correct hashes are accepted
2. Test that RevealedInValues with incorrect hashes are rejected
3. Test that missing OutValues don't cause validation failures
4. Test that the VRF chain remains intact across multiple rounds

### Proof of Concept

**Initial State:**
- Round N: Miner A produces block, Miner B misses time slot
- Miner B's `OutValue` from round N-1 = `Hash("legitimate_secret")` = `0x123abc...`

**Attack Steps:**
1. Miner A modifies their node's `SecretSharingService.GetRevealedInValues()` to return:
   ```
   { "MinerB_Pubkey": Hash("fake_secret") } // where Hash("fake_secret") = 0x456def... ≠ 0x123abc...
   ```

2. Miner A produces a block in Round N+1 with this malicious trigger information

3. On-chain execution:
   - `UpdateLatestSecretPieces` processes RevealedInValues
   - Sets `MinerB.PreviousInValue = Hash("fake_secret")` without validation
   - No error occurs

4. In `SupplyCurrentRoundInformation` (when NextRound is called):
   - Retrieves `MinerB.PreviousInValue = Hash("fake_secret")`
   - Calculates `MinerB.Signature` using this fake value
   - Sets `MinerB.InValue = Hash("fake_secret")`

**Expected Result:**
The transaction should fail with "Invalid revealed in value" error.

**Actual Result:**
The fake value is accepted and stored, breaking the VRF chain integrity. `Hash(MinerB.PreviousInValue) ≠ MinerB.OutValue_from_previous_round`, violating the critical invariant.

**Success Condition:**
Query Miner B's `PreviousInValue` in round N+1 and verify it equals `Hash("fake_secret")` instead of the legitimate value, proving the VRF chain is broken.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L14-16)
```csharp
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L186-200)
```csharp
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
