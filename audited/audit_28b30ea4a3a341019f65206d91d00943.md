# Audit Report

## Title
Scheme Manager Can Steal Profit Shares from Locked Token Holders via RemoveBeneficiary

## Summary
The TokenHolder contract's `RemoveBeneficiary` function allows scheme managers to remove or reduce profit shares from users who locked tokens via `RegisterForProfits`, while their tokens remain locked for the minimum lock period. This breaks the core economic guarantee that locking tokens entitles users to proportional profit distributions for the duration of the lock.

## Finding Description

The vulnerability exists in the `RemoveBeneficiary` function which fails to distinguish between two types of beneficiaries:

1. **Manager-added beneficiaries** (via `AddBeneficiary`): No tokens locked, freely removable
2. **Self-registered beneficiaries** (via `RegisterForProfits`): Tokens locked with minimum duration, should be protected

When a scheme is created, it sets `CanRemoveBeneficiaryDirectly = true` [1](#0-0) , allowing the manager to remove any beneficiary.

When users register for profits, they lock their tokens and the lock ID is stored [2](#0-1) , then they're added as beneficiaries to the Profit contract with shares equal to their locked amount [3](#0-2) .

However, the `RemoveBeneficiary` function only validates the caller is the scheme manager [4](#0-3)  and proceeds to remove the beneficiary from the Profit contract [5](#0-4)  without:
- Checking if the beneficiary has locked tokens
- Unlocking the tokens
- Removing the lock ID from state

In the Profit contract, when `CanRemoveBeneficiaryDirectly` is true, the removal sets the beneficiary's `EndPeriod` to `CurrentPeriod - 1` [6](#0-5) , effectively terminating all future profit claims.

The user can still eventually call `Withdraw` to unlock their tokens [7](#0-6) , but only after the minimum lock period expires [8](#0-7) . During this forced lock period with zero profit shares, the manager (or other beneficiaries) receive the redistributed profit allocations that should have gone to the victim.

## Impact Explanation

This vulnerability enables direct theft of profit distributions:

**Financial Impact:**
- Users lock capital expecting proportional profits for the lock duration
- Manager removes their shares while tokens remain locked
- During the lock period, users receive zero profits despite locked capital
- The "stolen" profit share is redistributed to remaining beneficiaries (potentially including the manager)

**Quantified Example:**
A user locks 10,000 tokens for a 30-day minimum lock period. If the manager removes 9,999 of their 10,000 shares:
- User expected: 50% of profits if manager has equal shares (5,000 tokens from 10,000 distributed)
- User receives: ~0.01% of profits (1 token from 10,000 distributed)
- Manager receives: ~99.99% of profits (9,999 tokens)
- Net theft: ~4,999 tokens of profit while user's capital remains locked

**Severity:**
Critical - This violates the fundamental economic invariant that locked tokens guarantee proportional profit share. It's a direct authorization bypass where the manager gains unauthorized control over profit distributions that should be protected by the lock mechanism.

## Likelihood Explanation

**High Likelihood due to:**

1. **Low Attacker Requirements:**
   - Any user can become a scheme manager by calling `CreateScheme` (permissionless)
   - No special privileges required beyond scheme creation
   - Single function call to execute the attack

2. **No Technical Barriers:**
   - Attack is a simple `RemoveBeneficiary` transaction
   - No timing constraints or race conditions
   - No complex state manipulation needed
   - Works immediately after users lock tokens

3. **Expected User Behavior:**
   - Users locking tokens via `RegisterForProfits` is normal, expected usage
   - No way for users to detect malicious intent before locking
   - Once locked, users cannot escape until minimum period expires

4. **Economic Incentives:**
   - Zero cost attack (just transaction fee)
   - Direct profit for attacker (receives redistributed shares)
   - Rational for any malicious manager
   - Appears as "legitimate" scheme management on-chain

## Recommendation

Add a protection in `RemoveBeneficiary` to prevent removing beneficiaries who have active token locks:

```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);
    
    // NEW: Check if beneficiary has locked tokens
    var lockId = State.LockIds[Context.Sender][input.Beneficiary];
    Assert(lockId == null, "Cannot remove beneficiary with locked tokens. User must withdraw first.");
    
    // ... rest of existing logic
}
```

Alternatively, automatically unlock tokens when removing beneficiaries who registered via `RegisterForProfits`:

```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);
    var lockId = State.LockIds[Context.Sender][input.Beneficiary];
    
    // If beneficiary has locked tokens, unlock them first
    if (lockId != null)
    {
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = input.Beneficiary,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
        
        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = input.Beneficiary,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });
        
        State.LockIds[Context.Sender].Remove(input.Beneficiary);
    }
    
    // ... rest of existing logic
}
```

## Proof of Concept

```csharp
[Fact]
public async Task Manager_Can_Steal_Profits_From_Locked_Token_Holders()
{
    // 1. Manager creates scheme with 30-day minimum lock
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 43200 // 30 days
    });
    
    // 2. Victim locks 10,000 tokens to register for profits
    await UserTokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = 10000,
        SchemeManager = Starter
    });
    
    // 3. Verify victim has shares in Profit contract
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
    {
        Manager = Starter
    });
    var victimShares = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeIds.SchemeIds[0],
        Beneficiary = UserAddress
    });
    victimShares.Details[0].Shares.ShouldBe(10000); // Victim has 10,000 shares
    
    // 4. Manager maliciously removes victim's shares
    await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
    {
        Beneficiary = UserAddress
    });
    
    // 5. Verify victim's shares are removed/reduced
    var afterRemoval = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeIds.SchemeIds[0],
        Beneficiary = UserAddress
    });
    afterRemoval.Details[0].EndPeriod.ShouldBeLessThan(afterRemoval.Details[0].StartPeriod); // EndPeriod set to past
    
    // 6. Verify victim's tokens are STILL LOCKED
    var lockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = UserAddress,
        Symbol = "ELF",
        LockId = State.LockIds[Starter][UserAddress] // LockId still exists
    });
    lockedAmount.Amount.ShouldBe(10000); // Tokens still locked!
    
    // 7. Verify victim CANNOT withdraw (minimum lock period not passed)
    var withdrawResult = await UserTokenHolderContractStub.Withdraw.SendWithExceptionAsync(Starter);
    withdrawResult.TransactionResult.Error.ShouldContain("Cannot withdraw"); // Locked for 30 days
    
    // VULNERABILITY CONFIRMED: 
    // - Victim's profit shares removed (cannot claim future profits)
    // - Victim's tokens remain locked for 30 days
    // - Manager profits from redistributed shares while victim loses profits
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-72)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L80-95)
```csharp
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L157-167)
```csharp
        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L168-176)
```csharp
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-245)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L351-356)
```csharp
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }
```
