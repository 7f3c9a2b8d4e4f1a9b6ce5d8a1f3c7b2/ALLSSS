### Title
Token Issuer Modification Never Persisted to Storage - Old Issuer Retains All Privileges

### Summary
The `ModifyTokenIssuerAndOwner()` function modifies the token issuer and owner in a local memory copy but fails to persist these changes back to contract storage. As a result, the modification has no effect whatsoever - the old issuer retains 100% of their issuing privileges, while the intended new issuer gains no privileges. This completely breaks the token ownership transfer mechanism.

### Finding Description

The vulnerability exists in the `ModifyTokenIssuerAndOwner()` function. [1](#0-0) 

**Root Cause:**

The function retrieves `tokenInfo` from storage, modifies the `Issuer` and `Owner` fields in the local object, but never persists the changes back to storage by calling `SetTokenInfo()`.

**Why Protections Fail:**

The contract uses a `MappedState<string, TokenInfo>` storage pattern declared in TokenContractState: [2](#0-1) 

The helper method `SetTokenInfo()` is required to persist changes: [3](#0-2) 

**Evidence from Correct Implementations:**

All other functions that modify `tokenInfo` correctly call `SetTokenInfo()`:

1. The `Issue()` function modifies supply and correctly persists: [4](#0-3) 

2. The `CrossChainReceiveToken()` function modifies supply and correctly persists: [5](#0-4) 

3. The `SetSymbolAlias()` function modifies external info and correctly persists: [6](#0-5) 

**Execution Path:**

When `Issue()` is called after `ModifyTokenIssuerAndOwner()`, it reads the issuer from storage and validates against it: [7](#0-6) 

Since the issuer was never updated in storage, the check passes for the old issuer and fails for the new issuer.

### Impact Explanation

**Direct Authorization Impact:**

- The token issuer modification function is completely non-functional
- Old issuer retains 100% of token issuance privileges indefinitely
- New issuer receives 0% privileges despite the function call succeeding
- Token creators cannot transfer control to new addresses as designed

**Operational Impact:**

- Breaks the entire token ownership transfer mechanism
- Creates a false sense of security - function appears to work (no error thrown) but has no effect
- Users who call this function believe they have transferred issuer rights when they haven't
- Violates the critical invariant: "Authorization & Governance - method-fee provider authority"

**Who Is Affected:**

- All token creators who attempt to use `ModifyTokenIssuerAndOwner()`
- Projects that rely on transferring token control to DAOs or new addresses
- Any governance structure expecting issuer changes to be effective

**Severity Justification:**

HIGH severity because:
1. Complete failure of a critical authorization control mechanism
2. 100% reproducibility on every function call
3. Violates fundamental token ownership transfer expectations
4. Creates persistent security vulnerabilities where old issuers retain unauthorized control

### Likelihood Explanation

**Attacker Capabilities:**

No attacker action required - this is a functional bug that affects all legitimate users.

**Attack Complexity:**

None - the bug triggers automatically on every call to `ModifyTokenIssuerAndOwner()`.

**Feasibility Conditions:**

- The function is publicly callable by any token issuer
- No special permissions or state required beyond being the current issuer
- Happens in 100% of cases

**Probability:**

Certain (100%) - every single execution of `ModifyTokenIssuerAndOwner()` results in the issuer modification not being persisted to storage.

### Recommendation

**Code-Level Mitigation:**

Add the missing `SetTokenInfo()` call to persist the modified token information:

```csharp
public override Empty ModifyTokenIssuerAndOwner(ModifyTokenIssuerAndOwnerInput input)
{
    Assert(!State.TokenIssuerAndOwnerModificationDisabled.Value, "Set token issuer and owner disabled.");
    Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
    Assert(input.Issuer != null && !input.Issuer.Value.IsNullOrEmpty(), "Invalid input issuer.");
    Assert(input.Owner != null && !input.Owner.Value.IsNullOrEmpty(), "Invalid input owner.");

    var tokenInfo = GetTokenInfo(input.Symbol);

    Assert(tokenInfo != null, "Token is not found.");
    Assert(tokenInfo.Issuer == Context.Sender, "Only token issuer can set token issuer and owner.");
    Assert(tokenInfo.Owner == null, "Can only set token which does not have owner.");
    
    tokenInfo.Issuer = input.Issuer;
    tokenInfo.Owner = input.Owner;
    
    SetTokenInfo(tokenInfo);  // ADD THIS LINE
    
    // RECOMMENDED: Fire an event to track the modification
    Context.Fire(new TokenIssuerAndOwnerChanged
    {
        Symbol = input.Symbol,
        NewIssuer = input.Issuer,
        NewOwner = input.Owner
    });

    return new Empty();
}
```

**Invariant Checks:**

Add integration tests that verify:
1. After calling `ModifyTokenIssuerAndOwner()`, the new issuer can successfully call `Issue()`
2. After calling `ModifyTokenIssuerAndOwner()`, the old issuer cannot call `Issue()`
3. Verify `GetTokenInfo()` returns the updated issuer and owner after modification

**Test Cases to Prevent Regression:**

```csharp
[Fact]
public void ModifyTokenIssuerAndOwner_Should_Persist_Changes()
{
    // Create token with issuer A
    // Call ModifyTokenIssuerAndOwner to change to issuer B
    // Verify GetTokenInfo shows issuer B
    // Verify issuer B can call Issue()
    // Verify issuer A cannot call Issue()
}
```

### Proof of Concept

**Initial State:**
1. Token "TEST" exists with Issuer = AddressA, Owner = null
2. AddressA has successfully issued tokens in the past

**Transaction Steps:**

Step 1: AddressA calls `ModifyTokenIssuerAndOwner()`
```
Input: {
  Symbol: "TEST",
  Issuer: AddressB,
  Owner: AddressB
}
Sender: AddressA
```
Result: Transaction succeeds with no error

Step 2: Query `GetTokenInfo("TEST")`
```
Result: {
  Symbol: "TEST",
  Issuer: AddressA,  // Still the old issuer!
  Owner: null         // Still null!
  ...
}
```

Step 3: AddressB (intended new issuer) calls `Issue()`
```
Input: {
  Symbol: "TEST",
  Amount: 1000,
  To: AddressB
}
Sender: AddressB
```
Result: Transaction FAILS with error "Sender is not allowed to issue token TEST"

Step 4: AddressA (old issuer) calls `Issue()`
```
Input: {
  Symbol: "TEST",
  Amount: 1000,
  To: AddressA
}
Sender: AddressA
```
Result: Transaction SUCCEEDS - old issuer still has full privileges

**Expected vs Actual Result:**

Expected: After Step 1, AddressB should be the issuer and able to issue tokens, AddressA should lose issuing privileges

Actual: After Step 1, nothing changes in storage - AddressA retains all issuing privileges, AddressB gains none

**Success Condition:**

The vulnerability is confirmed if after calling `ModifyTokenIssuerAndOwner()`, the old issuer can still successfully call `Issue()` while the new issuer cannot.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L158-161)
```csharp
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L163-167)
```csharp
        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L620-622)
```csharp
        tokenInfo.Supply = tokenInfo.Supply.Add(amount);
        Assert(tokenInfo.Supply <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L642-659)
```csharp
    public override Empty ModifyTokenIssuerAndOwner(ModifyTokenIssuerAndOwnerInput input)
    {
        Assert(!State.TokenIssuerAndOwnerModificationDisabled.Value, "Set token issuer and owner disabled.");
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        Assert(input.Issuer != null && !input.Issuer.Value.IsNullOrEmpty(), "Invalid input issuer.");
        Assert(input.Owner != null && !input.Owner.Value.IsNullOrEmpty(), "Invalid input owner.");

        var tokenInfo = GetTokenInfo(input.Symbol);

        Assert(tokenInfo != null, "Token is not found.");
        Assert(tokenInfo.Issuer == Context.Sender, "Only token issuer can set token issuer and owner.");
        Assert(tokenInfo.Owner == null, "Can only set token which does not have owner.");
        
        tokenInfo.Issuer = input.Issuer;
        tokenInfo.Owner = input.Owner;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L763-766)
```csharp
        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L12-16)
```csharp
    /// <summary>
    /// WARNING: Use GetTokenInfo & SetTokenInfo to operate TokenInfos
    /// due to token symbol alias feature.
    /// </summary>
    public MappedState<string, TokenInfo> TokenInfos { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L418-422)
```csharp
    private void SetTokenInfo(TokenInfo tokenInfo)
    {
        var symbol = tokenInfo.Symbol;
        State.TokenInfos[symbol] = tokenInfo;
    }
```
