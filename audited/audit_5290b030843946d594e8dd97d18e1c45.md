### Title
Unvalidated Encrypted Secret Pieces Allow Injection of Fake Shares in Consensus Secret Sharing Mechanism

### Summary
The `PerformSecretSharing` function accepts encrypted pieces from miners without validating they correspond to actual secret shares of the miner's InValue. When honest miners decrypt these fake pieces and reconstruct the miner's PreviousInValue using Shamir's Secret Sharing, the wrong reconstructed value is used in signature calculations that determine mining order, breaking the verifiable random function property of the consensus.

### Finding Description

**Root Cause:**

In `PerformSecretSharing`, encrypted pieces from `UpdateValueInput` are directly added to the miner's state without any validation: [1](#0-0) 

There is no check that these encrypted pieces actually correspond to secret shares of the InValue that hashes to the miner's published OutValue.

**Missing Validation Points:**

1. When miners submit reconstructed `PreviousInValue` values for other miners through `MinersPreviousInValues`, these are set directly without validation: [2](#0-1) 

2. When `RevealSharedInValues` reconstructs a miner's InValue from decrypted pieces, it sets the value without validating it matches the previously committed OutValue: [3](#0-2) 

3. The validation provider only checks the block producer's own PreviousInValue, not values being set for other miners: [4](#0-3) 

**Exploitation Path:**

1. **Round N - Injection:** Malicious miner submits `UpdateValueInput` with fake `encrypted_pieces` (random data or shares of a different secret instead of shares of their actual InValue that corresponds to their OutValue).

2. **Round N+1 - Decryption:** Honest miners decrypt the fake pieces they received and obtain garbage data.

3. **Reconstruction:** Off-chain, the `SecretSharingService` attempts to reconstruct the malicious miner's InValue from the fake decrypted pieces using Shamir's Secret Sharing, resulting in a wrong value: [5](#0-4) 

4. **Wrong Value Propagation:** The wrong reconstructed InValue is submitted by honest miners and set as the malicious miner's `PreviousInValue` without validation.

5. **Impact on Signature Calculation:** When the malicious miner doesn't produce a block, `SupplyCurrentRoundInformation` retrieves the wrong PreviousInValue and uses it to calculate the miner's signature: [6](#0-5) 

6. **Mining Order Manipulation:** The wrong signature affects the mining order calculation for subsequent rounds: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Violation:**
- The verifiable random function property of AEDPoS consensus is broken, as fake encrypted pieces bypass the commitment-reveal scheme
- Wrong signatures are used in mining order calculations (`supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1`), affecting fairness of block production scheduling
- Randomness generation is compromised, as signatures are XOR-combined to generate random values [8](#0-7) 

**Who is Affected:**
- All network participants relying on fair mining order and randomness
- Honest miners whose relative mining positions may be unfairly altered
- The protocol's consensus security assumptions

**Severity Justification:**
Medium severity because while it doesn't directly steal funds, it undermines core consensus properties (fairness, randomness, verifiability) and could provide mining advantages to malicious actors, indirectly affecting reward distribution.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an active miner in the consensus (realistic requirement)
- Can construct arbitrary encrypted pieces using any encryption key
- No special privileges beyond being in the miner list

**Attack Complexity:**
- Low complexity: Simply provide fake encrypted_pieces in `UpdateValueInput` instead of legitimate secret shares
- No timing constraints or race conditions required
- Deterministic outcome once fake pieces are accepted

**Feasibility Conditions:**
- Secret sharing must be enabled (controlled by configuration)
- Attacker must not mine in subsequent round to avoid self-revealing correct value (which would be validated) [9](#0-8) 

**Detection Constraints:**
- No on-chain detection mechanism exists for fake encrypted pieces
- Wrong reconstructed values are indistinguishable from legitimate ones without access to the original InValue
- High probability of successful exploitation

### Recommendation

**Immediate Fix:**

1. Add validation in `PerformSecretSharing` or when setting `PreviousInValue` from revealed shares to ensure reconstructed values match previously committed OutValues:

```csharp
// In RevealSharedInValues after line 50
var expectedOutValue = anotherMinerInPreviousRound.OutValue;
if (HashHelper.ComputeFrom(revealedInValue) != expectedOutValue)
{
    Context.LogDebug(() => $"Revealed in value doesn't match out value for {publicKeyOfAnotherMiner}");
    continue; // Skip setting invalid PreviousInValue
}
```

2. Similarly validate in `PerformSecretSharing` when processing `MinersPreviousInValues`:

```csharp
// In PerformSecretSharing before line 296
foreach (var previousInValue in input.MinersPreviousInValues)
{
    if (round.RealTimeMinersInformation.ContainsKey(previousInValue.Key))
    {
        var previousRound = GetPreviousRound(); // Need to retrieve
        if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(previousInValue.Key))
        {
            var expectedOutValue = previousRound.RealTimeMinersInformation[previousInValue.Key].OutValue;
            if (HashHelper.ComputeFrom(previousInValue.Value) == expectedOutValue)
            {
                round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
            }
        }
    }
}
```

**Invariant Check:**
- `Hash(PreviousInValue) == PreviousRound.OutValue` must hold for all revealed InValues

**Test Cases:**
- Test that fake encrypted pieces result in rejected PreviousInValue reconstruction
- Test that miners providing incorrect MinersPreviousInValues have those values rejected
- Test that legitimate secret sharing still works correctly with validation

### Proof of Concept

**Initial State:**
- Secret sharing is enabled in configuration
- Malicious miner M is in the active miner list for round N
- M's OutValue_N = Hash(InValue_N) is committed

**Attack Steps:**

1. **Round N:** Miner M calls `UpdateValue` with:
   - Correct `OutValue` and `Signature`
   - Fake `EncryptedPieces`: random bytes or shares of FakeSecret instead of InValue_N
   - These fake pieces are accepted and stored without validation

2. **Round N+1:** Honest miner H1 produces a block:
   - H1's node decrypts M's fake piece intended for H1
   - H1 submits `UpdateValue` with `DecryptedPieces` containing the decrypted fake data
   - Fake decrypted pieces are added to M's `DecryptedPieces` map

3. **Round N+1 or N+2:** When enough fake pieces are collected:
   - `RevealSharedInValues` or off-chain `SecretSharingService` reconstructs WrongInValue using fake pieces
   - WrongInValue is set as M's `PreviousInValue` without checking `Hash(WrongInValue) == OutValue_N`

4. **Round N+2:** `NextRound` is called:
   - `SupplyCurrentRoundInformation` uses WrongInValue to calculate M's signature
   - Wrong signature leads to incorrect mining order calculation
   - M's `supposedOrderOfNextRound` is different from what it should be

**Expected Result:** 
System should reject fake encrypted pieces or reconstructed values that don't match committed OutValues

**Actual Result:**
Fake encrypted pieces are accepted, wrong PreviousInValue is set, and wrong signatures affect mining order calculations

**Success Condition:**
Wrong PreviousInValue is stored in contract state and used in signature/order calculations, demonstrating broken consensus integrity

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L290-290)
```csharp
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L175-176)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
