### Title
FinalOrderOfNextRound Manipulation Allows Mining Order Centralization

### Summary
Miners can manipulate their `FinalOrderOfNextRound` and `SupposedOrderOfNextRound` values in block headers without validation, allowing them to guarantee favorable mining positions in subsequent rounds. The consensus validation logic fails to independently recalculate and verify these order values from the miner's signature, enabling a malicious miner to centralize block production by repeatedly assigning themselves priority time slots.

### Finding Description

**Root Cause:**
The `FinalOrderOfNextRound` field determines each miner's position in the next round's mining sequence. While this value should be deterministically calculated from a miner's signature using the formula `GetAbsModulus(signature.ToInt64(), minersCount) + 1`, there is no validation that verifies this calculation was performed correctly. [1](#0-0) 

**Vulnerable Code Locations:**

1. In `GetUpdateValueRound()`, the `FinalOrderOfNextRound` values from the current round are directly copied into the simplified round without validation: [2](#0-1) 

2. During block validation, `UpdateValueValidationProvider` only validates that `OutValue` and `Signature` are filled and that `PreviousInValue` is correct, but does NOT validate the order calculation: [3](#0-2) 

3. When processing consensus updates, `ProcessUpdateValue` blindly applies the `SupposedOrderOfNextRound` from the input and the `TuneOrderInformation` without verifying they were correctly calculated: [4](#0-3) 

4. The `UpdateValueInput` is extracted directly from the header round without recalculation: [5](#0-4) 

**Exploitation Path:**

1. When a malicious miner produces a block, they call `GetConsensusBlockExtraData` which should call `ApplyNormalConsensusData` to calculate orders from their signature
2. Instead of using the honest calculation, the attacker modifies the `Round` object before including it in the block header, setting their own `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` to favorable values (e.g., 1 for earliest position)
3. They adjust other miners' `FinalOrderOfNextRound` values via `TuneOrderInformation` to avoid obvious conflicts
4. The system generates a consensus transaction from this manipulated header data
5. `ProcessUpdateValue` applies these manipulated values to state
6. `ValidateConsensusAfterExecution` compares the header round with the state round, but both contain the same manipulated values, so validation passes
7. When the next round is generated, these manipulated orders are used to determine mining positions: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Violation:**
The manipulated `FinalOrderOfNextRound` directly controls miner positions and expected mining times in subsequent rounds. By repeatedly manipulating their order to position 1, a malicious miner can:

1. **Centralize Block Production**: Consistently mine first in each round, gaining disproportionate block rewards and transaction fees
2. **Unfair Mining Advantage**: Control 2-3x more blocks than their fair share over time by always getting priority time slots
3. **Consensus Mechanism Subversion**: The signature-based randomization that ensures fair miner rotation is completely bypassed
4. **Long-term Protocol Damage**: Over many rounds, this enables effective control of the consensus process by a single malicious miner

**Affected Parties:**
- Honest miners lose their fair share of block production opportunities and rewards
- The network's decentralization guarantees are violated
- Users experience a less secure consensus mechanism than designed

**Severity Justification:**
This is a HIGH severity vulnerability because it directly violates the core consensus invariant of "correct round transitions and miner schedule integrity" and enables centralization of block production without requiring majority miner collusion.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an active miner in the consensus set
- Requires ability to modify their node's consensus extra data generation before block creation
- No special cryptographic capabilities needed beyond normal miner operations

**Attack Complexity:**
- LOW: The attack requires only modifying integer values in the `Round` object before it's serialized into the block header
- The manipulated block passes all validation checks
- No coordination with other miners required
- Can be executed every time the attacker produces a block

**Feasibility Conditions:**
- Attacker controls one miner node (realistic for any miner)
- Can modify the consensus module code on their node to skip `ApplyNormalConsensusData` or override its results
- No economic cost beyond normal block production

**Detection Constraints:**
- Very difficult to detect because the manipulated values appear valid
- No on-chain evidence that orders were incorrectly calculated
- Would require off-chain monitoring to notice statistical anomalies in one miner's position patterns

**Probability Assessment:**
HIGH likelihood of exploitation once discovered, as the benefits (priority mining positions, increased rewards) significantly outweigh the low cost and complexity of execution.

### Recommendation

**Immediate Fix - Add Order Validation:**

1. In `UpdateValueValidationProvider`, add validation that recalculates and verifies the supposed order from the signature:

```csharp
// In UpdateValueValidationProvider.ValidateHeaderInformation()
var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
var minersCount = validationContext.BaseRound.RealTimeMinersInformation.Count;
var expectedOrder = GetAbsModulus(minerInRound.Signature.ToInt64(), minersCount) + 1;

if (minerInRound.SupposedOrderOfNextRound != expectedOrder)
    return new ValidationResult { Message = "Invalid SupposedOrderOfNextRound calculation from signature." };
```

2. Add validation for `TuneOrderInformation` consistency in `ProcessUpdateValue`:

```csharp
// Validate that TuneOrderInformation only adjusts orders that would have conflicts
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    var miner = currentRound.RealTimeMinersInformation[tuneOrder.Key];
    var originalOrder = GetAbsModulus(miner.Signature.ToInt64(), minersCount) + 1;
    
    // Verify this miner's original order would have conflicted with someone else's
    var hasConflict = currentRound.RealTimeMinersInformation.Values
        .Any(m => m.Pubkey != tuneOrder.Key && m.SupposedOrderOfNextRound == originalOrder);
    
    Assert(hasConflict, "Invalid order adjustment - no conflict existed");
}
```

3. Add invariant check that all distinct `FinalOrderOfNextRound` values form a contiguous sequence from 1 to N where N is the number of miners who produced blocks.

**Test Cases:**

1. Test that blocks with manipulated `SupposedOrderOfNextRound` (not matching signature calculation) are rejected
2. Test that blocks with invalid `TuneOrderInformation` (adjusting orders without actual conflicts) are rejected  
3. Test that honest order calculation and conflict resolution still work correctly
4. Add regression test for statistical distribution of miner positions over many rounds

### Proof of Concept

**Initial State:**
- 7 miners in the consensus set
- Attacker controls one miner node (pubkey: "AttackerMiner")
- Current round number: 100

**Attack Steps:**

1. **Attacker's turn to produce block arrives**
   - Normal flow would call `GetConsensusBlockExtraData` → `ApplyNormalConsensusData`
   - This would calculate: `supposedOrder = GetAbsModulus(signature.ToInt64(), 7) + 1`
   - Assume honest calculation would give order 4

2. **Attacker modifies consensus extra data generation**
   - After `ApplyNormalConsensusData` calculates order 4
   - Attacker overwrites: `RealTimeMinersInformation["AttackerMiner"].SupposedOrderOfNextRound = 1`
   - Attacker overwrites: `RealTimeMinersInformation["AttackerMiner"].FinalOrderOfNextRound = 1`
   - Attacker adjusts the legitimate miner who had order 1 to order 4 via `TuneOrderInformation`

3. **Block is created with manipulated data**
   - Block header contains the modified `Round` object
   - Block is broadcast to network

4. **Validation occurs on receiving nodes**
   - `ValidateConsensusBeforeExecution` called
   - `UpdateValueValidationProvider` checks signature exists ✓
   - Does NOT check if order calculation is correct ✗
   - Validation passes

5. **Block is executed**
   - `ProcessUpdateValue` applies manipulated orders to state
   - `ValidateConsensusAfterExecution` compares header with state
   - Both contain same manipulated values, so comparison passes

6. **Next round is generated (round 101)**
   - `GenerateNextRoundInformation` orders miners by `FinalOrderOfNextRound`
   - Attacker is assigned order 1 (earliest position)
   - Attacker's `ExpectedMiningTime` is set to `currentTime + (4000ms * 1)`
   - Other miners get later positions

**Expected vs Actual Result:**
- **Expected (Honest)**: Attacker gets order 4, mines at time offset 16000ms
- **Actual (Exploited)**: Attacker gets order 1, mines at time offset 4000ms

**Success Condition:**
The attacker successfully produces the first block in round 101 despite their signature-based calculation indicating they should have position 4. By repeating this attack in subsequent rounds, they maintain priority mining position indefinitely, centralizing block production.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L35-53)
```csharp
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-260)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L16-51)
```csharp
    public UpdateValueInput ExtractInformationToUpdateConsensus(string pubkey, ByteString randomNumber)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return null;

        var minerInRound = RealTimeMinersInformation[pubkey];

        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);

        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);

        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L25-36)
```csharp
        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
