# Audit Report

## Title
Null Reference Exception in DistributeProfitsForSubSchemes Due to Missing Null Check on Sub-Scheme Profit Details

## Summary
The `DistributeProfitsForSubSchemes` function in the Profit contract lacks null validation when accessing profit details for sub-schemes. A scheme manager can inadvertently call `RemoveBeneficiary` on a sub-scheme's virtual address, which removes the profit details from state but leaves the sub-scheme entry in the `SubSchemes` list. This state inconsistency causes a NullReferenceException during subsequent profit distributions, resulting in complete DoS of the scheme's distribution mechanism.

## Finding Description
The vulnerability stems from a state management inconsistency between two operations in the Profit contract:

When a sub-scheme is added via `AddSubScheme`, two state changes occur: (1) the sub-scheme's virtual address is added as a beneficiary with profit details [1](#0-0) , and (2) the sub-scheme is added to the parent scheme's `SubSchemes` list [2](#0-1) .

However, `RemoveBeneficiary` can be called directly by the manager on any beneficiary address, including sub-scheme virtual addresses, with only manager permission validation [3](#0-2) . This calls `RemoveProfitDetails`, which completely removes the beneficiary entry from the state map when all profit details are removed [4](#0-3) .

Critically, `RemoveBeneficiary` does NOT remove the entry from `scheme.SubSchemes` - only `RemoveSubScheme` performs that operation [5](#0-4) .

This creates an inconsistent state where a sub-scheme exists in the `SubSchemes` list but has no corresponding profit details. When `DistributeProfits` is subsequently called, it invokes `DistributeProfitsForSubSchemes` [6](#0-5) , which iterates through all sub-schemes and accesses their profit details without null validation [7](#0-6) . This causes a NullReferenceException when `subItemDetail` is null.

## Impact Explanation
When the inconsistent state exists and `DistributeProfits` is called:
- The transaction fails with a NullReferenceException at the point where it attempts to iterate over `subItemDetail.Details`
- Complete DoS of profit distribution for the entire scheme occurs
- All beneficiaries of the scheme (not just the problematic sub-scheme) cannot receive their entitled profits
- The scheme's economic functionality is halted until manual intervention
- The manager must either re-add the sub-scheme's profit details via `AddBeneficiary` or completely remove the sub-scheme via `RemoveSubScheme` to restore functionality

This represents a high-confidence DoS of a critical economic function that affects all participants in the scheme.

## Likelihood Explanation
This vulnerability can be triggered through legitimate scheme manager actions:

**Preconditions**:
- A scheme must have at least one sub-scheme added via `AddSubScheme`
- The manager (or TokenHolder contract) must call `RemoveBeneficiary` with the sub-scheme's virtual address

**Triggering Scenario**:
- Only the scheme manager or TokenHolder contract can call `RemoveBeneficiary` (not external attackers) [3](#0-2) 
- The manager may not realize a particular address is a sub-scheme's virtual address when performing beneficiary cleanup
- No validation prevents this action - the code treats sub-scheme virtual addresses identically to regular beneficiaries
- For schemes with `CanRemoveBeneficiaryDirectly=true`, managers may be more liberal in removing beneficiaries

While this requires manager action rather than external attack, it represents a defensive programming failure that allows an easily-triggered inconsistent state with no safeguards.

## Recommendation
Add a null check before accessing `subItemDetail.Details` in the `DistributeProfitsForSubSchemes` function:

```csharp
var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
if (subItemDetail == null)
{
    Context.LogDebug(() => $"Sub-scheme {subSchemeShares.SchemeId} has no profit details, skipping.");
    continue;
}
foreach (var detail in subItemDetail.Details) detail.LastProfitPeriod = scheme.CurrentPeriod;
```

Additionally, consider adding validation in `RemoveBeneficiary` to prevent removing sub-scheme virtual addresses:

```csharp
// Check if beneficiary is a sub-scheme virtual address
var isSubScheme = scheme.SubSchemes.Any(s => 
    Context.ConvertVirtualAddressToContractAddress(s.SchemeId) == input.Beneficiary);
Assert(!isSubScheme, "Cannot remove sub-scheme beneficiary directly. Use RemoveSubScheme instead.");
```

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_NullReference_SubScheme_DoS_Test()
{
    var creator = Creators[0];
    
    // Create parent and sub schemes
    var parentSchemeId = await CreateSchemeAsync(0, true); // CanRemoveBeneficiaryDirectly = true
    var subSchemeId = await CreateSchemeAsync(1);
    
    // Get sub-scheme details to get virtual address
    var subScheme = await creator.GetScheme.CallAsync(subSchemeId);
    var subSchemeVirtualAddress = subScheme.VirtualAddress;
    
    // Add sub-scheme to parent scheme
    await creator.AddSubScheme.SendAsync(new AddSubSchemeInput
    {
        SchemeId = parentSchemeId,
        SubSchemeId = subSchemeId,
        SubSchemeShares = 100
    });
    
    // Verify sub-scheme was added correctly
    var parentScheme = await creator.GetScheme.CallAsync(parentSchemeId);
    parentScheme.SubSchemes.Count.ShouldBe(1);
    
    // Manager removes sub-scheme's virtual address as beneficiary (creates inconsistent state)
    await creator.RemoveBeneficiary.SendAsync(new RemoveBeneficiaryInput
    {
        SchemeId = parentSchemeId,
        Beneficiary = subSchemeVirtualAddress
    });
    
    // Contribute profits to parent scheme
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = parentSchemeId,
        Amount = 1000,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    });
    
    // Attempt to distribute profits - this will cause NullReferenceException
    var result = await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = parentSchemeId,
        AmountsMap = { { ProfitContractTestConstants.NativeTokenSymbol, 1000 } }
    });
    
    // Transaction should fail due to NullReferenceException
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("NullReferenceException");
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L109-118)
```csharp
        AddBeneficiary(new AddBeneficiaryInput
        {
            SchemeId = input.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = subSchemeVirtualAddress,
                Shares = input.SubSchemeShares
            },
            EndPeriod = long.MaxValue
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L121-125)
```csharp
        scheme.SubSchemes.Add(new SchemeBeneficiaryShare
        {
            SchemeId = input.SubSchemeId,
            Shares = input.SubSchemeShares
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L150-151)
```csharp
        State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
        scheme.SubSchemes.Remove(shares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L237-239)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L376-383)
```csharp
        if (profitDetails.Details.Count != 0)
        {
            State.ProfitDetailsMap[scheme.SchemeId][beneficiary] = profitDetails;
        }
        else
        {
            State.ProfitDetailsMap[scheme.SchemeId].Remove(beneficiary);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L585-592)
```csharp
    private void PerformDistributeProfits(Dictionary<string, long> profitsMap, Scheme scheme, long totalShares,
        Address profitsReceivingVirtualAddress)
    {
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var remainAmount = DistributeProfitsForSubSchemes(symbol, amount, scheme, totalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L634-635)
```csharp
            var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
            foreach (var detail in subItemDetail.Details) detail.LastProfitPeriod = scheme.CurrentPeriod;
```
