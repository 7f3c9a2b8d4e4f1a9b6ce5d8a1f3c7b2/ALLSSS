### Title
Storage Bloat via Incorrect Cleanup in SetCandidateAdmin When Parliament Changes Admin

### Summary
The `SetCandidateAdmin` function in `ElectionContract_Candidate.cs` fails to properly clean up the old admin's `ManagedCandidatePubkeysMap` entry when Parliament changes a candidate's admin. This causes orphaned entries to accumulate in the old admin's list, leading to unbounded storage bloat and stale data over time.

### Finding Description

The vulnerability exists in the `SetCandidateAdmin` method [1](#0-0) 

The root cause is a logic error in the cleanup mechanism. When an admin change occurs, the function correctly adds the candidate pubkey to the new admin's `ManagedCandidatePubkeysMap` [2](#0-1) , but the cleanup operation removes the pubkey from `Context.Sender`'s list instead of the actual old admin's list [3](#0-2) 

The permission check shows that Parliament can bypass authentication [4](#0-3) . The old admin address is correctly retrieved at line 37 (`var oldCandidateAdmin = State.CandidateAdmins[pubkey]`), but this value is never used for cleanup.

**Execution Path:**
1. Candidate announces election with Admin A → pubkey added to Admin A's `ManagedCandidatePubkeysMap`
2. Parliament calls `SetCandidateAdmin` to change admin to Admin B
   - `Context.Sender` = Parliament address
   - Pubkey is added to Admin B's list (correct)
   - Cleanup attempts to remove from Parliament's list (incorrect - Parliament doesn't have this pubkey)
   - Pubkey remains orphaned in Admin A's list
3. Repeat step 2 with Admin C, D, etc. → pubkey accumulates in multiple admin lists

The issue only affects Parliament-initiated admin changes because non-Parliament callers must be the current admin due to permission checks, making `Context.Sender == oldCandidateAdmin`.

### Impact Explanation

**Storage Bloat:**
- Each orphaned entry consumes ~32 bytes (pubkey as ByteString)
- With N candidates and M admin changes per candidate: O(N×M) orphaned entries
- Over time with repeated governance operations, this grows unbounded
- Blockchain state storage increases permanently for all nodes

**Data Corruption:**
- The `GetManagedPubkeys` view method [5](#0-4)  returns incorrect data for old admins
- Old admins appear to still manage candidates they no longer control
- This breaks the semantic integrity of the admin-candidate relationship tracking

**Who is Affected:**
- Network validators bearing increased state storage costs
- Query interfaces returning stale admin relationships
- Off-chain systems relying on `ManagedCandidatePubkeysMap` accuracy

**Severity Justification:**
Medium severity because:
- Real operational impact (storage bloat, data corruption)
- Triggered by legitimate governance operations (no compromise required)
- No direct fund theft or consensus break
- Impact accumulates gradually but unboundedly

### Likelihood Explanation

**Entry Point:** Public method `SetCandidateAdmin` callable by Parliament [6](#0-5) 

**Preconditions:**
- Candidate must be active (checked at line 21-22)
- Parliament must call the function (bypasses permission at line 27)

**Feasibility:**
Parliament changing candidate admins is a **legitimate governance action**, not requiring compromise or malicious intent. Valid scenarios include:
- Admin key loss/compromise requiring emergency transfer
- Governance-mandated admin consolidation
- Admin unresponsiveness requiring replacement
- Protocol upgrades requiring admin updates

**Attack Complexity:** 
- Low - single transaction per admin change
- No coordination required
- No economic cost beyond gas fees

**Detection:**
- Difficult to detect without explicit state audits
- No events fired for orphaned entries
- Only visible through manual `GetManagedPubkeys` queries

**Probability:**
High likelihood over protocol lifetime as governance operations naturally accumulate.

### Recommendation

**Fix the cleanup logic to use the actual old admin address:**

Modify lines 51-54 to retrieve and use the old admin from `State.CandidateAdmins[pubkey]` instead of `Context.Sender`:

```csharp
// Get the old admin before updating
var oldCandidateAdmin = State.CandidateAdmins[pubkey];

// Update to new admin
State.CandidateAdmins[pubkey] = input.Admin;

// Add to new admin's list
var newAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[input.Admin] ?? new PubkeyList();
if (!newAdminManagedPubkeys.Value.Contains(pubkeyByteString))
    newAdminManagedPubkeys.Value.Add(pubkeyByteString);
State.ManagedCandidatePubkeysMap[input.Admin] = newAdminManagedPubkeys;

// Remove from OLD admin's list (not Context.Sender)
if (oldCandidateAdmin != null)
{
    var oldAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[oldCandidateAdmin] ?? new PubkeyList();
    if (oldAdminManagedPubkeys.Value.Contains(pubkeyByteString))
        oldAdminManagedPubkeys.Value.Remove(pubkeyByteString);
    if (oldAdminManagedPubkeys.Value.Any())
        State.ManagedCandidatePubkeysMap[oldCandidateAdmin] = oldAdminManagedPubkeys;
    else
        State.ManagedCandidatePubkeysMap.Remove(oldCandidateAdmin);
}
```

**Invariant Check:**
Add assertion: `GetManagedPubkeys(oldAdmin)` should NOT contain the pubkey after admin change.

**Test Cases:**
1. Test Parliament changing admin from A to B → verify pubkey removed from A's list
2. Test multiple Parliament-initiated admin changes → verify no orphaned entries
3. Test admin self-change → verify existing behavior preserved

**Migration:** 
Consider adding a cleanup function callable by Parliament to remove orphaned entries from existing state.

### Proof of Concept

**Initial State:**
- Candidate X announces election with Admin A
- `ManagedCandidatePubkeysMap[A]` = [X]
- `CandidateAdmins[X]` = A

**Step 1:** Parliament changes X's admin to B
```
SetCandidateAdmin({
    Pubkey: X,
    Admin: B
})
Caller: Parliament
```

**Expected Result:**
- `ManagedCandidatePubkeysMap[A]` = []
- `ManagedCandidatePubkeysMap[B]` = [X]

**Actual Result:**
- `ManagedCandidatePubkeysMap[A]` = [X]  ← ORPHANED
- `ManagedCandidatePubkeysMap[B]` = [X]
- `ManagedCandidatePubkeysMap[Parliament]` = []

**Step 2:** Parliament changes X's admin to C

**Expected Result:**
- `ManagedCandidatePubkeysMap[B]` = []
- `ManagedCandidatePubkeysMap[C]` = [X]

**Actual Result:**
- `ManagedCandidatePubkeysMap[A]` = [X]  ← ORPHANED
- `ManagedCandidatePubkeysMap[B]` = [X]  ← ORPHANED
- `ManagedCandidatePubkeysMap[C]` = [X]

**Success Condition:**
After N Parliament-initiated admin changes, X appears in N different admin lists instead of only the current admin's list, confirming unbounded storage bloat.

### Notes

The cleanup mechanism works correctly for non-Parliament admin changes because the permission check [7](#0-6)  ensures `Context.Sender == oldCandidateAdmin`. The bug is specific to Parliament's privileged bypass path.

Similar cleanup patterns exist in `QuitElection` [8](#0-7)  and `ReplaceCandidatePubkey` [9](#0-8) , which correctly use `Context.Sender` because those operations require the caller to be the current admin.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-57)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;

        var pubkeyByteString = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey));

        var newAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[input.Admin] ?? new PubkeyList();
        if (!newAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            newAdminManagedPubkeys.Value.Add(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[input.Admin] = newAdminManagedPubkeys;

        var oldAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[Context.Sender] ?? new PubkeyList();
        if (oldAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            oldAdminManagedPubkeys.Value.Remove(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[Context.Sender] = oldAdminManagedPubkeys;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L270-275)
```csharp
        var managedCandidatePubkey = State.ManagedCandidatePubkeysMap[Context.Sender];
        managedCandidatePubkey.Value.Remove(ByteString.CopyFrom(pubkeyBytes));
        if (managedCandidatePubkey.Value.Any())
            State.ManagedCandidatePubkeysMap[Context.Sender] = managedCandidatePubkey;
        else
            State.ManagedCandidatePubkeysMap.Remove(Context.Sender);
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L427-430)
```csharp
    public override PubkeyList GetManagedPubkeys(Address input)
    {
        return State.ManagedCandidatePubkeysMap[input];
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L323-326)
```csharp
        var managedPubkeys = State.ManagedCandidatePubkeysMap[Context.Sender];
        managedPubkeys.Value.Remove(oldPubkeyByteString);
        managedPubkeys.Value.Add(ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(newPubkey)));
        State.ManagedCandidatePubkeysMap[Context.Sender] = managedPubkeys;
```
