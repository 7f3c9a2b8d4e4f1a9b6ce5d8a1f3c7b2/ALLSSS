# Audit Report

## Title
Coordinated LIB Denial-of-Service via Zero ImpliedIrreversibleBlockHeight Bypass

## Summary
The `LibInformationValidationProvider` contains a critical validation bypass that allows miners to submit zero `ImpliedIrreversibleBlockHeight` values, circumventing regression checks. When more than one-third of miners exploit this flaw, the Last Irreversible Block (LIB) calculation permanently fails, halting consensus finality and blocking all cross-chain operations.

## Finding Description

The vulnerability exists in the validation logic that verifies whether a miner's reported irreversible block height has regressed. [1](#0-0) 

The conditional check on line 24 was designed to allow new miners (who legitimately have zero initial values) to pass validation without regression checks. However, this creates an exploitable bypass: existing miners can intentionally submit zero values to avoid validation entirely.

During normal block production, the system sets a miner's `ImpliedIrreversibleBlockHeight` to the current block height: [2](#0-1) 

After producing their first block, this value should never be zero during honest operation. However, miners control their consensus transaction submissions. When a miner submits an `UpdateValue` transaction, the provided `ImpliedIrreversibleBlockHeight` is stored directly in the round state without additional validation: [3](#0-2) 

The attack propagates to LIB calculation through filtering logic. When computing the LIB for subsequent rounds, the system explicitly excludes zero values: [4](#0-3) 

The LIB calculation requires a minimum threshold of valid (non-zero) heights defined as `MinersCountOfConsent` (two-thirds plus one of all miners): [5](#0-4) 

If insufficient valid heights remain after filtering zeros, the calculation returns zero, indicating LIB progression has failed: [6](#0-5) 

The `UpdateValue` method is publicly accessible, allowing any miner to submit their consensus data: [7](#0-6) 

Pre-execution validation applies `LibInformationValidationProvider` for `UpdateValue` behavior but fails to prevent the zero-value bypass: [8](#0-7) 

## Impact Explanation

**Consensus Finality Breakdown:**
The LIB mechanism is fundamental to AElf's consensus safety. When LIB stops advancing (returns zero), no blocks become irreversible, eliminating finality guarantees. This breaks the core invariant that LIB should monotonically increase (or remain constant), never regressing to zero after having advanced.

**Cross-Chain Operations Blocked:**
Cross-chain indexing critically depends on irreversible block heights for security. The `IrreversibleBlockStateProvider` validates LIB existence before allowing cross-chain operations: [9](#0-8) 

When LIB fails to advance beyond genesis height, this validation returns false, blocking all parent-chain and side-chain synchronization, effectively halting inter-chain asset transfers and communication.

**Quantified Attack Threshold:**
For a network with 21 miners:
- `MinersCountOfConsent = 21 ร 2 รท 3 + 1 = 15`
- Attack requires 8 colluding miners (>1/3 Byzantine threshold)
- This leaves 13 valid heights, below the required 15
- LIB calculation returns 0, permanently halting finality

**Severity:** Critical - violates fundamental consensus safety properties with protocol-wide operational impact affecting all network participants.

## Likelihood Explanation

**Attacker Capabilities:**
The attack requires coordination among slightly more than one-third of active miners (8 out of 21). This aligns precisely with the Byzantine fault tolerance threshold that distributed consensus systems are designed to tolerate. Miners have complete control over the content of their `UpdateValueInput` messages submitted via the public `UpdateValue` method.

**Attack Complexity:**
Execution is trivial. A malicious miner simply constructs an `UpdateValueInput` with `implied_irreversible_block_height = 0` and submits it during their assigned time slot. No cryptographic manipulation, complex timing attacks, or sophisticated exploits are required. The attack can be sustained indefinitely by repeatedly submitting zero values.

**Feasibility Conditions:**
The standard Byzantine adversary model assumes up to one-third of participants may act maliciously. This vulnerability is exploitable at exactly that threshold, making it feasible under the security assumptions the protocol claims to satisfy. No economic penalties (slashing) exist for this behavior, eliminating deterrence.

**Detection and Attribution:**
While the effect (LIB not advancing) is immediately observable in blockchain state, attributing responsibility to specific miners is difficult when multiple participants simultaneously exhibit the behavior. The protocol lacks mechanisms to penalize or automatically exclude miners engaging in this attack pattern.

## Recommendation

Implement strict validation that prevents existing miners from submitting zero `ImpliedIrreversibleBlockHeight` values. Distinguish between new miners (who legitimately have zero initial state) and existing miners (who should never regress to zero).

**Suggested Fix:**
```csharp
// In LibInformationValidationProvider.cs
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0)
{
    // Check if miner has ever produced a block (ProducedBlocks > 0)
    if (baseRound.RealTimeMinersInformation[pubkey].ProducedBlocks > 0 &&
        providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight == 0)
    {
        validationResult.Message = "Existing miner cannot submit zero implied lib height.";
        return validationResult;
    }
    
    if (baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
        providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
    {
        validationResult.Message = "Incorrect implied lib height.";
        return validationResult;
    }
}
```

Additionally, consider implementing minimum progression requirements where `ImpliedIrreversibleBlockHeight` must be at least the current block height minus a reasonable offset, preventing miners from reporting stale or manipulated heights.

## Proof of Concept

```csharp
[Fact]
public async Task LIB_Denial_Of_Service_Via_Zero_Height_Bypass()
{
    // Setup: Initialize 21 miners and advance through initial rounds normally
    const int minerCount = 21;
    var initialMiners = GenerateTestMiners(minerCount);
    await InitializeConsensusAsync(initialMiners);
    
    // Advance several rounds to establish non-zero ImpliedIrreversibleBlockHeight values
    for (int i = 0; i < 5; i++)
    {
        await ProduceNormalRoundAsync(initialMiners);
    }
    
    // Verify LIB is advancing normally
    var libBeforeAttack = await GetCurrentLIBHeightAsync();
    Assert.True(libBeforeAttack > 0, "LIB should be advancing before attack");
    
    // Attack: 8 miners (>1/3) submit UpdateValue with zero ImpliedIrreversibleBlockHeight
    var maliciousMiners = initialMiners.Take(8).ToList();
    foreach (var miner in maliciousMiners)
    {
        var maliciousUpdate = new UpdateValueInput
        {
            OutValue = GenerateValidOutValue(),
            Signature = GenerateValidSignature(),
            RoundId = await GetCurrentRoundIdAsync(),
            PreviousInValue = await GetPreviousInValueAsync(miner),
            ActualMiningTime = Timestamp.FromDateTime(DateTime.UtcNow),
            ImpliedIrreversibleBlockHeight = 0  // Malicious zero value
        };
        
        await SubmitUpdateValueAsync(miner, maliciousUpdate);
    }
    
    // Complete the round with honest miners
    var honestMiners = initialMiners.Skip(8).ToList();
    foreach (var miner in honestMiners)
    {
        await ProduceNormalBlockAsync(miner);
    }
    
    // Verify: LIB calculation should fail
    // With only 13 valid heights (< 15 required), LIB returns 0
    var libAfterAttack = await GetCurrentLIBHeightAsync();
    Assert.Equal(0, libAfterAttack);
    Assert.True(libBeforeAttack > libAfterAttack, "LIB regressed to zero - finality broken");
    
    // Verify cross-chain operations are blocked
    var canPerformCrossChain = await CanIndexCrossChainDataAsync();
    Assert.False(canPerformCrossChain, "Cross-chain operations should be blocked when LIB fails");
}
```

## Notes

This vulnerability represents a fundamental flaw in the consensus finality mechanism. The zero-check bypass was likely introduced with good intentions (allowing new miners to join), but it fails to distinguish between legitimate initialization scenarios and malicious exploitation by existing miners. The attack is particularly concerning because it operates within the stated Byzantine tolerance assumptions (1/3 malicious actors) yet completely breaks consensus finality, suggesting the protocol's security model may be inadequately implemented in this critical component.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L26-30)
```csharp
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** src/AElf.CrossChain.Core/Indexing/Infrastructure/IrreversibleBlockStateProvider.cs (L30-38)
```csharp
    public async Task<bool> ValidateIrreversibleBlockExistingAsync()
    {
        if (_irreversibleBlockExists)
            return true;
        var libIdHeight = await GetLastIrreversibleBlockHashAndHeightAsync();
        var lastIrreversibleBlockHeight = libIdHeight.BlockHeight;
        _irreversibleBlockExists = lastIrreversibleBlockHeight > AElfConstants.GenesisBlockHeight;
        return _irreversibleBlockExists;
    }
```
