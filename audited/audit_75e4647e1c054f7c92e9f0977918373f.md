### Title
Insufficient Taylor Series Iterations in Exp() Function Causes Incorrect Pricing for Large Exponents

### Summary
The `Exp()` function in BancorHelper uses only 20 iterations of the Taylor series to compute exponentials, which is insufficient for convergence when the exponent magnitude exceeds approximately 20. When connector weight ratios are extreme (e.g., 0.99/0.01 = 99) combined with large transaction amounts, the resulting exponent `y * Ln(x)` can reach values like -300, causing the alternating series to produce wildly incorrect results that corrupt Bancor pricing calculations.

### Finding Description

The `Exp()` function implements the Taylor series expansion `exp(y) = 1 + y + y²/2! + y³/3! + ...` with a fixed limit of 20 iterations. [1](#0-0) 

The Taylor series for exp(y) only begins to converge when terms start decreasing, which occurs when `n > |y| - 1`. For large negative exponents (e.g., y = -300), the first 20 terms are still growing in magnitude due to the alternating signs, producing catastrophically incorrect results through numerical instability.

**How Large Exponents Occur:**

In `GetReturnFromPaid`, the exponent is calculated as `y * Ln(x)` where `y = fromConnectorWeight / toConnectorWeight` and `x = fromConnectorBalance / (fromConnectorBalance + paidAmount)`. [2](#0-1) 

Connector weights are only constrained to be between 0 and 1 (exclusive): [3](#0-2) [4](#0-3) 

**Concrete Example:**
- Weights: `fromConnectorWeight = 0.99`, `toConnectorWeight = 0.01` → `y = 99`
- Balances: `fromConnectorBalance = 1000`, `paidAmount = 19000` → `x = 0.05`
- Ln(0.05) ≈ -2.996
- Exponent: `99 × (-2.996) = -296.6`

For exp(-296.6), the Taylor series terms are:
- Term 1: -296.6
- Term 2: 43,970
- Term 3: -4,349,000
- Term 20: ~10^50 (alternating)

The series hasn't converged; instead, massive alternating terms cause numerical instability. The result could be negative, enormously positive, or otherwise incorrect, leading to wrong pricing in Buy/Sell operations. [5](#0-4) 

### Impact Explanation

**Direct Fund Impact:**
- Incorrect `GetAmountToPayFromReturn` calculations cause users to pay vastly incorrect amounts (potentially zero or astronomical values)
- Incorrect `GetReturnFromPaid` calculations cause users to receive wrong token amounts
- If the error slightly favors one direction, arbitrageurs can drain connector balances through repeated trades
- In extreme cases, negative return values cause transaction reverts, creating DoS for legitimate trades

**Operational Impact:**
- Token conversion functionality becomes unreliable for certain weight configurations
- Users cannot execute trades at fair market prices
- Protocol reputation damage from pricing failures

**Who is Affected:**
All users attempting to buy or sell through TokenConverter when connector pairs have extreme weight ratios (>20:1 or <1:20) combined with transaction sizes that make `x` diverge significantly from 1.

**Severity Justification:**
Medium severity because it requires specific configuration (extreme weight ratios that are valid but not default), but once configured, causes concrete fund loss through incorrect pricing that any user can trigger.

### Likelihood Explanation

**Attacker Capabilities:**
No special privileges required. Any user can call `Buy()` or `Sell()` with transaction amounts that trigger the issue. [6](#0-5) 

**Preconditions:**
1. Governance (ConnectorController) must configure connectors with extreme weight ratios (e.g., 0.95:0.05 or higher)
2. User executes trades with amounts large relative to connector balance

Production defaults use moderate ratios (0.5 and 0.005), making the ratio 100:1: [7](#0-6) 

However, the validation explicitly allows any weights in (0, 1), making extreme ratios valid configurations.

**Attack Complexity:**
Low - once extreme weights exist, standard Buy/Sell transactions trigger the issue.

**Feasibility:**
Medium - requires governance decision to set extreme weights, but nothing prevents this configuration, and once set, exploitation is trivial.

**Detection:**
Difficult to detect in advance; would manifest as unexpected pricing behavior or transaction failures.

### Recommendation

**Immediate Fix:**
1. Increase `_LOOPS` constant to at least 100 iterations to handle larger exponents:
```csharp
private const int _LOOPS = 100; // Increased from 20
```

2. Add bounds checking on the exponent magnitude before calling `Exp()`:
```csharp
private static decimal Exp(decimal y)
{
    const decimal MAX_EXP = 50m;
    if (Math.Abs(y) > MAX_EXP)
        throw new InvalidValueException($"Exponent magnitude {Math.Abs(y)} exceeds safe limit {MAX_EXP}");
    // ... existing implementation
}
```

3. Add validation on weight ratios during connector initialization to prevent extreme configurations:
```csharp
private void AssertValidConnectorWeight(Connector connector)
{
    var weight = AssertedDecimal(connector.Weight);
    Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
    Assert(weight >= 0.01m && weight <= 0.99m, "Connector weight must be between 0.01 and 0.99 to prevent convergence issues.");
    connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
}
```

**Test Cases:**
1. Test Exp() with large negative values (e.g., -50, -100) and verify correctness
2. Test GetReturnFromPaid with extreme weight ratios (0.99/0.01) and large transaction amounts
3. Add integration tests verifying pricing accuracy across full range of allowed weight configurations

### Proof of Concept

**Initial State:**
1. Initialize TokenConverter with connector pair:
   - Connector A: weight = "0.99", balance = 10,000
   - Connector B: weight = "0.01", balance = 10,000

**Exploitation Steps:**
1. User calls `Sell()` with `amount = 190,000` of Connector A tokens
2. In `GetReturnFromPaid`:
   - `x = 10,000 / (10,000 + 190,000) = 0.05`
   - `y = 0.99 / 0.01 = 99`
   - `Ln(0.05)` calculated with 20 terms ≈ -2.996
   - `Exp(99 × -2.996) = Exp(-296.6)` calculated with 20 terms
3. Due to insufficient iterations, `Exp(-296.6)` returns incorrect value (could be negative or massive positive)
4. Return amount becomes `10,000 × (1 - incorrect_value)` = wrong value

**Expected vs Actual:**
- **Expected**: `exp(-296.6) ≈ 10^-129 ≈ 0`, so return ≈ 10,000 tokens
- **Actual**: Alternating series with 20 terms produces numerically unstable result, causing either transaction revert (negative amount) or severely incorrect pricing

**Success Condition:**
Transaction either reverts unexpectedly or completes with pricing error >5% from correct Bancor formula value.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-127)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L354-357)
```csharp
    private static bool IsBetweenZeroAndOne(decimal number)
    {
        return number > decimal.Zero && number < decimal.One;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L222-235)
```csharp
                Weight = "0.5",
                VirtualBalance = EconomicContractConstants.NativeTokenConnectorInitialVirtualBalance
            }
        };
        foreach (var resourceTokenSymbol in Context.Variables
                     .GetStringArray(EconomicContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(EconomicContractConstants.PayRentalSymbolListName)))
        {
            var resourceTokenConnector = new Connector
            {
                Symbol = resourceTokenSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
```
