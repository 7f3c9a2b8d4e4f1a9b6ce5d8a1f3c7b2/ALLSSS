### Title
Missing Validation of RevealedInValues Allows Malicious Miner to Inject Invalid PreviousInValue for Other Miners

### Summary
A malicious miner can inject arbitrary `RevealedInValues` through their node's trigger information, which are accepted without validation in `UpdateLatestSecretPieces` and stored in consensus state. This corrupts the `PreviousInValue` field for other miners, breaking the secret sharing protocol for random number generation and potentially manipulating miner ordering in subsequent rounds.

### Finding Description

In `GetConsensusExtraDataToPublishOutValue`, the function calls `UpdateLatestSecretPieces` to process secret sharing data from the trigger information: [1](#0-0) 

The `UpdateLatestSecretPieces` method blindly accepts `RevealedInValues` from the attacker-controlled trigger information and sets `PreviousInValue` for other miners without validation: [2](#0-1) 

The trigger information originates from the node's kernel layer (`AEDPoSTriggerInformationProvider`), where a malicious miner running modified node software can inject arbitrary values: [3](#0-2) 

This malicious data flows through to the consensus transaction. When generating transactions, `ExtractInformationToUpdateConsensus` includes all miners' `PreviousInValue` in `MinersPreviousInValues`: [4](#0-3) 

Finally, `ProcessUpdateValue` stores these unvalidated values directly into consensus state via `PerformSecretSharing`: [5](#0-4) 

**Root Cause**: The contract lacks validation that revealed InValues match the expected hash relationship: `HashHelper.ComputeFrom(revealedInValue) == previousOutValue`.

The only validation performed is in `UpdateValueValidationProvider`, which only checks the sender's own `PreviousInValue`: [6](#0-5) 

This validation does not cover the `RevealedInValues` for other miners, allowing the attack.

### Impact Explanation

**Consensus Protocol Corruption**: The `PreviousInValue` field is critical to the AEDPoS consensus mechanism. It is used in:
1. Secret sharing protocol for random number generation (affecting VRF-based randomness)
2. Signature calculations that determine miner ordering in subsequent rounds via `ApplyNormalConsensusData`
3. Last Irreversible Block (LIB) height calculations

By injecting incorrect `PreviousInValue` for other miners, an attacker can:
- **Break random number generation**: Corrupt the secret sharing protocol, compromising the randomness guarantees of the consensus
- **Manipulate block producer ordering**: Influence which miners get selected for future rounds by corrupting the signature-based ordering calculation
- **Undermine consensus integrity**: Violate fundamental consensus invariants that assume `PreviousInValue` matches the hash of the actual previous InValue

**Severity**: HIGH - This directly compromises consensus integrity, a critical system invariant. The attack allows state corruption that persists across rounds and affects all miners in the network.

### Likelihood Explanation

**Attacker Capabilities**: 
- Must be a valid miner in the current consensus set (realistic for malicious node operators)
- Must run modified node software to inject arbitrary `RevealedInValues` (straightforward for technical adversaries)

**Attack Complexity**: LOW
- Modification point is clear: inject arbitrary values in `AEDPoSTriggerInformationProvider`
- No complex timing requirements
- No need to break cryptographic primitives

**Preconditions**:
- Target miners must have `PreviousInValue == Hash.Empty` or `null` (lines 150-151 check)
- This occurs naturally at round starts and for miners who haven't revealed their InValue yet
- Common scenario, not restrictive

**Detection Constraints**: The attack is difficult to detect because:
- The malicious data passes all existing validation checks
- No on-chain mechanism verifies the correctness of revealed values
- The corruption manifests gradually as consensus state degradation

**Economic Rationality**: Extremely low cost - only requires node software modification with no transaction fees or token requirements.

### Recommendation

**Immediate Fix**: Add validation in `UpdateLatestSecretPieces` to verify that revealed InValues match the expected hash relationship:

```csharp
foreach (var revealedInValue in triggerInformation.RevealedInValues)
{
    if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
        (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
         updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
    {
        // VALIDATION: Verify the revealed value matches the expected OutValue hash
        if (TryToGetPreviousRoundInformation(out var previousRound) &&
            previousRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
        {
            var expectedOutValue = previousRound.RealTimeMinersInformation[revealedInValue.Key].OutValue;
            var computedOutValue = HashHelper.ComputeFrom(revealedInValue.Value);
            
            if (computedOutValue != expectedOutValue)
            {
                Context.LogDebug(() => $"Invalid revealed InValue for {revealedInValue.Key}");
                continue; // Skip invalid revealed value
            }
        }
        
        updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
    }
}
```

**Additional Safeguards**:
1. Add a validation provider specifically for `RevealedInValues` in `ValidateBeforeExecution`
2. Add test cases verifying rejection of invalid revealed InValues
3. Add monitoring/logging to detect attempts to inject invalid values

### Proof of Concept

**Initial State**:
- Round N has completed with miners A, B, C
- Round N+1 starts, all miners have `PreviousInValue == Hash.Empty`
- Attacker controls miner A

**Attack Steps**:
1. Attacker modifies their node's `AEDPoSTriggerInformationProvider` to inject malicious `RevealedInValues`:
   - Sets `RevealedInValues["B"] = MaliciousHash_B` (arbitrary value)
   - Sets `RevealedInValues["C"] = MaliciousHash_C` (arbitrary value)

2. When miner A produces a block, `GetConsensusExtraData` is called with the malicious trigger information

3. `UpdateLatestSecretPieces` (lines 148-152) sets:
   - `updatedRound.RealTimeMinersInformation["B"].PreviousInValue = MaliciousHash_B`
   - `updatedRound.RealTimeMinersInformation["C"].PreviousInValue = MaliciousHash_C`

4. The consensus transaction is generated with these values in `MinersPreviousInValues`

5. `ProcessUpdateValue` â†’ `PerformSecretSharing` stores the malicious values in state

**Expected vs Actual Result**:
- **Expected**: Contract rejects invalid revealed InValues that don't match `HashHelper.ComputeFrom(revealedInValue) == previousOutValue`
- **Actual**: Contract accepts and stores arbitrary values, corrupting consensus state for miners B and C

**Success Condition**: Query state after block execution shows miners B and C have incorrect `PreviousInValue` that doesn't hash to their previous round's `OutValue`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L122-125)
```csharp
        if (IsSecretSharingEnabled())
        {
            UpdateLatestSecretPieces(updatedRound, pubkey, triggerInformation);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L112-114)
```csharp
            var revealedInValues = _secretSharingService.GetRevealedInValues(hint.RoundId);
            foreach (var revealedInValue in revealedInValues)
                trigger.RevealedInValues.Add(revealedInValue.Key, revealedInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```
