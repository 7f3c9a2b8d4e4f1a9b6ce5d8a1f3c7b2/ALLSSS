### Title
NFT Protocol Creator Cannot Revoke TokenContract Issuer's Minting Rights Due to Dual Permission System

### Summary
The NFT contract maintains a dual permission system where the TokenContract issuer always has implicit minting rights regardless of the explicitly managed minter list. This creates an irrevocable permission that protocol creators cannot control, leading to potential unauthorized minting if the issuer's key is compromised and API inconsistency between stored and enforced permissions.

### Finding Description

The vulnerability stems from a discrepancy between two permission management mechanisms:

**Creation Flow:**
When creating an NFT protocol, the creator is set as the TokenContract issuer [1](#0-0) , and an explicit minter list is stored in the NFT contract's state [2](#0-1) .

**Permission Check Mechanism:**
During minting operations, the contract uses a private `GetMinterList` helper function that automatically includes the TokenContract issuer in the permission check [3](#0-2) . This modified list is then used to verify minting permissions [4](#0-3) .

**The Critical Flaw:**
The NFT protocol creator can only modify the stored minter list through `AddMinters` and `RemoveMinters` functions [5](#0-4) . Even if the creator calls `RemoveMinters` to remove the issuer from the stored list, the permission check will still grant minting rights because the private helper always re-adds the issuer.

**API Inconsistency:**
The public view function `GetMinterList` returns only the stored minter list [6](#0-5) , which does not reflect the actual enforced permissions. This creates a misleading API where users querying minting permissions see different results than what's actually enforced.

### Impact Explanation

**Loss of Access Control:**
NFT protocol creators lose the ability to fully control minting permissions for their protocols. The TokenContract issuer maintains irrevocable minting rights that cannot be removed through the standard permission management functions.

**Security Risk:**
If the issuer's private key is compromised, the creator has no mechanism to revoke the attacker's minting access. The attacker can continue to mint NFTs indefinitely, bypassing all attempts at access revocation through `RemoveMinters`.

**Supply Inflation:**
Unauthorized minting by a compromised issuer can inflate the NFT supply beyond the protocol creator's intended limits, violating the total supply invariant [7](#0-6) .

**API Inconsistency:**
External contracts and users querying the public `GetMinterList` function will receive incomplete information about actual minting permissions, potentially leading to incorrect assumptions about protocol security and access control.

This affects all NFT protocols created through the NFT contract, as the issuer is always set during creation and cannot be subsequently modified for tokens with owners (which includes all NFT tokens created through this contract).

### Likelihood Explanation

**High Likelihood:**
This is not an edge case but the default behavior for all NFT protocols. Every protocol created through the `Create` function automatically grants irrevocable minting rights to the issuer.

**No Special Preconditions Required:**
- The issuer is set at creation time with no special setup needed
- The permission check automatically includes the issuer on every mint operation
- No governance actions or special contract states are required

**Realistic Attack Scenario:**
1. Protocol creator creates an NFT protocol, becoming the TokenContract issuer
2. Creator's private key is compromised or stolen
3. Creator attempts to revoke access by calling `RemoveMinters` with the compromised address
4. The compromised issuer can still mint NFTs because `GetMinterList` always grants issuer permission
5. Attacker mints NFTs up to total supply limit, inflating supply and damaging protocol value

**Economic Rationality:**
The attack requires no special resources beyond obtaining the issuer's private key through phishing, social engineering, or key theft. There are no transaction costs that would make this attack economically infeasible.

### Recommendation

**Immediate Fix:**
Remove the automatic inclusion of the TokenContract issuer in the permission check. Modify the private `GetMinterList` helper function to return only the stored minter list without modification:

```csharp
private MinterList GetMinterList(TokenInfo tokenInfo)
{
    var minterList = State.MinterListMap[tokenInfo.Symbol] ?? new MinterList();
    // Remove: if (!minterList.Value.Contains(tokenInfo.Issuer)) minterList.Value.Add(tokenInfo.Issuer);
    return minterList;
}
```

**Alternative Approach:**
If the issuer should always have minting rights by design, prevent the issuer from being removed through `RemoveMinters` by adding a check:

```csharp
public override Empty RemoveMinters(RemoveMintersInput input)
{
    var protocolInfo = State.NftProtocolMap[input.Symbol];
    Assert(Context.Sender == protocolInfo.Creator, "No permission.");
    
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput { Symbol = input.Symbol });
    var minterList = State.MinterListMap[protocolInfo.Symbol];
    
    foreach (var minter in input.MinterList.Value)
    {
        Assert(minter != tokenInfo.Issuer, "Cannot remove token issuer from minter list.");
        if (minterList.Value.Contains(minter))
            minterList.Value.Remove(minter);
    }
    // ... rest of function
}
```

**Update Public API:**
Ensure the public `GetMinterList` view function returns the same permissions used in enforcement. Either modify the view function to include the issuer, or ensure the enforcement doesn't add the issuer automatically.

**Add Test Cases:**
1. Test that protocol creator can successfully revoke all minting permissions including their own
2. Test that removed minters cannot mint even if they are the TokenContract issuer
3. Test that the public `GetMinterList` view function returns the same list used in permission checks

### Proof of Concept

**Initial State:**
1. User creates NFT protocol "TESTNFT" through `Create` function
2. User becomes both protocol creator and TokenContract issuer
3. MinterListMap["TESTNFT"] contains only the creator address

**Attack Sequence:**
1. Creator's private key is compromised
2. Creator calls `RemoveMinters` with their own address to revoke access
3. MinterListMap["TESTNFT"] is now empty
4. Public view `GetMinterList("TESTNFT")` returns empty list
5. Compromised issuer calls `Mint` for "TESTNFT"

**Expected Result (Secure):**
Mint operation should fail with "No permission to mint." assertion

**Actual Result (Vulnerable):**
Mint operation succeeds because the private `GetMinterList` helper adds the issuer back to the permission list before the check at line 399, bypassing the creator's explicit revocation of minting rights.

**Success Condition:**
Compromised issuer successfully mints NFTs despite being removed from the stored minter list, demonstrating that the creator cannot effectively revoke the issuer's minting permissions.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L27-27)
```csharp
            Issuer = creator,
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L36-38)
```csharp
        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-373)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol] ?? new MinterList();

        foreach (var minter in input.MinterList.Value)
            if (!minterList.Value.Contains(minter))
                minterList.Value.Add(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListAdded
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }

    public override Empty RemoveMinters(RemoveMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol];

        foreach (var minter in input.MinterList.Value)
            if (minterList.Value.Contains(minter))
                minterList.Value.Remove(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListRemoved
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L375-381)
```csharp
    private MinterList GetMinterList(TokenInfo tokenInfo)
    {
        var minterList = State.MinterListMap[tokenInfo.Symbol] ?? new MinterList();
        if (!minterList.Value.Contains(tokenInfo.Issuer)) minterList.Value.Add(tokenInfo.Issuer);

        return minterList;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L398-399)
```csharp
        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L403-406)
```csharp
        protocolInfo.Supply = protocolInfo.Supply.Add(quantity);
        protocolInfo.Issued = protocolInfo.Issued.Add(quantity);
        Assert(protocolInfo.Issued <= protocolInfo.TotalSupply, "Total supply exceeded.");
        State.NftProtocolMap[input.Symbol] = protocolInfo;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L77-80)
```csharp
    public override MinterList GetMinterList(StringValue input)
    {
        return State.MinterListMap[input.Value];
    }
```
