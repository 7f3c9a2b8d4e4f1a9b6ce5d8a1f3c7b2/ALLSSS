# Audit Report

## Title
Precision Loss in SafeCalculateProfits Causes Permanent Fund Lockup in Period-Specific Virtual Addresses

## Summary
The `SafeCalculateProfits` method in ProfitContract uses a truncating `(long)` cast that permanently locks dust amounts in period-specific virtual addresses. Each distribution period creates a unique virtual address via hash functions, and without any recovery mechanism, these dust amounts accumulate and become permanently inaccessible, violating the token conservation invariant.

## Finding Description

The vulnerability stems from the `SafeCalculateProfits` method which performs decimal arithmetic but truncates when casting back to long: [1](#0-0) 

This truncation creates a two-level precision loss:

**First Level - Sub-scheme Distribution:**
When distributing to sub-schemes, the truncated amounts are calculated and sent, with the remainder going to the period-specific virtual address: [2](#0-1) [3](#0-2) 

**Second Level - Individual Claims:**
When beneficiaries claim profits, the same truncation occurs again: [4](#0-3) 

**Why Funds Become Permanently Locked:**

Each period uses a unique virtual address generated by XORing the scheme ID with a hash of the period number: [5](#0-4) 

Once a period ends, its virtual address is never accessed again. There is no sweep function, recovery mechanism, or admin method to reclaim dust from these addresses. The only fund-burning method (`BurnProfits`) operates on the general ledger, not period-specific addresses.

**Evidence from Test Files:**

Test files explicitly acknowledge and allow for rounding losses: [6](#0-5) 

These assertions allow individual claims to be 2 tokens short and total distributions to be 6 tokens short, confirming developers are aware of precision loss but have not implemented recovery.

## Impact Explanation

**Severity: Medium**

This vulnerability violates the core token conservation invariant - tokens sent to a profit scheme should be either claimable by beneficiaries or recoverable by the protocol. Instead, dust amounts become permanently locked in orphaned virtual addresses.

**Direct Fund Loss:**
- For a scheme with 100 participants distributing daily, approximately 1-2 tokens are lost per day
- Annual loss: 365-730 tokens per scheme
- Over 5 years: 1,825-3,650 tokens permanently locked per scheme

**Systemic Impact:**
- Affects ALL profit schemes including Treasury, TokenHolder, and Election dividends
- TokenHolder contract delegates to ProfitContract, inheriting this vulnerability: [7](#0-6) [8](#0-7) 

**Concrete Example:**
Distributing 99 tokens among 3 beneficiaries with shares (3333, 3333, 3334):
- Beneficiary 1: (long)(99 × 3333 ÷ 10000) = 32 tokens
- Beneficiary 2: (long)(99 × 3333 ÷ 10000) = 32 tokens  
- Beneficiary 3: (long)(99 × 3334 ÷ 10000) = 33 tokens
- **Total distributed: 97 tokens, 2 tokens permanently locked**

## Likelihood Explanation

**Likelihood: Certain (100%)**

This is not an exploit - it's an automatic bug that occurs on every profit distribution where shares don't divide evenly into whole numbers.

**Triggering Conditions:**
- Happens automatically during normal `DistributeProfits` and `ClaimProfits` operations
- No attacker action required
- No special conditions or timing requirements
- Guaranteed with any non-trivial share distribution

**Reachability:**
The vulnerable methods are publicly accessible: [9](#0-8) 

## Recommendation

**Solution 1: Track and Redistribute Dust**
Maintain a state variable tracking accumulated dust per period. When the next period distributes, include the previous period's dust in the distribution amount.

**Solution 2: Implement Sweep Function**
Add an admin function callable by scheme managers to sweep remaining balances from old period virtual addresses back to the general ledger:

```csharp
public override Empty SweepPeriodDust(SweepPeriodDustInput input)
{
    var scheme = State.SchemeInfos[input.SchemeId];
    Assert(scheme != null, "Scheme not found.");
    Assert(Context.Sender == scheme.Manager, "Only manager can sweep dust.");
    
    var periodAddress = GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);
    
    foreach (var symbol in input.Symbols)
    {
        var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
        {
            Owner = periodAddress,
            Symbol = symbol
        }).Balance;
        
        if (balance > 0)
        {
            Context.SendVirtualInline(
                GeneratePeriodVirtualAddressFromHash(input.SchemeId, input.Period),
                State.TokenContract.Value,
                nameof(State.TokenContract.Transfer), 
                new TransferInput
                {
                    To = scheme.VirtualAddress,
                    Amount = balance,
                    Symbol = symbol
                }.ToByteString());
        }
    }
    
    return new Empty();
}
```

**Solution 3: Use Rounding Up for Last Beneficiary**
When distributing, calculate all amounts using truncation except the last beneficiary, who receives the remainder to ensure total distribution equals input amount.

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_PrecisionLoss_CausesPermanentFundLockup_Test()
{
    // Setup: Create scheme and add 3 beneficiaries with specific shares
    var creator = Creators[0];
    var schemeId = await CreateSchemeAsync();
    
    const long beneficiary1Shares = 3333;
    const long beneficiary2Shares = 3333;
    const long beneficiary3Shares = 3334;
    const long totalAmount = 99;
    
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare 
        { 
            Beneficiary = Accounts[0].Address, 
            Shares = beneficiary1Shares 
        }
    });
    
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare 
        { 
            Beneficiary = Accounts[1].Address, 
            Shares = beneficiary2Shares 
        }
    });
    
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare 
        { 
            Beneficiary = Accounts[2].Address, 
            Shares = beneficiary3Shares 
        }
    });
    
    // Contribute and distribute profits
    await ContributeProfits(schemeId, totalAmount);
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        AmountsMap = { { ProfitContractTestConstants.NativeTokenSymbol, totalAmount } },
        Period = 1
    });
    
    // All beneficiaries claim their profits
    await Normal[0].ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeId = schemeId });
    await Normal[1].ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeId = schemeId });
    await Normal[2].ClaimProfits.SendAsync(new ClaimProfitsInput { SchemeId = schemeId });
    
    // Check period virtual address balance - should have dust remaining
    var periodAddress = await creator.GetSchemeAddress.CallAsync(new SchemePeriod
    {
        SchemeId = schemeId,
        Period = 1
    });
    
    var remainingBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = periodAddress,
        Symbol = ProfitContractTestConstants.NativeTokenSymbol
    })).Balance;
    
    // Vulnerability: 2 tokens permanently locked in period virtual address
    remainingBalance.ShouldBe(2); 
    
    // No recovery mechanism exists - these funds are permanently lost
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L417-499)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        if (input.AmountsMap.Any())
            Assert(input.AmountsMap.All(a => !string.IsNullOrEmpty(a.Key)), "Invalid token symbol.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");

        ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);

        var profitsMap = new Dictionary<string, long>();
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
        else
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
        }

        var totalShares = scheme.TotalShares;

        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }

        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");

        var profitsReceivingVirtualAddress =
            GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, releasingPeriod);

        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);

        Context.LogDebug(() => $"Receiving virtual address: {profitsReceivingVirtualAddress}");

        UpdateDistributedProfits(profitsMap, profitsReceivingVirtualAddress, totalShares);

        PerformDistributeProfits(profitsMap, scheme, totalShares, profitsReceivingVirtualAddress);

        scheme.CurrentPeriod = input.Period.Add(1);

        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L585-604)
```csharp
    private void PerformDistributeProfits(Dictionary<string, long> profitsMap, Scheme scheme, long totalShares,
        Address profitsReceivingVirtualAddress)
    {
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var remainAmount = DistributeProfitsForSubSchemes(symbol, amount, scheme, totalShares);
            Context.LogDebug(() => $"Distributing {remainAmount} {symbol} tokens.");
            // Transfer remain amount to individuals' receiving profits address.
            if (remainAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L606-649)
```csharp
    private long DistributeProfitsForSubSchemes(string symbol, long totalAmount, Scheme scheme, long totalShares)
    {
        Context.LogDebug(() => $"Sub schemes count: {scheme.SubSchemes.Count}");
        var remainAmount = totalAmount;
        foreach (var subSchemeShares in scheme.SubSchemes)
        {
            Context.LogDebug(() => $"Releasing {subSchemeShares.SchemeId}");

            // General ledger of this sub profit scheme.
            var subItemVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeShares.SchemeId);

            if (State.TokenContract.Value == null)
                State.TokenContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

            var distributeAmount = SafeCalculateProfits(subSchemeShares.Shares, totalAmount, totalShares);
            if (distributeAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = subItemVirtualAddress,
                        Amount = distributeAmount,
                        Symbol = symbol
                    }.ToByteString());

            remainAmount = remainAmount.Sub(distributeAmount);

            // Update current_period of detail of sub profit scheme.
            var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
            foreach (var detail in subItemDetail.Details) detail.LastProfitPeriod = scheme.CurrentPeriod;

            State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress] = subItemDetail;

            // Update sub scheme.
            var subScheme = State.SchemeInfos[subSchemeShares.SchemeId];
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
            }
        }

        return remainAmount;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L845-920)
```csharp
    private Dictionary<string, long> ProfitAllPeriods(Scheme scheme, ProfitDetail profitDetail, Address beneficiary, long maxProfitReceivingPeriodCount,
        bool isView = false, string targetSymbol = null)
    {
        var profitsMap = new Dictionary<string, long>();
        var lastProfitPeriod = profitDetail.LastProfitPeriod;

        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }

            profitsMap.Add(symbol, totalAmount);
        }

        profitDetail.LastProfitPeriod = lastProfitPeriod;

        return profitsMap;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L57-60)
```csharp
    private Hash GeneratePeriodVirtualAddressFromHash(Hash schemeId, long period)
    {
        return HashHelper.XorAndCompute(schemeId, HashHelper.ComputeFrom(period));
    }
```

**File:** test/AElf.Contracts.Election.Tests/Full/CitizenWelfareTests.cs (L715-725)
```csharp
            var actualClaimed = logEvents.Sum(l => l.Amount);
            actualClaimed.ShouldBeInRange(shouldClaimed - 2, shouldClaimed);
            profitsList.Add(actualClaimed);

            logEvents.First().TotalShares.ShouldBe(_profitShare.GetTotalSharesOfPeriod(period));
            logEvents.Select(l => l.ClaimerShares).Sum()
                .ShouldBe(_profitShare.GetSharesOfPeriod(period)[VoterKeyPairs[i].PublicKey.ToHex()]);
        }

        profitsList.Sum().ShouldBeInRange(totalAmount - 6, totalAmount);
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L131-147)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager, true);
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
        var distributeProfitsInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
        if (input.AmountsMap != null && input.AmountsMap.Any()) distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

        State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
        scheme.Period = scheme.Period.Add(1);
        State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L247-257)
```csharp
    public override Empty ClaimProfits(ClaimProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
        var beneficiary = input.Beneficiary ?? Context.Sender;
        State.ProfitContract.ClaimProfits.Send(new Profit.ClaimProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = beneficiary
        });
        return new Empty();
    }
```
