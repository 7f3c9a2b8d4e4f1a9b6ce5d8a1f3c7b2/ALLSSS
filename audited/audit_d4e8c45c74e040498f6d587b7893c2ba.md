### Title
Removed Organization Members Retain Proposal Creation Rights via Orphaned ProposerWhiteList Entries

### Summary
The `RemoveMember` function only removes addresses from the `OrganizationMemberList` but fails to remove them from the `ProposerWhiteList`. Since proposal creation authorization only checks the `ProposerWhiteList`, removed members can continue creating proposals despite no longer being organization members, violating the governance authorization invariant that proposers should be active members.

### Finding Description

The Association contract maintains two separate address lists for each organization: `OrganizationMemberList` (for voting rights) and `ProposerWhiteList` (for proposal creation rights). The vulnerability exists because these lists are managed independently without synchronization.

**Root Cause Location:**

The `RemoveMember` function only removes the address from `OrganizationMemberList`: [1](#0-0) 

The Organization structure contains both lists as separate fields: [2](#0-1) 

**Authorization Check Mismatch:**

When creating proposals, only the `ProposerWhiteList` is checked: [3](#0-2) 

The `AssertIsAuthorizedProposer` function only validates against `ProposerWhiteList`: [4](#0-3) 

However, voting operations (Approve/Reject/Abstain) correctly check the `OrganizationMemberList`: [5](#0-4) 

**Why Existing Protections Fail:**

The `Validate` function only ensures both lists are non-empty and duplicate-free, but does NOT enforce that proposers must also be members: [6](#0-5) 

While `ChangeOrganizationProposerWhiteList` exists to manually update the whitelist, it requires a full proposal workflow and is not automatically invoked by `RemoveMember`: [7](#0-6) 

### Impact Explanation

**Concrete Harm:**
- Non-members can create proposals that execute arbitrary contract calls on behalf of the organization
- Removed/expelled members retain governance influence without accountability
- Organization loses effective control over proposal creation through normal member management
- Breaks the fundamental governance invariant that proposers should be accountable active members

**Affected Parties:**
- All Association-based organizations in the AElf ecosystem
- Governance decisions become vulnerable to manipulation by former members
- Legitimate members cannot prevent proposal spam from removed members

**Severity Justification - HIGH:**
This is a governance bypass vulnerability allowing unauthorized proposal creation. While removed members cannot vote or force proposal execution, they can:
1. Create malicious proposals to confuse governance
2. Spam proposals causing operational overhead
3. Exploit timing windows if they regain temporary access to voting members
4. Maintain influence they should have lost upon removal

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must have previously been added to both `OrganizationMemberList` and `ProposerWhiteList`
- No special privileges required beyond being a former member
- Attack persists indefinitely after removal unless whitelist is manually updated via separate proposal

**Attack Complexity - LOW:**
1. Organization creates member with proposer rights (normal operation)
2. Organization removes member via `RemoveMember` (normal operation)
3. Removed member calls `CreateProposal` - succeeds due to orphaned whitelist entry
4. Removed member cannot vote, but proposal exists in system

**Feasibility:**
- Entry point is the standard public `CreateProposal` method
- No complex state manipulation required
- Works under normal AElf contract execution semantics
- Economically rational for malicious actors (low cost, high governance impact)

**Detection Constraints:**
- Organizations may not realize removed members can still create proposals
- No automatic cleanup mechanism exists
- Manual whitelist management via proposals is burdensome and error-prone

**Probability - HIGH:**
This will occur in any organization that removes members who were previously in the proposer whitelist, unless they explicitly create and execute a separate proposal to update the whitelist.

### Recommendation

**Code-Level Mitigation:**

Modify the `RemoveMember` function to also remove the address from `ProposerWhiteList`:

```csharp
public override Empty RemoveMember(Address input)
{
    var organization = State.Organizations[Context.Sender];
    Assert(organization != null, "Organization not found.");
    var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
    Assert(removeResult, "Remove member failed.");
    
    // ADD: Also remove from ProposerWhiteList if present
    organization.ProposerWhiteList.Proposers.Remove(input);
    
    Assert(Validate(organization), "Invalid organization.");
    State.Organizations[Context.Sender] = organization;
    Context.Fire(new MemberRemoved
    {
        OrganizationAddress = Context.Sender,
        Member = input
    });
    return new Empty();
}
```

**Invariant Check to Add:**

Add validation in the `Validate` function to enforce that all proposers must be members:

```csharp
private bool Validate(Organization organization)
{
    // Existing validations...
    
    // ADD: Ensure all proposers are also members
    foreach (var proposer in organization.ProposerWhiteList.Proposers)
    {
        if (!organization.OrganizationMemberList.OrganizationMembers.Contains(proposer))
            return false;
    }
    
    // Rest of validation...
}
```

**Test Cases to Add:**
1. Remove member who is in ProposerWhiteList - verify they cannot create proposals
2. Remove member who is not in ProposerWhiteList - verify normal operation
3. Attempt to create organization where proposer is not a member - should fail validation
4. Use `ChangeMember` with proposer - verify both lists are updated correctly

### Proof of Concept

**Required Initial State:**
- Association contract deployed and initialized
- Organization created with at least 2 members
- Address Alice in both `OrganizationMemberList` and `ProposerWhiteList`
- Address Bob in `OrganizationMemberList` only

**Transaction Sequence:**

1. **Setup**: Create organization
   - Call `CreateOrganization` with:
     - `organization_member_list`: [Alice, Bob]
     - `proposer_white_list`: [Alice]
     - Appropriate thresholds
   - Result: Organization created with address OrgAddress

2. **Normal Operation**: Alice creates proposal (should succeed)
   - Call `CreateProposal` from Alice's address
   - Input: Valid proposal targeting any contract method
   - Expected: Proposal created successfully
   - Actual: ✓ Proposal created (Alice in ProposerWhiteList)

3. **Remove Member**: Organization removes Alice
   - Call `RemoveMember` from OrgAddress (via prior proposal or if authorized)
   - Input: Alice's address
   - Expected: Alice removed from organization
   - Actual: ✓ Alice removed from `OrganizationMemberList` only

4. **Exploit**: Removed member creates proposal
   - Call `CreateProposal` from Alice's address
   - Input: New proposal with different parameters
   - Expected: Transaction should FAIL with "Unauthorized to propose"
   - **Actual: ✗ Transaction SUCCEEDS - Alice still in ProposerWhiteList**

5. **Verification**: Removed member cannot vote
   - Call `Approve` from Alice's address on any proposal
   - Expected: Transaction fails with "Unauthorized member"
   - Actual: ✓ Transaction fails correctly (Alice not in OrganizationMemberList)

**Success Condition:**
Step 4 succeeds when it should fail, proving removed members retain proposal creation rights while losing voting rights. This demonstrates the authorization inconsistency between the two lists.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** protobuf/association_contract.proto (L61-74)
```text
message Organization{
    // The organization members.
    OrganizationMemberList organization_member_list = 1;
    // The threshold for releasing the proposal.
    acs3.ProposalReleaseThreshold proposal_release_threshold = 2;
    // The proposer whitelist.
    acs3.ProposerWhiteList proposer_white_list = 3;
    // The address of organization.
    aelf.Address organization_address = 4;
    // The organizations id.
    aelf.Hash organization_hash = 5;
    // The creation token is for organization address generation.
    aelf.Hash creation_token = 6;
}
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```
