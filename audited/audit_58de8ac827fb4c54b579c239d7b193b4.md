### Title
Miner Cartel Can Manipulate Last Irreversible Block Height Through Unvalidated ImpliedIrreversibleBlockHeight Input

### Summary
Colluding miners can manipulate the Last Irreversible Block (LIB) height calculation by providing arbitrary `ImpliedIrreversibleBlockHeight` values in `UpdateValueInput`. The system lacks validation that this value equals `Context.CurrentHeight`, allowing miners to either stall finalization (by reporting low values) or prematurely finalize blocks (by reporting high values), breaking the consensus finality guarantee.

### Finding Description

The vulnerability exists in the consensus update flow where miners report their implied irreversible block height:

**Entry Point:** When miners produce blocks, `ExtractInformationToUpdateConsensus()` creates an `UpdateValueInput` that includes `ImpliedIrreversibleBlockHeight` from the miner's round information. [1](#0-0) 

**Intended Behavior:** When generating consensus extra data, the system sets `ImpliedIrreversibleBlockHeight = Context.CurrentHeight`, representing the miner's current view of the chain height. [2](#0-1) 

**Root Cause:** During transaction processing, `ProcessUpdateValue()` directly assigns the value from user-controlled input without validating it matches `Context.CurrentHeight`. [3](#0-2) 

**Insufficient Validation:** The `LibInformationValidationProvider` only checks that the provided value doesn't decrease from the previous value, but doesn't validate it equals or doesn't exceed the current block height. [4](#0-3) 

**LIB Calculation Impact:** The LIB is calculated by sorting all miners' implied heights and taking the value at position `(count-1)/3`, which represents approximately the lowest third. This means a cartel controlling more than 1/3 of miners can influence the LIB by reporting coordinated values. [5](#0-4) 

### Impact Explanation

**Attack Vector 1 - Denial of Service on Finalization (>1/3 Cartel):**
- With 7 total miners, 3 colluding miners (>1/3) can keep reporting `ImpliedIrreversibleBlockHeight = 1000` even when the current chain height reaches 5000
- Sorted heights: [1000, 1000, 1000, 5000, 5000, 5000, 5000]
- LIB position: (7-1)/3 = 2
- Calculated LIB: heights[2] = 1000
- **Result:** Blocks from 1001 onwards never finalize, breaking finality guarantees and cross-chain indexing that depends on irreversible block heights

**Attack Vector 2 - Premature Finalization (>2/3 Cartel):**
- With 7 total miners, 5 colluding miners (>2/3) report artificially high values like `ImpliedIrreversibleBlockHeight = 10000` when current height is only 5000
- Sorted heights: [5000, 5000, 10000, 10000, 10000, 10000, 10000]
- LIB position: (7-1)/3 = 2
- Calculated LIB: heights[2] = 10000
- **Result:** Blocks beyond the actual chain height are marked as irreversible, potentially finalizing invalid or non-existent blocks

**Severity: Critical** - This breaks the core consensus invariant that LIB heights must accurately reflect Byzantine fault-tolerant agreement on irreversible blocks. Cross-chain operations, state finality, and blockchain security all depend on correct LIB calculation.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires control of >1/3 of active miners for DoS attack on finalization
- Requires control of >2/3 of active miners for premature finalization attack
- In DPoS systems, mining cartels can form through stake concentration or vote buying

**Attack Complexity:**
- Low - Miners simply provide different values in `UpdateValueInput.ImpliedIrreversibleBlockHeight` field [6](#0-5) 
- No cryptographic breaks or complex transaction sequences required
- Standard consensus transaction execution path

**Feasibility:**
- The `UpdateValue` behavior is processed every block by participating miners [7](#0-6) 
- Validation only occurs through `LibInformationValidationProvider` which is insufficient
- No upper bound or equality checks exist in the codebase

**Detection:** 
- Difficult to detect since malicious values pass validation and are indistinguishable from network delays or honest reporting differences
- Only observable through monitoring LIB advancement patterns

**Economic Rationality:**
- High incentive for miners to manipulate finality for double-spend attacks, cross-chain fraud, or disrupting competitors
- Cost is only forming a mining cartel, which is feasible in stake-based consensus

### Recommendation

**Immediate Fix:**
Add strict validation in `ProcessUpdateValue()` to enforce that `ImpliedIrreversibleBlockHeight` equals `Context.CurrentHeight`:

```csharp
// In ProcessUpdateValue, after line 242:
Assert(
    updateValueInput.ImpliedIrreversibleBlockHeight == Context.CurrentHeight,
    $"Invalid implied irreversible block height. Expected {Context.CurrentHeight}, got {updateValueInput.ImpliedIrreversibleBlockHeight}");

minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**Alternative Approach:**
Modify `LibInformationValidationProvider` to add an upper bound check:

```csharp
// In ValidateHeaderInformation, add after line 30:
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight > validationContext.CurrentHeight)
{
    validationResult.Message = "Implied lib height cannot exceed current height.";
    return validationResult;
}
```

**Test Cases:**
1. Test that miners cannot set `ImpliedIrreversibleBlockHeight` higher than current block height
2. Test that miners cannot keep stale low values across multiple rounds
3. Test LIB calculation with various cartel sizes and manipulated values
4. Integration test verifying LIB advances correctly even with Byzantine miners

### Proof of Concept

**Initial State:**
- Network has 7 active miners
- Current round number: N
- Current block height: 5000
- Previous LIB: 4500

**Attack Scenario 1 - Finalization DoS (3 malicious miners):**

1. Malicious miners M1, M2, M3 produce blocks at heights 5001, 5002, 5003
2. Each sets `UpdateValueInput.ImpliedIrreversibleBlockHeight = 1000` (far below current height)
3. Honest miners M4, M5, M6, M7 produce blocks at heights 5004, 5005, 5006, 5007
4. Each honestly sets `UpdateValueInput.ImpliedIrreversibleBlockHeight = 5004, 5005, 5006, 5007` respectively
5. In round N+1, LIB calculation executes [8](#0-7) 
6. Sorted heights from round N: [1000, 1000, 1000, 5004, 5005, 5006, 5007]
7. LIB position: (7-1)/3 = 2
8. New LIB: heights[2] = 1000

**Expected Result:** LIB should advance to approximately 5003 (2/3 of current height)

**Actual Result:** LIB remains at 1000, stalling finalization for 4000+ blocks

**Success Condition:** LIB does not advance beyond 1000 despite chain progressing to height 5007, demonstrating successful finalization DoS with only 3/7 miners (42.8% < 50%).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L48-48)
```csharp
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** protobuf/aedpos_contract.proto (L217-218)
```text
    // The irreversible block height that miner recorded.
    int64 implied_irreversible_block_height = 12;
```
