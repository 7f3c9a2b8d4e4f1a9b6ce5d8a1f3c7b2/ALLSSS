# Audit Report

## Title
Missing LIB Height Validation in NextTerm Consensus Behavior Enables Consensus DoS Attack

## Summary
A malicious miner can inject negative `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` values during term transitions due to missing `LibInformationValidationProvider` validation for `NextTerm` behavior. This causes the blockchain to immediately enter Severe mining status, reducing block production to 1 block per round and effectively DoS'ing the consensus mechanism.

## Finding Description

**Root Cause:**

The `NextTermInput.Create()` method directly copies `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` from the provided Round parameter without any validation. [1](#0-0) 

These fields are defined as `int64` in the protobuf schema, allowing negative values. [2](#0-1) 

**Missing Validation:**

In `ValidateBeforeExecution`, the `LibInformationValidationProvider` (which validates LIB height monotonicity) is **only** applied to `UpdateValue` behavior at line 82, NOT to `NextTerm` behavior. [3](#0-2) 

The `LibInformationValidationProvider` prevents LIB values from going backward by checking if the new values are less than existing values. [4](#0-3) 

For `NextTerm` behavior, only `RoundTerminateValidationProvider` is applied, which validates term/round number increments but NOT LIB heights. [5](#0-4) 

**Attack Execution Path:**

1. A malicious miner (who is in the active miner list) generates a `NextTerm` transaction with manipulated Round containing negative `ConfirmedIrreversibleBlockHeight` (e.g., -1,000,000) and `ConfirmedIrreversibleBlockRoundNumber` (e.g., -100)

2. The consensus extra data passes validation since `LibInformationValidationProvider` is not applied to `NextTerm` behavior

3. The `NextTerm` method calls `ProcessConsensusInformation`. [6](#0-5) 

4. `ProcessConsensusInformation` routes to `ProcessNextTerm` which converts the input to Round. [7](#0-6) [8](#0-7) 

5. `ProcessNextTerm` stores the malicious Round via `AddRoundInformation` without any validation. [9](#0-8) 

6. `AddRoundInformation` directly persists to state. [10](#0-9) 

**Consensus DoS Impact:**

Once the negative LIB values are stored, subsequent calls to `GetMaximumBlocksCount()` read the malicious `libRoundNumber`. [11](#0-10) 

The `BlockchainMiningStatusEvaluator` uses the negative `libRoundNumber` in status calculation. With `libRoundNumber = -100` and `currentRoundNumber = 100` (example), the condition at line 127 evaluates to `100 >= -100 + 8` which is `100 >= -92` = TRUE, causing the blockchain to enter **Severe** status. [12](#0-11) 

In Severe status, mining is restricted to **1 block per round**, and `IrreversibleBlockHeightUnacceptable` events are fired continuously. [13](#0-12) 

## Impact Explanation

This vulnerability enables a **Consensus Denial-of-Service attack** with severe operational impact:

- **Blockchain Throughput**: Reduced to ~1 block per round (from normal 8+ blocks), causing severe performance degradation affecting all network participants
- **Network Disruption**: Continuous `IrreversibleBlockHeightUnacceptable` events signal abnormal state to the network
- **Consensus Integrity**: The blockchain appears to be in an abnormal Severe status despite being otherwise functional
- **Recovery Complexity**: Requires majority miner coordination to transition to the next term with valid LIB values

The attack has **persistent effect** - once the malicious values are stored in state, they remain until the next term transition fixes them. All users, applications, and services dependent on the blockchain experience degraded performance during this period.

The comment in the code suggesting protection via `ConstrainedAEDPoSTransactionValidationProvider` indicates this validation was intended but never implemented. [14](#0-13) 

## Likelihood Explanation

**HIGH Likelihood** - The attack is highly feasible:

**Attacker Capabilities Required:**
- Must be a current miner in the active miner list (multiple parties possess this capability in any decentralized network)
- Can generate and broadcast consensus blocks (standard miner capability)

**Attack Complexity:** LOW
- Simple modification of consensus extra data during term transition
- No complex state manipulation or precise timing requirements
- Single malicious block during term transition achieves persistent DoS effect

**Attack Window:**
- Any term transition provides an opportunity (these occur regularly based on election/term configuration)
- No detection or prevention at the validation layer

**Economic Rationality:**
- Attack cost: Normal block production cost (attacker is already producing blocks as a miner)
- Attack benefit: Severe network disruption, potential competitive advantage if attacker operates alternative infrastructure
- Low cost + high impact = economically rational for adversarial miners

The attack requires only privileges that multiple parties legitimately hold, has simple execution with guaranteed impact, making it a realistic threat scenario.

## Recommendation

Apply `LibInformationValidationProvider` validation to `NextTerm` behavior in addition to `UpdateValue`. Modify the validation logic in `ValidateBeforeExecution`:

```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        break;
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS LINE
        break;
}
```

Additionally, consider adding explicit validation in `NextTermInput.Create()` or `ProcessNextTerm` to reject non-positive LIB values:

```csharp
Assert(round.ConfirmedIrreversibleBlockHeight >= 0, "Invalid LIB height");
Assert(round.ConfirmedIrreversibleBlockRoundNumber >= 0, "Invalid LIB round number");
```

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. **Setup**: Initialize blockchain with normal consensus state where current round number is 100 and current LIB round number is 98
2. **Attack**: A miner in the active list generates a `NextTerm` transaction with:
   - `ConfirmedIrreversibleBlockRoundNumber = -100`
   - `ConfirmedIrreversibleBlockHeight = -1000000`
   - Valid term number increment and round number increment
3. **Validation Bypass**: The transaction passes `ValidateBeforeExecution` because `LibInformationValidationProvider` is not applied to `NextTerm` behavior
4. **State Corruption**: `ProcessNextTerm` stores the malicious values via `AddRoundInformation`
5. **DoS Trigger**: Next call to `GetMaximumBlocksCount()` evaluates: `currentRoundNumber (100) >= libRoundNumber (-100) + SevereStatusRoundsThreshold (8)` = `100 >= -92` = TRUE
6. **Impact**: Blockchain enters Severe status, `GetMaximumBlocksCount()` returns 1, mining restricted to 1 block per round
7. **Verification**: Monitor for continuous `IrreversibleBlockHeightUnacceptable` events and degraded block production rate

The attack succeeds because the validation gap allows negative LIB values to bypass checks during term transitions, directly corrupting consensus state and triggering the Severe mining status condition.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L16-17)
```csharp
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
```

**File:** protobuf/aedpos_contract.proto (L257-259)
```text
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-91)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L41-43)
```csharp
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-163)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L196-196)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L323-325)
```csharp
        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L24-26)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L127-128)
```csharp
            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```
