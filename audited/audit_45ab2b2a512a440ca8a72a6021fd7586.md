### Title
Case-Sensitive Pubkey Comparison Allows Banned Initial Miners to Bypass Ban and Replace Their Public Key

### Summary
The `IsPubkeyBanned()` function performs case-sensitive string lookups on `BannedPubkeyMap`, but pubkeys are stored in lowercase when banned by the consensus contract. A banned initial miner can exploit this by using uppercase hex variants of their pubkey to bypass ban checks in `SetCandidateAdmin` and `ReplaceCandidatePubkey`, ultimately allowing them to replace their banned pubkey with a new one and continue participating in consensus.

### Finding Description

**Root Cause:**

The `IsPubkeyBanned()` function at line 63 performs a direct case-sensitive dictionary lookup without normalizing the input pubkey: [1](#0-0) 

However, when pubkeys are banned by the consensus contract, they are always stored in lowercase because the consensus contract uses `ToHex()` which produces lowercase hex strings: [2](#0-1) 

The consensus contract detects evil miners and bans them using the lowercase pubkey: [3](#0-2) 

**Why Protections Fail:**

1. `SetCandidateAdmin` accepts user-provided pubkey strings without normalization and checks the ban using the exact input: [4](#0-3) 

2. For initial miners, the permission check at line 32 converts the pubkey to bytes (case-insensitive) and checks if the sender controls that address: [5](#0-4) 

3. `ReplaceCandidatePubkey` similarly checks bans without normalization: [6](#0-5) 

4. The `IsCurrentCandidateOrInitialMiner` check converts pubkeys to bytes (case-insensitive) when checking InitialMiners, allowing uppercase variants to pass: [7](#0-6) 

5. `HexStringToByteArray` is case-insensitive, treating "ABC123" and "abc123" as identical bytes: [8](#0-7) 

### Impact Explanation

**Direct Consensus Integrity Violation:**

A banned initial miner can completely bypass the ban system through the following attack:

1. Initial miner with pubkey bytes banned as lowercase "abc123..." in `BannedPubkeyMap`
2. Attacker uses uppercase variant "ABC123..." to call `SetCandidateAdmin`, which bypasses the ban check (different string key)
3. Attacker then calls `ReplaceCandidatePubkey` with uppercase "ABC123..." as OldPubkey
4. The replacement succeeds, removing the banned pubkey from InitialMiners and adding a new pubkey: [9](#0-8) 

**Consequences:**
- Banned evil nodes can return to consensus with a new identity
- Violates the critical invariant that evil miners must be permanently excluded
- Undermines the security mechanism designed to protect network integrity
- All initial miners (typically the most privileged consensus participants) are vulnerable to this bypass
- No fund loss required; attacker only needs to control their original keypair

**Severity: HIGH** - This directly compromises consensus integrity, a critical security boundary in the blockchain system.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an initial miner (set during contract initialization)
- Must control the private key corresponding to the banned pubkey
- Must be detected as evil and banned by consensus contract

**Attack Complexity: LOW**
- Two simple contract calls: `SetCandidateAdmin` then `ReplaceCandidatePubkey`
- No timing constraints or race conditions
- No economic cost beyond transaction fees
- No need to compromise trusted roles

**Feasibility: HIGH**
- Initial miners exist in every AElf chain deployment
- Evil node detection is an active mechanism in the consensus contract
- Banned miners have strong incentive to return to consensus (rewards, influence)
- The uppercase variant is a trivial transformation

**Detection: DIFFICULT**
- The ban appears to remain in place (for lowercase variant)
- State changes look legitimate (admin changes, pubkey replacements)
- Only careful analysis of case differences would reveal the bypass

### Recommendation

**Immediate Fix:**

Normalize all pubkey inputs to lowercase before any comparison or state access. Modify the ban check:

```csharp
private bool IsPubkeyBanned(string pubkey)
{
    return State.BannedPubkeyMap[pubkey.ToLower()];
}
```

**Comprehensive Fix:**

1. Add pubkey normalization at entry points:
   - In `SetCandidateAdmin`, normalize `input.Pubkey` before use
   - In `ReplaceCandidatePubkey`, normalize both `input.OldPubkey` and `input.NewPubkey`
   - In all methods accepting pubkey strings, add validation and normalization

2. Add a helper method for consistent normalization:
```csharp
private string NormalizePubkey(string pubkey)
{
    // Validate it's a valid hex string
    var bytes = ByteArrayHelper.HexStringToByteArray(pubkey);
    // Return canonical lowercase representation
    return bytes.ToHex();
}
```

3. Consider using pubkey bytes (ByteString) instead of strings for all state keys to eliminate encoding issues entirely

4. Add regression tests:
   - Test ban check with mixed-case pubkey variants
   - Test that banned pubkeys cannot bypass via case manipulation
   - Test that ReplaceCandidatePubkey fails for banned pubkeys regardless of case

### Proof of Concept

**Initial State:**
- Initial miner with pubkey bytes that convert to lowercase hex "abc123..."
- Miner is detected as evil by consensus contract
- `State.BannedPubkeyMap["abc123..."] = true` (lowercase)
- `State.CandidateInformationMap["abc123..."]` removed
- Pubkey bytes remain in `State.InitialMiners.Value.Value`

**Attack Sequence:**

**Step 1:** Call `SetCandidateAdmin` with uppercase variant
```
Input: {
  Pubkey: "ABC123..." (uppercase),
  Admin: attacker_controlled_address
}
```

Expected checks:
- `IsCurrentCandidateOrInitialMiner("ABC123...")` → PASSES (bytes match InitialMiners)
- `IsPubkeyBanned("ABC123...")` → Returns FALSE (looks up "ABC123..." not "abc123...")
- Permission check: Sender must be `Address.FromPublicKey(bytes of "ABC123...")` → PASSES if attacker controls the keypair

Result: `State.CandidateAdmins["ABC123..."] = attacker_controlled_address`

**Step 2:** Call `ReplaceCandidatePubkey` with uppercase variant
```
Input: {
  OldPubkey: "ABC123..." (uppercase),
  NewPubkey: "newkey456..." (attacker's new pubkey)
}
```

Expected checks:
- `IsCurrentCandidateOrInitialMiner("ABC123...")` → PASSES
- `IsPubkeyBanned("ABC123...")` → Returns FALSE (bypass!)
- `GetCandidateAdmin("ABC123...")` → Returns `attacker_controlled_address` (from Step 1)
- Permission check → PASSES

Result: 
- Banned pubkey bytes removed from `State.InitialMiners`
- New pubkey bytes added to `State.InitialMiners`
- Attacker successfully replaced banned identity with new one

**Success Condition:**
- Attacker's new pubkey is now an initial miner
- Original pubkey bytes no longer in InitialMiners
- Ban was completely bypassed through case manipulation
- Attacker can participate in consensus with new identity

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-23)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L29-33)
```csharp
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L61-64)
```csharp
    private bool IsPubkeyBanned(string pubkey)
    {
        return State.BannedPubkeyMap[pubkey];
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L75-82)
```csharp
    private bool IsCurrentCandidateOrInitialMiner(string pubkey)
    {
        var isCurrentCandidate = State.CandidateInformationMap[pubkey] != null &&
                                 State.CandidateInformationMap[pubkey].IsCurrentCandidate;
        var isInitialMiner = State.InitialMiners.Value.Value.Contains(
            ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey)));
        return isCurrentCandidate || isInitialMiner;
    }
```

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L38-41)
```csharp
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L175-178)
```csharp
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-18)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
```
