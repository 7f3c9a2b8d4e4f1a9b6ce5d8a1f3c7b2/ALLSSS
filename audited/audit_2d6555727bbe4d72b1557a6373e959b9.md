### Title
Non-Evil Miner Replacements Incorrectly Bypass Reward Penalty Calculations

### Summary
The `RecordMinerReplacement()` function incorrectly marks ALL replacement miners as evil miner replacements by unconditionally setting `State.IsReplacedEvilMiner[newPubkey] = true`. This causes non-evil replacement miners to bypass performance-based penalty calculations during reward distribution, receiving full shares even when producing significantly fewer blocks than average, creating unfair reward allocation.

### Finding Description

The root cause is in the `RecordMinerReplacement()` function where line 596 unconditionally executes regardless of the `IsOldPubkeyEvil` flag: [1](#0-0) 

The logic branches correctly based on `input.IsOldPubkeyEvil` (lines 583-594), but line 596 executes for ALL cases. This flag is then used in reward calculations: [2](#0-1) 

When `IsReplacedEvilMiner[pubkey]` is true, miners receive `shares = i.ProducedBlocks` directly, bypassing the penalty calculation function: [3](#0-2) 

The `CalculateShares()` function enforces performance penalties:
- Produces < 50% of average: 0 shares (no reward)
- Produces 50-80% of average: (producedBlocks² / average) shares (reduced reward)
- Produces ≥80% of average: producedBlocks shares (full reward)

The execution path starts from a public entry point callable by any candidate admin: [4](#0-3) 

This triggers the replacement notification flow: [5](#0-4) 

Which eventually calls the Treasury contract: [6](#0-5) 

### Impact Explanation

Replacement miners gain an unfair advantage in Basic Miner Reward distribution. Consider these scenarios with average blocks = 100:

**Scenario 1 (Low Performance):**
- Regular miner produces 40 blocks: receives 0 shares (no reward per penalty)
- Replacement miner produces 40 blocks: receives 40 shares (full reward)

**Scenario 2 (Mediocre Performance):**
- Regular miner produces 60 blocks: receives 60² / 100 = 36 shares (40% penalty)
- Replacement miner produces 60 blocks: receives 60 shares (no penalty)

This violates the Treasury's critical invariant of accurate share calculations and dividend distribution. Over multiple terms, this misallocates Basic Miner Rewards from high-performing miners to underperforming replacement miners. The magnitude depends on how poorly replacement miners perform, but could represent 10-100% excess rewards for severely underperforming nodes.

### Likelihood Explanation

**Attacker Capabilities:** Any candidate can voluntarily replace their public key via `ReplaceCandidatePubkey()` for legitimate reasons (key rotation, security). No special permissions or governance approval required beyond being a candidate.

**Attack Complexity:** Low. The vulnerability automatically triggers upon any pubkey replacement:
1. Candidate admin calls `ReplaceCandidatePubkey(oldPubkey, newPubkey)`
2. Treasury automatically marks new pubkey with `IsReplacedEvilMiner = true`
3. During next reward distribution, replacement miner bypasses penalties

**Feasibility:** High. The replacement mechanism is a standard operational feature. Miners can strategically time replacements before terms where they anticipate poor performance (hardware issues, network problems) to avoid penalties.

**Economic Rationality:** Clear incentive. A miner expecting to produce only 40% of average blocks would normally receive 0 reward. By replacing their pubkey first, they receive 40% reward instead - a significant gain with minimal cost.

### Recommendation

**Code Fix:** Move line 596 inside the `else` block so `IsReplacedEvilMiner` is only set for actual evil miner replacements:

```csharp
public override Empty RecordMinerReplacement(RecordMinerReplacementInput input)
{
    Assert(
        Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
        "Only AEDPoS Contract can record miner replacement.");

    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    if (!input.IsOldPubkeyEvil)
    {
        var latestMinedTerm = State.LatestMinedTerm[input.OldPubkey];
        State.LatestMinedTerm[input.NewPubkey] = latestMinedTerm;
        State.LatestMinedTerm.Remove(input.OldPubkey);
    }
    else
    {
        var replaceCandidates = State.ReplaceCandidateMap[input.CurrentTermNumber] ?? new StringList();
        replaceCandidates.Value.Add(input.NewPubkey);
        State.ReplaceCandidateMap[input.CurrentTermNumber] = replaceCandidates;
        
        // MOVE THIS LINE HERE - only for evil miner replacements
        State.IsReplacedEvilMiner[input.NewPubkey] = true;
    }

    return new Empty();
}
```

**Invariant Check:** Add assertion in `UpdateBasicMinerRewardWeights` to verify replacement miners are only marked when actually replacing evil miners.

**Test Cases:**
1. Test normal pubkey replacement: verify new miner receives penalty-adjusted shares
2. Test evil miner replacement: verify new miner bypasses penalties (if this path is implemented)
3. Test underperforming replacement miner: verify they receive 0 shares when producing < 50% average

### Proof of Concept

**Initial State:**
- Candidate A is a current miner with admin permissions
- Current term has average block production of 100 blocks per miner
- Candidate A expects to produce only 40 blocks next term (due to known hardware maintenance)

**Attack Sequence:**

1. **Before term ends:** Candidate A (admin) calls `Election.ReplaceCandidatePubkey(oldPubkeyA, newPubkeyB)`
   - Election contract processes replacement
   - AEDPoS contract updates round information
   - Treasury contract executes: `State.IsReplacedEvilMiner[newPubkeyB] = true` at line 596

2. **During next term:** New miner B produces only 40 blocks (average = 100)

3. **At term end:** `Release()` triggers `UpdateBasicMinerRewardWeights()`
   - For regular miner with 40 blocks: `CalculateShares(40, 100)` returns 0 shares
   - For miner B: bypasses `CalculateShares()`, receives `shares = 40` directly (lines 802-807)

**Expected Result:** Miner B should receive 0 shares (40 < 50% of average)

**Actual Result:** Miner B receives 40 shares, unfairly obtaining rewards that should go to other miners

**Success Condition:** Verify `State.IsReplacedEvilMiner[newPubkeyB] == true` after replacement, and observe non-zero reward shares despite severe underperformance in subsequent reward distribution.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L573-599)
```csharp
    public override Empty RecordMinerReplacement(RecordMinerReplacementInput input)
    {
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only AEDPoS Contract can record miner replacement.");

        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        if (!input.IsOldPubkeyEvil)
        {
            var latestMinedTerm = State.LatestMinedTerm[input.OldPubkey];
            State.LatestMinedTerm[input.NewPubkey] = latestMinedTerm;
            State.LatestMinedTerm.Remove(input.OldPubkey);
        }
        else
        {
            var replaceCandidates = State.ReplaceCandidateMap[input.CurrentTermNumber] ?? new StringList();
            replaceCandidates.Value.Add(input.NewPubkey);
            State.ReplaceCandidateMap[input.CurrentTermNumber] = replaceCandidates;
        }

        State.IsReplacedEvilMiner[input.NewPubkey] = true;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L802-812)
```csharp
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L280-302)
```csharp
    private void PerformReplacement(string oldPubkey, string newPubkey)
    {
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;

        // Notify Consensus Contract to update replacement information. (Update from old record.)
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-156)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
```
