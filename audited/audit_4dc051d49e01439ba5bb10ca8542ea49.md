### Title
Authorization Bypass: Any Miner Can Terminate Rounds Without Extra Block Producer Privilege

### Summary
The AEDPoS consensus system fails to validate that only the designated extra block producer can execute round termination commands (NextRound/NextTerm). Any miner in the active miner list can obtain a `TerminateRoundCommandStrategy`, produce NextRound/NextTerm blocks, and transition rounds, bypassing the extra block producer's exclusive authority. This undermines the consensus protocol's round rotation mechanism and allows unauthorized round transitions.

### Finding Description

**Root Cause:** Missing authorization check for extra block producer privilege in consensus command generation and block validation.

**Command Generation Phase (No Extra Block Producer Check):**

The consensus behavior provider determines which behavior a miner receives without checking if they are the extra block producer. In `ConsensusBehaviourProviderBase`, any miner whose time slot has passed or meets certain conditions will receive termination behavior: [1](#0-0) 

The `MainChainConsensusBehaviourProvider` returns NextRound or NextTerm based solely on round/term conditions, never checking if the caller is the extra block producer: [2](#0-1) 

When NextRound/NextTerm behavior is determined, a `TerminateRoundCommandStrategy` is created for ANY miner: [3](#0-2) 

**Mining Time Arrangement (Non-Extra-Block-Producers Get Valid Times):**

The `ArrangeAbnormalMiningTime` method checks if the pubkey is the extra block producer but only to provide optimized timing. Non-extra-block-producers still receive valid mining times: [4](#0-3) 

When not the extra block producer, the method calculates a future time based on the miner's order, allowing them to mine at their calculated slot in the next round period.

**Block Validation Phase (No Extra Block Producer Authorization Check):**

When a non-extra-block-producer produces a NextRound block, the `TimeSlotValidationProvider` only validates structural correctness for new rounds, not authorization: [5](#0-4) 

The `CheckRoundTimeSlots` method only validates that time slot intervals are consistent: [6](#0-5) 

The `PreCheck` method in transaction execution only validates miner list membership, not extra block producer privilege: [7](#0-6) 

The validation providers (`MiningPermissionValidationProvider`, `RoundTerminateValidationProvider`, `NextRoundMiningOrderValidationProvider`) check structural correctness but never verify that the sender is the extra block producer: [8](#0-7) 

**Execution Path:**
1. Regular miner calls `GetConsensusCommand` after their time slot
2. Receives NextRound/NextTerm behavior from `ConsensusBehaviourProvider`
3. Gets `TerminateRoundCommandStrategy` with valid mining time
4. Produces block with NextRound/NextTerm behavior
5. Block passes validation (only structural checks, no authorization)
6. `NextRound` or `NextTerm` transaction executes successfully
7. Round transitions without extra block producer involvement

### Impact Explanation

**Consensus Integrity Violation:**
- Any miner can bypass the designated extra block producer to terminate rounds
- Multiple miners could compete to produce NextRound blocks simultaneously
- The extra block producer's exclusive privilege to terminate rounds is meaningless
- Round rotation mechanism designed to ensure fair block production is undermined

**Protocol Disruption:**
- Strategic manipulation of round transitions by non-designated miners
- Potential for miners to skip the extra block producer's opportunity entirely
- Consensus state transitions occur without proper authorization
- Violation of the fundamental AEDPoS design where the extra block producer has special authority

**Systemic Impact:**
- Affects all rounds across the blockchain's lifetime
- Any of the active miners (typically ~17 in mainnet) can exploit this
- No recovery mechanism once unauthorized round transition completes
- Undermines trust in consensus protocol fairness and determinism

**Severity Justification:** Critical - This is a fundamental authorization bypass in the core consensus mechanism affecting protocol integrity.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an active miner in the current round (publicly verifiable role)
- No additional privileges required beyond being in miner list
- Can call public `GetConsensusCommand` method
- Can produce blocks at calculated mining times

**Attack Complexity:** Low
- Direct exploitation path through standard consensus methods
- No special timing requirements beyond waiting for arranged time
- No need to control multiple accounts or coordinate attacks
- Block production is normal miner operation

**Feasibility Conditions:**
- Attacker is an active miner (17 slots in mainnet, rotates via elections)
- Current block time has passed attacker's normal time slot
- Attacker waits for `ArrangeAbnormalMiningTime` calculated timestamp
- Produces NextRound block with consensus transaction

**Detection Constraints:**
- Exploitation appears as legitimate block production
- No obvious anomaly in block structure or timing
- Only detectable by analyzing which miner produced the round transition
- Could be dismissed as expected behavior if not carefully monitored

**Probability:** High - Any miner can exploit this during every round. With ~17 miners, each round presents multiple opportunities for unauthorized round termination.

### Recommendation

**Add Extra Block Producer Authorization Check in Validation:**

In `AEDPoSContract_Validation.cs`, add a new validation provider for NextRound/NextTerm behaviors:

```csharp
case AElfConsensusBehaviour.NextRound:
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new ExtraBlockProducerAuthorizationValidationProvider());
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

**Create ExtraBlockProducerAuthorizationValidationProvider:**

```csharp
public class ExtraBlockProducerAuthorizationValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        if (validationContext.ExtraData.Behaviour != AElfConsensusBehaviour.NextRound &&
            validationContext.ExtraData.Behaviour != AElfConsensusBehaviour.NextTerm)
            return new ValidationResult { Success = true };

        var extraBlockProducer = validationContext.BaseRound.RealTimeMinersInformation
            .FirstOrDefault(m => m.Value.IsExtraBlockProducer).Key;

        if (extraBlockProducer != validationContext.SenderPubkey)
            return new ValidationResult 
            { 
                Message = $"Only extra block producer can terminate rounds. " +
                         $"Expected: {extraBlockProducer}, Got: {validationContext.SenderPubkey}" 
            };

        return new ValidationResult { Success = true };
    }
}
```

**Additional Check in ConsensusBehaviourProvider:**

In `ConsensusBehaviourProviderBase.GetConsensusBehaviour()`, before returning termination behavior, verify extra block producer status:

```csharp
private AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
{
    var extraBlockProducer = CurrentRound.RealTimeMinersInformation
        .FirstOrDefault(m => m.Value.IsExtraBlockProducer).Key;
    
    if (_pubkey != extraBlockProducer)
        return AElfConsensusBehaviour.Nothing;
        
    return GetConsensusBehaviourToTerminateCurrentRoundInternal();
}
```

**Test Cases:**
1. Non-extra-block-producer attempts to call `GetConsensusCommand` after time slot → should receive `Nothing` behavior
2. Non-extra-block-producer attempts to produce NextRound block → validation should fail
3. Extra block producer produces NextRound block at correct time → should succeed
4. Extra block producer produces NextRound block too early → should fail time slot validation

### Proof of Concept

**Initial State:**
- 5 active miners in current round (Round N)
- Miner A: order 1, IsExtraBlockProducer = true
- Miner B: order 2, IsExtraBlockProducer = false
- Miner C: order 3, IsExtraBlockProducer = false
- Current round has progressed, Miner B has completed their time slot
- Current block time: past Miner B's time slot

**Attack Steps:**

1. **Miner B calls GetConsensusCommand:**
   - Input: Miner B's public key
   - `IsInMinerList` check passes (Miner B is in list)
   - `ConsensusBehaviourProvider.GetConsensusBehaviour()` executes
   - Miner B's OutValue exists (already mined), time slot passed
   - Returns `GetConsensusBehaviourToTerminateCurrentRound()` 
   - Returns `AElfConsensusBehaviour.NextRound`
   - **Result:** Miner B receives TerminateRoundCommandStrategy

2. **Miner B waits for arranged mining time:**
   - `ArrangeAbnormalMiningTime` calculates: futureRoundStartTime + (2 * miningInterval)
   - Miner B waits until this timestamp

3. **Miner B produces NextRound block:**
   - Block contains NextRound transaction with next round information
   - Extra data: `Behaviour = NextRound`, `SenderPubkey = MinerB`

4. **Block validation executes:**
   - `MiningPermissionValidationProvider`: Checks Miner B in miner list → PASS
   - `TimeSlotValidationProvider`: New round (different RoundId) → calls `CheckRoundTimeSlots` → PASS (structural only)
   - `NextRoundMiningOrderValidationProvider`: Validates FinalOrderOfNextRound consistency → PASS
   - `RoundTerminateValidationProvider`: Validates round number increment → PASS
   - **No check that Miner B is the extra block producer**

5. **NextRound transaction executes:**
   - `PreCheck()`: Verifies Miner B in miner list → PASS
   - `ProcessNextRound()` executes
   - State updated to Round N+1
   - **Result:** Round terminated by Miner B, not Miner A (the extra block producer)

**Expected vs Actual:**
- **Expected:** Only Miner A (extra block producer) can terminate Round N
- **Actual:** Miner B (regular miner) successfully terminates Round N, bypassing Miner A's privilege

**Success Condition:** Miner B's NextRound block is accepted and Round N+1 begins without Miner A producing the extra block.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-82)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L39-44)
```csharp
            case AElfConsensusBehaviour.NextRound:
            case AElfConsensusBehaviour.NextTerm:
                return new ConsensusCommandProvider(
                        new TerminateRoundCommandStrategy(currentRound, pubkey, currentBlockTime,
                            behaviour == AElfConsensusBehaviour.NextTerm))
                    .GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L26-36)
```csharp
        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }

        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-57)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-91)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```
