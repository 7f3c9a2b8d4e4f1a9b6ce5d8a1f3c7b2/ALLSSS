### Title
Malicious Miner Can Set Duplicate Mining Orders via TuneOrderInformation, Breaking Next Round Generation

### Summary
A malicious miner can exploit the lack of validation on the `TuneOrderInformation` field in `UpdateValueInput` to set all miners' `FinalOrderOfNextRound` to the same value. When the next round is generated, this causes multiple miners to be assigned identical `Order` values, breaking the consensus mechanism's fundamental assumption of unique mining orders and potentially halting consensus or causing chain forks.

### Finding Description

**Root Cause:**
The consensus contract allows miners to tune other miners' `FinalOrderOfNextRound` values via the `TuneOrderInformation` dictionary without validating that the tuned orders are unique or legitimate. [1](#0-0) 

**Attack Execution Path:**

1. **Entry Point**: A malicious miner produces a block and calls the `UpdateValue` method with a crafted `UpdateValueInput`.

2. **Malicious Payload**: The attacker includes a `TuneOrderInformation` dictionary mapping all other miners' public keys to the same order value (e.g., 1).

3. **Validation Bypass**: The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`, but does NOT validate the contents of `TuneOrderInformation`. [2](#0-1) 

4. **State Corruption**: During execution, `ProcessUpdateValue` applies the malicious tune orders to all specified miners, setting their `FinalOrderOfNextRound` to the attacker's chosen value. [3](#0-2) 

5. **Round Generation Failure**: When `GenerateNextRoundInformation` is called for the next round, it directly assigns each miner's `FinalOrderOfNextRound` as their `Order` in the next round, resulting in multiple miners having identical orders. [4](#0-3) 

6. **No Detection During NextRound Validation**: The `NextRoundMiningOrderValidationProvider` uses `.Distinct()` on `MinerInRound` objects (not on order values), which counts distinct miner objects rather than distinct order values, failing to detect duplicate orders. [5](#0-4) 

**Why Protections Fail:**
- No validation logic checks whether `TuneOrderInformation` values are unique across miners
- `NextRoundMiningOrderValidationProvider` validates count correctness but not uniqueness of order values
- `GenerateNextRoundInformation` blindly uses `FinalOrderOfNextRound` without verifying uniqueness
- No validation enforces that miners in the next round must have distinct `Order` values

### Impact Explanation

**Consensus Disruption:**
When multiple miners have identical `Order` values in a round:
- All miners with `Order = 1` have the same `ExpectedMiningTime` (calculated as `currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order))`)
- Multiple miners attempt to produce blocks simultaneously
- Time slot validation becomes non-deterministic
- The consensus mechanism's core invariant of sequential, unique mining orders is violated

**Severity: HIGH**
- Complete disruption of the consensus mechanism
- Potential chain halt if no clear block producer can be determined
- Chain fork risk if different nodes accept different blocks from miners with the same order
- Affects the entire blockchain network, not just individual miners

**Who Is Affected:**
- All network participants relying on consensus
- All miners unable to produce valid blocks
- All transactions pending inclusion in blocks

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an active miner (block producer) in the current round
- Requires no special privileges beyond normal miner status
- Does not require compromising other nodes or contracts

**Attack Complexity: LOW**
1. Attacker generates a legitimate block during their time slot
2. Crafts `UpdateValueInput` with malicious `TuneOrderInformation`:
   ```
   TuneOrderInformation = {
     "miner_B_pubkey": 1,
     "miner_C_pubkey": 1,
     "miner_D_pubkey": 1,
     ...all other miners: 1
   }
   ```
3. Includes this in their consensus transaction
4. Block passes all validation and is accepted

**Feasibility: HIGH**
- Attack is deterministic and requires no timing dependencies
- Can be executed in any round when the attacker has mining rights
- No external resources or complex setup required
- Impact is immediate upon next round generation

**Detection Constraints:**
- Attack is not detectable until next round generation attempts
- No warning signs in current round state
- By the time the issue is detected, state is already corrupted

### Recommendation

**Immediate Fix:**
Add validation in `ProcessUpdateValue` to ensure `TuneOrderInformation` maintains order uniqueness:

```csharp
// In ProcessUpdateValue, after line 258:
var allFinalOrders = new HashSet<int>();
foreach (var miner in currentRound.RealTimeMinersInformation.Values)
{
    if (miner.FinalOrderOfNextRound > 0)
        Assert(allFinalOrders.Add(miner.FinalOrderOfNextRound), 
               "Duplicate FinalOrderOfNextRound detected after tuning");
}
```

**Enhanced Validation:**
1. Add a new validation provider `UniqueOrderValidationProvider` for `UpdateValue` behavior that:
   - Verifies all miners with `FinalOrderOfNextRound > 0` have distinct values
   - Validates tuned orders fall within valid range `[1, minersCount]`
   - Ensures no order gaps or duplicates

2. Strengthen `NextRoundMiningOrderValidationProvider` to explicitly check for unique orders:
   ```csharp
   var orders = providedRound.RealTimeMinersInformation.Values
       .Select(m => m.FinalOrderOfNextRound)
       .Where(o => o > 0)
       .ToList();
   Assert(orders.Count == orders.Distinct().Count(), "Duplicate orders detected");
   ```

**Invariant Enforcement:**
Add an assertion in `GenerateNextRoundInformation` before assigning orders:
```csharp
// Before line 26:
var finalOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
Assert(finalOrders.Count == finalOrders.Distinct().Count(), 
       "Cannot generate next round: duplicate FinalOrderOfNextRound values");
```

### Proof of Concept

**Initial State:**
- 7 miners active in round N: A (attacker), B, C, D, E, F, G
- Each miner has unique `FinalOrderOfNextRound` (1-7 based on their signatures)
- Attacker A has mining rights and produces a block

**Attack Steps:**

1. **Attacker produces UpdateValue block:**
   - Sets own `SupposedOrderOfNextRound = 1`
   - Sets `TuneOrderInformation = {B: 1, C: 1, D: 1, E: 1, F: 1, G: 1}`

2. **Validation passes:**
   - `UpdateValueValidationProvider` checks only `OutValue`, `Signature`, `PreviousInValue`
   - No validator examines `TuneOrderInformation` contents
   - Block is accepted

3. **Execution updates state:**
   - All miners now have `FinalOrderOfNextRound = 1` in round N state

4. **Next round generation is triggered:**
   - Miner G (extra block producer) calls `NextRound`
   - `GenerateNextRoundInformation` executes
   - All 7 miners are assigned `Order = 1` in round N+1

5. **Result - Consensus broken:**
   - Round N+1 has 7 miners all with `Order = 1`
   - All have `ExpectedMiningTime = roundStartTime + miningInterval * 1`
   - When this time arrives, all miners attempt to produce blocks
   - Non-deterministic block selection or consensus halt

**Success Condition:**
Round N+1 state contains multiple miners with identical `Order` values, violating the fundamental consensus invariant that each miner must have a unique order determining their time slot.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L14-21)
```csharp
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```
