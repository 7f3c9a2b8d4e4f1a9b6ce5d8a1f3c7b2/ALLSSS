### Title
Immutable Candidate Deposit Lock Creates Permanent Economic DOS Risk

### Summary
The `LockTokenForElection` constant is hardcoded at deployment time with no governance mechanism to adjust it post-deployment. If set incorrectly or if economic conditions change (token price volatility, network scale), it creates either a permanent barrier preventing legitimate candidates from participating or allows spam candidate flooding, both resulting in DOS of the election system with no ability to respond without a full contract upgrade.

### Finding Description

The `LockTokenForElection` constant is defined as a compile-time constant in the Election contract: [1](#0-0) 

This value is used to lock tokens when candidates announce their election candidacy: [2](#0-1) 

And unlock the same amount when candidates quit: [3](#0-2) 

**Root Cause**: The value is a `const` rather than a state variable stored in the contract state. [4](#0-3)  Unlike other configurable Election contract parameters such as `MinimumLockTime`, `MaximumLockTime`, and vote weight settings which are stored in state and can be updated through governance methods [5](#0-4) , there is no corresponding state variable or update method for the candidate lock amount.

**Why Protections Fail**: The contract interface provides no method to update this value. [6](#0-5)  Methods exist to update vote weight settings, miners count, and treasury schemes, but no method exists to adjust the candidate deposit amount. The only way to change this value is through a full contract upgrade via the Genesis Contract's `UpdateSmartContract` method, which requires Parliament governance approval and complete contract redeployment.

### Impact Explanation

**Scenario 1 - Barrier Too High (DOS legitimate candidates)**:
- If token price increases significantly post-deployment (e.g., 10x-100x), the 100,000 ELF deposit becomes economically prohibitive
- Legitimate candidates cannot afford to announce election, reducing decentralization
- Current miners become entrenched with no new competition
- Election system becomes effectively non-functional

**Scenario 2 - Barrier Too Low (DOS via candidate flooding)**:
- If token price crashes or value was set too low initially
- Malicious actors can spam candidate announcements with minimal cost
- Each candidate registration consumes storage, voting options capacity, and computational resources
- Data center ranking list and profit scheme registrations become bloated [7](#0-6) 
- Legitimate voting becomes impractical due to excessive candidate options
- Consensus and profit distribution systems degraded by noise candidates

**Who is affected**: All network participants - legitimate candidates unable to participate, voters facing degraded UX, current miners facing governance attacks, and overall network decentralization compromised.

**Severity Justification**: High severity because this affects core governance and consensus mechanisms with no rapid remediation path. Unlike other DOS vulnerabilities that can be mitigated quickly, this requires full contract upgrade which could take weeks through governance process while DOS condition persists.

### Likelihood Explanation

**Feasibility**: Highly feasible because:
1. The value is permanently set at deployment - no attacker action needed if misconfigured
2. Token price volatility is common in crypto markets (10x-100x swings documented across ecosystems)
3. Network economic conditions naturally evolve (different scale at launch vs maturity)

**Attack Complexity**: 
- **Initial misconfiguration**: No attack needed - deployment team simply sets wrong value based on incorrect economic assumptions
- **Economic drift**: Natural market forces (no attacker needed) - token price changes over time making initially-correct value become incorrect

**Preconditions**: 
- For "too high" scenario: Token price increases OR initial value set too high
- For "too low" scenario: Token price decreases OR initial value set too low
- Both scenarios require only public method access (`AnnounceElection`) [8](#0-7) 

**Detection/Operational Constraints**: 
- Issue may not be apparent at deployment but emerge over time
- Once discovered, remediation requires:
  - Parliament proposal creation and approval
  - Full contract code update and redeployment  
  - Multi-week governance timeline
  - During this period, DOS condition actively harms network

**Probability**: Medium-to-High. While the exact value (100,000 ELF) may be reasonable at current conditions, cryptocurrency markets are volatile and the immutability creates permanent risk exposure.

### Recommendation

**Code-Level Mitigation**:

1. Convert `LockTokenForElection` from a constant to a state variable:
```csharp
// In ElectionContractState.cs
public Int64State LockTokenForElection { get; set; }
```

2. Initialize it during `InitialElectionContract`:
```csharp
// In ElectionContract_Maintainence.cs - InitialElectionContract method
State.LockTokenForElection.Value = input.LockTokenForElection;
```

3. Add governance-controlled update method to the proto:
```protobuf
// In election_contract.proto
rpc SetCandidateLockAmount (google.protobuf.Int64Value) returns (google.protobuf.Empty) {}
```

4. Implement the update method with proper authorization:
```csharp
public override Empty SetCandidateLockAmount(Int64Value input)
{
    Assert(input.Value > 0, "Lock amount must be positive.");
    Assert(Context.Sender == GetParliamentDefaultAddress() || 
           Context.Sender == GetVoteWeightInterestController(), 
           "No permission to update candidate lock amount.");
    State.LockTokenForElection.Value = input.Value;
    return new Empty();
}
```

5. Update `LockCandidateNativeToken()` and `QuitElection()` to read from state instead of constant.

**Invariant Checks**:
- Lock amount must be > 0
- Lock amount changes must be logged via events
- Consider adding min/max bounds (e.g., 1,000 to 1,000,000 ELF) to prevent extreme misconfiguration

**Test Cases**:
- Test governance update of lock amount via Parliament proposal
- Test that AnnounceElection correctly uses updated value
- Test that QuitElection returns correct amount after value update (historical locks should still return original lock amounts)
- Test boundary conditions (minimum/maximum acceptable values)
- Test unauthorized update attempts are rejected

### Proof of Concept

**Required Initial State**:
- Election contract deployed with `LockTokenForElection = 100_000_00000000` (100,000 ELF)
- Initial ELF token price: $1 USD
- Candidate has 150,000 ELF balance

**Scenario 1 - Barrier Too High (after token price increase)**:

1. Time passes, ELF price increases to $100 USD
2. Lock amount remains 100,000 ELF = $10,000,000 USD
3. Legitimate candidate attempts to announce election:
   - Calls `AnnounceElection` [8](#0-7) 
   - Requires locking 100,000 ELF ($10M USD)
   - Most legitimate candidates cannot afford this barrier
4. **Expected**: Candidate can participate with reasonable deposit
5. **Actual**: DOS - legitimate candidates economically excluded from election system
6. **Success Condition**: No new candidates can afford to participate, election system becomes non-functional for new entrants

**Scenario 2 - Barrier Too Low (after token price decrease)**:

1. Time passes, ELF price decreases to $0.01 USD  
2. Lock amount remains 100,000 ELF = $1,000 USD
3. Attacker with modest funds announces 1,000 spam candidates:
   - Each `AnnounceElection` call locks only 100,000 ELF ($1,000)
   - Total cost: $1,000,000 USD for 1,000 candidates
   - Each candidate added to voting options, data center list, profit schemes [7](#0-6) 
4. **Expected**: Spam candidates prevented by adequate economic barrier
5. **Actual**: DOS via resource exhaustion - voting UI becomes unusable, storage bloated, legitimate governance degraded
6. **Success Condition**: Election system flooded with spam candidates, making legitimate participation impractical

**Current Remediation Path**:
- Parliament must propose contract upgrade
- Governance approval required (potentially weeks)
- Full contract redeployment needed
- **During this entire period, DOS condition persists**

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L239-249)
```csharp
        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L1-101)
```csharp
using AElf.Sdk.CSharp.State;
using AElf.Standards.ACS1;
using AElf.Types;

namespace AElf.Contracts.Election;

public partial class ElectionContractState : ContractState
{
    public BoolState Initialized { get; set; }
    public BoolState VotingEventRegistered { get; set; }

    public SingletonState<Hash> TreasuryHash { get; set; }
    public SingletonState<Hash> WelfareHash { get; set; }
    public SingletonState<Hash> SubsidyHash { get; set; }
    public SingletonState<Hash> FlexibleHash { get; set; }
    public SingletonState<Hash> WelcomeHash { get; set; }

    // Old:Pubkey/New:Address -> ElectorVote
    public MappedState<string, ElectorVote> ElectorVotes { get; set; }

    public MappedState<string, CandidateVote> CandidateVotes { get; set; }

    public MappedState<string, CandidateInformation> CandidateInformationMap { get; set; }

    public Int64State CurrentTermNumber { get; set; }

    public SingletonState<PubkeyList> Candidates { get; set; }

    public SingletonState<DataCenterRankingList> DataCentersRankingList { get; set; }

    public SingletonState<PubkeyList> InitialMiners { get; set; }

    public MappedState<string, bool> BannedPubkeyMap { get; set; }

    /// <summary>
    ///     Vote Id -> Lock Time (seconds)
    /// </summary>
    public MappedState<Hash, long> LockTimeMap { get; set; }

    public MappedState<long, TermSnapshot> Snapshots { get; set; }

    public Int32State MinersCount { get; set; }

    /// <summary>
    ///     Time unit: seconds
    /// </summary>
    public Int64State MinimumLockTime { get; set; }

    /// <summary>
    ///     Time unit: seconds
    /// </summary>
    public Int64State MaximumLockTime { get; set; }

    public Int64State TimeEachTerm { get; set; }

    public SingletonState<Hash> MinerElectionVotingItemId { get; set; }

    public MappedState<string, MethodFees> TransactionFees { get; set; }
    public SingletonState<VoteWeightInterestList> VoteWeightInterestList { get; set; }
    public SingletonState<VoteWeightProportion> VoteWeightProportion { get; set; }
    public SingletonState<AuthorityInfo> VoteWeightInterestController { get; set; }

    public SingletonState<AuthorityInfo> MethodFeeController { get; set; }

    /// <summary>
    ///     Pubkey -> Address who has the authority to replace it.
    /// </summary>
    public MappedState<string, Address> CandidateAdmins { get; set; }

    /// <summary>
    ///     Admin address -> Pubkey
    /// </summary>
    public MappedState<Address, PubkeyList> ManagedCandidatePubkeysMap { get; set; }

    /// <summary>
    ///     Pubkey -> Newest pubkey
    /// </summary>
    public MappedState<string, string> CandidateReplacementMap { get; set; }

    /// <summary>
    ///     Pubkey -> Initial pubkey (First round initial miner pubkey or first announce election pubkey)
    /// </summary>
    public MappedState<string, string> InitialPubkeyMap { get; set; }

    /// <summary>
    ///     Initial pubkey -> Newest pubkey
    /// </summary>
    public MappedState<string, string> InitialToNewestPubkeyMap { get; set; }

    public SingletonState<Address> EmergencyResponseOrganizationAddress { get; set; }

    /// <summary>
    ///     Pubkey -> Sponsor address (who will pay announce election fee for this pubkey)
    /// </summary>
    public MappedState<string, Address> CandidateSponsorMap { get; set; }

    public BoolState ElectionEnabled { get; set; }

    public MappedState<Hash, bool> WeightsAlreadyFixedMap { get; set; }
    
}
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L22-52)
```csharp
    public override Empty InitialElectionContract(InitialElectionContractInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");

        State.Candidates.Value = new PubkeyList();

        State.MinimumLockTime.Value = input.MinimumLockTime;
        State.MaximumLockTime.Value = input.MaximumLockTime;

        State.TimeEachTerm.Value = input.TimeEachTerm;

        State.MinersCount.Value = input.MinerList.Count;
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
        foreach (var pubkey in input.MinerList)
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey
            };

        State.CurrentTermNumber.Value = 1;

        State.DataCentersRankingList.Value = new DataCenterRankingList();

        State.Initialized.Value = true;

        return new Empty();
    }
```

**File:** protobuf/election_contract.proto (L17-245)
```text
service ElectionContract {
    
    option (aelf.csharp_state) = "AElf.Contracts.Election.ElectionContractState";

    // Initialize the election contract.
    rpc InitialElectionContract (InitialElectionContractInput) returns (google.protobuf.Empty) {
    }
    
    // Register a new voting item through vote contract.
    rpc RegisterElectionVotingEvent (google.protobuf.Empty) returns (google.protobuf.Empty) {
    }
    
    // Take snapshot according to term number, and distribute profits.
    rpc TakeSnapshot (TakeElectionSnapshotInput) returns (google.protobuf.Empty) {
    }

    // To be a block producer, a user should first register to be a candidate and lock some token as a deposit. 
    // If the data center is not full, the user will be added in automatically and get one weight 
    // for sharing bonus in the future.
    rpc AnnounceElection (aelf.Address) returns (google.protobuf.Empty) {
    }
    rpc AnnounceElectionFor (AnnounceElectionForInput) returns (google.protobuf.Empty) {
    }

    // A candidate is able to quit the election provided he is not currently elected. If you quit successfully, 
    // the candidate will get his locked tokens back and will not receive anymore bonus.
    rpc QuitElection (google.protobuf.StringValue) returns (google.protobuf.Empty) {
    }
    
    // Used for voting for a candidate to be elected. The tokens you vote with will be locked until the end time. 
    // According to the number of token you voted and its lock time, you can get corresponding weight for 
    // sharing the bonus in the future. And return the vote id.
    rpc Vote (VoteMinerInput) returns (aelf.Hash) {
    }

    // Before the end time, you are able to change your vote target to other candidates.
    rpc ChangeVotingOption (ChangeVotingOptionInput) returns (google.protobuf.Empty) {
    }

    // After the lock time, your locked tokens will be unlocked and you can withdraw them according to the vote id.
    rpc Withdraw (aelf.Hash) returns (google.protobuf.Empty) {
    }

    // Update candidate information by consensus contract.
    rpc UpdateCandidateInformation (UpdateCandidateInformationInput) returns (google.protobuf.Empty) {
    }

    // Batch update candidate information by consensus contract.
    rpc UpdateMultipleCandidateInformation (UpdateMultipleCandidateInformationInput) returns (google.protobuf.Empty) {
    }

    // Update the count of miner by consensus contract.
    rpc UpdateMinersCount (UpdateMinersCountInput) returns (google.protobuf.Empty) {
    }

    // Set the treasury profit ids.
    rpc SetTreasurySchemeIds (SetTreasurySchemeIdsInput) returns (google.protobuf.Empty) {
    }
    
    // Set the weight of vote interest.
    rpc SetVoteWeightInterest (VoteWeightInterestList) returns (google.protobuf.Empty) {
    }
    
    // Set the weight of lock time and votes in the calculation of voting weight.
    rpc SetVoteWeightProportion (VoteWeightProportion) returns (google.protobuf.Empty) {
    }
    
    // Change the controller for the weight of vote interest.
    rpc ChangeVoteWeightInterestController (AuthorityInfo) returns (google.protobuf.Empty) {
    }
    
    // Candidate admin can replace candidate pubkey with a new pubkey.
    rpc ReplaceCandidatePubkey (ReplaceCandidatePubkeyInput) returns (google.protobuf.Empty) {
    }
    
    // Set admin address of candidate (mostly supply)
    rpc SetCandidateAdmin (SetCandidateAdminInput) returns (google.protobuf.Empty) {
    }
    
    rpc RemoveEvilNode (google.protobuf.StringValue) returns (google.protobuf.Empty) {
    }
    
    rpc EnableElection (google.protobuf.Empty) returns (google.protobuf.Empty) {
    }
    
    rpc SetProfitsReceiver (SetProfitsReceiverInput) returns (google.protobuf.Empty) {
    }

    // Views
    
    // Get all candidates’ public keys.
    rpc GetCandidates (google.protobuf.Empty) returns (PubkeyList) {
        option (aelf.is_view) = true;
    }
    
    // Get all candidates whose number of votes is greater than 0.
    rpc GetVotedCandidates (google.protobuf.Empty) returns (PubkeyList) {
        option (aelf.is_view) = true;
    }
    
    // Get a candidate’s information. 
    rpc GetCandidateInformation (google.protobuf.StringValue) returns (CandidateInformation) {
        option (aelf.is_view) = true;
    }
    
    // Get the victories of the latest term.
    rpc GetVictories (google.protobuf.Empty) returns (PubkeyList) {
        option (aelf.is_view) = true;
    }
    
    // Get the snapshot of term according to term number.
    rpc GetTermSnapshot (GetTermSnapshotInput) returns (TermSnapshot) {
        option (aelf.is_view) = true;
    }
    
    // Get the count of miner.
    rpc GetMinersCount (google.protobuf.Empty) returns (google.protobuf.Int32Value) {
        option (aelf.is_view) = true;
    }
    
    // Get the election result according to term id.
    rpc GetElectionResult (GetElectionResultInput) returns (ElectionResult) {
        option (aelf.is_view) = true;
    }
    
    // Get the voter information according to voter public key.
    rpc GetElectorVote (google.protobuf.StringValue) returns (ElectorVote) {
        option (aelf.is_view) = true;
    }
    
    // Gets the voter information including the active voting records (excluding withdrawn voting records.).
    rpc GetElectorVoteWithRecords (google.protobuf.StringValue) returns (ElectorVote) {
        option (aelf.is_view) = true;
    }
    
    // Gets the voter information including the active and withdrawn voting records.
    rpc GetElectorVoteWithAllRecords (google.protobuf.StringValue) returns (ElectorVote) {
        option (aelf.is_view) = true;
    }
    
    // Get voting information for candidate according to the public key of the candidate.
    rpc GetCandidateVote (google.protobuf.StringValue) returns (CandidateVote) {
        option (aelf.is_view) = true;
    }

    // Get voting information for candidate according to the public key of the candidate.
    rpc GetCandidateVoteWithRecords (google.protobuf.StringValue) returns (CandidateVote) {
        option (aelf.is_view) = true;
    }

    // Get voting information for candidate according to the public key of the candidate 
    // (including the active and withdrawn voting records).
    rpc GetCandidateVoteWithAllRecords (google.protobuf.StringValue) returns (CandidateVote) {
        option (aelf.is_view) = true;
    }
    
    // Get the total number of voters.
    rpc GetVotersCount (google.protobuf.Empty) returns (google.protobuf.Int64Value) {
        option (aelf.is_view) = true;
    }
    
    // Get the total number of vote token.
    rpc GetVotesAmount (google.protobuf.Empty) returns (google.protobuf.Int64Value) {
        option (aelf.is_view) = true;
    }
    
    // Get candidate information according to the index and length.
    rpc GetPageableCandidateInformation (PageInformation) returns (GetPageableCandidateInformationOutput) {
        option (aelf.is_view) = true;
    }
    
    // Get the voting item id of miner election.
    rpc GetMinerElectionVotingItemId (google.protobuf.Empty) returns (aelf.Hash) {
        option (aelf.is_view) = true;
    }
    
    // Get the data center ranking list.
    rpc GetDataCenterRankingList (google.protobuf.Empty) returns (DataCenterRankingList) {
        option (aelf.is_view) = true;
    }
    
    // Get the weight of vote interest.
    rpc GetVoteWeightSetting (google.protobuf.Empty) returns (VoteWeightInterestList) {
        option (aelf.is_view) = true;
    }
    
    // Get the weight of lock time and votes in the calculation of voting weight.
    rpc GetVoteWeightProportion (google.protobuf.Empty) returns (VoteWeightProportion) {
        option (aelf.is_view) = true;
    }
    
    // Used to calculate the bonus weights that users can get by voting.
    rpc GetCalculateVoteWeight (VoteInformation) returns (google.protobuf.Int64Value){
        option (aelf.is_view) = true;
    }
    
    // Query the controller for the weight of vote interest.
    rpc GetVoteWeightInterestController (google.protobuf.Empty) returns (AuthorityInfo) {
        option (aelf.is_view) = true;
    }
    
    // Inspect the evil nodes included in the specified miners and return to the replacement node.
    rpc GetMinerReplacementInformation (GetMinerReplacementInformationInput) returns (MinerReplacementInformation) {
        option (aelf.is_view) = true;
    }
    
    // Query candidate admin.
    rpc GetCandidateAdmin (google.protobuf.StringValue) returns (aelf.Address) {
        option (aelf.is_view) = true;
    }
    
    // Query the newest pubkey of an old pubkey.
    rpc GetNewestPubkey (google.protobuf.StringValue) returns (google.protobuf.StringValue) {
        option (aelf.is_view) = true;
    }
    
    // Query the old pubkey.
    rpc GetReplacedPubkey (google.protobuf.StringValue) returns (google.protobuf.StringValue) {
        option (aelf.is_view) = true;
    }

    rpc GetSponsor (google.protobuf.StringValue) returns (aelf.Address) {
        option (aelf.is_view) = true;
    }
    
    rpc GetManagedPubkeys (aelf.Address) returns (PubkeyList) {
        option (aelf.is_view) = true;
    }
}
```
