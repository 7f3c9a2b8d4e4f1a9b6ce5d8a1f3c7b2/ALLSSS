### Title
State Corruption in TokenHolder Scheme Updates via Cross-Scheme Operations

### Summary
The `UpdateTokenHolderProfitScheme` function writes scheme data to `Context.Sender`'s address instead of the scheme `manager`'s address, causing state corruption when users interact with schemes managed by others. When a user who is also a scheme manager calls `ClaimProfits` (or other cross-scheme operations) on an uninitialized scheme, their own scheme data gets overwritten, breaking withdrawals for users registered to their scheme. [1](#0-0) 

### Finding Description

The root cause is at line 298 in `UpdateTokenHolderProfitScheme`, which writes scheme data to the wrong address: [2](#0-1) 

This function is called by `GetValidScheme` which is invoked from multiple public methods including `ClaimProfits` (line 249), `RegisterForProfits` (line 152), `ContributeProfits` (line 102), and `Withdraw` (line 213). [3](#0-2) 

The execution path:
1. User Bob (who manages scheme B) calls `ClaimProfits` with `SchemeManager = Alice`
2. `GetValidScheme(Alice)` loads Alice's scheme from `State.TokenHolderProfitSchemes[Alice]`
3. If Alice's scheme has `SchemeId == null` (uninitialized), `UpdateTokenHolderProfitScheme` executes
4. Line 298 writes Alice's scheme data to `State.TokenHolderProfitSchemes[Bob]`, overwriting Bob's scheme
5. Users registered to Bob's scheme now reference corrupted scheme data

Test evidence confirms schemes have `SchemeId == null` immediately after creation: [4](#0-3) 

The scheme structure is stored in a mapping keyed by manager address: [5](#0-4) 

### Impact Explanation

**Concrete Harm:**
When Bob's scheme is corrupted with Alice's scheme data, the `Symbol` and `MinimumLockMinutes` fields change. Users who registered to Bob's scheme (e.g., locked "USDT" tokens) will fail to withdraw because: [6](#0-5) 

The `Withdraw` function uses the corrupted scheme's `Symbol` (now Alice's token instead of Bob's) and `MinimumLockMinutes` (now Alice's duration instead of Bob's), causing:
- Token unlock to fail with wrong symbol
- Incorrect lock time validation
- Permanent DoS of withdrawals for affected users

**Affected Parties:**
- Users who locked tokens in Bob's scheme lose access to their funds
- Bob's scheme becomes unusable
- Any scheme manager who interacts with uninitialized schemes risks corruption

**Severity:** Medium to High - causes operational DoS and effective fund lockup, though not direct theft.

### Likelihood Explanation

**Attacker Capabilities:** No special privileges required. Any user can trigger the bug by:
1. Creating their own scheme (becoming a manager)
2. Interacting with another scheme via `ClaimProfits`, `RegisterForProfits`, `ContributeProfits`, or `Withdraw`

**Attack Complexity:** Low
- Normal transaction sequence
- No timing requirements beyond the target scheme being uninitialized
- No economic cost beyond transaction fees

**Feasibility Conditions:**
- Target scheme must have `SchemeId == null` (window exists after `CreateScheme` until first state-updating operation)
- Attacker must be a scheme manager themselves
- Multiple entry points: `ClaimProfits`, `RegisterForProfits`, `ContributeProfits`, `Withdraw`

**Probability:** Medium - While schemes typically get initialized quickly, the vulnerability window exists and the operation sequence is natural (managers participating in multiple schemes). The `DistributeProfits` function with `updateSchemePeriod=true` provides another attack vector. [7](#0-6) 

### Recommendation

**Fix:** Change line 298 to write to the `manager` parameter address instead of `Context.Sender`:

```csharp
State.TokenHolderProfitSchemes[manager] = scheme;
```

**Additional Safeguards:**
1. Add validation to ensure scheme updates only occur when `manager == Context.Sender` for critical operations
2. Initialize `SchemeId` during `CreateScheme` by immediately querying the Profit contract
3. Add explicit ownership checks before scheme state modifications

**Test Cases:**
1. Verify scheme manager creates scheme A, user who manages scheme B claims from A, and B's scheme remains unchanged
2. Test all cross-scheme operations (`ClaimProfits`, `RegisterForProfits`, `ContributeProfits`, `Withdraw`) with multi-manager scenarios
3. Verify withdrawals work correctly for users in schemes after cross-scheme interactions

### Proof of Concept

**Initial State:**
1. Alice creates TokenHolder scheme A: `CreateScheme({Symbol: "ELF", MinimumLockMinutes: 100})`
   - Scheme stored at `State.TokenHolderProfitSchemes[Alice]` with `SchemeId = null`
2. Bob creates TokenHolder scheme B: `CreateScheme({Symbol: "USDT", MinimumLockMinutes: 200})`
3. Bob performs operation on his scheme (e.g., `AddBeneficiary`) to initialize `SchemeId`
4. Charlie registers to Bob's scheme, locking 1000 USDT tokens
5. Alice adds Bob as beneficiary to scheme A

**Exploit Steps:**
1. Bob calls `ClaimProfits({SchemeManager: Alice, Beneficiary: Bob})`
2. Line 249: `GetValidScheme(Alice)` loads scheme from `State.TokenHolderProfitSchemes[Alice]`
3. Line 289: Since Alice's `SchemeId == null`, condition fails, proceeds to state update
4. Line 298: Writes to `State.TokenHolderProfitSchemes[Bob]` (Context.Sender)
5. Bob's scheme now has: `{Symbol: "ELF", MinimumLockMinutes: 100, SchemeId: Alice's SchemeId}`

**Result:**
- Expected: Bob's scheme remains `{Symbol: "USDT", MinimumLockMinutes: 200}`
- Actual: Bob's scheme becomes `{Symbol: "ELF", MinimumLockMinutes: 100}`
- Charlie's withdrawal of USDT fails because scheme references ELF token
- Funds effectively locked until manual scheme correction (if possible)

**Success Condition:** Query `GetScheme(Bob)` returns Alice's scheme data instead of Bob's original scheme data.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L131-147)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager, true);
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
        var distributeProfitsInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
        if (input.AmountsMap != null && input.AmountsMap.Any()) distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

        State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
        scheme.Period = scheme.Period.Add(1);
        State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-236)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L247-257)
```csharp
    public override Empty ClaimProfits(ClaimProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
        var beneficiary = input.Beneficiary ?? Context.Sender;
        State.ProfitContract.ClaimProfits.Send(new Profit.ClaimProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = beneficiary
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L42-46)
```csharp
            var tokenHolderProfitScheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
            tokenHolderProfitScheme.Period.ShouldBe(0);
            tokenHolderProfitScheme.Symbol.ShouldBe("APP");
            tokenHolderProfitScheme.SchemeId.ShouldBeNull();
        }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L10-10)
```csharp
    public MappedState<Address, TokenHolderProfitScheme> TokenHolderProfitSchemes { get; set; }
```
