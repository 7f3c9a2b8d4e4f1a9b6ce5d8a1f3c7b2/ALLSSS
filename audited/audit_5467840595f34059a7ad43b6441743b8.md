### Title
RemoveSubScheme Fails to Update CachedDelayTotalShares, Causing Profit Dilution in Delayed Distribution Schemes

### Summary
When `RemoveSubScheme` is called to remove a sub-scheme from a profit scheme with delayed distribution (`DelayDistributePeriodCount > 0`), it correctly reduces `TotalShares` but fails to update `CachedDelayTotalShares`, unlike `RemoveBeneficiary` which properly handles both. This accounting inconsistency causes future periods to use inflated share counts for profit distribution, diluting rewards for all legitimate beneficiaries.

### Finding Description
The `AddSubScheme` function adds sub-schemes as beneficiaries with `EndPeriod=long.MaxValue`, increasing both current `TotalShares` and caching this value for delayed distribution. [1](#0-0) 

When profits are distributed with delay enabled, the current `TotalShares` is cached for future periods. [2](#0-1) 

The `RemoveSubScheme` function removes sub-schemes and reduces `TotalShares`, but critically does NOT update `CachedDelayTotalShares`. [3](#0-2) 

In contrast, `RemoveBeneficiary` correctly updates both `TotalShares` AND iterates through all cached delay periods to subtract removed shares. [4](#0-3) 

This inconsistency means when a sub-scheme is removed, future delayed distributions continue using the old (higher) share count, causing all beneficiaries to receive less profit than they should.

### Impact Explanation
**Direct Fund Impact**: When a scheme with `DelayDistributePeriodCount = D` has a sub-scheme removed at period P, all cached periods from P to P+D retain the inflated share count. At those future periods, profits are distributed using incorrect denominators, causing **permanent loss of entitled profits** for all legitimate beneficiaries.

**Quantified Example**: If TotalShares is 1000, a sub-scheme with 500 shares is added then removed before delayed distribution occurs, the cached value remains 1500. Future distributions calculate shares as `amount * beneficiary_shares / 1500` instead of `amount * beneficiary_shares / 1000`, resulting in each beneficiary receiving only 66.7% of their entitled profit. The "missing" 33.3% remains locked in the virtual address indefinitely.

**Who is Affected**: All beneficiaries of schemes with delayed distribution where sub-schemes are added and removed. This includes critical system schemes like Treasury dividend distributions and TokenHolder rewards.

### Likelihood Explanation
**Attacker Capabilities**: This requires scheme manager privileges, which could be a governance contract, multi-sig, or individual address depending on scheme setup. No additional privileges beyond normal scheme management are needed.

**Attack Complexity**: Trivial - simply call `AddSubScheme` then `RemoveSubScheme` on any scheme with `DelayDistributePeriodCount > 0`. This is normal operational behavior that managers might perform legitimately when restructuring profit distribution.

**Feasibility**: The Treasury contract demonstrates real-world usage of `RemoveSubScheme` in `ResetWeight` and `UpdateWelcomeRewardWeights`. [5](#0-4)  Any scheme administrator performing routine weight adjustments on delayed-distribution schemes will trigger this bug.

**Detection**: The bug manifests as unexplained profit shortfalls in future periods - difficult to detect without comparing expected vs actual distributions. Operational likelihood is HIGH for schemes that regularly adjust sub-scheme weights.

### Recommendation
Modify `RemoveSubScheme` to update `CachedDelayTotalShares` consistent with `RemoveBeneficiary`:

```csharp
public override Empty RemoveSubScheme(RemoveSubSchemeInput input)
{
    // ... existing validation code ...
    
    var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
    
    // Add cached delay shares update logic
    if (scheme.DelayDistributePeriodCount > 0)
    {
        var removedStartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount);
        for (var period = removedStartPeriod; 
             period < removedStartPeriod.Add(scheme.DelayDistributePeriodCount); 
             period++)
        {
            if (scheme.CachedDelayTotalShares.ContainsKey(period))
            {
                scheme.CachedDelayTotalShares[period] = 
                    scheme.CachedDelayTotalShares[period].Sub(shares.Shares);
            }
        }
    }
    
    // Clear profit details
    State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
    scheme.SubSchemes.Remove(shares);
    scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
    State.SchemeInfos[input.SchemeId] = scheme;
    
    return new Empty();
}
```

**Test Cases**: Add regression tests validating `CachedDelayTotalShares` updates when removing sub-schemes from delayed-distribution schemes, similar to existing tests for `RemoveBeneficiary`. [6](#0-5) 

### Proof of Concept
1. **Setup**: Create scheme with `DelayDistributePeriodCount = 5`, initial `TotalShares = 1000`
2. **Period 1**: Call `DistributeProfits(period=1)` → caches `CachedDelayTotalShares[6] = 1000`
3. **Period 2**: Call `AddSubScheme(shares=500)` → `TotalShares = 1500`
4. **Period 2**: Call `DistributeProfits(period=2)` → caches `CachedDelayTotalShares[7] = 1500`
5. **Period 3**: Call `RemoveSubScheme` → `TotalShares = 1000`, but `CachedDelayTotalShares[7]` remains 1500
6. **Period 7**: Call `DistributeProfits(period=7)` → uses `totalShares = CachedDelayTotalShares[7] = 1500` instead of actual 1000
7. **Result**: All beneficiaries receive `1000/1500 = 66.7%` of entitled profits; 33.3% permanently locked

**Verification**: Query `GetDistributedProfitsInfo(period=7)` shows `TotalShares = 1500` despite actual scheme `TotalShares = 1000`, confirming stale cached value is used for distribution calculations.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L109-118)
```csharp
        AddBeneficiary(new AddBeneficiaryInput
        {
            SchemeId = input.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = subSchemeVirtualAddress,
                Shares = input.SubSchemeShares
            },
            EndPeriod = long.MaxValue
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L131-156)
```csharp
    public override Empty RemoveSubScheme(RemoveSubSchemeInput input)
    {
        Assert(input.SchemeId != input.SubSchemeId, "Two schemes cannot be same.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only manager can remove sub-scheme.");

        var shares = scheme.SubSchemes.SingleOrDefault(d => d.SchemeId == input.SubSchemeId);
        if (shares == null) return new Empty();

        var subSchemeId = input.SubSchemeId;
        var subScheme = State.SchemeInfos[subSchemeId];
        Assert(subScheme != null, "Sub scheme not found.");

        var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
        // Remove profit details
        State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
        scheme.SubSchemes.Remove(shares);
        scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L243-258)
```csharp
        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L528-532)
```csharp
            State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
            {
                SchemeId = parentSchemeId,
                SubSchemeId = subSchemeId
            });
```

**File:** test/AElf.Contracts.Profit.Tests/BVT/SchemeTests.cs (L268-273)
```csharp
            await ContributeAndDistribute(creator, contributeAmountEachTime, 8);
            await RemoveBeneficiaryAsync(creator, Accounts[11].Address);
            var scheme = await creator.GetScheme.CallAsync(_schemeId);
            scheme.CachedDelayTotalShares.Values.ShouldAllBe(v => v == 12);
            scheme.TotalShares.ShouldBe(12);
        }
```
