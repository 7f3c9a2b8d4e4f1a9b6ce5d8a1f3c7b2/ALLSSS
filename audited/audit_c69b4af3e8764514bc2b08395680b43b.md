# Audit Report

## Title
NFT Type Inconsistency via Unchecked CrossChainCreate Symbol Format

## Summary
The `NFTContract.CrossChainCreate` method extracts NFT type from the first 2 characters of a symbol without validating the symbol format or verifying consistency with the token's metadata. Since the `MultiToken` contract accepts arbitrary `ExternalInfo` during token creation without validating NFT-specific metadata keys, attackers can create tokens with mismatched type information that propagates into the NFT protocol registry.

## Finding Description

The vulnerability arises from the interaction between two separate validation gaps:

**Gap 1: MultiToken accepts arbitrary ExternalInfo**

The `CreateToken` method directly assigns user-provided `ExternalInfo` without validating NFT-specific metadata keys. [1](#0-0) 

The reserved keys list in the MultiToken contract excludes NFT-specific keys like `"aelf_nft_type"`, `"aelf_nft_base_uri"`, and `"aelf_nft_token_id_reuse"`. [2](#0-1) 

These NFT-specific constants are defined separately and not protected during `MultiToken.Create`. [3](#0-2) 

The protection via `AssertMetadataKeysAreCorrect` only applies within the NFT contract's `Create` method, not in `MultiToken.Create`. [4](#0-3) [5](#0-4) 

**Gap 2: CrossChainCreate lacks validation**

The `CrossChainCreate` method blindly extracts the first 2 characters from any symbol and maps them to an NFT type. [6](#0-5) 

It then sets the NFT protocol's type based solely on this symbol-derived mapping, ignoring the token's `ExternalInfo`. [7](#0-6) 

The method has no access control and performs no symbol format validation. [8](#0-7) 

The expected format enforces minimum 9-digit numbers after the 2-character prefix (11+ total characters), but this is never validated in `CrossChainCreate`. [9](#0-8) 

**Attack Execution:**

1. Attacker possesses a SEED NFT (required for token creation). [10](#0-9) 

2. Attacker calls `MultiToken.Create` with:
   - Symbol: `"BA12345678"` (10 characters, starts with "BA" which maps to "Badges")
   - ExternalInfo: `{"aelf_nft_type": "Art", "aelf_nft_base_uri": "https://...", "aelf_nft_token_id_reuse": "false"}`

3. Token is created with metadata claiming type "Art" in `ExternalInfo`

4. Attacker calls `NFTContract.CrossChainCreate` with symbol `"BA12345678"`

5. `CrossChainCreate` extracts "BA" and maps it to "Badges" (not "Art")

6. NFT protocol is created with `NftType = "Badges"` while token metadata states `"aelf_nft_type": "Art"`

This creates a permanent inconsistency: queries via `GetNFTProtocolInfo` return "Badges" while token metadata reads show "Art".

## Impact Explanation

**Data Integrity Violation:**
The fundamental invariant that NFT protocol type must match token metadata type is violated. The legitimate flow ensures this consistency by generating symbols from type prefixes and setting matching metadata. [11](#0-10) [12](#0-11) 

**Affected Parties:**
- Users and dApps querying `GetNFTProtocolInfo` receive incorrect type classification [13](#0-12) 
- NFT marketplaces filtering by type may display collections in wrong categories
- Any governance or policy systems relying on NFT type enforcement
- Trust in the NFT type classification system is undermined

**Severity Assessment:**
Medium - While not directly causing fund loss, this creates systemic data integrity issues that can mislead users and break type-based logic across the ecosystem. The attack leaves the system in a valid but inconsistent state that persists indefinitely.

## Likelihood Explanation

**Entry Point Accessibility:**
Both required methods are publicly accessible without special authorization. The `Create` method requires a SEED NFT, which is the standard requirement for token creation and is obtainable through normal means. [14](#0-13) 

**Attack Complexity:**
The attack requires only two straightforward contract calls with no timing constraints, race conditions, or complex state manipulation. An attacker needs basic understanding of the contract interfaces and possession of one SEED NFT.

**Economic Feasibility:**
Cost is limited to gas fees plus the price of a SEED NFT, both economically reasonable. The attack creates valid tokens and protocols without triggering any anomaly detection mechanisms.

**Probability:**
High - The attack path is direct, requires minimal resources, and the resulting state appears valid to automated systems while creating exploitable inconsistencies for users and applications relying on type classification.

## Recommendation

**Fix 1: Validate NFT metadata keys in MultiToken.Create**

Add NFT-specific metadata keys to the validation in `MultiToken.CreateToken` by checking against NFT contract's reserved keys, or restrict setting these keys to only the NFT contract address.

**Fix 2: Validate symbol format in CrossChainCreate**

Add validation in `CrossChainCreate` to ensure:
- Symbol length is at least 11 characters (2-char prefix + 9-digit minimum)
- Characters after prefix are numeric
- Symbol follows the expected `{type_prefix}{number}` format

**Fix 3: Verify consistency between symbol and metadata**

In `CrossChainCreate`, after extracting the type from the symbol, verify it matches `tokenInfo.ExternalInfo.Value[NftTypeMetadataKey]` to detect any inconsistency.

**Fix 4: Add authorization to CrossChainCreate**

Consider restricting `CrossChainCreate` to be callable only by trusted cross-chain synchronization mechanisms rather than being fully public.

## Proof of Concept

```csharp
[Fact]
public async Task NFTTypeInconsistency_ViaCrossChainCreate_Test()
{
    // Setup: Get a SEED NFT for token creation
    await PrepareSeedNFT("BA12345678");
    
    // Step 1: Attacker creates token via MultiToken.Create with mismatched metadata
    var createInput = new CreateInput
    {
        Symbol = "BA12345678", // Starts with BA (Badges prefix)
        TokenName = "Fake Art Collection",
        TotalSupply = 1000000,
        Decimals = 0,
        Issuer = AttackerAddress,
        IsBurnable = true,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                { "aelf_nft_type", "Art" }, // Claims to be Art type
                { "aelf_nft_base_uri", "https://example.com/" },
                { "aelf_nft_token_id_reuse", "false" }
            }
        }
    };
    
    await TokenContractStub.Create.SendAsync(createInput);
    
    // Step 2: Attacker calls CrossChainCreate to register as NFT protocol
    await NFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
    {
        Symbol = "BA12345678"
    });
    
    // Step 3: Verify the inconsistency
    var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(
        new StringValue { Value = "BA12345678" });
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = "BA12345678" });
    
    // Protocol says "Badges" (from BA prefix)
    protocolInfo.NftType.ShouldBe("Badges");
    
    // Token metadata says "Art"
    tokenInfo.ExternalInfo.Value["aelf_nft_type"].ShouldBe("Art");
    
    // INCONSISTENCY CONFIRMED: Different types in protocol vs token metadata
    Assert.NotEqual(protocolInfo.NftType, tokenInfo.ExternalInfo.Value["aelf_nft_type"]);
}
```

## Notes

This vulnerability demonstrates a critical gap in cross-contract validation where the NFT contract assumes tokens follow its naming conventions without verifying this assumption. The legitimate NFT creation flow enforces consistency, but direct token creation bypasses these protections. The issue is exacerbated by `CrossChainCreate` being designed for cross-chain synchronization but lacking the validation to ensure data integrity when called with maliciously crafted tokens.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-17)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
    public const string LockCallbackExternalInfoKey = "aelf_lock_callback";
    public const string UnlockCallbackExternalInfoKey = "aelf_unlock_callback";
    public const string LogEventExternalInfoKey = "aelf_log_event";
    public const string TokenAliasExternalInfoKey = "aelf_token_alias";
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L7-9)
```csharp
    private const string NftTypeMetadataKey = "aelf_nft_type";
    private const string NftBaseUriMetadataKey = "aelf_nft_base_uri";
    private const string NftTokenIdReuseMetadataKey = "aelf_nft_token_id_reuse";
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-36)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L118-123)
```csharp
    private void AssertMetadataKeysAreCorrect(IEnumerable<string> metadataKeys)
    {
        var reservedMetadataKey = GetNftMetadataReservedKeys();
        foreach (var metadataKey in metadataKeys)
            Assert(!reservedMetadataKey.Contains(metadataKey), $"Metadata key {metadataKey} is reserved.");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L9-12)
```csharp
    public override NFTProtocolInfo GetNFTProtocolInfo(StringValue input)
    {
        return State.NftProtocolMap[input.Value];
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L97-107)
```csharp
    private List<string> GetNftMetadataReservedKeys()
    {
        return new List<string>
        {
            NftTypeMetadataKey,
            NftBaseUriMetadataKey,
            AssembledNftsKey,
            AssembledFtsKey,
            NftTokenIdReuseMetadataKey
        };
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-75)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L89-90)
```csharp
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L106-106)
```csharp
            NftType = nftTypeFullName
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L196-199)
```csharp
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
        // Add Uri to external info.
        tokenExternalInfo.Value[NftBaseUriMetadataKey] = input.BaseUri;
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
```
