# Audit Report

## Title
Hardcoded Election Lock Amount Causes DoS or Incorrect Economic Security When Native Token Decimals Differ from 8

## Summary
The Election contract's `LockTokenForElection` constant is hardcoded to `100_000_00000000` assuming 8 decimal places, but native token decimals are configurable from 0 to 18. When a chain is initialized with different decimals, the election system either fails completely (DoS) or locks economically incorrect amounts, breaking the intended 100,000 token security barrier.

## Finding Description

The Election contract defines a hardcoded constant for candidate locking: [1](#0-0) 

This constant assumes the native token has exactly 8 decimal places. However, native token decimals are configurable during chain initialization through the `NativeTokenDecimals` field: [2](#0-1) 

The Economic contract uses this configurable value when creating the native token: [3](#0-2) 

The decimals value is sourced from configurable `EconomicOptions` which defaults to 8 but can be changed: [4](#0-3) 

This configuration is passed during initialization: [5](#0-4) 

Token decimals are validated only to be between 0 and 18: [6](#0-5) 

The hardcoded constant is used directly without decimal adjustment when locking tokens: [7](#0-6) 

And when refunding: [8](#0-7) 

The MultiToken `TransferFrom` performs no decimal-specific validation beyond checking amounts are positive: [9](#0-8) 

Test code demonstrates native token creation with 2 decimals is feasible: [10](#0-9) 

## Impact Explanation

**Critical DoS Scenario (decimals < 8):**
When native token has fewer decimals (e.g., 2), the hardcoded value `100_000_00000000` represents an astronomically large token amount. For example:
- With 2 decimals: `100_000_00000000 / 10^2 = 1,000,000,000,000` tokens (1 trillion)
- Typical total supply with 2 decimals (proportionally adjusted): ~10 million tokens
- Result: `TransferFrom` fails with "Insufficient balance" as confirmed by test: [11](#0-10) 

**High Economic Security Break (decimals > 8):**
When native token has more decimals (e.g., 10), the hardcoded value represents too small an amount:
- With 10 decimals: `100_000_00000000 / 10^10 = 10,000` tokens
- Intended amount: 100,000 tokens
- Result: 90% reduction in economic barrier, making candidate announcements 10x cheaper

The default total supply value also assumes 8 decimals: [12](#0-11) 

## Likelihood Explanation

The vulnerability triggers through public entry points accessible to any user: [13](#0-12) 

And: [14](#0-13) 

**Preconditions:**
1. Chain initialized with native token decimals â‰  8
2. This is explicitly supported by the configuration system
3. Side chains or custom deployments may choose different decimals for token compatibility or precision requirements

**Feasibility:** The codebase demonstrates this configuration is valid and can occur in production environments.

**Probability:** Medium-High. While default is 8 decimals, the configuration is intentionally flexible with no enforcement, and any deviation immediately triggers the issue upon first election announcement.

## Recommendation

Add decimal-aware calculation to the Election contract. Query the native token's decimals during initialization and calculate the lock amount dynamically:

```csharp
// Store native token decimals during contract initialization
public override Empty Initialize(InitializeInput input)
{
    // ... existing initialization ...
    
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput 
    { 
        Symbol = Context.Variables.NativeSymbol 
    });
    State.NativeTokenDecimals.Value = tokenInfo.Decimals;
    
    return new Empty();
}

// Calculate lock amount based on actual decimals
private long GetLockTokenAmount()
{
    var decimals = State.NativeTokenDecimals.Value;
    // 100,000 tokens with correct decimal adjustment
    return 100_000 * (long)Math.Pow(10, decimals);
}

// Use in LockCandidateNativeToken
State.TokenContract.TransferFrom.Send(new TransferFromInput
{
    From = sponsorAddress,
    To = lockVirtualAddress,
    Symbol = Context.Variables.NativeSymbol,
    Amount = GetLockTokenAmount(), // Use dynamic calculation
    Memo = "Lock for announcing election."
});
```

## Proof of Concept

```csharp
[Fact]
public async Task ElectionContract_AnnounceElection_WrongDecimals_DoS_Test()
{
    // Initialize chain with native token having 2 decimals instead of 8
    await InitializeTokenWithDecimals(2);
    
    // Try to announce election with the hardcoded lock amount
    // LockTokenForElection = 100_000_00000000 assumes 8 decimals
    // With 2 decimals, this represents 1 trillion tokens (impossible amount)
    
    var candidateKeyPair = ValidationDataCenterKeyPairs[0];
    var transactionResult = await AnnounceElectionAsync(candidateKeyPair);
    
    // Verify DoS: transaction fails due to insufficient balance
    transactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    transactionResult.Error.ShouldContain("Insufficient balance");
    
    // Election system is completely unusable - no candidate can announce
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** protobuf/economic_contract.proto (L35-35)
```text
    int32 native_token_decimals = 4;
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L59-59)
```csharp
            Decimals = input.NativeTokenDecimals,
```

**File:** src/AElf.OS.Core/EconomicOptions.cs (L8-8)
```csharp
    public long TotalSupply { get; set; } = 1_000_000_000_00000000;
```

**File:** src/AElf.OS.Core/EconomicOptions.cs (L9-9)
```csharp
    public int Decimals { get; set; } = 8;
```

**File:** src/AElf.EconomicSystem/EconomicContractInitializationProvider.cs (L40-40)
```csharp
                    NativeTokenDecimals = _economicOptions.Decimals,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L276-277)
```csharp
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-118)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L187-194)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L242-249)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L254-259)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransferFrom(input.From, input.To, Context.Sender, tokenInfo.Symbol, input.Amount, input.Memo);
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Profit.Tests/ProfitContractTestBase.cs (L153-166)
```csharp
        tokenContractCallList.Add(nameof(TokenContract.Create), new CreateInput
        {
            Symbol = symbol,
            Decimals = 2,
            IsBurnable = true,
            TokenName = "elf token",
            TotalSupply = ProfitContractTestConstants.NativeTokenTotalSupply,
            Issuer = Starter,
            Owner = Starter,
            LockWhiteList =
            {
                ProfitContractAddress
            }
        });
```

**File:** test/AElf.Contracts.Election.Tests/GQL/ElectionTests.cs (L192-211)
```csharp
    public async Task ElectionContract_AnnounceElection_TokenNotEnough_Test()
    {
        var candidateKeyPair = VoterKeyPairs[0];
        var balance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = Address.FromPublicKey(candidateKeyPair.PublicKey),
            Symbol = ElectionContractTestConstants.NativeTokenSymbol
        })).Balance;
        var tokenTester = GetTokenContractTester(candidateKeyPair);
        await tokenTester.Transfer.SendAsync(new TransferInput
        {
            Symbol = ElectionContractTestConstants.NativeTokenSymbol,
            Amount = balance / 2,
            To = Address.FromPublicKey(VoterKeyPairs[1].PublicKey),
            Memo = "transfer token to other"
        });

        var transactionResult = await AnnounceElectionAsync(candidateKeyPair);
        transactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        transactionResult.Error.Contains("Insufficient balance").ShouldBeTrue();
```
