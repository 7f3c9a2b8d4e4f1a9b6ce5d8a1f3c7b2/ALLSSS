### Title
Duplicate Miner Public Keys in Election Victories Cause Consensus Term Transition Failure

### Summary
The Election contract's `GetVictories` method can return duplicate public keys when valid candidates are insufficient and initial miners overlap with valid candidates. When this duplicate list is used to generate a new consensus term in `GenerateFirstRoundOfNewTerm`, the `ToDictionary` call throws an `ArgumentException`, causing term transition failure and consensus DoS.

### Finding Description

The vulnerability exists in the interaction between the Election contract's `GetVictories` method and the Consensus contract's `GenerateFirstRoundOfNewTerm` method.

**Root Cause in Election Contract:** [1](#0-0) 

When there aren't enough valid candidates (`diff > 0`), the code constructs the victories list by:
1. Adding all valid candidates to the victories list
2. Creating a backups list from current miners excluding valid candidates
3. Adding initial miners to backups if they're not already in the backups list
4. Taking up to `diff` items from backups and adding them to victories

The critical flaw is at the initial miners addition logic: it only checks `!backups.Contains(k)` but doesn't verify whether the initial miner is already in the `validCandidates` list. Since initial miners can also be valid candidates (they can announce election), this creates duplicates in the final victories list.

**Failure Point in Consensus Contract:** [2](#0-1) 

When `GenerateFirstRoundOfNewTerm` is called with a `MinerList` containing duplicate public keys, the `ToDictionary` call attempts to create a dictionary with duplicate keys (same hex string), which throws `ArgumentException: "An item with the same key has already been added"`.

**Execution Path:** [3](#0-2) 

During term transition, `GenerateFirstRoundOfNextTerm` retrieves victories from the Election contract and calls `GenerateFirstRoundOfNewTerm` on them. [4](#0-3) 

This is invoked when generating consensus extra data for the next term. [5](#0-4) 

The `NextTerm` method is the public entry point for term transitions.

### Impact Explanation

**Consensus Failure:** When the `ToDictionary` call throws an exception, the entire term transition fails. This prevents the blockchain from transitioning to the next term, effectively halting consensus progression.

**Who is Affected:** All network participants are impacted as the blockchain cannot progress to new terms with updated miner lists. This freezes the governance and election system's ability to rotate miners.

**Severity Justification:** This is a HIGH severity issue because:
1. It causes complete consensus term transition failure
2. It can occur during normal blockchain operation without any malicious action
3. It's most likely during the critical early stages when initial miners are transitioning to elected miners
4. Recovery requires contract upgrade or manual intervention
5. It blocks the core consensus mechanism from functioning properly

### Likelihood Explanation

**Attacker Capabilities:** No attacker is required. This vulnerability triggers automatically during normal consensus operation when preconditions are met.

**Feasibility Conditions:** The issue occurs when:
1. The number of valid candidates is less than the target miners count (`State.MinersCount.Value`)
2. One or more initial miners have also announced as candidates (become valid candidates)
3. A term transition is triggered

**Probability Reasoning:** This scenario is highly likely in the early stages of the blockchain when:
- Initial miners are still active in consensus
- The election system is just starting with few candidates
- Initial miners announce themselves as candidates to continue participating
- The system attempts its first term transition from initial miners to elected miners

**Detection/Operational Constraints:** The failure is immediate and deterministic. Once the conditions are met, every term transition attempt will fail with the same exception until the duplicate is resolved.

### Recommendation

**Immediate Fix in Election Contract:**

Add deduplication logic in the `GetVictories` method to ensure initial miners that are already valid candidates are not added again:

```csharp
// In GetVictories method, replace lines 66-74 with:
var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
if (State.InitialMiners.Value != null)
    backups.AddRange(
        State.InitialMiners.Value.Value.Select(k => k.ToHex())
            .Where(k => !backups.Contains(k) && !validCandidates.Contains(k)));
```

**Additional Safety in Consensus Contract:**

Add deduplication before calling `ToDictionary`:

```csharp
// In GenerateFirstRoundOfNewTerm, before line 15:
var uniquePubkeys = Pubkeys.Distinct(new ByteStringEqualityComparer()).ToList();
var sortedMiners = (from obj in uniquePubkeys.ToDictionary<ByteString, string, int>(...)
```

**Invariant Checks:**
1. Assert that `GetVictories` returns no duplicates before returning
2. Add validation in `GenerateFirstRoundOfNewTerm` to check for duplicates in input
3. Add unit test verifying no duplicates when initial miners overlap with valid candidates

**Test Cases:**
1. Test with initial miners who are also valid candidates
2. Test term transition with insufficient valid candidates
3. Test with all initial miners as valid candidates
4. Test with varying overlap percentages between initial miners and valid candidates

### Proof of Concept

**Initial State:**
- MinersCount = 5 (target miners for consensus)
- InitialMiners = ["MinerA", "MinerB", "MinerC"]
- CurrentMiners = ["MinerA", "MinerB", "MinerC"] (using initial miners)
- MinerA and MinerB announce as candidates with sufficient votes
- ValidCandidates = ["MinerA", "MinerB"] (2 candidates)
- No other candidates exist

**Execution Steps:**

1. **Blockchain reaches term transition time** - Consensus determines it's time for `NextTerm`

2. **GetVictories is called:**
   - diff = 5 - 2 = 3 (need 3 more miners)
   - victories = ["MinerA", "MinerB"] (from validCandidates)
   - backups = ["MinerC"] (currentMiners excluding validCandidates)
   - Initial miners ["MinerA", "MinerB", "MinerC"] are processed:
     - "MinerA": not in backups, ADDED to backups
     - "MinerB": not in backups, ADDED to backups
     - "MinerC": already in backups, NOT added
   - backups = ["MinerC", "MinerA", "MinerB"]
   - Take Min(3, 3) = 3 from sorted backups: ["MinerA", "MinerB", "MinerC"]
   - Add to victories: ["MinerA", "MinerB"] + ["MinerA", "MinerB", "MinerC"]
   - **Result: victories = ["MinerA", "MinerB", "MinerA", "MinerB", "MinerC"]** (duplicates!)

3. **GenerateFirstRoundOfNewTerm is called** with MinerList containing duplicate "MinerA" and "MinerB"

4. **Exception thrown:**
   - `ToDictionary` attempts to add "MinerA" twice
   - `ArgumentException: An item with the same key has already been added. Key: MinerA`

**Expected Result:** Term transition completes successfully with 5 unique miners

**Actual Result:** Term transition fails with ArgumentException, consensus halts

**Success Condition:** Transaction reverts, term number doesn't increment, blockchain cannot proceed to next term

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L62-77)
```csharp
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-210)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
