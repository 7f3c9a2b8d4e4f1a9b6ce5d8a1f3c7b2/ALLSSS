# Audit Report

## Title
Case Sensitivity Inconsistency in SEED Collection Validation Breaks Token Creation Mechanism

## Summary
The TokenContract fails to normalize or validate the case of the SEED collection symbol ("SEED-0"), allowing a whitelisted address to inadvertently create "seed-0" (lowercase) through a typo in governance proposals. This permanently breaks the entire token creation mechanism for non-whitelisted users due to inconsistent case handling across storage, validation, and lookup operations.

## Finding Description

The vulnerability stems from three critical code defects in case handling:

**1. Whitelist Bypass Without Normalization**

When a whitelisted address (Parliament, Genesis, Economic, or CrossChain contracts) creates a token, the validation logic skips seed NFT requirements: [1](#0-0) 

The comparison at line 57 uses the hardcoded constant "SEED-0": [2](#0-1) 

If the input symbol is "seed-0" (lowercase), line 57 evaluates `"seed-0" != "SEED-0"` as true, but since the sender is whitelisted, the entire validation block is bypassed.

**2. Dual Storage System Creates Inconsistency**

Token registration uses case-insensitive existence checking: [3](#0-2) 

But token info retrieval is case-sensitive: [4](#0-3) 

And existence checking also verifies the case-insensitive map: [5](#0-4) 

This creates an irreversible state: once "seed-0" is created, `InsensitiveTokenExisting["SEED-0"]` is true, preventing "SEED-0" creation, but `TokenInfos["SEED-0"]` remains null.

**3. Case-Sensitive SEED Collection Check Breaks Mechanism**

When creating SEED NFTs (SEED-1, SEED-2, etc.), the code validates if the parent collection is the special SEED collection: [6](#0-5) 

If "seed-0" was created, line 37 evaluates `"seed-0" == "SEED-0"` as false, skipping the critical `SymbolSeedMap` population at line 51. This map is essential for token creation validation: [7](#0-6) 

**4. Symbol Validation Permits Lowercase**

The validation regex explicitly allows lowercase letters: [8](#0-7) 

## Impact Explanation

**Catastrophic and Permanent System DoS:**

1. **Complete SEED Mechanism Failure**: The `SymbolSeedMap` is never populated for any symbols, making it impossible to validate seed NFT ownership for token creation.

2. **Permanent Token Creation DoS**: All non-whitelisted users attempting to create tokens will fail at the seed NFT check: [9](#0-8) 

3. **Cannot Create SEED NFTs**: Attempts to create individual SEED NFTs fail because `GetTokenInfo("SEED-0")` returns null when only "seed-0" exists.

4. **Irreversible State**: Once "seed-0" is created, "SEED-0" cannot be created due to the case-insensitive existence check, leaving the system permanently broken with no recovery path.

This affects all protocol users requiring token creation capabilities, representing a critical availability failure of core system functionality.

## Likelihood Explanation

**Medium to High Likelihood Through Human Error:**

While this requires action by a whitelisted address (typically Parliament governance), the trigger is realistic human error:

1. **No Input Validation**: The contract lacks any normalization or validation to enforce uppercase for critical system constants
2. **Manual Proposal Creation**: Governance proposals are created by humans with typed parameters
3. **Common Error Pattern**: Case sensitivity errors are common in configuration and parameter specification
4. **No Programmatic Enforcement**: Test files consistently use uppercase "SEED-0": [10](#0-9) 

However, there's no runtime validation enforcing this convention.

The whitelisted addresses are: [11](#0-10) 

Parliament governance proposals involving typed string parameters are susceptible to typos during proposal creation.

## Recommendation

Implement defensive input validation for critical system constants:

```csharp
private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
{
    // Add normalization/validation at the start
    if (symbolType == SymbolType.NftCollection && 
        input.Symbol.ToUpper() == TokenContractConstants.SeedCollectionSymbol)
    {
        Assert(input.Symbol == TokenContractConstants.SeedCollectionSymbol, 
               "SEED collection symbol must be uppercase: SEED-0");
    }
    
    // Rest of existing logic...
}
```

Alternatively, normalize all collection symbols to uppercase during validation, or use case-insensitive comparison consistently throughout the SEED collection checks.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task LowercaseSeedCollection_BreaksTokenCreation()
{
    // Step 1: Whitelisted address creates "seed-0" (lowercase) instead of "SEED-0"
    var result = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "seed-0",  // Typo: lowercase instead of "SEED-0"
        Decimals = 0,
        IsBurnable = true,
        TokenName = "seed Collection",
        TotalSupply = 1,
        Issuer = DefaultAddress,
        Owner = DefaultAddress
    });
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 2: Verify "seed-0" was created
    var seedInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput 
    { 
        Symbol = "seed-0" 
    });
    seedInfo.Symbol.ShouldBe("seed-0");
    
    // Step 3: Cannot create "SEED-0" now due to case-insensitive existence check
    var upperResult = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "SEED-0",
        Decimals = 0,
        IsBurnable = true,
        TokenName = "SEED Collection",
        TotalSupply = 1,
        Issuer = DefaultAddress,
        Owner = DefaultAddress
    });
    upperResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    upperResult.TransactionResult.Error.ShouldContain("Token already exists");
    
    // Step 4: GetTokenInfo("SEED-0") returns null
    var upperSeedInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput 
    { 
        Symbol = "SEED-0" 
    });
    upperSeedInfo.Symbol.ShouldBeEmpty();  // Returns default empty TokenInfo
    
    // Step 5: Non-whitelisted users cannot create tokens (would fail at CheckSeedNFT)
    // This demonstrates the permanent DoS condition
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L118-131)
```csharp
    private void CheckSeedNFT(string symbolSeed, String symbol)
    {
        Assert(!string.IsNullOrEmpty(symbolSeed), "Seed NFT does not exist.");
        var tokenInfo = GetTokenInfo(symbolSeed);
        Assert(tokenInfo != null, "Seed NFT does not exist.");
        Assert(State.Balances[Context.Sender][symbolSeed] > 0, "Seed NFT balance is not enough.");
        Assert(tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.SeedOwnedSymbolExternalInfoKey, out var ownedSymbol) && ownedSymbol == symbol,
            "Invalid OwnedSymbol.");
        Assert(tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                   out var expirationTime)
               && long.TryParse(expirationTime, out var expirationTimeLong) &&
               Context.CurrentBlockTime.Seconds <= expirationTimeLong, "OwnedSymbol is expired.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L23-23)
```csharp
    public const string SeedCollectionSymbol = "SEED-0";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L28-31)
```csharp
    private bool IsValidCreateSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+$");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L233-233)
```csharp
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L302-302)
```csharp
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L37-51)
```csharp
        if (nftCollectionInfo.Symbol == TokenContractConstants.SeedCollectionSymbol)
        {
            Assert(input.Decimals == 0 && input.TotalSupply == 1, "SEED must be unique.");
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedOwnedSymbolExternalInfoKey,
                    out var ownedSymbol), "OwnedSymbol does not exist.");
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                       out var expirationTime)
                   && long.TryParse(expirationTime, out var expirationTimeLong) &&
                   Context.CurrentBlockTime.Seconds <= expirationTimeLong, "Invalid ownedSymbol.");
            var ownedSymbolType = GetSymbolType(ownedSymbol);
            Assert(ownedSymbolType != SymbolType.Nft, "Invalid OwnedSymbol.");
            CheckSymbolLength(ownedSymbol, ownedSymbolType);
            CheckTokenAndCollectionExists(ownedSymbol);
            CheckSymbolSeed(ownedSymbol);
            State.SymbolSeedMap[ownedSymbol.ToUpper()] = input.Symbol;
```

**File:** test/AElf.Contracts.Configuration.Tests/ConfigurationContractTestBase.cs (L179-179)
```csharp
                Symbol = "SEED-0",
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L259-265)
```csharp
    private bool IsAddressInCreateWhiteList(Address address)
    {
        return address == Context.GetZeroSmartContractAddress() ||
               address == GetDefaultParliamentController().OwnerAddress ||
               address == Context.GetContractAddressByName(SmartContractConstants.EconomicContractSystemName) ||
               address == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);
    }
```
