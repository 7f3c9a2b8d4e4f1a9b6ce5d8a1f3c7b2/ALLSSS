### Title
Missing ActualMiningTimes Validation in Next Round Transition Allows Consensus Manipulation

### Summary
The `ValidationForNextRound()` function fails to validate that `ActualMiningTimes` fields are empty for miners in the next round, allowing malicious miners to pre-fill false mining timestamps during round transitions. This enables manipulation of critical consensus logic including term change decisions and mining eligibility determination, undermining the integrity of the AEDPoS consensus mechanism.

### Finding Description

**Exact Code Location:** [1](#0-0) 

**Root Cause:**
The `ValidationForNextRound()` method only validates two aspects of next round information: (1) round number increments correctly, and (2) `InValue` is null for all miners. However, it completely omits validation that `ActualMiningTimes` should be empty/unset for the next round. [2](#0-1) 

**Why Protections Fail:**
The `MinerInRound` protobuf structure includes an `actual_mining_times` field as a repeated (array) of timestamps: [3](#0-2) 

When a miner triggers `NextRound`, they provide a `NextRoundInput` containing the complete `real_time_miners_information` map: [4](#0-3) 

The `ToRound()` conversion method copies all fields including any preset `ActualMiningTimes`: [5](#0-4) 

While legitimate next round generation via `GenerateNextRoundInformation()` creates new `MinerInRound` objects without setting `ActualMiningTimes`: [6](#0-5) 

There is no validation preventing maliciously crafted input from including preset values.

**Relevant Execution Path:**
1. Malicious miner (authorized via `PreCheck`) calls `NextRound`: [7](#0-6) 

2. Validation pipeline adds `RoundTerminateValidationProvider` for NextRound behavior: [8](#0-7) 

3. Validation passes despite preset `ActualMiningTimes` (only checks `InValue`): [9](#0-8) 

4. Malicious round is stored and becomes current round: [10](#0-9) 

### Impact Explanation

**Consensus Integrity Compromise:**

1. **Term Change Manipulation:** The `NeedToChangeTerm()` function uses the last `ActualMiningTime` to determine if sufficient miners have reached the term change threshold. Preset values allow attackers to force premature or delayed term changes: [11](#0-10) 

2. **Mining Eligibility Disruption:** During the first round of a term, `IsCurrentMiner()` uses `ActualMiningTimes.Last()` to calculate time slot eligibility. Preset values corrupt this logic, potentially preventing legitimate miners from producing blocks or allowing attackers to mine outside their slots: [12](#0-11) 

3. **Blockchain Start Timestamp Manipulation:** In the first round transition, preset `ActualMiningTimes` can manipulate the blockchain start timestamp, affecting all time-based calculations: [13](#0-12) 

**Who is Affected:**
All network participants are affected as consensus integrity is compromised. Term change timing affects validator elections, rewards distribution, and governance processes. Mining eligibility corruption can cause chain halts or enable double-mining scenarios.

**Severity Justification:**
Medium-to-High severity. While the attacker must be an existing miner (limiting attack surface), the impact on consensus integrity is severe. The attack is stealthy and can cascade through multiple rounds before detection.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an authorized miner in current or previous round (checked by `PreCheck`): [14](#0-13) 

**Attack Complexity:**
Low. Attacker only needs to:
1. Craft a `NextRoundInput` protobuf message with preset `ActualMiningTimes`
2. Submit it via `NextRound` transaction during their mining window
3. No complex timing or coordination required

**Feasibility Conditions:**
- Attacker is a miner (realistic in consensus context where any miner could become malicious)
- Normal round transition timing (happens regularly)
- Standard transaction costs apply

**Detection/Operational Constraints:**
Difficult to detect as preset timestamps may appear legitimate if chosen carefully (e.g., matching expected time slots). The validation explicitly allows this through its omission rather than rejecting it.

**Probability Reasoning:**
Medium-High likelihood. Any miner can execute this attack during normal operations. The only barrier is being a miner, which is a standard assumption in consensus security models. Economic incentive exists to manipulate term changes for validator position advantages.

### Recommendation

**Exact Code-Level Mitigation:**
Add validation in `ValidationForNextRound()` to ensure `ActualMiningTimes` is empty for all miners in the next round:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    // Existing InValue check
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // ADD THIS: Check ActualMiningTimes is empty
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.ActualMiningTimes.Count > 0))
        return new ValidationResult { Message = "ActualMiningTimes must be empty in next round." };

    return new ValidationResult { Success = true };
}
```

**Invariant Checks to Add:**
- Assert `ActualMiningTimes.Count == 0` for all miners when creating next round
- Add similar check in `ValidationForNextTerm()` 
- Consider adding a general round sanitization method that strips any preset actual mining times before storage

**Test Cases to Prevent Regression:**
1. Test NextRound with preset ActualMiningTimes → should fail validation
2. Test NextRound with mixed preset/empty ActualMiningTimes → should fail validation
3. Test NextTerm with preset ActualMiningTimes → should fail validation
4. Test legitimate round transitions still pass with new validation
5. Integration test verifying ActualMiningTimes only populated via UpdateValue/TinyBlock

### Proof of Concept

**Required Initial State:**
- Network with N miners in current round R
- Attacker is one of the miners (has produced at least one block)
- Current round approaching completion (attacker has right to trigger NextRound)

**Transaction Steps:**

1. **Craft Malicious NextRoundInput:**
```
NextRoundInput {
  round_number: R + 1,
  real_time_miners_information: {
    "MinerA": MinerInRound {
      pubkey: "MinerA",
      order: 1,
      expected_mining_time: T + interval,
      actual_mining_times: [T + interval + 100],  // PRESET VALUE
      // ... other fields
    },
    "MinerB": MinerInRound {
      pubkey: "MinerB", 
      order: 2,
      expected_mining_time: T + 2*interval,
      actual_mining_times: [T + 2*interval + 50],  // PRESET VALUE
      // ... other fields
    },
    // ... other miners
  },
  // ... other round fields
}
```

2. **Submit NextRound Transaction:**
Attacker calls `NextRound(malicious_input)` during their valid time slot

3. **Expected vs Actual Result:**
    - **Expected (Secure):** Validation rejects round with preset ActualMiningTimes
    - **Actual (Vulnerable):** Validation passes, malicious round stored with preset values

4. **Success Condition:**
Query `GetCurrentRoundInformation()` and observe:
    - Round number is R + 1
    - Miners have non-empty `ActualMiningTimes` despite no blocks produced yet
    - `NeedToChangeTerm()` returns incorrect value based on preset timestamps
    - `IsCurrentMiner()` returns incorrect mining eligibility for first round of next term

**Verification:**
```csharp
var currentRound = GetCurrentRoundInformation();
Assert(currentRound.RoundNumber == R + 1);
Assert(currentRound.RealTimeMinersInformation["MinerA"].ActualMiningTimes.Count > 0);  // Should be 0
Assert(currentRound.RealTimeMinersInformation["MinerA"].ActualMiningTimes[0] == T + interval + 100);  // Preset value present
```

### Notes

The vulnerability stems from incomplete validation that assumes honest input generation. The comment in the validation code explicitly lists only "Round Number" and "In Values Should Be Null" as checked aspects, indicating `ActualMiningTimes` was overlooked during security review. This is particularly critical because `ActualMiningTimes` directly affects consensus state transitions and mining permissions, making it a high-value target for manipulation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** protobuf/aedpos_contract.proto (L291-292)
```text
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
```

**File:** protobuf/aedpos_contract.proto (L458-462)
```text
message NextRoundInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-156)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L191-214)
```csharp
        // If current round is the first round of current term.
        if (currentRound.RoundNumber == 1)
        {
            Context.LogDebug(() => "First round");

            var latestMinedInfo =
                currentRound.RealTimeMinersInformation.Values.OrderByDescending(i => i.Order)
                    .FirstOrDefault(i => i.ActualMiningTimes.Any() && i.Pubkey != pubkey);
            if (latestMinedInfo != null)
            {
                var minersCount = currentRound.RealTimeMinersInformation.Count;
                var latestMinedSlotLastActualMiningTime = latestMinedInfo.ActualMiningTimes.Last();
                var latestMinedOrder = latestMinedInfo.Order;
                var currentMinerOrder =
                    currentRound.RealTimeMinersInformation.Single(i => i.Key == pubkey).Value.Order;
                var passedSlotsCount =
                    (Context.CurrentBlockTime - latestMinedSlotLastActualMiningTime).Milliseconds()
                    .Div(miningInterval);
                if (passedSlotsCount == currentMinerOrder.Sub(latestMinedOrder).Add(1).Add(minersCount) ||
                    passedSlotsCount == currentMinerOrder.Sub(latestMinedOrder).Add(minersCount))
                {
                    Context.LogDebug(() => "[CURRENT MINER]FIRST ROUND");
                    return true;
                }
```
