# Audit Report

## Title
Round 1 Special Handling Causes Incorrect Penalty for All Miners When First Miner Misses Time Slot

## Summary
A protocol design flaw in the AEDPoS consensus mechanism causes all miners to receive an incorrect `MissedTimeSlots` penalty increment when Round 1's first miner is delayed. The issue stems from the special handling that instructs miners to produce `NextRound` blocks instead of `UpdateValue` blocks, which fails to set the `SupposedOrderOfNextRound` field used to distinguish mining vs non-mining miners during round generation.

## Finding Description

The vulnerability exists in the interaction between consensus behavior determination and round generation logic.

**Step 1: Round 1 Special Behavior Determination**

When Round 1's first miner (Order 1) has not produced a block (`FirstMiner().OutValue == null`), all other miners are instructed to produce `NextRound` behavior to prevent fork blocks: [1](#0-0) 

**Step 2: SupposedOrderOfNextRound Only Set in UpdateValue Path**

The `SupposedOrderOfNextRound` field is set during `UpdateValue` block production via `ApplyNormalConsensusData`: [2](#0-1) 

This method is called during UpdateValue behavior: [3](#0-2) 

And the value is also explicitly set during UpdateValue processing: [4](#0-3) 

**Step 3: NextRound Blocks Skip Setting SupposedOrderOfNextRound**

The `GetConsensusExtraDataForNextRound` method does NOT call `ApplyNormalConsensusData` and does not set `SupposedOrderOfNextRound` for any miner: [5](#0-4) 

**Step 4: Round 1 Initialized with Default Values**

Round 1 is initialized by `GenerateFirstRoundOfNewTerm` which creates `MinerInRound` objects but never sets `SupposedOrderOfNextRound`, leaving it at the protobuf default of 0: [6](#0-5) 

The protobuf definition confirms `int32` fields default to 0: [7](#0-6) 

**Step 5: GenerateNextRoundInformation Uses SupposedOrderOfNextRound to Identify Miners**

When generating Round 2, the protocol uses `GetMinedMiners()` to identify which miners mined in Round 1: [8](#0-7) 

This returns only miners where `SupposedOrderOfNextRound != 0`. Since ALL miners in Round 1 have this field set to 0 (and the NextRound block didn't update it), `GetMinedMiners()` returns an empty list.

**Step 6: All Miners Treated as Non-Mining and Penalized**

All miners are therefore placed in the "not mined" category and receive a `MissedTimeSlots` increment: [9](#0-8) 

## Impact Explanation

**Concrete Harm:**
- All miners in the network receive an incorrect `MissedTimeSlots` increment of 1, including the miner who actively produced the `NextRound` block following protocol instructions
- This corrupts miner statistics used for consensus monitoring and reputation tracking
- The miner who correctly followed the protocol's `NextRound` instruction is unfairly penalized
- While a single missed slot (compared to the evil miner threshold of 4320) is small, it represents data corruption in consensus state
- The `MissedTimeSlots` counter persists across rounds and this could compound if the scenario repeats

**Who is Affected:**
- All miners during Round 1 → Round 2 transition when first miner is delayed
- Particularly unfair to the miner following protocol to produce the NextRound block

**Severity Assessment (Medium):**
- No immediate fund loss or system halt
- Creates incorrect consensus state affecting miner reputation/statistics
- Impacts fairness and integrity of consensus mechanism
- Limited to specific but realistic scenario

## Likelihood Explanation

**Triggering Conditions:**
- Occurs naturally when Round 1's first miner (Order 1) misses their time slot
- Common causes: network delays, node temporarily offline, slow block propagation
- Code comments acknowledge Round 1 timing is unreliable, making delays realistic [10](#0-9) 

**Feasibility:**
- No attacker needed - happens through normal protocol operation
- High probability during blockchain initialization or new term starts
- Deterministic when preconditions are met

**Detection:**
- Issue is deterministic and reproducible
- Can be verified by examining Round 2 miner statistics after a Round 1 where first miner was delayed

## Recommendation

The fix should ensure that miners producing `NextRound` blocks in Round 1 properly set their `SupposedOrderOfNextRound` value. One approach:

1. Modify `GetConsensusExtraDataForNextRound` to call `ApplyNormalConsensusData` for the miner producing the NextRound block when transitioning from Round 1
2. Alternatively, modify `GetMinedMiners()` to have special logic for Round 1 → Round 2 transitions that checks `OutValue != null` or `ActualMiningTimes.Count > 0` instead of only relying on `SupposedOrderOfNextRound`
3. Or initialize Round 1 miners with a non-zero default `SupposedOrderOfNextRound` value and adjust the comparison logic accordingly

The recommended fix is option 1, as it maintains consistency with the existing architecture where `ApplyNormalConsensusData` is responsible for setting mining-related fields.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task Round1_FirstMinerMissed_AllMinersIncorrectlyPenalized()
{
    // Setup: Initialize blockchain with Round 1
    var initialRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    initialRound.RoundNumber.ShouldBe(1);
    
    // Verify all miners start with 0 MissedTimeSlots and SupposedOrderOfNextRound = 0
    foreach (var miner in initialRound.RealTimeMinersInformation.Values)
    {
        miner.MissedTimeSlots.ShouldBe(0);
        miner.SupposedOrderOfNextRound.ShouldBe(0);
    }
    
    // First miner (Order 1) has NOT produced a block yet
    var firstMiner = initialRound.RealTimeMinersInformation.Values.First(m => m.Order == 1);
    firstMiner.OutValue.ShouldBeNull();
    
    // Second miner produces NextRound block (as protocol instructs)
    var secondMinerKeyPair = ValidationDataCenterKeyPairs[1];
    var nextRoundInfo = await AEDPoSContractStub.GetConsensusExtraData.CallAsync(
        new AElfConsensusTriggerInformation
        {
            Behaviour = AElfConsensusBehaviour.NextRound,
            Pubkey = ByteString.CopyFrom(secondMinerKeyPair.PublicKey)
        }.ToBytesValue());
        
    var nextRoundInput = NextRoundInput.Parser.ParseFrom(nextRoundInfo.ToConsensusHeaderInformation().Round.ToByteArray());
    var randomNumber = await GenerateRandomProofAsync(secondMinerKeyPair);
    nextRoundInput.RandomNumber = ByteString.CopyFrom(randomNumber);
    
    await AEDPoSContractStub.NextRound.SendAsync(nextRoundInput);
    
    // Check Round 2
    var round2 = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    round2.RoundNumber.ShouldBe(2);
    
    // VULNERABILITY: ALL miners have MissedTimeSlots = 1, including the one who produced NextRound block
    foreach (var miner in round2.RealTimeMinersInformation.Values)
    {
        // Expected: Only first miner should have MissedTimeSlots = 1
        // Actual: ALL miners have MissedTimeSlots = 1 (INCORRECT)
        miner.MissedTimeSlots.ShouldBe(1); // This demonstrates the bug
    }
}
```

## Notes

This vulnerability represents a consensus state integrity issue rather than a direct financial exploit. The impact is primarily on the fairness and accuracy of miner reputation tracking. While the immediate effect is limited (a single incorrect penalty), it demonstrates a flaw in the protocol's Round 1 handling logic that violates the expected behavior where only non-mining miners should receive penalties.

The issue is particularly problematic because the miner who correctly follows the protocol's instruction to produce a `NextRound` block is penalized along with truly non-mining miners, creating an unfair situation where compliance with the protocol results in an incorrect penalty.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L94-102)
```csharp
            if (
                // For first round, the expected mining time is incorrect (due to configuration),
                CurrentRound.RoundNumber == 1 &&
                // so we'd better prevent miners' ain't first order (meanwhile he isn't boot miner) from mining fork blocks
                _minerInRound.Order != 1 &&
                // by postpone their mining time
                CurrentRound.FirstMiner().OutValue == null
            )
                return AElfConsensusBehaviour.NextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-42)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-111)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-203)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-246)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L23-37)
```csharp
        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
```

**File:** protobuf/aedpos_contract.proto (L287-289)
```text
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L39-56)
```csharp
        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```
