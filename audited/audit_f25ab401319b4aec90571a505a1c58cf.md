### Title
MethodFeeController Can Set Unbounded Fees Leading to Irreversible Governance DoS

### Summary
An attacker who gains control of the MethodFeeController can set arbitrarily high transaction fees on critical governance and system methods without any upper bound validation. This enables a permanent denial-of-service attack where governance methods (CreateProposal, Approve, Release) become prohibitively expensive, preventing the system from recovering even if honest actors regain majority control. The lack of fee caps and emergency recovery mechanisms allows temporary governance compromise to cause irreversible chain dysfunction.

### Finding Description

The MethodFeeController state in Configuration and all ACS1-implementing contracts lacks upper bound validation on fee amounts. [1](#0-0) 

The SetMethodFee implementation only validates that amounts are non-negative and tokens are valid, with no maximum fee limit: [2](#0-1) 

The validation function AssertValidToken only checks amount >= 0 and token validity: [3](#0-2) 

This pattern is consistent across all system contracts implementing ACS1. The MethodFeeController is initially set to Parliament's default organization through RequiredMethodFeeControllerSet: [4](#0-3) 

While consensus methods (UpdateValue, NextTerm) are hardcoded to be fee-free and protected from this attack: [5](#0-4) 

Other critical methods including governance operations are NOT protected. When fees exceed user balances, transactions fail: [6](#0-5) 

**Root Cause**: The SetMethodFee validation only enforces amount >= 0 with no upper bound, combined with no emergency recovery mechanism to bypass or reset prohibitive fees once set.

**Why Protections Fail**: 
1. No maximum fee caps exist in any ACS1 implementation
2. Changing MethodFeeController back requires calling governance methods (CreateProposal, Approve, Release) which would themselves have prohibitive fees
3. No emergency organization or zero contract override exists for fee-related methods
4. The Configuration contract's zero contract override only applies to SetConfiguration, not to ChangeMethodFeeController: [7](#0-6) 

### Impact Explanation

**Harm**: An attacker controlling MethodFeeController can set fees to arbitrarily high values (e.g., 10^18 ELF) on critical methods including:
- Parliament.CreateProposal, Approve, Release (governance operations)
- Token.Transfer (all token operations)
- Association/Referendum governance methods
- Any system contract method not hardcoded as fee-free

**Quantified Damage**: 
- Complete DoS of governance: No proposals can be created, approved, or released
- User operations become unusable: Token transfers and other user-facing methods are priced out
- **Irreversible**: Even if honest actors regain 66.67% miner control, they cannot create proposals to fix the fees because CreateProposal itself requires paying the prohibitive fee
- Requires hard fork to recover

**Who Is Affected**: All chain participants - users cannot transact, governance cannot operate, only consensus block production continues.

**Severity Justification**: Critical - The attack creates permanent chain dysfunction. Unlike typical governance attacks that are reversible when honest majority returns, this attack weaponizes fee controls to create an irreversible governance deadlock. The lack of safety bounds amplifies temporary control into permanent failure.

### Likelihood Explanation

**Attacker Capabilities**: 
- Precondition: Attacker must control MethodFeeController (initially requires 66.67% miner approval to change from Parliament default organization)
- This could occur through: temporary governance compromise, miner collusion, economic bribes, or malicious proposal that passes

**Attack Complexity**: Once MethodFeeController is controlled, attack execution is trivial:
1. Call SetMethodFee with fees set to 10^18 or higher on governance methods
2. Call SetMethodFee with prohibitive fees on token operations
3. Immediate effect - all targeted methods become uncallable

**Feasibility Conditions**: The attack is executable through standard contract calls with no special requirements beyond MethodFeeController authority.

**Detection/Operational Constraints**: The attack is immediately visible (fees spike), but irreversible - no operational constraints prevent it once launched.

**Probability Reasoning**: While gaining initial MethodFeeController control requires significant effort (governance compromise), the vulnerability's severity lies in the IRREVERSIBILITY: temporary control creates permanent damage. The lack of safety limits (fee caps, emergency overrides) means the system cannot recover even after honest actors regain majority.

### Recommendation

**Code-Level Mitigation**:

1. Add maximum fee limits in SetMethodFee validation across all ACS1 implementations:
```
private void AssertValidToken(string symbol, long amount)
{
    const long MaxMethodFee = 10_000_00000000; // 10,000 ELF maximum
    Assert(amount >= 0, "Invalid amount.");
    Assert(amount <= MaxMethodFee, "Fee exceeds maximum allowed limit.");
    // ... existing token validation
}
```

2. Implement emergency recovery mechanism - create an emergency organization with very high threshold (90%+) that can reset MethodFeeController even when governance is priced out:
```
public override Empty ResetMethodFeeControllerEmergency(Empty input)
{
    AssertSenderIsEmergencyOrganization();
    var defaultAuthority = new AuthorityInfo
    {
        OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
        ContractAddress = State.ParliamentContract.Value
    };
    State.MethodFeeController.Value = defaultAuthority;
    return new Empty();
}
```

3. Add time-delay mechanism for MethodFeeController changes (e.g., 7-day delay) to allow detection and response.

**Invariant Checks**:
- Assert all SetMethodFee calls satisfy: 0 <= amount <= MAX_METHOD_FEE
- Assert MethodFeeController changes include time-lock delay
- Add event monitoring for fee changes exceeding reasonable thresholds

**Test Cases**:
- Test SetMethodFee rejection when amount exceeds maximum
- Test emergency recovery path can reset MethodFeeController when governance is priced out
- Test time-delay enforcement on MethodFeeController changes

### Proof of Concept

**Required Initial State**:
1. Attacker controls MethodFeeController (e.g., through prior successful proposal changing it to attacker-controlled Association)
2. Chain is operational with standard token balances

**Transaction Steps**:

Step 1 - Set prohibitive fees on governance:
```
SetMethodFee({
    MethodName: "CreateProposal",
    Fees: [{ Symbol: "ELF", BasicFee: 1000000_00000000 }] // 1 million ELF
})

SetMethodFee({
    MethodName: "Approve", 
    Fees: [{ Symbol: "ELF", BasicFee: 1000000_00000000 }]
})

SetMethodFee({
    MethodName: "Release",
    Fees: [{ Symbol: "ELF", BasicFee: 1000000_00000000 }]
})
```

Step 2 - Attempt recovery (fails):
```
// Honest actors try to create proposal to reset MethodFeeController
CreateProposal(...) 
// FAILS: "Transaction fee not enough" - requires 1M ELF
```

Step 3 - Verify DoS:
```
// Any user transaction fails
Transfer(...) // If fee also set high
// FAILS: "Transaction fee not enough"

// Governance is permanently locked
// No proposals can be created, approved, or released
```

**Expected vs Actual Result**:
- Expected: Fees should be capped at reasonable maximum, or emergency recovery should exist
- Actual: Fees can be set to arbitrary values (validated only amount >= 0), creating irreversible DoS with no recovery path

**Success Condition**: After Step 1 executes, governance becomes permanently non-functional. Even with 100% miner support, no proposals can be created to reset fees, requiring hard fork to recover.

### Notes

The vulnerability's severity stems from the combination of: (1) lack of upper bounds on fees, (2) lack of emergency recovery mechanisms, and (3) the self-referential nature of governance - fees on governance methods prevent governance from fixing itself. While consensus operations remain functional (block production continues), all user-facing and governance operations are permanently disabled, effectively rendering the chain unusable without hard fork intervention.

### Citations

**File:** contract/AElf.Contracts.Configuration/ConfigurationState.cs (L10-10)
```csharp
    public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L11-21)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L51-65)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L79-88)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L38-52)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (new List<string>
            {
                nameof(InitialAElfConsensusContract), nameof(FirstRound), nameof(UpdateValue),
                nameof(UpdateTinyBlockInformation), nameof(NextRound), nameof(NextTerm)
            }.Contains(input.Value))
            return new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };

        return State.TransactionFees[input.Value];
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L118-126)
```csharp
        ModifyBalance(fromAddress, bill, allowanceBill);
        var chargingOutput = new ChargeTransactionFeesOutput { Success = chargingResult };
        if (!chargingResult)
            chargingOutput.ChargingInformation = "Transaction fee not enough.";
        
        Context.LogDebug(() => "TryToChargeTransactionFee End");
        Context.LogDebug(() => "ChargeTransactionFees End");
        return chargingOutput;
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_Helper.cs (L32-43)
```csharp
    private void AssertPerformedByConfigurationControllerOrZeroContract()
    {
        if (State.ConfigurationController.Value == null)
        {
            var defaultConfigurationController = GetDefaultConfigurationController();
            State.ConfigurationController.Value = defaultConfigurationController;
        }

        Assert(
            State.ConfigurationController.Value.OwnerAddress == Context.Sender ||
            Context.GetZeroSmartContractAddress() == Context.Sender, "No permission.");
    }
```
