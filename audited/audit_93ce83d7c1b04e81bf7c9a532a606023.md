### Title
Insufficient Governance Validation Allows Parliament to Set Single-Address Controller for Transfer Blacklist

### Summary
The `ChangeTransferBlackListController()` function only validates that an organization exists, not its governance parameters. Parliament can create and set a single-member Association organization as the TransferBlackListController, enabling that single address to unilaterally blacklist any user without multi-party oversight, effectively freezing their token operations.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:**
The `ChangeTransferBlackListController()` function calls `CheckOrganizationExist(input)` to validate the new controller [2](#0-1) , but this validation is insufficient.

The `CheckOrganizationExist()` implementation only performs an existence check: [3](#0-2) 

This calls `ValidateOrganizationExist` on the authorization contract, which merely checks: [4](#0-3) 

**Why Protections Fail:**
The validation does NOT verify:
- The organization type (Parliament, Association, Referendum)
- The number of members in the organization
- The approval thresholds required for proposals
- Whether the organization has multi-party governance

Association organizations allow single-member configurations based on the validation logic: [5](#0-4) 

This validation permits organizations with only 1 member and `MinimalApprovalThreshold = 1`, creating a single-address controller.

**Execution Path:**
1. Parliament (or any actor) creates a single-member Association organization via public `CreateOrganization()`
2. Parliament calls `ChangeTransferBlackListController()` with this Association's AuthorityInfo
3. The single-member controller can now call `AddToTransferBlackList()` or `BatchAddToTransferBlackList()`: [6](#0-5) 

These functions only check `AssertControllerForTransferBlackList()`, which validates the sender is the controller's owner address, without verifying multi-party approval.

### Impact Explanation

**Harm:**
Addresses added to the transfer blacklist lose critical operational capabilities:

1. **Cannot transfer tokens:** [7](#0-6) 

2. **Cannot perform cross-chain transfers:** [8](#0-7) 

3. **Cannot pay transaction fees** (effectively bricking the account): [9](#0-8) 

**Affected Parties:**
Any user can be arbitrarily blacklisted by the single-address controller, causing complete loss of token functionality.

**Severity Justification:**
While removal from the blacklist requires Parliament approval: [10](#0-9) 

The damage is **instantaneous and unilateral** when adding to the blacklist. This violates the governance principle that critical operations affecting user funds should require multi-party consensus. A malicious or compromised single-address controller can freeze arbitrary users' accounts before detection or intervention.

### Likelihood Explanation

**Attacker Capabilities:**
Parliament already has authority to call `ChangeTransferBlackListController()`, so no privilege escalation is required. Association organizations are publicly creatable without restrictions.

**Attack Complexity:**
Low - the exploit requires only:
1. Create single-member Association (public operation)
2. Parliament proposal to change controller (standard governance)
3. Single-address controller blacklists users (single transaction)

**Feasibility Conditions:**
- Parliament must approve the controller change (realistic as Parliament may legitimately seek faster blacklist response)
- No technical barriers exist
- The system explicitly allows this configuration through its validation logic

**Detection/Operational Constraints:**
The controller change is visible on-chain, but once set, the single-address controller operates with no delay or oversight for additions. By the time malicious blacklisting is detected, users are already frozen.

### Recommendation

**Code-Level Mitigation:**
Enhance `ChangeTransferBlackListController()` to validate governance parameters:

```csharp
public override Empty ChangeTransferBlackListController(AuthorityInfo input)
{
    AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    // NEW: Validate organization has appropriate governance
    ValidateControllerGovernance(input);
    
    State.TransferBlackListController.Value = input;
    return new Empty();
}

private void ValidateControllerGovernance(AuthorityInfo input)
{
    // Ensure controller is Parliament or multi-sig Association/Referendum
    // Require minimum member count (e.g., >= 3)
    // Require minimum approval threshold (e.g., >= 2)
    // Can call organization contracts to query their governance parameters
}
```

**Invariant Checks:**
- TransferBlackListController must always be a multi-party governance organization
- Minimum member count threshold (e.g., 3 members)
- Minimum approval threshold (e.g., 2 approvals)

**Test Cases:**
1. Attempt to set single-member Association as controller → should fail
2. Attempt to set Association with MinimalApprovalThreshold=1 → should fail
3. Verify only properly-governed organizations (Parliament, multi-sig Association) can be set as controller

### Proof of Concept

**Required Initial State:**
- Parliament contract deployed and initialized
- Association contract deployed and initialized
- MultiToken contract deployed with default Parliament controller

**Transaction Steps:**

1. **Create Single-Member Association:**
   - Caller: Any address (Alice)
   - Contract: Association.CreateOrganization()
   - Input: `CreateOrganizationInput` with:
     - `OrganizationMemberList`: [Alice]
     - `ProposalReleaseThreshold.MinimalApprovalThreshold`: 1
     - `ProposalReleaseThreshold.MinimalVoteThreshold`: 1
     - `ProposerWhiteList`: [Alice]
   - Result: Returns single-member Association address

2. **Parliament Sets New Controller:**
   - Caller: Parliament (via proposal → approval → release)
   - Contract: TokenContract.ChangeTransferBlackListController()
   - Input: `AuthorityInfo` with:
     - `ContractAddress`: Association contract address
     - `OwnerAddress`: Single-member organization address from step 1
   - Result: Transaction succeeds, controller changed

3. **Single Address Blacklists Users:**
   - Caller: Alice (single controller member)
   - Contract: TokenContract.AddToTransferBlackList() or BatchAddToTransferBlackList()
   - Input: Target user addresses (Bob, Carol, etc.)
   - Result: Users immediately blacklisted without multi-party approval

**Expected vs Actual Result:**
- **Expected:** Setting a controller should require validation of multi-party governance
- **Actual:** Single-address controller is accepted and can unilaterally blacklist users

**Success Condition:**
After step 3, blacklisted addresses cannot transfer tokens, perform cross-chain operations, or pay transaction fees, with no multi-party approval required for the blacklisting action.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L90-97)
```csharp
    public override Empty ChangeTransferBlackListController(AuthorityInfo input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.TransferBlackListController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L560-563)
```csharp
    public override Empty CrossChainTransfer(CrossChainTransferInput input)
    {
        Assert(!IsInTransferBlackListInternal(Context.Sender), "Sender is in transfer blacklist.");
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L854-880)
```csharp
    public override Empty AddToTransferBlackList(Address input)
    {
        AssertControllerForTransferBlackList();
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid address.");
        State.TransferBlackList[input] = true;
        return new Empty();
    }

    public override Empty BatchAddToTransferBlackList(BatchAddToTransferBlackListInput input)
    {
        AssertControllerForTransferBlackList();
        Assert(input != null && input.Addresses != null && input.Addresses.Count > 0, "Invalid input.");
        
        // Validate all addresses first
        foreach (var address in input.Addresses)
        {
            Assert(address != null && !address.Value.IsNullOrEmpty(), "Invalid address.");
        }
        
        // Remove duplicates and add to blacklist
        var uniqueAddresses = input.Addresses.Distinct().ToList();
        foreach (var address in uniqueAddresses)
        {
            State.TransferBlackList[address] = true;
        }
        
        return new Empty();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L883-890)
```csharp
    public override Empty RemoveFromTransferBlackList(Address input)
    {
        // Removing from transfer blacklist requires higher security and response speed is not critical, 
        // so it should be controlled by Parliament.
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid address.");
        State.TransferBlackList[input] = false;
        return new Empty();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L99-103)
```csharp
    private void DoTransfer(Address from, Address to, string symbol, long amount, string memo = null)
    {
        Assert(!IsInTransferBlackListInternal(from), "From address is in transfer blacklist.");
        Assert(from != to, "Can't do transfer to sender itself.");
        AssertValidMemo(memo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L237-240)
```csharp
    private void ModifyBalance(Address fromAddress, TransactionFeeBill bill,
        TransactionFreeFeeAllowanceBill allowanceBill)
    {
        Assert(!IsInTransferBlackListInternal(fromAddress), "Charge fee address is in transfer blacklist.");
```
