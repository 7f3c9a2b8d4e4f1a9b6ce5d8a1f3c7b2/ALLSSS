### Title
Missing Authorization Validation in NextTerm Allows Unauthorized Miner List Installation and Premature Term Transitions

### Summary
The `NextTerm` transaction execution lacks critical validation to verify (1) whether term transition timing conditions are actually met, and (2) whether the provided miner list matches the election results. Any current miner can exploit this to install an arbitrary miner list and force premature term transitions, completely bypassing the election-based governance mechanism.

### Finding Description

**Location:** 
- `contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs` line 177
- `contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs` lines 161-221
- `contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs` lines 89-91

**Root Cause:**

The consensus design has a critical gap between command generation and execution validation. While `GetConsensusCommand` uses `NeedToChangeTerm` to determine when term transitions should occur based on timing conditions [1](#0-0) , this check is **never enforced** during transaction validation or execution.

When `ValidateBeforeExecution` processes a NextTerm behavior, it only adds `RoundTerminateValidationProvider` [2](#0-1) . This provider only validates that the term number increments by exactly 1 [3](#0-2) , but does NOT check:
- Whether `NeedToChangeTerm` timing conditions are satisfied
- Whether the miner list in the input matches election results from `GetVictories`

During execution, `ProcessNextTerm` directly installs the miner list from the input without any validation [4](#0-3) . The function calls `GenerateFirstRoundOfNextTerm` during normal consensus command generation to get the proper miner list from the Election contract [5](#0-4) , but this validation is **completely bypassed** when a miner crafts their own NextTerm transaction.

The `PreCheck` authorization only verifies the sender is in the current OR previous round's miner list [6](#0-5) , which is insufficient - it doesn't validate whether the sender is authorized to perform a term transition at this specific time or with this specific miner list.

**Why Existing Protections Fail:**

1. `MiningPermissionValidationProvider` only checks if sender is in current round's miner list [7](#0-6) 

2. `TimeSlotValidationProvider` only validates time slot scheduling, not term transition timing [8](#0-7) 

3. The `NeedToChangeTerm` condition that checks timing based on blockchain age and period [9](#0-8)  is never invoked during validation or execution

4. No validation compares the provided miner list against `State.ElectionContract.GetVictories` results

### Impact Explanation

**Consensus Integrity Compromise:**
- **Unauthorized Miner List Installation**: An attacker can install an arbitrary miner list (e.g., all themselves, or excluding competitors) completely bypassing the election-based governance mechanism
- **Premature Term Transitions**: Terms can be changed before the proper timing conditions are met, disrupting the intended term duration and election cycle
- **Reward Misallocation**: Treasury releases and mining rewards get distributed based on the fraudulent term transition [10](#0-9) 

**Governance Subversion:**
The election system becomes meaningless if any current miner can install their own miner list. This breaks the fundamental assumption that miner selection is determined by token holder voting through the Election contract.

**Protocol Damage:**
- Election snapshots are taken with incorrect state [11](#0-10) 
- Treasury periods get advanced prematurely [12](#0-11) 
- Miner performance tracking becomes corrupted

**Severity: HIGH** - Direct compromise of consensus mechanism integrity and governance bypass with realistic exploitability.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be in the current round's miner list (realistic - there are multiple miners)
- Must be able to construct a valid Round structure (straightforward - can copy from legitimate round generation)
- Must be able to submit transactions (standard miner capability)

**Attack Complexity: LOW**
1. Attacker waits for their time slot
2. Instead of following the consensus command from `GetConsensusCommand`, they craft a custom NextTerm transaction
3. Set `NextTermInput.TermNumber = CurrentTermNumber + 1`
4. Set `NextTermInput.Round` with fraudulent miner list (e.g., only attacker's pubkey repeated, or excluding competitors)
5. Submit transaction during their time slot
6. All validations pass because they only check term number increment and miner authorization, not timing conditions or miner list correctness

**Feasibility Conditions:**
- Attacker is a current miner (one of ~17-21 miners typically)
- It's the attacker's time slot (happens regularly in rotation)
- No additional trust assumptions required

**Detection Constraints:**
The attack succeeds silently - the NextTerm transaction appears valid to all validators since validation only checks term number increment. Other nodes would accept the fraudulent term transition as legitimate.

**Economic Rationality:**
If an attacker can install themselves as the sole miner or exclude competitors, they gain:
- All future mining rewards
- Control over block production
- Ability to censor transactions
The benefit far exceeds the cost of being a single miner in the current term.

**Probability: HIGH** - The attack is straightforward to execute, requires only standard miner privileges, and has no complex preconditions.

### Recommendation

**Immediate Fixes Required:**

1. **Add Term Timing Validation** in `ValidateBeforeExecution`:
```
In AEDPoSContract_Validation.cs, for NextTerm behavior, add validation:
    - Call NeedToChangeTerm with current round, blockchain start timestamp, current term number, and period seconds
    - Assert the result is true before allowing NextTerm execution
    - This ensures term transitions only occur when timing conditions are actually met
```

2. **Add Miner List Validation** in `ValidationForNextTerm` or `ProcessNextTerm`:
```
In RoundTerminateValidationProvider.cs or ProcessNextTerm:
    - Call State.ElectionContract.GetVictories to get the official election results
    - Compare the miner list in NextTermInput against the election winners
    - Assert they match exactly (accounting for proper ordering/structure)
    - This ensures only election-validated miner lists can be installed
```

3. **Strengthen PreCheck Authorization**:
```
In PreCheck method:
    - Add validation that term change timing conditions are met
    - Add check that the behavior matches what GetConsensusCommand would return
    - Verify the sender is the designated miner for term transition (not just any miner)
```

**Invariant Checks to Add:**
- `Assert(currentRound.NeedToChangeTerm(...), "Term transition timing conditions not met")`
- `Assert(VerifyMinerListMatchesElection(input.Round), "Miner list does not match election results")`
- `Assert(IsAuthorizedForTermTransition(sender, currentRound), "Not authorized to perform term transition")`

**Test Cases to Prevent Regression:**
- Test that NextTerm fails when called before timing conditions are met
- Test that NextTerm fails with miner list not matching election results  
- Test that only the proper designated miner can perform term transitions
- Test that premature NextTerm attempts are rejected at validation stage

### Proof of Concept

**Initial State:**
- Current term number: 1
- Current round has 7 miners: [A, B, C, D, E, F, G]
- Blockchain age < period required for term change (e.g., 6 days into 7-day period)
- Election contract has different winners ready: [X, Y, Z, W, V, U, T]
- Attacker is miner C in current round

**Attack Steps:**

1. **During miner C's time slot**, instead of following normal consensus command, construct malicious NextTerm:
   ```
   NextTermInput:
     - TermNumber = 2 (current + 1)
     - RoundNumber = currentRound + 1  
     - Round.RealTimeMinersInformation = [C, C, C, C, C, C, C] (all attacker)
     - RandomNumber = valid VRF proof
   ```

2. **Submit NextTerm transaction** to consensus contract [13](#0-12) 

3. **Validation passes** because:
   - C is in current miner list ✓ (MiningPermissionValidationProvider passes)
   - It's C's time slot ✓ (TimeSlotValidationProvider passes)
   - Term number = 1 + 1 = 2 ✓ (RoundTerminateValidationProvider passes)
   - C is in current round ✓ (PreCheck passes)

4. **Execution succeeds** [14](#0-13) :
   - Miner list [C, C, C, C, C, C, C] directly installed
   - Term number updated to 2
   - Treasury release triggered
   - Election snapshot taken

**Expected Result:** 
NextTerm should be rejected because:
- Timing conditions not met (blockchain age insufficient)
- Miner list doesn't match election results [X, Y, Z, W, V, U, T]

**Actual Result:**
NextTerm succeeds, installing attacker as all miners for term 2, bypassing election completely and allowing premature term transition.

**Success Condition:**
After exploitation, `State.MinerListMap[2]` contains only attacker C's pubkey, giving them complete control of consensus for the new term, and term transition occurred before timing conditions warranted it.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-256)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-51)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }

    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-243)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }

    /// <summary>
    ///     If periodSeconds == 7:
    ///     1, 1, 1 => 0 != 1 - 1 => false
    ///     1, 2, 1 => 0 != 1 - 1 => false
    ///     1, 8, 1 => 1 != 1 - 1 => true => term number will be 2
    ///     1, 9, 2 => 1 != 2 - 1 => false
    ///     1, 15, 2 => 2 != 2 - 1 => true => term number will be 3.
    /// </summary>
    /// <param name="blockchainStartTimestamp"></param>
    /// <param name="termNumber"></param>
    /// <param name="blockProducedTimestamp"></param>
    /// <param name="periodSeconds"></param>
    /// <returns></returns>
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
