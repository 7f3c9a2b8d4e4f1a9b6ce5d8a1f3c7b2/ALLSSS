### Title
Missing Zero Address Validation in TokenHolder AddBeneficiary Allows Permanent Profit Loss

### Summary
The `AddBeneficiary` function in TokenHolderContract does not validate that `input.Beneficiary` is a non-zero address before adding it to the profit scheme. This allows a zero address to be registered as a beneficiary, which will permanently lock its allocated share of profits since tokens cannot be transferred to the zero address, effectively burning those rewards and diluting legitimate beneficiaries' shares.

### Finding Description
The TokenHolder contract's `AddBeneficiary` function accepts `AddTokenHolderBeneficiaryInput` and directly uses `input.Beneficiary` without validating it is a non-zero address. [1](#0-0) 

The function delegates to the Profit contract's `AddBeneficiary`, which only validates the beneficiary is not null but does NOT check for zero address: [2](#0-1) 

The codebase establishes a clear validation pattern for zero addresses using `address.Value.Any()`: [3](#0-2) [4](#0-3) 

When profits are claimed for a zero address beneficiary, the transfer fails because the MultiToken contract validates addresses: [5](#0-4) 

This validation is triggered through the call chain: Transfer → DoTransfer → ModifyBalance → GetBalance → AssertValidInputAddress.

### Impact Explanation
**Direct Fund Loss**: When a zero address is added as beneficiary with shares, it receives a proportional allocation of all distributed profits. Since tokens cannot be transferred to the zero address (the transfer reverts), these allocated profits remain permanently locked in the period virtual addresses and are effectively burned.

**Dilution of Legitimate Beneficiaries**: If a zero address holds X% of total shares, then X% of all distributed profits are permanently lost. For example, if the zero address has 100 shares out of 1000 total shares, 10% of all profits distributed through the scheme are irrecoverable.

**Who is Affected**: All legitimate beneficiaries lose their proportional share of the profits that would have been available if the zero address had not been allocated shares.

**Severity Justification**: Medium - While this requires the scheme manager to add the zero address (either maliciously or by error), it results in permanent loss of a portion of all future profits, with no recovery mechanism except removing the beneficiary and redistributing shares.

### Likelihood Explanation
**Attacker Capabilities**: The scheme manager (typically the scheme creator) must call `AddBeneficiary` with a zero address. This could occur through:
- Programming error in automated beneficiary management
- Malicious manager seeking to reduce profit distribution to legitimate beneficiaries
- Uninitialized address variable being passed

**Attack Complexity**: Low - requires a single transaction calling `AddBeneficiary` with a zero address beneficiary and non-zero shares.

**Feasibility Conditions**: The manager must have already created a TokenHolder scheme. The authority check is enforced: [6](#0-5) 

**Detection**: The issue manifests when `ClaimProfits` is called for the zero address beneficiary and fails. However, the locked profits are not easily detectable as they remain in period virtual addresses.

**Probability**: Medium - while requiring manager access, the lack of input validation makes this exploitable through simple programming errors or malicious intent.

### Recommendation
Add zero address validation in the `AddBeneficiary` function before delegating to the Profit contract:

```csharp
public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
{
    Assert(input.Beneficiary != null && input.Beneficiary.Value.Any(), 
        "Invalid beneficiary address.");
    
    var scheme = GetValidScheme(Context.Sender);
    // ... rest of implementation
}
```

Additionally, add the same validation to the Profit contract's `AssertValidInput` method:

```csharp
private void AssertValidInput(AddBeneficiaryInput input)
{
    Assert(input.SchemeId != null, "Invalid scheme id.");
    Assert(input.BeneficiaryShare?.Beneficiary != null, "Invalid beneficiary address.");
    Assert(input.BeneficiaryShare?.Beneficiary.Value.Any(), "Invalid beneficiary address.");
    Assert(input.BeneficiaryShare?.Shares >= 0, "Invalid share.");
}
```

**Test Cases**: Add test cases verifying that:
1. `AddBeneficiary` with `new Address()` (zero address) is rejected
2. `AddBeneficiary` with null address is rejected
3. Valid addresses continue to work normally

### Proof of Concept
**Initial State**: 
- Scheme manager has created a TokenHolder profit scheme
- 1000 tokens are ready to be distributed

**Attack Steps**:
1. Manager calls `AddBeneficiary` with:
   - Beneficiary: `new Address()` (zero address)
   - Shares: 100
2. Manager calls `AddBeneficiary` with legitimate beneficiary:
   - Beneficiary: User1
   - Shares: 900
3. Manager calls `DistributeProfits` to distribute 1000 tokens
4. User1 calls `ClaimProfits` and receives 900 tokens (90%)
5. Anyone attempts to call `ClaimProfits` for zero address - transaction fails with "Invalid input address"

**Expected Result**: `AddBeneficiary` should reject zero address in step 1

**Actual Result**: Zero address is accepted as beneficiary, and 100 tokens (10% of profits) are permanently locked and cannot be claimed

**Success Condition**: After full profit distribution cycle, only 900 tokens out of 1000 are claimable by legitimate beneficiaries, with 100 tokens permanently locked in period virtual addresses allocated to the zero address beneficiary.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-68)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }

        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = shares
            }
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L217-222)
```csharp
    private void AssertValidInput(AddBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.BeneficiaryShare?.Beneficiary != null, "Invalid beneficiary address.");
        Assert(input.BeneficiaryShare?.Shares >= 0, "Invalid share.");
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L730-730)
```csharp
        Assert(input.NewManager.Value.Any(), "Invalid new sponsor.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L101-101)
```csharp
        Assert(input.Value.Any(), "Admin is needed while announcing election.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```
