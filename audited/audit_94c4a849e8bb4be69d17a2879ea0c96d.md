### Title
Unvalidated DecryptedPieces Allow Manipulation of Revealed InValues in Secret Sharing Consensus

### Summary
The `ExtractInformationToUpdateConsensus()` function collects DecryptedPieces from miners without cryptographic validation, and these pieces are stored on-chain via `PerformSecretSharing()`. When DecryptedPieces are later used to reconstruct InValues through secret sharing (via `RevealSharedInValues()` or off-chain `RevealPreviousInValues()`), there is no validation that the reconstructed value matches the original miner's InValue or OutValue. This allows malicious miners to provide corrupted decrypted pieces that will cause incorrect InValue reconstruction, affecting consensus randomness and signature calculations for offline miners.

### Finding Description

**Collection without validation:**
In `ExtractInformationToUpdateConsensus()`, DecryptedPieces are collected from the round information without any cryptographic validation of their correctness. [1](#0-0) 

**Storage without validation:**
These unvalidated DecryptedPieces are directly stored into other miners' records in the `PerformSecretSharing()` method during UpdateValue processing, with no verification that they are legitimate decryptions. [2](#0-1) 

**On-chain reconstruction without validation:**
When `RevealSharedInValues()` reconstructs a miner's InValue using Shamir's Secret Sharing, it calls `SecretSharingHelper.DecodeSecret()` with the stored DecryptedPieces but never validates that the reconstructed InValue matches the original. [3](#0-2) 

There is no check that `HashHelper.ComputeFrom(revealedInValue) == previousRound.OutValue`, which would verify the reconstruction's correctness.

**Off-chain reconstruction without validation:**
The off-chain `RevealPreviousInValues()` service performs identical reconstruction without validation. [4](#0-3) 

**Usage in consensus:**
When `SupplyCurrentRoundInformation()` is called during NextRound/NextTerm processing, it uses the revealed (potentially corrupted) PreviousInValue for miners who didn't mine, affecting their signature calculation and InValue assignment. [5](#0-4) 

**Root cause:**
Shamir's Secret Sharing reconstruction is deterministic but not self-validating. If any piece used in reconstruction is corrupted, the entire reconstructed secret will be incorrect. The protocol assumes DecryptedPieces are honest but provides no cryptographic proof mechanism.

### Impact Explanation

**Consensus integrity compromise:**
A malicious miner can manipulate the revealed InValues for target miners who fail to produce blocks, directly affecting:
1. Signature calculations used in consensus randomness generation
2. InValue assignments that should cryptographically match previous OutValues  
3. Next round ordering via the signature-based calculation in `CalculateNextExtraBlockProducerOrder()` [6](#0-5) 

**Affected parties:**
- Offline or Byzantine-faulted miners whose InValues are reconstructed via secret sharing
- All network participants who depend on consensus randomness for fair ordering
- The integrity of the LIB (Last Irreversible Block) height calculations that depend on correct round progression

**Severity justification:**
This is a HIGH severity issue because it violates the fundamental consensus invariant that reconstructed InValues must match original committed values. While the attack requires the target miner to be offline, this is a realistic scenario in distributed systems, and the manipulation affects core consensus security properties including randomness and fairness.

### Likelihood Explanation

**Attacker capabilities:**
- Attacker must be an active miner with block production rights
- Can submit UpdateValue transactions with arbitrary DecryptedPieces
- No additional privileges required beyond being in the miner set

**Attack complexity:**
- LOW - Simply provide corrupted byte arrays as DecryptedPieces in UpdateValue call
- The corrupted pieces are stored on-chain without validation
- Reconstruction is deterministic, so all nodes compute the same incorrect result

**Feasibility conditions:**
- Target miner must not produce blocks in the round (missed time slot)
- Attacker's corrupted piece must be included in reconstruction (highly likely since threshold is 2/3 of miners)
- Secret sharing must be enabled via configuration

**Attack sequence:**
1. Attacker calls `UpdateValue()` with corrupted DecryptedPieces for Target [7](#0-6) 

2. Corrupted pieces stored on-chain
3. When NextRound is processed, `SupplyCurrentRoundInformation()` called [8](#0-7) 

4. Target's InValue reconstructed from corrupted pieces, affecting consensus

**Probability reasoning:**
MEDIUM-HIGH likelihood - Miner downtime is common in distributed consensus systems, and the attack is straightforward to execute. The only constraint is that the attacker must be an active miner.

### Recommendation

**Add cryptographic validation after reconstruction:**

In `RevealSharedInValues()` and `RevealPreviousInValues()`, after reconstructing the InValue, validate it against the miner's previous OutValue:

```
var revealedInValue = HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// Add validation
if (previousRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].OutValue != null)
{
    var expectedHash = HashHelper.ComputeFrom(revealedInValue);
    if (expectedHash != previousRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].OutValue)
    {
        Context.LogDebug(() => $"Invalid revealed in value for {publicKeyOfAnotherMiner}");
        continue; // Skip this invalid revelation
    }
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**Invariant to enforce:**
`Hash(RevealedInValue) == PreviousRound.OutValue` for all revealed InValues.

**Test cases:**
1. Test that corrupted DecryptedPieces fail reconstruction validation
2. Test that only valid DecryptedPieces result in PreviousInValue being set
3. Test that miners with invalid revelations are handled gracefully
4. Test reconstruction with mixed valid/invalid pieces

### Proof of Concept

**Initial state:**
- Secret sharing enabled in configuration
- Miner A (attacker), Miner B (target), and other honest miners in current round
- Miner B produced block in Round N with InValue_B and OutValue_B = Hash(InValue_B)

**Attack steps:**
1. Round N+1 begins
2. Miner B goes offline (misses time slot)
3. Miner A calls `UpdateValue()` for Round N+1, including:
   - `DecryptedPieces[B] = corrupted_bytes` (not the legitimate decryption of B's encrypted piece)
4. `PerformSecretSharing()` stores corrupted piece: `round.RealTimeMinersInformation[B].DecryptedPieces[A] = corrupted_bytes`
5. Miner C triggers `NextRound()` for Round N+2
6. `SupplyCurrentRoundInformation()` is called
7. For offline Miner B, it retrieves `PreviousInValue` from current round (which may have been set by revealed values)
8. Off-chain or during previous block generation, `RevealSharedInValues()` reconstructed incorrect InValue using corrupted pieces
9. Result: Miner B's signature calculated as `previousRound.CalculateSignature(corrupted_InValue)` instead of correct value

**Expected vs Actual:**
- **Expected:** Miner B's InValue reconstructed to original InValue_B, with Hash(InValue_B) == OutValue_B
- **Actual:** Miner B's InValue reconstructed to corrupted value, with Hash(corrupted_value) != OutValue_B

**Success condition:**
The attack succeeds if the revealed PreviousInValue for Miner B does not match their original InValue_B from Round N, yet is still used in consensus calculations without triggering validation failures.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L26-28)
```csharp
        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-257)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L46-52)
```csharp
            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L172-180)
```csharp
            var sharedParts = minerInRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            Logger.LogDebug($"Revealed in value of {pubkey} of round {round.RoundNumber}: {revealedInValue}");

            revealedInValues[pubkey] = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-165)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
