# Audit Report

## Title
Proposer Whitelist Validation Bypass Allows Organization DoS via Empty Addresses

## Summary
The Referendum contract's whitelist validation only checks the count of addresses, not their validity. This allows an attacker to set a proposer whitelist containing only empty addresses (e.g., `new Address()` with no byte value), which passes validation but permanently breaks proposal authorization, causing irreversible denial-of-service of the organization's governance capabilities.

## Finding Description

The vulnerability stems from insufficient validation in the proposer whitelist mechanism. The `Empty()` extension method only verifies that the whitelist contains at least one address by checking the count, without validating that those addresses have non-empty `Value` fields. [1](#0-0) 

The `Validate()` function in the Referendum contract relies on this flawed `Empty()` check when validating organization state: [2](#0-1) 

When `ChangeOrganizationProposerWhiteList` is called through a governance proposal, it updates the whitelist and validates using `Validate(organization)`, but this validation only ensures the list is not empty by count, not by content validity: [3](#0-2) 

Unlike other contracts in the codebase that properly validate addresses (checking both null and empty Value), the Referendum whitelist validation lacks this critical check: [4](#0-3) [5](#0-4) 

**Attack Execution Path:**

1. Attacker (who is an authorized proposer) creates a proposal calling `ChangeOrganizationProposerWhiteList` with `ProposerWhiteList { Proposers = { new Address() } }`
2. Proposal gets approved through token-weighted voting
3. Proposer releases the proposal, executing the whitelist change
4. Validation passes because count > 0 (the `Empty()` check returns false)
5. Organization state is updated with the invalid whitelist
6. All subsequent `CreateProposal` calls fail at authorization check: [6](#0-5) 

The `Contains()` method uses protobuf Address equality, which compares the `Value` fields. Since an empty Address (with `Value = ByteString.Empty`) will never equal any valid address (with actual byte data), the authorization check always fails: [7](#0-6) [8](#0-7) 

The Address type definition confirms that addresses can be instantiated empty (protobuf provides parameterless constructor), creating an Address with an empty `Value` field: [9](#0-8) 

## Impact Explanation

**HIGH Severity** - This vulnerability causes permanent, irreversible denial-of-service of critical governance functionality:

- **Operational Impact**: The organization becomes completely unable to create new proposals. All `CreateProposal` calls will fail with "Unauthorized to propose" because no valid address can match the empty addresses in the whitelist.

- **Governance Impact**: The organization is effectively bricked. It cannot execute any governance actions that require new proposals, including attempts to fix the whitelist itself. The organization has lost its core governance capability permanently.

- **Affected Parties**: All members of the affected Referendum organization lose their governance rights and cannot participate in decision-making.

The test suite confirms that completely empty whitelists (count=0) should be rejected, indicating that invalid whitelists are not intended behavior: [10](#0-9) 

The prevalence of proper address validation patterns elsewhere in the codebase (BasicContractZero, MultiToken) confirms this is an unintended security gap rather than intended behavior.

## Likelihood Explanation

**MEDIUM Likelihood** - The attack is feasible but requires specific conditions:

**Attacker Capabilities Required:**
- Must be an authorized proposer in the target Referendum organization
- Must convince token holders to approve the malicious proposal through token-weighted voting

**Attack Complexity:**
- LOW technical complexity: Simply create a single proposal with `new Address()` in the whitelist
- Protobuf messages support default instantiation, allowing empty Address objects to be created and transmitted
- The attack could be disguised within a complex proposal or executed by a compromised proposer account

**Feasibility Assessment:**
- Realistic in governance attack scenarios where an insider has proposer privileges
- Requires governance participation (token-weighted voting approval), but achievable
- Once executed, the damage is permanent and cannot be reversed through normal governance mechanisms

This represents a credible threat in scenarios involving:
- Malicious insiders with proposer privileges
- Compromised proposer accounts
- Social engineering to get voters to approve seemingly legitimate proposals

## Recommendation

Add explicit validation to ensure all addresses in the proposer whitelist have non-empty `Value` fields. Modify the `Validate()` function in `Referendum_Helper.cs`:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    
    // Add validation for address validity
    foreach (var proposer in organization.ProposerWhiteList.Proposers)
    {
        if (proposer == null || proposer.Value.IsNullOrEmpty())
            return false;
    }
    
    Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

Alternatively, add a validation extension method to `ProposerWhiteListExtensions.cs`:

```csharp
public static bool HasInvalidAddresses(this ProposerWhiteList proposerWhiteList)
{
    return proposerWhiteList.Proposers.Any(p => p == null || p.Value.IsNullOrEmpty());
}
```

Then use it in the Validate function:
```csharp
if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
    organization.OrganizationHash == null || organization.ProposerWhiteList.Empty() ||
    organization.ProposerWhiteList.HasInvalidAddresses())
    return false;
```

## Proof of Concept

```csharp
[Fact]
public async Task ChangeOrganizationProposerWhiteList_WithEmptyAddress_ShouldFail()
{
    // Setup: Create organization with valid proposer
    var organizationAddress = await CreateOrganizationAsync(5000, 5000, 10000, 10000, new[] { DefaultSender });
    
    // Attack: Create proposal to change whitelist to contain only empty address
    var emptyAddressWhitelist = new ProposerWhiteList
    {
        Proposers = { new Address() }  // Empty address with no byte value
    };
    
    var proposalId = await CreateReferendumProposalAsync(
        DefaultSenderKeyPair,
        emptyAddressWhitelist,
        nameof(ReferendumContractStub.ChangeOrganizationProposerWhiteList),
        organizationAddress,
        ReferendumContractAddress);
    
    // Approve and release the malicious proposal
    await ApproveAllowanceAsync(Accounts[3].KeyPair, 5000, proposalId);
    await ApproveAsync(Accounts[3].KeyPair, proposalId);
    var releaseResult = await ReferendumContractStub.Release.SendAsync(proposalId);
    
    // This should fail but currently succeeds due to insufficient validation
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Invalid organization");
    
    // Verify: Try to create a new proposal - should fail permanently
    var newProposalInput = new CreateProposalInput
    {
        ToAddress = TokenContractAddress,
        ContractMethodName = "Transfer",
        Params = ByteString.Empty,
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        OrganizationAddress = organizationAddress
    };
    
    var createResult = await ReferendumContractStub.CreateProposal.SendWithExceptionAsync(newProposalInput);
    createResult.TransactionResult.Error.ShouldContain("Unauthorized to propose");
}
```

## Notes

This vulnerability also affects the Association contract, which uses identical validation patterns. The same fix should be applied to `contract/AElf.Contracts.Association/Association_Helper.cs` to prevent similar attacks on Association organizations.

### Citations

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L13-16)
```csharp
    public static bool Empty(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Count() == 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L18-21)
```csharp
    public static bool Contains(this ProposerWhiteList proposerWhiteList, Address address)
    {
        return proposerWhiteList.Proposers.Contains(address);
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L397-401)
```csharp
        Assert(contractOperation.Deployer != null && !contractOperation.Deployer.Value.IsNullOrEmpty(),
            "Invalid input deploying address.");
        Assert(contractOperation.Salt != null && !contractOperation.Salt.Value.IsNullOrEmpty(), "Invalid input salt.");
        Assert(contractOperation.CodeHash != null && !contractOperation.CodeHash.Value.IsNullOrEmpty(),
            "Invalid input code hash.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L646-647)
```csharp
        Assert(input.Issuer != null && !input.Issuer.Value.IsNullOrEmpty(), "Invalid input issuer.");
        Assert(input.Owner != null && !input.Owner.Value.IsNullOrEmpty(), "Invalid input owner.");
```

**File:** src/AElf.Types/Types/Address.cs (L96-99)
```csharp
        public static bool operator ==(Address address1, Address address2)
        {
            return address1?.Equals(address2) ?? ReferenceEquals(address2, null);
        }
```

**File:** protobuf/aelf/core.proto (L135-138)
```text
message Address
{
    bytes value = 1;
}
```

**File:** test/AElf.Contracts.Referendum.Tests/ReferendumContractTest.cs (L774-788)
```csharp
        // invalid proposal whitelist
        {
            var organizationAddress = await CreateOrganizationAsync();
            var newProposalWhitelist = new ProposerWhiteList();
            var changeProposerWhitelistProposalId = await CreateReferendumProposalAsync(DefaultSenderKeyPair,
                newProposalWhitelist,
                nameof(ReferendumContractStub.ChangeOrganizationProposerWhiteList), organizationAddress,
                ReferendumContractAddress);
            var keyPair = Accounts[3].KeyPair;
            await ApproveAllowanceAsync(keyPair, 5000, changeProposerWhitelistProposalId);
            await ApproveAsync(keyPair, changeProposerWhitelistProposalId);
            var ret = await ReferendumContractStub.Release.SendWithExceptionAsync(
                changeProposerWhitelistProposalId);
            ret.TransactionResult.Error.ShouldContain("Invalid organization");
        }
```
