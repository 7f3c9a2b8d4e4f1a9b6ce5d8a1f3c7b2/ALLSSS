# Audit Report

## Title
Parliament Can Forcibly Seize Control of Any Candidate Through Unchecked Admin Override

## Summary
The `SetCandidateAdmin()` function in the Election contract grants Parliament unrestricted authority to forcibly change any candidate's admin address without requiring consent from the candidate or current admin. This mis-scoped privilege allows Parliament to subsequently force candidates to quit elections, replace their public keys, and redirect their mining rewards, fundamentally undermining candidate autonomy in the decentralized consensus system.

## Finding Description

The vulnerability exists in the permission check logic of the `SetCandidateAdmin()` function. [1](#0-0) 

When `Context.Sender` equals the Parliament default address, the entire permission validation block is completely bypassed. The function proceeds directly to setting the new admin without verifying either the current admin's consent or the original candidate owner's approval. [2](#0-1) 

Once Parliament forcibly changes a candidate's admin, they gain three critical powers that violate candidate autonomy:

**1. Force Candidate to Quit Election:** The `QuitElection()` function requires the caller to be the candidate's admin. [3](#0-2)  With seized admin control, Parliament can forcibly terminate any candidate's election participation and unlock their staked tokens.

**2. Replace Candidate's Public Key:** The `ReplaceCandidatePubkey()` function also enforces admin-only access. [4](#0-3)  Parliament can replace a candidate's mining public key, effectively disrupting their consensus participation and mining operations.

**3. Redirect Candidate's Profit Rewards:** The Treasury contract's `SetProfitsReceiver()` function verifies that the caller is the candidate's admin before allowing profit receiver changes. [5](#0-4)  Parliament can redirect mining rewards and subsidy profits to any address, depriving candidates of their earned income.

This represents a mis-scoped privilege because while Parliament is a trusted governance role, this specific power violates the fundamental security guarantee that candidates maintain autonomous control over their election participation and earned rewards. The code shows candidates explicitly set their own admins during election announcement, [6](#0-5)  indicating admin control was designed to remain with candidates, not be subject to unlimited governance override.

## Impact Explanation

**Direct Financial Impact:**
Parliament can redirect any candidate's mining rewards and subsidy profits by first seizing admin control via `SetCandidateAdmin`, then calling `SetProfitsReceiver` to change the beneficiary address. Candidates lose their legitimately earned rewards without any consent or recourse mechanism.

**Governance Centralization:**
Parliament can force candidates to quit elections at will, effectively allowing governance to control who participates in consensus. This centralizes power by enabling censorship of dissenting candidates and undermining the permissionless nature of the election system.

**Operational Disruption:**
Parliament can replace candidate public keys, disrupting their mining operations and consensus participation. Combined with the ability to force quit, this gives governance complete operational control over candidates who have invested tokens (locked via `LockCandidateNativeToken`) to participate in elections.

**Severity Justification:**
This is HIGH severity because it violates the fundamental protocol invariant of candidate autonomy in a decentralized consensus system. While Parliament requires 2/3 miner approval for proposals (providing some democratic safeguard), the mechanism grants excessive power with no emergency conditions, consent requirements, or additional constraints. This enables censorship, reward theft, and governance capture scenarios that undermine the system's decentralization guarantees.

## Likelihood Explanation

**Execution Path:**
1. Parliament creates a proposal calling `SetCandidateAdmin` with target candidate and new admin address
2. Proposal achieves 2/3 miner approval through standard governance process  
3. Upon release, proposal execution calls `SetCandidateAdmin` with Parliament as sender
4. Permission checks are bypassed, admin is forcibly changed
5. Parliament (or new admin) can now call `QuitElection`, `ReplaceCandidatePubkey`, or `SetProfitsReceiver`

**Feasibility:**
The attack requires only standard Parliament governance approval (2/3 miners). There are no additional technical barriers, emergency conditions to check, or time delays. Any candidate can be targeted at any time through this mechanism.

**Realistic Scenarios:**
- Governance censoring candidates who oppose protocol changes
- Hostile governance takeover redirecting rewards to colluding addresses
- Rationalized as "emergency response" but executed without true emergency conditions
- Coercing candidates into compliance through threat of admin seizure

**Detection Constraints:**
While proposals are publicly visible on-chain, once a Parliament proposal passes and executes, the admin change is immediate and irreversible. Victim candidates have no mechanism to prevent or revert the unauthorized admin change.

**Probability Assessment:**
While 2/3 miner consensus provides democratic safeguard, the capability fundamentally exists and could be exercised under various circumstances. The lack of any consent mechanism from affected candidates or additional constraints beyond standard proposal approval makes this exploitable whenever Parliament chooses to act.

## Recommendation

Implement additional safeguards to prevent unrestricted admin seizure:

```csharp
public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
{
    Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
        "Pubkey is neither a current candidate nor an initial miner.");
    Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

    var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
    
    // Allow Parliament override ONLY in emergency scenarios
    if (Context.Sender == GetParliamentDefaultAddress())
    {
        // Require emergency response organization approval
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(),
            "Parliament admin override requires emergency authorization.");
        
        // Add time delay before change takes effect
        State.PendingAdminChanges[pubkey] = new PendingAdminChange
        {
            NewAdmin = input.Admin,
            EffectiveTime = Context.CurrentBlockTime.AddDays(7)
        };
        return new Empty();
    }
    
    // Normal permission checks for non-Parliament callers
    if (State.CandidateAdmins[pubkey] == null)
    {
        Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
            "No permission.");
    }
    else
    {
        var oldCandidateAdmin = State.CandidateAdmins[pubkey];
        Assert(Context.Sender == oldCandidateAdmin, "No permission.");
    }

    State.CandidateAdmins[pubkey] = input.Admin;
    // ... rest of implementation
}
```

Alternative: Remove Parliament override entirely and rely on emergency response mechanisms through the existing `RemoveEvilNode` function for truly malicious candidates.

## Proof of Concept

```csharp
[Fact]
public async Task Parliament_CanSeizeCandidateAdmin_Test()
{
    // Setup: Candidate announces election with their own admin
    var candidateKeyPair = SampleKeyPairs.KeyPairs[0];
    var candidateAdmin = Accounts[1].Address;
    var parliamentAddress = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
    
    // Candidate announces election
    await ElectionContractStub.AnnounceElection.SendAsync(candidateAdmin);
    
    // Verify candidate has control via their admin
    var admin = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = candidateKeyPair.PublicKey.ToHex() });
    admin.ShouldBe(candidateAdmin);
    
    // Parliament creates proposal to seize admin
    var maliciousAdmin = Accounts[2].Address;
    var proposalId = await CreateParliamentProposalAsync(
        nameof(ElectionContractStub.SetCandidateAdmin),
        new SetCandidateAdminInput
        {
            Pubkey = candidateKeyPair.PublicKey.ToHex(),
            Admin = maliciousAdmin
        });
    
    // Proposal passes with 2/3 approval and gets released
    await ApproveAndReleaseProposalAsync(proposalId);
    
    // Verify Parliament successfully seized admin without candidate consent
    var newAdmin = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = candidateKeyPair.PublicKey.ToHex() });
    newAdmin.ShouldBe(maliciousAdmin);
    
    // Demonstrate Parliament can now force quit
    await ElectionContractStub.QuitElection.SendWithExceptionAsync(
        new StringValue { Value = candidateKeyPair.PublicKey.ToHex() });
    // Would succeed if called from maliciousAdmin
}
```

**Notes:**
- The vulnerability is confirmed through direct code analysis of the permission bypass
- Parliament's trusted status does not exempt it from mis-scoped privilege concerns per the validation framework
- This represents a design-level security issue where excessive governance power undermines protocol guarantees
- The impact is severe (censorship, reward theft) despite requiring governance consensus
- Candidates have no consent mechanism or protection against this forced admin seizure

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L27-40)
```csharp
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L42-42)
```csharp
        State.CandidateAdmins[pubkey] = input.Admin;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L101-103)
```csharp
        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L181-181)
```csharp
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L608-609)
```csharp
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
```
