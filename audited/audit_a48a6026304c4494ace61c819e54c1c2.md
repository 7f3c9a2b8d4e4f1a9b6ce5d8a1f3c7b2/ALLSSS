### Title
Missing Cross-Chain Verification in NFT Protocol Creation Allows Unauthorized Protocol Registration

### Summary
The `CrossChainCreate` method in the NFT contract creates NFT protocols on sidechains without verifying that the protocol actually exists on the source chain or performing any cross-chain proof verification. This allows anyone to create unauthorized NFT protocols on sidechains by leveraging legitimately created tokens, gaining minter privileges and potentially deceiving users about protocol authenticity.

### Finding Description

The vulnerability exists in the `CrossChainCreate` method at [1](#0-0) 

**Root Cause:**
Unlike the TokenContract's `CrossChainCreateToken` method which performs proper cross-chain verification [2](#0-1) , the NFT contract's `CrossChainCreate` only retrieves token information from the local TokenContract state [3](#0-2)  and directly assigns the Creator from the token issuer [4](#0-3)  without any verification that:
1. The NFT protocol exists on the source chain
2. The properties match the source chain protocol
3. This is a legitimate cross-chain synchronization

**Why Protections Fail:**
While the TokenContract properly validates cross-chain token registration using merkle proofs [5](#0-4)  and transaction verification [6](#0-5) , the NFT contract provides no such protection. The `CrossChainCreateInput` only contains a symbol [7](#0-6)  with no merkle path, transaction bytes, or chain verification data.

**Execution Path:**
1. Attacker creates a token on mainchain via TokenContract.Create with themselves as issuer [8](#0-7) 
2. Token is synced to sidechain via legitimate CrossChainCreateToken (with proper verification)
3. Attacker calls NFTContract.CrossChainCreate on sidechain with that token symbol
4. NFT protocol is created with attacker as Creator and added to MinterList [9](#0-8) 

### Impact Explanation

**Concrete Harm:**
- **Unauthorized Minter Privileges**: Attacker gains minting rights for NFT protocols that shouldn't exist or belong to others, allowing creation of fake NFTs
- **Protocol Integrity Violation**: NFT protocols on sidechains don't match mainchain state, breaking cross-chain consistency assumptions
- **User Deception**: Users on sidechains may interact with fake NFT protocols believing they're legitimate cross-chain synchronized protocols
- **Economic Impact**: Fake NFTs could be minted and traded, potentially causing financial losses to users who believe they're acquiring authentic cross-chain assets

**Who is Affected:**
- NFT protocol owners whose protocols could be spoofed on sidechains
- Users on sidechains who interact with fake NFT protocols
- The overall integrity of the AElf cross-chain NFT ecosystem

**Severity Justification:**
Critical - This allows complete bypass of cross-chain verification for NFT protocols, enabling unauthorized protocol creation and minter privilege escalation on sidechains.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be able to create a token on mainchain (requires seed NFT or whitelist status, but seed NFTs are obtainable through normal means)
- Must be able to call public contract methods

**Attack Complexity:**
Low - Only requires two simple steps:
1. Create token on mainchain (standard operation)
2. Call CrossChainCreate on sidechain with the token symbol

**Feasibility Conditions:**
- Token must be synced to sidechain first (can be done by attacker or any third party via CrossChainCreateToken)
- NFT protocol with that symbol must not already exist on sidechain [10](#0-9) 

**Detection Constraints:**
Difficult to detect as the operation appears legitimate - the token exists, the transaction succeeds, and events are fired normally

**Probability:**
High - The attack is straightforward, low-cost (only transaction fees), and there are no authorization checks preventing anyone from calling CrossChainCreate.

### Recommendation

**Code-Level Mitigation:**
Modify `CrossChainCreate` to follow the same cross-chain verification pattern as `CrossChainCreateToken`:

1. Change CrossChainCreateInput to include transaction bytes, merkle path, parent chain height, and source chain ID
2. Add cross-chain verification step similar to [11](#0-10) 
3. Verify the original transaction called a new `ValidateNFTProtocolExists` method on the source chain
4. Extract and validate NFT protocol properties from the verified transaction
5. Only then create the NFT protocol locally

**Invariant Checks to Add:**
- Verify merkle proof against cross-chain contract before protocol creation
- Validate source chain NFT protocol existence through cross-chain verification
- Ensure Creator from verified transaction matches local token issuer

**Test Cases:**
- Test that CrossChainCreate fails without valid merkle proof
- Test that CrossChainCreate fails if NFT protocol doesn't exist on source chain
- Test that CrossChainCreate succeeds only with properly verified cross-chain transaction
- Test rejection of protocols created from tokens that weren't created through NFT contract on source chain

### Proof of Concept

**Initial State:**
- Mainchain: TokenContract deployed and initialized
- Sidechain: Both TokenContract and NFTContract deployed
- Attacker has seed NFT on mainchain to create tokens

**Transaction Steps:**
1. **On Mainchain**: Attacker calls `TokenContract.Create` with:
   - Symbol: Generated through seed NFT mechanism
   - Issuer: Attacker's address
   - Other standard parameters
   - Result: Token created with attacker as issuer, NO NFT protocol created

2. **Cross-Chain Sync**: Anyone calls `TokenContract.CrossChainCreateToken` on sidechain with:
   - Valid transaction bytes from mainchain
   - Merkle proof
   - Result: Token registered on sidechain with attacker as issuer (legitimate operation)

3. **On Sidechain**: Attacker calls `NFTContract.CrossChainCreate` with:
   - Symbol: The token symbol from step 1
   - Result: NFT protocol created with attacker as Creator and minter

**Expected vs Actual:**
- **Expected**: CrossChainCreate should fail because no NFT protocol exists on mainchain
- **Actual**: CrossChainCreate succeeds, creating unauthorized NFT protocol with attacker privileges

**Success Condition:**
- Attacker gains minter privileges for an NFT protocol on sidechain that doesn't exist on mainchain
- Attacker can mint NFTs under this protocol on sidechain
- No corresponding NFT protocol exists on mainchain with the same symbol

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-129)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;

        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = input.Symbol,
            Creator = nftProtocolInfo.Creator,
            IsBurnable = nftProtocolInfo.IsBurnable,
            IssueChainId = nftProtocolInfo.IssueChainId,
            ProtocolName = nftProtocolInfo.ProtocolName,
            TotalSupply = nftProtocolInfo.TotalSupply,
            Metadata = nftProtocolInfo.Metadata,
            BaseUri = nftProtocolInfo.BaseUri,
            IsTokenIdReuse = isTokenIdReuse,
            NftType = nftProtocolInfo.NftType
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-534)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }

        return new Empty();
    }
```

**File:** protobuf/nft_contract.proto (L132-134)
```text
message CrossChainCreateInput {
    string symbol = 1;
}
```
