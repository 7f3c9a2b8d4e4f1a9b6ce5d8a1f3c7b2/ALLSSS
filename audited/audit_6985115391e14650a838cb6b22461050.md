### Title
EnableConnector Allows Re-Enabling with Zero Deposit, Corrupting DepositBalance Accounting

### Summary
The `EnableConnector` function lacks validation to prevent re-enabling already-enabled connectors and unconditionally overwrites `DepositBalance` with `needDeposit.NeedAmount`. An attacker can exploit this by calling `EnableConnector` on an active connector with conditions that yield `needDeposit.NeedAmount = 0`, erasing accumulated deposits from prior Buy operations and causing DoS of Sell operations plus pricing manipulation.

### Finding Description

**Location**: [1](#0-0) 

**Root Cause**: The `EnableConnector` function has two critical flaws:

1. **No Re-Enabling Protection**: Unlike `UpdateConnector` which checks `!targetConnector.IsPurchaseEnabled` [2](#0-1) , `EnableConnector` has no assertion preventing calls on already-enabled connectors.

2. **Unconditional DepositBalance Overwrite**: Line 297 unconditionally assigns `State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount` [3](#0-2)  regardless of existing balance, instead of adding to it.

**Exploitation Path**:

When `GetNeededDeposit` returns `needDeposit.NeedAmount = 0`, this occurs when `amountOutOfTokenConvert = totalSupply - balance - AmountToTokenConvert <= 0` [4](#0-3) . An attacker with sufficient resource tokens can satisfy this condition by setting `AmountToTokenConvert >= totalSupply - balance`, causing no base token deposit requirement.

The conditional transfer only executes if `needDeposit.NeedAmount > 0` [5](#0-4) , so when `needDeposit.NeedAmount = 0`, line 297 sets `DepositBalance` to zero, erasing any prior deposits.

### Impact Explanation

**Direct Operational Impact**:

1. **DepositBalance Accounting Corruption**: Prior Buy operations accumulate base tokens in `DepositBalance` [6](#0-5) . Resetting this to 0 creates a mismatch between actual contract balance and tracked balance.

2. **Sell Operation DoS**: The Sell function subtracts from `DepositBalance` using checked arithmetic [7](#0-6) . With `DepositBalance = 0`, any Sell attempt throws an `OverflowException` [8](#0-7) , making Sell operations permanently unavailable.

3. **Pricing Manipulation**: `GetSelfBalance` for deposit accounts returns `VirtualBalance + DepositBalance` [9](#0-8) . With corrupted `DepositBalance`, Bancor pricing calculations [10](#0-9)  use incorrect balances, underpricing Buy operations and enabling arbitrage.

4. **Permanent Damage**: Once enabled with `IsPurchaseEnabled = true`, connectors cannot be updated [2](#0-1) , making the corruption irreversible.

**Affected Parties**: All users holding resource tokens who can no longer sell them, and new buyers who receive mispriced tokens.

### Likelihood Explanation

**Attacker Capabilities**: Any external user can call `EnableConnector` (no authorization required) [11](#0-10) .

**Attack Complexity**: LOW
- Attacker acquires `AmountToTokenConvert >= totalSupply - balance` resource tokens
- Approves TokenConverter contract
- Calls `EnableConnector` with acquired tokens
- Cost: Market price of required resource tokens

**Feasibility Conditions**:
- Target connector already enabled with `DepositBalance > 0` from prior Buys
- Attacker has liquidity to acquire sufficient resource tokens
- Economic incentive exists (e.g., arbitrage profit > token acquisition cost)

**Detection**: Transaction appears as legitimate `EnableConnector` call; malicious intent only evident after observing corrupted `DepositBalance` state.

**Probability**: HIGH for high-value connector pairs where arbitrage opportunities justify token acquisition costs.

### Recommendation

**Immediate Mitigation**:

Add re-enabling protection in `EnableConnector`:

```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    var fromConnector = State.Connectors[input.TokenSymbol];
    Assert(fromConnector != null && !fromConnector.IsDepositAccount,
        "[EnableConnector]Can't find from connector.");
    var toConnector = State.Connectors[fromConnector.RelatedSymbol];
    Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
    
    // ADD THIS CHECK
    Assert(!fromConnector.IsPurchaseEnabled && !toConnector.IsPurchaseEnabled,
        "Connectors already enabled");
    
    var needDeposit = GetNeededDeposit(input);
    // ... rest of function
}
```

**Additional Invariant Checks**:

1. Validate `VirtualBalance > 0` for deposit accounts in `AddPairConnector` [12](#0-11) 
2. Add total balance validation before enabling: `Assert(GetSelfBalance(toConnector) > 0, "Insufficient deposit balance")`
3. Consider additive model: `State.DepositBalance[toConnector.Symbol] = State.DepositBalance[toConnector.Symbol].Add(needDeposit.NeedAmount);`

**Test Cases**:

1. Verify `EnableConnector` fails when called on already-enabled connector
2. Test that multiple `EnableConnector` calls on same connector are rejected
3. Verify `DepositBalance` integrity after legitimate enable then buy/sell sequences

### Proof of Concept

**Initial State**:
- Connector pair for token "RES" created with `NativeVirtualBalance = 100,000,000`, enabled
- User A executes `Buy(symbol: "RES", amount: 10,000)`, pays 1,000 base tokens
- `State.DepositBalance["(NT)RES"] = 1,000`
- Contract holds 1,000 actual base tokens

**Attack Steps**:
1. Attacker observes `totalSupply("RES") = 1,000,000`, `balance(TokenConverter, "RES") = 900,000`
2. Attacker acquires 100,000 RES tokens (or more)
3. Attacker approves TokenConverter for 100,000 RES
4. Attacker calls:
   ```
   EnableConnector({
       TokenSymbol: "RES",
       AmountToTokenConvert: 100,000
   })
   ```
5. `GetNeededDeposit` calculates: `amountOutOfTokenConvert = 1,000,000 - 900,000 - 100,000 = 0`
6. Returns `needDeposit.NeedAmount = 0` [13](#0-12) 
7. No base token transfer occurs (line 277 condition false)
8. Line 297 executes: `State.DepositBalance["(NT)RES"] = 0` (overwrites 1,000)
9. Lines 298-299 set `IsPurchaseEnabled = true` (already true, no effect)

**Result**:
- `DepositBalance` corrupted: 0 (should be 1,000)
- Actual contract balance: 1,000 base tokens (unchanged)
- `GetSelfBalance(depositConnector)` now returns 100,000,000 instead of 100,001,000
- Any subsequent Sell attempt throws: `OverflowException: Arithmetic operation resulted in an overflow` when executing `0.Sub(amountToReceive)` [7](#0-6) 
- Buy operations execute with incorrect (lower) pricing, enabling arbitrage

**Success Condition**: `State.DepositBalance["(NT)RES"] == 0` while contract holds 1,000 base tokens, with Sell operations permanently disabled.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L64-64)
```csharp
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L96-109)
```csharp
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L141-141)
```csharp
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-84)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```
