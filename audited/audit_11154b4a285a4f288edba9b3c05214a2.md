### Title
Unvalidated Secret Reconstruction in RevealSharedInValues Allows Consensus State Corruption

### Summary
The `RevealSharedInValues()` function reconstructs miners' InValues from DecryptedPieces using `SecretSharingHelper.DecodeSecret` without validating that the reconstructed secret matches the original OutValue hash. Since Shamir's Secret Sharing reconstruction succeeds even with corrupted shares (producing an incorrect result), a malicious miner can provide corrupted DecryptedPieces that cause incorrect PreviousInValue storage, leading to consensus state corruption when these values are used in `SupplyCurrentRoundInformation` to generate miner signatures.

### Finding Description

The vulnerability exists in the secret sharing recovery mechanism: [1](#0-0) 

The `RevealSharedInValues` function extracts DecryptedPieces from the previous round and passes them directly to `SecretSharingHelper.DecodeSecret` without any validation. The DecodeSecret implementation uses Lagrange interpolation: [2](#0-1) 

This mathematical reconstruction always succeeds and returns a result, even when input shares are corrupted. There is no error detection or verification that the reconstructed secret is correct.

The reconstructed value is stored as `PreviousInValue` in the consensus round state without validation. Later, in `SupplyCurrentRoundInformation`, this unvalidated PreviousInValue is used to calculate miner signatures: [3](#0-2) 

Critically, there is no validation here that `Hash(previousInValue) == previousRound.RealTimeMinersInformation[miner.Pubkey].OutValue`, unlike the validation that exists elsewhere: [4](#0-3) 

The validation in `UpdateValueValidationProvider` only checks the sender's own PreviousInValue, not revealed values of other miners: [5](#0-4) 

DecryptedPieces are added to the round state without validation in `PerformSecretSharing`: [6](#0-5) 

### Impact Explanation

**Consensus State Corruption**: When corrupted DecryptedPieces cause incorrect PreviousInValue reconstruction, this incorrect value is used in `SupplyCurrentRoundInformation` to calculate miner signatures. The signature calculation uses: [7](#0-6) 

An incorrect signature for one miner corrupts the combined signature result, affecting consensus randomness generation and round state integrity.

**Who is Affected**: All miners and the consensus mechanism. Miners who fail to produce blocks in a round have their InValue/Signature fields filled by `SupplyCurrentRoundInformation`, which would use the corrupted PreviousInValue. This breaks the cryptographic chain of consensus values.

**Severity**: Critical - violates the "Consensus & Cross-Chain" invariant requiring "Correct round transitions and miner schedule integrity." Compromises the verifiable randomness property of the consensus mechanism.

### Likelihood Explanation

**Attacker Capabilities**: Any miner in the consensus set can execute this attack by providing corrupted DecryptedPieces in their UpdateValue transaction. The attacker needs:
- Miner status in the consensus round
- Ability to submit UpdateValue transactions with DecryptedPieces field

**Attack Complexity**: Low. The attacker simply provides incorrect byte arrays as DecryptedPieces values: [8](#0-7) 

**Feasibility**: In Shamir's Secret Sharing, even one corrupted share among the threshold shares used causes complete reconstruction failure - the scheme has no built-in error correction. The minimum threshold is 2/3 of miners: [9](#0-8) 

If an attacker corrupts just their own DecryptedPieces for a target miner, and those pieces are selected for reconstruction (which happens deterministically based on miner order), the reconstructed secret will be wrong.

**Detection**: The attack is difficult to detect since DecodeSecret succeeds without error, and the incorrect PreviousInValue is stored normally. The corruption only manifests when signatures don't match expected values in subsequent consensus operations.

### Recommendation

**Immediate Fix**: Add validation after secret reconstruction to verify the reconstructed InValue matches the expected OutValue hash:

```csharp
var revealedInValue = 
    HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// Validate reconstructed value matches original OutValue
if (anotherMinerInPreviousRound.OutValue != null && 
    revealedInValue != Hash.Empty &&
    HashHelper.ComputeFrom(revealedInValue) != anotherMinerInPreviousRound.OutValue)
{
    Context.LogDebug(() => $"Reconstructed InValue validation failed for {publicKeyOfAnotherMiner}");
    continue; // Skip this miner, don't set incorrect PreviousInValue
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**Additional Validation**: In `SupplyCurrentRoundInformation`, add validation before using PreviousInValue:

```csharp
previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
if (previousInValue != null && 
    previousRound.RealTimeMinersInformation[miner.Pubkey].OutValue != null &&
    HashHelper.ComputeFrom(previousInValue) != previousRound.RealTimeMinersInformation[miner.Pubkey].OutValue)
{
    // Revealed PreviousInValue doesn't match expected OutValue, treat as invalid
    previousInValue = null;
}
```

**Test Cases**: Add tests verifying:
1. Corrupted DecryptedPieces cause reconstruction to be rejected
2. Only valid reconstructed InValues are stored as PreviousInValue
3. Invalid PreviousInValue in round state doesn't corrupt signature generation

### Proof of Concept

**Initial State**:
- Round N has miners A, B, C with OutValues already committed
- Miner A's OutValue = Hash(InValue_A)
- Secret sharing is enabled
- Minimum threshold = 2 (with 3 miners)

**Attack Steps**:
1. In Round N, miners encrypt and distribute shares of their InValues
2. In Round N+1, attacker (Miner B) decrypts shares from Miner A but provides corrupted DecryptedPieces in UpdateValue transaction:
   - `input.DecryptedPieces["A"] = <corrupted_bytes_not_matching_original>`
3. The corrupted DecryptedPieces are stored in round state via `PerformSecretSharing`
4. During NextRound behavior, `RevealSharedInValues` is called
5. It extracts DecryptedPieces for Miner A including the corrupted piece from Miner B
6. `SecretSharingHelper.DecodeSecret` succeeds but produces `incorrect_InValue_A != InValue_A`
7. This incorrect value is stored: `currentRound.RealTimeMinersInformation["A"].PreviousInValue = incorrect_InValue_A`
8. If Miner A fails to produce blocks, `SupplyCurrentRoundInformation` reads this incorrect PreviousInValue
9. It calculates: `signature = previousRound.CalculateSignature(incorrect_InValue_A)`
10. The incorrect signature is stored in consensus state

**Expected Result**: Reconstructed InValue should be validated against OutValue hash and rejected if incorrect

**Actual Result**: Incorrect reconstructed InValue is stored and used without validation, corrupting consensus signatures

**Success Condition**: After attack, `Hash(stored_PreviousInValue) != original_OutValue`, and the miner's signature field contains an incorrect value that breaks consensus integrity.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-52)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-64)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L80-86)
```csharp
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-48)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-114)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L26-28)
```csharp
        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);
```
