### Title
Contract Version Rollback via Self-Declared Assembly Version Manipulation

### Summary
The `ProposeUpdateContract` function relies on `AssertContractVersion` to prevent deploying older contract versions, but this check can be trivially bypassed because contract versions are self-declared in assembly metadata rather than validated against external records. A malicious or compromised contract author can reintroduce previously patched vulnerabilities by modifying old code slightly (to change the code hash) while manipulating the AssemblyVersion attribute to a higher number, defeating the version protection mechanism.

### Finding Description

The version rollback protection in `ProposeUpdateContract` fails due to the following design weakness: [1](#0-0) 

The version check at line 184 calls `AssertContractVersion`: [2](#0-1) 

This function extracts the version from the contract assembly metadata itself via `Context.CheckContractVersion`, which ultimately calls: [3](#0-2) 

The version comparison at line 89 uses: [4](#0-3) 

The critical issue is that the version string comes directly from the assembly being deployed: [5](#0-4) 

**Root Cause**: The version is self-declared by the contract code itself (`assembly.GetName().Version`), not tracked or validated by the system against historical versions or external sources.

**Why Protections Fail**:
1. The `AssertContractNotExists` check at line 187 only prevents deploying the exact same code hash: [6](#0-5) 

2. Trivial code modifications (adding comments, whitespace, renaming private variables) change the code hash while preserving vulnerable functionality
3. The attacker can set any AssemblyVersion value they want in the old code before compilation
4. No automated comparison exists between the new code's functionality and previous versions
5. The same flawed check repeats during execution in `UpdateSmartContract`: [7](#0-6) 

### Impact Explanation

**Direct Harm**:
- **Reintroduction of Patched Vulnerabilities**: An attacker can deploy contract code containing previously fixed security flaws (e.g., arithmetic overflow bugs, access control bypasses, reentrancy vulnerabilities)
- **Fund Theft**: If the rolled-back vulnerability enabled unauthorized token minting, burning, or transfer, attackers can steal or manipulate funds
- **Protocol Compromise**: For critical system contracts (consensus, governance, treasury), this enables attacks that were previously mitigated
- **Governance Bypass**: The version control mechanism's intent is completely defeated

**Affected Parties**:
- All users of the upgraded contract
- The entire protocol if a system contract (Parliament, Token, Treasury, Consensus) is affected
- Value at risk depends on contract importance (potentially entire chain TVL for system contracts)

**Severity Justification**: CRITICAL because it:
- Undermines the entire contract upgrade security model
- Can reintroduce any historical vulnerability
- Affects high-value system contracts
- Requires only author-level access (realistic for targeted attacks on infrastructure contracts)

### Likelihood Explanation

**Attacker Capabilities Required**:
- Must be the contract author OR compromise the author's private keys
- Must craft a proposal that passes governance review

**Attack Complexity**: LOW to MEDIUM
1. Obtain old vulnerable contract source code (often publicly available)
2. Make trivial modifications (add comment, whitespace) to alter code hash
3. Change AssemblyVersion attribute to higher number (e.g., "3.0.0" when current is "2.0.0")
4. Compile and submit via `ProposeUpdateContract`
5. Use social engineering in proposal description ("critical hotfix", "security patch")

**Feasibility Conditions**:
- BARRIER: Requires contract author access (high bar but realistic via compromise, insider threat, or initially malicious author)
- BARRIER: Must pass two governance approvals (ContractDeploymentController and CodeCheckController)
- WEAKNESS: No automated detection - relies entirely on manual code review
- WEAKNESS: Governance members may not have expertise/time for thorough review
- WEAKNESS: Social engineering can mislead reviewers about the update's purpose

**Detection/Operational Constraints**:
- Proposal is on-chain and public, but detecting the rollback requires:
  - Manual comparison with historical contract versions
  - Deep code review expertise
  - Awareness that version numbers can be manipulated
- No system alerts or automated warnings for suspicious patterns

**Probability Reasoning**: 
While requiring author-level access is significant, the complete lack of automated protection combined with reliance on fallible manual review creates a realistic attack vector, especially for:
- Targeted attacks on high-value system contracts
- Compromised development infrastructure
- Insider threats
- Malicious original authors planning long-term exploits

### Recommendation

**Code-Level Mitigation**:

1. **Maintain Version History**: Store all previous code hashes and versions in state:
```
MappedState<Address, ContractVersionHistory> VersionHistory;
```

2. **Validate Against History**: In `AssertContractVersion`, verify the new code is not functionally similar to any previous version by:
   - Checking code hash against all historical hashes for that contract
   - Computing similarity metrics between new and old bytecode
   - Requiring increasing version numbers across the entire history

3. **Add Cryptographic Proof**: Require contract updates to include a signed attestation from the build system proving code lineage and version progression

4. **Enhanced Checks**:
```csharp
private void AssertContractVersion(Address contractAddress, string currentVersion, ByteString newCode, int category)
{
    var codeHash = HashHelper.ComputeFrom(newCode.ToByteArray());
    
    // Check against ALL historical versions
    var history = State.VersionHistory[contractAddress];
    Assert(!history.CodeHashes.Contains(codeHash), 
        "Cannot deploy code similar to a previous version");
    
    // Existing version string check
    var contractVersionCheckResult = Context.CheckContractVersion(currentVersion, ...);
    Assert(contractVersionCheckResult.IsSubsequentVersion, ...);
    
    // Store in history
    history.CodeHashes.Add(codeHash);
    history.Versions.Add(newContractVersion);
}
```

5. **Add Test Cases**:
   - Test that deploying old code with modified version number fails
   - Test that trivially modified old code (with higher version) fails
   - Test version history persistence across updates

### Proof of Concept

**Initial State**:
- TokenContract v2.0.0 deployed at address A
- Version 2.0.0 fixed critical vulnerability X
- Attacker has compromised author's private key

**Attack Steps**:

1. **Retrieve Old Code**: Obtain TokenContract v1.0.0 source (contains vulnerability X)

2. **Modify Code Hash**:
   - Add comment: `// Updated for performance improvements`
   - Rename private variable: `_tempValue` → `_tempVal`
   - Result: Code hash changes from H1 to H2

3. **Manipulate Version**:
   - Change AssemblyVersion attribute from "1.0.0.0" to "2.1.0.0"
   - Compile contract

4. **Submit Proposal**:
```csharp
ProposeUpdateContract(new ContractUpdateInput {
    Address = TokenContractAddress,
    Code = ByteString.CopyFrom(compiledBytesWithManipulatedVersion)
})
```

5. **Version Check Execution**:
   - System extracts version from assembly: "2.1.0.0"
   - Compares: "2.0.0" < "2.1.0.0" → TRUE (passes)
   - Code hash H2 not in registry → TRUE (passes)

6. **Governance Approval**: 
   - Proposal description: "Security hotfix for TokenContract v2.1.0"
   - Reviewers see higher version number, assume it's legitimate
   - Approvals obtained through social engineering or review fatigue

7. **Update Execution**:
   - Same checks pass during `UpdateSmartContract`
   - Old vulnerable code deployed with version "2.1.0.0"

**Expected vs Actual**:
- EXPECTED: System rejects code that reintroduces old vulnerabilities
- ACTUAL: System accepts code because version string manipulation bypasses all checks

**Success Condition**: After update, vulnerability X (patched in v2.0.0) is now exploitable again in the deployed contract at address A, despite the system recording it as version "2.1.0.0"

### Notes

This vulnerability represents a fundamental weakness in the version control model where security depends entirely on self-declared metadata rather than cryptographically verified code provenance. While governance review provides defense-in-depth, the lack of automated technical controls violates security best practices. The attack is particularly concerning for system contracts where author compromise would have chain-wide impact.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-187)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
        AssertContractVersion(info.ContractVersion, input.Code, info.Category);

        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        AssertContractNotExists(codeHash);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L124-127)
```csharp
        var contractInfo = Context.UpdateSmartContract(contractAddress, reg, null, info.ContractVersion);
        Assert(contractInfo.IsSubsequentVersion,
            $"The version to be deployed is lower than the effective version({info.ContractVersion}), please correct the version number.");

```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L366-377)
```csharp
    private void AssertContractVersion(string currentVersion, ByteString code, int category)
    {
        var contractVersionCheckResult =
            Context.CheckContractVersion(currentVersion, new SmartContractRegistration
            {
                Code = code,
                Category = category,
                CodeHash = HashHelper.ComputeFrom(code.ToByteArray())
            });
        Assert(contractVersionCheckResult.IsSubsequentVersion,
            $"The version to be deployed is lower than the effective version({currentVersion}), please correct the version number.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L379-382)
```csharp
    private void AssertContractNotExists(Hash codeHash)
    {
        Assert(State.SmartContractRegistrations[codeHash] == null, "contract code has already been deployed before.");
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/SmartContractService.cs (L53-61)
```csharp
    public async Task<ContractVersionCheckDto> CheckContractVersionAsync(string previousContractVersion,SmartContractRegistration registration)
    {
        var newContractVersion = await GetVersion(registration);
        var isSubsequentVersion = CheckVersion(previousContractVersion,newContractVersion);
        return new ContractVersionCheckDto
        {
            IsSubsequentVersion = isSubsequentVersion
        };
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/SmartContractService.cs (L77-90)
```csharp
    private bool CheckVersion(string previousContractVersion,string newContractVersion)
    {
        if (newContractVersion.IsNullOrEmpty())
        {
            return false;
        }

        if (previousContractVersion.IsNullOrEmpty())
        {
            return true;
        }

        return  new Version(previousContractVersion) < new Version(newContractVersion);
    }
```

**File:** src/AElf.Runtime.CSharp/CSharpSmartContractRunner.cs (L33-33)
```csharp
        ContractVersion = assembly.GetName().Version?.ToString();
```
