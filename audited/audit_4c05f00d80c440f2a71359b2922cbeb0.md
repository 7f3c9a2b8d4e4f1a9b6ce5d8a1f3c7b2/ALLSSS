### Title
Missing Validation on MinimumLockTime Initialization Allows Zero-Lock-Time Votes with Full Vote Weight Benefits

### Summary
The `InitialElectionContract` method fails to validate that `MinimumLockTime` is greater than zero during initialization. If deployed with `MinimumLockTime = 0`, users can create votes with zero lock time, withdraw tokens instantly, and still receive full vote weight benefits (1.5x vote amount with default settings), completely bypassing the intended token locking mechanism that secures the election system.

### Finding Description
The vulnerability exists in the initialization flow: [1](#0-0) 

The `InitialElectionContract` method directly assigns `input.MinimumLockTime` to state without any validation that it must be greater than zero. When `MinimumLockTime = 0`, the validation in the `Vote` method becomes ineffective: [2](#0-1) 

The check `lockSeconds >= State.MinimumLockTime.Value` passes when both are zero, allowing: [3](#0-2) 

A vote is created with `LockTimeMap[voteId] = 0`. Despite zero lock time, the user receives non-zero vote weight: [4](#0-3) 

When `lockTime = 0`, `lockDays = 0`, and `Pow(initBase, 0) = 1`. With default proportions: [5](#0-4) 

The weight becomes `votesAmount + votesAmount * 1/2 = 1.5 * votesAmount`. Users can then withdraw immediately: [6](#0-5) 

The check `actualLockedTime >= claimedLockDays` passes immediately when `claimedLockDays = 0`.

### Impact Explanation
**Critical breach of election security invariant**: The minimum lock time requirement is a fundamental constraint ensuring voters commit tokens for a meaningful period, preventing vote manipulation and ensuring election stability. 

With this vulnerability:
- Users can vote for any candidate and withdraw instantly without any time commitment
- They receive 1.5x vote weight despite zero lock time
- Election results can be manipulated through rapid vote/withdraw cycles
- The economic security model collapses as there's no cost to voting
- Voters can participate in multiple elections simultaneously by voting and immediately withdrawing
- Candidates can artificially inflate their vote counts through coordinated instant-vote-withdraw attacks

This affects all election participants and undermines the entire governance mechanism's integrity.

### Likelihood Explanation
**Likelihood: Low-to-Medium**, dependent on deployment process:

The exploit requires `MinimumLockTime = 0` to be set during contract initialization. While the default value in `EconomicOptions` is properly set: [7](#0-6) 

The configuration can be overridden during deployment. Scenarios include:
- **Misconfiguration**: Operator error during sidechain or testnet deployment
- **Malicious deployment**: Untrusted party deploying the contract with intentional misconfiguration
- **Configuration file error**: Incorrect value in deployment configuration files

The contract is initialized once and cannot be reinitialized: [8](#0-7) 

Making the misconfiguration permanent if it occurs. For mainnet deployments by trusted parties with proper review, likelihood is low. For sidechains or permissionless deployments, likelihood increases significantly.

### Recommendation
Add validation in `InitialElectionContract` to enforce minimum lock time constraints:

```csharp
public override Empty InitialElectionContract(InitialElectionContractInput input)
{
    Assert(!State.Initialized.Value, "Already initialized.");
    
    // Add validation
    Assert(input.MinimumLockTime > 0, "Minimum lock time must be greater than zero.");
    Assert(input.MinimumLockTime <= input.MaximumLockTime, "Minimum lock time cannot exceed maximum lock time.");
    Assert(input.MaximumLockTime > 0, "Maximum lock time must be greater than zero.");
    
    State.Candidates.Value = new PubkeyList();
    State.MinimumLockTime.Value = input.MinimumLockTime;
    // ... rest of initialization
}
```

Add integration tests to verify:
1. Initialization fails when `MinimumLockTime = 0`
2. Initialization fails when `MinimumLockTime > MaximumLockTime`
3. Vote creation fails with proper error when attempting zero lock time
4. Withdrawal fails when attempting to withdraw before lock time expires

### Proof of Concept

**Initial State:**
- Election contract deployed with `InitialElectionContractInput { MinimumLockTime = 0, MaximumLockTime = 1000000, ... }`
- Candidate "CandidateA" has announced election
- User has 1,000,000 tokens

**Attack Sequence:**

1. **T0: Create vote with zero lock time**
   - User calls `Vote({ CandidatePubkey: "CandidateA", Amount: 1000000, EndTimestamp: T0 })`
   - `lockSeconds = T0 - T0 = 0`
   - `AssertValidLockSeconds(0)` checks `0 >= 0` ✓ (passes)
   - `LockTimeMap[voteId] = 0`
   - Vote weight = `GetVotesWeight(1000000, 0)` = `1.5 * 1000000 = 1,500,000` shares
   - User receives 1,500,000 profit shares for welfare scheme
   - Tokens are locked in TokenContract

2. **T0 + 1 second: Immediate withdrawal**
   - User calls `Withdraw(voteId)`
   - `actualLockedTime = 1 second`
   - `claimedLockDays = 0`
   - Check `1 >= 0` ✓ (passes)
   - Tokens unlocked and returned to user
   - User had 1,500,000 profit weight for 1 second

**Expected Result:** Vote creation should fail due to insufficient lock time

**Actual Result:** Vote succeeds, user receives full vote weight, can withdraw immediately

**Success Condition:** User successfully creates vote, receives profit shares, and withdraws within seconds while `MinimumLockTime` should enforce a minimum period (typically 7+ days).

### Notes
This vulnerability is distinct from runtime exploits—it's a deployment-time configuration vulnerability that becomes permanent. The severity is HIGH because once deployed with `MinimumLockTime = 0`, the election system is fundamentally broken with no recovery path except contract upgrade. Defense-in-depth requires contracts to validate critical invariants during initialization rather than relying solely on correct configuration.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L22-29)
```csharp
    public override Empty InitialElectionContract(InitialElectionContractInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");

        State.Candidates.Value = new PubkeyList();

        State.MinimumLockTime.Value = input.MinimumLockTime;
        State.MaximumLockTime.Value = input.MaximumLockTime;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L261-268)
```csharp
    private VoteWeightProportion GetDefaultVoteWeightProportion()
    {
        return new VoteWeightProportion
        {
            TimeProportion = 2,
            AmountProportion = 1
        };
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L320-326)
```csharp
    private void AssertValidLockSeconds(long lockSeconds)
    {
        Assert(lockSeconds >= State.MinimumLockTime.Value,
            $"Invalid lock time. At least {State.MinimumLockTime.Value.Div(60).Div(60).Div(24)} days");
        Assert(lockSeconds <= State.MaximumLockTime.Value,
            $"Invalid lock time. At most {State.MaximumLockTime.Value.Div(60).Div(60).Div(24)} days");
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L429-434)
```csharp
        var lockSeconds = (input.EndTimestamp - Context.CurrentBlockTime).Seconds;
        AssertValidLockSeconds(lockSeconds);

        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-586)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L629-636)
```csharp
    public override Empty Withdraw(Hash input)
    {
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input);

        var actualLockedTime = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockDays = State.LockTimeMap[input];
        Assert(actualLockedTime >= claimedLockDays,
            $"Still need {claimedLockDays.Sub(actualLockedTime).Div(86400)} days to unlock your token.");
```

**File:** src/AElf.OS.Core/EconomicOptions.cs (L15-16)
```csharp
    public long MaximumLockTime { get; set; } = 1080 * 86400;
    public long MinimumLockTime { get; set; } = 90 * 86400;
```
