# Audit Report

## Title
Transfer Blacklist Bypass - Recipient Address Not Validated

## Summary
The transfer blacklist implementation only validates the sender (FROM) address but fails to check the recipient (TO) address in `DoTransfer`. This allows blacklisted addresses to receive tokens through multiple paths including direct Transfer, Unlock, Issue, and CrossChainReceiveToken operations, fundamentally breaking the blacklist's intended purpose of freezing an address's token activity.

## Finding Description

The root cause is in the `DoTransfer` method which only validates the FROM address against the blacklist: [1](#0-0) 

The blacklist check only validates `from` but never checks if `to` is blacklisted. This creates multiple bypass vectors:

**Primary Bypass Path - Unlock to Blacklisted Address:**

A blacklisted user can unlock their previously locked tokens. The `Unlock` method uses `SendVirtualInline` to transfer tokens from a virtual address: [2](#0-1) 

When `Unlock` is called with `input.Address` being a blacklisted user, the virtual address (computed at lines 234-235) becomes the sender. Since `DoTransfer` only checks if the FROM address (virtual address) is blacklisted - and it's not - the transfer succeeds, allowing the blacklisted user to reclaim their locked tokens.

**Additional Bypass Vectors:**

1. **Direct Transfer TO blacklisted addresses**: The `Transfer` method calls `DoTransfer` with sender and recipient: [3](#0-2) 

Since only the FROM address is checked, any user can send tokens TO a blacklisted address.

2. **Issue operations bypass blacklist** by calling `ModifyBalance` directly without any blacklist validation: [4](#0-3) 

3. **CrossChainReceiveToken bypasses blacklist** by calling `ModifyBalance` directly: [5](#0-4) 

The test suite confirms the flaw - tests verify that Lock is blocked for blacklisted senders but do NOT test whether Unlock to blacklisted recipients is blocked: [6](#0-5) 

No test exists for unlocking TO a blacklisted address.

## Impact Explanation

**Direct Operational Impact:** The transfer blacklist feature is rendered ineffective. When governance blacklists an address (for regulatory compliance, compromised keys, or malicious actors), the expectation is that the address is frozen from ALL token activity. However:

- Blacklisted addresses can receive tokens from any sender via Transfer
- Blacklisted users can unlock previously locked tokens from Election/Vote contracts  
- Token issuers can issue new tokens to blacklisted addresses
- Cross-chain transfers can deliver tokens to blacklisted addresses

**Most Critical Scenario:** A user locks tokens in Election/Vote contracts, then engages in malicious behavior and gets blacklisted by governance. The user can simply call `Unlock` to reclaim their locked funds, completely bypassing the blacklist restriction.

**Severity:** HIGH - The core security feature (blacklist) is fundamentally broken. Governance cannot effectively enforce blacklist decisions, allowing malicious actors to retain token access and regain locked funds.

## Likelihood Explanation

**Exploitability:** HIGH

1. **Direct Transfer Path:** Any address can immediately send tokens to a blacklisted address. No special permissions or conditions required.

2. **Unlock Path:** A blacklisted user can unlock their own tokens if they locked them before being blacklisted. The `Unlock` authorization check allows `Context.Origin == input.Address`: [7](#0-6) 

The user simply calls Unlock with their own address, and the virtual address mechanism bypasses the blacklist.

**Attack Complexity:** TRIVIAL
- No race conditions or timing dependencies
- No economic cost beyond gas fees  
- Works immediately on any blacklisted address
- Exploitable through standard public methods

**Probability:** 100% - This is a permanent logic gap that affects all blacklisted addresses and is immediately exploitable.

## Recommendation

Add recipient (TO) address blacklist validation in `DoTransfer`:

```csharp
private void DoTransfer(Address from, Address to, string symbol, long amount, string memo = null)
{
    Assert(!IsInTransferBlackListInternal(from), "From address is in transfer blacklist.");
    Assert(!IsInTransferBlackListInternal(to), "To address is in transfer blacklist.");  // ADD THIS CHECK
    Assert(from != to, "Can't do transfer to sender itself.");
    AssertValidMemo(memo);
    ModifyBalance(from, symbol, -amount);
    ModifyBalance(to, symbol, amount);
    Context.Fire(new Transferred
    {
        From = from,
        To = to,
        Symbol = symbol,
        Amount = amount,
        Memo = memo ?? string.Empty
    });
}
```

Additionally, add blacklist checks in `Issue` and `CrossChainReceiveToken` before calling `ModifyBalance`:

```csharp
// In Issue method, before ModifyBalance:
Assert(!IsInTransferBlackListInternal(input.To), "To address is in transfer blacklist.");

// In CrossChainReceiveToken method, before ModifyBalance:
Assert(!IsInTransferBlackListInternal(receivingAddress), "Receiving address is in transfer blacklist.");
```

## Proof of Concept

```csharp
[Fact]
public async Task BlacklistedAddress_CanReceiveTokens_AndUnlockFunds()
{
    // Setup: Create token and fund user
    await CreateAndIssueToken(1000_00000000L);
    
    // User locks tokens before being blacklisted
    var lockId = HashHelper.ComputeFrom("test_lock");
    await BasicFunctionContractStub.LockToken.SendAsync(new LockTokenInput
    {
        Address = DefaultAddress,
        Amount = 100_00000000L,
        Symbol = AliceCoinTokenInfo.Symbol,
        LockId = lockId,
        Usage = "Testing"
    });
    
    // Governance adds user to blacklist
    var defaultParliament = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
    var proposalId = await CreateProposalAsync(TokenContractAddress, defaultParliament, 
        nameof(TokenContractStub.AddToTransferBlackList), DefaultAddress);
    await ApproveWithMinersAsync(proposalId);
    await ParliamentContractStub.Release.SendAsync(proposalId);
    
    // Verify user is blacklisted
    var isBlacklisted = await TokenContractStub.IsInTransferBlackList.CallAsync(DefaultAddress);
    isBlacklisted.Value.ShouldBe(true);
    
    // BUG: Blacklisted user can still receive tokens via direct transfer
    var transferResult = await TokenContractStubUser.Transfer.SendAsync(new TransferInput
    {
        To = DefaultAddress,
        Symbol = AliceCoinTokenInfo.Symbol,
        Amount = 50_00000000L,
        Memo = "Bypass test"
    });
    transferResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Should fail but succeeds!
    
    // BUG: Blacklisted user can unlock their previously locked tokens
    var unlockResult = await BasicFunctionContractStub.UnlockToken.SendAsync(new UnlockInput
    {
        Address = DefaultAddress,
        Amount = 100_00000000L,
        Symbol = AliceCoinTokenInfo.Symbol,
        LockId = lockId,
        Usage = "Bypass test"
    });
    unlockResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Should fail but succeeds!
    
    // Blacklisted user successfully received and unlocked tokens despite being blacklisted
    var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultAddress,
        Symbol = AliceCoinTokenInfo.Symbol
    });
    balance.Balance.ShouldBeGreaterThan(0); // Blacklist completely bypassed
}
```

**Notes:**
This vulnerability fundamentally breaks the transfer blacklist feature. While the blacklist prevents sending tokens FROM blacklisted addresses, it fails to prevent receiving tokens TO blacklisted addresses. This is particularly critical for the Unlock path, where blacklisted users can reclaim previously locked funds by exploiting the virtual address mechanism that bypasses the FROM-only blacklist check.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L99-114)
```csharp
    private void DoTransfer(Address from, Address to, string symbol, long amount, string memo = null)
    {
        Assert(!IsInTransferBlackListInternal(from), "From address is in transfer blacklist.");
        Assert(from != to, "Can't do transfer to sender itself.");
        AssertValidMemo(memo);
        ModifyBalance(from, symbol, -amount);
        ModifyBalance(to, symbol, amount);
        Context.Fire(new Transferred
        {
            From = from,
            To = to,
            Symbol = symbol,
            Amount = amount,
            Memo = memo ?? string.Empty
        });
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L154-178)
```csharp
    public override Empty Issue(IssueInput input)
    {
        Assert(input.To != null, "To address not filled.");
        AssertValidMemo(input.Memo);
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");

        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(input.To, input.Symbol, input.Amount);

        Context.Fire(new Issued
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = input.To,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L224-252)
```csharp
    public override Empty Unlock(UnlockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Unlock behaviour should be initialed by origin address.");

        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        Context.SendVirtualInline(fromVirtualAddress, Context.Self, nameof(Transfer), new TransferInput
        {
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        DealWithExternalInfoDuringUnlock(new TransferFromInput
        {
            From = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress),
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L591-638)
```csharp
    public override Empty CrossChainReceiveToken(CrossChainReceiveTokenInput input)
    {
        var transferTransaction = Transaction.Parser.ParseFrom(input.TransferTransactionBytes);
        var transferTransactionId = transferTransaction.GetHash();

        Assert(!State.VerifiedCrossChainTransferTransaction[transferTransactionId],
            "Token already claimed.");

        var crossChainTransferInput =
            CrossChainTransferInput.Parser.ParseFrom(transferTransaction.Params.ToByteArray());
        var symbol = crossChainTransferInput.Symbol;
        var amount = crossChainTransferInput.Amount;
        var receivingAddress = crossChainTransferInput.To;
        var targetChainId = crossChainTransferInput.ToChainId;
        var transferSender = transferTransaction.From;

        var tokenInfo = AssertValidToken(symbol, amount);
        var issueChainId = GetIssueChainId(tokenInfo.Symbol);
        Assert(issueChainId == crossChainTransferInput.IssueChainId, "Incorrect issue chain id.");
        Assert(targetChainId == Context.ChainId, "Unable to claim cross chain token.");
        var registeredTokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        AssertCrossChainTransaction(transferTransaction, registeredTokenContractAddress,
            nameof(CrossChainTransfer));
        Context.LogDebug(() =>
            $"symbol == {tokenInfo.Symbol}, amount == {amount}, receivingAddress == {receivingAddress}, targetChainId == {targetChainId}");

        CrossChainVerify(transferTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);

        State.VerifiedCrossChainTransferTransaction[transferTransactionId] = true;
        tokenInfo.Supply = tokenInfo.Supply.Add(amount);
        Assert(tokenInfo.Supply <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(receivingAddress, tokenInfo.Symbol, amount);

        Context.Fire(new CrossChainReceived
        {
            From = transferSender,
            To = receivingAddress,
            Symbol = tokenInfo.Symbol,
            Amount = amount,
            Memo = crossChainTransferInput.Memo,
            FromChainId = input.FromChainId,
            ParentChainHeight = input.ParentChainHeight,
            IssueChainId = issueChainId,
            TransferTransactionId = transferTransactionId
        });
        return new Empty();
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenApplicationTests.cs (L1973-1984)
```csharp
        // Lock should fail when sender is in blacklist
        var lockId = HashHelper.ComputeFrom("lockId");
        var lockTokenResult = (await BasicFunctionContractStub.LockToken.SendWithExceptionAsync(new LockTokenInput
        {
            Address = DefaultAddress,
            Amount = Amount,
            Symbol = AliceCoinTokenInfo.Symbol,
            LockId = lockId,
            Usage = "Testing."
        })).TransactionResult;
        lockTokenResult.Status.ShouldBe(TransactionResultStatus.Failed);
        lockTokenResult.Error.ShouldContain("From address is in transfer blacklist");
```
