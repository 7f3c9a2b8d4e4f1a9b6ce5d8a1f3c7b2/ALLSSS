### Title
Sponsor Loses Direct Control Over Locked Deposit When Admin Address Differs in AnnounceElectionFor

### Summary
In `AnnounceElectionFor()`, when the sponsor sets a different admin address than themselves, the sponsor's locked deposit tokens (100,000 ELF) can only be unlocked by the admin through `QuitElection()`. If the admin loses their private key, becomes uncooperative, or has a dispute with the sponsor, the sponsor has no direct mechanism to reclaim their funds and must rely on slow governance intervention through Parliament.

### Finding Description

The vulnerability exists in the separation of token ownership and unlock authority in `AnnounceElectionFor()`:

**Token Locking by Sponsor:** [1](#0-0) 

The sponsor (Context.Sender) pays the 100,000 ELF deposit which gets locked to a virtual address.

**Admin Assignment Separation:** [2](#0-1) 

At line 127, the admin can be set to any address via `input.Admin`, differing from the sponsor (Context.Sender). The sponsor is recorded separately at line 140.

**Admin-Only Unlock Permission:** [3](#0-2) 

Line 236 enforces that ONLY the admin can call `QuitElection()` to unlock the tokens. Line 245 shows tokens are returned to the sponsor, but the admin controls when this happens.

**Insufficient Escape Hatch:** [4](#0-3) 

While Parliament can change the admin (line 27 bypass), this requires a governance proposal and may not be approved, creating unnecessary friction for what should be a sponsor-controlled asset.

### Impact Explanation

**Direct Fund Impact:**
- Sponsor's 100,000 ELF deposit (ElectionContractConstants.LockTokenForElection) becomes inaccessible without admin cooperation
- If admin loses private key: Sponsor must request Parliament intervention, face delays, governance approval uncertainty, and potential rejection
- If admin becomes uncooperative: Sponsor enters dispute requiring governance arbitration

**Who Is Affected:**
- Sponsors who set different admin addresses (organizations sponsoring candidates, delegation scenarios)
- Estimated impact per incident: 100,000 ELF locked indefinitely without recourse

**Severity Justification:**
Medium severity because:
1. Funds are not permanently lost (Parliament escape hatch exists)
2. However, recovery requires slow governance process with uncertain outcome
3. Creates unnecessary trust dependency for sponsor's own assets
4. No time-based fallback or sponsor-controlled emergency unlock

### Likelihood Explanation

**Reachable Entry Point:**
`AnnounceElectionFor()` is a public method explicitly designed to support sponsor ≠ admin scenarios.

**Feasible Preconditions:**
1. Sponsor calls `AnnounceElectionFor` with `input.Admin` set to different address (supported feature)
2. Admin loses private key, gets compromised, or disputes with sponsor (common in blockchain operations)
3. No unusual attacker capabilities required

**Execution Practicality:**
Scenario 1 (Key Loss):
- Sponsor: Organization A pays deposit
- Admin: Candidate B manages operations
- Candidate B loses private key → Organization A cannot reclaim 100,000 ELF without Parliament

Scenario 2 (Dispute):
- Sponsor wants to quit and reclaim deposit
- Admin refuses to cooperate
- Sponsor has no direct recourse except Parliament proposal

**Economic Rationality:**
- No attack cost (happens through normal usage or accidents)
- 100,000 ELF per candidate is significant value
- Key loss and disputes are realistic operational risks

**Probability:**
Medium - Feature is explicitly supported, but requires sponsor-admin separation which may be less common than self-sponsorship. However, when used, the risk materializes immediately upon admin key compromise or cooperation failure.

### Recommendation

**Primary Fix - Add Sponsor Emergency Unlock:**
Add a time-delayed sponsor reclaim mechanism in `QuitElection()`:

```solidity
// Allow sponsor to quit if admin hasn't acted within timelock period
var sponsor = State.CandidateSponsorMap[pubkey];
var admin = State.CandidateAdmins[initialPubkey];
var announcementTime = candidateInformation.AnnouncementTransactionId timestamp;

if (Context.Sender == admin) {
    // Admin can quit immediately
} else if (Context.Sender == sponsor && 
           Context.CurrentBlockTime > announcementTime + 30 days) {
    // Sponsor can quit after 30-day timelock if admin hasn't
} else {
    Assert(false, "Only admin or sponsor (after timelock) can quit election.");
}
```

**Alternative Fix - Require Sponsor Approval:**
Modify `AnnounceElectionFor()` to require explicit sponsor authorization when admin ≠ sponsor, storing this approval on-chain to document the trust relationship.

**Invariant Check:**
Add assertion: "Sponsor must always have eventual unlock authority over their own locked funds, either directly or through time-bound fallback."

**Test Cases:**
1. Sponsor sets different admin → Admin quits normally → Tokens return to sponsor ✓
2. Sponsor sets different admin → Wait 30 days → Sponsor quits directly → Tokens return to sponsor ✓
3. Sponsor sets different admin → Sponsor attempts immediate quit → Transaction fails ✓
4. Parliament changes admin → New admin can quit → Tokens return to original sponsor ✓

### Proof of Concept

**Initial State:**
- Alice (sponsor) has 200,000 ELF balance
- Bob (admin) is a separate account
- Candidate pubkey belongs to Charlie

**Execution Steps:**

**Step 1 - Sponsor Announces Election:**
```
Caller: Alice
Method: AnnounceElectionFor(AnnounceElectionForInput {
    Pubkey: Charlie's pubkey,
    Admin: Bob's address
})
Result: 
- Alice's balance: 100,000 ELF (locked 100,000)
- State.CandidateAdmins[Charlie] = Bob
- State.CandidateSponsorMap[Charlie] = Alice
```

**Step 2 - Admin Key Compromise:**
```
Event: Bob loses private key or becomes uncooperative
Result: Bob cannot call QuitElection()
```

**Step 3 - Sponsor Attempts Direct Unlock:**
```
Caller: Alice
Method: QuitElection(Charlie's pubkey)
Result: TRANSACTION FAILS
Error: "Only admin can quit election."
```

**Expected vs Actual:**
- **Expected**: Alice (sponsor who paid) can reclaim her 100,000 ELF deposit
- **Actual**: Alice cannot unlock her own funds without Bob's cooperation or Parliament intervention

**Success Condition for Exploit:**
Alice's 100,000 ELF remains locked indefinitely while she maintains no direct control over unlocking, demonstrating the sponsor's loss of fund control when admin differs.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-42)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-250)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });

```
