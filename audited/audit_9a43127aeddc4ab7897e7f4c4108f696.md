### Title
Infinite Loop in NFT Symbol Generation Due to Fixed Hash Reuse in Collision Handling

### Summary
The `GenerateSymbolNumber()` function contains a do-while loop that reuses the same hash value on every iteration when checking for symbol number collisions. Since `Context.ConvertHashToInt64()` is deterministic, the loop generates the same number repeatedly if a collision occurs, resulting in an infinite loop that only terminates when transaction gas is exhausted. This causes legitimate NFT protocol creation transactions to fail with gas depletion.

### Finding Description
The vulnerability exists in the `GenerateSymbolNumber()` function [1](#0-0) 

The root cause is that `randomHash` is computed once before the collision-checking loop [2](#0-1)  and this same hash is reused inside the do-while loop [3](#0-2) 

The `Context.ConvertHashToInt64()` function is deterministic and always returns the same output for the same input hash [4](#0-3) 

When a generated symbol number already exists in `State.IsCreatedMap`, the while condition remains true, but since the hash never changes, the exact same number is generated again on the next iteration, creating an infinite loop with no exit condition except gas exhaustion.

The function is called from the publicly accessible `Create()` method [5](#0-4)  via the `GetSymbol()` helper [6](#0-5) 

There is no maximum iteration limit, no hash regeneration mechanism, and no fallback strategy when collisions occur.

### Impact Explanation
**Direct Operational Impact:**
- Any user attempting to create an NFT protocol that collides with an existing symbol number will experience complete transaction failure due to gas exhaustion
- Users lose all gas fees paid for the failed transaction with no protocol created
- As the symbol space fills up over time (tracked in `State.IsCreatedMap`), the probability of natural collisions increases exponentially, making legitimate operations progressively more likely to fail

**Griefing Attack Potential:**
- An attacker can monitor pending transactions and calculate the predictable random number generation (based on sender address and block height)
- By front-running with strategic NFT creations, the attacker can force specific users' transactions to hit collisions
- This is particularly damaging for high-value NFT protocol launches where timing and gas costs are critical

**Who Is Affected:**
- All users creating NFT protocols on the mainchain via the `Create()` method
- Protocol adoption and usability severely degraded as symbol space saturation increases

**Severity Justification:**
This is a HIGH severity issue because it causes guaranteed DoS of a core protocol function (NFT creation), results in direct financial loss through wasted gas fees, enables targeted griefing attacks, and becomes progressively worse over time as more symbols are created.

### Likelihood Explanation
**Attacker Capabilities:**
- Any user can call the public `Create()` method without special permissions
- The random number generation is predictable because it depends on deterministic inputs (sender address, block height minus one)
- An attacker can compute what number will be generated for a target user's transaction

**Attack Complexity:**
- Low complexity: Simply call `Create()` with symbols that occupy the target numbers
- Front-running is feasible on blockchain networks with mempool visibility
- No special permissions or complex state manipulation required

**Feasibility Conditions:**
- Attack succeeds whenever a collision occurs, which can be engineered by the attacker
- Natural collisions become increasingly likely as the symbol space fills (birthday paradox)
- No defensive mechanisms exist in the code to prevent or handle this scenario

**Detection/Operational Constraints:**
- Failed transactions appear as normal out-of-gas failures, making debugging difficult
- Users may repeatedly attempt creation, wasting more gas each time
- The issue compounds as the protocol grows and symbol space becomes more saturated

**Probability Reasoning:**
HIGH likelihood because the attack requires minimal sophistication, can be executed by any user, and the natural occurrence rate increases over time due to space saturation without any collision resolution mechanism.

### Recommendation
**Immediate Code-Level Mitigation:**

1. Regenerate the hash on each iteration by incorporating a loop counter:
   - Add a loop iteration counter
   - On each iteration, combine the original hash with the counter to generate a new hash
   - This ensures different numbers are attempted on subsequent iterations

2. Add a maximum iteration limit to prevent infinite loops:
   - Define a constant maximum iteration count (e.g., 100 attempts)
   - If limit is reached, expand the symbol number length using the existing `GetCurrentNumberLength()` mechanism or throw a clear error

3. Implement proper collision resolution strategy:
   - Consider expanding number space dynamically when collision rate exceeds threshold
   - Add fallback mechanism to try different NFT type prefixes or number ranges

**Example Fix Pattern:**
```
var maxAttempts = 100;
var attempt = 0;
do {
    var currentHash = HashHelper.ConcatAndCompute(randomHash, 
        HashHelper.ComputeFrom(attempt));
    randomNumber = Context.ConvertHashToInt64(currentHash, from, from.Mul(10));
    attempt++;
} while (State.IsCreatedMap[randomNumber] && attempt < maxAttempts);
Assert(attempt < maxAttempts, "Unable to generate unique symbol number");
```

**Invariant Checks:**
- Assert that loop iterations never exceed defined maximum
- Monitor collision rates and trigger symbol space expansion proactively
- Add state query to check symbol space saturation before allowing creation

**Test Cases:**
- Test collision scenario where generated number is pre-occupied
- Test gas consumption with varying collision rates
- Test maximum iteration limit enforcement
- Test symbol space expansion when saturation threshold reached

### Proof of Concept

**Initial State:**
- NFT contract deployed on AELF mainchain
- Symbol space has some existing protocols created

**Attack Sequence:**

1. **Attacker observes pending transaction** from VictimUser creating NFT protocol with type "Art"

2. **Attacker calculates** what random number will be generated:
   - Hash will be: `HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(VictimUser.Address), HashHelper.ComputeFrom(randomBytes))`
   - Random bytes are from block height - 1, which is predictable
   - Resulting number can be pre-computed

3. **Attacker front-runs** by calling `Create()` to occupy that exact symbol number

4. **VictimUser's transaction executes:**
   - Enters `GenerateSymbolNumber()` function
   - Computes same `randomHash` as predicted
   - Enters do-while loop at line 79
   - Generates the pre-occupied number
   - `State.IsCreatedMap[randomNumber]` returns true
   - Loop continues with SAME hash
   - Generates SAME number again
   - Loop never exits
   - Transaction runs until gas limit reached

**Expected Result:** NFT protocol created successfully with unique symbol

**Actual Result:** Transaction fails with out-of-gas error, all gas fees consumed, no protocol created

**Success Condition:** VictimUser's transaction consumes all available gas and reverts, demonstrating the infinite loop vulnerability. This can be verified by checking transaction execution traces showing repeated identical number generation attempts until gas depletion.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L169-178)
```csharp
    public long ConvertHashToInt64(Hash hash, long start = 0, long end = long.MaxValue)
    {
        if (start < 0 || start > end) throw new ArgumentException("Incorrect arguments.");

        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-23)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
```
