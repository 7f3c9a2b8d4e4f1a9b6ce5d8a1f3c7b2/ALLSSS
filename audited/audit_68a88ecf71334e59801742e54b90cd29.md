# Audit Report

## Title
Dictionary Key Mismatch in RecoverFromUpdateValue Causes Consensus Validation DoS During Miner Replacement

## Summary
The `RecoverFromUpdateValue` function contains a critical bug where it iterates over all miners in the provided round and directly accesses the current round's `RealTimeMinersInformation` dictionary without checking if keys exist. This causes a `KeyNotFoundException` during miner replacement scenarios when blocks contain miners not present in the validator's current round state, resulting in consensus validation failure before the system's designed miner replacement validation logic can execute.

## Finding Description

The vulnerability exists in the `RecoverFromUpdateValue` method where it performs unsafe dictionary access: [1](#0-0) 

**Root Cause:** While the function checks if the sender's pubkey exists in both rounds [2](#0-1) , it then iterates over ALL miners in the provided round and directly accesses `RealTimeMinersInformation[information.Key]` without verifying each key exists. This violates C# dictionary safety and throws `KeyNotFoundException` when a key from the provided round doesn't exist in the current round.

**Why This Occurs:** During miner replacement via `RecordCandidateReplacement`, the current round's miner list is modified by removing the old pubkey and adding a new one [3](#0-2) . When a block produced before the replacement (containing the old miner list) is validated after the replacement, the provided round contains miners not in the current round.

**Validation Call Paths:**

*Before-execution validation:* [4](#0-3) 

*After-execution validation:* [5](#0-4) 

**Unreachable Protection:** The system has miner replacement validation logic designed to handle this scenario [6](#0-5) , but it's unreachable because the exception is thrown at line 91 before this validation can execute.

**Pattern Inconsistency:** The codebase consistently uses `ContainsKey` checks before accessing `RealTimeMinersInformation` throughout:
- [7](#0-6) 
- [8](#0-7) 

The missing check in `RecoverFromUpdateValue` breaks this defensive pattern.

## Impact Explanation

**High Severity DoS Impact:**
- Blocks containing consensus data from before miner replacement fail validation with unhandled exceptions rather than being properly validated or gracefully rejected
- Consensus validation becomes unreliable during miner replacement transitions as nodes with different timing see different round states
- The designed miner replacement validation mechanism (lines 103-123) that would properly handle these cases never executes
- Network disruption during normal protocol operations (miner replacement is a legitimate feature)

**Affected Operations:**
- Block validation during miner replacement events executed via [9](#0-8) 
- Consensus integrity during term transitions when miner lists change
- All nodes attempting to validate blocks during these state transitions

**Security Guarantees Broken:**
- Consensus validation should handle legitimate state transitions gracefully
- Blocks following protocol rules should be validated correctly or rejected with proper error handling
- Miner replacement should not cause validation failures via exceptions

## Likelihood Explanation

**High Likelihood - Normal Operations:**

Miner replacement is a standard protocol feature executed when candidates update their public keys. The vulnerability triggers during legitimate operations without malicious intent.

**Triggering Scenario:**
1. At time T1, miner M1 is active in the current round with miner list [M1, M2, M3]
2. Miner M1's candidate admin calls `ReplaceCandidatePubkey` to replace M1 with M4
3. Node A produced a block at T1 with consensus data containing [M1, M2, M3]
4. Node B processes the replacement, updating its current round to [M4, M2, M3]
5. Node B receives Node A's block and validates it
6. `RecoverFromUpdateValue` iterates over [M1, M2, M3] from the block
7. Dictionary access for M1 fails because M1 was removed from the current round
8. `KeyNotFoundException` thrown, validation fails

**Preconditions:** Only normal protocol operations:
- Miner replacement via the Election contract (happens periodically)
- Block propagation timing differences between nodes (inherent in distributed systems)

**No Special Privileges Required:** This occurs during normal consensus operation, not requiring attacker control.

## Recommendation

Add `ContainsKey` validation before dictionary access in the foreach loop to match the defensive pattern used throughout the codebase:

```csharp
foreach (var information in providedRound.RealTimeMinersInformation)
{
    if (!RealTimeMinersInformation.ContainsKey(information.Key))
        continue; // Skip miners not in current round
        
    RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
        information.Value.SupposedOrderOfNextRound;
    RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
        information.Value.FinalOrderOfNextRound;
    RealTimeMinersInformation[information.Key].PreviousInValue =
        information.Value.PreviousInValue;
}
```

This allows the function to skip miners that have been replaced, permitting the proper miner replacement validation logic at lines 103-123 to execute and handle the scenario correctly.

## Proof of Concept

```csharp
[Fact]
public void RecoverFromUpdateValue_ThrowsKeyNotFoundException_WhenMinerReplaced()
{
    // Setup: Create current round with miners M2, M3, M4 (M1 was replaced with M4)
    var currentRound = new Round
    {
        RoundNumber = 1,
        RealTimeMinersInformation =
        {
            ["M2"] = new MinerInRound { Pubkey = "M2" },
            ["M3"] = new MinerInRound { Pubkey = "M3" },
            ["M4"] = new MinerInRound { Pubkey = "M4" }
        }
    };

    // Setup: Create provided round from old block with miners M1, M2, M3 (before replacement)
    var providedRound = new Round
    {
        RoundNumber = 1,
        RealTimeMinersInformation =
        {
            ["M1"] = new MinerInRound { Pubkey = "M1", SupposedOrderOfNextRound = 1 },
            ["M2"] = new MinerInRound { Pubkey = "M2", SupposedOrderOfNextRound = 2 },
            ["M3"] = new MinerInRound { Pubkey = "M3", SupposedOrderOfNextRound = 3 }
        }
    };

    // Execute: Call RecoverFromUpdateValue with M2 as sender (exists in both)
    // Expected: Should throw KeyNotFoundException when accessing M1
    var exception = Assert.Throws<KeyNotFoundException>(() =>
    {
        currentRound.RecoverFromUpdateValue(providedRound, "M2");
    });
    
    // The exception proves the vulnerability - legitimate miner replacement 
    // scenarios cause unhandled exceptions in consensus validation
}
```

## Notes

This vulnerability affects the critical consensus validation path and can occur during normal protocol operations (miner replacement). The issue is particularly severe because:

1. **Legitimate State Transitions Fail:** Normal miner replacement operations cause validation failures
2. **Unreachable Protection:** Existing miner replacement validation logic exists but cannot execute due to the exception
3. **Pattern Violation:** The codebase consistently uses `ContainsKey` checks elsewhere, indicating this is a missed defensive check
4. **Distributed System Race:** The timing-dependent nature of block propagation vs state updates makes this highly likely to occur in production

The fix is straightforward (add `ContainsKey` check) and aligns with existing code patterns. The miner replacement validation at lines 103-123 would then properly handle scenarios where miner lists differ between block production and validation time.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L10-12)
```csharp
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-92)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L103-123)
```csharp
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L10-10)
```csharp
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-26)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
```
