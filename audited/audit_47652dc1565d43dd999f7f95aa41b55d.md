# Audit Report

## Title
Consensus Behavior Validation Bypass Allows Indefinite Term Change Prevention

## Summary
The AEDPoS consensus validation system validates that block data is structurally consistent with the claimed consensus behavior (NextRound vs NextTerm) but never independently verifies that the claimed behavior matches what consensus rules require. A malicious miner can produce NextRound blocks when NextTerm is required, bypassing term transitions indefinitely and preventing election results, miner list updates, and reward distributions from taking effect.

## Finding Description

The vulnerability exists in a critical gap between behavior determination and validation in the consensus system.

**Behavior Determination (What SHOULD Happen):**

The honest flow determines consensus behavior through `MainChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()`, which calls `NeedToChangeTerm()` to check if 2/3 of miners have reached the term change threshold. [1](#0-0) 

When `NeedToChangeTerm()` returns true (and not round 1 or single node), it returns `NextTerm` behavior. [2](#0-1) 

**Validation Logic (What IS Validated):**

The validation system reads the claimed behavior from `extraData.Behaviour` and adds validators based on that claim: [3](#0-2) 

The `RoundTerminateValidationProvider` validates structural consistency with the claimed behavior: [4](#0-3) 

For NextRound, it only checks that the round number increments and InValues are null. For NextTerm, it additionally checks term number increments. **Critically, it never calls `NeedToChangeTerm()` to verify the behavior choice was correct.**

**Execution Without Cross-Validation:**

The execution methods process the claimed behavior without verifying it matches consensus requirements: [5](#0-4) 

`ProcessNextRound` executes without any assertion that term change is not needed.

**Attack Scenario:**

1. Blockchain reaches a state where `NeedToChangeTerm()` returns true (2/3 miners past term threshold)
2. Malicious miner's turn to produce the round-ending block
3. Instead of calling `NextTerm()`, attacker calls `NextRound()` via the public entry point: [6](#0-5) 

4. Attacker provides structurally valid NextRoundInput (round number + 1, same term, InValues null)
5. Validation passes because it only checks NextRound structural consistency
6. `ProcessNextRound` executes, bypassing term change
7. Attack repeats indefinitely every round

## Impact Explanation

**HIGH - Consensus and Governance Integrity Violation**

When term changes are prevented, the following critical failures occur:

1. **Election Results Never Applied**: New miners elected through governance cannot join consensus because `ProcessNextTerm` is never called to fetch new miners from the Election contract and update the miner list. [7](#0-6) 

2. **Reward Distribution Blocked**: Mining rewards donation to Treasury and treasury profit releases are tied to term boundaries and never occur. [8](#0-7) 

3. **Election Snapshots Missing**: Historical voting records are never captured, breaking election accounting. [9](#0-8) 

4. **Governance System Compromised**: Current miners maintain control indefinitely regardless of election results, fundamentally breaking AEDPoS's democratic consensus mechanism.

This affects all network participants and violates the core security guarantee that elected miners will take effect after term periods.

## Likelihood Explanation

**HIGH Likelihood**

**Accessible Entry Point**: The `NextRound` method is public and directly callable by any miner. Access control only verifies the caller is in the current or previous miner list via `PreCheck()`: [10](#0-9) 

**Realistic Preconditions**: The attack only requires:
- Blockchain state where term change threshold is reached (normal periodic occurrence)
- Attacker is a miner in current miner list (realistic - they want to stay miners)

**Simple Execution**: No complex cryptographic operations or state manipulation required. Attacker simply calls a different public method than they should.

**Detection Difficulty**: The block appears as a valid NextRound transition. Other nodes validate it using the same flawed logic that doesn't check if NextTerm should have been used instead.

**Economic Incentive**: Incumbent miners have strong economic motivation to prevent term changes to maintain their mining rewards and governance control. Attack cost is negligible (just modify node behavior), while benefit is significant (continued revenue).

## Recommendation

Add independent verification in the validation logic that the claimed behavior matches consensus requirements:

```csharp
// In RoundTerminateValidationProvider or ValidateBeforeExecution:

if (extraData.Behaviour == AElfConsensusBehaviour.NextRound)
{
    // Verify NextRound is the correct behavior
    var blockchainStartTimestamp = GetBlockchainStartTimestamp();
    var periodSeconds = State.PeriodSeconds.Value;
    
    if (validationContext.BaseRound.RoundNumber > 1 && 
        validationContext.BaseRound.RealTimeMinersInformation.Keys.Count > 1 &&
        validationContext.BaseRound.NeedToChangeTerm(
            blockchainStartTimestamp, 
            validationContext.CurrentTermNumber, 
            periodSeconds))
    {
        return new ValidationResult 
        { 
            Success = false, 
            Message = "NextTerm behavior required but NextRound was used" 
        };
    }
}
```

Alternatively, add an assertion in `ProcessNextRound`:

```csharp
// At the start of ProcessNextRound:
var blockchainStartTimestamp = GetBlockchainStartTimestamp();
Assert(
    !currentRound.NeedToChangeTerm(blockchainStartTimestamp, 
        State.CurrentTermNumber.Value, State.PeriodSeconds.Value) ||
    currentRound.RoundNumber == 1 ||
    currentRound.RealTimeMinersInformation.Keys.Count == 1,
    "Term change required - must use NextTerm instead of NextRound"
);
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanBypassTermChange_ByCallingNextRound()
{
    // Setup: Initialize consensus with term period
    await InitializeConsensusWithTermPeriod(periodSeconds: 604800); // 7 days
    
    // Advance blockchain past term threshold (>7 days elapsed)
    // Ensure 2/3+ miners have mined blocks in the new period
    await AdvancePastTermThreshold();
    
    // Verify NeedToChangeTerm would return true
    var currentRound = await GetCurrentRound();
    var blockchainStartTimestamp = await GetBlockchainStartTimestamp();
    var needsTermChange = currentRound.NeedToChangeTerm(
        blockchainStartTimestamp, currentTermNumber: 1, periodSeconds: 604800);
    Assert.True(needsTermChange); // Term change is required
    
    // Malicious miner calls NextRound instead of NextTerm
    var nextRoundInput = GenerateValidNextRoundInput(currentRound);
    await ConsensusStub.NextRound.SendAsync(nextRoundInput);
    
    // Verify attack succeeded:
    var newRound = await GetCurrentRound();
    Assert.Equal(currentRound.RoundNumber + 1, newRound.RoundNumber); // Round incremented
    Assert.Equal(1, await GetCurrentTermNumber()); // Term stayed at 1 (VULNERABILITY)
    
    // Verify term change was bypassed:
    var minerList = await GetCurrentMinerList();
    Assert.Equal(currentRound.RealTimeMinersInformation.Keys, 
                 minerList.Pubkeys); // Same miners (election results ignored)
}
```

This test demonstrates that a miner can successfully call `NextRound` when `NeedToChangeTerm` returns true, bypassing the term transition and preventing election results from taking effect. The validation accepts the block, and the term number remains unchanged while the round increments, proving the vulnerability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-191)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L203-211)
```csharp

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L213-218)
```csharp

```
