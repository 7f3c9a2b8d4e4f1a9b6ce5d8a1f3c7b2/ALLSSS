### Title
Ineffective Mining Order Validation Allows Consensus Non-Determinism Through Duplicate FinalOrderOfNextRound Values

### Summary
The `NextRoundMiningOrderValidationProvider` fails to validate the uniqueness of `FinalOrderOfNextRound` values in the current round, allowing miners to create duplicate order values via `TuneOrderInformation` during `UpdateValue`. This causes non-deterministic miner ordering when generating the next round, breaking consensus across nodes.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:**
The validation uses `.Distinct()` on `MinerInRound` objects rather than on `FinalOrderOfNextRound` values themselves. Since each miner has a unique pubkey, this effectively counts all miners with `FinalOrderOfNextRound > 0` without checking if the order values are unique.

More critically, this validation checks the provided NEXT round (where miners haven't mined yet), making both sides of the comparison equal to 0. The validation should check the CURRENT round's `FinalOrderOfNextRound` uniqueness before next round generation.

**Attack Path:**

1. During `UpdateValue`, miners set their own `FinalOrderOfNextRound` and can modify others via `TuneOrderInformation`: [2](#0-1) 

2. The `UpdateValueValidationProvider` does not check for duplicate `FinalOrderOfNextRound` values: [3](#0-2) 

3. When `NextRound` is generated, it orders miners by `FinalOrderOfNextRound` using non-deterministic LINQ `OrderBy`: [4](#0-3) 

4. LINQ's `OrderBy` does not guarantee stable ordering for equal keys, causing different nodes to potentially produce different miner sequences for the next round.

### Impact Explanation

**Consensus Integrity Failure:**
- Different nodes generate different next round miner orders from the same current round state
- This breaks the fundamental determinism requirement of blockchain consensus
- Nodes would disagree on which miner should produce blocks at specific times
- Results in chain forks, failed block validation, and complete consensus breakdown

**Affected Parties:**
- All network participants suffer from consensus instability
- Block producers cannot reliably produce blocks in their assigned time slots
- Network could halt or split into incompatible chains

**Severity:** Critical - Complete consensus failure affecting entire network operation.

### Likelihood Explanation

**Attacker Capabilities:**
Any active miner can execute this attack during their normal `UpdateValue` operation by manipulating the `TuneOrderInformation` parameter: [5](#0-4) 

**Attack Complexity:** Low
- Attacker simply includes duplicate order values in `TuneOrderInformation` when calling `UpdateValue`
- No special privileges required beyond being an active miner
- No complex timing or state manipulation needed

**Feasibility:** High
- The attack vector is a direct public method call available to all miners
- No validation prevents duplicate `FinalOrderOfNextRound` values during `UpdateValue`
- The flawed validation during `NextRound` does not catch the issue

**Detection Difficulty:** High until consensus fails
- No immediate indication of malicious tuning during `UpdateValue`
- Consensus divergence only becomes apparent when next round is generated
- By then, the corrupt state is already persisted

### Recommendation

**Immediate Fix:**
Modify `NextRoundMiningOrderValidationProvider` to validate `FinalOrderOfNextRound` uniqueness in the base (current) round:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var baseRound = validationContext.BaseRound; // Check current round, not provided next round
    
    var minersWithOrders = baseRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0).ToList();
    
    var uniqueOrders = minersWithOrders
        .Select(m => m.FinalOrderOfNextRound)
        .Distinct()
        .Count();
    
    if (uniqueOrders != minersWithOrders.Count)
    {
        validationResult.Message = "Duplicate FinalOrderOfNextRound values detected.";
        return validationResult;
    }
    
    if (minersWithOrders.Count != baseRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound count.";
        return validationResult;
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

**Additional Safeguards:**
1. Add validation in `ProcessUpdateValue` to prevent setting duplicate values via `TuneOrderInformation`
2. Add invariant check in `GenerateNextRoundInformation` to assert no duplicate `FinalOrderOfNextRound` values exist
3. Add unit tests verifying rejection of duplicate order values
4. Consider using stable sort or explicit tie-breaking logic in `OrderBy` calls

### Proof of Concept

**Initial State:**
- Current round with 3 miners (A, B, C)
- Miner A has mined (OutValue set, SupposedOrderOfNextRound = 2)
- Miner B has mined (OutValue set, SupposedOrderOfNextRound = 3)
- Miner C has mined (OutValue set, SupposedOrderOfNextRound = 1)

**Attack Steps:**
1. Miner A calls `UpdateValue` with `TuneOrderInformation = {("B", 2)}` to set Miner B's `FinalOrderOfNextRound` to 2 (same as A's)
2. Current round state now has: A.FinalOrderOfNextRound = 2, B.FinalOrderOfNextRound = 2, C.FinalOrderOfNextRound = 1
3. `UpdateValueValidationProvider` passes (doesn't check uniqueness)
4. State is persisted with duplicate order values
5. Node X calls `NextRound`, generates next round via `GenerateNextRoundInformation`
6. `OrderBy(m => m.FinalOrderOfNextRound)` with duplicates produces non-deterministic ordering
7. Node X might order as: [C(order=1), A(order=2), B(order=3)]
8. Node Y might order as: [C(order=1), B(order=2), A(order=3)]
9. Nodes X and Y produce different next rounds from identical state
10. Consensus divergence detected; network cannot agree on block producer schedule

**Expected Result:** Duplicate `FinalOrderOfNextRound` values should be rejected during validation

**Actual Result:** Duplicate values pass validation and cause consensus non-determinism

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-260)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```
