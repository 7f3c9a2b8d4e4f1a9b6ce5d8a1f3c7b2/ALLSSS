### Title
NFT Contract SetMethodFee Governance Bypass - Immutable Fee Violates ACS1 Standard

### Summary
The NFT contract's `SetMethodFee` implementation is a no-op stub that does not store any fee data, while `GetMethodFee` returns a hardcoded 100 ELF fee for the Create method. This violates the ACS1 standard's explicit promise that SetMethodFee controls method fees, rendering governance powerless to adjust fees and breaking the core governance model where Parliament should be able to manage transaction costs.

### Finding Description

**Root Cause - Stub Implementation:**

The NFT contract implements `SetMethodFee` as a no-op that simply returns Empty without any logic or state modifications. [1](#0-0) 

Similarly, `ChangeMethodFeeController` is also a stub returning Empty. [2](#0-1) 

**Hardcoded Fee in GetMethodFee:**

Despite SetMethodFee being non-functional, `GetMethodFee` returns a hardcoded 100_00000000 (100 ELF) fee for the "Create" method, ignoring any stored state. [3](#0-2) 

**Missing State Variables:**

The NFTContractState lacks the required state variables that proper ACS1 implementations use to store method fees and controller information. [4](#0-3) 

**Comparison with Correct Implementation:**

The proper pattern requires `MethodFeeController` and `TransactionFees` state variables as shown in Configuration contract. [5](#0-4) 

A correct SetMethodFee implementation validates input, checks authorization, and stores fees in state as demonstrated by the MultiToken contract. [6](#0-5) 

A correct GetMethodFee retrieves stored fees from state rather than returning hardcoded values. [7](#0-6) 

**How Fees Are Actually Charged:**

The fee charging mechanism calls GetMethodFee on the target contract to retrieve fee configuration before transaction execution. [8](#0-7) 

**ACS1 Standard Violation:**

The ACS1 standard explicitly documents that SetMethodFee should "Set the method fees for the specified method. Note that this will override all fees of the method." [9](#0-8) 

The standard shows that SetMethodFee must validate tokens, check authorization, and store fees in State.TransactionFees. [10](#0-9) 

The standard requires GetMethodFee to return stored values from State.TransactionFees. [11](#0-10) 

### Impact Explanation

**Governance Authority Bypass:**
Parliament and governance organizations cannot fulfill their intended role of managing transaction fees for the NFT contract. The ACS1 standard establishes that governance (specifically Parliament's default organization) controls method fees, but this contract bypasses that authority entirely.

**Immutable Economic Parameters:**
The 100 ELF Create fee is hardcoded and cannot be adjusted based on:
- Market conditions (token price fluctuations)
- Network congestion levels
- Community governance decisions
- Economic policy changes

**Misleading Success:**
When governance attempts to set fees through proper channels:
1. Parliament creates a proposal to call SetMethodFee
2. Block producers approve the proposal
3. The transaction executes successfully (returns Empty, no revert)
4. Governance believes the fee was changed
5. **Reality: Nothing changed - the fee remains 100 ELF**

This creates a false sense of control and wastes governance resources on ineffective proposals.

**Standard Violation:**
Breaks the fundamental contract of ACS1 that all AElf system contracts are expected to honor, undermining the consistency and predictability of the platform's governance model.

### Likelihood Explanation

**High Probability Scenario:**
Governance regularly adjusts method fees across all system contracts in response to economic conditions. The NFT contract implements the ACS1 interface, signaling to governance that it supports fee management. Parliament will inevitably attempt to adjust the Create fee through normal governance processes.

**No Authentication Required:**
The exploit doesn't require any privileged access - governance's own legitimate actions trigger the issue. Any governance member proposing a fee change through proper channels will encounter this problem.

**Silent Failure:**
The transaction succeeds without error, providing no indication that the operation was ineffective. There are no reverts, no error messages, and no events to signal the failure. Governance would only discover the issue by:
- Manually querying GetMethodFee after the proposal
- Observing that users are still charged 100 ELF
- Analyzing the contract source code

**No Testing Coverage:**
Grep search confirms there are no tests for NFT contract's SetMethodFee functionality, indicating this issue has never been validated during development.

**Realistic Trigger Conditions:**
- Token price changes making 100 ELF too expensive/cheap
- Community requests for fee adjustments
- Alignment with other contract fee structures
- Economic policy updates

### Recommendation

**1. Add Required State Variables:**

Add to NFTContractState.cs:
```csharp
public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
public MappedState<string, MethodFees> TransactionFees { get; set; }
```

**2. Implement SetMethodFee Properly:**

Replace the stub implementation with proper logic:
- Validate token symbols and amounts using AssertValidToken
- Initialize MethodFeeController if not set (defaulting to Parliament)
- Check authorization: Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress)
- Store fees: State.TransactionFees[input.MethodName] = input

**3. Update GetMethodFee:**

Modify GetMethodFee to:
- First check State.TransactionFees[input.Value]
- Return stored fees if they exist
- Fall back to hardcoded 100 ELF default only if not set
- This maintains backward compatibility while enabling governance control

**4. Implement ChangeMethodFeeController:**

Add proper implementation:
- Require current controller authorization
- Validate organization exists using CheckOrganizationExist
- Update State.MethodFeeController.Value

**5. Implement GetMethodFeeController:**

Return the actual controller:
- Call RequiredMethodFeeControllerSet() to initialize if needed
- Return State.MethodFeeController.Value

**6. Add Comprehensive Tests:**

Create test cases covering:
- SetMethodFee without authorization (should fail)
- SetMethodFee with Parliament authorization (should succeed)
- GetMethodFee returns stored fees after SetMethodFee
- ChangeMethodFeeController authorization checks
- Default fee behavior before any fees are set

### Proof of Concept

**Initial State:**
- NFT contract deployed with current implementation
- GetMethodFee("Create") returns 100 ELF

**Step 1 - Governance Attempts Fee Change:**
```
Parliament creates proposal:
- ToAddress: NFT_CONTRACT_ADDRESS
- ContractMethodName: "SetMethodFee"
- Params: MethodFees { MethodName = "Create", Fees = { { Symbol = "ELF", BasicFee = 50_00000000 } } }
```

**Step 2 - Proposal Approved and Released:**
- Miners approve proposal (meets threshold)
- Proposal is released and executed
- Transaction succeeds with result: Empty (no revert)

**Step 3 - Verify Fee Change:**
```
Query: GetMethodFee("Create")
Expected: 50 ELF (the newly set fee)
Actual: 100 ELF (unchanged hardcoded value)
```

**Step 4 - User Creates NFT:**
```
User calls: Create(...)
Expected: Charged 50 ELF
Actual: Charged 100 ELF (per hardcoded GetMethodFee)
```

**Success Condition for Exploit:**
The governance proposal executes successfully but has zero effect on actual fee charged. The Create method continues charging 100 ELF despite governance's explicit action to change it to 50 ELF, proving governance control is illusory.

**Evidence of Standard Violation:**
The ACS1 documentation states SetMethodFee "will override all fees of the method," but this implementation violates that promise, breaking the governance contract that Parliament relies upon.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-11)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L13-16)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L1-46)
```csharp
﻿using AElf.Sdk.CSharp.State;
using AElf.Types;

namespace AElf.Contracts.NFT;

public partial class NFTContractState : ContractState
{
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
}
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationState.cs (L10-11)
```csharp
    public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
    public MappedState<string, MethodFees> TransactionFees { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L37-52)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (new List<string>
            {
                nameof(ClaimTransactionFees), nameof(DonateResourceToken), nameof(ChargeTransactionFees),
                nameof(CheckThreshold), nameof(CheckResourceToken), nameof(ChargeResourceToken),
                nameof(CrossChainReceiveToken)
            }.Contains(input.Value))
            return new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
        var fees = State.TransactionFees[input.Value];
        return fees;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-39)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
```

**File:** docs-sphinx/reference/acs/acs1.rst (L17-17)
```text
| SetMethodFee                | `acs1.MethodFees <#acs1.MethodFees>`__                           | `google.protobuf.Empty <#google.protobuf.Empty>`__   | Set the method fees for the specified method. Note that this will override all fees of the method.   |
```

**File:** docs-sphinx/reference/acs/acs1.rst (L293-295)
```text
   public override MethodFees GetMethodFee(StringValue input)
       return State.TransactionFees[input.Value];
   }
```

**File:** docs-sphinx/reference/acs/acs1.rst (L316-326)
```text
   public override Empty SetMethodFee(MethodFees input)
   {
     foreach (var symbolToAmount in input.Fees)
     {
        AssertValidToken(symbolToAmount.Symbol, symbolToAmount.BasicFee); 
     }
     RequiredMethodFeeControllerSet();
     Assert(Context.Sender ==             State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
       State.TransactionFees[input.MethodName] = input;
       return new Empty();
   }
```
