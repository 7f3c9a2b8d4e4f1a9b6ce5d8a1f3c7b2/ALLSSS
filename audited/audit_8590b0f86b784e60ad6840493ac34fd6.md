### Title
Mining Order Manipulation via Unvalidated TuneOrderInformation in UpdateValue

### Summary
A malicious miner can manipulate the mining order for the next consensus round by providing arbitrary `FinalOrderOfNextRound` values through the `TuneOrderInformation` field in `UpdateValueInput`. These values are applied to state without validation, allowing the attacker to control their mining position, skip legitimate miners, or disrupt the consensus schedule.

### Finding Description

**Root Cause:**
The `ProcessUpdateValue` method applies `TuneOrderInformation` from miner input directly to state without validating that the order values are legitimate: [1](#0-0) 

The intended behavior is that `TuneOrderInformation` should only contain miners whose `FinalOrderOfNextRound` differs from `SupposedOrderOfNextRound` due to conflict resolution: [2](#0-1) 

However, no validation enforces this constraint.

**Why Validation Fails:**

1. `MiningPermissionValidationProvider` only checks if the sender is a valid miner, not order values: [3](#0-2) 

2. `UpdateValueValidationProvider` only validates cryptographic fields (OutValue, Signature, PreviousInValue), NOT `TuneOrderInformation`: [4](#0-3) 

3. `NextRoundMiningOrderValidationProvider` validates `FinalOrderOfNextRound`, but is ONLY added for NextRound behavior, not UpdateValue: [5](#0-4) 

4. `RecoverFromUpdateValue` blindly copies `FinalOrderOfNextRound` values without validation: [6](#0-5) 

**Execution Path:**
When the next round is generated, `GenerateNextRoundInformation` uses the manipulated `FinalOrderOfNextRound` values from state to determine mining order: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Breach:**
- Attacker can set their own `FinalOrderOfNextRound` to 1 to mine first in the next round, gaining priority access to transactions and any extra block producer benefits
- Attacker can manipulate other miners' orders to disadvantage competitors or push specific miners to unfavorable time slots
- Attacker can create duplicate order values (e.g., multiple miners with order 1), causing the next round generation to produce invalid or unpredictable mining schedules
- Attacker can set invalid orders (e.g., all orders set to 99 when only 5 miners exist), breaking the round generation logic

**Miner Schedule Integrity:**
The protocol's fairness guarantee—that mining order is determined by cryptographic randomness (signature-based calculation)—is completely bypassed. Miners who should mine first based on proper calculations can be arbitrarily pushed to later positions.

**Affected Parties:**
- All miners in the network suffer from unfair schedule manipulation
- The network loses consensus fairness and predictability
- Transaction ordering can be manipulated if the attacker consistently mines first

**Severity Justification: HIGH**
This breaks a critical consensus invariant (miner schedule integrity) and allows direct manipulation of the core consensus mechanism without requiring any sophisticated attack or additional privileges beyond being a legitimate miner.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a legitimate miner (has mining permissions and can produce blocks)
- This is a realistic precondition in a DPoS system where miners may have economic incentives to game the system

**Attack Complexity: LOW**
The attack is straightforward:
1. When producing a block with UpdateValue behavior, simply modify the `TuneOrderInformation` map in `UpdateValueInput`
2. Set arbitrary `FinalOrderOfNextRound` values for self and/or other miners
3. No cryptographic challenges or complex state manipulation required

**Execution Practicality:**
The `UpdateValueInput` structure accepts the `tune_order_information` field as defined in the protobuf: [8](#0-7) 

Any miner can populate this field with arbitrary values when calling `UpdateValue`.

**Economic Rationality:**
- No additional cost beyond normal mining operations
- Potential benefits include mining first (capturing MEV, extra rewards) or disadvantaging competitors
- High probability that a malicious miner would attempt this if detected

**Detection Difficulty:**
The manipulation occurs within normal UpdateValue transactions and leaves no obvious traces distinguishable from legitimate conflict resolution adjustments.

### Recommendation

**Code-Level Mitigation:**

1. Add validation in `UpdateValueValidationProvider` or create a new validation provider for UpdateValue that validates `TuneOrderInformation`:
   - Verify that keys in `TuneOrderInformation` correspond only to miners who have legitimate conflicts (where calculated `SupposedOrderOfNextRound` conflicts with existing `FinalOrderOfNextRound`)
   - Verify that tuned order values are within valid range [1, minersCount]
   - Verify that tuned orders follow the intended conflict resolution logic from `ApplyNormalConsensusData`
   - Verify no duplicate final orders exist after applying tuning

2. Apply validation before line 260 in `ProcessUpdateValue`:
```
// Validate TuneOrderInformation before applying
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key), 
           "Invalid miner key in TuneOrderInformation");
    Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount, 
           "Order value out of valid range");
    // Additional checks for conflict resolution legitimacy
}
```

3. Consider making `TuneOrderInformation` computed server-side rather than client-provided to eliminate the attack surface entirely.

**Invariant Checks:**
- `FinalOrderOfNextRound` values for all miners must be in range [1, minersCount]
- No duplicate `FinalOrderOfNextRound` values among miners who mined
- Only miners with legitimate order conflicts (detected via signature collision) should have `FinalOrderOfNextRound` != `SupposedOrderOfNextRound`

**Test Cases:**
1. Test that UpdateValue with invalid `TuneOrderInformation` keys is rejected
2. Test that UpdateValue with out-of-range order values is rejected
3. Test that UpdateValue with duplicate final orders is rejected
4. Test that UpdateValue with arbitrary tuning (no conflicts) is rejected
5. Test that legitimate conflict resolution still works after validation is added

### Proof of Concept

**Initial State:**
- 5 miners: A (attacker), B, C, D, E
- Current round N with all miners having mined
- Natural order calculation for next round based on signatures: A=3, B=1, C=2, D=4, E=5

**Attack Steps:**

1. Attacker (Miner A) produces their UpdateValue block with malicious `TuneOrderInformation`:
```
UpdateValueInput {
  OutValue: <valid_hash>,
  Signature: <valid_signature>,
  SupposedOrderOfNextRound: 3,  // Correct calculated value
  TuneOrderInformation: {
    "A": 1,  // Manipulate to mine first
    "B": 5,  // Push B to last
    "C": 2,
    "D": 3,
    "E": 4
  },
  // ... other fields
}
```

2. `ValidateBeforeExecution` is called:
   - `MiningPermissionValidationProvider`: ✓ Passes (A is a valid miner)
   - `TimeSlotValidationProvider`: ✓ Passes (correct time slot)
   - `UpdateValueValidationProvider`: ✓ Passes (only checks OutValue/Signature/PreviousInValue)
   - No validator checks `TuneOrderInformation`

3. `ProcessUpdateValue` executes:
   - Line 247: Sets `minerInRound["A"].FinalOrderOfNextRound = 3` (from SupposedOrderOfNextRound)
   - Line 260: Applies `TuneOrderInformation`, overwriting to:
     * A.FinalOrderOfNextRound = 1
     * B.FinalOrderOfNextRound = 5
     * C.FinalOrderOfNextRound = 2
     * D.FinalOrderOfNextRound = 3
     * E.FinalOrderOfNextRound = 4
   - Line 284: State is updated with manipulated values

4. When next miner triggers NextRound:
   - `GenerateNextRoundInformation` is called
   - Line 26 orders miners by `FinalOrderOfNextRound`
   - Line 28-32: Next round assigns Order = FinalOrderOfNextRound for each miner
   
**Expected Result:**
Mining order in next round should be: B(1), C(2), A(3), D(4), E(5) based on signatures

**Actual Result:**
Mining order in next round is: A(1), C(2), D(3), E(4), B(5) based on attacker's manipulation

**Success Condition:**
Attacker successfully mines first in the next round instead of third, breaking the consensus fairness guarantee.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-20)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-88)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L25-36)
```csharp
        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```
