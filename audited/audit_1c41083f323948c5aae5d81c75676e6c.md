### Title
Governance Bypass via Unvalidated ContractAddress in ChangeMethodFeeController

### Summary
The `ChangeMethodFeeController` method fails to validate that the `AuthorityInfo.ContractAddress` is a legitimate governance contract (Parliament, Association, or Referendum), allowing an attacker to specify a malicious contract that bypasses organization existence checks. This enables permanent governance bypass by setting an arbitrary address as the method fee controller without proper authorization controls.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController` method and the `CheckOrganizationExist` helper function across all ACS1-compliant contracts, including TokenConverter. [1](#0-0) 

The method performs two validation steps:
1. **Line 25**: `AssertSenderAddressWith` verifies the sender is the current controller's OwnerAddress (direct equality check)
2. **Line 26**: `CheckOrganizationExist` validates the new organization exists by calling the provided ContractAddress [2](#0-1) 

The root cause is that `CheckOrganizationExist` makes a cross-contract call to `authorityInfo.ContractAddress` without validating this address is one of the three legitimate governance contracts (Parliament, Association, or Referendum). The ContractAddress is fully controlled by the caller and can point to any deployed contract.

**Why existing protections fail:**
- The `AssertSenderAddressWith` check only validates the current sender authorization, not the validity of the new controller being set
- No validation exists to ensure `ContractAddress` points to a system governance contract
- The `Context.Call` will successfully execute against any contract that has a `ValidateOrganizationExist` method returning `BoolValue`

**Exploitation path:**
1. Attacker deploys a malicious contract with: `public BoolValue ValidateOrganizationExist(Address input) { return new BoolValue { Value = true }; }`
2. Current controller (e.g., Parliament) creates/approves a proposal to change the method fee controller
3. Proposal specifies: `ContractAddress = malicious_contract`, `OwnerAddress = attacker_address`
4. `CheckOrganizationExist` calls the malicious contract, which returns true
5. Validation passes, controller is changed to attacker's address with fake governance
6. Attacker can now call `SetMethodFee` directly without any governance approval [3](#0-2) 

This pattern is systemic across all contracts implementing ACS1: [4](#0-3) [5](#0-4) 

### Impact Explanation

**Governance Impact - HIGH:**
- **Permanent governance bypass**: Once the malicious controller is set, the attacker controls method fees indefinitely without requiring ongoing governance approval
- **Fee manipulation**: Attacker can arbitrarily set transaction fees for critical methods (Buy, Sell, SetConnector in TokenConverter), potentially:
  - Setting fees to zero to drain fee revenue
  - Setting exorbitant fees to DoS the contract
  - Creating economic exploits through fee manipulation
- **Affects all ACS1 contracts**: This vulnerability exists in 13+ system contracts including MultiToken, Parliament, Treasury, Profit, CrossChain, Economic, Election, Vote, Configuration, and TokenConverter

**Who is affected:**
- Protocol treasury (loss of fee revenue)
- Users (potential DoS through high fees or economic exploits)
- Governance legitimacy (undermines entire authorization model)

**Severity justification:**
- Breaks the critical governance invariant that controllers must be legitimate organizations
- Enables privilege escalation from governed control to arbitrary control
- Permanent damage - once exploited, attacker maintains control until governance can regain access (which requires the attacker to approve changing back)

### Likelihood Explanation

**Attacker capabilities required:**
- Ability to deploy a contract (standard AElf capability)
- Social engineering or partial compromise of current governance to approve one malicious proposal

**Attack complexity - MEDIUM:**
- Technical execution is straightforward (deploy simple contract, create proposal)
- Requires governance approval, BUT this is realistic through:
  - **Social engineering**: ContractAddress appears as a valid address hash, difficult to distinguish from legitimate governance contracts without careful verification
  - **Proposal obfuscation**: Proposal reviewers may focus on OwnerAddress validity rather than ContractAddress authenticity
  - **Insider threat**: Single malicious proposer or reviewer in governance
  - **Oversight**: In high-volume governance operations, thorough validation of every parameter may be missed

**Feasibility conditions:**
- No special permissions required beyond normal contract deployment
- Attack works on both mainnet and sidechains
- One successful malicious proposal achieves permanent compromise

**Detection constraints:**
- Pre-execution: Difficult to detect without manual verification of ContractAddress against known system contracts
- Post-execution: Controller change is visible on-chain but damage is already done
- No automatic validation prevents this attack

**Probability reasoning:**
While requiring governance approval adds friction, the combination of low technical barriers, realistic social engineering vectors, and catastrophic permanent impact makes this a HIGH likelihood vulnerability that violates defense-in-depth principles. The contract MUST validate critical security parameters rather than relying solely on governance vigilance.

### Recommendation

**Immediate fix - Add ContractAddress validation:**

In `CheckOrganizationExist` (and all similar methods across ACS1 contracts), validate that the ContractAddress is a legitimate governance contract:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate ContractAddress is a legitimate governance contract
    var parliamentAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    var associationAddress = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    var referendumAddress = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress || 
        authorityInfo.ContractAddress == associationAddress || 
        authorityInfo.ContractAddress == referendumAddress,
        "Invalid contract address - must be a system governance contract.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Invariant to enforce:**
- `AuthorityInfo.ContractAddress` in controller changes MUST be one of the three system governance contracts (Parliament, Association, or Referendum)

**Required test cases:**
1. Test `ChangeMethodFeeController` with non-governance ContractAddress (e.g., TokenContract) - should fail
2. Test with arbitrary/user-deployed ContractAddress - should fail  
3. Test with valid governance contracts but invalid organization - should fail (existing test)
4. Test with valid governance contract and valid organization - should succeed (existing test)

**Apply fix to all affected contracts:**
TokenConverter, MultiToken, Parliament, Association, Referendum, Treasury, Profit, TokenHolder, Vote, Configuration, Economic, CrossChain, Election, Consensus, Genesis (13+ contracts total)

### Proof of Concept

**Initial state:**
- TokenConverter contract deployed with default Parliament controller
- Parliament default organization is the current MethodFeeController.OwnerAddress

**Attack steps:**

1. **Attacker deploys malicious contract:**
```csharp
public class MaliciousAuthContract : AElf.Sdk.CSharp.CSharpSmartContract<State>
{
    public BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = true }; // Always returns true
    }
}
```

2. **Create malicious proposal:**
```csharp
var maliciousProposal = await ParliamentContractStub.CreateProposal.SendAsync(new CreateProposalInput
{
    OrganizationAddress = parliamentDefaultOrg,
    ContractMethodName = "ChangeMethodFeeController",
    ToAddress = TokenConverterContractAddress,
    Params = new AuthorityInfo
    {
        ContractAddress = maliciousContractAddress, // Deployed malicious contract
        OwnerAddress = attackerAddress // Attacker's personal address
    }.ToByteString(),
    ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
});
```

3. **Social engineer governance approval:** Proposal appears legitimate, reviewers don't carefully verify ContractAddress

4. **Release and execute proposal:**
```csharp
await ParliamentContractStub.Release.SendAsync(proposalId);
```

5. **Verify exploitation:**
```csharp
var newController = await TokenConverterStub.GetMethodFeeController.CallAsync(new Empty());
// newController.OwnerAddress == attackerAddress
// newController.ContractAddress == maliciousContractAddress
```

6. **Attacker directly controls fees:**
```csharp
// Attacker can now call SetMethodFee directly without governance
var result = await AttackerStub.SetMethodFee.SendAsync(new MethodFees { ... });
// result.Status == TransactionResultStatus.Mined (succeeds)
```

**Expected behavior:** ChangeMethodFeeController should reject any ContractAddress that is not Parliament, Association, or Referendum

**Actual behavior:** ChangeMethodFeeController accepts malicious ContractAddress, enabling permanent governance bypass

**Success condition:** After step 5, `attackerAddress` can call `SetMethodFee` directly without requiring any governance proposal/approval, demonstrating complete bypass of authorization controls.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```
