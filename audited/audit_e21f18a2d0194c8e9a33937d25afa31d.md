### Title
Consensus DoS via Multiple Extra Block Producers in Round Data

### Summary
The `ArrangeAbnormalMiningTime` function and round generation logic lack validation to ensure only one miner has `IsExtraBlockProducer` set to true. A malicious extra block producer can inject corrupted round data with multiple miners marked as extra block producers, which passes all validation checks but causes a fatal exception in the next round, halting the entire blockchain.

### Finding Description

**Root Cause:**

The consensus system fails to validate the uniqueness of the `IsExtraBlockProducer` flag when processing NextRound transitions. While round generation code properly sets exactly one miner as extra block producer [1](#0-0) , there is no validation that enforces this invariant when a miner submits round data.

**Execution Path:**

1. The malicious extra block producer calls `GetConsensusBlockExtraData` for NextRound behavior [2](#0-1) 

2. They modify the returned round information to set multiple miners' `IsExtraBlockProducer = true` before submitting the block

3. The block goes through `ValidateBeforeExecution` which applies multiple validation providers [3](#0-2) 

4. None of the validation providers check `IsExtraBlockProducer` uniqueness:
   - `MiningPermissionValidationProvider` only checks miner list membership [4](#0-3) 
   - `TimeSlotValidationProvider` only validates time slots [5](#0-4) 
   - `RoundTerminateValidationProvider` only checks round number increment [6](#0-5) 

5. The corrupted round is stored without additional validation [7](#0-6) 

6. In the next round, when any miner attempts block production, `IsCurrentMiner` is called which uses `.Single()` to retrieve the extra block producer [8](#0-7) 

7. The `.Single()` call throws `InvalidOperationException` because multiple miners have `IsExtraBlockProducer = true`

8. All miners fail to produce blocks, halting the chain

**Why Existing Protections Fail:**

While `GetExtraBlockProducerInformation` uses `.First()` [9](#0-8)  which would not throw on multiple matches, `IsCurrentMiner` uses `.Single()` which enforces uniqueness at runtime but too late to prevent the attack. The validation pipeline lacks a proactive check before round data is persisted.

### Impact Explanation

**Harm:** Complete blockchain halt requiring manual intervention or hard fork to recover.

**Affected Parties:** 
- All network participants lose ability to transact
- Validators cannot produce blocks
- Applications dependent on the chain become unavailable
- Smart contract operations cease

**Severity Justification:** CRITICAL - This is a consensus-level DoS vulnerability that:
- Stops all block production permanently
- Requires no special economic resources beyond being a miner
- Cannot self-recover through normal consensus mechanisms
- Affects the entire network simultaneously
- Leaves no path for honest miners to continue

### Likelihood Explanation

**Attacker Capabilities:** Must be a miner designated as extra block producer for the current round.

**Attack Complexity:** LOW - The attacker simply needs to:
1. Wait until they are the extra block producer
2. Modify the round data structure before block submission
3. Set multiple miners' `IsExtraBlockProducer` flags to true

**Feasibility:** HIGH - The attack requires:
- Being a miner (achievable through normal election/staking)
- Waiting for extra block producer designation (rotates deterministically)
- Modifying consensus extra data (no cryptographic binding prevents this)

**Detection:** The attack is only detected when it's too late - during the next round's block production when `.Single()` throws. No monitoring can prevent it proactively.

**Probability:** MEDIUM-HIGH - While requiring miner status, the attack is trivial to execute and guarantees success. A malicious or compromised miner could execute this at will during their extra block slot.

### Recommendation

**Primary Fix:** Add validation in `ValidateBeforeExecution` to enforce extra block producer uniqueness:

```csharp
// In AEDPoSContract_Validation.cs, add a new validation provider for NextRound/NextTerm behaviors
public class ExtraBlockProducerValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var round = validationContext.ExtraData.Round;
        var extraBlockProducers = round.RealTimeMinersInformation.Values
            .Count(m => m.IsExtraBlockProducer);
        
        if (extraBlockProducers != 1)
        {
            return new ValidationResult 
            { 
                Message = $"Invalid extra block producer count: {extraBlockProducers}. Must be exactly 1." 
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

**Additional Protections:**
1. Add assertion in `AddRoundInformation` [7](#0-6)  to verify invariant before persisting
2. Replace `.Single()` with `.FirstOrDefault()` in `IsCurrentMiner` [8](#0-7)  and handle invalid state gracefully
3. Add unit tests verifying rejection of round data with zero or multiple extra block producers

### Proof of Concept

**Initial State:**
- Chain is running normally with N miners
- Attacker is miner M, currently designated as extra block producer for round R

**Attack Steps:**

1. Attacker M reaches their extra block production time slot
2. M calls local `GetConsensusBlockExtraData` which generates next round information with M' as the designated extra block producer
3. M modifies the returned `AElfConsensusHeaderInformation` to set both M' and M'' with `IsExtraBlockProducer = true`
4. M produces block B with the corrupted consensus extra data
5. Block B undergoes validation via `ValidateBeforeExecution`:
   - MiningPermissionValidationProvider: PASS (M is in miner list)
   - TimeSlotValidationProvider: PASS (time slots are valid)
   - RoundTerminateValidationProvider: PASS (round number is R+1)
   - NextRoundMiningOrderValidationProvider: PASS (mining orders are consistent)
6. Block B is accepted and `ProcessNextRound` stores the corrupted round R+1
7. Round R+1 begins, miner attempts to produce next block
8. Block production calls `IsCurrentMiner` which executes line 170
9. `InvalidOperationException` thrown: "Sequence contains more than one matching element"
10. All subsequent block production attempts fail with same exception

**Expected vs Actual:**
- Expected: Validation rejects block B with multiple extra block producers
- Actual: Block B is accepted, causing permanent chain halt in round R+1

**Success Condition:** Chain stops producing blocks after round R+1 begins, with all miners encountering exceptions during `IsCurrentMiner` validation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-65)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-176)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-57)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-30)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-170)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```
