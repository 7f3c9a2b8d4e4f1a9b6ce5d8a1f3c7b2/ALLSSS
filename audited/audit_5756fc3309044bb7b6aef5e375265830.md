### Title
Immutable Random Number Provider Reference Creates Operational Lock-in Risk

### Summary
The NFT contract caches the consensus contract address on first use in `State.RandomNumberProviderContract.Value` with no mechanism to update it. While normal in-place contract upgrades work automatically, this creates operational lock-in if the consensus contract address ever needs to change, permanently blocking new NFT protocol creation.

### Finding Description

The `MakeSureRandomNumberProviderContractAddressSet()` function implements lazy initialization that only sets the random number provider address once: [1](#0-0) 

Once `State.RandomNumberProviderContract.Value` is set, it is never updated again. The NFT contract interface provides no administrative function to update this reference: [2](#0-1) 

The cached address is used during NFT protocol creation to generate random symbol numbers: [3](#0-2) [4](#0-3) 

**Root Cause**: The contract caches the consensus contract address rather than resolving it dynamically on each use. While AElf system contracts are typically upgraded in-place (same address, new code), this caching creates a permanent dependency: [5](#0-4) 

The upgrade mechanism preserves the contract address but updates the code. However, if the Genesis contract's `NameAddressMapping` is ever updated to point the consensus contract name to a different address (emergency replacement scenario), the NFT contract would remain locked to the old cached address.

### Impact Explanation

**Operational DoS of NFT Creation**: If the cached consensus contract address becomes non-functional or deprecated, all NFT protocol creation attempts will fail when `GenerateSymbolNumber()` calls `GetRandomBytes()` on the broken address. This permanently disables the `Create()` and indirectly affects operations dependent on new NFT protocols.

**Affected Parties**: NFT protocol creators and the broader NFT ecosystem on the chain.

**Severity Justification**: MEDIUM - This creates operational DoS of an important protocol function (NFT creation) with no recovery path, but does not directly impact existing NFTs, funds, or core consensus/governance functions.

### Likelihood Explanation

**Normal Upgrade Scenario (High Probability)**: When the consensus contract is upgraded in-place at the same address (standard AElf practice), the NFT contract automatically uses the upgraded version. **No issue in this case.**

**Address Change Scenario (Low Probability)**: If the consensus contract requires emergency replacement at a different address, or governance decides to switch to a different randomness source, the NFT contract cannot be updated. This scenario is unlikely given AElf's architecture but possible in extreme circumstances (critical bug, architecture migration, VRF oracle adoption).

**Feasibility**: The condition requires unusual circumstances (consensus contract needing complete replacement rather than in-place upgrade), making this a LOW likelihood scenario under normal operations.

**Detection**: The issue manifests immediately when attempting to create new NFT protocols after the consensus contract becomes unavailable.

### Recommendation

Add a governance-controlled function to update the random number provider contract reference:

```csharp
public override Empty SetRandomNumberProviderContract(Address input)
{
    AssertSenderIsParliamentDefaultAddress();
    Assert(input != null, "Invalid address.");
    State.RandomNumberProviderContract.Value = input;
    
    Context.Fire(new RandomNumberProviderContractUpdated
    {
        NewAddress = input
    });
    
    return new Empty();
}
```

Add corresponding protobuf definition:
```protobuf
rpc SetRandomNumberProviderContract (aelf.Address) returns (google.protobuf.Empty) {}
```

This allows governance to update the reference if the consensus contract needs replacement, while maintaining the lazy initialization pattern for normal operation.

**Test Cases**: 
1. Verify only Parliament default address can call the setter
2. Test NFT creation works after updating to a new random number provider
3. Ensure existing NFT operations are unaffected by the update

### Proof of Concept

**Initial State**: NFT contract deployed with `State.RandomNumberProviderContract.Value` = null

**Step 1**: User calls `Create()` for first NFT protocol
- `MakeSureRandomNumberProviderContractAddressSet()` caches consensus contract address
- NFT protocol created successfully

**Step 2**: Consensus contract at cached address becomes deprecated/non-functional
- Scenario A: Emergency requires replacing consensus contract at different address
- Scenario B: Genesis contract updates `NameAddressMapping` to point to new consensus address

**Step 3**: User attempts `Create()` for new NFT protocol
- **Expected**: Should use current/updated consensus contract address
- **Actual**: Still calls old cached address, `GetRandomBytes()` fails
- **Result**: Permanent DoS of NFT creation, no recovery mechanism available

**Success Condition**: NFT contract cannot create new protocols until manually updated (impossible without the recommended admin function).

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L17-22)
```csharp
    private void MakeSureRandomNumberProviderContractAddressSet()
    {
        if (State.RandomNumberProviderContract.Value == null)
            State.RandomNumberProviderContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** protobuf/nft_contract.proto (L18-101)
```text
service NFTContract {
    option (aelf.csharp_state) = "AElf.Contracts.NFT.NFTContractState";
    option (aelf.base) = "acs1.proto";

    // Create a new nft protocol.
    rpc Create (CreateInput) returns (google.protobuf.StringValue) {
    }
    rpc CrossChainCreate (CrossChainCreateInput) returns (google.protobuf.Empty) {
    }
    // Mint (Issue) an amount of nft.
    rpc Mint (MintInput) returns (aelf.Hash) {
    }
    // Transfer nft to another address.
    rpc Transfer (TransferInput) returns (google.protobuf.Empty) {
    }
    // Transfer nft from one address to another.
    rpc TransferFrom (TransferFromInput) returns (google.protobuf.Empty) {
    }
    // Approve another address to transfer nft from own account.
    rpc Approve (ApproveInput) returns (google.protobuf.Empty) {
    }
    // De-approve.
    rpc UnApprove (UnApproveInput) returns (google.protobuf.Empty) {
    }
    // Approve or de-approve another address as the operator of all NFTs of a certain protocol.
    rpc ApproveProtocol (ApproveProtocolInput) returns (google.protobuf.Empty) {
    }
    // Destroy nfts.
    rpc Burn (BurnInput) returns (google.protobuf.Empty) {
    }
    // Lock several nfts and fts to mint one nft.
    rpc Assemble (AssembleInput) returns (aelf.Hash) {
    }
    // Disassemble one assembled nft to get locked nfts and fts back.
    rpc Disassemble (DisassembleInput) returns (google.protobuf.Empty) {
    }
    // Modify metadata of one nft.
    rpc Recast (RecastInput) returns (google.protobuf.Empty) {
    }

    rpc AddMinters (AddMintersInput) returns (google.protobuf.Empty) {
    }
    rpc RemoveMinters (RemoveMintersInput) returns (google.protobuf.Empty) {
    }
    
    rpc AddNFTType (AddNFTTypeInput) returns (google.protobuf.Empty) {
    }
    rpc RemoveNFTType (google.protobuf.StringValue) returns (google.protobuf.Empty) {
    }

    rpc GetNFTProtocolInfo (google.protobuf.StringValue) returns (NFTProtocolInfo) {
        option (aelf.is_view) = true;
    }
    rpc GetNFTInfo (GetNFTInfoInput) returns (NFTInfo) {
        option (aelf.is_view) = true;
    }
    rpc GetNFTInfoByTokenHash (aelf.Hash) returns (NFTInfo) {
        option (aelf.is_view) = true;
    }
    rpc GetBalance (GetBalanceInput) returns (GetBalanceOutput) {
        option (aelf.is_view) = true;
    }
    rpc GetBalanceByTokenHash (GetBalanceByTokenHashInput) returns (GetBalanceOutput) {
        option (aelf.is_view) = true;
    }
    rpc GetAllowance (GetAllowanceInput) returns (GetAllowanceOutput) {
        option (aelf.is_view) = true;
    }
    rpc GetAllowanceByTokenHash (GetAllowanceByTokenHashInput) returns (GetAllowanceOutput) {
        option (aelf.is_view) = true;
    }
    rpc GetMinterList (google.protobuf.StringValue) returns (MinterList) {
        option (aelf.is_view) = true;
    }
    rpc CalculateTokenHash (CalculateTokenHashInput) returns (aelf.Hash) {
        option (aelf.is_view) = true;
    }
    rpc GetNFTTypes (google.protobuf.Empty) returns (NFTTypes) {
        option (aelf.is_view) = true;
    }
    rpc GetOperatorList (GetOperatorListInput) returns (AddressList) {
        option (aelf.is_view) = true;
    }
}
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-22)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L98-144)
```csharp
    private void UpdateSmartContract(Address contractAddress, byte[] code, Address author, bool isUserContract)
    {
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        Assert(author == info.Author, "No permission.");

        var oldCodeHash = info.CodeHash;
        var newCodeHash = HashHelper.ComputeFrom(code);
        Assert(oldCodeHash != newCodeHash, "Code is not changed.");
        AssertContractNotExists(newCodeHash);

        info.CodeHash = newCodeHash;
        info.IsUserContract = isUserContract;
        info.Version++;

        var reg = new SmartContractRegistration
        {
            Category = info.Category,
            Code = ByteString.CopyFrom(code),
            CodeHash = newCodeHash,
            IsSystemContract = info.IsSystemContract,
            Version = info.Version,
            ContractAddress = contractAddress,
            IsUserContract = isUserContract
        };

        var contractInfo = Context.UpdateSmartContract(contractAddress, reg, null, info.ContractVersion);
        Assert(contractInfo.IsSubsequentVersion,
            $"The version to be deployed is lower than the effective version({info.ContractVersion}), please correct the version number.");

        info.ContractVersion = contractInfo.ContractVersion;
        reg.ContractVersion = info.ContractVersion;

        State.ContractInfos[contractAddress] = info;
        State.SmartContractRegistrations[reg.CodeHash] = reg;

        Context.Fire(new CodeUpdated
        {
            Address = contractAddress,
            OldCodeHash = oldCodeHash,
            NewCodeHash = newCodeHash,
            Version = info.Version,
            ContractVersion = info.ContractVersion
        });

        Context.LogDebug(() => "BasicContractZero - update success: " + contractAddress.ToBase58());
    }
```
