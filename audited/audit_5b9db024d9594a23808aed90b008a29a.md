### Title
Fee Tokens Permanently Locked in TokenConverter When Base Token Not Available for Method Fees

### Summary
The `HandleFee()` function transfers half the fee (donateFee) to the TokenConverter contract before calling `DividendPoolContract.Donate()`. However, Treasury's `Donate()` implementation has an early return path when the token is not available for method fees, returning `Empty` successfully without transferring the tokens. This causes donateFee to become permanently locked in the TokenConverter contract with no recovery mechanism.

### Finding Description

In `HandleFee()`, the function executes the following sequence: [1](#0-0) 

The donateFee is transferred from the user to the TokenConverter contract. Then the contract approves the Treasury: [2](#0-1) 

And calls Donate: [3](#0-2) 

The critical issue is in the Treasury's `Donate()` implementation, which has an early return: [4](#0-3) 

When `IsTokenAvailableForMethodFee` returns false (token is not burnable), the function returns `Empty` successfully. This means the inline transaction succeeds, but the subsequent `TransferFrom` never executes: [5](#0-4) 

The token availability check verifies if the token is burnable: [6](#0-5) 

The TokenConverter's `Initialize()` function sets the base token but performs no validation that the token is burnable: [7](#0-6) 

AElf's inline transaction mechanism only rolls back on exceptions. When `Donate()` returns `Empty` successfully, the transaction continues: [8](#0-7) 

### Impact Explanation

**Direct Fund Impact:**
- Every `Buy()` or `Sell()` transaction calculates a fee, with half designated as donateFee
- When the base token is not burnable, donateFee accumulates in the TokenConverter contract permanently
- No withdrawal or recovery function exists in the TokenConverter contract to reclaim these tokens
- Users lose half their fee payment (the donation portion) with no benefit to the protocol
- The locked funds accumulate indefinitely with each swap transaction

**Affected Parties:**
- All users performing token swaps through the TokenConverter contract
- Protocol treasury loses intended donations
- TokenConverter contract becomes a permanent token sink

**Severity Justification:**
High severity due to permanent, unrecoverable fund loss that occurs on every fee-bearing transaction when the base token is misconfigured.

### Likelihood Explanation

**Preconditions:**
- TokenConverter must be initialized with a base token that has `IsBurnable = false`
- This can occur if the initialization uses a non-standard token instead of the native token

**Feasibility:**
- The native token (ELF) is designed with `IsBurnable = true` by default
- Standard deployments use the native token as the base token
- However, no validation exists in `Initialize()` to enforce this requirement
- Token's `IsBurnable` property cannot be changed after token creation, making misconfiguration permanent

**Attack Complexity:**
- Not an attack per se, but an operational risk
- Occurs automatically on every Buy/Sell transaction if misconfigured
- No special privileges or external coordination required
- Once misconfigured during deployment, affects all subsequent operations

**Probability Assessment:**
Low-Medium likelihood. While standard deployments are safe, the lack of validation creates risk during:
- Custom deployments on side chains
- Testing/staging environments that become production
- Contract upgrades or migrations with modified parameters

### Recommendation

**Immediate Fix:**
Add validation in the `Initialize()` function to ensure the base token is burnable:

```csharp
public override Empty Initialize(InitializeInput input)
{
    Assert(IsValidBaseSymbol(input.BaseTokenSymbol), $"Base token symbol is invalid. {input.BaseTokenSymbol}");
    Assert(State.TokenContract.Value == null, "Already initialized.");
    State.TokenContract.Value =
        Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
    
    var baseSymbol = !string.IsNullOrEmpty(input.BaseTokenSymbol)
        ? input.BaseTokenSymbol
        : Context.Variables.NativeSymbol;
    
    // ADD THIS VALIDATION
    var isAvailable = State.TokenContract.IsTokenAvailableForMethodFee.Call(
        new StringValue { Value = baseSymbol }).Value;
    Assert(isAvailable, $"Base token {baseSymbol} must be burnable and available for method fees.");
    
    State.BaseTokenSymbol.Value = baseSymbol;
    // ... rest of initialization
}
```

**Additional Safeguards:**
1. Add a recovery function controlled by governance to withdraw stuck tokens
2. Implement a pre-check in `HandleFee()` before transferring donateFee
3. Add monitoring to detect accumulating balances in the TokenConverter contract

**Test Cases:**
1. Test initialization with non-burnable token (should fail)
2. Test HandleFee with token that becomes unavailable for method fees
3. Test recovery mechanism for stuck tokens
4. Verify correct operation with burnable base token

### Proof of Concept

**Initial State:**
1. Deploy TokenConverter contract
2. Initialize with `BaseTokenSymbol` set to a non-burnable token (e.g., a custom token with `IsBurnable = false`)
3. User has sufficient balance and approvals

**Exploitation Steps:**
1. User calls `Buy()` or `Sell()` with an amount that generates a fee
2. `HandleFee()` is invoked with calculated fee
3. donateFee portion transferred from user to TokenConverter (succeeds)
4. TokenConverter approves Treasury (succeeds)
5. `Treasury.Donate()` called, returns Empty without transfer (succeeds)
6. burnFee portion transferred and burned (succeeds)
7. Transaction completes successfully

**Expected Result:**
- donateFee should be transferred to Treasury and contributed to profit scheme

**Actual Result:**
- donateFee remains in TokenConverter contract
- TokenConverter balance increases by donateFee amount
- No Treasury contribution occurs
- User's tokens are locked with no recovery path

**Success Condition:**
Query TokenConverter balance after multiple Buy/Sell transactions shows accumulating donateFee amounts with no corresponding Treasury donations, confirming permanent fund lock.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L33-35)
```csharp
        State.BaseTokenSymbol.Value = !string.IsNullOrEmpty(input.BaseTokenSymbol)
            ? input.BaseTokenSymbol
            : Context.Variables.NativeSymbol;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L220-227)
```csharp
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = donateFee
            });
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L231-236)
```csharp
        State.TokenContract.Approve.Send(new ApproveInput
        {
            Symbol = State.BaseTokenSymbol.Value,
            Spender = State.DividendPoolContract.Value,
            Amount = donateFee
        });
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L237-241)
```csharp
        State.DividendPoolContract.Donate.Send(new DonateInput
        {
            Symbol = State.BaseTokenSymbol.Value,
            Amount = donateFee
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L181-182)
```csharp
        if (!State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = input.Symbol }).Value)
            return new Empty();
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L194-202)
```csharp
        if (Context.Sender != Context.Self)
            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = Context.Self,
                Symbol = input.Symbol,
                Amount = input.Amount,
                Memo = "Donate to treasury."
            });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L252-257)
```csharp
    private bool IsTokenAvailableForMethodFee(string symbol)
    {
        var tokenInfo = GetTokenInfo(symbol);
        if (tokenInfo == null) throw new AssertionException("Token is not found.");
        return tokenInfo.IsBurnable;
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L241-243)
```csharp
            if (!inlineTrace.IsSuccessful())
                // Already failed, no need to execute remaining inline transactions
                break;
```
