### Title
Period Desynchronization Causes RegisterForProfits DoS and Auto-Distribution Failure

### Summary
The TokenHolder contract maintains a cached period value that can become desynchronized from the Profit contract's CurrentPeriod when distributions are initiated externally. This desynchronization causes RegisterForProfits transactions to fail during auto-distribution attempts, preventing users from registering as beneficiaries and breaking the auto-distribution mechanism. While profits are not distributed twice or lost entirely, the operational impact is severe as users cannot participate in the profit scheme.

### Finding Description

The vulnerability stems from period synchronization issues between TokenHolder and Profit contracts: [1](#0-0) 

RegisterForProfits calls `GetValidScheme` without the `updateSchemePeriod` flag, which returns a cached scheme without synchronizing the period: [2](#0-1) 

When `updateSchemePeriod` is false and `scheme.SchemeId != null`, the function returns early without updating the period from the Profit contract.

During auto-distribution, RegisterForProfits reads the originScheme but uses the stale cached period: [3](#0-2) 

The cached `scheme.Period` at line 196 may not match the Profit contract's actual `CurrentPeriod`. When Profit.DistributeProfits is called with this stale period, it fails validation: [4](#0-3) 

**Root Cause**: The period can become desynchronized when:
1. The scheme manager (set during scheme creation) calls Profit.DistributeProfits directly: [5](#0-4) 
   
2. Or when other authorized contracts call Profit.DistributeProfits: [6](#0-5) 

3. The Profit contract increments CurrentPeriod, but TokenHolder's cached period is not updated: [7](#0-6) 

### Impact Explanation

**Operational Impact (DoS):**
- Users cannot call RegisterForProfits when period is desynchronized
- The entire transaction reverts, preventing users from:
  - Locking their tokens
  - Becoming beneficiaries  
  - Receiving their share of profits
- Auto-distribution feature fails completely

**Affected Parties:**
- All users attempting to register for profits when period is out of sync
- The profit distribution mechanism itself becomes unreliable

**Severity Justification:**
While profits are not distributed twice (period validation prevents this) or lost entirely (they remain in VirtualAddress and can be distributed later), the HIGH severity is warranted due to:
1. Complete DoS of critical user registration function
2. Breaking of the auto-distribution feature which is a core contract functionality
3. Requires manual intervention by scheme manager to restore synchronization
4. Affects all users attempting to participate in profit scheme during desynchronization period

### Likelihood Explanation

**Attacker Capabilities:** No malicious attacker required - this occurs through normal operations when:
- The scheme manager performs manual distribution via Profit contract
- Other system contracts (e.g., Treasury) call Profit.DistributeProfits for shared schemes

**Execution Practicality:** Highly practical and will occur naturally:
1. Scheme manager is a legitimate role set during scheme creation
2. Direct Profit.DistributeProfits calls are authorized and expected
3. No special privileges or complex setup required

**Feasibility Conditions:**
- Any profit scheme created through TokenHolder contract is vulnerable
- Occurs whenever distribution happens outside TokenHolder's control
- Probability increases with multiple distribution sources or active scheme management

**Detection:** The issue manifests immediately as failed RegisterForProfits transactions with period validation errors, making it easily detectable but also immediately impactful to users.

### Recommendation

**Fix 1: Always synchronize period in RegisterForProfits**

Modify RegisterForProfits to always update the cached period before auto-distribution:

```csharp
// In RegisterForProfits, change line 152:
var scheme = GetValidScheme(input.SchemeManager, true); // Add updateSchemePeriod = true
```

**Fix 2: Add period synchronization before auto-distribution check**

Before the auto-distribution logic, explicitly synchronize the period:

```csharp
// After line 177, before auto-distribute check:
UpdateTokenHolderProfitScheme(ref scheme, input.SchemeManager, true);
```

**Fix 3: Use originScheme.CurrentPeriod directly**

Since RegisterForProfits already queries the originScheme (line 181), use its CurrentPeriod instead of the cached value:

```csharp
// Replace line 196:
Period = originScheme.CurrentPeriod
```

**Invariant Check to Add:**
Validate period synchronization before calling DistributeProfits and log a warning if desynchronized.

**Test Cases:**
1. Create scheme, manager calls Profit.DistributeProfits directly, then user calls RegisterForProfits
2. Multiple RegisterForProfits calls with auto-distribution in sequence
3. External contract calls Profit.DistributeProfits, verify subsequent RegisterForProfits succeeds

### Proof of Concept

**Initial State:**
- TokenHolder scheme created with auto-distribute threshold
- Profit.CurrentPeriod = 1
- TokenHolder.scheme.Period = 1

**Exploitation Steps:**

1. **Scheme Manager distributes directly:**
   - Call `Profit.DistributeProfits(schemeId, period=1)`
   - Profit.CurrentPeriod increments to 2
   - TokenHolder.scheme.Period remains 1 (not updated)

2. **User contributes profits:**
   - Call `TokenHolder.ContributeProfits(tokens to VirtualAddress)`
   - Tokens successfully transferred to VirtualAddress

3. **User attempts to register:**
   - Call `TokenHolder.RegisterForProfits(amount, schemeManager)`
   - Function reads cached scheme.Period = 1
   - Balance check passes, triggers auto-distribution
   - Calls `Profit.DistributeProfits(schemeId, period=1)`
   - Profit validates: input.Period (1) â‰  CurrentPeriod (2)
   - **Assert fails: "Invalid period"**
   - **Entire transaction reverts**

**Expected Result:** User successfully registers and auto-distribution occurs

**Actual Result:** Transaction fails with period validation error, user cannot register, auto-distribution fails

**Success Condition:** RegisterForProfits transaction reverts due to period mismatch, demonstrating the DoS condition

### Notes

While the vulnerability doesn't cause profits to be "distributed twice" (prevented by period validation) or "lost entirely" (they remain in VirtualAddress), it does cause significant operational disruption. The auto-distribution feature fails and users are blocked from registering, which represents a HIGH severity DoS vulnerability affecting core contract functionality. The desynchronization occurs naturally through authorized operations, making it a realistic and recurring issue that requires immediate remediation.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-22)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-152)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L181-206)
```csharp
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-289)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
    }

    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L426-428)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L478-480)
```csharp
        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```
