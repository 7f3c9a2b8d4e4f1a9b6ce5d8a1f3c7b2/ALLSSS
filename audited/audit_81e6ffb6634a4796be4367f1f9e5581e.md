### Title
Missing Round Number Validation Allows Bypass of Continuous Block Production Limit

### Summary
The `UpdateValueValidationProvider` fails to validate that the `ProvidedRound.RoundNumber` matches the `BaseRound.RoundNumber` (current round). This allows malicious miners to provide consensus data with an arbitrary round number (e.g., round 1 or 2) even when the actual current round is much higher. By exploiting this, attackers can bypass the continuous blocks production limit enforced by `ContinuousBlocksValidationProvider`, enabling them to monopolize block production and undermine network decentralization.

### Finding Description

The vulnerability exists in the consensus header validation flow for UpdateValue behavior. The root cause is the absence of round number validation across all validation providers. [1](#0-0) 

The `UpdateValueValidationProvider.ValidateHeaderInformation()` only validates that the miner's OutValue and Signature are filled, and checks the previous in value hash. It does not verify that `ProvidedRound.RoundNumber` matches `BaseRound.RoundNumber`. [2](#0-1) 

The validation context is populated with `BaseRound` (current round from state), `PreviousRound` (previous round from state), and `ProvidedRound` (from miner-supplied consensus extra data). However, no validator checks if these round numbers are consistent. [3](#0-2) 

The `ContinuousBlocksValidationProvider` uses `ProvidedRound.RoundNumber > 2` to determine whether to enforce the continuous blocks limit. By providing `RoundNumber <= 2`, this check evaluates to false and the validation is completely skipped, even when the actual current round is 100+. [4](#0-3) 

When honest miners generate consensus extra data, `GetUpdateValueRound()` correctly copies the `RoundNumber` from the current round. However, nothing prevents a malicious miner from manually constructing extra data with a different round number.

The grep search confirms `ProvidedRound.RoundNumber` is only referenced once in the entire codebase - in the bypassable continuous blocks check.

### Impact Explanation

**Consensus Integrity Violation**: The continuous blocks production limit is a critical consensus mechanism designed to prevent any single miner from monopolizing block production. The base limit is 8 continuous blocks. [5](#0-4) 

When a miner exceeds this limit (tracked via `LatestPubkeyToTinyBlocksCount.BlocksCount < 0`), they should be rejected and forced to trigger a NextRound transition. By bypassing this check, an attacker can:

1. **Monopolize Block Production**: Produce unlimited consecutive blocks instead of the 8-block limit
2. **Centralize the Network**: Other miners are starved of block production opportunities
3. **Manipulate Rewards**: Capture disproportionate block rewards and transaction fees
4. **Degrade Consensus Fairness**: Violate the round-robin miner rotation mechanism
5. **Enable Follow-on Attacks**: Use extended block production windows to execute timing-based attacks

The limit can be dynamically reduced during abnormal blockchain conditions (when LIB is lagging) to as low as 1 block. [6](#0-5) 

Bypassing this protection during severe conditions amplifies the impact, as it defeats the emergency mechanism designed to stabilize the network.

### Likelihood Explanation

**Attack Complexity**: Low - The attack requires only modifying the `RoundNumber` field in consensus extra data before submitting an UpdateValue transaction.

**Attacker Capabilities**: Any authorized miner can execute this attack. Preconditions:
- Attacker must be in the current round's miner list (validated by `MiningPermissionValidationProvider`)
- Attacker must have already exhausted their continuous blocks quota

**Execution Path**:
1. Current round is N (e.g., 100), attacker has `BlocksCount < 0`
2. Attacker crafts consensus extra data with `ProvidedRound.RoundNumber = 1`
3. Submits UpdateValue transaction with this crafted data
4. `ContinuousBlocksValidationProvider` check evaluates false, validation skipped
5. Other validators pass (TimeSlot, MiningPermission, LibInformation, UpdateValue)
6. Block executes successfully using correct round from state
7. Attacker repeats to produce unlimited blocks

**Detection Difficulty**: The attack leaves no obvious traces since the execution uses the correct round number from state. The only indicator is the abnormal continuous block production pattern, but the system designed to prevent this is bypassed.

**Economic Rationality**: High incentive - Block producers earn mining rewards and transaction fees. Monopolizing block production directly increases attacker revenue while denying rewards to other miners.

### Recommendation

Add explicit round number validation in `UpdateValueValidationProvider`:

```csharp
if (validationContext.ProvidedRound.RoundNumber != validationContext.BaseRound.RoundNumber)
{
    return new ValidationResult { Message = "Round number mismatch: provided round must match current round for UpdateValue behavior." };
}
``` [1](#0-0) 

Insert this check at the beginning of `ValidateHeaderInformation()` before other validations. This ensures the provided round number is correct before any subsequent logic relies on it.

Additionally, add test cases covering:
1. UpdateValue with wrong round number (too low) - should fail
2. UpdateValue with wrong round number (too high) - should fail  
3. Continuous blocks limit bypass attempt - should fail with fix in place
4. Normal UpdateValue with correct round number - should succeed

### Proof of Concept

**Initial State**:
- Current round number: 100
- Miner M is in round 100's miner list
- Miner M has produced 8+ continuous blocks
- `State.LatestPubkeyToTinyBlocksCount.Value = {Pubkey: M, BlocksCount: -1}`

**Attack Sequence**:
1. Miner M calls `GetConsensusCommand` - should receive NextRound behavior due to exceeded limit
2. Instead, Miner M manually constructs `AElfConsensusHeaderInformation`:
   - `Behaviour = AElfConsensusBehaviour.UpdateValue`
   - `Round.RoundNumber = 1` (instead of 100)
   - `Round.RealTimeMinersInformation[M]` contains valid OutValue, Signature
   - Other round fields constructed to pass remaining validations
3. Miner M submits UpdateValue transaction with this crafted data
4. Validation executes:
   - `ContinuousBlocksValidationProvider`: `ProvidedRound.RoundNumber (1) > 2` → FALSE → validation skipped
   - Other validators pass
5. Block is accepted and mined
6. Miner M repeats steps 2-5 indefinitely

**Expected Result**: Miner M's block should be rejected by `ContinuousBlocksValidationProvider` with message "Sender produced too many continuous blocks."

**Actual Result**: Miner M's block is accepted. Continuous blocks limit is bypassed. Miner M can produce unlimited consecutive blocks, monopolizing the network.

**Success Condition**: After attack, verify that Miner M has produced >8 consecutive blocks in the current round without triggering NextRound, violating the consensus invariant.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-14)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L14-16)
```csharp
        var round = new Round
        {
            RoundNumber = RoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-66)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
```
