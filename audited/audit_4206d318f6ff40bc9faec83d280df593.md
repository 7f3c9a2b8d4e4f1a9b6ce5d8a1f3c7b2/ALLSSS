### Title
Missing Upper Bound Validation on ImpliedIrreversibleBlockHeight Allows LIB Calculation Manipulation

### Summary
The consensus contract lacks validation that `ImpliedIrreversibleBlockHeight` does not exceed `Context.CurrentHeight` when miners submit consensus updates. Malicious miners can set inflated values that, with sufficient collusion, can manipulate the Last Irreversible Block (LIB) calculation to produce invalid heights, causing the LIB mechanism to stall or fire events with nonsensical future block heights.

### Finding Description
When a miner produces a block and updates consensus information via `UpdateValue`, the `ImpliedIrreversibleBlockHeight` field is set directly from the transaction input without validating it against the current block height. [1](#0-0) 

The intended behavior is to set this value to `Context.CurrentHeight` during block generation: [2](#0-1) 

However, miners can construct transactions with arbitrary `ImpliedIrreversibleBlockHeight` values. The only validation is in `LibInformationValidationProvider`, which merely checks that the value did not decrease: [3](#0-2) 

**There is no validation that `ImpliedIrreversibleBlockHeight <= Context.CurrentHeight`.**

The LIB calculation in the next round uses these potentially inflated values from the previous round: [4](#0-3) 

The calculation selects the value at index `(count - 1) / 3` from sorted implied heights, requiring at least `MinersCountOfConsent = (totalMiners * 2 / 3) + 1` miners to have mined: [5](#0-4) 

If the calculated LIB height exceeds the current blockchain height, the system fires an `IrreversibleBlockFound` event with an invalid future height: [6](#0-5) 

### Impact Explanation
**Consensus Integrity Violation:**
1. Malicious miners can set `ImpliedIrreversibleBlockHeight` to values exceeding `Context.CurrentHeight` (e.g., setting 2000 when producing block at height 1000)
2. With collusion of > 1/3 of miners (exceeding the Byzantine fault tolerance threshold), the LIB calculation can produce a height that exceeds the actual blockchain height
3. The system fires `IrreversibleBlockFound` events with invalid future heights
4. When `IrreversibleBlockFoundLogEventProcessor` attempts to get the block hash at this height, it returns null since the block doesn't exist, causing silent failure
5. This prevents legitimate LIB advancement, stalling the finality mechanism

**Cross-Chain Impact:**
Cross-chain contracts rely on LIB for finalization. Stalled or manipulated LIB values could:
- Delay cross-chain transaction processing
- Create inconsistencies between chains expecting synchronized LIB values

**System-Wide Effects:**
- LIB mechanism becomes unreliable under adversarial conditions
- The consensus safety guarantee is undermined
- Downstream systems depending on LIB (cross-chain indexing, transaction pool cleanup, etc.) malfunction

**Severity: HIGH** - Affects core consensus safety mechanism and requires collusion beyond standard BFT assumptions to fully exploit, but the missing validation allows nonsensical state.

### Likelihood Explanation
**Attacker Requirements:**
- Must be an active miner in the consensus set
- To fully manipulate LIB: requires collusion of more than 1/3 of total miners (exceeding Byzantine threshold)
- To cause invalid LIB events: single malicious miner can inject inflated values

**Attack Complexity:**
- **Low**: Simply modify `UpdateValueInput.ImpliedIrreversibleBlockHeight` when producing blocks
- No cryptographic bypass needed
- Direct manipulation of consensus transaction data

**Feasibility:**
- Entry point is the public `UpdateValue` method called during block production
- The validation provider explicitly checks this field but has incomplete logic
- AElf contract execution model supports this attack vector

**Detection:**
- Difficult to detect in real-time since inflated values are stored in state
- LIB advancement stall would be noticeable but cause unclear
- Invalid `IrreversibleBlockFound` events fail silently

**Economic Rationality:**
- Attack cost: requires becoming a miner (stake requirements)
- For full LIB manipulation: requires controlling > 1/3 of miner stakes
- Griefing attack (causing LIB stall): low cost for a single compromised miner

### Recommendation
**1. Add Upper Bound Validation in ProcessUpdateValue:**

Add validation immediately after line 248 in `AEDPoSContract_ProcessConsensusInformation.cs`:

```csharp
minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
// ADD THIS CHECK:
Assert(minerInRound.ImpliedIrreversibleBlockHeight <= Context.CurrentHeight, 
    "ImpliedIrreversibleBlockHeight cannot exceed current block height.");
```

**2. Strengthen LibInformationValidationProvider:**

Add check in `LibInformationValidationProvider.ValidateHeaderInformation` after line 30:

```csharp
// ADD THIS CHECK:
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight > validationContext.ExtraData.BlockHeight)
{
    validationResult.Message = "ImpliedIrreversibleBlockHeight exceeds block height.";
    return validationResult;
}
```

**3. Add Defensive Check in LIB Calculation:**

In `LastIrreversibleBlockHeightCalculator.Deconstruct`, add validation:

```csharp
libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
// ADD THIS CHECK:
if (libHeight > currentBlockHeight)
    libHeight = 0; // Don't accept future LIB heights
```

**4. Test Cases:**
- Test that UpdateValue rejects `ImpliedIrreversibleBlockHeight > Context.CurrentHeight`
- Test that LIB calculation handles inflated values gracefully
- Test that validation fails for future implied heights
- Test Byzantine scenarios with > 1/3 malicious miners setting inflated values

### Proof of Concept
**Initial State:**
- Blockchain at height 1000
- Round N with 7 miners (MinersCountOfConsent = 5)
- True safe LIB should be approximately 950

**Attack Sequence:**

1. **Malicious Miner A** produces block at height 1000:
   - Constructs `UpdateValueInput` with `ImpliedIrreversibleBlockHeight = 2000` (instead of correct value 1000)
   - Submits block with this consensus transaction

2. **Validation**:
   - `LibInformationValidationProvider` checks only that value didn't decrease (passes if previous value â‰¤ 2000)
   - No check that 2000 > 1000 (Context.CurrentHeight)
   - Transaction accepted and executed

3. **State Update**:
   - `ProcessUpdateValue` stores `ImpliedIrreversibleBlockHeight = 2000` for Miner A

4. **Subsequent Rounds**:
   - Miners B, C, D repeat the attack (requires collusion of 4 out of 7 miners)
   - Previous round now has heights: [2000, 2000, 2000, 2000, 1001, 1002, 1003]

5. **LIB Calculation in Round N+1** (at blockchain height ~1007):
   - `LastIrreversibleBlockHeightCalculator` sorts: [1001, 1002, 1003, 2000, 2000, 2000, 2000]
   - Selects index (7-1)/3 = 2
   - Calculates LIB = 1003 (if not enough colluders) or higher with more manipulation

6. **With Full Collusion** (5+ miners):
   - Sorted heights: [2000, 2000, 2000, 2000, 2000, 1001, 1002]
   - LIB calculated as 1002 or 2000 depending on how many inflated
   - System fires `IrreversibleBlockFound` with potentially invalid height

7. **Result**:
   - If LIB > current blockchain height: `IrreversibleBlockFoundLogEventProcessor.GetBlockHashByHeightAsync` returns null, silent failure
   - LIB advancement stalls
   - System accepts and stores nonsensical consensus data

**Expected Behavior**: Transaction rejected with "ImpliedIrreversibleBlockHeight cannot exceed current block height"

**Actual Behavior**: Transaction accepted, inflated value stored, LIB mechanism potentially compromised

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-19)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);

    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```
