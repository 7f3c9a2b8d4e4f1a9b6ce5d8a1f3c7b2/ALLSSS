### Title
Unhandled Dictionary Access Exception in GetUpdateValueRound Can DOS Consensus Operations

### Summary
The `GetUpdateValueRound()` method directly accesses the `RealTimeMinersInformation` dictionary without validating key existence, causing an unhandled `KeyNotFoundException` when called with an invalid pubkey or empty dictionary. This exception can propagate during block production and DOS consensus operations, particularly since the calling method `GetConsensusExtraData()` is publicly accessible and lacks defensive validation.

### Finding Description

The vulnerability exists across multiple locations in the consensus extra data generation flow: [1](#0-0) 

In `GetUpdateValueRound()`, line 13 directly accesses `RealTimeMinersInformation[pubkey]` without checking if the key exists in the dictionary. If the dictionary is empty or does not contain the pubkey, this throws `KeyNotFoundException`. [2](#0-1) 

The same vulnerability exists earlier in the call chain at `GetConsensusExtraDataToPublishOutValue()`, where lines 58-63 repeatedly access `currentRound.RealTimeMinersInformation[pubkey]` without validation. [3](#0-2) 

The entry point `GetConsensusBlockExtraData()` does not validate the return value from `TryToGetCurrentRoundInformation()` at line 20, and proceeds to call `GetConsensusExtraDataToPublishOutValue()` with potentially invalid round data. The subsequent call to `GetUpdateValueRound(pubkey)` at line 31 compounds the issue. [4](#0-3) 

The public entry point `GetConsensusExtraData()` is a view method with no access control that directly delegates to `GetConsensusBlockExtraData()`. [5](#0-4) 

While `ApplyNormalConsensusData()` does check for key existence and returns unchanged if the pubkey is missing, this protection occurs AFTER the vulnerable dictionary accesses in `GetConsensusExtraDataToPublishOutValue()`.

**Root Cause:** Lack of defensive programming - no `ContainsKey()` checks before dictionary access operations. The methods assume the pubkey will always be present but fail catastrophically when this assumption is violated.

**Why Existing Protections Fail:** [6](#0-5) 

While `GetConsensusCommand()` validates the miner is in the list using `IsInMinerList()`, this validation is in a separate method. The `GetConsensusExtraData()` view method can be called directly without going through `GetConsensusCommand()`, bypassing this validation.

### Impact Explanation

**Operational Impact - Consensus DOS:** [7](#0-6) 

During block production, `GetConsensusExtraDataAsync()` calls the consensus contract's `GetConsensusExtraData.CallAsync()` method. If this throws `KeyNotFoundException`, the contract call fails, preventing generation of consensus extra data required for block headers. [8](#0-7) 

The `GetBlockHeaderExtraDataAsync()` method relies on successful consensus extra data generation. Failure cascades to block production failure, preventing miners from producing blocks and halting consensus progress.

**Affected Parties:**
- All network participants experience consensus disruption
- Block producers unable to fulfill their consensus duties
- Transactions cannot be processed during the DOS period

**Severity Justification:** Medium severity because while the impact (consensus halt) is severe, exploitation requires either:
1. State inconsistency (race condition, bug in round management)
2. Direct malicious invocation of the public view method
3. Edge cases where upstream validation fails

### Likelihood Explanation

**Attacker Capabilities:**
- Any user can call `GetConsensusExtraData()` as it is a public view method with no access control
- Attacker only needs to provide a pubkey that is not in the current round's miner list
- No special permissions or stake required

**Attack Complexity:** Low
1. Query current round information to identify valid round number
2. Call `GetConsensusExtraData()` with arbitrary pubkey not in miner list
3. Exception is thrown, potentially affecting concurrent block production

**Feasibility Conditions:**
- Normal consensus flow has upstream validation in `GetConsensusCommand()` that should prevent this
- However, edge cases exist:
  - Race conditions during round transitions
  - State inconsistencies between command generation and extra data generation
  - Bugs in round management that result in empty or incomplete miner lists
  - Direct calls to `GetConsensusExtraData()` bypassing command validation

**Likelihood Assessment:** Medium
- Direct exploitation through malicious calls to view method has low impact (view methods don't affect state)
- Real risk is during legitimate block production if state inconsistencies occur
- Probability depends on robustness of round management and state consistency guarantees

### Recommendation

**Immediate Mitigation:**

Add defensive validation in `GetUpdateValueRound()`:
```csharp
public Round GetUpdateValueRound(string pubkey)
{
    if (!RealTimeMinersInformation.ContainsKey(pubkey))
    {
        Context.LogWarning($"Pubkey {pubkey} not found in RealTimeMinersInformation");
        return new Round(); // Or throw a more specific, handled exception
    }
    var minerInRound = RealTimeMinersInformation[pubkey];
    // ... rest of method
}
```

Add validation in `GetConsensusExtraDataToPublishOutValue()`:
```csharp
private AElfConsensusHeaderInformation GetConsensusExtraDataToPublishOutValue(...)
{
    Assert(currentRound.RealTimeMinersInformation.ContainsKey(pubkey), 
           $"Pubkey {pubkey} is not in current round miner list");
    // ... rest of method
}
```

Add return value check in `GetConsensusBlockExtraData()`:
```csharp
if (!TryToGetCurrentRoundInformation(out var currentRound))
{
    Assert(false, "Failed to get current round information");
}
```

**Test Cases:**
1. Call `GetConsensusExtraData()` with pubkey not in current round - should return error, not throw
2. Call with empty round information - should handle gracefully
3. Test round transition edge cases - ensure no race conditions
4. Verify exception handling during block production flows

### Proof of Concept

**Initial State:**
- Consensus contract deployed and initialized
- Current round has miners A, B, C with pubkeys 0x01, 0x02, 0x03

**Attack Steps:**
1. Attacker queries current round to confirm miner list
2. Attacker calls `GetConsensusExtraData()` with trigger information containing:
   - Pubkey: 0x99 (not in current miner list)
   - Behaviour: AElfConsensusBehaviour.UpdateValue
   - Valid InValue and other required fields

**Expected Result:** Method returns valid result or handled error

**Actual Result:** 
- `GetConsensusExtraDataToPublishOutValue()` attempts to access `currentRound.RealTimeMinersInformation[0x99]` at line 58
- `KeyNotFoundException` is thrown
- Contract execution fails with unhandled exception
- If this occurs during legitimate block production (due to race condition or state inconsistency), block production fails

**Success Condition:** Exception is thrown when accessing dictionary with invalid key, demonstrating lack of defensive validation

### Notes

The vulnerability manifests at multiple points in the call chain. While the question specifically asks about `GetUpdateValueRound()`, the exception would typically occur earlier at `GetConsensusExtraDataToPublishOutValue()` lines 58-63. However, both locations lack proper defensive checks and should be fixed. The issue represents a systemic lack of input validation in consensus extra data generation that could be exploited during edge cases or state inconsistencies.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L13-13)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L20-31)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);

        var publicKeyBytes = triggerInformation.Pubkey;
        var pubkey = publicKeyBytes.ToHex();

        var information = new AElfConsensusHeaderInformation();
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L58-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-58)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L10-10)
```csharp
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L195-208)
```csharp
    public async Task<byte[]> GetConsensusExtraDataAsync(ChainContext chainContext)
    {
        _blockTimeProvider.SetBlockTime(_nextMiningTime, chainContext.BlockHash);

        Logger.LogDebug(
            $"Block time of getting consensus extra data: {_nextMiningTime.ToDateTime():hh:mm:ss.ffffff}.");

        var contractReaderContext =
            await _consensusReaderContextService.GetContractReaderContextAsync(chainContext);
        var input = _triggerInformationProvider.GetTriggerInformationForBlockHeaderExtraData(
            _consensusCommand.ToBytesValue());
        var consensusContractStub = _contractReaderFactory.Create(contractReaderContext);
        var output = await consensusContractStub.GetConsensusExtraData.CallAsync(input);
        return output.Value.ToByteArray();
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusExtraDataProvider.cs (L29-40)
```csharp
    public async Task<ByteString> GetBlockHeaderExtraDataAsync(BlockHeader blockHeader)
    {
        if (blockHeader.Height == AElfConstants.GenesisBlockHeight) return null;

        var consensusInformation = await _consensusService.GetConsensusExtraDataAsync(new ChainContext
        {
            BlockHash = blockHeader.PreviousBlockHash,
            BlockHeight = blockHeader.Height - 1
        });

        return consensusInformation == null ? ByteString.Empty : ByteString.CopyFrom(consensusInformation);
    }
```
