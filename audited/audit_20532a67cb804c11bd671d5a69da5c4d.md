# Audit Report

## Title
Arithmetic Underflow in Quadratic Voting Withdrawal Due to Vote/Withdraw Amount Mismatch

## Summary
The Vote contract contains a critical arithmetic mismatch between vote addition and withdrawal for quadratic voting items. When a quadratic vote is cast, only `1` is added to `Results[option]`, but during withdrawal, the full `votingRecord.Amount` (equal to `TicketCost * votesCount`) is subtracted. This causes an arithmetic underflow exception, permanently preventing users from withdrawing their locked tokens and creating a complete denial-of-service for all quadratic voting items.

## Finding Description

The Vote contract implements quadratic voting functionality where users pay an increasing cost for each additional vote. However, there is a fundamental inconsistency in how vote amounts are tracked versus how they are withdrawn.

**During Vote Execution:**

When a user votes on a quadratic voting item, the contract calculates the amount as `TicketCost * currentVotesCount` and stores this full amount in the voting record. [1](#0-0) 

However, when updating the voting results, the contract passes only `1` instead of the actual locked amount for quadratic votes. [2](#0-1) 

The `UpdateVotingResult()` function then adds this value (which is `1` for quadratic voting) to `Results[option]`. [3](#0-2) 

**During Withdrawal:**

When a user attempts to withdraw, the contract subtracts the full `votingRecord.Amount` from `Results[option]` without any special handling for quadratic voting. [4](#0-3) 

**Why This Fails:**

The `.Sub()` method is a checked arithmetic operation that throws an `OverflowException` when underflow occurs. [5](#0-4) 

Since `Results[option]` contains only `1` but the withdrawal attempts to subtract `TicketCost * votesCount` (which is always greater than 1 for any reasonable ticket cost), the operation `1.Sub(100)` throws an exception, causing the transaction to fail.

The `Withdraw()` function never checks the `IsQuadratic` flag to adjust its logic accordingly, making this issue affect every single quadratic voting withdrawal attempt.

## Impact Explanation

**Direct Fund Impact:**
- All tokens locked for quadratic voting become permanently locked and unrecoverable
- Users cannot withdraw their funds, resulting in complete loss of access to locked tokens
- For example: If `TicketCost = 100` and a user votes once, they lock 100 tokens but `Results[option]` only contains `1`, making withdrawal mathematically impossible

**Operational Impact:**
- Complete denial of service on the `Withdraw()` function for ALL quadratic voting items
- Voting results are corrupted as `Results[option]` values don't reflect actual token amounts locked
- The entire quadratic voting feature is non-functional in production

**Affected Parties:**
- All users who participate in quadratic voting items lose their locked tokens
- Vote sponsors who create quadratic voting items unknowingly create token traps
- The protocol's voting mechanism integrity is compromised

This represents a HIGH severity vulnerability due to guaranteed permanent fund loss and complete feature DoS with no available workaround.

## Likelihood Explanation

**No Attack Required:**
This is a fundamental logic bug that triggers during normal, legitimate operation. No malicious intent or special conditions are needed.

**Trivial Reproduction:**
Any user participating in quadratic voting will encounter this issue:
1. Sponsor creates a quadratic voting item with `IsQuadratic = true` and any `TicketCost > 1`
2. User votes normally using the public `Vote()` function
3. User attempts to withdraw using the public `Withdraw()` function
4. Transaction fails with `OverflowException`

**Feasibility:**
- Quadratic voting feature must be enabled (`IsQuadratic = true`)
- `TicketCost` must be greater than the vote count (always true for reasonable ticket costs like 100, 1000, etc.)
- No special permissions or state manipulation required
- Uses standard public contract methods

**Probability:**
100% reproducible on every quadratic voting withdrawal attempt. The arithmetic mismatch guarantees the failure.

## Recommendation

The `Withdraw()` function must check the `IsQuadratic` flag and apply the same logic used during voting. Specifically:

```csharp
public override Empty Withdraw(WithdrawInput input)
{
    var votingRecord = State.VotingRecords[input.VoteId];
    if (votingRecord == null) throw new AssertionException("Voting record not found.");
    var votingItem = State.VotingItems[votingRecord.VotingItemId];

    // ... existing permission checks ...

    var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);
    var votingResult = State.VotingResults[votingResultHash];
    
    // FIX: Use same logic as Vote() - subtract 1 for quadratic, full amount for regular
    var amountToSubtract = votingItem.IsQuadratic ? 1 : votingRecord.Amount;
    votingResult.Results[votingRecord.Option] =
        votingResult.Results[votingRecord.Option].Sub(amountToSubtract);
    
    // ... rest of withdrawal logic ...
}
```

This ensures symmetry between vote addition and withdrawal, preventing the underflow condition.

## Proof of Concept

```csharp
[Fact]
public async Task QuadraticVoting_Withdrawal_Underflow_Test()
{
    // Register a quadratic voting item with TicketCost = 100
    var votingItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1, isQuadratic: true, ticketCost: 100);
    
    var voter = Accounts[1].KeyPair;
    var voterAddress = Accounts[1].Address;
    
    // User votes once - this will lock 100 tokens but only add 1 to Results[option]
    await Vote(voter, votingItem.VotingItemId, votingItem.Options[0], 100);
    
    // Verify the voting record shows 100 tokens locked
    var voteIds = await GetVoteIds(voter, votingItem.VotingItemId);
    var voteId = voteIds.ActiveVotes.First();
    var votingRecord = await VoteContractStub.GetVotingRecord.CallAsync(voteId);
    votingRecord.Amount.ShouldBe(100); // Full amount stored
    
    // Verify Results[option] only contains 1
    var votingResult = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = votingItem.VotingItemId,
        SnapshotNumber = 1
    });
    votingResult.Results[votingItem.Options[0]].ShouldBe(1); // Only 1 added for quadratic
    
    // Attempt to withdraw - this will fail with OverflowException
    // Because it tries to do: Results[option].Sub(votingRecord.Amount) => 1.Sub(100)
    var withdrawResult = await WithdrawWithException(voter, voteId);
    
    withdrawResult.Status.ShouldBe(TransactionResultStatus.Failed);
    withdrawResult.Error.ShouldContain("Overflow"); // Arithmetic underflow detected
    
    // Tokens remain permanently locked - user cannot recover them
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L98-103)
```csharp
        else
        {
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L119-119)
```csharp
        UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L176-177)
```csharp
        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L215-216)
```csharp
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-97)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
```
