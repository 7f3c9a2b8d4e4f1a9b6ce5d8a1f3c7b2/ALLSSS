### Title
Zero IndexingPrice Allows Free Side Chain Block Indexing, Breaking Economic Incentive Model

### Summary
The `CreateSideChain` function accepts IndexingPrice of zero without validation, allowing side chain creators to set up chains that never pay indexing fees to miners. This breaks the cross-chain economic model where miners are compensated for indexing side chain blocks, resulting in free indexing service for the side chain at the expense of unpaid miner work.

### Finding Description

The validation function `AssertValidSideChainCreationRequest` only checks that `IndexingPrice >= 0`, which allows zero as a valid value: [1](#0-0) 

In `CreateSideChain`, the IndexingPrice from the request is directly assigned to the SideChainInfo without any minimum price enforcement: [2](#0-1) 

When side chain blocks are indexed in `IndexSideChainBlockData`, the indexing price is retrieved and used to calculate fees. If IndexingPrice is zero, no fee deduction occurs (`lockedToken -= 0`), no fee accumulates (`indexingFeeAmount += 0`), and the transfer to miners is skipped since the condition `indexingFeeAmount > 0` evaluates to false: [3](#0-2) 

Additionally, the `AdjustIndexingFeePrice` function also allows adjusting the price to zero with only a check for `>= 0`, and requires approval from an organization that includes the side chain creator by default: [4](#0-3) 

### Impact Explanation

**Direct Economic Impact:**
- Miners who index side chain blocks receive zero compensation for their computational work and storage resources
- Side chain operators obtain indexing services indefinitely without payment
- The cross-chain indexing fee mechanism, designed to compensate miners and ensure service sustainability, is completely bypassed

**Protocol Integrity:**
- Breaks the fundamental economic incentive model where miners are paid for cross-chain indexing work
- Creates an unfair advantage for side chains with zero indexing price over those paying appropriate fees
- Undermines the sustainability of the cross-chain infrastructure

**Affected Parties:**
- Miners: Perform unpaid labor indexing side chain blocks
- Protocol: Economic model broken, incentive misalignment
- Honest side chain creators: Disadvantaged against free-riders

**Severity Justification:** HIGH - Direct economic exploitation, breaks critical protocol invariant (miner compensation for cross-chain work), easily exploitable with lasting impact.

### Likelihood Explanation

**Attack Feasibility:**
The vulnerability is highly exploitable because:
1. **Reachable Entry Point:** The `RequestSideChainCreation` and `CreateSideChain` functions are standard public methods accessible through the governance proposal flow
2. **Feasible Preconditions:** Only requires governance approval, and the side chain creator is included in the default indexing fee controller organization
3. **Low Attack Complexity:** Simple parameter setting (IndexingPrice = 0, LockedTokenAmount = 0) passes all validations
4. **Economic Rationality:** Zero cost to attacker (no fees paid), significant benefit (free indexing forever)

**Execution Practicality:**
The attack follows the normal side chain creation process with no special permissions or exploits required. The test suite even validates that negative indexing prices are rejected but does not test or prevent zero: [5](#0-4) 

**Detection Constraints:** The zero indexing price would be visible in the proposal but may not raise immediate concerns if reviewers assume validation exists.

### Recommendation

**Immediate Fix:**
Add a minimum indexing price constant and enforce it in validation:

1. In `AssertValidSideChainCreationRequest`, add a minimum price check: [1](#0-0) 

Update the assertion to:
```csharp
const long MinimumIndexingPrice = 1; // Define appropriate minimum
Assert(
    sideChainCreationRequest.IndexingPrice >= MinimumIndexingPrice &&
    sideChainCreationRequest.LockedTokenAmount >= sideChainCreationRequest.IndexingPrice,
    "Invalid chain creation request.");
```

2. In `AdjustIndexingFeePrice`, enforce the same minimum: [6](#0-5) 

Update to:
```csharp
Assert(input.IndexingFee >= MinimumIndexingPrice, "Invalid side chain fee price.");
```

**Test Coverage:**
Add test cases to verify:
- Side chain creation with IndexingPrice = 0 is rejected
- AdjustIndexingFeePrice with value 0 is rejected
- Side chain creation with IndexingPrice = MinimumIndexingPrice succeeds
- Miners receive appropriate compensation at minimum price level

### Proof of Concept

**Initial State:**
- Cross-chain contract initialized
- Attacker has sufficient allowance for minimal locked tokens (can be 0)

**Attack Sequence:**
1. Attacker calls `RequestSideChainCreation` with:
   - `IndexingPrice = 0`
   - `LockedTokenAmount = 0`
   - `IsPrivilegePreserved = false` (to avoid additional token requirements)

2. Proposal passes governance approval (attacker participates in organization voting)

3. `CreateSideChain` executes successfully, creating side chain with IndexingPrice = 0

4. Miners propose and index side chain blocks via `ProposeCrossChainIndexing` and `ReleaseCrossChainIndexingProposal`

5. In `IndexSideChainBlockData`, for each indexed block:
   - `indexingPrice = 0` retrieved from SideChainInfo
   - `lockedToken -= 0` (no deduction)
   - `indexingFeeAmount += 0` (no fee accumulates)
   - Transfer to miner skipped (condition `indexingFeeAmount > 0` is false)

**Expected Result:** Miner receives indexing fee payment

**Actual Result:** Miner receives zero compensation, side chain indexes blocks indefinitely for free

**Success Condition:** Side chain status remains Active, blocks are indexed, but no token transfers occur to miners indexing the blocks.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L119-122)
```csharp
        Assert(
            sideChainCreationRequest.IndexingPrice >= 0 &&
            sideChainCreationRequest.LockedTokenAmount >= sideChainCreationRequest.IndexingPrice,
            "Invalid chain creation request.");
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L842-868)
```csharp
                var indexingPrice = sideChainInfo.IndexingPrice;

                lockedToken -= indexingPrice;

                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
                else
                {
                    indexingFeeAmount += indexingPrice;
                }

                currentSideChainHeight++;
                indexedSideChainBlockData.Add(sideChainBlockData);
            }

            if (indexingFeeAmount > 0)
                TransferDepositToken(new TransferInput
                {
                    To = proposer,
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = indexingFeeAmount,
                    Memo = "Index fee."
                }, chainId);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L143-154)
```csharp
        var sideChainInfo = new SideChainInfo
        {
            Proposer = input.Proposer,
            SideChainId = chainId,
            SideChainStatus = SideChainStatus.Active,
            IndexingPrice = sideChainCreationRequest.IndexingPrice,
            IsPrivilegePreserved = sideChainCreationRequest.IsPrivilegePreserved,
            CreationTimestamp = Context.CurrentBlockTime,
            CreationHeightOnParentChain = Context.CurrentHeight,
            IndexingFeeController = CreateDefaultOrganizationForIndexingFeePriceManagement(input.Proposer)
        };
        State.SideChainInfo[chainId] = sideChainInfo;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L244-255)
```csharp
    public override Empty AdjustIndexingFeePrice(AdjustIndexingFeeInput input)
    {
        var info = State.SideChainInfo[input.SideChainId];
        Assert(info != null && info.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");
        Assert(input.IndexingFee >= 0, "Invalid side chain fee price.");
        var expectedOrganizationAddress = info.IndexingFeeController.OwnerAddress;
        Assert(expectedOrganizationAddress == Context.Sender, "No permission.");
        info.IndexingPrice = input.IndexingFee;
        State.SideChainInfo[input.SideChainId] = info;
        return new Empty();
    }
```

**File:** test/AElf.Contracts.CrossChain.Tests/SideChainLifeTimeManagementTest.cs (L1128-1143)
```csharp
        {
            var createProposalInput = CreateSideChainCreationRequest(-1, 10, GetValidResourceAmount(),
                new[]
                {
                    new SideChainTokenInitialIssue
                    {
                        Address = DefaultSender,
                        Amount = 100
                    }
                }, true);
            var requestSideChainCreation =
                await CrossChainContractStub.RequestSideChainCreation.SendWithExceptionAsync(createProposalInput);

            requestSideChainCreation.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
            requestSideChainCreation.TransactionResult.Error.ShouldContain("Invalid chain creation request.");
        }
```
