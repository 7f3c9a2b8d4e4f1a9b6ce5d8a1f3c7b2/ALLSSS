### Title
Missing Minimum Block Count Validation Allows Premature Round Termination

### Summary
The `ValidationForNextRound()` function in `RoundTerminateValidationProvider.cs` lacks validation to ensure a minimum number of blocks have been produced in the current round before advancing to the next round. This allows rounds to terminate prematurely with insufficient block production, violating consensus integrity expectations and potentially degrading blockchain throughput.

### Finding Description

The vulnerability exists in the `ValidationForNextRound()` method which only performs two checks when validating round termination: [1](#0-0) 

The function validates:
1. Round number increments by exactly 1
2. All InValues are null in the next round

**Root Cause**: The validation does not check whether a minimum threshold of blocks were produced in `BaseRound` before allowing round advancement. The `Round` structure contains the `GetMinedBlocks()` method that aggregates total blocks produced: [2](#0-1) 

Additionally, the `Round` structure includes `MinersCountOfConsent` which calculates the 2/3 majority threshold: [3](#0-2) 

However, neither `GetMinedBlocks()` nor `MinersCountOfConsent` are used in the round termination validation logic. The validation providers are applied in: [4](#0-3) 

The `NextRoundMiningOrderValidationProvider` validates consistency between miners who mined and those determining next order: [5](#0-4) 

However, this only ensures that all miners who actually mined have determined their next round order—it does not enforce a minimum participation threshold. If only 1 out of 17 miners produces a block, the validation still passes.

The round advancement process occurs through: [6](#0-5) 

And is processed in: [7](#0-6) 

The `ProcessNextRound` method only detects "evil miners" based on missed time slots (>= 4,320), not total block production.

### Impact Explanation

**Consensus Integrity Violation**: Rounds can advance with significantly fewer blocks than expected. In a network with 17 miners, a round could theoretically advance with only 1-2 blocks produced instead of the expected 17+ blocks, representing an 88-94% reduction in block production.

**Degraded Blockchain Throughput**: Premature round termination directly reduces transaction processing capacity. If rounds consistently advance with minimal blocks, the blockchain's effective TPS (transactions per second) could drop dramatically below design specifications.

**Unfair Reward Distribution**: Mining rewards and profit distributions are based on blocks produced per round. Rounds terminating early benefit miners who managed to produce blocks while penalizing those who didn't get the opportunity, creating economic imbalances.

**Network Synchronization Issues**: Other nodes expecting a minimum block count per round may experience confusion or delays when rounds advance prematurely, potentially causing temporary consensus disagreements.

**Severity Justification**: This violates the critical invariant "Correct round transitions and time-slot validation, miner schedule integrity" under Consensus & Cross-Chain integrity. The impact is systemic as it affects the fundamental consensus mechanism's operation rather than isolated transactions.

### Likelihood Explanation

**Attacker Capabilities**: The extra block producer (determined pseudo-randomly each round) can legitimately trigger `NextRound` when their time slot arrives: [8](#0-7) 

No special privileges beyond normal miner status are required.

**Attack Complexity**: Low. The extra block producer simply calls `NextRound` at the appropriate time. The consensus behavior determination logic: [9](#0-8) 

automatically returns the termination behavior without checking block count thresholds.

**Feasibility Conditions**: 
- Network disruption (DDoS, network partition) preventing most miners from producing blocks
- Coordinated attack where malicious miners intentionally skip their time slots
- Software bugs causing miners to fail block production
- Natural occurrence during initial network bootstrapping or low participation periods

**Detection Constraints**: The blockchain will record the premature round advancement in the consensus logs, but without minimum block count validation, this appears as legitimate consensus behavior rather than an attack.

**Probability**: MEDIUM to HIGH. This can occur both accidentally (during network issues) and intentionally (malicious extra block producer exploiting lack of validation). The likelihood increases during periods of network instability or low miner participation.

### Recommendation

**Add Minimum Block Count Validation**: Modify `ValidationForNextRound()` to enforce a minimum threshold of blocks produced:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing checks
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Enforce minimum block count threshold
    var minedBlocks = validationContext.BaseRound.GetMinedBlocks();
    var minersCount = validationContext.BaseRound.RealTimeMinersInformation.Count;
    var minimumRequiredBlocks = minersCount > 1 ? minersCount.Mul(2).Div(3) : 1; // Require 2/3 of miners to have produced blocks
    
    if (minedBlocks < minimumRequiredBlocks)
        return new ValidationResult 
        { 
            Message = $"Insufficient blocks produced. Required: {minimumRequiredBlocks}, Actual: {minedBlocks}" 
        };

    return new ValidationResult { Success = true };
}
```

**Alternative Approach**: Enforce that at least `MinersCountOfConsent` miners have produced blocks:

```csharp
var minersWhoMined = validationContext.BaseRound.GetMinedMiners().Count;
var requiredMiners = validationContext.BaseRound.MinersCountOfConsent;

if (minersWhoMined < requiredMiners)
    return new ValidationResult 
    { 
        Message = $"Insufficient miner participation. Required: {requiredMiners}, Actual: {minersWhoMined}" 
    };
```

**Test Cases**:
1. Test round advancement fails when only 1 of 17 miners produced blocks
2. Test round advancement succeeds when ≥ 2/3 miners produced blocks  
3. Test single-node scenario (should allow advancement with 1 block)
4. Test edge case with exactly 2/3 threshold

### Proof of Concept

**Initial State**:
- Network with 17 active miners (standard AElf mainchain configuration)
- Round N in progress with round number = 100
- Current time has reached extra block producer's time slot
- Miner M1 is designated as extra block producer for this round

**Attack Sequence**:

1. **Network Disruption Phase**: Attacker (or natural network issues) prevents 15 of 17 miners from producing blocks during round N. Only miners M1 and M2 successfully produce blocks.

2. **Validation Check**: M1 generates NextRound consensus command. The validation flow executes:
   - `ValidateBeforeExecution()` calls validation providers
   - `RoundTerminateValidationProvider.ValidationForNextRound()` executes
   - Checks: Round number 100 + 1 = 101 ✓
   - Checks: InValues are null ✓
   - **Missing Check**: GetMinedBlocks() returns 2, but no minimum threshold validation exists
   - Validation passes

3. **Round Advancement**: M1 calls `NextRound()`: [6](#0-5) 

4. **Result**: Round advances from 100 to 101 despite only 2 of 17 miners (11.8%) producing blocks.

**Expected Behavior**: Round advancement should be rejected with error "Insufficient blocks produced. Required: 11, Actual: 2"

**Actual Behavior**: Round advances successfully with only 2 blocks produced, violating the expected consensus participation threshold of 2/3 (11+ miners).

**Success Condition**: Check blockchain state after M1's NextRound transaction:
- `State.CurrentRoundNumber.Value` increments to 101 despite insufficient block production
- `GetMinedBlocksOfPreviousTerm()` for round 100 returns only 2 blocks
- No validation error is logged

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L124-127)
```csharp
    public long GetMinedBlocks()
    {
        return RealTimeMinersInformation.Values.Sum(minerInRound => minerInRound.ProducedBlocks);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```
