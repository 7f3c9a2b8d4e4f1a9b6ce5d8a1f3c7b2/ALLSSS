### Title
Miner Subset Exclusion Attack via Unvalidated ProvidedRound Miner List in NextRound Transitions

### Summary
The `NextRoundMiningOrderValidationProvider` validates that counts of miners with `FinalOrderOfNextRound > 0` equals counts with `OutValue != null` within the `ProvidedRound`, but never validates that `ProvidedRound` contains ALL miners from `BaseRound`. A malicious miner can craft a `NextRoundInput` excluding legitimate miners, pass validation, and commit an incomplete miner set to state, effectively removing miners from consensus and denying their rewards.

### Finding Description

The vulnerability exists in the validation logic for NextRound consensus transitions: [1](#0-0) 

This validator only checks internal consistency within `ProvidedRound` - that miners with `FinalOrderOfNextRound > 0` match those with `OutValue != null`. Both counts are computed from the SAME `ProvidedRound.RealTimeMinersInformation` collection.

During NextRound behavior validation, only these providers are active: [2](#0-1) 

None of these validators compare the miner list in `ProvidedRound` against `BaseRound` to ensure completeness. The `MiningPermissionValidationProvider` only checks the sender: [3](#0-2) 

The `ProvidedRound` comes directly from the `NextRoundInput` submitted by the block producer: [4](#0-3) 

After validation passes, the provided round is directly committed to state without any miner count verification: [5](#0-4) 

The `ToRound()` conversion preserves whatever miners are in the input: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Compromise**: An attacker can arbitrarily exclude legitimate miners from subsequent rounds, reducing the active consensus set from N to M miners (M < N). This directly violates the "miner schedule integrity" critical invariant.

**Reward Misallocation**: Excluded miners lose all mining rewards for subsequent rounds until the attack is detected and corrected. In a 7-miner network where 2 miners are excluded, victims lose 100% of their expected earnings while the remaining 5 miners receive disproportionate rewards (40% increase per miner).

**Security Degradation**: Reducing the active miner set from 7 to 5 decreases Byzantine fault tolerance. The network becomes vulnerable to collusion attacks with fewer compromised nodes needed for 51% control.

**Operational Impact**: Excluded miners cannot participate in consensus despite being validly elected, creating a denial-of-service condition for legitimate participants. This can be repeated across multiple rounds to permanently suppress specific miners.

### Likelihood Explanation

**Reachable Entry Point**: Any miner authorized to produce the NextRound block can execute this attack via the public `NextRound` method: [7](#0-6) 

**Minimal Attacker Capabilities**: The attacker only needs to:
1. Be an active miner with normal block production rights
2. Wait for their turn to produce the NextRound transition block
3. Modify the `NextRoundInput.RealTimeMinersInformation` map to exclude target miners
4. Submit the transaction

**No Special Privileges Required**: The attack doesn't require compromising governance, election contracts, or other trusted roles - just normal miner participation.

**Attack Complexity**: LOW - The attacker can legitimately generate proper NextRound data via `GetConsensusExtraData`, then manually modify the miner list before submission. The validation logic has no defense against this manipulation.

**Detection Difficulty**: The attack may go undetected initially as the validation passes all checks. Only off-chain monitoring comparing expected vs actual miner counts would detect the discrepancy.

**Economic Rationality**: HIGH - Colluding miners can increase their rewards by 20-40% by excluding competitors, with minimal cost (one block production slot). The incentive is particularly strong when mining rewards are substantial.

### Recommendation

Add explicit validation in `NextRoundMiningOrderValidationProvider` to ensure the miner set integrity:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var providedRound = validationContext.ProvidedRound;
    var baseRound = validationContext.BaseRound;
    
    // NEW CHECK: Ensure miner count matches unless IsMinerListJustChanged
    if (!providedRound.IsMinerListJustChanged && 
        providedRound.RealTimeMinersInformation.Count != baseRound.RealTimeMinersInformation.Count)
    {
        validationResult.Message = "Provided round miner count does not match base round.";
        return validationResult;
    }
    
    // NEW CHECK: Ensure all base round miners are present in provided round (unless list changed)
    if (!providedRound.IsMinerListJustChanged)
    {
        foreach (var baseKey in baseRound.RealTimeMinersInformation.Keys)
        {
            if (!providedRound.RealTimeMinersInformation.ContainsKey(baseKey))
            {
                validationResult.Message = $"Miner {baseKey} from base round missing in provided round.";
                return validationResult;
            }
        }
    }
    
    // Existing check
    var distinctCount = providedRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0).Distinct().Count();
    if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound.";
        return validationResult;
    }

    validationResult.Success = true;
    return validationResult;
}
```

Add comprehensive test cases covering:
- NextRound with fewer miners than BaseRound (should fail)
- NextRound with different miners than BaseRound (should fail)
- NextRound with correct miner set (should pass)
- NextRound with `IsMinerListJustChanged=true` (special handling)

### Proof of Concept

**Initial State:**
- Current round has 7 miners: {Alice, Bob, Carol, Dave, Eve, Frank, Grace}
- All 7 miners produced blocks with valid `OutValue` and `FinalOrderOfNextRound`
- Round number: 100
- Attacker: Alice (authorized miner)

**Attack Sequence:**

1. Alice's turn to produce NextRound block arrives
2. Alice calls `GetConsensusExtraData` with `NextRound` behavior to generate proper round data with all 7 miners
3. Alice manually constructs `NextRoundInput`:
   - `RoundNumber = 101`
   - `RealTimeMinersInformation` = {Alice, Bob, Carol, Dave, Eve} (excludes Frank, Grace)
   - For each included miner: copy `FinalOrderOfNextRound`, `OutValue`, and other fields
   - `IsMinerListJustChanged = false`
   - Other fields: proper values
4. Alice submits `NextRound(modifiedInput)` transaction

**Validation Result:**
- `MiningPermissionValidationProvider`: Alice in BaseRound → ✓ PASS
- `NextRoundMiningOrderValidationProvider`: count(FinalOrderOfNextRound > 0) = 5, count(OutValue != null) = 5 in ProvidedRound → ✓ PASS (both counts from subset!)
- `RoundTerminateValidationProvider`: RoundNumber increments 100→101 → ✓ PASS
- Transaction succeeds

**Actual Result:**
- Round 101 committed to state with only 5 miners
- Frank and Grace excluded from consensus
- Frank and Grace lose all mining opportunities and rewards for round 101 and beyond until corrected
- Remaining 5 miners receive 40% higher rewards (distributing among 5 instead of 7)

**Expected Result:**
- Validation should FAIL with "Provided round miner count does not match base round"
- Transaction should be rejected
- All 7 miners remain in consensus

**Success Condition:**
Frank and Grace's public keys are absent from `State.Rounds[101].RealTimeMinersInformation.Keys` despite being present in `State.Rounds[100].RealTimeMinersInformation.Keys`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-24)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
```

**File:** protobuf/aedpos_contract.proto (L458-481)
```text
message NextRoundInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producers’ expecting time (second).
    int64 round_id_for_validation = 10;
    // The random number.
    bytes random_number = 11;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
