# Audit Report

## Title
Side Chain Disposal with Outstanding Debt Allows Indexing Fee Theft

## Summary
The `DisposeSideChain` function permits disposal of side chains in `IndexingFeeDebt` status without settling outstanding debts recorded in `ArrearsInfo`. When a chain with accumulated indexing fee debts is disposed, the `UnlockTokenAndResource` helper returns only the remaining balance to the chain proposer, causing indexers who performed legitimate work to permanently lose their rightful fees.

## Finding Description

The vulnerability exists in the disposal flow for side chains with outstanding indexing fee debts:

**Insufficient Status Validation:**
The `DisposeSideChain` function only checks that the chain status is not `Terminated`, allowing disposal of chains in `IndexingFeeDebt` status. [1](#0-0) 

**Debt Tracking Mechanism:**
When side chains exhaust their indexing fee balance during the `IndexSideChainBlockData` operation, the system transitions them to `IndexingFeeDebt` status and records unpaid amounts in the `ArrearsInfo` mapping. [2](#0-1) 

**Missing Debt Settlement:**
The `UnlockTokenAndResource` helper only returns the remaining deposit balance to the chain proposer without checking or settling debts recorded in `ArrearsInfo`. [3](#0-2) 

**Correct Debt Settlement Pattern:**
The `Recharge` function demonstrates the proper approach - when handling chains in `IndexingFeeDebt` status, it iterates through `ArrearsInfo` entries, transfers owed amounts to each creditor, and only then clears the debt records. [4](#0-3) 

**Status Definitions:**
The `SideChainStatus` enum defines `INDEXING_FEE_DEBT = 2` as a valid intermediate state between `ACTIVE` and `TERMINATED`. [5](#0-4) 

**Debt Storage:**
The `ArrearsInfo` field (a map of creditor addresses to amounts) stores indexing fee debt, which can be queried via the `GetSideChainIndexingFeeDebt` view function. [6](#0-5) 

## Impact Explanation

**Direct Financial Loss:**
- Indexers (miners who proposed side chain block data) permanently lose unpaid indexing fees recorded in `ArrearsInfo`
- Each indexing operation performed after balance depletion creates unpaid debt that becomes unrecoverable post-disposal
- The remaining deposit balance is incorrectly returned to the chain proposer instead of first settling creditor claims

**Economic Model Breakdown:**
- Violates the fundamental protocol guarantee that indexers receive compensation for cross-chain block indexing work
- Creates perverse incentives where chain proposers can deliberately underfund chains and dispose them to avoid accumulated debts
- Undermines trust in the cross-chain indexing payment system

**Protocol Integrity:**
- The `ArrearsInfo` debt tracking mechanism becomes meaningless if debts can be written off through disposal
- Contradicts the explicit debt settlement logic implemented in the `Recharge` function
- Loss amount equals the sum of all values in `ArrearsInfo` at disposal time, multiplied by the number of affected indexers

## Likelihood Explanation

**Natural Occurrence:**
This vulnerability triggers in common operational scenarios without requiring malicious intent:
1. A side chain is created with limited initial funding
2. The chain operates normally until the indexing fee balance depletes
3. Additional indexing operations occur, creating debt entries in `ArrearsInfo`
4. Governance legitimately decides to dispose the chain rather than recharge it

**Reachable Execution Path:**
- `DisposeSideChain` is callable through the side chain lifetime controller (typically Parliament governance)
- No special privileges beyond standard governance participation are required
- The existing test suite contains a test (`AdjustCrossChainIndexingFeePriceTest_IndexingFeeDebt_Dispose`) demonstrating that disposal of chains with adjusted pricing (which can lead to debt scenarios) is explicitly supported [7](#0-6) 

**Economic Feasibility:**
- Cost to create a side chain is minimal (just the initial locked amount)
- Standard Parliament governance proposal fees apply
- Net benefit to malicious proposer: avoid paying accumulated indexing fees exceeding initial deposit plus governance costs

**High Probability:**
The vulnerability is triggered whenever governance disposes an underfunded side chain - a legitimate operational decision that has unintended consequences of automatic debt forgiveness.

## Recommendation

Add validation in `DisposeSideChain` to prevent disposal of chains with outstanding debts, or implement debt settlement logic before disposal:

**Option 1 - Prevent Disposal with Debt:**
```csharp
public override Int32Value DisposeSideChain(Int32Value input)
{
    AssertSideChainLifetimeControllerAuthority(Context.Sender);
    
    var chainId = input.Value;
    var info = State.SideChainInfo[chainId];
    Assert(info != null, "Side chain not found.");
    Assert(info.SideChainStatus == SideChainStatus.Active, "Side chain must be in Active status to dispose.");
    
    // ... rest of disposal logic
}
```

**Option 2 - Settle Debts Before Disposal:**
```csharp
public override Int32Value DisposeSideChain(Int32Value input)
{
    AssertSideChainLifetimeControllerAuthority(Context.Sender);
    
    var chainId = input.Value;
    var info = State.SideChainInfo[chainId];
    Assert(info != null, "Side chain not found.");
    Assert(info.SideChainStatus != SideChainStatus.Terminated, "Incorrect chain status.");
    
    // Settle outstanding debts first
    if (info.SideChainStatus == SideChainStatus.IndexingFeeDebt)
    {
        var totalDebt = info.ArrearsInfo.Values.Sum();
        Assert(totalDebt == 0, "Cannot dispose side chain with outstanding indexing fee debt. Please recharge to settle debts first.");
    }
    
    // ... rest of disposal logic
}
```

## Proof of Concept

The following test demonstrates the vulnerability by creating a side chain with limited funds, causing it to enter debt status through indexing operations, and then successfully disposing it while debts remain unpaid:

```csharp
[Fact]
public async Task DisposeSideChain_WithOutstandingDebt_LosesIndexingFees()
{
    var parentChainId = 123;
    long lockedToken = 2;
    long indexingPrice = 1;
    long parentChainHeightOfCreation = 10;

    // Create side chain with limited funding
    var sideChainId = await InitAndCreateSideChainAsync(
        parentChainHeightOfCreation, parentChainId, lockedToken, indexingPrice);

    // Index blocks to deplete balance
    var fakeSideChainBlockHash = HashHelper.ComputeFrom("blockHash");
    var fakeTxMerkleTreeRoot = HashHelper.ComputeFrom("merkleRoot");
    
    var blockData1 = CreateSideChainBlockData(fakeSideChainBlockHash, 1, sideChainId, fakeTxMerkleTreeRoot);
    var blockData2 = CreateSideChainBlockData(fakeSideChainBlockHash, 2, sideChainId, fakeTxMerkleTreeRoot);
    await DoIndexAsync(new CrossChainBlockData { SideChainBlockDataList = { blockData1, blockData2 } }, new[] { sideChainId });

    // Index additional block to create debt
    var blockData3 = CreateSideChainBlockData(fakeSideChainBlockHash, 3, sideChainId, fakeTxMerkleTreeRoot);
    await DoIndexAsync(new CrossChainBlockData { SideChainBlockDataList = { blockData3 } }, new[] { sideChainId });

    // Verify debt exists
    var chainStatus = await GetSideChainStatusAsync(sideChainId);
    chainStatus.ShouldBe(SideChainStatus.IndexingFeeDebt);
    
    var debt = await CrossChainContractStub.GetSideChainIndexingFeeDebt.CallAsync(new Int32Value { Value = sideChainId });
    debt.Value.ShouldBeGreaterThan(0);

    // Dispose chain - this should fail but succeeds, losing indexer fees
    var disposalProposalId = await DisposeSideChainProposalAsync(new Int32Value { Value = sideChainId });
    await ApproveWithMinersAsync(disposalProposalId);
    var result = await ReleaseProposalAsync(disposalProposalId);
    
    // VULNERABILITY: Disposal succeeds despite outstanding debt
    result.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Indexers permanently lose their fees recorded in ArrearsInfo
}
```

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L174-215)
```csharp
    public override Empty Recharge(RechargeInput input)
    {
        var chainId = input.ChainId;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null && sideChainInfo.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");

        TransferFrom(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = input.Amount,
            Memo = "Indexing fee recharging."
        });

        long arrearsAmount = 0;
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
        }

        sideChainInfo.ArrearsInfo.Clear();
        sideChainInfo.SideChainStatus = SideChainStatus.Active;
        State.SideChainInfo[chainId] = sideChainInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L222-242)
```csharp
    public override Int32Value DisposeSideChain(Int32Value input)
    {
        AssertSideChainLifetimeControllerAuthority(Context.Sender);

        var chainId = input.Value;
        var info = State.SideChainInfo[chainId];
        Assert(info != null, "Side chain not found.");
        Assert(info.SideChainStatus != SideChainStatus.Terminated, "Incorrect chain status.");

        if (TryGetIndexingProposal(chainId, out _))
            ResetChainIndexingProposal(chainId);

        UnlockTokenAndResource(info);
        info.SideChainStatus = SideChainStatus.Terminated;
        State.SideChainInfo[chainId] = info;
        Context.Fire(new Disposed
        {
            ChainId = chainId
        });
        return new Int32Value { Value = chainId };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L73-86)
```csharp
    private void UnlockTokenAndResource(SideChainInfo sideChainInfo)
    {
        // unlock token
        var chainId = sideChainInfo.SideChainId;
        var balance = GetSideChainIndexingFeeDeposit(chainId);
        if (balance <= 0)
            return;
        TransferDepositToken(new TransferInput
        {
            To = sideChainInfo.Proposer,
            Amount = balance,
            Symbol = Context.Variables.NativeSymbol
        }, chainId);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L816-893)
```csharp
    private List<SideChainBlockData> IndexSideChainBlockData(IList<SideChainBlockData> sideChainBlockDataList,
        Address proposer, int chainId)
    {
        var indexedSideChainBlockData = new List<SideChainBlockData>();

        {
            var formattedProposerAddress = proposer.ToByteString().ToBase64();
            long indexingFeeAmount = 0;

            var sideChainInfo = State.SideChainInfo[chainId];
            var currentSideChainHeight = State.CurrentSideChainHeight[chainId];
            long arrearsAmount = 0;
            var lockedToken = sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt
                ? 0
                : GetSideChainIndexingFeeDeposit(chainId);

            foreach (var sideChainBlockData in sideChainBlockDataList)
            {
                var target = currentSideChainHeight != 0
                    ? currentSideChainHeight + 1
                    : AElfConstants.GenesisBlockHeight;
                var sideChainHeight = sideChainBlockData.Height;
                if (target != sideChainHeight)
                    break;

                // indexing fee
                var indexingPrice = sideChainInfo.IndexingPrice;

                lockedToken -= indexingPrice;

                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
                else
                {
                    indexingFeeAmount += indexingPrice;
                }

                currentSideChainHeight++;
                indexedSideChainBlockData.Add(sideChainBlockData);
            }

            if (indexingFeeAmount > 0)
                TransferDepositToken(new TransferInput
                {
                    To = proposer,
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = indexingFeeAmount,
                    Memo = "Index fee."
                }, chainId);

            if (arrearsAmount > 0)
            {
                if (sideChainInfo.ArrearsInfo.TryGetValue(formattedProposerAddress, out var amount))
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = amount + arrearsAmount;
                else
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = arrearsAmount;
            }

            State.SideChainInfo[chainId] = sideChainInfo;
            State.CurrentSideChainHeight[chainId] = currentSideChainHeight;
            
            Context.Fire(new SideChainIndexed
            {
                ChainId = chainId,
                IndexedHeight = currentSideChainHeight
            });
        }

        if (indexedSideChainBlockData.Count > 0)
            Context.LogDebug(() =>
                $"Last indexed height {indexedSideChainBlockData.Last().Height} for side chain {chainId}");

        return indexedSideChainBlockData;
    }
```

**File:** protobuf/cross_chain_contract.proto (L189-199)
```text
enum SideChainStatus
{
    // Currently no meaning.
    FATAL = 0;
    // The side chain is being indexed.
    ACTIVE = 1;
    // The side chain is in debt for indexing fee.
    INDEXING_FEE_DEBT = 2;
    // The side chain is disposed.
    TERMINATED = 3;
}
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L89-99)
```csharp
    public override Int64Value GetSideChainIndexingFeeDebt(Int32Value input)
    {
        var chainId = input.Value;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null, "Side chain not found.");

        return new Int64Value
        {
            Value = sideChainInfo.ArrearsInfo.Values.Sum()
        };
    }
```

**File:** test/AElf.Contracts.CrossChain.Tests/SideChainLifeTimeManagementTest.cs (L425-512)
```csharp
    public async Task AdjustCrossChainIndexingFeePriceTest_IndexingFeeDebt_Dispose()
    {
        await InitializeCrossChainContractAsync();
        long lockedTokenAmount = 10;
        await ApproveBalanceAsync(lockedTokenAmount);

        var proposalId = await CreateSideChainProposalAsync(1, lockedTokenAmount);
        await ApproveWithMinersAsync(proposalId);
        var releaseTx =
            await CrossChainContractStub.ReleaseSideChainCreation.SendAsync(new ReleaseSideChainCreationInput
                { ProposalId = proposalId });
        var organizationAddress = OrganizationCreated.Parser
            .ParseFrom(releaseTx.TransactionResult.Logs.First(l => l.Name.Contains(nameof(OrganizationCreated)))
                .NonIndexed).OrganizationAddress;
        organizationAddress.ShouldNotBeNull();

        var sideChainCreatedEvent = SideChainCreatedEvent.Parser
            .ParseFrom(releaseTx.TransactionResult.Logs.First(l => l.Name.Contains(nameof(SideChainCreatedEvent)))
                .NonIndexed);
        var sideChainId = sideChainCreatedEvent.ChainId;
        {
            var newIndexingFeePrice = 10;
            var indexingFeeAdjustProposalId = await CreateAssociationProposalAsync(
                nameof(CrossChainContractStub.AdjustIndexingFeePrice),
                organizationAddress, CrossChainContractAddress, new AdjustIndexingFeeInput
                {
                    IndexingFee = newIndexingFeePrice,
                    SideChainId = sideChainId
                });

            var parliamentOrganizationAddress =
                (await CrossChainContractStub.GetCrossChainIndexingController.CallAsync(new Empty())).OwnerAddress;
            var approveProposalId = await CreateParliamentProposalAsync(nameof(AssociationContractStub.Approve),
                parliamentOrganizationAddress, indexingFeeAdjustProposalId, AssociationContractAddress);
            await ApproveWithMinersAsync(approveProposalId);
            await ParliamentContractStub.Release.SendAsync(approveProposalId);
            await AssociationContractStub.Approve.SendAsync(indexingFeeAdjustProposalId);
            await AssociationContractStub.Release.SendAsync(indexingFeeAdjustProposalId);

            var indexingFeePriceCheck =
                await CrossChainContractStub.GetSideChainIndexingFeePrice.SendAsync(new Int32Value
                    { Value = sideChainId });
            indexingFeePriceCheck.Output.Value.ShouldBe(newIndexingFeePrice);

            var sideChainStatus = await GetSideChainStatusAsync(sideChainId);
            sideChainStatus.ShouldBe(SideChainStatus.Active);
        }

        {
            var newIndexingFeePrice = 11;
            var indexingFeeAdjustProposalId = await CreateAssociationProposalAsync(
                nameof(CrossChainContractStub.AdjustIndexingFeePrice),
                organizationAddress, CrossChainContractAddress, new AdjustIndexingFeeInput
                {
                    IndexingFee = newIndexingFeePrice,
                    SideChainId = sideChainId
                });

            var parliamentOrganizationAddress =
                (await CrossChainContractStub.GetCrossChainIndexingController.CallAsync(new Empty())).OwnerAddress;
            var approveProposalId = await CreateParliamentProposalAsync(nameof(AssociationContractStub.Approve),
                parliamentOrganizationAddress, indexingFeeAdjustProposalId, AssociationContractAddress);
            await ApproveWithMinersAsync(approveProposalId);
            await ParliamentContractStub.Release.SendAsync(approveProposalId);
            await AssociationContractStub.Approve.SendAsync(indexingFeeAdjustProposalId);
            await AssociationContractStub.Release.SendAsync(indexingFeeAdjustProposalId);

            (await CrossChainContractStub.GetSideChainIndexingFeePrice.CallWithExceptionAsync(new Int32Value
                { Value = sideChainId + 1 })).Value.ShouldContain("Side chain not found.");

            var indexingFeePriceCheck =
                await CrossChainContractStub.GetSideChainIndexingFeePrice.SendAsync(new Int32Value
                    { Value = sideChainId });
            indexingFeePriceCheck.Output.Value.ShouldBe(newIndexingFeePrice);

            var sideChainStatus = await GetSideChainStatusAsync(sideChainId);
            sideChainStatus.ShouldBe(SideChainStatus.Active);

            var disposalProposalId = await DisposeSideChainProposalAsync(new Int32Value
            {
                Value = sideChainId
            });
            await ApproveWithMinersAsync(disposalProposalId);
            var transactionResult = await ReleaseProposalAsync(disposalProposalId);
            var status = transactionResult.Status;
            status.ShouldBe(TransactionResultStatus.Mined);
        }
    }
```
