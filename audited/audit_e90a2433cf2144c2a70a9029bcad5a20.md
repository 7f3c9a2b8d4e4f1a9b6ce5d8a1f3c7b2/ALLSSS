### Title
Inconsistent Vote Counting Allows Governance Manipulation Through Strategic Member Removal

### Summary
The Association contract contains an inconsistency in vote counting logic where abstention, approval, and rejection counts filter by current membership, but the total vote threshold check counts all votes including those from removed members. This allows organizations to manipulate proposal outcomes by strategically removing members after they vote, bypassing abstention/rejection thresholds while still meeting the minimal vote threshold with votes from non-members.

### Finding Description

**Direct Answer:** At line 43-44, the abstention count does NOT include non-members who abstained before removal, as it explicitly filters by current membership. [1](#0-0) 

**Root Cause:** The vulnerability stems from inconsistent filtering logic across vote counting methods:

1. `IsProposalAbstained` filters abstentions by current membership [2](#0-1) 

2. `IsProposalRejected` filters rejections by current membership [3](#0-2) 

3. `CheckEnoughVoteAndApprovals` filters approvals by current membership [4](#0-3) 

4. BUT the same function counts ALL votes (approvals + rejections + abstentions) WITHOUT filtering for the MinimalVoteThreshold check [5](#0-4) 

The `IsReleaseThresholdReached` function calls all these checks in sequence. [6](#0-5) 

**Why Protections Fail:** The `RemoveMember` function allows the organization to remove members at any time, including after they have voted on active proposals. [7](#0-6)  There is no check preventing member removal while proposals are pending, and the vote counts in `ProposalInfo` are never updated when members are removed.

### Impact Explanation

**Governance Manipulation:** Organizations can strategically remove members after voting to manipulate whether proposals pass or fail:

- **Bypass Abstention Threshold:** Remove abstaining members to reduce the counted abstentions below `MaximalAbstentionThreshold`, while their votes still count toward `MinimalVoteThreshold`
- **Bypass Rejection Threshold:** Remove rejecting members to reduce counted rejections below `MaximalRejectionThreshold`, while maintaining total vote count
- **Artificial Vote Inflation:** Keep total vote count artificially high using removed members' votes to meet `MinimalVoteThreshold`

**Concrete Example:**
- Organization: 10 members, MinimalVoteThreshold=8, MinimalApprovalThreshold=6, MaximalAbstentionThreshold=2
- Proposal receives: 6 approvals, 4 abstentions
- Initially fails: abstentionMemberCount (4) > MaximalAbstentionThreshold (2)
- Remove 2 abstaining members via `RemoveMember`
- Now passes: abstentionMemberCount (2) ≤ 2, approvedMemberCount (6) ≥ 6, totalVotes (10) ≥ 8
- Proposal released with 6/8 current member approvals, using 2 non-member votes

**Severity:** HIGH - Violates fundamental governance invariant that only current organization members should participate in decision-making. Enables unauthorized proposal execution through membership manipulation.

### Likelihood Explanation

**Reachable Entry Point:** The attack uses public methods `Abstain`, `Approve`, `Reject` for voting, and `RemoveMember` for manipulation. [8](#0-7) [7](#0-6) 

**Feasible Preconditions:** Organizations must have control to call `RemoveMember` (organization can only modify itself via Context.Sender check). This is a standard organizational capability, not a privileged attack requirement.

**Execution Practicality:** 
1. Create proposal (standard operation)
2. Members vote (standard operation)
3. Organization calls `RemoveMember` via governance proposal (standard capability)
4. Proposer calls `Release` successfully (standard operation) [9](#0-8) 

**Attack Complexity:** LOW - Uses only standard contract functionality without requiring special timing, transaction ordering, or external dependencies.

**Detection:** Organizations can legitimately remove members for valid reasons, making malicious removal difficult to distinguish from benign operations. No contract-level detection mechanism exists.

### Recommendation

**Immediate Fix:** Apply consistent membership filtering to the total vote count check in `CheckEnoughVoteAndApprovals`:

```csharp
var isVoteThresholdReached =
    proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
    proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
    proposal.Rejections.Count(organization.OrganizationMemberList.Contains) >=
    organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

This ensures all vote threshold checks use the same membership filtering logic, counting only current members.

**Additional Protections:**
1. Consider preventing member removal while active proposals exist
2. Add validation in `Validate(organization)` to ensure removed members' votes are not counted
3. Add test cases covering member removal scenarios during active proposals

**Regression Prevention:** Add comprehensive test suite including:
- Test removing abstaining members and verifying abstention threshold calculation
- Test removing approving members and verifying approval threshold calculation  
- Test removing rejecting members and verifying rejection threshold calculation
- Test that MinimalVoteThreshold only counts current member votes

### Proof of Concept

**Initial State:**
- Organization created with 10 members (M1-M10)
- Thresholds: MinimalVoteThreshold=8, MinimalApprovalThreshold=6, MaximalAbstentionThreshold=2, MaximalRejectionThreshold=2

**Attack Steps:**
1. Proposer (M1) creates proposal
2. Members vote: M1-M6 approve (6 approvals), M7-M10 abstain (4 abstentions)
3. Check IsReleaseThresholdReached: 
   - abstentionMemberCount = 4 > 2 → IsProposalAbstained returns TRUE
   - IsReleaseThresholdReached returns FALSE (proposal blocked)
4. Organization executes RemoveMember(M9) and RemoveMember(M10) via governance
5. Check IsReleaseThresholdReached again:
   - abstentionMemberCount = 2 (only M7, M8 counted) ≤ 2 → IsProposalAbstained returns FALSE
   - approvedMemberCount = 6 ≥ 6 → approval sufficient
   - totalVotes = 10 (still includes M9, M10) ≥ 8 → vote threshold met
   - IsReleaseThresholdReached returns TRUE
6. Proposer calls Release successfully

**Expected Result:** Proposal should fail or only count 8 votes from current members (failing MinimalVoteThreshold)

**Actual Result:** Proposal passes using votes from 2 removed members to meet MinimalVoteThreshold while excluding their abstentions from MaximalAbstentionThreshold check

**Success Condition:** Proposal released despite only 8 current members and 2 of 10 votes coming from non-members, demonstrating successful governance manipulation.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-38)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-44)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L163-180)
```csharp
    public override Empty Abstain(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Abstentions.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Abstain),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
