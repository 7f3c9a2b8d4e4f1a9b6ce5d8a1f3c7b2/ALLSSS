# Audit Report

## Title
Vote Counting Inconsistency Allows Proposals to Pass with Insufficient Current Member Participation

## Summary
The `CheckEnoughVoteAndApprovals` function in the Association contract contains a critical inconsistency: it filters approvals by current organization membership when checking `MinimalApprovalThreshold`, but does not filter the total vote count when checking `MinimalVoteThreshold`. This allows proposals to be released with votes from removed members counting toward participation requirements, enabling governance decisions with significantly less current member engagement than intended.

## Finding Description

The vulnerability exists in the `CheckEnoughVoteAndApprovals` method where two different vote counting approaches are used. [1](#0-0) 

The approval count correctly filters to only include current organization members using `organization.OrganizationMemberList.Contains`.

However, the total vote threshold check does not apply any membership filtering: [2](#0-1) 

This counts ALL addresses in `proposal.Abstentions`, `proposal.Approvals`, and `proposal.Rejections` without verifying they are current members.

In contrast, other threshold checks in the same file correctly filter by membership: [3](#0-2) [4](#0-3) 

**Root Cause:** When members vote via `Approve`, `Reject`, or `Abstain` methods, membership is verified at voting time: [5](#0-4) 

However, if these members are subsequently removed from the organization via the `RemoveMember` function: [6](#0-5) 

Their addresses remain in the proposal's vote lists but are no longer in `organization.OrganizationMemberList`. At proposal release time, the inconsistent filtering causes their votes to count toward `MinimalVoteThreshold` but not toward specific approval/rejection/abstention thresholds.

The proposal release process invokes this flawed logic: [7](#0-6) 

## Impact Explanation

This vulnerability undermines the governance integrity of Association organizations by allowing proposals to pass with artificially inflated participation metrics:

**Concrete Scenario:**
- Organization with 10 current members
- Governance requires `MinimalVoteThreshold = 9` (90% participation) and `MinimalApprovalThreshold = 5` (50% approval)
- Attack sequence:
  1. Attacker creates malicious proposal P1
  2. Obtains 5 approvals from current members (satisfies `MinimalApprovalThreshold`)
  3. Obtains 4 additional votes (any type) from other members
  4. Creates and executes proposal P2 to remove those 4 voters
  5. Releases P1, which now passes with 9 total votes (including 4 removed members) despite only 5/10 (50%) current member participation

**Harm:**
- Governance decisions executed without the intended level of current member support
- `MinimalVoteThreshold` parameter becomes meaningless as it can be satisfied with non-member votes
- Organizations lose the ability to enforce minimum participation requirements
- Malicious proposals can pass with coordinated member removal timing

**Affected Parties:**
- All Association organizations relying on `MinimalVoteThreshold` for participation guarantees
- Organization members whose governance rights are diluted
- Systems trusting Association contract governance decisions

**Severity Justification:** Critical - This directly violates governance invariants and allows proposals to execute with insufficient democratic support, affecting all Association-based governance in the AElf ecosystem.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to influence enough current members to vote for a proposal (requires social engineering or legitimate support)
- Ability to create and execute a proposal to remove members (requires meeting the organization's governance thresholds)

**Attack Complexity:** Medium
The attack requires coordinated governance actions but uses only standard, legitimate contract methods:
1. Create malicious proposal P1
2. Obtain minimum required approvals from current members
3. Obtain additional votes from other members
4. Create proposal P2 to remove the additional voters
5. Execute P2 through normal governance process
6. Release P1, which now passes `MinimalVoteThreshold` with removed members' votes

**Feasibility Conditions:**
- Organizations must use `MinimalVoteThreshold` parameter (commonly used for participation requirements)
- Time gap between voting and proposal release allows for member removal (normal operation)
- Attacker needs sufficient influence to pass one removal proposal (feasible in compromised governance)

**Detection/Operational Constraints:**
- Member removal is a legitimate governance action and cannot be blocked
- The inconsistency is in core threshold logic, not easily detectable by users
- No events or checks warn about counting non-member votes

**Probability Reasoning:** High likelihood in adversarial scenarios where attackers have minority control or during governance disputes, as the attack requires only standard governance capabilities and exploits intended functionality without triggering any warnings or protections.

## Recommendation

Fix the inconsistency in `CheckEnoughVoteAndApprovals` by filtering the total vote count to only include current organization members, consistent with how other threshold checks operate:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter votes by current membership
    var currentMemberVoteCount = 
        proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
        proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
        proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
    
    var isVoteThresholdReached =
        currentMemberVoteCount >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

This ensures that only votes from current organization members are counted toward all threshold checks, maintaining the governance invariant that participation metrics reflect current membership.

## Proof of Concept

```csharp
[Fact]
public async Task VoteCountingInconsistency_RemovedMembersVotesStillCount()
{
    // Setup: Create organization with 10 members, requiring 90% participation (9 votes) and 50% approval (5 approvals)
    var minimalApprovalThreshold = 5;
    var minimalVoteThreshold = 9;
    var organizationAddress = await CreateOrganizationAsync(
        minimalApprovalThreshold, 
        minimalVoteThreshold,
        maximalAbstentionThreshold: 10,
        maximalRejectionThreshold: 10,
        Reviewer1
    );
    
    // Ensure organization has 10 members (Reviewer1, Reviewer2, Reviewer3 by default, need to add 7 more)
    // ... (add 7 more members to the organization) ...
    
    // Step 1: Create a proposal
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
    
    // Step 2: Get 5 approvals from current members
    await GetAssociationContractTester(Reviewer1KeyPair).Approve.SendAsync(proposalId);
    await GetAssociationContractTester(Reviewer2KeyPair).Approve.SendAsync(proposalId);
    // ... (get 3 more approvals) ...
    
    // Step 3: Get 4 additional votes from other members who will be removed
    var member6 = Accounts[5].Address;
    var member7 = Accounts[6].Address;
    var member8 = Accounts[7].Address;
    var member9 = Accounts[8].Address;
    
    await GetAssociationContractTester(Accounts[5].KeyPair).Abstain.SendAsync(proposalId);
    await GetAssociationContractTester(Accounts[6].KeyPair).Abstain.SendAsync(proposalId);
    await GetAssociationContractTester(Accounts[7].KeyPair).Abstain.SendAsync(proposalId);
    await GetAssociationContractTester(Accounts[8].KeyPair).Abstain.SendAsync(proposalId);
    
    // Step 4: Remove those 4 members via governance
    // Create and execute removal proposals for members 6-9
    // ... (remove member6, member7, member8, member9) ...
    
    // Step 5: Verify the proposal can be released despite only 5/10 current members voting
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    
    // Bug: ToBeReleased should be false (only 5 current members voted, need 9)
    // But it's true because removed members' votes still count
    proposal.ToBeReleased.ShouldBeTrue(); // This demonstrates the vulnerability
    
    // The proposal can be released even though only 5/10 current members participated
    var releaseResult = await GetAssociationContractTester(Reviewer1KeyPair).Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

This test demonstrates that a proposal requiring 9 votes (90% of 10 members) can pass with only 5 current member votes when 4 additional voters are removed after voting.

## Notes

The vulnerability is particularly insidious because:

1. **No obvious exploit signature:** Member removal is a legitimate governance operation, making the attack hard to distinguish from normal activity

2. **Affects all Association organizations:** Any organization using `MinimalVoteThreshold` for participation requirements is vulnerable

3. **Inconsistent with other checks:** The same file correctly filters votes by membership for rejection and abstention thresholds, making this an implementation inconsistency rather than an intentional design choice

4. **Time-based attack window:** The gap between voting and proposal release creates a natural window for member manipulation

The fix should maintain consistency across all threshold checks by ensuring votes from removed members are never counted toward any governance metrics at proposal release time.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-38)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-44)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L128-130)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-188)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
