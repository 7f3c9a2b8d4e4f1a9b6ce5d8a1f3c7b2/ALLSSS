### Title
VotersCount Accounting Error Due to Asymmetric Increment/Decrement Logic in Multiple-Vote Withdrawal Scenarios

### Summary
The Vote contract's `VotersCount` field suffers from an accounting bug where it increments by 1 for every vote cast but only decrements by 1 when a voter withdraws their last vote. This causes permanent inflation of `VotersCount` when voters cast multiple votes and withdraw them. `GetVotingResult()` returns this inconsistent count without validation, misrepresenting the actual number of active voters.

### Finding Description
The vulnerability exists in the asymmetric accounting logic between vote creation and withdrawal:

**Increment Logic** [1](#0-0) 
When `UpdateVotingResult()` is called during voting, it unconditionally increments `VotersCount` by 1 for every vote cast, even if the same voter is casting multiple votes.

**Decrement Logic** [2](#0-1) 
When `Withdraw()` is called, it only decrements `VotersCount` by 1 if the voter has no remaining active votes after the withdrawal. If the voter still has other active votes, `VotersCount` remains unchanged.

**No Validation on Read** [3](#0-2) 
`GetVotingResult()` directly returns the stored `VotingResult` without detecting or validating this mismatch.

**Root Cause**: The contract treats `VotersCount` as a count of vote operations rather than unique voters, but the withdrawal logic attempts to track unique voters. This mismatch creates permanent inflation.

**Execution Path**:
1. Voter A calls `Vote()` → `VotersCount` = 1
2. Voter A calls `Vote()` again → `VotersCount` = 2
3. Voter A calls `Withdraw()` on first vote → `VotersCount` stays 2 (has remaining active vote)
4. Voter A calls `Withdraw()` on second vote → `VotersCount` = 1 (decremented once)
5. Result: `VotersCount` = 1 but actual active voters = 0

The test case confirms this behavior is systemic [4](#0-3) , where two votes from the same user result in `VotersCount` = 2, not 1.

### Impact Explanation
**Operational Impact - Data Integrity**:
- `VotersCount` permanently misrepresents voting participation metrics after any voter casts multiple votes and withdraws them
- The protobuf definition describes `voters_count` as "The total number of voters" [5](#0-4) , but the implementation fails to track this accurately
- Any governance system, UI dashboard, or analytics tool relying on this count receives inflated data
- The magnitude of inflation equals the number of "extra" votes cast by voters who later fully withdraw (e.g., if 100 voters each cast 2 votes then withdraw both, `VotersCount` inflates by 100)
- Affects all voting items across the system, including those used by the Election contract for consensus participation tracking

**Severity Justification**: Medium - While this doesn't directly steal funds or break critical invariants, it corrupts a fundamental voting metric that could influence governance decisions and participation tracking. The bug is deterministic and affects every voting item where voters cast multiple votes.

### Likelihood Explanation
**High Likelihood**:
- **Reachable Entry Point**: Any user can call the public `Vote()` and `Withdraw()` methods [6](#0-5)  and [7](#0-6) 
- **Feasible Preconditions**: Requires only that a voting item exists and allows multiple votes per voter (standard behavior)
- **Execution Practicality**: Normal voting operations with no special permissions or complex state setup
- **Economic Rationality**: No cost beyond normal voting gas fees; happens as side effect of legitimate voting behavior
- **Detection**: The bug manifests automatically whenever any voter follows the pattern: vote multiple times → withdraw all votes

The flaw is not malicious exploitation but rather inevitable occurrence through normal multi-vote usage patterns. Even without adversarial intent, the accounting error accumulates over the lifetime of voting items.

### Recommendation
**Code-Level Mitigation**:
1. Modify `UpdateVotingResult()` to track unique voters rather than vote operations:
   - Before incrementing `VotersCount`, check if this is the voter's first active vote for this voting item
   - Only increment if `votedItems.VotedItemVoteIds[votingItemIndex].ActiveVotes.Count == 0` before adding the new vote

2. Modify `Withdraw()` decrement logic to be symmetric:
   - Change the condition to decrement when removing the voter's last active vote (current behavior is correct but only works if increment is also fixed)

3. Add validation to `GetVotingResult()`:
   - Optionally compute actual unique voter count from `VotedItems` state and compare with stored `VotersCount`
   - Log warnings or assert on mismatches during critical queries

**Invariant Check**:
```
For any VotingResult at any time:
VotersCount == number of unique addresses with ActiveVotes.Count > 0 for that VotingItemId
```

**Test Cases**:
- Test: Single voter casts 2 votes then withdraws both → verify `VotersCount` returns to 0
- Test: 3 voters each cast 2 votes, 1 voter withdraws both → verify `VotersCount` = 2
- Test: Voter casts 5 votes, withdraws 3 → verify `VotersCount` unchanged (voter still active)

### Proof of Concept
**Initial State**:
- Voting item registered with ID `votingItemId`, accepting token `ELF`, snapshot 1 active
- User A has sufficient ELF balance

**Transaction Steps**:
1. User A calls `Vote(votingItemId, option="A", amount=100)` → TX1 succeeds
   - Query `GetVotingResult()`: `VotersCount` = 1 ✓

2. User A calls `Vote(votingItemId, option="A", amount=100)` → TX2 succeeds  
   - Query `GetVotingResult()`: `VotersCount` = 2 ✓

3. User A calls `Withdraw(voteId=TX1)` → TX3 succeeds
   - User A still has 1 active vote (TX2)
   - Query `GetVotingResult()`: `VotersCount` = 2 (unchanged) ✓

4. User A calls `Withdraw(voteId=TX2)` → TX4 succeeds
   - User A now has 0 active votes
   - Query `GetVotingResult()`: `VotersCount` = 1 ✗

**Expected Result**: `VotersCount` = 0 (no active voters)  
**Actual Result**: `VotersCount` = 1 (inflated by 1)

**Success Condition**: After all withdrawals, `VotersCount` should equal the number of addresses with active votes (0), but instead returns inflated count (1), confirming the bug.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L90-143)
```csharp
    public override Empty Vote(VoteInput input)
    {
        var votingItem = AssertValidVoteInput(input);
        var amount = 0L;
        if (!votingItem.IsQuadratic)
        {
            amount = input.Amount;
        }
        else
        {
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }

        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;

        UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
        UpdateVotedItems(input.VoteId, votingRecord.Voter, votingItem);

        if (votingItem.IsLockToken)
            // Lock voted token.
            State.TokenContract.Lock.Send(new LockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                LockId = input.VoteId,
                Amount = amount
            });

        Context.Fire(new Voted
        {
            VoteId = input.VoteId,
            VotingItemId = votingRecord.VotingItemId,
            Voter = votingRecord.Voter,
            Amount = votingRecord.Amount,
            Option = votingRecord.Option,
            SnapshotNumber = votingRecord.SnapshotNumber,
            VoteTimestamp = votingRecord.VoteTimestamp
        });

        return new Empty();
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L178-178)
```csharp
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L191-239)
```csharp
    public override Empty Withdraw(WithdrawInput input)
    {
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;

        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;

        if (votingItem.IsLockToken)
            State.TokenContract.Unlock.Send(new UnlockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                Amount = votingRecord.Amount,
                LockId = input.VoteId
            });

        Context.Fire(new Withdrawn
        {
            VoteId = input.VoteId
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L41-41)
```csharp
        return State.VotingResults[votingResultHash];
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L613-622)
```csharp
        await Vote(voteUser1, votingItem.VotingItemId, votingItem.Options.First(), 100L);
        await Vote(voteUser1, votingItem.VotingItemId, votingItem.Options.First(), 200L);
        var votingResult = await GetLatestVotingResult(votingItem.VotingItemId);
        votingResult.VotersCount.ShouldBe(2);
        votingResult.VotesAmount.ShouldBe(300L);

        await Vote(voteUser2, votingItem.VotingItemId, votingItem.Options.Last(), 100L);
        await Vote(voteUser2, votingItem.VotingItemId, votingItem.Options.Last(), 200L);
        votingResult = await GetLatestVotingResult(votingItem.VotingItemId);
        votingResult.VotersCount.ShouldBe(4);
```

**File:** protobuf/vote_contract.proto (L169-170)
```text
    // The total number of voters.
    int64 voters_count = 4;
```
