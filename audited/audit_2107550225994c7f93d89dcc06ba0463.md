### Title
Minter List State Pollution via Reference Mutation in GetMinterList

### Summary
The private `GetMinterList(TokenInfo tokenInfo)` function mutates the cached state object in-place by automatically adding the issuer to the minter list, causing unintended persistent state changes. [1](#0-0)  This bypasses the `RemoveMinters` access control mechanism, as the issuer is automatically re-added to the persistent minter list on every mint operation.

### Finding Description
The `GetMinterList` function retrieves the minter list from `State.MinterListMap` and modifies it by adding the issuer if not present. [1](#0-0) 

Due to AElf's `MappedState` implementation, accessing state returns a reference to the cached protobuf object, not a copy. [2](#0-1)  When this cached object is modified in-place, the changes are detected during transaction finalization by comparing the modified object against the original deserialized instance, and the modifications are persisted to state. [3](#0-2) 

The function is called during `PerformMint`, which is invoked by both `Mint` and `Assemble` operations. [4](#0-3)  The correct pattern in this codebase is to use `.Clone()` when reading from state to prevent unintended mutations, as demonstrated in other functions like `Disassemble` and `Recast`. [5](#0-4) [6](#0-5) [7](#0-6) 

Additionally, the returned reference can be further mutated by callers within the contract execution context, though current usage only performs read operations.

### Impact Explanation
This vulnerability creates an **access control bypass** where the NFT protocol creator cannot permanently revoke the issuer's minting permission:

1. Creator calls `RemoveMinters` to remove the issuer from authorized minters. [8](#0-7) 
2. Any subsequent mint operation automatically re-adds the issuer to the persistent minter list via `GetMinterList`.
3. The issuer regains permanent minting permission, defeating the intended access control.

The impact is limited to minting permission management - no direct fund theft or supply manipulation beyond normal minting constraints occurs. However, it violates the expected behavior of the `RemoveMinters` function and prevents proper access control enforcement. The severity is LOW because the issuer is typically a trusted party (the creator) established during protocol creation. [9](#0-8) 

### Likelihood Explanation
This vulnerability triggers **automatically** on every mint operation with 100% likelihood:

- **Entry points**: Public `Mint` and `Assemble` functions are accessible to authorized minters. [10](#0-9) [11](#0-10) 
- **Preconditions**: Only requires that a minter list exists in state (initialized during protocol creation).
- **Complexity**: No attacker action needed - the bug manifests through normal contract operation.
- **Detection**: Difficult to detect as it appears as normal state updates without error events.

The behavior is deterministic and occurs on every mint transaction after an attempt to remove the issuer from the minter list.

### Recommendation

**Immediate Fix**: Clone the minter list before modification to prevent state pollution:

```csharp
private MinterList GetMinterList(TokenInfo tokenInfo)
{
    var storedList = State.MinterListMap[tokenInfo.Symbol];
    var minterList = storedList?.Clone() ?? new MinterList();
    if (!minterList.Value.Contains(tokenInfo.Issuer)) 
        minterList.Value.Add(tokenInfo.Issuer);
    return minterList;
}
```

**Alternative Solution**: If the intent is to ensure the issuer always appears in the returned list for authorization checks without persisting this change, the current logic should be preserved but callers should be prevented from modifying the returned object, or the check should be performed differently.

**Test Case**: Add a test that verifies:
1. Create NFT protocol with issuer A
2. Remove issuer A via `RemoveMinters`
3. Perform a mint operation by another authorized minter
4. Verify issuer A remains removed from the stored minter list

### Proof of Concept

**Initial State:**
- NFT protocol "TEST-1" created with creator/issuer = Address A
- Minter list initialized with Address A [9](#0-8) 

**Transaction Sequence:**
1. Creator calls `RemoveMinters` with Address A to revoke issuer's minting permission [8](#0-7) 
2. Expected: `State.MinterListMap["TEST-1"]` no longer contains Address A
3. Any authorized minter calls `Mint` for "TEST-1" 
4. `PerformMint` calls `GetMinterList(tokenInfo)` where `tokenInfo.Issuer = Address A` [4](#0-3) 
5. Function retrieves cached minter list, adds Address A back to it, returns reference
6. Modified cached object is persisted at transaction end

**Actual Result:** `State.MinterListMap["TEST-1"]` now contains Address A again

**Expected Result:** Address A should remain absent from the minter list after removal

**Success Condition:** Call `GetMinterList` view function and verify Address A is present in the stored list despite explicit removal.

### Notes

The public view function `GetMinterList(StringValue)` does not have this issue for external callers, as view function calls execute in read-only contexts and return serialized copies. [12](#0-11)  However, the private function's behavior affects internal contract state across all operations.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L12-19)
```csharp
    public override Hash Mint(MintInput input)
    {
        if (input.Metadata != null && input.Metadata.Value.Any())
            AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var nftMinted = PerformMint(input);
        return nftMinted.TokenHash;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L113-189)
```csharp
    public override Hash Assemble(AssembleInput input)
    {
        if (input.Metadata != null && input.Metadata.Value.Any())
            AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var metadata = input.Metadata ?? new Metadata();

        if (input.AssembledNfts.Value.Any())
        {
            metadata.Value[AssembledNftsKey] = input.AssembledNfts.ToString();
            // Check owner.
            foreach (var pair in input.AssembledNfts.Value)
            {
                var nftHash = Hash.LoadFromHex(pair.Key);
                var nftInfo = GetNFTInfoByTokenHash(nftHash);
                Assert(State.BalanceMap[nftHash][Context.Sender] >= pair.Value,
                    $"Insufficient balance of {nftInfo.Symbol}{nftInfo.TokenId}.");
                DoTransfer(nftHash, Context.Sender, Context.Self, pair.Value);
            }
        }

        if (input.AssembledFts.Value.Any())
        {
            metadata.Value[AssembledFtsKey] = input.AssembledFts.ToString();
            // Check balance and allowance.
            foreach (var pair in input.AssembledFts.Value)
            {
                var symbol = pair.Key;
                var amount = pair.Value;
                var balance = State.TokenContract.GetBalance.Call(new MultiToken.GetBalanceInput
                {
                    Owner = Context.Sender,
                    Symbol = symbol
                }).Balance;
                Assert(balance >= amount, $"Insufficient balance of {symbol}");
                var allowance = State.TokenContract.GetAllowance.Call(new MultiToken.GetAllowanceInput
                {
                    Owner = Context.Sender,
                    Spender = Context.Self,
                    Symbol = symbol
                }).Allowance;
                Assert(allowance >= amount, $"Insufficient allowance of {symbol}");
                State.TokenContract.TransferFrom.Send(new MultiToken.TransferFromInput
                {
                    From = Context.Sender,
                    To = Context.Self,
                    Symbol = symbol,
                    Amount = amount
                });
            }
        }

        var mingInput = new MintInput
        {
            Symbol = input.Symbol,
            Alias = input.Alias,
            Owner = input.Owner,
            Uri = input.Uri,
            Metadata = metadata,
            TokenId = input.TokenId
        };

        var nftMinted = PerformMint(mingInput, true);
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;

        if (input.AssembledFts.Value.Any()) State.AssembledFtsMap[nftMinted.TokenHash] = input.AssembledFts;

        Context.Fire(new Assembled
        {
            Symbol = input.Symbol,
            TokenId = nftMinted.TokenId,
            AssembledNfts = input.AssembledNfts,
            AssembledFts = input.AssembledFts
        });

        return nftMinted.TokenHash;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L203-203)
```csharp
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L212-212)
```csharp
        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L268-268)
```csharp
        var oldMetadata = nftInfo.Metadata.Clone();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L355-373)
```csharp
    public override Empty RemoveMinters(RemoveMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol];

        foreach (var minter in input.MinterList.Value)
            if (minterList.Value.Contains(minter))
                minterList.Value.Remove(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListRemoved
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L375-381)
```csharp
    private MinterList GetMinterList(TokenInfo tokenInfo)
    {
        var minterList = State.MinterListMap[tokenInfo.Symbol] ?? new MinterList();
        if (!minterList.Value.Contains(tokenInfo.Issuer)) minterList.Value.Add(tokenInfo.Issuer);

        return minterList;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L398-399)
```csharp
        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L26-37)
```csharp
    public TEntity this[TKey key]
    {
        get
        {
            if (!Cache.TryGetValue(key, out var valuePair))
            {
                valuePair = LoadKey(key);
                Cache[key] = valuePair;
            }

            return valuePair.IsDeleted ? SerializationHelper.Deserialize<TEntity>(null) : valuePair.Value;
        }
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L78-93)
```csharp
    internal override TransactionExecutingStateSet GetChanges()
    {
        var stateSet = new TransactionExecutingStateSet();
        foreach (var kv in Cache)
        {
            var key = GetSubStatePath(kv.Key.ToString()).ToStateKey(Context.Self);
            if (kv.Value.IsDeleted)
                stateSet.Deletes[key] = true;
            else if (!Equals(kv.Value.OriginalValue, kv.Value.Value))
                stateSet.Writes[key] = ByteString.CopyFrom(SerializationHelper.Serialize(kv.Value.Value));

            stateSet.Reads[key] = true;
        }

        return stateSet;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L36-38)
```csharp
        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L77-80)
```csharp
    public override MinterList GetMinterList(StringValue input)
    {
        return State.MinterListMap[input.Value];
    }
```
