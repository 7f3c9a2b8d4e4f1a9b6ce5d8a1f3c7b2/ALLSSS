### Title
Referendum Organization Self-Modification Deadlock via Unreachable Thresholds and Inaccessible Whitelists

### Summary
The Referendum contract allows organizations to modify their own voting thresholds and proposer whitelists through proposals. However, the validation logic does not verify that thresholds are achievable relative to token supply or that whitelist addresses are accessible. Once an organization sets impossible-to-meet thresholds or a whitelist containing only inaccessible addresses, it permanently loses the ability to pass any corrective proposals, resulting in an unrecoverable deadlock state.

### Finding Description

The vulnerability exists in two functions that modify organization parameters: [1](#0-0) [2](#0-1) 

These functions can only be called with `Context.Sender` equal to the organization address, which occurs when a proposal is released via the virtual address mechanism: [3](#0-2) 

The root cause is that the `Validate` function performs insufficient checks on organization parameters: [4](#0-3) 

This validation only ensures:
- Proposer whitelist is not empty (count > 0)
- `MinimalApprovalThreshold <= MinimalVoteThreshold`
- `MinimalApprovalThreshold > 0`
- Thresholds are non-negative

**Critical Missing Validations:**

1. **No Token Supply Feasibility Check**: The validation does not verify that `MinimalVoteThreshold` or `MinimalApprovalThreshold` are achievable given the token's total or circulating supply. An organization could set `MinimalVoteThreshold = 10^18` for a token with only 10^6 total supply.

2. **No Whitelist Accessibility Check**: The validation only checks that the whitelist is non-empty, not whether any addresses in it are accessible (i.e., have known private keys, are not burn addresses, or belong to cooperative parties). Proposals can only be created by whitelisted addresses: [5](#0-4) 

3. **No Recovery Mechanism**: There is no admin override, emergency function, or time-based reset that could fix a deadlocked organization. Once the deadlock occurs, it is permanent.

**Execution Path:**
1. Whitelisted proposer creates a proposal calling `ChangeOrganizationThreshold` with unreachable thresholds
2. Proposal gets approved under current (valid) thresholds
3. Proposal is released, executing with organization address as sender
4. New thresholds are set and pass validation (despite being unreachable)
5. All future proposals now require impossible vote counts to pass
6. No corrective proposal can ever be approved
7. Organization is permanently deadlocked

### Impact Explanation

**Governance DoS - Permanent Organization Lockout:**
- The affected organization loses all governance capabilities permanently
- No proposals can ever be released again, including critical operational or emergency actions
- Any funds, permissions, or authority controlled by the organization become permanently inaccessible

**Affected Parties:**
- Token holders who participated in the organization's governance
- Contracts or systems that depend on the organization for configuration updates
- Users of services managed by the organization

**Severity Justification - High:**
- **Irreversible**: No recovery path exists once deadlock occurs
- **Complete Loss of Function**: Organization becomes entirely non-functional
- **Broad Impact**: Affects all stakeholders of the organization
- **Exploitable via Misconfiguration**: Can occur accidentally through operational errors, not just malicious attacks

**Quantified Impact:**
- 100% loss of governance capability for the affected organization
- Permanent freeze of any assets or permissions controlled by the organization
- Potential cascade effects if the organization manages critical system parameters

### Likelihood Explanation

**Attacker Capabilities Required:**
1. **Initial Whitelist Access**: Attacker must be in the organization's proposer whitelist, OR
2. **Social Engineering**: Convince legitimate proposers to create the malicious proposal, OR  
3. **Accidental Misconfiguration**: Legitimate operator makes an error when setting thresholds

**Attack Complexity - Medium:**
- Attack requires one successful proposal to pass
- Must convince enough token holders to approve the malicious proposal initially
- However, once the organization's threshold/whitelist is corrupted, the deadlock is automatic

**Feasibility Conditions:**
- Organization must have sufficient initial token holder participation to pass the malicious proposal
- No external monitoring or validation of threshold reasonableness
- Token holders may not recognize unrealistic thresholds in proposal parameters

**Probability Assessment - Medium to High:**
- **Malicious Scenario**: Requires attacker whitelist access + proposal approval (Medium difficulty)
- **Accidental Scenario**: Legitimate operators could easily mistype threshold values (e.g., adding extra zeros) (High probability)
- **Mixed Scenario**: Disgruntled organization member could exploit during chaotic periods (Medium probability)

The combination of permanent impact and realistic occurrence scenarios (especially accidental misconfiguration) makes this a significant vulnerability.

### Recommendation

**1. Add Token Supply Feasibility Checks:**

Modify the `Validate` function to verify thresholds against token supply:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
        
    var tokenInfo = GetTokenInfo(organization.TokenSymbol);
    Assert(!string.IsNullOrEmpty(tokenInfo.Symbol), "Token not exists.");

    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    
    // NEW: Check thresholds are achievable relative to token supply
    Assert(proposalReleaseThreshold.MinimalVoteThreshold <= tokenInfo.Supply, 
        "MinimalVoteThreshold exceeds token supply.");
    Assert(proposalReleaseThreshold.MinimalApprovalThreshold <= tokenInfo.Supply,
        "MinimalApprovalThreshold exceeds token supply.");
    
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

**2. Add Reasonable Upper Bounds:**

Consider adding configurable maximum thresholds (e.g., 80% of token supply) to prevent setting thresholds that are technically possible but practically unreachable.

**3. Add Whitelist Sanity Checks:**

Implement validation that checks whitelist addresses are not known burn addresses or system contracts that cannot create proposals.

**4. Add Emergency Recovery Mechanism:**

Consider adding a time-locked emergency override controlled by a separate authority (e.g., Parliament) that can reset an organization's parameters if no proposals have been executed for an extended period (e.g., 90 days).

**5. Add Pre-Change Warnings:**

Emit detailed warning events when threshold changes are proposed, including calculations showing the percentage of token supply required.

**Test Cases to Add:**
- Test creating organization with thresholds exceeding token supply (should fail)
- Test changing thresholds to exceed token supply via proposal (should fail)
- Test changing whitelist to empty list (should fail - already handled)
- Test recovery mechanism if implemented

### Proof of Concept

**Initial State:**
- Organization exists with valid configuration:
  - Token: "ELF" with total supply of 1,000,000 tokens
  - MinimalVoteThreshold: 50,000 (5% of supply, achievable)
  - MinimalApprovalThreshold: 30,000 (3% of supply, achievable)
  - ProposerWhiteList: [Alice, Bob, Charlie]

**Attack Sequence:**

**Step 1**: Malicious proposer (Alice) creates proposal to change threshold
```
CreateProposal({
  contract_method_name: "ChangeOrganizationThreshold",
  to_address: ReferendumContractAddress,
  params: ProposalReleaseThreshold {
    minimal_vote_threshold: 10,000,000,000 (10 billion - impossible!)
    minimal_approval_threshold: 10,000,000,000
    maximal_rejection_threshold: 0
    maximal_abstention_threshold: 0
  },
  organization_address: OrganizationAddress,
  expired_time: +7 days
})
```

**Step 2**: Malicious proposal gets approved under current valid thresholds
- Token holders approve with 35,000 tokens (meets current 30,000 requirement)
- Proposal becomes releasable

**Step 3**: Release malicious proposal
```
Release(proposalId)
```
- Executes via virtual address with Context.Sender = OrganizationAddress
- New thresholds are set: MinimalVoteThreshold = 10,000,000,000
- Validation passes (only checks mathematical relationships, not feasibility)

**Step 4**: Attempt corrective proposal
```
CreateProposal({
  contract_method_name: "ChangeOrganizationThreshold",
  to_address: ReferendumContractAddress,  
  params: <valid thresholds>,
  organization_address: OrganizationAddress
})
```

**Step 5**: Try to approve corrective proposal
- Token holders approve with maximum possible: 1,000,000 tokens (entire supply)
- Check if releasable: NO
- Reason: IsReleaseThresholdReached returns false because:
  - approval_count (1,000,000) < minimal_approval_threshold (10,000,000,000)
  - Proposal can NEVER be released

**Expected Result**: Corrective proposal approved and released, organization fixed

**Actual Result**: Organization permanently deadlocked - no proposal can ever meet the 10 billion token requirement when only 1 million tokens exist

**Success Condition for Attack**: Organization can no longer execute ANY proposals, verified by:
- GetProposal().to_be_released = false for all proposals regardless of approval count
- Organization governance completely frozen

### Notes

This vulnerability also affects the Association and Parliament contracts which have similar `ChangeOrganizationThreshold` implementations. The same validation gaps exist across all three governance contract types in the AElf system.

The issue is particularly dangerous because it can occur through honest operational mistakes (typos, unit confusion) rather than requiring malicious intent, yet the consequences are equally severe and permanent.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-137)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```
