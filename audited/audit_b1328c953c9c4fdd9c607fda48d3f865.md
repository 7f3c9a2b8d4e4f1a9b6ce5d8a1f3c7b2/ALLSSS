# Audit Report

## Title
Unauthorized Round Termination Due to Missing Extra Block Producer Authorization Check

## Summary
The AEDPoS consensus contract fails to validate that only the designated extra block producer can terminate rounds. Any miner who has already mined a block can prematurely trigger NextRound/NextTerm behaviors after their time slot expires, bypassing the intended extra block producer mechanism and violating consensus schedule integrity.

## Finding Description

The vulnerability exists across the consensus command generation and validation pipeline where authorization to terminate rounds is never verified.

**Flawed Behavior Assignment:** The behavior provider grants round-terminating behaviors to any miner whose `OutValue` is not null and whose time slot has passed, without checking if they are the designated extra block producer. [1](#0-0) 

When line 82 executes, it returns `GetConsensusBehaviourToTerminateCurrentRound()` which yields NextRound or NextTerm behavior. [2](#0-1) 

**Insufficient Entry Point Validation:** The public `GetConsensusCommand` method only verifies miner list membership via `IsInMinerList`, not extra block producer authorization. [3](#0-2) 

The `IsInMinerList` method merely checks dictionary key existence. [4](#0-3) 

**Missing Validation in Pipeline:** None of the validation providers enforce extra block producer authorization:

- `MiningPermissionValidationProvider` only validates miner list membership. [5](#0-4) 

- `RoundTerminateValidationProvider` only checks round/term number correctness. [6](#0-5) 

- The validation orchestrator adds these providers for NextRound/NextTerm but never includes extra block producer checks. [7](#0-6) 

**Execution Permission Check Insufficient:** The `PreCheck` method during transaction execution only validates miner list membership, not extra block producer status. [8](#0-7) 

**Design Intent Violated:** The codebase explicitly documents that only the extra block producer should terminate rounds. [9](#0-8) 

Each round designates one miner with `IsExtraBlockProducer = true`. [10](#0-9) 

The `IsCurrentMiner` method correctly validates extra block producer authorization for the extra block time slot. [11](#0-10) 

However, this validation method is never invoked in the consensus command generation or block validation pipeline.

## Impact Explanation

**Consensus Protocol Integrity Violation:** This vulnerability breaks the fundamental AEDPoS consensus invariant that rounds must be terminated only by designated extra block producers. Miners can manipulate the consensus schedule by prematurely ending rounds, preventing later-scheduled miners from producing blocks.

**Quantified Economic Impact:** In a round with N miners where the attacker is at position K < N:
- (N - K) miners lose their block production opportunity
- These miners receive zero mining rewards for that round
- The attacker monopolizes the right to determine round transitions
- Block rewards are unfairly redistributed to earlier-positioned miners

**Affected Parties:**
- **Legitimate miners:** Direct economic loss from missed block rewards
- **Extra block producer:** Role is completely bypassed, intended privileges nullified
- **Network:** Consensus schedule predictability is destroyed
- **Protocol integrity:** Core design assumption violated

**Severity Assessment: Medium** because:
- Requires attacker to be an elected miner (high privilege, but achievable)
- Direct economic impact on other miners' rewards
- Violates critical consensus invariant
- Does not enable direct treasury theft but manipulates reward distribution
- Damages long-term protocol fairness and predictability

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be in current miner list (achievable via election/staking)
- Must have produced at least one block in the current round (normal mining operation)
- No additional vulnerabilities or special privileges needed

**Attack Complexity: Low**
- Single call to `GetConsensusCommand` after attacker's time slot expires
- No race conditions required
- No timing attacks needed
- Deterministic success given preconditions

**Execution Steps:**
1. Attacker mines their normal block during assigned time slot (sets `OutValue`)
2. Attacker waits until their time slot expires (`IsTimeSlotPassed` becomes true)
3. Attacker requests consensus command via `GetConsensusCommand`
4. Behavior provider returns NextRound/NextTerm behavior
5. Attacker produces block with round-terminating transaction
6. Validation passes (all checks only verify miner list membership)
7. Round terminates prematurely

**Detection Difficulty:**
- Attack appears as legitimate round transition on-chain
- No obvious indicators distinguish it from proper extra block producer behavior
- Only post-facto analysis of `IsExtraBlockProducer` flag reveals the violation

**Probability Assessment: Medium-High**
- Scenario occurs regularly (miners transition rounds frequently)
- Low technical barrier once miner status achieved
- Economic incentive exists (capture remaining block rewards)
- No monitoring mechanisms to prevent or detect exploitation

## Recommendation

Add explicit extra block producer authorization validation in the consensus pipeline:

**Option 1 - Validation Provider Approach:**
Create a new `ExtraBlockProducerValidationProvider` that validates the sender is the designated extra block producer for NextRound/NextTerm behaviors:

```csharp
public class ExtraBlockProducerValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        
        // Only check for round-terminating behaviors
        if (validationContext.ExtraData.Behaviour != AElfConsensusBehaviour.NextRound &&
            validationContext.ExtraData.Behaviour != AElfConsensusBehaviour.NextTerm)
        {
            validationResult.Success = true;
            return validationResult;
        }
        
        // Get designated extra block producer
        var extraBlockProducer = validationContext.BaseRound.RealTimeMinersInformation
            .FirstOrDefault(m => m.Value.IsExtraBlockProducer).Key;
            
        if (extraBlockProducer != validationContext.SenderPubkey)
        {
            validationResult.Message = 
                $"Sender {validationContext.SenderPubkey} is not the designated extra block producer. " +
                $"Expected: {extraBlockProducer}";
            return validationResult;
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Then add this provider in `AEDPoSContract_Validation.cs`:

```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new ExtraBlockProducerValidationProvider());
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new ExtraBlockProducerValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        break;
}
```

**Option 2 - Behavior Provider Approach:**
Add validation in `ConsensusBehaviourProviderBase.GetConsensusBehaviour()` before returning round-terminating behavior:

```csharp
// Before line 82
var extraBlockProducer = CurrentRound.RealTimeMinersInformation
    .FirstOrDefault(m => m.Value.IsExtraBlockProducer).Key;
    
if (_pubkey != extraBlockProducer)
{
    // Not authorized to terminate round
    return AElfConsensusBehaviour.Nothing;
}

return GetConsensusBehaviourToTerminateCurrentRound();
```

**Recommended Approach:** Implement both options for defense-in-depth:
1. Behavior provider prevents unauthorized command generation
2. Validation provider ensures no bypasses during block execution

## Proof of Concept

**Note:** This is a conceptual PoC demonstrating the vulnerability path. A full test would require the AEDPoS test harness setup.

```csharp
[Fact]
public async Task UnauthorizedRoundTermination_ByNonExtraBlockProducer()
{
    // Setup: Round with 5 miners, attacker at position 2
    var miners = new[] { "miner1", "miner2_attacker", "miner3", "miner4", "miner5" };
    var round = GenerateRound(miners, extraBlockProducerIndex: 0); // miner1 is extra block producer
    
    // Attacker (miner2) produces their normal block
    await ProduceBlock("miner2_attacker", AElfConsensusBehaviour.UpdateValue);
    
    // Advance time past miner2's slot but before extra block time
    AdvanceTime(miningInterval * 2); // Past miner2's slot, but miner3/4/5 haven't mined yet
    
    // VULNERABILITY: miner2_attacker requests consensus command
    var command = await ConsensusContract.GetConsensusCommand.CallAsync(
        new BytesValue { Value = ByteString.CopyFrom(GetPublicKey("miner2_attacker")) }
    );
    
    // Command should be Invalid (only extra block producer should terminate)
    // But ACTUAL behavior: command.Hint contains NextRound behavior
    Assert.Equal(AElfConsensusBehaviour.NextRound, 
        AElfConsensusHint.Parser.ParseFrom(command.Hint).Behaviour);
    
    // Attacker produces block with NextRound transaction
    await ProduceBlock("miner2_attacker", AElfConsensusBehaviour.NextRound);
    
    // RESULT: Round terminated prematurely
    // miner3, miner4, miner5 never got to mine
    // Extra block producer (miner1) was bypassed
    var currentRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.Equal(round.RoundNumber + 1, currentRound.RoundNumber); // Round incremented
    
    // Verify miners 3/4/5 didn't produce blocks
    Assert.Null(round.RealTimeMinersInformation["miner3"].OutValue);
    Assert.Null(round.RealTimeMinersInformation["miner4"].OutValue);
    Assert.Null(round.RealTimeMinersInformation["miner5"].OutValue);
}
```

The test demonstrates that any miner who has mined can terminate the round once their time slot expires, without being the designated extra block producer.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-82)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L10-47)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) return ValidationForNextRound(validationContext);

        if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) return ValidationForNextTerm(validationContext);

        validationResult.Success = true;
        return validationResult;
    }

    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-91)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L61-64)
```csharp
    ///     In current AElf Consensus design, each miner produce his block in one time slot, then the extra block producer
    ///     produce a block to terminate current round and confirm the mining order of next round.
    ///     So totally, the time of one round is:
    ///     MiningInterval * MinersCount + MiningInterval.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-65)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```
