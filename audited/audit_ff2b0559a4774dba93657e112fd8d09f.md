### Title
Uninitialized Configuration Keys Return Default Values Enabling ACS Validation Bypass

### Summary
The Configuration contract's `GetConfiguration` method returns an empty `BytesValue` for uninitialized configuration keys instead of failing. [1](#0-0)  This behavior masks critical configuration errors, particularly allowing user contracts to bypass required ACS standard validation when the `RequiredAcsInContracts` configuration is unset or cleared.

### Finding Description

**Root Cause:**
The `GetConfiguration` method performs a null check and returns an empty `BytesValue()` object when a configuration key doesn't exist. [1](#0-0)  This design is intentional as confirmed by test cases [2](#0-1)  but creates a security vulnerability for critical system configurations.

**Why Protections Fail:**
The Configuration contract has no initialization methods, [3](#0-2)  meaning critical configurations are not automatically set during deployment and must be manually configured via governance.

**Critical Exploitation Path:**

1. **Configuration Service** retrieves configuration data by calling the contract's `GetConfiguration` method and returns the ByteString value [4](#0-3) 

2. **RequiredAcsProvider** calls `GetConfigurationDataAsync` to retrieve `RequiredAcsInContracts` configuration and parses it into a RequiredAcsInContracts object [5](#0-4)  When the configuration is uninitialized, the returned ByteString is empty, resulting in an empty ACS list.

3. **CodeCheckService** retrieves required ACS for user contracts [6](#0-5)  and passes it to the contract auditor. [7](#0-6) 

4. **AcsValidator** has an early return: when `AcsList.Count == 0`, it returns empty validation results, performing NO validation. [8](#0-7) 

**Additional Vulnerable Configurations:**
- `SecretSharingEnabled` in consensus: When uninitialized, MergeFrom leaves BoolValue at default (false), silently disabling secret sharing. [9](#0-8) 
- `UserContractMethodFee`: Returns empty fee object when uninitialized, allowing contracts to bypass fee requirements. [10](#0-9) 

### Impact Explanation

**Direct Harm:**
- **ACS1 Fee Bypass**: User contracts can be deployed without implementing ACS1 (transaction fee standard), evading all transaction fees and depriving the protocol of fee revenue.
- **Security Standard Bypass**: Contracts bypass other mandatory ACS standards that enforce security invariants, operational requirements, or governance controls.
- **Consensus Integrity**: Secret sharing can be unintentionally disabled in consensus if configuration is missing, weakening consensus security.

**Affected Parties:**
- Protocol: Loss of fee revenue and security guarantees
- Users: Exposure to non-compliant contracts lacking required security standards
- Validators: Potential consensus weakening if secret sharing is disabled

**Severity Justification:**
HIGH impact - This breaks a critical security invariant (mandatory ACS validation) that protects the entire contract deployment system. The Configuration contract's state mapping [11](#0-10)  is designed to store arbitrary key-value pairs but lacks safeguards for critical system configurations.

### Likelihood Explanation

**Attack Preconditions:**
1. **Initial Deployment**: Chain deployed without setting `RequiredAcsInContracts` configuration (no automatic initialization occurs)
2. **Governance Attack**: Malicious or buggy governance proposal clears/resets the configuration
3. **Configuration Drift**: Configuration accidentally deleted during system upgrades

**Attack Complexity:**
- **Low for initial state**: If administrators forget to set configuration post-deployment
- **Medium for governance attack**: Requires passing a governance proposal through Parliament default organization
- **Detection difficulty**: Silent failures mask the misconfiguration until non-compliant contracts are deployed

**Feasibility:**
The Configuration contract is authorized by Parliament or Genesis contract. [12](#0-11)  A single approved proposal can set any configuration value, including clearing critical ones. The contract validates permissions but not configuration content/presence.

**Economic Rationality:**
Attackers could deploy contracts that avoid fees entirely, making this economically attractive. The cost is limited to governance proposal creation and approval coordination.

### Recommendation

**Code-Level Mitigations:**

1. **Add explicit initialization for critical configurations** in `ConfigurationContractInitializationProvider`:
   - Set default `RequiredAcsInContracts` with mandatory ACS1
   - Set default `SecretSharingEnabled` to true
   - Establish baseline critical configurations at deployment

2. **Implement validation in SetConfiguration** to prevent clearing critical keys:
   - Maintain a whitelist of protected configuration keys
   - Require special authorization to modify protected keys
   - Reject proposals that set critical configurations to empty values

3. **Add defensive checks in consumers**:
   - `RequiredAcsProvider` should assert that AcsList is not empty for user contract validation
   - `CodeCheckService` should fail loudly if required ACS configuration is missing
   - `IsSecretSharingEnabled` should throw if configuration is uninitialized rather than defaulting to false

4. **Implement configuration state verification**:
   - Add `VerifyConfiguration(key)` method that fails if critical configuration is unset
   - Call verification before critical operations
   - Emit events when critical configurations are modified

**Test Cases:**
- Test that code check fails when RequiredAcsInContracts is empty (should not allow deployment)
- Test that secret sharing configuration must be explicitly set before consensus operations
- Test that SetConfiguration rejects clearing protected configuration keys
- Test initialization sets all critical configurations with non-empty values

### Proof of Concept

**Initial State:**
- Configuration contract deployed via genesis
- `RequiredAcsInContracts` configuration never set (empty initialization list confirmed)
- Default Parliament organization has approval authority

**Exploitation Steps:**

1. **Verify configuration is uninitialized:**
   - Call `GetConfiguration("RequiredAcsInContracts")`
   - Returns empty BytesValue (Length = 0)

2. **Deploy non-compliant user contract:**
   - Create contract that does NOT implement ACS1 (no transaction fee methods)
   - Submit contract via Genesis contract's `ProposeUserSmartContract`
   - CodeCheck runs but AcsValidator receives empty RequiredAcs list
   - Validation passes with no ACS checks performed
   - Contract deploys successfully

3. **Execute transactions without fees:**
   - Call methods on deployed non-compliant contract
   - Transactions execute without charging any fees
   - Protocol loses fee revenue

**Expected vs Actual:**
- **Expected**: Code check should fail for contracts missing ACS1, rejecting deployment
- **Actual**: Code check passes, contract deploys, transactions bypass fee system

**Success Condition:**
Contract deployment succeeds and transactions execute fee-free when `RequiredAcsInContracts` configuration is uninitialized, demonstrating complete bypass of mandatory ACS validation.

### Citations

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract.cs (L10-14)
```csharp
    public override Empty SetConfiguration(SetConfigurationInput input)
    {
        AssertPerformedByConfigurationControllerOrZeroContract();
        Assert(input.Key.Any() && input.Value != ByteString.Empty, "Invalid set config input.");
        State.Configurations[input.Key] = new BytesValue { Value = input.Value };
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract.cs (L23-27)
```csharp
    public override BytesValue GetConfiguration(StringValue input)
    {
        var value = State.Configurations[input.Value];
        return value ?? new BytesValue();
    }
```

**File:** test/AElf.Contracts.Configuration.Tests/ConfigurationContractTest.cs (L57-66)
```csharp
    [Fact]
    public async Task GetConfiguration_Of_Not_Exist_Key_Test()
    {
        var transactionResult =
            await ExecuteContractWithMiningAsync(ConfigurationContractAddress,
                nameof(ConfigurationImplContainer.ConfigurationImplStub.GetConfiguration),
                new StringValue { Value = "BlockTransactionLimit" });
        Assert.True(transactionResult.Status == TransactionResultStatus.Mined);
        transactionResult.ReturnValue.Length.ShouldBe(0);
    }
```

**File:** src/AElf.Kernel.Configuration/ConfigurationContractInitializationProvider.cs (L13-16)
```csharp
    public List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        return new List<ContractInitializationMethodCall>();
    }
```

**File:** src/AElf.Kernel.Configuration/IConfigurationService.cs (L42-55)
```csharp
    public async Task<ByteString> GetConfigurationDataAsync(string configurationName, ChainContext chainContext)
    {
        var indexedSideChainBlockData = await _contractReaderFactory
            .Create(new ContractReaderContext
            {
                BlockHash = chainContext.BlockHash,
                BlockHeight = chainContext.BlockHeight,
                ContractAddress = await _smartContractAddressService.GetAddressByContractNameAsync(chainContext,
                    ConfigurationSmartContractAddressNameProvider.StringName)
            })
            .GetConfiguration.CallAsync(new StringValue { Value = configurationName });

        return indexedSideChainBlockData.Value;
    }
```

**File:** src/AElf.Kernel.CodeCheck/Infrastructure/RequiredAcsProvider.cs (L18-37)
```csharp
    public async Task<RequiredAcs> GetRequiredAcsInContractsAsync(Hash blockHash, long blockHeight)
    {
        var chainContext = new ChainContext
        {
            BlockHash = blockHash,
            BlockHeight = blockHeight
        };

        var returned =
            await _configurationService.GetConfigurationDataAsync(
                RequiredAcsInContractsConfigurationName, chainContext);

        var requiredAcsInContracts = new RequiredAcsInContracts();
        requiredAcsInContracts.MergeFrom(returned);
        return new RequiredAcs
        {
            AcsList = requiredAcsInContracts.AcsList.ToList(),
            RequireAll = requiredAcsInContracts.RequireAll
        };
    }
```

**File:** src/AElf.Kernel.CodeCheck/Application/CodeCheckService.cs (L37-40)
```csharp
        if (isUserContract)
        {
            requiredAcs = await _requiredAcsProvider.GetRequiredAcsInContractsAsync(blockHash, blockHeight);
        }
```

**File:** src/AElf.Kernel.CodeCheck/Application/CodeCheckService.cs (L52-52)
```csharp
            contractAuditor.Audit(code, requiredAcs, isSystemContract);
```

**File:** src/AElf.CSharp.CodeOps/Validators/Assembly/AcsValidator.cs (L18-19)
```csharp
        if (requiredAcs.AcsList.Count == 0)
            return Enumerable.Empty<ValidationResult>(); // No ACS required
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L71-77)
```csharp
        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L134-165)
```csharp
    private UserContractMethodFees GetActualFee(Address contractAddress, string methodName)
    {
        if (State.ConfigurationContract.Value == null)
            State.ConfigurationContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
        //Get the fee of the specified contract method set by the configuration contract.
        //configuration_key:UserContractMethod_contractAddress_methodName
        var spec = State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = $"{TokenContractConstants.UserContractMethodFeeKey}_{contractAddress.ToBase58()}_{methodName}"
        });
        var fee = new UserContractMethodFees();
        if (!spec.Value.IsNullOrEmpty())
        {
            fee.MergeFrom(spec.Value);
            return fee;
        }

        //If special key is null,get the normal fee set by the configuration contract.
        //configuration_key:UserContractMethod
        var value = State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = TokenContractConstants.UserContractMethodFeeKey
        });
        if (value.Value.IsNullOrEmpty())
        {
            return new UserContractMethodFees();
        }

        fee.MergeFrom(value.Value);
        return fee;
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationState.cs (L12-12)
```csharp
    public MappedState<string, BytesValue> Configurations { get; set; }
```
