### Title
Cross-Chain Indexing Controller Change Prevents Legitimate Proposal Release

### Summary
The `GetIndexingProposalStatus()` function incorrectly marks legitimately approved cross-chain indexing proposals as not releasable when the CrossChainIndexingController is changed after proposal creation. This causes a denial-of-service condition where approved proposals cannot be automatically released, blocking cross-chain data indexing until proposals expire.

### Finding Description
The vulnerability exists in the `GetIndexingProposalStatus()` function which determines whether pending cross-chain indexing proposals should be released. [1](#0-0) 

The root cause is that this function requires BOTH conditions to be true:
1. The proposal must be approved (`proposalInfo.ToBeReleased` from the authorization contract)
2. The proposal's organization address must match the current controller's owner address

When a cross-chain indexing proposal is created via `ProposeCrossChainBlockData`, it uses the current controller's OwnerAddress as the proposal's OrganizationAddress. [2](#0-1) 

However, the CrossChainIndexingController can be changed at any time via `ChangeCrossChainIndexingController`, which has no checks for pending proposals. [3](#0-2) 

When the controller changes after proposal creation, the organization address mismatch causes `GetIndexingProposalStatus` to return `ToBeReleased = false` even for proposals that were legitimately approved by their original organization.

The automatic release mechanism relies on this view function. The service layer calls `GetIndexingProposalStatus` and then filters proposals where `ToBeReleased = true` to determine which should be released. [4](#0-3) 

When `ToBeReleased` is incorrectly set to false, the proposal is filtered out and never gets released automatically. [5](#0-4) 

### Impact Explanation
**Operational Impact - DoS of Cross-Chain Indexing:**

When this vulnerability is triggered, approved cross-chain indexing proposals become stuck and cannot be released through the normal automatic mechanism. This has several concrete consequences:

1. **Blocked Cross-Chain Communication:** The affected chain's cross-chain data cannot be indexed, preventing verification of cross-chain transactions and merkle proofs for that chain.

2. **Delayed Data Propagation:** Parent-chain or side-chain block data remains unindexed, breaking the cross-chain communication flow until the proposal expires and a new one is created with the new controller.

3. **Resource Waste:** The originally approved proposal, which consumed governance resources (voting, approvals), becomes unusable and must be abandoned.

4. **Service Disruption:** All chains that had pending approved proposals at the time of controller change are affected simultaneously, potentially causing widespread cross-chain indexing failure.

The severity is HIGH because cross-chain indexing is a critical protocol function required for side-chain and parent-chain communication integrity. The impact affects the core cross-chain verification invariant.

### Likelihood Explanation
**High Likelihood:**

This vulnerability has realistic exploitability with the following characteristics:

1. **Reachable Entry Point:** `ChangeCrossChainIndexingController` is a legitimate public governance function. [3](#0-2) 

2. **Feasible Preconditions:** 
   - Requires pending cross-chain indexing proposals (normal operational state during active cross-chain communication)
   - Requires controller change through governance (legitimate action for updating governance structure)
   - No special attacker capabilities needed - this occurs through normal governance operations

3. **Execution Practicality:** Controller changes are expected governance actions, demonstrated in test scenarios. [6](#0-5) 

4. **No Protection:** The `ChangeCrossChainIndexingController` function has no checks for pending proposals and no mechanism to migrate or handle them.

5. **Economic Rationality:** This can occur accidentally during normal governance operations without malicious intent. The "attack" cost is just the normal governance proposal process.

The vulnerability is particularly likely because controller changes and cross-chain proposals operate independently, with no coordination mechanism to prevent conflicts.

### Recommendation

**Primary Fix:** Remove the organization address check from `GetIndexingProposalStatus` or make it validate against the stored controller at proposal creation time.

**Option 1 (Recommended):** Store the controller's ContractAddress and OwnerAddress with each proposal when created, then validate against the stored values rather than current state: [7](#0-6) 

Modify `ChainIndexingProposal` to include the controller information at creation time, and check against these stored values in `GetIndexingProposalStatus`.

**Option 2:** Simply check if the proposal exists and is approved, without organization address validation: [1](#0-0) 

Change to: `pendingChainIndexingProposalStatus.ToBeReleased = proposalInfo.ToBeReleased;`

**Option 3:** Add protection to prevent controller changes when pending proposals exist: [3](#0-2) 

Add assertion: `Assert(State.IndexingPendingProposal.Value?.ChainIndexingProposalCollections.Count == 0, "Cannot change controller with pending proposals");`

**Invariant Check:** Ensure that approved proposals can always be released regardless of subsequent controller changes, or ensure controller changes handle/clear pending proposals first.

**Test Cases:** Add test coverage for controller changes with pending proposals in various states (proposed, approved, expired).

### Proof of Concept

**Initial State:**
- CrossChainIndexingController = { ContractAddress: ParliamentContract, OwnerAddress: OrganizationA }
- No pending cross-chain indexing proposals

**Attack/Exploit Steps:**

1. **Miner proposes cross-chain data** (normal operation):
   - Call `ProposeCrossChainIndexing` with valid cross-chain block data
   - Proposal created with `OrganizationAddress = OrganizationA` [8](#0-7) 
   - Proposal status: Pending, awaiting approval

2. **Organization A approves the proposal** (normal governance):
   - Parliament members vote and approve the proposal
   - In authorization contract: `proposal.ToBeReleased = true`
   - Proposal is ready for release

3. **Governance changes controller** (legitimate governance action):
   - Call `ChangeCrossChainIndexingController` with new AuthorityInfo
   - New controller: { ContractAddress: ParliamentContract, OwnerAddress: OrganizationB }
   - Controller successfully changed [3](#0-2) 

4. **Service layer checks proposal status** (automatic mechanism):
   - Call `GetIndexingProposalStatus` [9](#0-8) 
   - Function retrieves: `proposalInfo.ToBeReleased = true`, `proposalInfo.OrganizationAddress = OrganizationA`
   - Current controller: `crossChainIndexingController.OwnerAddress = OrganizationB`
   - Check fails: `OrganizationA != OrganizationB`
   - Returns: `ToBeReleased = false` [1](#0-0) 

5. **Release mechanism skips the proposal**:
   - `FindToBeReleasedChainIdList` filters proposals where `ToBeReleased = true` [4](#0-3) 
   - This approved proposal is NOT included (filtered out)
   - No release transaction is created

**Expected vs Actual Result:**
- **Expected:** Approved proposal should be released automatically, cross-chain data indexed
- **Actual:** Proposal marked as not releasable, cross-chain indexing blocked for this chain, must wait for proposal expiration

**Success Condition:** The approved cross-chain indexing proposal remains stuck and cannot be released through the automatic mechanism until it expires, demonstrating a complete denial-of-service for that chain's cross-chain indexing.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L177-179)
```csharp
            pendingChainIndexingProposalStatus.ToBeReleased =
                proposalInfo.ToBeReleased &&
                proposalInfo.OrganizationAddress == crossChainIndexingController.OwnerAddress;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L390-447)
```csharp
    private void ProposeCrossChainBlockData(CrossChainDataDto crossChainDataDto, Address proposer)
    {
        var crossChainIndexingController = GetCrossChainIndexingController();
        foreach (var chainId in crossChainDataDto.GetChainIdList())
        {
            Assert(!TryGetIndexingProposal(chainId, out _), "Chain indexing already proposed.");
            var proposalToken =
                HashHelper.ConcatAndCompute(Context.PreviousBlockHash, ConvertChainIdToHash(chainId));
            var proposalCreationInput = new CreateProposalBySystemContractInput
            {
                ProposalInput = new CreateProposalInput
                {
                    Params = new AcceptCrossChainIndexingProposalInput
                    {
                        ChainId = chainId
                    }.ToByteString(),
                    ContractMethodName = nameof(AcceptCrossChainIndexingProposal),
                    ExpiredTime =
                        Context.CurrentBlockTime.AddSeconds(CrossChainIndexingProposalExpirationTimePeriod),
                    OrganizationAddress = crossChainIndexingController.OwnerAddress,
                    ToAddress = Context.Self,
                    Token = proposalToken
                },
                OriginProposer = Context.Sender
            };

            Context.SendInline(crossChainIndexingController.ContractAddress,
                nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                    .CreateProposalBySystemContract), proposalCreationInput);

            var proposedCrossChainBlockData = new CrossChainBlockData();
            if (crossChainDataDto.ParentChainToBeIndexedData.TryGetValue(chainId,
                    out var parentChainToBeIndexedData))
                proposedCrossChainBlockData.ParentChainBlockDataList.Add(parentChainToBeIndexedData);
            else if (crossChainDataDto.SideChainToBeIndexedData.TryGetValue(chainId,
                         out var sideChainToBeIndexedData))
                proposedCrossChainBlockData.SideChainBlockDataList.Add(sideChainToBeIndexedData);

            var crossChainIndexingProposal = new ChainIndexingProposal
            {
                ChainId = chainId,
                Proposer = proposer,
                ProposedCrossChainBlockData = proposedCrossChainBlockData
            };
            var proposalId = Context.GenerateId(crossChainIndexingController.ContractAddress, proposalToken);
            crossChainIndexingProposal.ProposalId = proposalId;
            SetCrossChainIndexingProposalStatus(crossChainIndexingProposal,
                CrossChainIndexingProposalStatus.Pending);
            Context.Fire(new CrossChainIndexingDataProposedEvent
            {
                ProposedCrossChainData = proposedCrossChainBlockData,
                ProposalId = proposalId
            });

            Context.LogDebug(() =>
                $"Proposed cross chain data for chain {ChainHelper.ConvertChainIdToBase58(chainId)}");
        }
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L61-74)
```csharp
    public override Empty ChangeCrossChainIndexingController(AuthorityInfo input)
    {
        AssertCrossChainIndexingControllerAuthority(Context.Sender);
        SetContractStateRequired(State.ParliamentContract, SmartContractConstants.ParliamentContractSystemName);
        Assert(
            input.ContractAddress == State.ParliamentContract.Value &&
            ValidateParliamentOrganization(input.OwnerAddress), "Invalid authority input.");
        State.CrossChainIndexingController.Value = input;
        Context.Fire(new CrossChainIndexingControllerChanged
        {
            AuthorityInfo = input
        });
        return new Empty();
    }
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataService.cs (L89-103)
```csharp
        var toBeReleasedChainIdList = FindToBeReleasedChainIdList(indexingProposalStatusList, utcNow);

        if (toBeReleasedChainIdList.Count > 0)
        {
            // release pending proposal and unable to propose anything if it is ready
            _transactionInputForBlockMiningDataProvider.AddTransactionInputForBlockMining(blockHash,
                new CrossChainTransactionInput
                {
                    PreviousBlockHeight = blockHeight,
                    MethodName =
                        nameof(CrossChainContractImplContainer.CrossChainContractImplStub
                            .ReleaseCrossChainIndexingProposal),
                    Value = new ReleaseCrossChainIndexingProposalInput { ChainIdList = { toBeReleasedChainIdList } }
                        .ToByteString()
                });
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataService.cs (L346-363)
```csharp
    private async Task<GetIndexingProposalStatusOutput> GetIndexingProposalStatusAsync(
        Hash blockHash, long blockHeight, Timestamp timestamp)
    {
        var pendingProposal = await _contractReaderFactory
            .Create(new ContractReaderContext
            {
                BlockHash = blockHash,
                BlockHeight = blockHeight,
                ContractAddress = await GetCrossChainContractAddressAsync(new ChainContext
                {
                    BlockHash = blockHash,
                    BlockHeight = blockHeight
                }),
                Timestamp = timestamp
            })
            .GetIndexingProposalStatus.CallAsync(new Empty());
        return pendingProposal;
    }
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataService.cs (L373-379)
```csharp
    private List<int> FindToBeReleasedChainIdList(
        GetIndexingProposalStatusOutput pendingChainIndexingProposalStatusList, Timestamp timestamp)
    {
        return pendingChainIndexingProposalStatusList.ChainIndexingProposalStatus
            .Where(pair => pair.Value.ToBeReleased && pair.Value.ExpiredTime > timestamp).Select(pair => pair.Key)
            .ToList();
    }
```

**File:** test/AElf.Contracts.CrossChain.Tests/SideChainLifeTimeManagementTest.cs (L25-64)
```csharp
    public async Task ChangeIndexingController()
    {
        await InitializeCrossChainContractAsync();
        var oldOrganizationAddress =
            (await CrossChainContractStub.GetCrossChainIndexingController.CallAsync(new Empty())).OwnerAddress;

        var newOrganizationAddress = (await ParliamentContractStub.CreateOrganization.SendAsync(
            new CreateOrganizationInput
            {
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MaximalAbstentionThreshold = 3333,
                    MaximalRejectionThreshold = 3333,
                    MinimalApprovalThreshold = 3333,
                    MinimalVoteThreshold = 3333
                },
                ParliamentMemberProposingAllowed = true
            })).Output;
        var proposalRes = await ParliamentContractStub.CreateProposal.SendAsync(new CreateProposalInput
        {
            ContractMethodName = nameof(CrossChainContractStub.ChangeCrossChainIndexingController),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            Params = new AuthorityInfo
            {
                ContractAddress = ParliamentContractAddress, OwnerAddress = newOrganizationAddress
            }.ToByteString(),
            ToAddress = CrossChainContractAddress,
            OrganizationAddress = oldOrganizationAddress
        });

        var proposalId = Hash.Parser.ParseFrom(proposalRes.TransactionResult.ReturnValue);
        await ApproveWithMinersAsync(proposalId);
        var releaseResult = (await ParliamentContractStub.Release.SendAsync(proposalId)).TransactionResult;
        releaseResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var crossChainIndexingController =
            await CrossChainContractStub.GetCrossChainIndexingController.CallAsync(new Empty());
        crossChainIndexingController.ContractAddress.ShouldBe(ParliamentContractAddress);
        crossChainIndexingController.OwnerAddress.ShouldBe(newOrganizationAddress);
    }
```
