### Title
NFT Protocol Creation Fails Due to Symbol Type Misclassification and Length Validation

### Summary
The NFT contract generates protocol symbols in the format `{shortName}{randomNumber}` (e.g., "AR123456789") without using the NFT separator character '-'. This causes the TokenContract to misclassify these symbols as regular tokens and enforce the wrong maximum length constraint (10 characters for tokens vs 30 for NFTs), resulting in all NFT protocol creation attempts failing with "Invalid token symbol length" error.

### Finding Description

**Location**: [1](#0-0) 

The NFT contract's `GetSymbol()` function generates symbols by concatenating a 2-character short name with a 9+ digit random number (e.g., "AR123456789"). The initial symbol length is 11 characters (2 + 9). [2](#0-1) 

When the NFT contract calls `TokenContract.Create()` with this symbol: [3](#0-2) 

The TokenContract's `GetSymbolType()` function determines symbol classification based on the presence of the '-' separator: [4](#0-3) 

Since NFT protocol symbols lack the '-' separator, they are classified as `SymbolType.Token` (not NFT/NftCollection). This triggers the wrong validation in `CheckSymbolLength()`: [5](#0-4) 

The function enforces `SymbolMaxLength = 10` for tokens but `NFTSymbolMaxLength = 30` for NFTs: [6](#0-5) [7](#0-6) 

Since the 11-character NFT protocol symbols exceed the 10-character token limit, validation fails.

**Regarding Random Number Growth**: The `GetCurrentNumberLength()` function contains logic to increment the number length: [8](#0-7) 

However, the growth mechanism appears non-functional as the `NftProtocolNumberFlag` is never incremented beyond its initial value of 10^(length-1), meaning the condition on line 104 will never be satisfied under normal operation. Nevertheless, if the length were to grow (through external state manipulation or code changes), symbols could theoretically reach 31 characters (2 + 29 digits), violating the NFTSymbolMaxLength of 30.

### Impact Explanation

**Critical Operational Failure**: The NFT contract is completely non-functional for its primary purpose - creating NFT protocols. Every call to the public `Create()` method will fail during the token creation step with "Invalid token symbol length" error.

**Affected Parties**:
- All users attempting to create NFT protocols on the mainchain
- Existing NFT contract deployments are unusable
- The entire NFT ecosystem built on this contract

**Severity Justification**: This is a HIGH severity issue because it represents a complete denial of service for the NFT contract's core functionality, not a potential vulnerability but an actual operational failure.

### Likelihood Explanation

**Guaranteed Exploitation**: This is not an attack scenario but a guaranteed failure condition:
- **Entry Point**: Public `Create()` method accessible to any user [9](#0-8) 
- **Preconditions**: None - happens on every NFT protocol creation attempt
- **Complexity**: Zero - the failure is automatic and unavoidable
- **Detection**: Immediate - every transaction will revert with validation error

The validation is executed in `AssertValidCreateInput()` which is called unconditionally: [10](#0-9) 

### Recommendation

**Immediate Fix**: Modify the symbol format to include the NFT separator to ensure proper classification:

1. Update `GetSymbol()` to generate symbols like "AR-123456789" (with '-' separator)
2. This will cause `GetSymbolType()` to correctly classify them as NFT-related symbols
3. Validation will then enforce the 30-character limit instead of 10

**Alternative Fix**: Update `GetSymbolType()` logic to recognize NFT protocol symbols without separators by checking if the first 2 characters match known NFT type short names.

**Validation**: Add comprehensive integration tests that verify:
- NFT protocol creation succeeds
- Generated symbols are within NFTSymbolMaxLength (30 characters)
- Symbol classification is correct throughout the creation flow

**Length Growth Protection**: If implementing number length growth, add explicit validation in `GetCurrentNumberLength()`:
```
Assert(newSymbolNumberLength + 2 <= NFTSymbolMaxLength, "Symbol would exceed maximum length");
```

### Proof of Concept

**Initial State**: Deploy NFT contract on AELF mainchain

**Transaction Steps**:
1. Call `NFTContract.Create()` with valid parameters:
   - NftType: "VirtualWorlds" (maps to "VW" short name)
   - ProtocolName: "HUMAN"
   - TotalSupply: 1,000,000,000
   - Other required fields

**Expected Result**: NFT protocol created successfully with symbol like "VW123456789"

**Actual Result**: Transaction reverts with error "Invalid token symbol length" during `TokenContract.Create()` validation because:
- Generated symbol: "VW123456789" (11 characters)
- Classified as: SymbolType.Token
- Enforced limit: 10 characters
- Validation fails: 11 > 10

**Verification**: The test suite expects 11-character symbols: [11](#0-10) 

This confirms the design intent conflicts with the validation implementation.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L87-116)
```csharp
    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-14)
```csharp
    public override StringValue Create(CreateInput input)
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L20-34)
```csharp
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L305-311)
```csharp
    private void CheckSymbolLength(string symbol, SymbolType symbolType)
    {
        if (symbolType == SymbolType.Token)
            Assert(symbol.Length <= TokenContractConstants.SymbolMaxLength, "Invalid token symbol length");
        if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
            Assert(symbol.Length <= TokenContractConstants.NFTSymbolMaxLength, "Invalid NFT symbol length");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L7-7)
```csharp
    public const int SymbolMaxLength = 10;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L20-20)
```csharp
    public const int NFTSymbolMaxLength = 30;
```

**File:** test/AElf.Contracts.NFT.Tests/NFTContractTests.cs (L48-48)
```csharp
        symbol.Length.ShouldBe(11);
```
