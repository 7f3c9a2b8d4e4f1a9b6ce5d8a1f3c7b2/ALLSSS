### Title
Missing Election Results Validation in NextTerm Allows Current Miners to Bypass Elections and Retain Mining Authority

### Summary
The `NextTerm` method in AEDPoSContract lacks validation to ensure the miner list in `NextTermInput` matches the election results from `GetVictories`. A current miner can call `NextTerm` with arbitrary miners (including themselves) even if they lost the election, completely bypassing the voting-based miner selection mechanism and retaining control over block production indefinitely.

### Finding Description

The vulnerability exists in the validation and processing flow of term transitions: [1](#0-0) 

For `NextTerm` behavior, only `RoundTerminateValidationProvider` is added to the validation chain. [2](#0-1) 

This validator only checks that term/round numbers increment correctly, but performs NO validation of the miner list contents. [3](#0-2) 

`ProcessNextTerm` blindly accepts whatever miner list is provided in `NextTermInput.RealTimeMinersInformation` and sets it as the new miner list without comparing it against election results. [4](#0-3) 

The `NextTermInput` contains the full miner list specified by the caller, with no on-chain enforcement that it matches `ElectionContract.GetVictories()`. [5](#0-4) 

The `PreCheck` allows any current OR previous round miner to call `NextTerm`, giving attackers the necessary permission.

Regarding the original question about `MiningPermissionValidationProvider`: [6](#0-5) 

This validator only checks if sender exists in `BaseRound.RealTimeMinersInformation`, with no term number consistency check. However, in normal operation `BaseRound.TermNumber` and `CurrentTermNumber` should always match because they're updated atomically. The lack of this check is a defense-in-depth weakness but not independently exploitable.

### Impact Explanation

**Critical Consensus Integrity Violation:**
- Attacker miners can completely bypass the election system
- Enables permanent control over block production regardless of voting outcomes
- Violates the fundamental democratic governance model of AEDPoS consensus
- Eliminates community control over validator selection

**Concrete Damage:**
- Miners who lost elections retain full block production authority
- Block rewards continue flowing to unelected miners
- Voting system becomes meaningless - votes cannot change miner set
- Community loses ability to remove malicious or underperforming miners
- Centralization risk: small cartel of miners can self-perpetuate indefinitely

**Affected Parties:**
- All token holders who voted expecting their votes to matter
- Legitimate election winners who are excluded from mining
- Protocol integrity and credibility
- Economic model based on staking and voting incentives

### Likelihood Explanation

**High Likelihood - All Conditions Present:**

**Reachable Entry Point:** [7](#0-6) 

The `NextTerm` method is a public entry point callable by any current miner.

**Attacker Capabilities:**
- Must be a current miner (has mining authority in current term)
- Can construct `NextTermInput` with arbitrary miner list
- Can observe election results to know they're losing

**Execution Practicality:**
- Attack is simple: call `NextTerm` with self-preserving miner list when term should change
- No complex state manipulation required
- Single transaction execution
- Passes all existing validation checks

**Economic Rationality:**
- Cost: standard transaction fee
- Benefit: retain mining rewards indefinitely (millions in block rewards over time)
- Extremely profitable for miners facing election loss
- No detection mechanism - appears as legitimate term transition

**Detection/Operational Constraints:**
- Off-chain monitoring might notice mismatch with expected election results
- However, no on-chain enforcement exists
- Once executed, cannot be easily reversed without governance intervention
- Protocol has no built-in recovery mechanism

### Recommendation

**Immediate Mitigation - Add Election Results Validation:**

Add a new validation provider for `NextTerm` behavior:

```csharp
public class ElectionResultsValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        if (validationContext.ExtraData.Behaviour != AElfConsensusBehaviour.NextTerm)
            return new ValidationResult { Success = true };
            
        // Get expected miners from election contract
        var expectedVictories = State.ElectionContract.GetVictories.Call(new Empty());
        var providedMiners = validationContext.ProvidedRound.RealTimeMinersInformation.Keys
            .Select(k => ByteStringHelper.FromHexString(k)).ToHashSet();
            
        // Verify provided miner list matches election results
        if (expectedVictories.Pubkeys.Count != providedMiners.Count ||
            !expectedVictories.Pubkeys.All(pk => providedMiners.Contains(pk)))
        {
            return new ValidationResult 
            { 
                Message = "Provided miner list does not match election results." 
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Add to validation chain in `AEDPoSContract_Validation.cs`:
```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new ElectionResultsValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

**Defense-in-Depth - Add Term Consistency Check:**

In `MiningPermissionValidationProvider`:
```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    
    // Check term consistency
    if (validationContext.BaseRound.TermNumber != validationContext.CurrentTermNumber)
    {
        validationResult.Message = $"Term number mismatch: BaseRound term {validationContext.BaseRound.TermNumber} != Current term {validationContext.CurrentTermNumber}";
        return validationResult;
    }
    
    if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
    {
        validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
        return validationResult;
    }

    validationResult.Success = true;
    return validationResult;
}
```

**Test Cases:**
1. Test NextTerm with miner list not matching GetVictories - should fail
2. Test NextTerm with subset of election winners - should fail  
3. Test NextTerm with extra miners not in election results - should fail
4. Test NextTerm with correct election winners - should succeed
5. Test term number mismatch detection in mining permission validation

### Proof of Concept

**Initial State:**
- Term 1, Round 10
- Current miners: [MinerA, MinerB, MinerC] 
- Election results (GetVictories): [MinerD, MinerE, MinerF]
- MinerA knows they lost election and will lose block rewards

**Attack Sequence:**

1. MinerA observes it's time for term change (NeedToChangeTerm returns true)

2. MinerA constructs malicious `NextTermInput`:
   - `TermNumber = 2` (correct increment, passes validation)
   - `RoundNumber = 11` (correct increment, passes validation)
   - `RealTimeMinersInformation = {MinerA, MinerB, MinerC}` (OLD miners, but no validation!)

3. MinerA calls `NextTerm(maliciousInput)`
   - Validation: `RoundTerminateValidationProvider` checks only term/round numbers âœ“ passes
   - No validator checks miner list against election results
   - `PreCheck` passes because MinerA is current miner

4. `ProcessNextTerm` executes:
   - Updates `CurrentTermNumber` to 2
   - Updates `CurrentRoundNumber` to 11  
   - Calls `SetMinerList` with {MinerA, MinerB, MinerC}
   - Sets `State.Rounds[11]` with old miners

**Result:**
- Term 2 begins with MinerA, MinerB, MinerC as miners
- Election winners MinerD, MinerE, MinerF are excluded
- Old miners continue producing blocks and earning rewards
- Voting outcome completely ignored
- Attack succeeds with single transaction at minimal cost

**Expected vs Actual:**
- **Expected:** Term 2 should have miners [MinerD, MinerE, MinerF] from election
- **Actual:** Term 2 has miners [MinerA, MinerB, MinerC] who lost election
- **Success Condition:** Old miners can call `UpdateValue`/`TinyBlock`/`NextRound` in term 2 and validation passes

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-190)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** protobuf/aedpos_contract.proto (L484-489)
```text
message NextTermInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
