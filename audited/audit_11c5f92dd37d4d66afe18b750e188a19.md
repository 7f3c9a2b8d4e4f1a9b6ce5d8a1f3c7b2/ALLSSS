### Title
Missing Token Name Length Validation in Cross-Chain Token Creation Allows Storage DoS

### Summary
The `RegisterTokenInfo` function validates that `tokenInfo.TokenName` is not null or empty but does not check its length. While the normal `Create` flow enforces an 80-character limit, the `CrossChainCreateToken` flow bypasses this validation, allowing tokens with extremely long names (up to the 128KB state size limit) to be registered from whitelisted cross-chains, causing significant storage bloat and potential DoS.

### Finding Description
The vulnerability exists in the inconsistent validation across two code paths that register tokens:

**Normal Create Path (Protected):** [1](#0-0) 

This path validates `input.TokenName.Length <= TokenContractConstants.TokenNameLength` (80 characters). [2](#0-1) 

**Cross-Chain Create Path (Vulnerable):** [3](#0-2) 

This path creates a `TokenInfo` from cross-chain data and directly calls `RegisterTokenInfo` without length validation.

**Root Cause:** [4](#0-3) 

The `RegisterTokenInfo` function only checks `!string.IsNullOrEmpty(tokenInfo.TokenName)` but never validates the length constraint, relying on upstream callers to perform this check.

**Why Existing Protections Are Insufficient:**

While the AElf blockchain enforces a state size limit (default 128KB): [5](#0-4) [6](#0-5) 

This only provides an upper bound but still allows TokenName values approximately 1,250x larger than intended (100KB vs 80 bytes), violating defense-in-depth principles.

### Impact Explanation
**Concrete Harm:**
- **Storage Bloat:** Each malicious token can store a TokenName up to ~100KB instead of the intended 80 bytes, consuming ~1,250x more state storage per token
- **Cumulative DoS:** An attacker can register multiple such tokens to cause significant cumulative storage consumption
- **Expensive Operations:** Reading/writing TokenInfo objects with extremely large TokenName fields increases gas costs and degrades contract performance
- **State Database Stress:** Large state entries stress the underlying storage layer (Redis/SSDB)

**Quantified Impact:**
- Single token: 100KB vs 80 bytes = ~131,000 bytes excessive storage
- 10 malicious tokens = ~1.3MB excessive storage
- State read/write operations become proportionally more expensive

**Affected Parties:**
- Node operators (increased storage costs)
- Contract users (higher gas fees for operations)
- Protocol (blockchain state bloat)

**Severity Justification:** Medium - High impact (storage DoS) but Medium-Low likelihood (requires compromised whitelisted source chain).

### Likelihood Explanation
**Attack Prerequisites:**
1. Source chain must be registered in the cross-chain whitelist (controlled by Parliament governance): [7](#0-6) [8](#0-7) 

2. Source chain must either:
   - Be compromised or have a critical bug allowing TokenName length validation bypass
   - Run a different contract version without proper validation
   - Experience governance failure leading to invalid token creation

3. Attacker must execute cross-chain token creation with proof verification: [9](#0-8) 

**Complexity:** Medium - Requires compromising or exploiting a trusted whitelisted chain, but once achieved, the attack is straightforward.

**Feasibility:** The attack is executable if preconditions are met. While whitelisted chains are governance-controlled and presumed trustworthy, the principle of defense-in-depth suggests the receiving chain should independently validate all inputs regardless of source trust.

**Detection:** Difficult to detect until storage metrics show anomalies or specific TokenInfo queries become expensive.

**Probability:** Medium-Low - Requires source chain compromise or bug, but represents a real persistent risk for any whitelisted cross-chain integration.

### Recommendation
**Code-Level Mitigation:**
Add explicit TokenName length validation in the `CrossChainCreateToken` function before calling `RegisterTokenInfo`:

```csharp
// In CrossChainCreateToken, after line 503:
Assert(validateTokenInfoExistsInput.TokenName.Length <= TokenContractConstants.TokenNameLength,
    "Token name exceeds maximum length.");
```

**Alternative (Defense-in-Depth):**
Add the validation directly in `RegisterTokenInfo` to protect all code paths:

```csharp
// In RegisterTokenInfo, after line 228:
Assert(tokenInfo.TokenName.Length <= TokenContractConstants.TokenNameLength,
    "Token name exceeds maximum length.");
```

The second approach is preferred as it enforces the invariant at the point of state modification, protecting against future code paths that might also call `RegisterTokenInfo`.

**Additional Checks:**
- Validate other TokenInfo fields in cross-chain creation (Symbol length, decimals range, etc.)
- Add monitoring for TokenInfo state sizes

**Test Cases:**
- Test cross-chain token creation with TokenName exactly at 80 characters (should pass)
- Test cross-chain token creation with TokenName at 81 characters (should fail)
- Test cross-chain token creation with TokenName at 100KB (should fail)

### Proof of Concept
**Initial State:**
1. Parliament governance has registered a cross-chain token contract address for ChainA in the whitelist
2. ChainA has been compromised or has a validation bug

**Attack Steps:**
1. **On ChainA:** Attacker exploits the compromised chain to create a token with:
   - Symbol: "MALICIOUS"
   - TokenName: [100KB string of repeated characters]
   - Other valid fields

2. **Transaction Creation:** Attacker creates a `ValidateTokenInfoExists` transaction on ChainA with the malicious token parameters

3. **Cross-Chain Propagation:** Attacker calls `CrossChainCreateToken` on the target chain with:
   - TransactionBytes containing the ValidateTokenInfoExists transaction
   - Valid MerklePath proving the transaction was executed on ChainA
   - FromChainId = ChainA's ID
   - ParentChainHeight at which the transaction occurred

4. **Verification Passes:** 
   - `CrossChainVerify` succeeds because the merkle proof is valid
   - No TokenName length check is performed
   - `RegisterTokenInfo` succeeds with the 100KB TokenName

5. **Result:** 
   - Expected: Token creation rejected due to excessive TokenName length
   - Actual: Token successfully registered with 100KB TokenName
   - State.TokenInfos["MALICIOUS"] now contains ~100KB of data instead of ~80 bytes

6. **Success Condition:** Query `GetTokenInfo("MALICIOUS")` returns a TokenInfo with TokenName length >> 80 characters, and state storage metrics show excessive consumption.

**Repeatability:** Attack can be repeated with different symbols to register multiple bloated tokens, amplifying the storage DoS impact.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L252-264)
```csharp
    private AuthorityInfo GetCrossChainTokenContractRegistrationController()
    {
        var parliamentContractAddress =
            Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
        var controller = new AuthorityInfo
        {
            ContractAddress = State.ParliamentContract.Value,
            OwnerAddress = Context.Call<Address>(parliamentContractAddress,
                nameof(ParliamentContractContainer.ParliamentContractReferenceState.GetDefaultOrganizationAddress),
                new Empty())
        };
        return controller;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-277)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L313-320)
```csharp
    private void CheckCrossChainTokenContractRegistrationControllerAuthority()
    {
        if (State.CrossChainTokenContractRegistrationController.Value == null)
            State.CrossChainTokenContractRegistrationController.Value =
                GetCrossChainTokenContractRegistrationController();
        Assert(State.CrossChainTokenContractRegistrationController.Value.OwnerAddress == Context.Sender,
            "No permission.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L5-5)
```csharp
    public const int TokenNameLength = 80;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L486-488)
```csharp
        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L492-508)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L148-159)
```csharp
    public object ValidateStateSize(object obj)
    {
        var stateSizeLimit = AsyncHelper.RunSync(() => _smartContractBridgeService.GetStateSizeLimitAsync(
            new ChainContext
            {
                BlockHash = _transactionContext.PreviousBlockHash,
                BlockHeight = _transactionContext.BlockHeight - 1
            }));
        var size = SerializationHelper.Serialize(obj).Length;
        if (size > stateSizeLimit)
            throw new StateOverSizeException($"State size {size} exceeds limit of {stateSizeLimit}.");
        return obj;
```
