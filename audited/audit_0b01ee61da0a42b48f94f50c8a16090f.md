# Audit Report

## Title
Missing Duplicate UpdateValue Check Allows Consensus Data Overwrite Within Same Round

## Summary
The AEDPoS consensus contract fails to prevent miners from calling `UpdateValue` multiple times within a single round. The validation flow calls `RecoverFromUpdateValue` before checking whether consensus data was already submitted, allowing malicious miners to overwrite their `OutValue` and `Signature` fields. This breaks consensus invariants by enabling manipulation of randomness generation and next-round miner ordering.

## Finding Description

The vulnerability exists in the consensus validation flow where the system fails to verify whether a miner has already submitted their consensus data before allowing an update.

**Root Cause:**

The validation flow in `ValidateBeforeExecution` calls `baseRound.RecoverFromUpdateValue()` on the current state BEFORE any duplicate-submission checks occur. [1](#0-0) 

This recovery method unconditionally overwrites the `OutValue` and `Signature` fields in the baseRound with values from the provided round, regardless of whether these fields were already populated. [2](#0-1) 

The modified baseRound (with attacker's new values already written) is then used to construct the validation context. [3](#0-2) 

The `UpdateValueValidationProvider` only checks that the provided values are non-null, not whether the ORIGINAL state already had these values set. [4](#0-3) 

During execution, `ProcessUpdateValue` again unconditionally overwrites the stored values. [5](#0-4) 

**Why Existing Protections Fail:**

1. `EnsureTransactionOnlyExecutedOnceInOneBlock` only prevents multiple consensus transactions in the SAME block (height), not across different blocks within the same round. [6](#0-5) 

2. The consensus behavior provider checks `OutValue == null` to determine whether to generate UpdateValue commands, but this cannot prevent manually crafted transactions. [7](#0-6) 

3. Time slot validation only verifies the miner is within their allocated time window, not whether they've already submitted. [8](#0-7) 

4. Permission validation only checks if the signer is in the miner list. [9](#0-8) 

## Impact Explanation

**Consensus Randomness Manipulation:**
The `Signature` field is directly used in XOR operations to generate consensus randomness. [10](#0-9) 

A malicious miner can submit multiple `UpdateValue` transactions with different `InValue` inputs to generate different signatures. By iterating through different values, they can "re-roll" the random output until obtaining a favorable result for mechanisms that depend on consensus randomness, such as validator selection or reward distribution.

**Next Round Order Manipulation:**
The signature directly determines each miner's position in the next round through modulo arithmetic. [11](#0-10) 

By manipulating their signature value, a malicious miner can control their order in the subsequent round, potentially securing advantageous early positions or avoiding detection patterns.

**Secret Sharing Integrity Breach:**
If secret sharing is enabled, the attacker can manipulate encrypted pieces and decrypted pieces through repeated submissions. [12](#0-11) 

This breaks the cryptographic guarantees of the secret sharing mechanism, potentially compromising the entire consensus integrity.

**Severity: HIGH** - Fundamentally breaks consensus invariants including fair randomness generation and deterministic miner ordering.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be a legitimate miner with an allocated time slot in the current round
- Can sign transactions with their miner private key  
- Can submit transactions to the network

**Attack Execution:**
1. Miner produces block at height H with `UpdateValue` containing `OutValue_1 = Hash(InValue_1)`
2. Within the same round, miner produces another block at height H+1 with `UpdateValue` containing `OutValue_2 = Hash(InValue_2)` where `InValue_2 â‰  InValue_1`
3. The second transaction passes all validations because `RecoverFromUpdateValue` has already modified the validation state
4. The execution unconditionally overwrites the first submission

**Feasibility:**
- Mining intervals typically provide 4-8 seconds, sufficient time for multiple blocks
- No special infrastructure required beyond standard miner node setup
- Attack leaves on-chain evidence but no automatic prevention exists

**Probability: HIGH** - Any malicious miner in the active set can execute this attack during their allocated time slot without special conditions or race requirements.

## Recommendation

Add a duplicate submission check BEFORE calling `RecoverFromUpdateValue` in the validation flow:

```csharp
// In ValidateBeforeExecution method, before line 46
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
{
    // Check if OutValue is already set in the ORIGINAL state
    var minerInBaseRound = baseRound.RealTimeMinersInformation[extraData.SenderPubkey.ToHex()];
    if (minerInBaseRound.OutValue != null && minerInBaseRound.OutValue != Hash.Empty)
    {
        return new ValidationResult 
        { 
            Success = false, 
            Message = "Miner has already submitted UpdateValue in this round." 
        };
    }
    
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
}
```

This ensures the original state is checked before any modifications occur, preventing duplicate submissions within the same round.

## Proof of Concept

```csharp
// Test demonstrating duplicate UpdateValue submission
[Fact]
public async Task MinerCanSubmitUpdateValueTwiceInSameRound()
{
    // Setup: Initialize consensus with a miner
    var miner = SampleAccount.Accounts[0];
    await InitializeConsensusAsync();
    
    // Get current round
    var currentRound = await GetCurrentRoundInformation();
    var roundNumber = currentRound.RoundNumber;
    
    // First UpdateValue submission at block height H
    var firstInput = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("InValue1"),
        Signature = HashHelper.ComputeFrom("Signature1"),
        // ... other fields
    };
    await MinerUpdateValueAsync(miner, firstInput);
    
    // Verify first submission was recorded
    var roundAfterFirst = await GetCurrentRoundInformation();
    roundAfterFirst.RoundNumber.ShouldBe(roundNumber); // Still same round
    var minerInfo1 = roundAfterFirst.RealTimeMinersInformation[miner.PublicKey.ToHex()];
    minerInfo1.OutValue.ShouldBe(firstInput.OutValue);
    
    // Second UpdateValue submission at block height H+1 (still same round)
    var secondInput = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("InValue2"), // Different value!
        Signature = HashHelper.ComputeFrom("Signature2"), // Different signature!
        // ... other fields
    };
    
    // VULNERABILITY: This should fail but succeeds
    var result = await MinerUpdateValueAsync(miner, secondInput);
    result.Status.ShouldBe(TransactionResultStatus.Mined); // Passes validation
    
    // Verify second submission OVERWROTE the first
    var roundAfterSecond = await GetCurrentRoundInformation();
    roundAfterSecond.RoundNumber.ShouldBe(roundNumber); // Still same round
    var minerInfo2 = roundAfterSecond.RealTimeMinersInformation[miner.PublicKey.ToHex()];
    
    // OutValue and Signature were overwritten!
    minerInfo2.OutValue.ShouldBe(secondInput.OutValue); // VULNERABILITY: Different from first!
    minerInfo2.Signature.ShouldBe(secondInput.Signature); // VULNERABILITY: Overwritten!
    minerInfo2.OutValue.ShouldNotBe(minerInfo1.OutValue); // Proves overwrite occurred
}
```

**Notes:**
- The vulnerability allows miners to manipulate their contribution to consensus randomness by submitting multiple values and selecting the most favorable outcome
- The signature value directly determines next-round ordering, giving attackers control over their position in subsequent rounds
- The attack is detectable off-chain but requires active monitoring; no on-chain protection currently exists
- The fix must check the ORIGINAL state before `RecoverFromUpdateValue` modifies it, as validation currently operates on already-modified state

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L14-20)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-245)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-56)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-22)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

```
