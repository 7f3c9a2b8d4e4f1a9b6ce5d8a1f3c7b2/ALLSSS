### Title
Historical Round Information Disclosure Through Unfiltered GetRoundInformation View Method

### Summary
The `GetRoundInformation` function returns complete historical round data without sanitization, exposing sensitive information including miner performance metrics (`missed_time_slots`), precise timing patterns (`actual_mining_times`), and secret sharing cryptographic data (`encrypted_pieces`/`decrypted_pieces`). This creates an inconsistent protection model where `GetPreviousTermInformation` filters sensitive fields but `GetRoundInformation` does not, enabling analysis of miner replacement patterns, evil node identification, and punishment history.

### Finding Description

The `GetRoundInformation` view method directly returns the full `Round` object from state storage without any data filtering or obfuscation: [1](#0-0) 

This method simply retrieves the round via `TryToGetRoundInformation`, which directly accesses `State.Rounds[roundNumber]`: [2](#0-1) 

The `Round` protobuf structure contains comprehensive miner information including sensitive fields: [3](#0-2) 

Each `MinerInRound` within the round exposes:
- `missed_time_slots`: Direct evidence of poor performance leading to punishment
- `actual_mining_times`: Precise timing patterns for network analysis
- `encrypted_pieces`/`decrypted_pieces`: Secret sharing cryptographic data
- Performance metrics that reveal evil node identification [4](#0-3) 

**Evidence of Design Intent to Protect Historical Data:**

The codebase demonstrates clear intent to obfuscate sensitive historical information. The `GetPreviousTermInformation` method explicitly filters data, returning only `Pubkey` and `ProducedBlocks`: [5](#0-4) 

Additionally, a `DeleteSecretSharingInformation` method exists specifically to clear sensitive cryptographic data: [6](#0-5) 

A `GetCheckableRound` method provides data sanitization by clearing `EncryptedPieces`, `DecryptedPieces`, `ActualMiningTimes`, and optionally `PreviousInValue`: [7](#0-6) 

**Root Cause:**

The inconsistency arises because `GetPreviousTermInformation` applies filtering logic while `GetRoundInformation` does not. Historical rounds remain in storage for 40,960 rounds before cleanup: [8](#0-7) [9](#0-8) 

**Miner Replacement Detection:**

When evil miners are identified, they are removed from the round and replaced with alternatives: [10](#0-9) 

By querying sequential historical rounds within the same term and comparing `real_time_miners_information` keys, attackers can identify which miners disappeared (evil nodes) and track replacement patterns. The system detects evil miners based on excessive missed time slots: [11](#0-10) 

### Impact Explanation

**Information Disclosed:**
1. **Miner Performance History**: The `missed_time_slots` field directly reveals which miners had poor performance, approaching or exceeding the tolerable threshold of 4,320 missed slots (3 days)
2. **Evil Node Identification**: By comparing miner lists across consecutive rounds in the same term, observers can identify miners that were removed mid-term due to being marked as evil nodes
3. **Timing Patterns**: The `actual_mining_times` field exposes precise block production timestamps enabling network topology analysis and timing-based attacks
4. **Secret Sharing Data**: Historical `encrypted_pieces` and `decrypted_pieces` remain accessible despite the existence of a dedicated deletion method

**Consequences:**
- **Network Analysis**: Attackers can analyze timing patterns to map network topology and identify infrastructure vulnerabilities
- **Targeted Attacks**: Miners with historically poor performance can be targeted for DDoS or social engineering attacks
- **Reputation Damage**: Public disclosure of punishment history could enable reputation attacks against node operators
- **Correlation Attacks**: Timing and performance data could enable correlation of anonymous miner identities with real-world entities

**Severity Justification:**
Low severity because:
- No direct financial loss or fund theft
- No unauthorized state modifications
- No consensus integrity compromise
- Impact limited to information disclosure
- However, the vulnerability is confirmed due to clear evidence of design intent to protect this data (as demonstrated by `GetPreviousTermInformation` filtering)

### Likelihood Explanation

**Attacker Capabilities:**
- Any user can call the public view method `GetRoundInformation` with arbitrary round numbers
- No authentication, authorization, or access control exists
- Method is marked as `is_view = true` in the protobuf definition: [12](#0-11) 

**Attack Complexity:**
- Trivial: Single view method call per round
- No preconditions required
- No transaction fees for view methods
- Can query all rounds from 1 to current round number

**Feasibility:**
- Completely practical and executable immediately
- Attacker can script automated historical round scanning
- All 40,960 kept rounds are accessible: [8](#0-7) 

**Detection Constraints:**
- View method calls typically do not generate events
- Exploitation is passive and undetectable
- No rate limiting or monitoring exists

**Probability:** Very high - the vulnerability is actively exploitable by anyone with basic blockchain query capability.

### Recommendation

**Immediate Fix:**
Apply the same data filtering pattern used in `GetPreviousTermInformation` to `GetRoundInformation` for historical rounds. Modify the function to return sanitized round data:

1. **Filter Sensitive Fields**: Return only non-sensitive fields (`Pubkey`, `ProducedBlocks`, `Order`, `ExpectedMiningTime`) while clearing:
   - `MissedTimeSlots`
   - `ActualMiningTimes`
   - `EncryptedPieces` / `DecryptedPieces`
   - `InValue` / `OutValue` / `Signature` / `PreviousInValue`

2. **Implementation Approach**: Create a helper method similar to `GetCheckableRound` that returns a filtered copy of historical round data, then use it in `GetRoundInformation`:

```
private Round GetFilteredRoundInformation(Round round)
{
    var result = new Round { RoundNumber = round.RoundNumber, TermNumber = round.TermNumber };
    foreach (var minerInRound in round.RealTimeMinersInformation)
    {
        result.RealTimeMinersInformation[minerInRound.Key] = new MinerInRound
        {
            Pubkey = minerInRound.Value.Pubkey,
            ProducedBlocks = minerInRound.Value.ProducedBlocks,
            Order = minerInRound.Value.Order,
            ExpectedMiningTime = minerInRound.Value.ExpectedMiningTime,
            IsExtraBlockProducer = minerInRound.Value.IsExtraBlockProducer
        };
    }
    return result;
}
```

3. **Update GetRoundInformation**:
```
public override Round GetRoundInformation(Int64Value input)
{
    return TryToGetRoundInformation(input.Value, out var round) 
        ? GetFilteredRoundInformation(round) 
        : new Round();
}
```

**Additional Considerations:**
- Consider applying the same filtering to `GetCurrentRoundInformation` if current round data should also be protected
- Document the privacy policy clearly in API documentation
- Add integration tests verifying that historical queries do not expose sensitive fields
- Consider implementing a configurable "recency threshold" where only very recent rounds (e.g., last 3 rounds) return full data while older rounds are filtered

### Proof of Concept

**Initial State:**
- AEDPoS contract is initialized and running
- Multiple rounds have completed with miner replacements occurring
- Some miners have been marked as evil and replaced

**Exploitation Steps:**

1. Query current round number:
```
GetCurrentRoundNumber() → returns current round N
```

2. Query historical round information (e.g., round N-100):
```
GetRoundInformation(N-100) → returns full Round object
```

3. Query subsequent round (N-99):
```
GetRoundInformation(N-99) → returns full Round object
```

4. Analyze differences:
```
Compare round.RealTimeMinersInformation.Keys between N-100 and N-99
If miner pubkey exists in N-100 but not N-99 within same term → evil miner identified
Examine round.RealTimeMinersInformation[pubkey].MissedTimeSlots → see punishment progression
Examine round.RealTimeMinersInformation[pubkey].ActualMiningTimes → analyze timing patterns
```

**Expected Result:**
Filtered round information with sensitive fields cleared (similar to `GetPreviousTermInformation`)

**Actual Result:**
Complete round information including:
- Full miner performance metrics with `missed_time_slots` counts
- Precise `actual_mining_times` timestamps for all miners
- Cryptographic `encrypted_pieces` and `decrypted_pieces`
- Clear indication of miner list changes enabling evil node identification

**Success Condition:**
Attacker successfully reconstructs:
- Complete history of which miners were replaced and when
- Performance degradation timeline for each replaced miner
- Timing patterns for network analysis
- Punishment history showing which nodes approached or exceeded the 4,320 missed slot threshold

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L26-29)
```csharp
    public override Round GetRoundInformation(Int64Value input)
    {
        return TryToGetRoundInformation(input.Value, out var round) ? round : new Round();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L309-342)
```csharp
            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L440-457)
```csharp
    public override Round GetPreviousTermInformation(Int64Value input)
    {
        var lastRoundNumber = State.FirstRoundNumberOfEachTerm[input.Value.Add(1)].Sub(1);
        var round = State.Rounds[lastRoundNumber];
        if (round == null || round.RoundId == 0) return new Round();
        var result = new Round
        {
            TermNumber = input.Value
        };
        foreach (var minerInRound in round.RealTimeMinersInformation)
            result.RealTimeMinersInformation[minerInRound.Key] = new MinerInRound
            {
                Pubkey = minerInRound.Value.Pubkey,
                ProducedBlocks = minerInRound.Value.ProducedBlocks
            };

        return result;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L66-70)
```csharp
    private bool TryToGetRoundInformation(long roundNumber, out Round round)
    {
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L117-123)
```csharp
        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
```

**File:** protobuf/aedpos_contract.proto (L77-80)
```text
    // Get information of the round according to round number.
    rpc GetRoundInformation (google.protobuf.Int64Value) returns (Round) {
        option (aelf.is_view) = true;
    }
```

**File:** protobuf/aedpos_contract.proto (L243-264)
```text
message Round {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producers’ expecting time (second).
    int64 round_id_for_validation = 10;
}
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_GetLighterRound.cs (L7-14)
```csharp
    public void DeleteSecretSharingInformation()
    {
        var encryptedPieces = RealTimeMinersInformation.Values.Select(i => i.EncryptedPieces);
        foreach (var encryptedPiece in encryptedPieces) encryptedPiece.Clear();

        var decryptedPieces = RealTimeMinersInformation.Values.Select(i => i.DecryptedPieces);
        foreach (var decryptedPiece in decryptedPieces) decryptedPiece.Clear();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L10-10)
```csharp
    public const int KeepRounds = 40960;
```
