### Title
Sponsor Fund Misdirection in ReplaceCandidatePubkey Causes Loss of Locked Election Tokens

### Summary
The `ReplaceCandidatePubkey` function blindly copies the sponsor mapping from old to new pubkey without validating whether a sponsor exists. When a candidate announces via `AnnounceElection` (not `AnnounceElectionFor`), the sponsor map is never set. Upon replacement and subsequent `QuitElection`, the locked 100,000 tokens are sent to the address derived from the new pubkey instead of the original sponsor, resulting in permanent fund loss.

### Finding Description

The vulnerability exists in the `PerformReplacement` method called by `ReplaceCandidatePubkey`. At the critical lines, the sponsor mapping is transferred without validation: [1](#0-0) 

The root cause is that when candidates announce via `AnnounceElection`, the `CandidateSponsorMap` is never initialized (only set in `AnnounceElectionFor`): [2](#0-1) 

The locked tokens come from the candidate's address during announcement: [3](#0-2) 

When `QuitElection` is called after replacement, the refund destination is determined by: [4](#0-3) 

Since `CandidateSponsorMap[newPubkey]` is null (copied from the null old value), funds are sent to `Address.FromPublicKey(newPubkey)` instead of the original sponsor at `Address.FromPublicKey(oldPubkey)`.

The candidate information (including the original `AnnouncementTransactionId` that points to the locked funds) is transferred to the new pubkey: [5](#0-4) 

This creates a mismatch: the locked funds virtual address is based on the original announcement, but the recipient address is derived from the new pubkey.

### Impact Explanation

**Direct Fund Loss:** The original sponsor loses exactly 100,000 native tokens (with 8 decimals): [6](#0-5) 

**Who is Affected:** 
- Original sponsors who announced election via `AnnounceElection` (where sponsor mapping is not set)
- The funds are permanently misdirected to an address derived from the new pubkey, which may not be controlled by the original sponsor

**Broken Invariant:** The sponsor tracking mechanism that ensures locked funds are returned to the original depositor is violated. The `CandidateSponsorMap` is designed to track who paid the election fee, but the blind copy operation breaks this tracking for replaced candidates.

**Severity Justification:** Medium severity due to significant fund loss (100,000 tokens) affecting legitimate users during valid operations (key replacement scenarios).

### Likelihood Explanation

**Reachable Entry Point:** The `ReplaceCandidatePubkey` function is publicly accessible and controlled by the candidate admin: [7](#0-6) 

**Feasible Preconditions:**
1. Candidate announces election via `AnnounceElection` (common path, especially for initial miners or self-managed candidates)
2. The candidate admin later calls `ReplaceCandidatePubkey` (legitimate use case for key compromise, loss, or rotation)
3. Eventually `QuitElection` is called to recover locked funds

**Execution Practicality:** All steps are standard operations within the contract's intended functionality. Key replacement is an intentional feature designed for scenarios like:
- Private key compromise requiring emergency key rotation
- Key loss necessitating replacement
- Organizational changes in validator management

**Probability:** Medium - While pubkey replacement is not everyday operation, it is a legitimate and intended feature for handling security incidents and operational changes.

### Recommendation

**Code-Level Mitigation:**
In the `PerformReplacement` method, preserve the original sponsor by deriving it from the old pubkey when the sponsor map is null:

```csharp
// Line 320-321 should be replaced with:
State.CandidateSponsorMap[newPubkey] = State.CandidateSponsorMap[oldPubkey] ?? 
    Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(oldPubkey));
State.CandidateSponsorMap.Remove(oldPubkey);
```

**Invariant Check:**
Add an assertion to verify sponsor tracking is maintained:
```csharp
var originalSponsor = State.CandidateSponsorMap[oldPubkey] ?? 
    Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(oldPubkey));
Assert(originalSponsor != null, "Failed to preserve sponsor information");
State.CandidateSponsorMap[newPubkey] = originalSponsor;
```

**Regression Test:**
Add test case covering:
1. Announce election via `AnnounceElection` (no explicit sponsor)
2. Replace pubkey
3. Verify quit election returns funds to original address

### Proof of Concept

**Initial State:**
- Candidate with `oldPubkey` announces election via `AnnounceElection`
- 100,000 tokens locked from `Address.FromPublicKey(oldPubkey)` to virtual address based on `Context.OriginTransactionId`
- `State.CandidateSponsorMap[oldPubkey]` = null (never set)

**Transaction Sequence:**
1. **AnnounceElection Transaction:**
   - Sender: Address corresponding to oldPubkey
   - Result: Candidate registered, 100,000 tokens locked
   - `CandidateSponsorMap[oldPubkey]` remains null

2. **ReplaceCandidatePubkey Transaction:**
   - Sender: Candidate admin
   - Input: `{ OldPubkey: oldPubkey, NewPubkey: newPubkey }`
   - Execution at line 320: `State.CandidateSponsorMap[newPubkey] = null` (copied from oldPubkey)
   - Result: All state transferred to newPubkey, oldPubkey banned

3. **QuitElection Transaction:**
   - Sender: Candidate admin
   - Input: `{ Value: newPubkey }`
   - Execution at line 245: `To = null ?? Address.FromPublicKey(newPubkeyBytes)`
   - Result: 100,000 tokens sent to `Address.FromPublicKey(newPubkey)`

**Expected vs Actual Result:**
- **Expected:** Tokens returned to `Address.FromPublicKey(oldPubkey)` (original sponsor)
- **Actual:** Tokens sent to `Address.FromPublicKey(newPubkey)` (potentially uncontrolled address)
- **Success Condition:** Original sponsor loses 100,000 tokens if they don't control the new pubkey's corresponding private key

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L237-242)
```csharp
        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L320-321)
```csharp
        State.CandidateSponsorMap[newPubkey] = State.CandidateSponsorMap[oldPubkey];
        State.CandidateSponsorMap.Remove(oldPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L140-140)
```csharp
        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L184-194)
```csharp
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L240-249)
```csharp
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```
