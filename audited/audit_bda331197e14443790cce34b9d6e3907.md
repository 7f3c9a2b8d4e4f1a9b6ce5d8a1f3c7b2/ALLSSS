### Title
Authorization Bypass in Transaction Fee Delegation Setup Allows Forced Delegation and DoS

### Summary
The `SetTransactionFeeDelegateInfos()` and `SetTransactionFeeDelegations()` functions allow any sender to forcibly add themselves as a delegatee for an arbitrary delegator address without requiring authorization from the delegator. This enables attackers to fill up all 24 delegatee slots for victims, preventing legitimate delegation setups and forcing unwanted delegation configurations.

### Finding Description

**Root Cause:**

Both delegation setup functions fail to verify that the caller has authorization from the delegator to establish the delegation relationship:

1. In `SetTransactionFeeDelegateInfos()`, the function uses `Context.Sender` as the delegatee but accepts an arbitrary `input.DelegatorAddress` without any authorization check: [1](#0-0) 

2. Similarly, `SetTransactionFeeDelegations()` exhibits the same flaw: [2](#0-1) 

**Missing Authorization:**

The only validation performed is on the address format and token validity, not on whether the caller is authorized to create delegations for the specified delegator: [3](#0-2) 

**Delegation Slot Limit:**

Each delegator can have a maximum of 24 delegatees per contract/method combination (or 24 total for general delegations), enforced by `DELEGATEE_MAX_COUNT`: [4](#0-3) 

This limit is checked before adding new delegatees: [5](#0-4) 

**Test Confirmation:**

The test suite explicitly demonstrates this unauthorized behavior, where different users can set delegations for other users without consent: [6](#0-5) 

### Impact Explanation

**Authorization Violation:**
Any address can unilaterally establish a delegation relationship with any victim address, violating the fundamental authorization invariant that only authorized parties should modify a user's delegation configuration.

**Denial of Service:**
An attacker can fill all 24 delegatee slots for a victim across multiple contract/method combinations, preventing the victim from adding legitimate delegatees they actually want to delegate fee payments to.

**Operational Griefing:**
Victims must manually remove malicious delegatees using `RemoveTransactionFeeDelegatee()`, incurring gas costs and operational overhead: [7](#0-6) 

**State Pollution:**
Unauthorized delegation entries pollute the contract state and can cause confusion about which delegatees are legitimate versus malicious.

**Severity Justification:**
While this does not result in direct fund theft (delegatees pay from their own balances when used), it constitutes a HIGH severity vulnerability due to:
- Clear authorization bypass violating critical invariants
- Practical DoS attack vector with bounded slots
- Forced state modifications without consent
- Griefing potential requiring gas to remediate

### Likelihood Explanation

**Reachable Entry Point:**
Both functions are public methods callable by any address without special permissions.

**Zero Preconditions:**
The attacker needs only:
- Valid token symbols (which are publicly known)
- Positive delegation amounts (can be minimal, like 1 unit)
- Target victim address

**Attack Complexity:**
Extremely low - a simple transaction with arbitrary `DelegatorAddress` succeeds:
```
SetTransactionFeeDelegateInfos({
  DelegatorAddress: <victim_address>,
  DelegateInfoList: [{ContractAddress: X, MethodName: Y, Delegations: {ELF: 1}}]
})
```

**Economic Rationality:**
Attack costs only transaction fees to fill up victim's 24 slots across multiple contract/method combinations. The attacker pays from their own balance if the delegation is ever used, but they can set minimal amounts to limit potential costs.

**Detection:**
Events are emitted when delegations are added, but victims may not monitor these proactively: [8](#0-7) 

**Probability:**
HIGH - The vulnerability is easily exploitable with no technical barriers.

### Recommendation

**Primary Fix - Add Authorization Check:**

Modify both functions to require that `Context.Sender` equals `input.DelegatorAddress`, ensuring only delegators can set up their own delegations:

```csharp
public override Empty SetTransactionFeeDelegateInfos(SetTransactionFeeDelegateInfosInput input)
{
    Assert(Context.Sender == input.DelegatorAddress, 
        "Only the delegator can set their own delegation configuration.");
    // ... rest of function
}
```

Apply the same fix to `SetTransactionFeeDelegations()`: [9](#0-8) 

**Alternative - Opt-In Model:**

Implement a two-step process where:
1. Delegatee proposes delegation
2. Delegator must explicitly approve via a separate `ApproveDelegation()` function

**Invariant Tests:**

Add test cases to verify:
1. Non-delegator addresses cannot call delegation setup functions for other users
2. Only `Context.Sender == DelegatorAddress` succeeds
3. Unauthorized attempts fail with appropriate error messages

**Cleanup Mechanism:**

Consider adding a `RemoveAllDelegatees()` function to allow delegators to efficiently clear all malicious entries at once.

### Proof of Concept

**Initial State:**
- VictimAddress has 0 delegatees
- AttackerAddress has sufficient balance for transaction fees

**Attack Steps:**

1. Attacker calls `SetTransactionFeeDelegateInfos()` 24 times with different contract/method combinations:
```
For i = 1 to 24:
  SetTransactionFeeDelegateInfos({
    DelegatorAddress: VictimAddress,
    DelegateInfoList: [{
      ContractAddress: Contract_i,
      MethodName: "method",
      Delegations: {ELF: 1}
    }]
  })
```

2. All transactions succeed without authorization from VictimAddress

**Result:**
- VictimAddress now has 24 delegatees (all attacker-controlled)
- Victim cannot add legitimate delegatees due to `DELEGATEE_MAX_COUNT` limit
- Query `GetTransactionFeeDelegateeList()` shows 24 malicious entries

**Expected vs Actual:**
- **Expected:** Only VictimAddress should be able to set their own delegations
- **Actual:** AttackerAddress successfully set delegations for VictimAddress

**Success Condition:**
`GetTransactionFeeDelegateeList(VictimAddress, Contract_i, "method").DelegateeAddresses.Count == 24` with all entries unauthorized.

---

**Notes:**

The vulnerability is confirmed by both code analysis and existing test behavior that demonstrates unauthorized delegation setup. While the delegatee pays fees (not the delegator), the authorization bypass and DoS potential make this a significant security issue requiring immediate remediation. The fix is straightforward: add a sender authorization check at the function entry point.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L12-22)
```csharp
    public override SetTransactionFeeDelegationsOutput SetTransactionFeeDelegations(
        SetTransactionFeeDelegationsInput input)
    {
        AssertValidInputAddress(input.DelegatorAddress);
        Assert(input.Delegations != null, "Delegations cannot be null!");

        // get all delegatees, init it if null.
        var allDelegatees = State.TransactionFeeDelegateesMap[input.DelegatorAddress] ?? new TransactionFeeDelegatees();
        var allDelegateesMap = allDelegatees.Delegatees;

        var delegateeAddress = Context.Sender.ToBase58();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L135-162)
```csharp
    public override Empty RemoveTransactionFeeDelegatee(
        RemoveTransactionFeeDelegateeInput input)
    {
        Assert(input.DelegateeAddress != null, "Delegatee Address cannot be null!");

        if (State.TransactionFeeDelegateesMap[Context.Sender] == null)
        {
            return new Empty();
        }

        if (!State.TransactionFeeDelegateesMap[Context.Sender].Delegatees
                .ContainsKey(input.DelegateeAddress.ToBase58()))
        {
            return new Empty();
        }

        var delegatees = State.TransactionFeeDelegateesMap[Context.Sender];
        delegatees.Delegatees.Remove(input.DelegateeAddress.ToBase58());
        State.TransactionFeeDelegateesMap[Context.Sender] = delegatees;

        Context.Fire(new TransactionFeeDelegationCancelled
        {
            Caller = Context.Sender,
            Delegatee = input.DelegateeAddress,
            Delegator = Context.Sender
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L198-217)
```csharp
    public override Empty SetTransactionFeeDelegateInfos(SetTransactionFeeDelegateInfosInput input)
    {
        Assert(input.DelegatorAddress != null && input.DelegateInfoList.Count > 0,
            "Delegator address and delegate info cannot be null.");
        var toAddTransactionList = new DelegateTransactionList();
        var toUpdateTransactionList = new DelegateTransactionList();
        var toCancelTransactionList = new DelegateTransactionList();
        var delegatorAddress = input.DelegatorAddress;
        foreach (var delegateInfo in input.DelegateInfoList)
        {
            //If isUnlimitedDelegate is false,delegate info list should > 0.
            Assert(delegateInfo.IsUnlimitedDelegate || delegateInfo.Delegations.Count > 0,
                "Delegation cannot be null.");
            Assert(delegateInfo.ContractAddress != null && !string.IsNullOrEmpty(delegateInfo.MethodName),
                "Invalid contract address and method name.");

            var existDelegateeInfoList =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
                    [delegateInfo.MethodName] ?? new TransactionFeeDelegatees();
            var delegateeAddress = Context.Sender.ToBase58();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L226-228)
```csharp
                Assert(existDelegateeList.Count < TokenContractConstants.DELEGATEE_MAX_COUNT,
                    "The quantity of delegatee has reached its limit");
                existDelegateeList.Add(delegateeAddress, new TransactionFeeDelegations());
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L317-326)
```csharp
        if (toAddTransactionList.Value.Count > 0)
        {
            Context.Fire(new TransactionFeeDelegateInfoAdded
            {
                Caller = Context.Sender,
                Delegatee = Context.Sender,
                Delegator = delegatorAddress,
                DelegateTransactionList = toAddTransactionList
            });
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L18-18)
```csharp
    public const int DELEGATEE_MAX_COUNT = 24;
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenDelegationTest.cs (L982-992)
```csharp
        await TokenContractStub.SetTransactionFeeDelegateInfos.SendAsync(new SetTransactionFeeDelegateInfosInput
        {
            DelegatorAddress = User1Address,
            DelegateInfoList = { delegateInfo1 }
        });
        //User2 -> User1
        await TokenContractStubDelegate.SetTransactionFeeDelegateInfos.SendAsync(new SetTransactionFeeDelegateInfosInput
        {
            DelegatorAddress = User1Address,
            DelegateInfoList = { delegateInfo1 }
        });
```
