# Audit Report

## Title
Term Change Detection Failure Due to Unordered ActualMiningTimes Array

## Summary
The `NeedToChangeTerm()` function incorrectly uses unsorted array access to determine consensus term transitions. Miners can exploit this by providing out-of-order timestamps via public consensus methods, causing term change detection to fail and blocking critical governance operations including elections, treasury distributions, and validator updates.

## Finding Description

The `NeedToChangeTerm()` function determines whether the blockchain should transition to a new consensus term by checking if two-thirds of miners have timestamps indicating the term period has elapsed. However, it retrieves each miner's "latest" timestamp using `.Last()` on the `ActualMiningTimes` array without sorting: [1](#0-0) 

The `ActualMiningTimes` field is defined as a `repeated google.protobuf.Timestamp` that stores timestamps in insertion order, not chronological order: [2](#0-1) 

Timestamps are added via simple `.Add()` operations that append to the array without enforcing chronological ordering: [3](#0-2) [4](#0-3) 

The `TimeSlotValidationProvider` validates timestamps but explicitly sorts before retrieving the latest value, indicating developer awareness of ordering issues: [5](#0-4) 

However, this validation only checks if the latest *existing* timestamp falls within time slot bounds - it does not prevent new timestamps from being added out of chronological order. The codebase shows inconsistent handling: `TimeSlotValidationProvider` sorts before access, while `NeedToChangeTerm()` and `ExtractInformationToUpdateConsensus()` use unsorted `.Last()`: [6](#0-5) 

Even logging code explicitly sorts before displaying, confirming the array can be unordered: [7](#0-6) 

**Attack Vector:**

The `UpdateValue` and `UpdateTinyBlockInformation` methods are public RPCs accessible to all miners: [8](#0-7) 

A miner can submit custom `UpdateValueInput` with an `actual_mining_time` value that is chronologically earlier than their previous timestamps but still within their time slot validation bounds. For example, if a miner has timestamps `[100, 110]` and submits timestamp `105`, the array becomes `[100, 110, 105]`. When sorted, the latest is `110`, but `NeedToChangeTerm()` retrieves `105` using `.Last()`, causing incorrect term change calculations.

## Impact Explanation

Term transitions are critical governance operations that trigger multiple essential functions in `ProcessNextTerm()`: [9](#0-8) 

Specifically:

1. **Election System Disruption**: Lines 176-190 update the miner list and term number. If term change is blocked, validator set updates cannot occur, freezing the election system.

2. **Treasury Distribution Failure**: Lines 203-210 trigger treasury reward releases. Delayed term transitions prevent mining reward distribution and treasury operations.

3. **Election Snapshots Missing**: Lines 213-218 create election snapshots for vote counting and reward allocation. Without snapshots, the voting system cannot accurately distribute rewards to voters.

The function requires `MinersCountOfConsent` (typically 2/3 of miners) to have timestamps indicating term change should occur. If attackers manipulate timestamps for even 1/3 + 1 miners to be counted incorrectly, term change is permanently blocked. This freezes consensus governance indefinitely, as subsequent term transitions depend on previous successful transitions.

The impact severity is HIGH because:
- **Consensus integrity**: Core term transition logic fails
- **Governance capture**: Elections and validator updates blocked
- **Economic harm**: Treasury distributions delayed indefinitely
- **Availability**: Critical governance operations become unavailable
- **Cascading failure**: Each blocked term transition prevents future transitions

## Likelihood Explanation

The attack is highly feasible:

**Entry Points**: `UpdateValue` and `UpdateTinyBlockInformation` are public consensus operations accessible to all active miners without additional access controls.

**Preconditions**: Attacker only needs to be in the active miner list, which is a normal state for consensus participants.

**Attack Execution**:
1. Miner produces blocks normally, accumulating timestamps (e.g., `[100, 110]`)
2. When approaching term transition, miner submits `UpdateValue` with `actual_mining_time` set to an earlier value (e.g., `105`)
3. If `105` falls within the miner's time slot window (expectedMiningTime to expectedMiningTime + miningInterval), it passes `TimeSlotValidationProvider` bounds checking
4. Array becomes `[100, 110, 105]` - unordered
5. `NeedToChangeTerm()` retrieves `105` instead of `110`, potentially causing incorrect term change decision

**Feasibility Factors**:
- **Complexity**: Low - simply provide timestamp parameter within valid range
- **Detection**: Difficult - all timestamps appear legitimate within time slot bounds
- **Cost**: Negligible - normal block production cost
- **Collusion**: Only requires compromising 1/3 + 1 miners to block term change

The vulnerability could even occur naturally through clock skew, network delays, or block propagation timing variations, though deliberate exploitation by malicious miners is more concerning.

## Recommendation

Enforce chronological ordering when adding timestamps to `ActualMiningTimes`:

**Option 1**: Validate new timestamp is after previous maximum:
```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    
    // Add validation
    var latestExisting = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
    if (latestExisting != null && updateValueInput.ActualMiningTime <= latestExisting)
    {
        Assert(false, "New timestamp must be after previous timestamps");
    }
    
    minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
    // ... rest of method
}
```

**Option 2**: Always sort before using `.Last()` in `NeedToChangeTerm()`:
```csharp
public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
{
    return RealTimeMinersInformation.Values
               .Where(m => m.ActualMiningTimes.Any())
               .Select(m => m.ActualMiningTimes.OrderBy(t => t).Last())  // Add sorting
               .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                   t, currentTermNumber, periodSeconds))
           >= MinersCountOfConsent;
}
```

**Option 3** (Most robust): Store ActualMiningTimes as a sorted collection or maintain a separate "latest timestamp" field that is properly validated on updates.

Apply the same fix to other locations using unsorted `.Last()`:
- `ExtractInformationToUpdateConsensus()` (Round_ExtractInformationToUpdateConsensus.cs line 42)
- `GenerateTransactionListByExtraData()` (AEDPoSContract_ACS4_ConsensusInformationProvider.cs line 157)
- View methods (AEDPoSContract_ViewMethods.cs line 202)

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task TermChangeDetection_FailsWithUnorderedTimestamps()
{
    // Setup: Create a round with 3 miners
    var round = new Round
    {
        RoundNumber = 1,
        TermNumber = 1,
        RealTimeMinersInformation =
        {
            ["miner1"] = new MinerInRound
            {
                Pubkey = "miner1",
                ActualMiningTimes = { 
                    Timestamp.FromDateTime(DateTime.UtcNow.AddSeconds(100)),
                    Timestamp.FromDateTime(DateTime.UtcNow.AddSeconds(110)),
                    Timestamp.FromDateTime(DateTime.UtcNow.AddSeconds(105)) // Out of order!
                }
            },
            ["miner2"] = new MinerInRound
            {
                Pubkey = "miner2",
                ActualMiningTimes = { 
                    Timestamp.FromDateTime(DateTime.UtcNow.AddSeconds(100)),
                    Timestamp.FromDateTime(DateTime.UtcNow.AddSeconds(112))
                }
            },
            ["miner3"] = new MinerInRound
            {
                Pubkey = "miner3",
                ActualMiningTimes = { 
                    Timestamp.FromDateTime(DateTime.UtcNow.AddSeconds(100)),
                    Timestamp.FromDateTime(DateTime.UtcNow.AddSeconds(111))
                }
            }
        }
    };

    var blockchainStart = Timestamp.FromDateTime(DateTime.UtcNow);
    var periodSeconds = 10L;
    
    // NeedToChangeTerm uses .Last() without sorting
    // For miner1: .Last() returns 105 (wrong) instead of 110 (correct)
    // This causes incorrect term change calculation
    var needsTermChange = round.NeedToChangeTerm(blockchainStart, 1, periodSeconds);
    
    // Expected: Should detect term change based on timestamps 110, 112, 111
    // Actual: May fail due to miner1's timestamp being read as 105
    // Result: Term transition is incorrectly blocked
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** protobuf/aedpos_contract.proto (L30-43)
```text
    rpc UpdateValue (UpdateValueInput) returns (google.protobuf.Empty) {
    }

    // Update consensus information, create a new round.
    rpc NextRound (NextRoundInput) returns (google.protobuf.Empty) {
    }

    // Update consensus information, create a new term.
    rpc NextTerm (NextTermInput) returns (google.protobuf.Empty) {
    }

    // Update consensus tiny block information.
    rpc UpdateTinyBlockInformation (TinyBlockInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/aedpos_contract.proto (L292-292)
```text
    repeated google.protobuf.Timestamp actual_mining_times = 13;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L304-304)
```csharp
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L42-42)
```csharp
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_GetLogs.cs (L39-46)
```csharp
            var actualMiningTimes = minerInRound.ActualMiningTimes.OrderBy(t => t).Select(t =>
            {
                if (t < roundStartTime)
                    return
                        $"{t.ToDateTime().ToUniversalTime():yyyy-MM-dd HH.mm.ss,ffffff} (For Extra Block Slot Of Previous Round)";

                return t.ToDateTime().ToUniversalTime().ToString("yyyy-MM-dd HH.mm.ss,ffffff");
            });
```
