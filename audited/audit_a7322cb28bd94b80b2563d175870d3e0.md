### Title
Missing Hash Validation in SetTreasurySchemeIdsToElectionContract Allows Invalid Profit Scheme Configuration

### Summary
The `SetTreasurySchemeIdsToElectionContract()` function retrieves profit scheme IDs from Treasury and Election contracts without validating that the arrays exist, have sufficient elements, or contain non-empty hashes. This lack of defensive validation could cause profit distribution system failure if initialization occurs out of order or Treasury initialization is incomplete.

### Finding Description

The vulnerability exists in the `SetTreasurySchemeIdsToElectionContract()` function which is called during Economic contract initialization: [1](#0-0) 

The function has multiple validation gaps:

1. **No null checking**: `GetManagingSchemeIds` can return null if the manager has no schemes created, but the code directly accesses `.SchemeIds` without null validation. [2](#0-1) 

2. **No array bounds checking**: The code accesses indices [0,3,4] for Treasury and [0,1] for Election without verifying these indices exist in the returned arrays.

3. **No empty hash validation**: Even if arrays exist with correct length, individual Hash values could be `Hash.Empty` or null, and there's no validation before storing them.

4. **Recipient validation missing**: The Election contract's `SetTreasurySchemeIds` method only checks if the values were previously set, but doesn't validate the input hashes are non-empty: [3](#0-2) 

The root cause is the assumption that Treasury initialization has completed successfully before Economic initialization, but this dependency is not enforced in code.

### Impact Explanation

The stored scheme IDs (`SubsidyHash` and `WelfareHash`) are actively used in profit distribution during term snapshots: [4](#0-3) 

If invalid (null or empty) hashes are stored:
- `DistributeProfits` calls will fail with scheme not found errors
- Election rewards cannot be distributed to candidates and voters
- Economic incentive system becomes non-functional
- Accumulated rewards remain locked in profit schemes

This creates an **Operational DoS** of the entire economic distribution system, affecting all network participants expecting rewards.

### Likelihood Explanation

The vulnerability requires specific preconditions:

1. **Out-of-order initialization**: Economic contract `InitialEconomicSystem` called before Treasury contract completes both `InitialTreasuryContract` and `InitialMiningRewardProfitItem`. [5](#0-4) 

2. **Partial Treasury failure**: Treasury creates schemes but fails during the `ResetManager` calls that transfer schemes to Election contract.

While initialization order is typically controlled by deployment orchestration, the code itself contains no defensive checks. The initialization providers operate independently: [6](#0-5) [7](#0-6) 

**Likelihood: Medium** - Requires deployment ordering issues but code lacks safeguards.

### Recommendation

Add comprehensive validation in `SetTreasurySchemeIdsToElectionContract()`:

```csharp
private void SetTreasurySchemeIdsToElectionContract()
{
    State.ProfitContract.Value = Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
    
    var treasurySchemes = State.ProfitContract.GetManagingSchemeIds.Call(
        new GetManagingSchemeIdsInput
        {
            Manager = Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)
        });
    Assert(treasurySchemes != null, "Treasury schemes not found.");
    Assert(treasurySchemes.SchemeIds.Count >= 5, "Insufficient treasury schemes.");
    
    var electionSchemes = State.ProfitContract.GetManagingSchemeIds.Call(
        new GetManagingSchemeIdsInput
        {
            Manager = Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName)
        });
    Assert(electionSchemes != null, "Election schemes not found.");
    Assert(electionSchemes.SchemeIds.Count >= 2, "Insufficient election schemes.");
    
    var treasuryHash = treasurySchemes.SchemeIds[0];
    var welcomeHash = treasurySchemes.SchemeIds[3];
    var flexibleHash = treasurySchemes.SchemeIds[4];
    var subsidyHash = electionSchemes.SchemeIds[0];
    var welfareHash = electionSchemes.SchemeIds[1];
    
    Assert(treasuryHash != null && treasuryHash != Hash.Empty, "Invalid treasury hash.");
    Assert(welcomeHash != null && welcomeHash != Hash.Empty, "Invalid welcome hash.");
    Assert(flexibleHash != null && flexibleHash != Hash.Empty, "Invalid flexible hash.");
    Assert(subsidyHash != null && subsidyHash != Hash.Empty, "Invalid subsidy hash.");
    Assert(welfareHash != null && welfareHash != Hash.Empty, "Invalid welfare hash.");
    
    State.ElectionContract.SetTreasurySchemeIds.Send(new SetTreasurySchemeIdsInput
    {
        TreasuryHash = treasuryHash,
        WelcomeHash = welcomeHash,
        FlexibleHash = flexibleHash,
        SubsidyHash = subsidyHash,
        WelfareHash = welfareHash
    });
}
```

Additionally, add validation in Election contract's `SetTreasurySchemeIds` to reject empty hashes as a defense-in-depth measure.

Add integration tests verifying initialization failure scenarios are handled gracefully.

### Proof of Concept

**Scenario: Economic initialization before Treasury completion**

1. **Initial State**: Contracts deployed but Treasury not fully initialized
   - Treasury contract deployed
   - `InitialTreasuryContract` called (creates 7 schemes)
   - `InitialMiningRewardProfitItem` NOT yet called (schemes not transferred to Election)

2. **Trigger**: Call `InitialEconomicSystem` on Economic contract

3. **Execution Path**:
   - Economic contract calls `SetTreasurySchemeIdsToElectionContract()`
   - `GetManagingSchemeIds` for Election returns null or empty array (no schemes transferred yet)
   - Code attempts to access `schemeIdsManagingByElectionContract[0]` 
   - **Result**: `IndexOutOfRangeException` or `NullReferenceException`

4. **Impact**: Economic contract initialization fails, native token creation incomplete, entire economic system non-functional

**Scenario: Partial Treasury initialization**

1. **Initial State**: 
   - Treasury creates schemes but `ResetManager` fails for Election schemes
   - Election `ManagingSchemeIds` remains empty

2. **Trigger**: `InitialEconomicSystem` proceeds

3. **Result**: Same exception as above, economic system initialization failure

**Success Condition**: System fails to initialize rather than silently storing invalid configuration, but lack of validation means system state is inconsistent.

### Citations

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L187-209)
```csharp
    private void SetTreasurySchemeIdsToElectionContract()
    {
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
        var schemeIdsManagingByTreasuryContract = State.ProfitContract.GetManagingSchemeIds.Call(
            new GetManagingSchemeIdsInput
            {
                Manager = Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)
            }).SchemeIds;
        var schemeIdsManagingByElectionContract = State.ProfitContract.GetManagingSchemeIds.Call(
            new GetManagingSchemeIdsInput
            {
                Manager = Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName)
            }).SchemeIds;
        State.ElectionContract.SetTreasurySchemeIds.Send(new SetTreasurySchemeIdsInput
        {
            TreasuryHash = schemeIdsManagingByTreasuryContract[0],
            WelcomeHash = schemeIdsManagingByTreasuryContract[3],
            FlexibleHash = schemeIdsManagingByTreasuryContract[4],
            SubsidyHash = schemeIdsManagingByElectionContract[0],
            WelfareHash = schemeIdsManagingByElectionContract[1]
        });
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L12-15)
```csharp
    public override CreatedSchemeIds GetManagingSchemeIds(GetManagingSchemeIdsInput input)
    {
        return State.ManagingSchemeIds[input.Manager];
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L162-171)
```csharp
    public override Empty SetTreasurySchemeIds(SetTreasurySchemeIdsInput input)
    {
        Assert(State.TreasuryHash.Value == null, "Treasury profit ids already set.");
        State.TreasuryHash.Value = input.TreasuryHash;
        State.WelfareHash.Value = input.WelfareHash;
        State.SubsidyHash.Value = input.SubsidyHash;
        State.WelcomeHash.Value = input.WelcomeHash;
        State.FlexibleHash.Value = input.FlexibleHash;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L442-454)
```csharp
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.SubsidyHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.WelfareHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L80-121)
```csharp
    public override Empty InitialMiningRewardProfitItem(Empty input)
    {
        Assert(State.TreasuryHash.Value == null, "Already initialized.");
        var managingSchemeIds = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = Context.Self
        }).SchemeIds;

        Assert(managingSchemeIds.Count == 7, "Incorrect schemes count.");

        State.TreasuryHash.Value = managingSchemeIds[0];
        State.RewardHash.Value = managingSchemeIds[1];
        State.SubsidyHash.Value = managingSchemeIds[2];
        State.WelfareHash.Value = managingSchemeIds[3];
        State.BasicRewardHash.Value = managingSchemeIds[4];
        State.VotesWeightRewardHash.Value = managingSchemeIds[5];
        State.ReElectionRewardHash.Value = managingSchemeIds[6];

        var electionContractAddress =
            Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName);
        if (electionContractAddress != null)
        {
            State.ProfitContract.ResetManager.Send(new ResetManagerInput
            {
                SchemeId = managingSchemeIds[2],
                NewManager = electionContractAddress
            });
            State.ProfitContract.ResetManager.Send(new ResetManagerInput
            {
                SchemeId = managingSchemeIds[3],
                NewManager = electionContractAddress
            });
        }

        BuildTreasury();

        var treasuryVirtualAddress = Address.FromPublicKey(State.ProfitContract.Value.Value.Concat(
            managingSchemeIds[0].Value.ToByteArray().ComputeHash()).ToArray());
        State.TreasuryVirtualAddress.Value = treasuryVirtualAddress;

        return new Empty();
    }
```

**File:** src/AElf.EconomicSystem/TreasuryContractInitializationProvider.cs (L15-30)
```csharp
    public List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        return new List<ContractInitializationMethodCall>
        {
            new()
            {
                MethodName = nameof(TreasuryContractContainer.TreasuryContractStub.InitialTreasuryContract),
                Params = ByteString.Empty
            },
            new()
            {
                MethodName = nameof(TreasuryContractContainer.TreasuryContractStub.InitialMiningRewardProfitItem),
                Params = ByteString.Empty
            }
        };
    }
```

**File:** src/AElf.EconomicSystem/EconomicContractInitializationProvider.cs (L31-62)
```csharp
    public List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        return new List<ContractInitializationMethodCall>
        {
            new()
            {
                MethodName = nameof(EconomicContractContainer.EconomicContractStub.InitialEconomicSystem),
                Params = new InitialEconomicSystemInput
                {
                    NativeTokenDecimals = _economicOptions.Decimals,
                    IsNativeTokenBurnable = _economicOptions.IsBurnable,
                    NativeTokenSymbol = _economicOptions.Symbol,
                    NativeTokenName = _economicOptions.TokenName,
                    NativeTokenTotalSupply = _economicOptions.TotalSupply,
                    MiningRewardTotalAmount =
                        Convert.ToInt64(_economicOptions.TotalSupply * _economicOptions.DividendPoolRatio),
                    TransactionSizeFeeUnitPrice = _economicOptions.TransactionSizeFeeUnitPrice
                }.ToByteString()
            },
            new()
            {
                MethodName = nameof(EconomicContractContainer.EconomicContractStub.IssueNativeToken),
                Params = new IssueNativeTokenInput
                {
                    Amount = Convert.ToInt64(_economicOptions.TotalSupply * (1 - _economicOptions.DividendPoolRatio)),
                    To = Address.FromPublicKey(
                        ByteArrayHelper.HexStringToByteArray(_consensusOptions.InitialMinerList.First())),
                    Memo = "Issue native token"
                }.ToByteString()
            }
        };
    }
```
