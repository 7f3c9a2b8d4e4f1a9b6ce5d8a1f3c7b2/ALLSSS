# Audit Report

## Title
Secret Sharing Information Permanently Stored On-Chain Enabling Retrospective InValue Recovery

## Summary
The AEDPoS consensus contract stores encrypted and decrypted secret sharing pieces in persistent blockchain storage (`State.Rounds`) but only removes them from block headers. This allows anyone to query historical round information via the public `GetRoundInformation` view method and recover miners' secret InValues using the stored decrypted pieces, completely undermining the secret sharing security mechanism designed to protect consensus randomness.

## Finding Description

The vulnerability exists due to a critical disconnect between what data is stored persistently versus what data is cleaned up:

**Storage Path:** When miners produce blocks, the `ProcessUpdateValue` method processes consensus updates. It calls `PerformSecretSharing` which adds encrypted_pieces and decrypted_pieces to the Round object's miner information. [1](#0-0) [2](#0-1) 

This Round object (containing all secret pieces) is then persisted to blockchain state via `TryToUpdateRoundInformation`. [3](#0-2) [4](#0-3) 

**Deletion Path:** The `DeleteSecretSharingInformation()` method clears encrypted and decrypted pieces from Round objects. [5](#0-4) 

However, this method is ONLY called when generating consensus block extra data for headers (not during transaction processing), and it operates on a copy of the Round object being returned in the header - not the already-persisted state in `State.Rounds`. [6](#0-5) 

**Exposure Path:** The public view method `GetRoundInformation` directly returns Round objects from `State.Rounds[roundNumber]` without any filtering of secret sharing information. [7](#0-6) 

**Recovery Mechanism:** The contract itself demonstrates how to recover InValues from decrypted pieces using `SecretSharingHelper.DecodeSecret`, requiring only 2/3 threshold of miners' decrypted pieces. [8](#0-7) 

The protobuf definition confirms that `encrypted_pieces` and `decrypted_pieces` are stored as part of `MinerInRound` within the Round structure. [9](#0-8) 

## Impact Explanation

This vulnerability has **HIGH severity** impact on consensus integrity:

1. **Secret Sharing Security Broken**: The entire purpose of the secret sharing mechanism is defeated. InValues are meant to remain secret until explicitly revealed by the protocol, but all decrypted pieces (which can reconstruct the InValue) are permanently stored on-chain in accessible storage.

2. **Retrospective Analysis**: Any party can reconstruct past InValues by querying historical rounds and using the publicly available recovery algorithm with the stored decrypted pieces. This enables analysis of all consensus randomness since deployment.

3. **Consensus Predictability**: InValues are used for random number generation in consensus through VRF mechanisms. Recovering past InValues could enable analysis of consensus behavior patterns and potentially predict future randomness if there are implementation weaknesses in InValue generation or if patterns emerge.

4. **Protocol-Wide Exposure**: This affects all consensus rounds where secret sharing is enabled. Historical round data persists for multiple rounds (controlled by `AEDPoSContractConstants.KeepRounds`), meaning the exposure window is significant. [10](#0-9) 

The impact is concrete because the secret sharing mechanism is explicitly designed to protect InValues through cryptographic splitting and this vulnerability completely bypasses that protection by permanently storing the reconstruction keys on-chain.

## Likelihood Explanation

The likelihood of exploitation is **VERY HIGH**:

1. **Zero Barrier Entry**: `GetRoundInformation` is a public view method defined in the contract with no authentication or permission checks. Any user or observer can call it.

2. **Trivial Execution**: Exploitation requires only three simple steps:
   - Query `GetRoundInformation(roundNumber)` for any past round
   - Extract `DecryptedPieces` from the returned Round object's miner information
   - Apply the publicly available `SecretSharingHelper.DecodeSecret` algorithm with 2/3 threshold

3. **No Detection**: Querying view methods is a read-only operation that leaves no transaction trace on the blockchain, making exploitation completely undetectable.

4. **Zero Cost**: View methods are free to call and require no transaction fees or gas payments.

5. **Always Available**: The data persists in `State.Rounds` for multiple rounds before cleanup, providing a wide window of exposure for recent consensus rounds.

The attack is not theoretical - the contract storage structure, view method exposure, and recovery algorithm implementation are all confirmed in the production codebase.

## Recommendation

Implement proper cleanup of secret sharing information from persistent storage:

1. **Immediate Fix**: Modify `TryToUpdateRoundInformation` or create a new method to clear encrypted_pieces and decrypted_pieces from Round objects before persisting them to `State.Rounds`, or immediately after persistence once they're no longer needed for consensus validation.

2. **Alternative Approach**: Filter the Round object returned by `GetRoundInformation` to remove secret sharing fields before returning to callers, ensuring historical data queries don't expose sensitive cryptographic material.

3. **Architectural Fix**: Store secret sharing information in separate state variables with explicit cleanup logic, rather than embedding it in the Round structure that gets persisted long-term.

The fix should ensure that while secret pieces may be needed temporarily during consensus processing, they are purged from persistent storage once their consensus purpose is fulfilled.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

1. A miner produces a block during normal consensus operation, which triggers `ProcessUpdateValue`
2. Secret sharing pieces are stored via `PerformSecretSharing` and persisted via `TryToUpdateRoundInformation` to `State.Rounds[roundNumber]`
3. An external observer (not a miner) calls the public view method `GetRoundInformation(roundNumber)`
4. The returned Round object contains full `DecryptedPieces` for all miners
5. The observer extracts decrypted pieces and applies `SecretSharingHelper.DecodeSecret` with the orders and 2/3 threshold
6. The original InValue is successfully recovered, breaking the confidentiality guarantee

No special privileges, transaction fees, or complex operations are required - just a simple view call and application of the public recovery algorithm.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L118-123)
```csharp
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L126-132)
```csharp
    private bool TryToUpdateRoundInformation(Round round)
    {
        var ri = State.Rounds[round.RoundNumber];
        if (ri == null) return false;
        State.Rounds[round.RoundNumber] = round;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_GetLighterRound.cs (L7-14)
```csharp
    public void DeleteSecretSharingInformation()
    {
        var encryptedPieces = RealTimeMinersInformation.Values.Select(i => i.EncryptedPieces);
        foreach (var encryptedPiece in encryptedPieces) encryptedPiece.Clear();

        var decryptedPieces = RealTimeMinersInformation.Values.Select(i => i.DecryptedPieces);
        foreach (var decryptedPiece in decryptedPieces) decryptedPiece.Clear();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L50-50)
```csharp
        if (!isGeneratingTransactions) information.Round.DeleteSecretSharingInformation();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L26-29)
```csharp
    public override Round GetRoundInformation(Int64Value input)
    {
        return TryToGetRoundInformation(input.Value, out var round) ? round : new Round();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-53)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
```

**File:** protobuf/aedpos_contract.proto (L293-296)
```text
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
```
