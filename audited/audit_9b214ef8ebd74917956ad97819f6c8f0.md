### Title
Unvalidated LIB Height/Round Correspondence in NextRound and NextTerm Transitions Enables State Corruption

### Summary
The `LibInformationValidationProvider` only validates LIB (Last Irreversible Block) information for `UpdateValue` behavior, but not for `NextRound` or `NextTerm` behaviors. While `UpdateValue` recalculates LIB values internally, `NextRound` and `NextTerm` directly store the provided LIB values to state without validation, allowing a malicious extra block producer to inject mismatched `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` pairs that corrupt the consensus state and trigger operational disruption.

### Finding Description

The vulnerability exists in the validation logic for consensus behaviors. The `LibInformationValidationProvider` validates that LIB values do not go backwards: [1](#0-0) 

However, this validator is only applied to `UpdateValue` behavior, not to `NextRound` or `NextTerm`: [2](#0-1) 

For `UpdateValue`, the provided LIB values are validated but then discarded and recalculated using `LastIrreversibleBlockHeightCalculator`: [3](#0-2) 

However, for `NextRound` and `NextTerm`, the provided LIB values are extracted from the consensus header and included in the input: [4](#0-3) 

These values are then converted back to a Round object and stored directly to state via `AddRoundInformation`: [5](#0-4) 

The validators for `NextRound` (`NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider`) only check mining order and round number increment, but do not validate LIB values. There is no check ensuring that `ConfirmedIrreversibleBlockRoundNumber` corresponds to the actual round at `ConfirmedIrreversibleBlockHeight`.

### Impact Explanation

**Operational DoS Impact**: The corrupted LIB values directly affect `GetMaximumBlocksCount`, which evaluates blockchain mining status based on the round number difference: [6](#0-5) 

By providing an artificially low `ConfirmedIrreversibleBlockRoundNumber` (e.g., 1 instead of the actual 50), an attacker can make the system calculate a large difference `currentRoundNumber - libRoundNumber`, triggering:
- **Abnormal status**: Reduces maximum blocks per miner based on a false crisis formula
- **Severe status**: Limits all miners to 1 block each and fires `IrreversibleBlockHeightUnacceptable` event, which can trigger chain rollback procedures

**Cross-Chain Impact**: Cross-chain indexing operations rely on accurate LIB values for finality guarantees. Corrupted LIB values could cause cross-chain data to be indexed at incorrect heights, affecting the security of cross-chain asset transfers and message passing.

**Persistence**: The incorrect LIB values propagate to subsequent rounds via `GenerateNextRoundInformation`: [7](#0-6) 

This means the corruption persists until manually corrected through governance or a proper NextRound block with correct values is produced.

### Likelihood Explanation

**Attacker Capabilities**: The attacker must be the extra block producer for the current round, which rotates among miners. With N miners, the probability is 1/N per round. In typical AELf configurations with 17-21 miners, a malicious miner becomes extra block producer every 17-21 rounds on average.

**Attack Complexity**: Low. The attacker:
1. Calls `GetConsensusExtraData` to obtain legitimate next round information
2. Modifies `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` to mismatched values
3. Produces the NextRound/NextTerm block with modified data
4. Validation passes (no LIB validation for these behaviors)
5. Corrupted values stored to state

**Detection**: The attack would be detected when:
- Miners notice LIB is not advancing properly
- Blockchain enters false Abnormal/Severe status
- Cross-chain operations fail due to incorrect LIB references
However, by this point, damage has occurred and requires corrective action.

**Economic Rationality**: The attack cost is minimal (one block production opportunity). The attacker could be motivated by:
- Disrupting competitor chains in a multi-chain ecosystem
- Griefing/DoS without direct financial gain
- Creating chaos to execute other attacks during recovery

### Recommendation

**Immediate Fix**: Apply `LibInformationValidationProvider` to all consensus behaviors that use provided LIB values:

```csharp
// In AEDPoSContract_Validation.cs, line 77-92
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        break;
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
}
```

**Additional Invariant Check**: Enhance `LibInformationValidationProvider` to verify height/round correspondence by checking that the provided values match the expected values from `GenerateNextRoundInformation` for NextRound/NextTerm behaviors. This requires access to the generated round during validation to compare against provided values.

**Test Cases**:
1. Test NextRound with mismatched LIB values (should fail validation)
2. Test NextTerm with artificially low LIB round number (should fail validation)
3. Test that correct LIB propagation from current to next round is enforced
4. Test that GetMaximumBlocksCount cannot be manipulated via incorrect LIB values

### Proof of Concept

**Initial State**:
- Current blockchain height: 1000
- Current round number: 50
- Current round LIB: height=950, roundNumber=48
- Malicious miner is designated extra block producer

**Attack Steps**:
1. Extra block producer calls `GetConsensusExtraData` for NextRound behavior
2. Receives correct next round with `ConfirmedIrreversibleBlockHeight=950, ConfirmedIrreversibleBlockRoundNumber=48`
3. Attacker modifies to `ConfirmedIrreversibleBlockHeight=100, ConfirmedIrreversibleBlockRoundNumber=1`
4. Produces NextRound block with modified values
5. Validation passes (`NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` do not check LIB)
6. `ProcessNextRound` stores corrupted round to state via `AddRoundInformation`

**Expected Result**: Validation should reject the block due to incorrect LIB values

**Actual Result**: 
- Block accepted, corrupted LIB stored to state
- Next time `GetMaximumBlocksCount` executes:
  - `libRoundNumber = 1`
  - `currentRoundNumber = 51`
  - Difference = 50 (>>= SevereStatusRoundsThreshold of 8)
  - Triggers Severe status
  - Fires `IrreversibleBlockHeightUnacceptable` event
  - All miners limited to 1 block each
- Chain enters degraded mode until LIB corrected

**Success Condition**: Blockchain enters false Severe status, limiting all miners to 1 block production, demonstrating successful operational DoS via LIB corruption.

### Notes

The vulnerability specifically affects NextRound and NextTerm behaviors because UpdateValue behavior recalculates LIB values internally rather than using the provided values. The root cause is the asymmetric application of validation logic across different consensus behaviors, where the assumption that "provided values will be correct" holds for UpdateValue (because they're recalculated) but not for NextRound/NextTerm (where they're directly stored).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L8-34)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-79)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }

        if (!State.IsPreviousBlockInSevereStatus.Value)
            return AEDPoSContractConstants.MaximumTinyBlocksCount;

        Context.Fire(new IrreversibleBlockHeightUnacceptable
        {
            DistanceToIrreversibleBlockHeight = 0
        });
        State.IsPreviousBlockInSevereStatus.Value = false;

        return AEDPoSContractConstants.MaximumTinyBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```
