### Title
Unbounded Loop in Side Chain Enumeration Causes DoS When Side Chain Count Exceeds Execution Threshold

### Summary
The `GetSideChainIdAndHeight` and `GetAllChainsIdAndHeight` view methods contain an unbounded loop that iterates through all side chain serial numbers without any maximum limit check. When the number of created side chains (including terminated ones) approaches the system's `ExecutionBranchThreshold` of 15,000, these critical view methods will fail, breaking the cross-chain indexing functionality that depends on them.

### Finding Description

**Root Cause:**

The `GetSideChainIdAndHeight` method iterates through all side chain serial numbers from 1 to `State.SideChainSerialNumber.Value`: [1](#0-0) 

The `SideChainSerialNumber` is incremented with each side chain creation and never decreases, even when chains are terminated: [2](#0-1) 

**Why Protections Fail:**

1. **No Maximum Limit:** There is no check in `CreateSideChain` that validates whether creating another side chain would exceed safe operational limits.

2. **Execution Branch Threshold:** AElf enforces a default `ExecutionBranchThreshold` of 15,000 branches per transaction: [3](#0-2) 

When this threshold is exceeded, the execution observer throws an exception: [4](#0-3) 

3. **Terminated Chains Still Counted:** Even though terminated chains are skipped with `continue`, the loop still iterates through their serial numbers, consuming branch count.

4. **Critical Dependency:** The cross-chain indexing service depends on `GetAllChainsIdAndHeight` to retrieve chain height information: [5](#0-4) 

**Execution Path:**

1. Side chains are created through parliament-approved proposals via `CreateSideChain`
2. Each creation increments `SideChainSerialNumber` permanently
3. Cross-chain indexing service calls `GetAllChainIdHeightPairsAtLibAsync`
4. This internally calls `GetAllChainsIdAndHeight` which calls `GetSideChainIdAndHeight`
5. When serial number approaches 15,000, the loop exceeds `ExecutionBranchThreshold`
6. Method throws `RuntimeBranchThresholdExceededException`, breaking cross-chain indexing

### Impact Explanation

**Concrete Harm:**

Once approximately 15,000 side chains have been created (even if many are terminated), the following critical functionality becomes permanently unusable:

1. **Cross-Chain Indexing Failure:** The indexing service cannot retrieve chain heights, halting all cross-chain block data indexing
2. **View Method Unavailability:** `GetSideChainIdAndHeight` and `GetAllChainsIdAndHeight` become uncallable
3. **System-Wide Impact:** Cross-chain verification and synchronization stops working

**Who is Affected:**

- All side chains lose ability to be indexed by the main chain
- Parent chain indexing may also be affected (via `GetAllChainsIdAndHeight`)
- Users cannot perform cross-chain operations
- The entire cross-chain infrastructure becomes non-functional

**Severity Justification:**

While this doesn't directly steal funds, it represents a **complete operational DoS** of the cross-chain functionality with no recovery mechanism, as the serial number cannot be decreased and terminated chains cannot be removed from the enumeration.

### Likelihood Explanation

**Attacker Capabilities Required:**

- Control or influence over parliament organization to approve side chain creation proposals
- Sufficient locked tokens for each side chain (amount specified in `LockedTokenAmount`)

**Attack Complexity:**

Creating 15,000 side chains requires:
- 15,000 parliament-approved proposals
- Each proposal requires validation checks: [6](#0-5) 

- Locked tokens for each chain
- Time to process all proposals

**Feasibility Conditions:**

1. **Malicious Attack:** Requires compromised or malicious parliament, making it detectable but feasible if governance is captured
2. **Gradual Accumulation:** More realistically, legitimate growth over years could naturally reach this limit
3. **Economic Cost:** Very expensive (15,000 Ã— locked token amount), but economically rational for a well-resourced attacker seeking to permanently disable cross-chain functionality

**Detection/Operational Constraints:**

- Parliament members would notice repeated side chain creation proposals
- Blockchain analytics would show the pattern
- However, if spread over time or legitimately needed, detection becomes harder

**Probability:** MEDIUM - While requiring parliament approval (reducing likelihood), the lack of any maximum limit means this is inevitable given sufficient time or a determined attacker with governance control.

### Recommendation

**Immediate Mitigation:**

1. Add a maximum side chain limit constant in the constants file:

```csharp
private const long MaximumSideChainCount = 1000; // or appropriate limit based on system design
```

2. Add validation in `CreateSideChain`:

```csharp
Assert(State.SideChainSerialNumber.Value < MaximumSideChainCount, 
    "Maximum side chain limit reached.");
```

3. Consider implementing a cleanup mechanism to remove terminated chains from enumeration, or maintain a separate collection of only active chain IDs.

**Long-term Fix:**

Replace the loop-based enumeration with a maintained collection of active chain IDs:

```csharp
// Add to state
public MappedState<int, bool> ActiveSideChainIds { get; set; }

// Update in CreateSideChain
State.ActiveSideChainIds[chainId] = true;

// Update in DisposeSideChain  
State.ActiveSideChainIds[chainId] = false;

// Modify GetSideChainIdAndHeight to iterate only active chains
```

**Test Cases:**

1. Test that side chain creation fails when approaching the maximum limit
2. Test `GetSideChainIdAndHeight` performance with maximum allowed chains
3. Test that terminated chains don't contribute to the limit (if using active collection approach)

### Proof of Concept

**Initial State:**
- Cross-chain contract initialized
- Parliament organization configured with controlled members

**Attack Sequence:**

1. Create 15,000 side chain proposals through parliament (or wait for legitimate accumulation):
   - For i = 1 to 15,000:
     - Call `RequestSideChainCreation` with valid `SideChainCreationRequest`
     - Parliament approves proposal
     - Call `ReleaseSideChainCreation` or have parliament execute `CreateSideChain`

2. Verify serial number reached threshold:
   - `State.SideChainSerialNumber.Value >= 15000`

3. Attempt to call indexing service:
   - Cross-chain indexing service calls `GetAllChainIdHeightPairsAtLibAsync`
   - This internally calls `GetAllChainsIdAndHeight`
   
**Expected Result:**
    - Method returns chain heights successfully

**Actual Result:**
- `RuntimeBranchThresholdExceededException` thrown
- Cross-chain indexing permanently broken
- No recovery mechanism available

**Success Condition:**
The attack succeeds when `GetSideChainIdAndHeight` becomes uncallable due to exceeding the branch threshold, permanently disabling cross-chain functionality.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L104-113)
```csharp
        var serialNumber = State.SideChainSerialNumber.Value;
        for (long i = 1; i <= serialNumber; i++)
        {
            var chainId = GetChainId(i);
            var sideChainInfo = State.SideChainInfo[chainId];
            if (sideChainInfo.SideChainStatus == SideChainStatus.Terminated)
                continue;
            var height = State.CurrentSideChainHeight[chainId];
            dict.IdHeightDict.Add(chainId, height);
        }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L135-136)
```csharp
        State.SideChainSerialNumber.Value = State.SideChainSerialNumber.Value.Add(1);
        var serialNumber = State.SideChainSerialNumber.Value;
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L7-7)
```csharp
    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L29-36)
```csharp
    public void BranchCount()
    {
        if (_branchThreshold != -1 && _branchCount == _branchThreshold)
            throw new RuntimeBranchThresholdExceededException(
                $"Contract branch threshold {_branchThreshold} exceeded.");

        _branchCount++;
    }
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataService.cs (L157-176)
```csharp
    public async Task<ChainIdAndHeightDict> GetAllChainIdHeightPairsAtLibAsync()
    {
        var isReadyToCreateChainCache =
            await _irreversibleBlockStateProvider.ValidateIrreversibleBlockExistingAsync();
        if (!isReadyToCreateChainCache)
            return new ChainIdAndHeightDict();
        var lib = await _irreversibleBlockStateProvider.GetLastIrreversibleBlockHashAndHeightAsync();
        return await _contractReaderFactory
            .Create(new ContractReaderContext
            {
                BlockHash = lib.BlockHash,
                BlockHeight = lib.BlockHeight,
                ContractAddress = await GetCrossChainContractAddressAsync(new ChainContext
                {
                    BlockHash = lib.BlockHash,
                    BlockHeight = lib.BlockHeight
                })
            }).GetAllChainsIdAndHeight
            .CallAsync(new Empty());
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L100-137)
```csharp
    private void AssertValidSideChainCreationRequest(SideChainCreationRequest sideChainCreationRequest,
        Address proposer)
    {
        var proposedRequest = State.ProposedSideChainCreationRequestState[Context.Sender];
        Assert(proposedRequest == null || Context.CurrentBlockTime >= proposedRequest.ExpiredTime,
            "Request side chain creation failed.");

        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var allowance = State.TokenContract.GetAllowance.Call(new GetAllowanceInput
        {
            Owner = proposer,
            Spender = Context.Self,
            Symbol = Context.Variables.NativeSymbol
        }).Allowance;

        Assert(
            allowance >= sideChainCreationRequest.LockedTokenAmount,
            "Allowance not enough.");

        Assert(
            sideChainCreationRequest.IndexingPrice >= 0 &&
            sideChainCreationRequest.LockedTokenAmount >= sideChainCreationRequest.IndexingPrice,
            "Invalid chain creation request.");

        if (!sideChainCreationRequest.IsPrivilegePreserved)
            return; // there is no restriction for non-exclusive side chain creation

        AssertValidResourceTokenAmount(sideChainCreationRequest);

        if (!IsPrimaryTokenNeeded(sideChainCreationRequest))
            return;

        // assert primary token to create
        AssertValidSideChainTokenInfo(sideChainCreationRequest.SideChainTokenCreationRequest);
        Assert(sideChainCreationRequest.SideChainTokenInitialIssueList.Count > 0 &&
               sideChainCreationRequest.SideChainTokenInitialIssueList.All(issue => issue.Amount > 0),
            "Invalid side chain token initial issue list.");
    }
```
