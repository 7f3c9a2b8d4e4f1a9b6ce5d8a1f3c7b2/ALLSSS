### Title
Miner List Validation Bypass Allows Unauthorized Block Producers via NextRound Consensus Data Manipulation

### Summary
The validation pipeline for NextRound consensus behavior lacks cross-validation between the base round's miner list and the provided round's miner list. A malicious legitimate miner can inject unauthorized miners into the next round by modifying consensus header data before block submission, and no subsequent validator will detect this manipulation, allowing unauthorized miners to produce blocks in future rounds.

### Finding Description

**Root Cause**: The consensus validation system validates the block sender's authorization but fails to verify that the miner list in the next round matches the current round's miner list during NextRound transitions. [1](#0-0) 

MiningPermissionValidationProvider only checks if the sender's public key exists in `BaseRound.RealTimeMinersInformation.Keys`, but does not validate the entire miner list in `ProvidedRound`. [2](#0-1) 

The validation pipeline for NextRound behavior includes only MiningPermissionValidationProvider, TimeSlotValidationProvider, ContinuousBlocksValidationProvider, NextRoundMiningOrderValidationProvider, and RoundTerminateValidationProvider. [3](#0-2) 

TimeSlotValidationProvider accesses `BaseRound.RealTimeMinersInformation[SenderPubkey]` assuming the key exists (validated by MiningPermissionValidationProvider), but uses BaseRound only for time slot checks, not miner list validation. [4](#0-3) 

NextRoundMiningOrderValidationProvider only validates internal consistency within ProvidedRound (miners with orders vs miners with OutValues), not whether the miner list matches BaseRound. [5](#0-4) 

The consensus extra data extractor only verifies that `SenderPubkey` matches `SignerPubkey`, providing no cryptographic integrity protection for the Round data itself, including `RealTimeMinersInformation`. [6](#0-5) 

When ProcessNextRound executes, it directly converts the input to a Round object via `input.ToRound()` and adds it to state via `AddRoundInformation(nextRound)`, committing the attacker-modified miner list to blockchain state without additional validation. [7](#0-6) 

The legitimate GenerateNextRoundInformation maintains the same miner list from current round to next round, but this server-side generation can be bypassed since miners can modify the consensus data before block submission. [8](#0-7) 

ValidateConsensusAfterExecution does not prevent this attack for NextRound because it compares the header against the state that was just modified by the same round data, making the hash comparison meaningless for detecting miner list manipulation in NextRound transitions.

### Impact Explanation

**Consensus Integrity Violation**: Unauthorized miners can gain block production privileges, fundamentally breaking the consensus mechanism's security model. This violates the critical invariant that "miner schedule integrity" must be maintained.

**Concrete Impact**:
- Unauthorized entities can produce blocks and include/exclude transactions
- Attackers can disrupt consensus by producing malicious blocks or withholding blocks
- Network security is compromised as the authenticated miner set becomes untrustworthy
- Potential for transaction censorship, double-spending attempts, or network partitioning
- Complete breakdown of the election-based consensus model

**Affected Parties**: All network participants, as consensus integrity affects the entire blockchain's trustworthiness and operation.

**Severity Justification**: HIGH - This directly compromises the fundamental consensus layer, allowing unauthorized block production which is a critical security failure in any blockchain system.

### Likelihood Explanation

**Attacker Capabilities Required**: 
- Control of a single legitimate miner node OR ability to compromise one miner
- Ability to modify consensus extra data before block submission (standard mining node capability)
- Knowledge of miner list structure and time slot calculation (public protocol information)

**Attack Complexity**: LOW to MEDIUM
- No cryptographic barriers (only SenderPubkey signature verification exists)
- Straightforward data structure manipulation in block header
- No special timing or race condition requirements
- Attack succeeds with a single malicious NextRound block

**Feasibility Conditions**:
- Attacker must wait for their turn to produce the extra block that triggers NextRound
- Network must accept the malicious block (guaranteed if validators don't detect the manipulation)
- One successful attack persists indefinitely (unauthorized miners remain in miner list until NextTerm)

**Detection Constraints**: 
- No automated detection mechanism exists in the validation pipeline
- Off-chain monitoring would need to independently verify miner list integrity
- Attack is detectable post-facto by comparing actual vs expected miner lists

**Probability**: HIGH - The attack is practical, requires minimal capabilities (single compromised miner), and has no technical barriers preventing execution.

### Recommendation

**Immediate Fix**: Add miner list validation in the NextRound validation pipeline:

1. **Create MinerListConsistencyValidationProvider** that validates for NextRound behavior:
   ```
   - Verify ProvidedRound.RealTimeMinersInformation.Keys equals BaseRound.RealTimeMinersInformation.Keys
   - Ensure no miners are added or removed during NextRound transitions
   - Only allow miner list changes during NextTerm (with Election Contract verification)
   ```

2. **Register the validator** in ValidateBeforeExecution for NextRound behavior at line 86 of AEDPoSContract_Validation.cs

3. **Add cryptographic integrity protection** by including a hash of the expected next round miner list in the current round's consensus data, verified during NextRound validation

4. **Strengthen ValidateConsensusAfterExecution** to independently verify miner list integrity by comparing against the Election Contract's authoritative miner set for the current term

**Invariant to Enforce**: 
```
For NextRound transitions: 
  ProvidedRound.RealTimeMinersInformation.Keys == BaseRound.RealTimeMinersInformation.Keys

For NextTerm transitions:
  ProvidedRound.RealTimeMinersInformation.Keys == ElectionContract.GetVictories().Pubkeys
```

**Test Cases**:
1. NextRound block with additional miner → should be rejected
2. NextRound block with removed miner → should be rejected  
3. NextRound block with replaced miner (wrong pubkey) → should be rejected
4. NextRound block with correct miner list → should be accepted
5. NextTerm block with updated miner list from Election Contract → should be accepted

### Proof of Concept

**Required Initial State**:
- Blockchain operational with N legitimate miners (e.g., N=5)
- Attacker controls one legitimate miner M
- Current round number R, ready for NextRound transition

**Attack Steps**:

1. Attacker's miner M waits for their turn as extra block producer
2. M calls GetConsensusExtraData with NextRound behavior, receives legitimate consensus data
3. M parses the AElfConsensusHeaderInformation from the returned data
4. M modifies `headerInformation.Round.RealTimeMinersInformation` to add attacker's public key A:
   - Calculate appropriate Order (N+1)
   - Calculate ExpectedMiningTime maintaining consistent mining intervals
   - Set other required fields (Pubkey, default values for counters)
5. M serializes the modified consensus data and includes it in block header
6. M produces and signs the block with their legitimate private key

**Validation Results**:
- MiningPermissionValidationProvider: PASS (M is in BaseRound) ✓
- TimeSlotValidationProvider: PASS (time slots are consistent) ✓
- NextRoundMiningOrderValidationProvider: PASS (internal consistency maintained) ✓
- RoundTerminateValidationProvider: PASS (round number increments correctly) ✓
- Block accepted and transactions executed ✓

**Expected vs Actual Result**:
- Expected: Block should be rejected due to unauthorized miner in next round
- Actual: Block is accepted, State.Rounds[R+1] now contains attacker A in miner list

**Success Condition**: In round R+1, attacker A can produce blocks by:
- Calling GetConsensusCommand with their public key A → receives valid command
- MiningPermissionValidationProvider validates A against BaseRound (now contains A) → PASS
- Attacker successfully produces unauthorized blocks

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-76)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L21-33)
```csharp
    public ByteString ExtractConsensusExtraData(BlockHeader header)
    {
        var consensusExtraData =
            _blockExtraDataService.GetExtraDataFromBlockHeader(_consensusExtraDataProvider.BlockHeaderExtraDataKey,
                header);
        if (consensusExtraData == null)
            return null;

        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```
