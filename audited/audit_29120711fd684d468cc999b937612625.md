### Title
Case Sensitivity Inconsistency in SEED Collection Validation Breaks Token Creation Mechanism

### Summary
The `GetSymbolType()` function correctly classifies symbols ending in "-0" as `NftCollection` through pattern matching, but the SEED collection special handling uses case-sensitive string comparison against the hardcoded constant `"SEED-0"`. This inconsistency allows a whitelisted address to create a lowercase "seed-0" collection, which bypasses SEED-specific validations and permanently breaks the SEED NFT mechanism since subsequent lookups for "SEED-0" fail due to case-sensitive token info storage.

### Finding Description

The vulnerability stems from inconsistent case handling across multiple code paths:

**1. Pattern-Based Classification (Case-Agnostic)**

The `GetSymbolType()` function uses pattern matching that treats any symbol ending with "-0" identically, regardless of case: [1](#0-0) 

This returns `SymbolType.NftCollection` for both "SEED-0" and "seed-0".

**2. Case-Sensitive SEED Validation Bypass**

The `CreateToken()` method bypasses seed NFT validation using a case-sensitive comparison: [2](#0-1) 

The constant `TokenContractConstants.SeedCollectionSymbol` is defined as the uppercase string "SEED-0": [3](#0-2) 

If a whitelisted address creates "seed-0" (lowercase), line 57 evaluates `"seed-0" != "SEED-0"` as `true`, but the whitelist check at line 56 bypasses the entire validation block.

**3. Case-Sensitive Token Info Storage vs Case-Insensitive Existence Check**

Token registration uses case-insensitive existence checking: [4](#0-3) 

But token info retrieval is strictly case-sensitive: [5](#0-4) 

**4. Broken SEED NFT Creation**

When creating individual SEED NFTs (SEED-1, SEED-2, etc.), the code checks if the collection is the special SEED collection using case-sensitive comparison: [6](#0-5) 

If "seed-0" was created instead of "SEED-0", this check fails (`"seed-0" == "SEED-0"` returns false), and the critical `SymbolSeedMap` is never populated, breaking the entire SEED mechanism.

**5. Symbol Validation Permits Lowercase**

The validation regex explicitly allows lowercase letters: [7](#0-6) 

### Impact Explanation

**Operational Impact - Critical System DoS:**

1. **Complete SEED Mechanism Failure**: If "seed-0" is created instead of "SEED-0", the `SymbolSeedMap` is never populated for any symbols. This map is essential for token creation validation.

2. **Permanent Token Creation DoS**: All non-whitelisted addresses attempting to create tokens will fail because `CheckSeedNFT()` requires valid seed NFTs mapped in `SymbolSeedMap`, which remains empty.

3. **Cannot Create SEED NFTs**: Attempts to create SEED-1, SEED-2, etc. fail at collection lookup because `GetTokenInfo("SEED-0")` returns null when only "seed-0" exists (case-sensitive lookup).

4. **Irreversible State**: Once "seed-0" is created, "SEED-0" cannot be created due to case-insensitive existence checks, leaving the system permanently broken.

**Affected Parties:**
- All users requiring SEED NFTs for token creation
- Protocol governance and token economics functionality
- System integrity and token issuance mechanism

### Likelihood Explanation

**Attack Complexity: Low to Medium**

**Preconditions:**
- Attacker must influence a whitelisted address (typically Parliament default organization) to create "seed-0" instead of "SEED-0"
- This can occur through:
  - Social engineering of governance proposal submitters
  - Typo in governance proposal parameters
  - Manipulated genesis configuration files
  - Human error in case-sensitive symbol specification

**Feasibility:**
- Reachable via public `Create()` method routed through governance proposals
- No technical barriers once proposal is submitted with lowercase symbol
- Case sensitivity errors are common in configuration and proposals
- Tests consistently use uppercase "SEED-0", but runtime enforcement is absent [8](#0-7) [9](#0-8) 

**Probability: Medium** - While requiring governance involvement, the lack of runtime validation makes human error the primary risk vector.

### Recommendation

**1. Add Case Normalization at Entry Point**

In `GetSymbolType()`, normalize symbols to uppercase before processing:

```csharp
private SymbolType GetSymbolType(string symbol)
{
    symbol = symbol?.ToUpper() ?? throw new AssertionException("Symbol cannot be null");
    var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
    // ... rest of logic
}
```

**2. Enforce Uppercase for SEED Collection**

In `CreateToken()`, add explicit validation:

```csharp
if (symbolType == SymbolType.NftCollection && 
    input.Symbol.ToUpper() == TokenContractConstants.SeedCollectionSymbol)
{
    Assert(input.Symbol == TokenContractConstants.SeedCollectionSymbol, 
           "SEED collection symbol must be uppercase 'SEED-0'");
}
```

**3. Normalize Symbol Storage**

Update `RegisterTokenInfo()` to store symbols in uppercase:

```csharp
private void RegisterTokenInfo(TokenInfo tokenInfo)
{
    var normalizedSymbol = tokenInfo.Symbol.ToUpper();
    Assert(tokenInfo.Symbol == normalizedSymbol, "Token symbols must be uppercase");
    // ... rest of logic
}
```

**4. Add Regression Tests**

Add test cases validating:
- Lowercase "seed-0" creation is rejected
- Mixed-case SEED collection creation is rejected
- Case-sensitive SEED NFT creation with proper error messages

### Proof of Concept

**Initial State:**
- Parliament organization with create whitelist permission
- No SEED collection exists yet

**Exploit Steps:**

1. Parliament submits and approves proposal to create token with symbol "seed-0" (lowercase):
   ```
   Create({
     Symbol: "seed-0",
     TokenName: "seed Collection",
     TotalSupply: 1,
     Decimals: 0,
     IsBurnable: true,
     Issuer: ParliamentAddress,
     Owner: ParliamentAddress
   })
   ```

2. `GetSymbolType("seed-0")` returns `SymbolType.NftCollection` (pattern match on "-0")

3. `CreateToken()` at line 56-57 checks:
   - `IsAddressInCreateWhiteList(ParliamentAddress)` â†’ true
   - Bypasses seed validation entirely

4. "seed-0" is successfully created and stored as `State.TokenInfos["seed-0"]`

5. `State.InsensitiveTokenExisting["SEED-0"]` is set to true

**Result - System Break:**

6. Attempt to create "SEED-0" (correct uppercase) fails:
   - `CheckTokenExists("SEED-0")` triggers
   - `State.InsensitiveTokenExisting["SEED-0"]` is true
   - Assert fails: "Token already exists"

7. Attempt to create SEED-1 fails:
   - `GetNftCollectionSymbol("SEED-1")` returns "SEED-0"
   - `GetTokenInfo("SEED-0")` returns null (only "seed-0" exists)
   - `AssertNftCollectionExist()` fails: "NFT collection not exist"

8. All token creation by non-whitelisted users fails:
   - `CheckSeedNFT()` looks up `State.SymbolSeedMap[symbol]`
   - Map is empty (never populated because "seed-0" != "SEED-0" check failed)
   - Assert fails: "Seed NFT does not exist"

**Success Condition:** SEED mechanism permanently disabled, token creation DoS achieved.

### Notes

The inconsistency exists because `GetSymbolType()` correctly uses pattern matching for NFT collection classification (making it technically case-agnostic), but the special SEED collection handling incorrectly relies on exact string matching without case normalization. This architectural mismatch between generic NFT collection handling and SEED-specific logic creates the vulnerability window. The issue is exacerbated by AElf's design choice to allow case-sensitive symbol storage while performing case-insensitive existence checks, creating a state where a symbol can exist but be unlookable under its expected case.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L23-23)
```csharp
    public const string SeedCollectionSymbol = "SEED-0";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L28-31)
```csharp
    private bool IsValidCreateSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+$");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L232-233)
```csharp
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L37-52)
```csharp
        if (nftCollectionInfo.Symbol == TokenContractConstants.SeedCollectionSymbol)
        {
            Assert(input.Decimals == 0 && input.TotalSupply == 1, "SEED must be unique.");
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedOwnedSymbolExternalInfoKey,
                    out var ownedSymbol), "OwnedSymbol does not exist.");
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                       out var expirationTime)
                   && long.TryParse(expirationTime, out var expirationTimeLong) &&
                   Context.CurrentBlockTime.Seconds <= expirationTimeLong, "Invalid ownedSymbol.");
            var ownedSymbolType = GetSymbolType(ownedSymbol);
            Assert(ownedSymbolType != SymbolType.Nft, "Invalid OwnedSymbol.");
            CheckSymbolLength(ownedSymbol, ownedSymbolType);
            CheckTokenAndCollectionExists(ownedSymbol);
            CheckSymbolSeed(ownedSymbol);
            State.SymbolSeedMap[ownedSymbol.ToUpper()] = input.Symbol;
        }
```

**File:** test/AElf.Contracts.MultiToken.Tests/MultiTokenContractTestBase.cs (L105-106)
```csharp
    protected int SeedNum = 0;
    protected string SeedNFTSymbolPre = "SEED-";
```

**File:** test/AElf.Contracts.Referendum.Tests/ReferendumContractTest.cs (L1347-1354)
```csharp
                Symbol = "SEED-0",
                Decimals = 0,
                IsBurnable = true,
                TokenName = "seed Collection",
                TotalSupply = 1,
                Issuer = defaultParliamentAddress,
                ExternalInfo = new ExternalInfo(),
                Owner = defaultParliamentAddress
```
