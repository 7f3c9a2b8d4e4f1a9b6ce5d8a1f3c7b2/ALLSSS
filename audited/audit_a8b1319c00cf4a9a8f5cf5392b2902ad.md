### Title
Incorrect Distinct() Usage Allows Duplicate FinalOrderOfNextRound Values to Bypass Validation

### Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` method calls `Distinct()` on `MinerInRound` objects instead of on their `FinalOrderOfNextRound` values. Since protobuf-generated classes use value-based equality comparing all fields, miners with duplicate `FinalOrderOfNextRound` values but different pubkeys are incorrectly counted as distinct, allowing invalid rounds with duplicate mining orders to pass validation and disrupt consensus.

### Finding Description

The validation logic at [1](#0-0)  calls `Distinct()` directly on the filtered collection of `MinerInRound` objects. 

**Root Cause**: The `MinerInRound` class is a protobuf-generated message [2](#0-1)  that implements value-based equality across all fields (pubkey, order, in_value, out_value, signature, etc.). When `Distinct()` operates on `MinerInRound` objects, it compares the entire object, not just the `FinalOrderOfNextRound` field. Three miners with identical `FinalOrderOfNextRound = 1` but different pubkeys will be counted as three distinct objects, not one.

**Validation Failure**: The check at [3](#0-2)  compares `distinctCount` (which incorrectly counts distinct objects) against the count of miners who mined. With duplicate `FinalOrderOfNextRound` values, this validation incorrectly passes.

**Execution Path**: This validation is invoked during `NextRound` behavior [4](#0-3) , which processes round transitions [5](#0-4) .

### Impact Explanation

**Consensus Disruption**: When `GenerateNextRoundInformation` processes miners with duplicate `FinalOrderOfNextRound` values [6](#0-5) , multiple miners are assigned the same `Order` in the next round. Each miner maintains their unique dictionary key (pubkey), so they all enter the round with identical order values.

**Mining Schedule Conflicts**: Multiple miners with `Order = 1` will calculate the same expected mining time [7](#0-6) , causing simultaneous mining attempts and consensus conflicts.

**Non-Deterministic Behavior**: Functions that select miners by order become non-deterministic. The extra block producer selection [8](#0-7)  and continuous mining prevention logic [9](#0-8)  use `FirstOrDefault` on order lookups, returning unpredictable results when multiple miners share the same order.

**Affected Parties**: All network participants suffer from consensus instability, potential chain halt, or fork scenarios. Miners may be unfairly excluded from rewards or double-counted.

### Likelihood Explanation

**Reachable Entry Point**: Any miner in the current miner list can call the `NextRound` public method [10](#0-9) .

**Feasible Preconditions**: The attacker must be a current miner (checked by `PreCheck()` [11](#0-10) ). They can manually construct a `NextRoundInput` using `NextRoundInput.Create()` [12](#0-11)  with modified `RealTimeMinersInformation` containing duplicate `FinalOrderOfNextRound` values.

**Execution Practicality**: The attack requires only standard transaction submission capabilities. While normal `UpdateValue` operations include conflict resolution logic [13](#0-12) , a malicious miner can bypass this by directly proposing a crafted `NextRound` input.

**Economic Rationality**: The attack costs only transaction fees. The benefit is causing consensus disruption, which could be valuable for attackers seeking to halt the chain, manipulate mining rewards, or create instability for market manipulation.

### Recommendation

**Immediate Fix**: Modify the validation to select the `FinalOrderOfNextRound` values before calling `Distinct()`:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // ADD THIS LINE
    .Distinct()
    .Count();
```

**Invariant Check**: Add an explicit validation that no two miners share the same `FinalOrderOfNextRound`:

```csharp
var finalOrders = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
    
if (finalOrders.Count != finalOrders.Distinct().Count())
{
    validationResult.Message = "Duplicate FinalOrderOfNextRound detected.";
    return validationResult;
}
```

**Test Cases**: Add unit tests verifying:
1. Validation fails when multiple miners have identical `FinalOrderOfNextRound` values
2. Validation passes only when all miners have unique `FinalOrderOfNextRound` values
3. Round generation fails gracefully if duplicate orders somehow enter the system

### Proof of Concept

**Initial State**:
- Network has 5 miners: A, B, C, D, E
- Current round: only miners A, B, C produced blocks (have `OutValue != null`)
- All other fields (pubkey, signature, etc.) differ between miners

**Attack Steps**:
1. Miner A constructs a malicious `NextRoundInput` where:
   - Miner A: `FinalOrderOfNextRound = 1`, `OutValue = Hash_A`
   - Miner B: `FinalOrderOfNextRound = 1`, `OutValue = Hash_B`  
   - Miner C: `FinalOrderOfNextRound = 1`, `OutValue = Hash_C`
   - Miners D, E: `FinalOrderOfNextRound = 0`

2. Miner A submits transaction calling `NextRound(maliciousInput)`

**Expected Result**: Validation should fail because three miners share `FinalOrderOfNextRound = 1`

**Actual Result**: 
- Validation at line 15-16 calls `Distinct()` on `MinerInRound` objects
- Since A, B, C have different pubkeys (and other fields), they are counted as 3 distinct objects
- `distinctCount = 3`
- Count of miners with `OutValue != null` = 3
- Validation passes: `3 == 3` âœ“
- Next round is created with all three miners assigned `Order = 1`
- Consensus disruption occurs when all three attempt to mine simultaneously

**Success Condition**: The malicious round is accepted into state [14](#0-13) , causing multiple miners to have identical mining orders in the next round, leading to mining conflicts and non-deterministic consensus behavior.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L17-21)
```csharp
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-61)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-79)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-40)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```
