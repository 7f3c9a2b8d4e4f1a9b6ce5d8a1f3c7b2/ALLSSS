### Title
Missing Upper Bound Validation for ImpliedIrreversibleBlockHeight Allows LIB Manipulation

### Summary
The `ProcessUpdateValue` function accepts `updateValueInput.ImpliedIrreversibleBlockHeight` without validating it against an upper bound (current block height), allowing miners to set artificially high values. When combined across multiple miners (≥1/3 threshold), this can manipulate the Last Irreversible Block (LIB) calculation to prematurely finalize non-existent or future blocks, violating consensus integrity.

### Finding Description

The vulnerability exists in the consensus update flow where `ImpliedIrreversibleBlockHeight` values are accepted and used without proper bounds checking:

**1. Missing Upper Bound Validation in ProcessUpdateValue:** [1](#0-0) 

The function directly assigns the input value without validation against `Context.CurrentHeight`.

**2. System Sets Correct Value But Doesn't Enforce It:** [2](#0-1) 

The system correctly sets `ImpliedIrreversibleBlockHeight = Context.CurrentHeight` when generating consensus data, but this constraint is not enforced during validation.

**3. Insufficient Validation - Only Checks Non-Decrease:** [3](#0-2) 

The validation only ensures the value doesn't decrease from the previous round, but accepts any higher value including those exceeding the current block height.

**4. Stored Values Used in LIB Calculation:** [4](#0-3) 

The LIB calculator retrieves `ImpliedIrreversibleBlockHeight` values from miners in the previous round and selects the value at position `(count-1)/3` in the sorted list.

**5. Miners Control Transaction Signing:** [5](#0-4) 

Miners sign their own consensus transactions, giving them the ability to create modified transactions with inflated values.

**Root Cause:** The protocol assumes `ImpliedIrreversibleBlockHeight` values will equal `Context.CurrentHeight` but never validates this invariant. The system generates correct values but doesn't enforce that miners use them.

### Impact Explanation

**Consensus Integrity Violation:**
- Miners can set `ImpliedIrreversibleBlockHeight` to values higher than the current block height (e.g., block 1000 + 10000 = block 11000)
- When ≥1/3 of miners provide inflated values, the BFT calculation at position `(count-1)/3` yields an artificially high LIB
- The blockchain would mark future/non-existent blocks as irreversible

**Concrete Harm:**
- **Premature Finalization**: Blocks that haven't been produced are marked irreversible
- **Chain Inconsistency**: Other nodes may reject blocks based on invalid LIB values
- **Potential Chain Halt**: Conflicting LIB states could prevent consensus
- **Cross-Chain Impact**: Invalid LIB heights propagated to cross-chain mechanisms

**Affected Parties:**
- All network participants relying on finality guarantees
- Cross-chain protocols using LIB for settlement
- Applications depending on irreversibility for critical operations

**Severity Justification:** Critical - Violates core consensus invariant (LIB correctness) with potential for chain-level disruption.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an active miner in the consensus round
- Must create custom `UpdateValue` transaction instead of using system-generated one
- Needs to sign the modified transaction with their miner key

**Attack Complexity:**
- **Single Miner Impact**: Limited - value is sorted with others, single outlier doesn't affect LIB
- **Collusion Required**: ≥1/3 miners must provide inflated values to manipulate the `(count-1)/3` position
- **Technical Difficulty**: Low - simply modify `UpdateValueInput.ImpliedIrreversibleBlockHeight` before signing

**Feasibility Conditions:**
- Attacker controls ≥1/3 of miner nodes, OR
- Collusion among ≥1/3 of independent miners
- Within BFT threat model (< 1/3 Byzantine assumption) boundaries, but still represents a protocol violation where honest behavior is not enforced

**Detection Constraints:**
- No on-chain validation catches the inflated value
- Would be detected post-facto when LIB jumps to impossible heights
- Observable through monitoring but not preventable once transactions are accepted

**Probability Assessment:** Medium-High for miners with sufficient stake/control, as the missing validation makes the attack straightforward once preconditions are met.

### Recommendation

**Add Upper Bound Validation:**

Add a check in `ProcessUpdateValue` immediately after line 248:

```csharp
minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

// Add validation
Assert(minerInRound.ImpliedIrreversibleBlockHeight <= Context.CurrentHeight,
    $"ImpliedIrreversibleBlockHeight ({minerInRound.ImpliedIrreversibleBlockHeight}) cannot exceed current height ({Context.CurrentHeight})");
```

**Alternative: Add to LibInformationValidationProvider:**

Enhance the validation in `LibInformationValidationProvider.ValidateHeaderInformation`:

```csharp
// After line 30, add:
if (providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight > validationContext.ExtraData.Round.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
{
    validationResult.Message = "Implied lib height exceeds expected value from consensus extra data.";
    return validationResult;
}
```

**Test Cases:**
1. Test that UpdateValue rejects transactions with `ImpliedIrreversibleBlockHeight > Context.CurrentHeight`
2. Test that UpdateValue accepts `ImpliedIrreversibleBlockHeight == Context.CurrentHeight`
3. Test LIB calculation remains correct with boundary values
4. Test multi-miner scenarios where some miners provide invalid values

### Proof of Concept

**Initial State:**
- Current block height: 1000
- Current round: Round 10
- Malicious miner M1 is scheduled to produce block in current round

**Attack Steps:**

1. **Miner generates correct consensus data:**
   - System calls `GetConsensusExtraDataToPublishOutValue`
   - Sets `ImpliedIrreversibleBlockHeight = 1000` (Context.CurrentHeight)

2. **Miner creates modified transaction:**
   - Instead of using system-generated `UpdateValue` transaction
   - Creates custom `UpdateValueInput` with `ImpliedIrreversibleBlockHeight = 11000`
   - Signs transaction with miner key

3. **Transaction validation:**
   - `ValidateConsensusBeforeExecution`: Passes (validates header extra data, not transaction input)
   - `LibInformationValidationProvider`: Passes (11000 > previous value, doesn't check upper bound)
   - `UpdateValueValidationProvider`: Passes (doesn't check ImpliedIrreversibleBlockHeight)

4. **Transaction executes:**
   - `ProcessUpdateValue` sets `minerInRound.ImpliedIrreversibleBlockHeight = 11000`
   - Value stored in round state

5. **Next round LIB calculation:**
   - If ≥1/3 miners provided inflated values
   - `GetSortedImpliedIrreversibleBlockHeights` returns: [1000, 1000, 11000, 11000, ...]
   - Position `(count-1)/3` selects an inflated value
   - LIB jumps to block 11000 (which doesn't exist yet)

**Expected Result:** Transaction rejected with "ImpliedIrreversibleBlockHeight exceeds current height"

**Actual Result:** Transaction accepted, LIB manipulated to impossible value

**Success Condition:** LIB height set to value > actual chain height, causing premature finalization.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** src/AElf.Kernel/Miner/Application/MiningService.cs (L107-107)
```csharp
        foreach (var transaction in systemTransactions) await SignAsync(transaction);
```
