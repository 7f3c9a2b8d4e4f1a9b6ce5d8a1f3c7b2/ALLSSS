# Audit Report

## Title
Time Slot Validation Allows Overlapping and Unequal Mining Windows via Lenient Interval Checks

## Summary
The `CheckRoundTimeSlots()` validation function uses a lenient interval check that permits mining time intervals to vary from 0ms to 2× the base interval. This allows malicious miners to craft NextRoundInput data with overlapping or gapped time slots that pass validation, breaking the consensus assumption of sequential, non-overlapping mining windows and enabling unfair mining advantages.

## Finding Description

The vulnerability exists in the time slot validation logic where consecutive miners' expected mining times are validated using an overly permissive check. [1](#0-0) 

The validation calculates a `baseMiningInterval` from the first two miners and then checks that subsequent intervals satisfy `Math.Abs(miningInterval - baseMiningInterval) <= baseMiningInterval`. This mathematically permits any interval in the range [0, 2×baseMiningInterval]. For example, if the base interval is 4000ms, consecutive miners can be spaced anywhere from 0ms to 8000ms apart.

In contrast, legitimate round generation creates equal time slots using uniform intervals: [2](#0-1) 

However, when miners provide `NextRoundInput`, the validation only checks the lenient interval rule, not equality. Each miner's effective time slot duration is determined by `GetMiningInterval()`: [3](#0-2) 

This calculates a uniform slot length from the first two miners' expected times, but when combined with arbitrary expected mining times that pass the lenient validation, it creates overlapping windows.

**Example Attack Scenario:**
- Miner A: ExpectedMiningTime = t+0
- Miner B: ExpectedMiningTime = t+4000ms (interval=4000ms, sets baseMiningInterval)
- Miner C: ExpectedMiningTime = t+12000ms (interval=8000ms, |8000-4000|=4000 ≤ 4000 ✓ passes)
- Miner D: ExpectedMiningTime = t+14000ms (interval=2000ms, |2000-4000|=2000 ≤ 4000 ✓ passes)

With GetMiningInterval() returning 4000ms (based on first two miners), the effective time slots become:
- Miner A: [?, t+4000]
- Miner B: [?, t+8000]
- Miner C: [?, t+16000]
- Miner D: [?, t+18000]

At time t+15000, both Miner C and Miner D can mine because `IsTimeSlotPassed()` returns false for both.

The validation during NextRound processing does not prevent this: [4](#0-3) 

The provided Round is stored directly without regeneration: [5](#0-4) 

During overlapping periods, `IsTimeSlotPassed()` returns false for multiple miners simultaneously: [6](#0-5) 

This function only checks if the slot END has passed (ExpectedMiningTime + miningInterval < currentBlockTime), with no validation that currentBlockTime >= ExpectedMiningTime. Therefore, miners can mine anytime before their slot end time.

Both miners in overlapping regions receive mining behavior: [7](#0-6) 

When a miner hasn't mined in the current round and `!IsTimeSlotPassed` evaluates to true, they receive `UpdateValue` behavior, allowing them to mine.

## Impact Explanation

**Consensus Integrity Breach:**
- Breaks the fundamental consensus invariant that only one miner should have an active time slot at any given moment
- Multiple miners can produce blocks simultaneously during overlapping periods, violating sequential mining guarantees
- Creates gaps where no miner has an active time slot, potentially causing block production delays
- Enables strategic time slot allocation where colluding miners give themselves advantageous positions

**Unfair Mining Advantages:**
- Colluding miners can manipulate the round structure to give themselves longer effective mining windows (up to 2× normal) while compressing honest miners' slots (down to near-0)
- Non-colluding miners placed in overlapping regions face unpredictable block acceptance and potential conflicts
- Miners assigned to gap regions may entirely miss their expected slots as the time never arrives
- Long-term accumulation of unfair block production opportunities

**Reward Misallocation:**
- Unequal time slot distribution directly translates to unequal block production opportunities and mining rewards
- Honest miners may appear to "miss time slots" when they're actually placed in poorly allocated windows
- Systematic advantage for attackers in accumulating consensus rewards

**Network Stability:**
- Chain quality degradation from non-uniform block timing
- Increased fork rates during overlapping periods when multiple miners produce blocks
- Breaks assumptions in LIB (Last Irreversible Block) calculations that rely on sequential, predictable time slots

**Severity: HIGH** - This vulnerability fundamentally breaks core consensus time slot invariants and enables systematic, long-term mining unfairness.

## Likelihood Explanation

**Attacker Capabilities:**
- Requires being a miner in the current miner list (obtainable through election process)
- Must craft malicious NextRoundInput with manipulated ExpectedMiningTime values
- Can submit NextRound transaction at any time during their mining eligibility

**Attack Complexity:**
- LOW - Simple arithmetic manipulation within the allowed 2× range
- No cryptographic breaks or complex protocol violations required
- Can be easily automated once mining infrastructure is controlled

**Feasibility Conditions:**
- Attacker needs to be elected as a block producer (realistic in DPoS)
- Permission check only validates miner list membership: [8](#0-7) 

- For sustained advantage, 2-3 colluding miners are sufficient in typical miner sets
- Attack can be repeated every round for continuous benefit

**Detection Constraints:**
- Manipulated rounds pass all validation checks and appear as legitimate consensus data
- Would require off-chain statistical analysis of time slot distributions to detect anomalies
- No on-chain monitoring or alerts for this type of manipulation

**Economic Rationality:**
- Cost: Standard mining operational costs plus minimal development effort for manipulation logic
- Benefit: Proportionally increased share of block rewards based on time slot advantage
- Highly rational for profit-maximizing miners, especially with collusion
- Low risk of detection or punishment

**Probability: MEDIUM-HIGH** - Exploitable by any miner in the active set through straightforward manipulation, with clear economic incentives and low detection risk.

## Recommendation

Modify `CheckRoundTimeSlots()` to enforce strict equality of time slot intervals rather than allowing a 2× variance range:

```csharp
public ValidationResult CheckRoundTimeSlots()
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

    var baseMiningInterval =
        (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

    if (baseMiningInterval <= 0)
        return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

    // FIXED: Require exact interval equality instead of allowing 2× variance
    for (var i = 1; i < miners.Count - 1; i++)
    {
        var miningInterval =
            (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
        if (miningInterval != baseMiningInterval)
            return new ValidationResult { Message = "Time slots must be equal." };
    }

    return new ValidationResult { Success = true };
}
```

Additionally, consider adding authorization checks to ensure only the designated extra block producer can submit NextRound transactions, and add lower bound validation in `IsTimeSlotPassed()` or the validation pipeline to ensure miners cannot mine before their ExpectedMiningTime.

## Proof of Concept

The following test demonstrates the vulnerability by crafting a Round with overlapping time slots that passes validation:

```csharp
[Fact]
public void CheckRoundTimeSlots_AllowsOverlappingSlots()
{
    // Arrange: Create a round with manipulated time slots
    var baseTime = TimestampHelper.GetUtcNow();
    var round = new Round
    {
        RoundNumber = 2,
        RealTimeMinersInformation =
        {
            // Miner A at t+0
            ["minerA"] = new MinerInRound 
            { 
                Order = 1, 
                ExpectedMiningTime = baseTime 
            },
            // Miner B at t+4000ms (sets base interval = 4000ms)
            ["minerB"] = new MinerInRound 
            { 
                Order = 2, 
                ExpectedMiningTime = baseTime.AddMilliseconds(4000) 
            },
            // Miner C at t+12000ms (interval = 8000ms, within 2× limit)
            ["minerC"] = new MinerInRound 
            { 
                Order = 3, 
                ExpectedMiningTime = baseTime.AddMilliseconds(12000) 
            },
            // Miner D at t+14000ms (interval = 2000ms, creates overlap with C)
            ["minerD"] = new MinerInRound 
            { 
                Order = 4, 
                ExpectedMiningTime = baseTime.AddMilliseconds(14000) 
            }
        }
    };

    // Act: Validate the manipulated round
    var result = round.CheckRoundTimeSlots();

    // Assert: Validation passes despite overlapping slots
    result.Success.ShouldBeTrue();
    
    // Verify overlap: At t+15000, both C and D can mine
    var overlapTime = baseTime.AddMilliseconds(15000);
    var miningInterval = round.GetMiningInterval(); // Returns 4000ms
    
    // Miner C's slot hasn't passed: t+12000 + 4000 = t+16000 > t+15000
    round.IsTimeSlotPassed("minerC", overlapTime).ShouldBeFalse();
    
    // Miner D's slot hasn't passed: t+14000 + 4000 = t+18000 > t+15000
    round.IsTimeSlotPassed("minerD", overlapTime).ShouldBeFalse();
    
    // Both miners can mine simultaneously, breaking consensus invariant
}
```

This test proves that the lenient validation allows overlapping time slots where multiple miners can mine concurrently, violating the fundamental consensus assumption of sequential mining.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-54)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L88-90)
```csharp
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L33-33)
```csharp
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L114-114)
```csharp
            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
```
