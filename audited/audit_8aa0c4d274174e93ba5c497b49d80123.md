### Title
Scheme Manager Can Retroactively Increase MinimumLockMinutes to Prevent User Withdrawals

### Summary
The `CreateScheme` function lacks protection against multiple invocations by the same manager, allowing a malicious scheme manager to overwrite the `TokenHolderProfitScheme` with a new `MinimumLockMinutes` value. This retroactively applies the new lock period to existing users who registered under the original scheme, effectively trapping their locked tokens indefinitely.

### Finding Description

The vulnerability exists in the `CreateScheme` function which has no validation to prevent repeated calls: [1](#0-0) 

The function unconditionally overwrites `State.TokenHolderProfitSchemes[Context.Sender]` without checking if a scheme already exists. When users register for profits, their lock timestamp is recorded: [2](#0-1) 

When withdrawing, the function retrieves the current scheme (which may have been replaced) and uses its `MinimumLockMinutes` to validate the withdrawal: [3](#0-2) 

The root cause is that:
1. Lock timestamps are stored separately and persist across scheme recreations
2. The withdrawal time check uses the CURRENT scheme's `MinimumLockMinutes` against the ORIGINAL lock timestamp
3. The Profit contract allows multiple scheme creations by using count-based scheme ID generation: [4](#0-3) 

Each call creates a new profit scheme with a different ID, so the "Already exists" check at line 59 doesn't prevent this: [5](#0-4) 

### Impact Explanation

**Direct Fund Impact**: Users' locked tokens can be permanently frozen. If a user locks 10,000 ELF with an initial 1-minute lock period, the scheme manager can change it to effectively infinite lock time (e.g., 100,000,000 minutes = ~190 years), making the funds unrecoverable for the user's lifetime.

**Affected Parties**: All users who have registered for profits in any TokenHolder scheme are vulnerable. This includes:
- Individual token holders participating in profit distribution schemes
- DApp contracts that use TokenHolder for staking mechanisms
- Side chain dividend pool participants

**Severity Justification**: HIGH - This allows complete theft/freezing of user funds with no recourse. The attack is undetectable until users attempt withdrawal, by which point their funds are already trapped. Unlike governance attacks requiring consensus, this can be executed unilaterally by any scheme manager.

### Likelihood Explanation

**Attacker Capabilities**: Any scheme manager can execute this attack. Scheme managers are created when anyone calls `CreateScheme`, making the barrier to entry very low.

**Attack Complexity**: Trivial - requires only a single additional `CreateScheme` transaction with modified `MinimumLockMinutes` parameter.

**Feasibility Conditions**:
- Attacker must have created a scheme (anyone can)
- Users must have registered for profits (normal operation)
- No special timing or coordination required

**Detection Constraints**: The attack is silent - no events indicate scheme parameter changes, and users only discover the issue when attempting withdrawal. The scheme manager can wait until significant value is locked before executing.

**Economic Rationality**: Extremely favorable for attacker - gas cost of one transaction versus potential to lock millions in user funds. Can be combined with social engineering (promise high yields with short lock periods to attract deposits, then change parameters).

**Probability**: HIGH - The vulnerability is straightforward to exploit and economically rational for malicious actors.

### Recommendation

**Immediate Fix**: Add a check in `CreateScheme` to prevent recreation:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
           "Scheme already exists for this manager.");
    
    // ... rest of function
}
```

**Additional Protections**:
1. Add an `UpdateScheme` function with strict governance controls if parameter updates are needed
2. Emit events when scheme parameters are modified
3. Implement a time-lock mechanism before parameter changes take effect
4. Consider making `MinimumLockMinutes` immutable after users have registered

**Invariant to Enforce**: A scheme manager can only create one scheme per address. If updates are needed, they must go through a governed update mechanism with user notification period.

**Test Case**: Add regression test that attempts to call `CreateScheme` twice with different `MinimumLockMinutes` values and verifies the second call fails.

### Proof of Concept

**Initial State**:
- Scheme manager address: `0xSchemeManager`
- User address: `0xUser`
- User has 10,000 ELF tokens approved for TokenHolder contract

**Attack Sequence**:

1. **Manager creates initial scheme** (T=0):
   ```
   CreateScheme({
       Symbol: "ELF",
       MinimumLockMinutes: 1
   })
   ```
   Result: Scheme created with 1-minute lock

2. **User registers for profits** (T=0):
   ```
   RegisterForProfits({
       SchemeManager: 0xSchemeManager,
       Amount: 10000
   })
   ```
   Result: 10,000 ELF locked, `State.LockTimestamp[lockId] = T=0`

3. **Manager front-runs withdrawal** (T=0.5 minutes):
   ```
   CreateScheme({
       Symbol: "ELF",
       MinimumLockMinutes: 100000000
   })
   ```
   Result: New scheme overwrites old one with 100M minute lock period

4. **User attempts withdrawal** (T=2 minutes, after original 1-minute lock expires):
   ```
   Withdraw(0xSchemeManager)
   ```
   Expected: Withdrawal succeeds (2 minutes > 1 minute)
   
   Actual: Transaction reverts with "Cannot withdraw." because:
   - `LockTimestamp = T=0`
   - `scheme.MinimumLockMinutes = 100000000`
   - Check fails: `T=0 + 100000000 minutes < T=2 minutes` is FALSE

**Success Condition**: User's 10,000 ELF remains locked and unrecoverable for ~190 years despite registering under a 1-minute lock period.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-177)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-228)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L56-60)
```csharp
        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
        State.SchemeInfos[schemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```
