### Title
Method Fee Controller Can DOS Contract by Setting Fees in Zero-Supply Tokens

### Summary
The method fee controller can set transaction fees in burnable tokens without validation that the tokens have circulating supply, enabling a complete denial-of-service attack. By setting method fees exclusively in a custom token with zero issued supply and marking fees as size-free, the controller can make all transactions impossible to execute as the pre-execution plugin blocks transactions when fee payment fails.

### Finding Description

The vulnerability exists in the fee validation and charging mechanism across multiple components:

**Root Cause - Insufficient Validation:**
The `AssertValidFeeToken` method only validates that a token exists and is burnable, with no checks on circulating supply or availability: [1](#0-0) 

**Fee Setting Path:**
The controller can set method fees via `SetMethodFee` which only requires controller authorization: [2](#0-1) 

**Fee Charging Failure:**
When fees cannot be paid, `ChargeTransactionFees` returns `Success = false`: [3](#0-2) 

**Transaction Blocking:**
The pre-execution plugin blocks transaction execution when fee charging fails: [4](#0-3) 

**Attack Execution Path:**
1. Controller creates a burnable token where they are the issuer
2. Controller calls `SetMethodFee` with fees ONLY in this custom token and `IsSizeFeeFree = true`
3. Controller never issues any tokens (supply remains zero) or burns all issued supply
4. Users attempt transactions but cannot pay fees as the token is unavailable
5. Pre-execution plugin blocks all transactions with "Transaction fee not enough"

### Impact Explanation

**Critical Operational Impact:**
- Complete denial-of-service of affected contract methods
- Users cannot execute any transactions requiring method fees
- Contract functionality becomes permanently inaccessible until controller reverses the fee settings
- Affects all users of the contract without discrimination

**Affected Scope:**
The attack can target any method by setting its fees, including critical functions like `Transfer`, `Approve`, `Issue`, effectively bricking the entire token contract. The DOS persists until the controller (or governance if controller is Parliament) submits and approves a proposal to reset fees to accessible tokens.

**Severity Justification:**
Critical severity due to complete functional disruption with no user-side mitigation possible. While the impact is binary (complete DOS), the prerequisite of controller compromise mitigates practical likelihood.

### Likelihood Explanation

**Attacker Capabilities Required:**
The attacker must control the method fee controller, which by default is Parliament's default organization requiring 2/3 block producer approval: [5](#0-4) 

**Attack Complexity:**
Once controller access is obtained, the attack is trivial:
- Single call to `SetMethodFee` with custom token parameters
- No complex transaction sequences or timing requirements
- Immediate and permanent effect

**Feasibility Conditions:**
- Requires governance compromise (Parliament control) OR prior malicious controller change
- Token creation and issuer role are unrestricted capabilities
- No detection mechanisms exist in the fee validation logic

**Likelihood Assessment:**
LOW to MEDIUM likelihood. While governance compromise is typically low probability in properly functioning systems, it represents a severe failure mode. If governance is compromised through miner collusion, validator key compromise, or social engineering, this attack becomes immediately executable with guaranteed success.

### Recommendation

**Immediate Mitigation - Add Supply Validation:**

Modify `AssertValidFeeToken` in `TokenContract_ACS1_MethodFeeProvider.cs` to validate circulating supply:

```csharp
private void AssertValidFeeToken(string symbol, long amount)
{
    AssertValidSymbolAndAmount(symbol, amount);
    var tokenInfo = GetTokenInfo(symbol);
    if (tokenInfo == null)
    {
        throw new AssertionException("Token is not found");
    }
    Assert(tokenInfo.IsBurnable, $"Token {symbol} cannot set as method fee.");
    
    // NEW: Validate token has circulating supply
    Assert(tokenInfo.Supply > 0, $"Token {symbol} has zero circulating supply and cannot be used for method fees.");
}
```

**Additional Protections:**

1. **Require Primary Token Inclusion:** When `IsSizeFeeFree = false` is not set, at least one fee token should be the primary token (ELF) or another whitelisted common token

2. **Minimum Supply Threshold:** Consider requiring tokens used for fees to have a minimum circulating supply percentage relative to total supply

3. **Fee Fallback Mechanism:** Implement fallback to size-fee-only charging if base fee payment fails, preventing complete DOS

4. **Governance Monitoring:** Add events and monitoring for method fee changes to detect suspicious fee configurations

**Test Cases:**
- Test setting fees in token with zero issued supply (should fail)
- Test setting fees in token where all supply has been burned (should fail)
- Test setting fees with `IsSizeFeeFree = true` and unavailable token (should fail or fall back)

### Proof of Concept

**Initial State:**
- Attacker controls method fee controller (Parliament default organization compromised)
- Target contract (e.g., MultiToken) has normal ELF-based fees

**Attack Steps:**

1. **Create Custom Token:**
   ```
   Call TokenContract.Create({
     Symbol: "ATTACK",
     IsBurnable: true,
     TotalSupply: 1000000,
     Issuer: AttackerAddress,
     Owner: AttackerAddress
   })
   ```

2. **Set Method Fees to Attack Token:**
   ```
   Call TokenContract.SetMethodFee({
     MethodName: "Transfer",
     Fees: [{ Symbol: "ATTACK", BasicFee: 100 }],
     IsSizeFeeFree: true
   })
   ```

3. **Do Not Issue Any Tokens:**
   - Skip calling `Issue` method
   - Token supply remains 0
   - No user can obtain ATTACK tokens

4. **Attempt Normal Transaction:**
   ```
   User calls TokenContract.Transfer({
     To: RecipientAddress,
     Symbol: "ELF",
     Amount: 100
   })
   ```

**Expected vs Actual Result:**
- **Expected (without vulnerability):** Transaction executes with fees charged in available tokens or validation prevents fee setting
- **Actual (with vulnerability):** 
  - Pre-execution plugin calls `ChargeTransactionFees`
  - Fee charging fails (ATTACK token has zero supply)
  - Returns `Success = false, ChargingInformation = "Transaction fee not enough"`
  - Plugin blocks transaction execution via `IsStopExecuting` return value `true`
  - User transaction never executes

**Success Condition:**
All transactions requiring the affected method are permanently blocked until controller resets fees to accessible tokens.

---

**Notes:**

This vulnerability represents a specific abuse vector requiring governance-level compromise. While the prerequisite significantly reduces practical likelihood, the missing supply validation enables a trivial and complete DOS attack once controller access is obtained. The mitigation is straightforward: validate that tokens used for fees have positive circulating supply.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L91-109)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo();

        // Parliament Auth Contract maybe not deployed.
        if (State.ParliamentContract.Value != null)
        {
            defaultAuthority.OwnerAddress =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
            defaultAuthority.ContractAddress = State.ParliamentContract.Value;
        }

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L123-132)
```csharp
    private void AssertValidFeeToken(string symbol, long amount)
    {
        AssertValidSymbolAndAmount(symbol, amount);
        var tokenInfo = GetTokenInfo(symbol);
        if (tokenInfo == null)
        {
            throw new AssertionException("Token is not found");
        }
        Assert(tokenInfo.IsBurnable, $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L84-126)
```csharp
    private ChargeTransactionFeesOutput TryToChargeTransactionFee(ChargeTransactionFeesInput input, Address fromAddress,
        TransactionFeeBill bill, TransactionFreeFeeAllowanceBill allowanceBill, Dictionary<string, long> fee,
        bool isSizeFeeFree)
    {
        Context.LogDebug(() => "TryToChargeTransactionFee Start");
        var chargingResult =
            ChargeTransactionFeesToBill(input, fromAddress, ref bill, ref allowanceBill, fee, isSizeFeeFree);
        if (!chargingResult)
        {
            var delegatorAddress = fromAddress;
            chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                isSizeFeeFree, delegatorAddress);
        }

        if (!chargingResult)
        {
            var transactionFeeDelegatees =
                State.TransactionFeeDelegateInfoMap[fromAddress][input.ContractAddress][input.MethodName] ??
                State.TransactionFeeDelegateesMap[fromAddress];
            if (transactionFeeDelegatees != null)
            {
                var delegateeAddress = transactionFeeDelegatees.Delegatees;
                foreach (var (delegatee, _) in delegateeAddress)
                {
                    chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                        isSizeFeeFree, Address.FromBase58(delegatee));
                    if (chargingResult)
                    {
                        break;
                    }
                }
            }
        }

        ModifyBalance(fromAddress, bill, allowanceBill);
        var chargingOutput = new ChargeTransactionFeesOutput { Success = chargingResult };
        if (!chargingResult)
            chargingOutput.ChargingInformation = "Transaction fee not enough.";
        
        Context.LogDebug(() => "TryToChargeTransactionFee End");
        Context.LogDebug(() => "ChargeTransactionFees End");
        return chargingOutput;
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L123-129)
```csharp
    public bool IsStopExecuting(ByteString txReturnValue, out string preExecutionInformation)
    {
        var chargeTransactionFeesOutput = new ChargeTransactionFeesOutput();
        chargeTransactionFeesOutput.MergeFrom(txReturnValue);
        preExecutionInformation = chargeTransactionFeesOutput.ChargingInformation;
        return !chargeTransactionFeesOutput.Success;
    }
```
