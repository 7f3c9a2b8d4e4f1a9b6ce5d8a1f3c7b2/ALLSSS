### Title
Authorization Bypass in Secret Sharing Allows Malicious Miners to Corrupt Other Miners' PreviousInValue

### Summary
The `UpdateLatestSecretPieces()` function accepts caller-provided `RevealedInValues` without cryptographic validation, allowing a malicious miner to set arbitrary `PreviousInValue` for other miners. This bypasses the proper secret reconstruction mechanism and enables unauthorized state modification that can manipulate consensus signatures and miner ordering.

### Finding Description

The vulnerability exists in the `UpdateLatestSecretPieces()` function which processes revealed in-values during block generation: [1](#0-0) 

This code iterates through `triggerInformation.RevealedInValues` and directly updates the `PreviousInValue` field for other miners with only two checks: (1) the target miner exists, and (2) their `PreviousInValue` is currently empty or null. **There is no validation that the revealed values are correctly reconstructed from on-chain decrypted secret shares.**

The trigger information containing `RevealedInValues` comes from the off-chain service: [2](#0-1) 

While the legitimate off-chain `SecretSharingService` properly reconstructs these values using Shamir's Secret Sharing: [3](#0-2) 

A malicious miner can modify their node to provide arbitrary values instead. The contract has a separate on-chain function `RevealSharedInValues()` that performs proper validation and reconstruction: [4](#0-3) 

However, `UpdateLatestSecretPieces()` bypasses this validation entirely. The corrupted values are then propagated through the consensus flow: [5](#0-4) 

And finally persisted to state without validation: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Compromise**: The `PreviousInValue` field is critical for consensus security. It is used to calculate signatures via `CalculateSignature()`: [7](#0-6) 

These signatures determine miner order for the next round: [8](#0-7) 

By setting arbitrary `PreviousInValue` for other miners, an attacker can:
1. **Manipulate signatures**: Corrupt the signature calculation for other miners, affecting the XOR-based random number generation
2. **Control miner ordering**: Influence the `supposedOrderOfNextRound` calculation, potentially favoring themselves with better time slots
3. **Break consensus invariants**: Cause validation failures for honest miners whose `PreviousInValue` no longer matches their `OutValue` from the previous round [9](#0-8) 

The validation expects `hash(previousInValue) == previousOutValue`, but a malicious miner can set values that violate this, causing honest miners to fail validation.

**Affected Parties**: All miners in the network whose `PreviousInValue` is empty/null are vulnerable to having their consensus state corrupted by any other miner.

### Likelihood Explanation

**Attacker Capabilities**: Any active miner can execute this attack by modifying their node software to inject arbitrary `RevealedInValues` in the trigger information provider. No special permissions or economic barriers exist beyond being selected as a miner.

**Attack Complexity**: Low. The attacker only needs to:
1. Modify their node's `AEDPoSTriggerInformationProvider.GetTriggerInformationForConsensusTransactions()` to inject false `RevealedInValues`
2. Produce a block normally - their modified trigger information is processed via the ACS4 interface: [10](#0-9) 

**Feasibility**: The attack is immediately executable by any miner at any time. The entry point `GetConsensusExtraData()` is called during normal block production, making this a natural attack vector with no additional transaction overhead.

**Detection**: Difficult to detect as the malicious values appear in consensus extra data and state updates occur through normal consensus processing paths.

### Recommendation

**Code-Level Mitigation**: Add cryptographic verification in `UpdateLatestSecretPieces()` to ensure revealed InValues match reconstruction from on-chain decrypted pieces:

```csharp
foreach (var revealedInValue in triggerInformation.RevealedInValues)
{
    if (!updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
        continue;
        
    var targetMiner = updatedRound.RealTimeMinersInformation[revealedInValue.Key];
    
    if (targetMiner.PreviousInValue != Hash.Empty && targetMiner.PreviousInValue != null)
        continue;
    
    // VALIDATION: Reconstruct from decrypted pieces and verify match
    if (targetMiner.DecryptedPieces.Count < minersCount)
        continue;
        
    var orders = targetMiner.DecryptedPieces.Select((t, i) =>
        updatedRound.RealTimeMinersInformation.Values
            .First(m => m.Pubkey == targetMiner.DecryptedPieces.Keys.ToList()[i]).Order)
        .ToList();
        
    var sharedParts = targetMiner.DecryptedPieces.Values.ToList()
        .Select(s => s.ToByteArray()).ToList();
        
    var reconstructedValue = HashHelper.ComputeFrom(
        SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
    
    // Only accept if revealed value matches reconstruction
    if (reconstructedValue == revealedInValue.Value)
        targetMiner.PreviousInValue = revealedInValue.Value;
}
```

**Invariant Checks**: 
1. Revealed InValues MUST be cryptographically verifiable against on-chain decrypted pieces
2. Only values that can be reconstructed from threshold number of decrypted shares should be accepted
3. Add assertion that prevents modification of non-empty `PreviousInValue` fields

**Test Cases**: Add regression tests that:
1. Verify rejection of incorrect revealed InValues
2. Ensure only properly reconstructed values are accepted
3. Test that malicious trigger information cannot corrupt other miners' state

### Proof of Concept

**Initial State**:
- Network with multiple miners in current round
- Miner A (attacker) is scheduled to produce next block
- Miner B has empty `PreviousInValue` (normal state before revelation)
- Miner B has shared encrypted pieces in previous round

**Attack Steps**:
1. Attacker modifies their node's `AEDPoSTriggerInformationProvider.GetTriggerInformationForConsensusTransactions()`
2. Injects malicious entry in `RevealedInValues`: `{ "MinerB_pubkey": malicious_hash }`
3. Produces block normally - block generation calls `GetConsensusExtraData()`
4. `GetConsensusBlockExtraData()` processes the malicious trigger information
5. `UpdateLatestSecretPieces()` accepts the malicious hash without validation
6. `ExtractInformationToUpdateConsensus()` includes corrupted value in `MinersPreviousInValues`
7. `UpdateValue` transaction executes, calling `PerformSecretSharing()`
8. Miner B's `PreviousInValue` is now set to attacker's arbitrary value

**Expected Result**: The system should reject revealed InValues that don't match secret reconstruction from on-chain decrypted pieces.

**Actual Result**: The attacker successfully sets Miner B's `PreviousInValue` to an arbitrary value, which will:
- Cause Miner B's signature calculation to be corrupted
- Potentially cause Miner B to fail validation in subsequent rounds
- Allow attacker to manipulate random number generation and miner ordering

**Success Condition**: After the attack, querying `GetRoundInformation()` shows Miner B's `PreviousInValue` matches the attacker's injected value rather than the legitimate secret-shared value.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L112-114)
```csharp
            var revealedInValues = _secretSharingService.GetRevealedInValues(hint.RoundId);
            foreach (var revealedInValue in revealedInValues)
                trigger.RevealedInValues.Add(revealedInValue.Key, revealedInValue.Value);
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L175-176)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-52)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-59)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }
```
