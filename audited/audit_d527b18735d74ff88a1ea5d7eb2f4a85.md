### Title
Missing Validation of Critical Consensus Fields Allows Miners to Corrupt Round State and Manipulate Mining Order

### Summary
The `UpdateValueValidationProvider.ValidateHeaderInformation()` method fails to validate multiple critical consensus fields including `SupposedOrderOfNextRound`, `TuneOrderInformation`, and `MinersPreviousInValues`. These unvalidated fields are directly applied to the round state during `ProcessUpdateValue`, allowing malicious miners to arbitrarily manipulate next-round mining orders and corrupt the secret sharing mechanism. Additionally, `NextRoundMiningOrderValidationProvider` contains a bug that fails to detect duplicate `FinalOrderOfNextRound` values, compounding the vulnerability.

### Finding Description

The `UpdateValueValidationProvider.ValidateHeaderInformation()` method only validates three fields: [1](#0-0) 

Specifically, it validates that `OutValue` and `Signature` are non-null/non-empty: [2](#0-1) 

And validates `PreviousInValue` matches the previous `OutValue`: [3](#0-2) 

However, the `UpdateValueInput` message contains many additional critical fields that are never validated: [4](#0-3) 

During block execution, `ProcessUpdateValue` directly applies these unvalidated fields to the round state:

**1. SupposedOrderOfNextRound (line 246)** - Should be calculated as `GetAbsModulus(signature.ToInt64(), minersCount) + 1` but is accepted without validation: [5](#0-4) 

The correct calculation method is defined here: [6](#0-5) 

**2. TuneOrderInformation (lines 259-260)** - Allows setting arbitrary `FinalOrderOfNextRound` for OTHER miners without validation: [7](#0-6) 

**3. MinersPreviousInValues (lines 295-296)** - Allows setting arbitrary `PreviousInValue` for OTHER miners in secret sharing: [8](#0-7) 

The `FinalOrderOfNextRound` values are critical because they determine mining order in the next round: [9](#0-8) 

During validation, `RecoverFromUpdateValue` updates ALL miners' fields from the provided round without validation: [10](#0-9) 

Furthermore, `NextRoundMiningOrderValidationProvider` has a critical bug where `Distinct()` operates on `MinerInRound` objects (reference types) instead of the `FinalOrderOfNextRound` values, failing to catch duplicate orders: [11](#0-10) 

The updated round state is then persisted to storage: [12](#0-11) 

### Impact Explanation

**Consensus/Cross-Chain Integrity Impact:**
1. **Mining Order Manipulation**: By providing arbitrary `TuneOrderInformation`, a malicious miner can manipulate other miners' `FinalOrderOfNextRound` values, controlling who mines when in the next round. This violates the deterministic mining schedule that should be based on signature calculations.

2. **Miner Exclusion**: By setting other miners' `SupposedOrderOfNextRound` to 0 through the provided round data, attackers can cause honest miners to be excluded from `GetMinedMiners()` and counted as having missed their slots: [13](#0-12) 

3. **Secret Sharing Corruption**: By providing malicious `MinersPreviousInValues`, attackers can corrupt other miners' `PreviousInValue` fields, breaking the secret sharing scheme used for random number generation and consensus validation.

4. **Duplicate Order Chaos**: The bug in `NextRoundMiningOrderValidationProvider` combined with lack of validation allows duplicate `FinalOrderOfNextRound` values to persist, causing undefined behavior when `OrderBy` is used to sort miners by order.

**Severity**: HIGH - This directly compromises consensus integrity, the mining schedule, and the random number generation mechanism. Multiple miners could end up with the same time slot, or miners could be assigned to mine at incorrect times, causing consensus disruption and potential chain halts.

### Likelihood Explanation

**Reachable Entry Point**: The `UpdateValue` method is a standard entry point called by miners when producing blocks: [14](#0-13) 

**Attacker Capabilities**: Any miner can exploit this vulnerability. They simply need to:
1. Construct an `UpdateValueInput` with manipulated `TuneOrderInformation` or `MinersPreviousInValues`
2. Submit it as part of their block production

**Execution Practicality**: The exploit is straightforward:
- No special permissions beyond being a miner
- No complex state setup required
- Direct modification of the `UpdateValueInput` message before submission
- The validation flow accepts the malicious data without checks

**Detection Constraints**: The lack of validation means the malicious values are not flagged during block validation. The manipulated state becomes canonical once the block is accepted.

**Likelihood**: HIGH - The attack requires minimal sophistication and is directly executable by any miner producing blocks.

### Recommendation

**1. Validate SupposedOrderOfNextRound** in `UpdateValueValidationProvider.ValidateHeaderInformation()`:
```csharp
// Add after line 17 in UpdateValueValidationProvider.cs
var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
if (minerInRound.SupposedOrderOfNextRound != 0)
{
    var expectedOrder = GetAbsModulus(minerInRound.Signature.ToInt64(), 
        validationContext.ProvidedRound.RealTimeMinersInformation.Count) + 1;
    if (minerInRound.SupposedOrderOfNextRound != expectedOrder)
        return new ValidationResult { Message = "Invalid SupposedOrderOfNextRound calculation." };
}
```

**2. Validate TuneOrderInformation** - Verify it only contains legitimate conflict resolutions by checking against expected values from `ApplyNormalConsensusData` logic.

**3. Validate MinersPreviousInValues** - Ensure values are consistent with the previous round's state and secret sharing protocol.

**4. Fix NextRoundMiningOrderValidationProvider bug**:
```csharp
// Replace line 15-16 in NextRoundMiningOrderValidationProvider.cs
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
```

**5. Add test cases** verifying rejection of:
- Incorrect `SupposedOrderOfNextRound` values
- Duplicate `FinalOrderOfNextRound` assignments
- Arbitrary `MinersPreviousInValues`

### Proof of Concept

**Initial State:**
- Blockchain with 5 miners in current round
- Miner A is scheduled to produce next block
- All miners have correct `SupposedOrderOfNextRound` from previous blocks

**Attack Steps:**
1. Miner A produces a block with `UpdateValue` behavior
2. Miner A constructs `UpdateValueInput` with malicious `TuneOrderInformation`:
   - Sets Miner B's `FinalOrderOfNextRound` = 1
   - Sets Miner C's `FinalOrderOfNextRound` = 1 (duplicate)
   - Sets their own `FinalOrderOfNextRound` = 1 (duplicate)
3. Also provides malicious `MinersPreviousInValues` with incorrect hash values for Miner D and E
4. Submits the block

**Expected Result:**
- Validation should reject the block due to invalid `TuneOrderInformation` and `MinersPreviousInValues`

**Actual Result:**
- `UpdateValueValidationProvider` does not validate these fields
- `NextRoundMiningOrderValidationProvider` fails to catch duplicates due to `Distinct()` bug
- Block is accepted
- `ProcessUpdateValue` applies the malicious values to state
- Next round generation uses corrupted `FinalOrderOfNextRound` values
- Multiple miners are assigned order 1, causing time slot conflicts
- Miners D and E have corrupted `PreviousInValue`, causing their blocks to fail validation
- Consensus disruption occurs

**Success Condition:** Malicious miner's block is accepted and the corrupted consensus data persists in the round state, disrupting subsequent round generation and secret sharing validation.

### Notes

The vulnerability exists because the validation layer (`UpdateValueValidationProvider`) is incomplete, while the execution layer (`ProcessUpdateValue`) trusts the input data. The compounding bug in `NextRoundMiningOrderValidationProvider` where `Distinct()` doesn't work properly on reference types means even the limited validation for next-round orders is ineffective. This creates a comprehensive failure in consensus data integrity validation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** protobuf/aedpos_contract.proto (L194-221)
```text
message UpdateValueInput {
    // Calculated from current in value.
    aelf.Hash out_value = 1;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 2;
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
    // Publish previous in value for validation previous signature and previous out value.
    aelf.Hash previous_in_value = 4;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    google.protobuf.Timestamp actual_mining_time = 5;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 6;
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 8;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 9;
    // The amount of produced blocks.
    int64 produced_blocks = 10;
    // The InValue in the previous round, miner public key -> InValue.
    map<string, aelf.Hash> miners_previous_in_values = 11;
    // The irreversible block height that miner recorded.
    int64 implied_irreversible_block_height = 12;
    // The random number.
    bytes random_number = 13;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-22)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-100)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
```
