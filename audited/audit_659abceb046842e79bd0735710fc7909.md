### Title
Missing Defensive Null Checks in MethodFeeController Initialization Leading to Permanent State Corruption

### Summary
The `RequiredMethodFeeControllerSet()` method in ElectionContract lacks defensive null checks present in other ACS1 implementations (TokenContract, ProfitContract), making it vulnerable to permanent state corruption if the Parliament contract is unavailable during initialization. This causes all method fee management functions to become permanently locked, as the controller is set with null fields that cannot be changed.

### Finding Description

The ElectionContract's `RequiredMethodFeeControllerSet()` implementation directly initializes the MethodFeeController without validating that the Parliament contract is available or that the returned addresses are non-null. [1](#0-0) 

The method calls `GetParliamentDefaultAddress()` which internally accesses the Parliament contract: [2](#0-1) 

**Root Cause:** If `Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName)` returns null (Parliament not deployed), the subsequent call to `State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty())` will fail with a null reference exception, or in edge cases, return null/default values that corrupt the state.

**Comparison with Secure Implementations:**

TokenContract handles this scenario defensively with explicit null checks: [3](#0-2) 

ProfitContract uses a validation helper before accessing Parliament: [4](#0-3) 

**Why Protections Fail:** The ElectionContract has no null validation, making it vulnerable when:
1. Parliament contract is not yet deployed during side-chain initialization
2. Contract deployment order is incorrect
3. Contract addresses are not properly registered in the system

Once `State.MethodFeeController.Value` is set with null fields, all subsequent operations fail: [5](#0-4) [6](#0-5) 

### Impact Explanation

**Operational Impact - DoS of Method Fee Management:**
1. `SetMethodFee` permanently fails: Authorization check `Context.Sender == State.MethodFeeController.Value.OwnerAddress` becomes `Context.Sender == null`, which always evaluates to false, blocking all method fee updates
2. `ChangeMethodFeeController` permanently fails: Same authorization check prevents fixing the corrupted state
3. `GetMethodFeeController` returns invalid data: Returns AuthorityInfo with null `OwnerAddress` and/or `ContractAddress`, violating state invariants

**Affected Parties:**
- Contract administrators lose ability to configure transaction fees
- Users cannot adjust fee structures for Election contract methods
- Governance operations requiring fee adjustments are blocked

**Severity:** High - While this doesn't directly steal funds, it permanently breaks critical governance functionality of the method fee provider system, which is part of the ACS1 standard that all system contracts must implement correctly.

### Likelihood Explanation

**Feasibility:** High likelihood in specific scenarios:

1. **Side-chain deployment:** When deploying a new side-chain, if contracts are initialized in wrong order or Parliament initialization fails, ElectionContract's first ACS1 method call will trigger the corrupted initialization

2. **Test environments:** Development and testing scenarios where full system contract suite may not be properly initialized

3. **Contract upgrades:** If Parliament contract address changes or becomes temporarily unavailable during upgrade procedures

**Preconditions:**
- Parliament contract not deployed/initialized when ElectionContract's first ACS1 method (SetMethodFee, ChangeMethodFeeController, or GetMethodFeeController) is called
- No attacker action required - this is a deployment/initialization vulnerability

**Detection:** The issue manifests immediately on first call to any ACS1 method, making it easily detectable but difficult to recover from without contract redeployment.

**Execution Complexity:** None - occurs automatically during normal initialization flow.

### Recommendation

**Code-Level Mitigation:**

Implement defensive null checks following the TokenContract pattern:

```csharp
private void RequiredMethodFeeControllerSet()
{
    if (State.MethodFeeController.Value != null) return;
    
    // Ensure Parliament contract reference is set
    if (State.ParliamentContract.Value == null)
        State.ParliamentContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

    var defaultAuthority = new AuthorityInfo();

    // Parliament Auth Contract maybe not deployed.
    if (State.ParliamentContract.Value != null)
    {
        defaultAuthority.OwnerAddress = 
            State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
        defaultAuthority.ContractAddress = State.ParliamentContract.Value;
    }

    State.MethodFeeController.Value = defaultAuthority;
}
```

**Alternative:** Use ProfitContract's `ValidateContractState` helper pattern: [7](#0-6) 

**Invariant Checks to Add:**
1. Assert Parliament contract address is non-null before initialization
2. Assert returned organization address is valid before storing
3. Add integration tests verifying graceful handling of missing dependencies

**Test Cases:**
1. Test ElectionContract initialization when Parliament is not deployed
2. Test recovery path when Parliament becomes available after initial failure
3. Test all ACS1 methods with uninitialized Parliament contract

### Proof of Concept

**Initial State:**
- ElectionContract deployed and initialized via `InitialElectionContract`
- Parliament contract NOT deployed or not properly initialized
- `State.MethodFeeController.Value` is null (not yet initialized)

**Transaction Steps:**

1. **Trigger**: Admin attempts to call `SetMethodFee` to configure transaction fees
   - Input: MethodFees with valid token symbols and amounts
   - Expected: Method fee should be set with Parliament as default controller

2. **Execution Flow**:
   - Line 14: Calls `RequiredMethodFeeControllerSet()`
   - Line 51: Check passes (`State.MethodFeeController.Value == null`)
   - Line 55: Calls `GetParliamentDefaultAddress()`
   - In GetParliamentDefaultAddress (ElectionContract_Candidate.cs):
     - Line 68-70: Sets `State.ParliamentContract.Value` to result of `Context.GetContractAddressByName(...)`
     - **Result**: Returns null if Parliament not deployed
     - Line 72: Attempts to call `GetDefaultOrganizationAddress` on null reference
     - **Result**: Throws exception OR returns null/default address
   - Line 56: Gets null from `Context.GetContractAddressByName(...)`
   - Lines 53-59: Creates AuthorityInfo with null OwnerAddress and/or ContractAddress
   - Line 59: Stores corrupted AuthorityInfo to state

3. **Result**: 
   - `State.MethodFeeController.Value` now contains AuthorityInfo with null fields
   - Line 16: `Assert(Context.Sender == null, ...)` fails with "Unauthorized to set method fee."

4. **Recovery Attempt**: Admin tries `ChangeMethodFeeController` with valid AuthorityInfo
   - Line 23: Calls `RequiredMethodFeeControllerSet()` (no-op, already set)
   - Line 24: `AssertSenderAddressWith(null)` fails with "Unauthorized behavior."
   - **No recovery possible without redeploying contract**

**Success Condition for Exploit**: Method fee management system permanently broken, requiring contract redeployment to fix.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L11-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L49-60)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = GetParliamentDefaultAddress(),
            ContractAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName)
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L66-73)
```csharp
    private Address GetParliamentDefaultAddress()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        return State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L91-109)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo();

        // Parliament Auth Contract maybe not deployed.
        if (State.ParliamentContract.Value != null)
        {
            defaultAuthority.OwnerAddress =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
            defaultAuthority.ContractAddress = State.ParliamentContract.Value;
        }

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L71-83)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        ValidateContractState(State.ParliamentContract, SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L931-936)
```csharp
    private void ValidateContractState(ContractReferenceState state, string contractSystemName)
    {
        if (state.Value != null)
            return;
        state.Value = Context.GetContractAddressByName(contractSystemName);
    }
```
