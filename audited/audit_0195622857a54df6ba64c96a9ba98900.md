### Title
Governance Controller Bypass via Malicious Contract Address in AuthorityInfo Validation

### Summary
The `CheckOrganizationExist()` function in BasicContractZero_Helper.cs unconditionally trusts the return value from any contract address provided in `AuthorityInfo.ContractAddress` without validating that it is a legitimate governance contract (Parliament, Association, or Referendum). An attacker can deploy a malicious contract that always returns true for `ValidateOrganizationExist`, then through a governance proposal, change critical system controllers to this malicious authority, achieving complete bypass of governance controls.

### Finding Description

The vulnerability exists in the `CheckOrganizationExist` helper function that validates `AuthorityInfo` structures before accepting them as new controllers: [1](#0-0) 

This function performs a cross-contract call to `authorityInfo.ContractAddress` and trusts the returned `BoolValue.Value` without any validation that the contract address is a registered system governance contract.

**Critical Usage Points:**

1. **ChangeContractDeploymentController** - Controls who can deploy contracts: [2](#0-1) 

2. **ChangeCodeCheckController** - Controls code validation for deployments: [3](#0-2) 

3. **Multiple MultiToken controller changes** - Controls token fees, cross-chain registration, and transfer blacklists: [4](#0-3) 

**Root Cause:** The system assumes all contracts implementing `ValidateOrganizationExist` will behave honestly, but there is no whitelist or validation ensuring `ContractAddress` points to a legitimate governance contract (Parliament, Association, or Referendum).

**Why Existing Protections Fail:**

Legitimate governance contracts implement `ValidateOrganizationExist` by checking their state: [5](#0-4) [6](#0-5) 

However, a malicious contract can implement the same interface but always return true:
```csharp
public override BoolValue ValidateOrganizationExist(Address input)
{
    return new BoolValue { Value = true }; // Always returns true
}
```

The system has a `ValidateSystemContractAddress` method that could verify contract addresses: [7](#0-6) 

However, this validation is **never called** in the controller change methods, leaving the system vulnerable.

### Impact Explanation

**Direct Governance Bypass:**
Once an attacker successfully changes a controller to their malicious contract, they gain unilateral control over critical system functions:

1. **Contract Deployment Authority** - Can deploy any contract without legitimate governance approval, including contracts that:
   - Mint unlimited tokens
   - Bypass consensus rules
   - Manipulate cross-chain verification

2. **Code Check Authority** - Can bypass code validation restrictions, deploying contracts with:
   - Forbidden APIs (DateTime.Now, Random, etc.)
   - Malicious logic
   - Backdoors

3. **Token Control Authority** - Can:
   - Modify transaction fee controllers unilaterally
   - Change transfer blacklist controllers
   - Control cross-chain token registration

**Severity Justification:** This is a **HIGH** severity issue because:
- Breaks the fundamental governance invariant that "only existing organizations can execute proposals"
- Enables complete bypass of all governance controls once exploited
- Affects multiple critical system contracts (Genesis, MultiToken, CrossChain, etc.)
- Leads to unauthorized contract deployment, token manipulation, and system configuration changes
- No way to recover once a controller is compromised without another governance vote

### Likelihood Explanation

**Attack Prerequisites:**
1. **Deploy Malicious Contract** - Attacker must deploy a contract with a malicious `ValidateOrganizationExist` method. Current code check restrictions focus on structure and type whitelists but would NOT prevent a simple method that returns `true`.

2. **Create Governance Proposal** - Attacker or compromised governance member must create a proposal to change the controller, providing `AuthorityInfo` with:
   - `ContractAddress`: Malicious contract address
   - `OwnerAddress`: Attacker-controlled address

3. **Get Proposal Approved** - The proposal must pass the organization's approval threshold. This requires either:
   - Social engineering organization members who don't verify the contract address
   - Compromised organization member(s) with sufficient voting power
   - Exploiting another vulnerability to manipulate votes

4. **Release Proposal** - The proposer releases the approved proposal, executing the controller change.

**Feasibility Assessment:**
- **Entry Point**: Public methods `ChangeContractDeploymentController` and similar are reachable ✓
- **Preconditions**: Requires governance participation but realistic with social engineering ✓
- **Execution**: Standard proposal workflow, no special capabilities required ✓
- **Detection**: Difficult - organization members may not verify contract addresses are legitimate governance contracts ✓

**Likelihood Rating: MEDIUM-HIGH**
While requiring a governance proposal approval, the attack is practical because:
- No technical barriers prevent deploying the malicious contract
- Proposal parameters (contract addresses) are not easily verifiable by non-technical governance members
- Once executed, the change appears legitimate in the system state
- Multiple attack opportunities exist across different controller types

### Recommendation

**Immediate Fix:**
Add validation in `CheckOrganizationExist` to ensure `ContractAddress` is a registered system governance contract:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a registered governance contract
    var parliamentAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    var associationAddress = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    var referendumAddress = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress ||
        authorityInfo.ContractAddress == associationAddress ||
        authorityInfo.ContractAddress == referendumAddress,
        "Invalid governance contract address.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Additional Safeguards:**
1. Add invariant check in all controller change methods to validate the governance contract type
2. Emit events when controllers change, including the contract address for transparency
3. Add view method to query valid governance contract addresses
4. Document requirement that `AuthorityInfo.ContractAddress` must be a system governance contract

**Test Cases:**
1. Test that controller change fails when providing non-governance contract address
2. Test that controller change succeeds only with Parliament/Association/Referendum addresses
3. Test attempt to use malicious contract address is rejected
4. Add integration test verifying governance contract address validation

### Proof of Concept

**Initial State:**
- Genesis contract deployed with default Parliament controller
- Parliament has multiple miners as members
- Attacker has deployed contracts capability

**Attack Steps:**

1. **Deploy Malicious Contract:**
```csharp
public class MaliciousGovernance : Contract
{
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = true }; // Always returns true
    }
}
```
Deploy this contract at address `MALICIOUS_ADDR`

2. **Create Proposal via Compromised Member:**
Create proposal to Parliament calling `ChangeContractDeploymentController` with:
```protobuf
AuthorityInfo {
    contract_address: MALICIOUS_ADDR
    owner_address: ATTACKER_ADDR
}
```

3. **Social Engineering:**
Get proposal approved by convincing Parliament members it's a legitimate governance change (they don't verify the contract address is a real governance contract)

4. **Release Proposal:**
Proposer releases the approved proposal

5. **Expected Result:**
    - `CheckOrganizationExist` calls `MALICIOUS_ADDR.ValidateOrganizationExist(ATTACKER_ADDR)`
    - Malicious contract returns `true`
    - Validation passes
    - `State.ContractDeploymentController.Value` is set to malicious authority

6. **Post-Exploitation:**
Attacker can now:
    - Create proposals to deploy any contract
    - The malicious governance contract always approves
    - Attacker deploys arbitrary contracts without legitimate governance oversight
    - System governance is completely compromised

**Success Condition:** Attacker can deploy arbitrary contracts without legitimate organization approval, breaking the core governance invariant.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L59-64)
```csharp
    public override Empty ValidateSystemContractAddress(ValidateSystemContractAddressInput input)
    {
        var actualAddress = GetContractAddressByName(input.SystemContractHashName);
        Assert(actualAddress == input.Address, "Address not expected.");
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L366-373)
```csharp
    public override Empty ChangeContractDeploymentController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.ContractDeploymentController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L375-382)
```csharp
    public override Empty ChangeCodeCheckController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.CodeCheckController.Value.OwnerAddress);
        Assert(CheckOrganizationExist(input),
            "Invalid authority input.");
        State.CodeCheckController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L45-97)
```csharp
    public override Empty ChangeSymbolsToPayTXSizeFeeController(AuthorityInfo input)
    {
        AssertControllerForSymbolToPayTxSizeFee();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.SymbolToPayTxFeeController.Value = input;
        return new Empty();
    }

    public override Empty ChangeSideChainRentalController(AuthorityInfo input)
    {
        AssertControllerForSideChainRental();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.SideChainRentalController.Value = input;
        return new Empty();
    }

    public override Empty ChangeCrossChainTokenContractRegistrationController(AuthorityInfo input)
    {
        CheckCrossChainTokenContractRegistrationControllerAuthority();
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.CrossChainTokenContractRegistrationController.Value = input;
        return new Empty();
    }

    public override Empty ChangeUserFeeController(AuthorityInfo input)
    {
        AssertUserFeeController();
        Assert(CheckOrganizationExist(input), "Invalid authority input.");
        State.UserFeeController.Value.RootController = input;
        State.UserFeeController.Value.ParliamentController = null;
        State.UserFeeController.Value.ReferendumController = null;
        return new Empty();
    }

    public override Empty ChangeDeveloperController(AuthorityInfo input)
    {
        AssertDeveloperFeeController();
        Assert(CheckOrganizationExist(input), "Invalid authority input.");
        State.DeveloperFeeController.Value.RootController = input;
        State.DeveloperFeeController.Value.ParliamentController = null;
        State.DeveloperFeeController.Value.DeveloperController = null;
        return new Empty();
    }

    public override Empty ChangeTransferBlackListController(AuthorityInfo input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.TransferBlackListController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```
