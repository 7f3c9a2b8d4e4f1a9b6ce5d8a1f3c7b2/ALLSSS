# Audit Report

## Title
Incorrect Balance Validation in Recharge Allows Side Chain to Run Out of Indexing Funds Immediately

## Summary
The `Recharge` function in the CrossChain contract contains a mathematically flawed balance validation formula that double-counts the recharge amount and arrears. This allows side chains to successfully recharge with insufficient funds, causing them to immediately re-enter debt status after the next block indexing operation, disrupting cross-chain data flow and leaving indexing proposers unpaid.

## Finding Description

The vulnerability exists in the balance validation logic when a side chain recharges while in `IndexingFeeDebt` status. [1](#0-0) 

The execution flow has a critical ordering flaw:

1. **Recharge transfer** - The function first transfers `input.Amount` tokens to the side chain's virtual address [2](#0-1) 

2. **Arrears payment** - If the chain is in debt, it pays all accumulated arrears from the side chain's virtual address to creditors [3](#0-2) 

3. **Balance retrieval** - It retrieves the current balance AFTER both operations above [4](#0-3) 

4. **Flawed validation** - It validates using the formula: `input.Amount + originBalance >= arrearsAmount + IndexingPrice` [5](#0-4) 

**Root Cause**: The `GetSideChainIndexingFeeDeposit` helper method [6](#0-5)  returns the balance AFTER the recharge and arrears payment have already executed. Therefore:
- `originBalance = initial_balance + input.Amount - arrearsAmount`

Substituting into the validation formula:
- `input.Amount + (initial_balance + input.Amount - arrearsAmount) >= arrearsAmount + IndexingPrice`
- Simplifies to: `2*input.Amount + initial_balance >= 2*arrearsAmount + IndexingPrice`

The correct check should ensure the final balance covers at least one indexing operation:
- `final_balance >= IndexingPrice`
- `initial_balance + input.Amount - arrearsAmount >= IndexingPrice`
- Rearranged: `initial_balance + input.Amount >= arrearsAmount + IndexingPrice`

The actual formula double-counts both `input.Amount` and `arrearsAmount`, allowing recharges that leave insufficient funds.

**Concrete Example**:
- Initial balance: 5 tokens
- Arrears: 90 tokens  
- IndexingPrice: 20 tokens
- Recharge amount: 100 tokens

Current validation: `100 + 15 >= 90 + 20` → `115 >= 110` ✓ PASSES
But final balance: `5 + 100 - 90 = 15 < 20` ✗ INSUFFICIENT

Correct validation: `5 + 100 >= 90 + 20` → `105 >= 110` ✗ WOULD CORRECTLY FAIL

**Secondary Issue**: When the side chain is NOT in debt status, the validation is completely skipped [7](#0-6) , allowing arbitrarily small recharges regardless of `IndexingPrice`.

## Impact Explanation

**Operational Disruption**: When a side chain successfully recharges with insufficient funds due to this flawed validation, it immediately returns to `IndexingFeeDebt` status after the next indexing operation executes. The indexing mechanism deducts `IndexingPrice` for each indexed block [8](#0-7) , and when the balance becomes negative, the chain enters debt status and arrears accumulate [9](#0-8) .

**Severity Justification (Medium)**:
- Side chain operators experience "successful" recharges that fail operationally
- Proposers who index the next block are not paid, accumulating arrears instead
- Cross-chain data flow is disrupted as chains cycle between Active and Debt states
- No direct fund theft occurs, but protocol operational reliability is severely compromised
- Affects all stakeholders: side chain operators, indexing proposers, and cross-chain applications relying on consistent data availability

The vulnerability breaks the fundamental guarantee that a successful recharge should restore the chain to operational Active status for at least one indexing cycle.

## Likelihood Explanation

**Reachable Entry Point**: The `Recharge` function is a public method callable by any address [10](#0-9) .

**Feasible Preconditions**:
1. A side chain exists with non-zero `IndexingPrice`
2. The chain is in `IndexingFeeDebt` status with accumulated arrears (common scenario)
3. User attempts to recharge with an amount in the vulnerable range: where `2*input.Amount >= arrearsAmount + IndexingPrice` but `input.Amount < arrearsAmount + IndexingPrice`

**Execution Practicality**: This vulnerability triggers during normal operational workflows without requiring any attack intent. Side chain operators routinely recharge their chains, and the flaw manifests whenever the recharge amount falls within the vulnerable mathematical range. This is particularly likely when operators calculate "just enough" to cover arrears without accounting for the next indexing operation.

**Probability Assessment**: High - The flaw will manifest during routine operations whenever recharge amounts are calculated based on arrears alone, which is a natural operational pattern. No special privileges, attack sophistication, or economic irrationality required.

## Recommendation

**Fix 1 - Correct the validation formula for debt status**:
```csharp
if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
{
    // Pay arrears
    foreach (var arrears in sideChainInfo.ArrearsInfo)
    {
        arrearsAmount += arrears.Value;
        TransferDepositToken(new TransferInput
        {
            To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = arrears.Value,
            Memo = "Indexing fee recharging."
        }, chainId);
    }
    
    // FIXED: Check balance BEFORE operations or use correct formula
    var finalBalance = GetSideChainIndexingFeeDeposit(chainId);
    Assert(finalBalance >= sideChainInfo.IndexingPrice,
        "Indexing fee recharging not enough.");
}
```

**Fix 2 - Add validation for non-debt status**:
```csharp
// Always validate sufficient balance after recharge
var finalBalance = GetSideChainIndexingFeeDeposit(chainId);
Assert(finalBalance >= sideChainInfo.IndexingPrice,
    "Insufficient balance for next indexing operation.");
```

## Proof of Concept

```csharp
[Fact]
public async Task RechargeValidation_DoubleCountingVulnerability()
{
    // Setup: Create side chain with IndexingPrice = 20
    var parentChainId = 123;
    long initialLockedToken = 95; // Will create debt scenario
    long indexingPrice = 20;
    var sideChainId = await InitAndCreateSideChainAsync(parentChainId, initialLockedToken, indexingPrice);
    
    // Index blocks to create debt (95 tokens / 20 per block = 4 blocks, then debt)
    for (int i = 1; i <= 5; i++)
    {
        var blockData = CreateSideChainBlockData(HashHelper.ComputeFrom($"block{i}"), i, sideChainId, HashHelper.ComputeFrom("tx"));
        await DoIndexAsync(new CrossChainBlockData { SideChainBlockDataList = { blockData } }, new[] { sideChainId });
    }
    
    // Verify debt status
    var status = await GetSideChainStatusAsync(sideChainId);
    status.ShouldBe(SideChainStatus.IndexingFeeDebt);
    
    var debt = await CrossChainContractStub.GetSideChainIndexingFeeDebt.CallAsync(new Int32Value { Value = sideChainId });
    var arrearsAmount = debt.Value; // Should be 5 tokens (1 block unpaid)
    
    var balanceBefore = await GetSideChainBalanceAsync(sideChainId);
    balanceBefore.ShouldBe(0); // Balance is zero
    
    // Attempt vulnerable recharge: 
    // With arrears=5, IndexingPrice=20, recharge with 15 tokens
    // Current formula: 2*15 + 0 >= 2*5 + 20 → 30 >= 30 ✓ PASSES
    // But final balance: 0 + 15 - 5 = 10 < 20 ✗ INSUFFICIENT
    await ApproveBalanceAsync(15);
    var rechargeResult = await CrossChainContractStub.Recharge.SendAsync(new RechargeInput
    {
        ChainId = sideChainId,
        Amount = 15
    });
    
    // Recharge succeeds due to flawed validation
    rechargeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Status appears Active
    status = await GetSideChainStatusAsync(sideChainId);
    status.ShouldBe(SideChainStatus.Active);
    
    // But balance is insufficient for next indexing
    var balanceAfter = await GetSideChainBalanceAsync(sideChainId);
    balanceAfter.ShouldBe(10); // 15 - 5 (arrears) = 10
    balanceAfter.ShouldBeLessThan(indexingPrice); // 10 < 20 - VULNERABLE!
    
    // Index one more block - chain immediately returns to debt
    var nextBlock = CreateSideChainBlockData(HashHelper.ComputeFrom("block6"), 6, sideChainId, HashHelper.ComputeFrom("tx"));
    await DoIndexAsync(new CrossChainBlockData { SideChainBlockDataList = { nextBlock } }, new[] { sideChainId });
    
    // Chain is back in debt immediately after "successful" recharge
    status = await GetSideChainStatusAsync(sideChainId);
    status.ShouldBe(SideChainStatus.IndexingFeeDebt);
    
    // Vulnerability confirmed: recharge passed validation but left insufficient funds
}
```

**Notes**:
- The vulnerability affects the core cross-chain indexing reliability guarantee
- Both issues (double-counting in debt state + no validation in active state) should be fixed
- The mathematical flaw is objectively verifiable through algebraic substitution
- No special circumstances or edge cases required - this manifests during normal operations

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L174-215)
```csharp
    public override Empty Recharge(RechargeInput input)
    {
        var chainId = input.ChainId;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null && sideChainInfo.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");

        TransferFrom(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = input.Amount,
            Memo = "Indexing fee recharging."
        });

        long arrearsAmount = 0;
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
        }

        sideChainInfo.ArrearsInfo.Clear();
        sideChainInfo.SideChainStatus = SideChainStatus.Active;
        State.SideChainInfo[chainId] = sideChainInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L88-98)
```csharp
    private long GetSideChainIndexingFeeDeposit(int chainId)
    {
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var balanceOutput = State.TokenContract.GetBalance.Call(new GetBalanceInput
        {
            Owner = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol
        });

        return balanceOutput.Balance;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L842-855)
```csharp
                var indexingPrice = sideChainInfo.IndexingPrice;

                lockedToken -= indexingPrice;

                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
                else
                {
                    indexingFeeAmount += indexingPrice;
                }
```
