# Audit Report

## Title
Time Slot Validation Bypass via Cross-Round ActualMiningTimes Injection in Tiny Blocks

## Summary
The AEDPoS consensus validation system fails to verify the freshness and integrity of `ActualMiningTimes` in tiny block headers. A malicious miner can inject stale timestamps from previous rounds into their tiny block's consensus extra data, bypassing time slot validation and producing blocks outside their designated time windows. This vulnerability exploits the fact that `ActualMiningTimes` are excluded from hash-based integrity checks and that the validation logic explicitly allows pre-round timestamps for "previous extra block slot" scenarios without verifying legitimacy.

## Finding Description

The vulnerability exists in the tiny block validation pipeline where three critical flaws combine to enable time slot bypass:

**Flaw 1: ActualMiningTimes Excluded from Hash Validation**

The `GetCheckableRound()` method explicitly clears `ActualMiningTimes` before computing the round hash: [1](#0-0) 

This means `ValidateConsensusAfterExecution` cannot detect modifications to `ActualMiningTimes` through hash comparison: [2](#0-1) 

**Flaw 2: Unconditional Merging of Provided ActualMiningTimes**

During validation, `RecoverFromTinyBlock()` blindly merges all `ActualMiningTimes` from the provided round into the base round without any freshness checks: [3](#0-2) 

This occurs before time slot validation: [4](#0-3) 

**Flaw 3: Permissive Time Slot Validation Logic**

The `CheckMinerTimeSlot()` method allows timestamps before the round start time, intended for legitimate "previous extra block slot" scenarios: [5](#0-4) 

However, it never validates whether the miner is actually the extra block producer or whether the timestamp legitimately belongs to the previous extra block slot.

**Attack Execution Path:**

1. Attacker mines blocks in Round N, accumulating `ActualMiningTimes` entries (e.g., timestamps T₁, T₂, T₃ from Round N)

2. In Round N+1, when the attacker wants to produce a tiny block outside their designated time slot:
   - The attacker calls `GetConsensusExtraDataForTinyBlock()` which normally adds the current timestamp
   - The attacker modifies the returned `Round` object, replacing/adding old `ActualMiningTimes` from Round N
   - The attacker serializes this modified `Round` into the block header's consensus extra data
   - The attacker signs and broadcasts the block

3. During validation on receiving nodes:
   - `ValidateBeforeExecution` calls `RecoverFromTinyBlock()`, which adds the injected old timestamps to `baseRound`
   - `CheckMinerTimeSlot()` retrieves the latest `ActualMiningTime` (now includes the old timestamp)
   - Since old Round N timestamps < Round N+1 expected mining time AND < Round N+1 start time, validation passes at lines 46-48
   - `ValidateConsensusAfterExecution` compares hashes, but since `ActualMiningTimes` are cleared before hashing, the modified data passes validation

4. The block is accepted and `ProcessTinyBlock()` records the attacker's manipulated timestamp: [6](#0-5) 

**Why New Rounds Enable the Attack:**

New rounds are generated with empty `ActualMiningTimes` arrays, which is confirmed in the round generation logic: [7](#0-6) 

This creates a clean slate where injected old timestamps will be the only/earliest entries, ensuring they're selected as `latestActualMiningTime` by the validation logic.

## Impact Explanation

**Severity: HIGH**

This vulnerability directly undermines a fundamental consensus invariant: miners must produce blocks only within their designated time slots. The impact includes:

1. **Consensus Schedule Violation**: Attackers can produce blocks at arbitrary times while validation logic believes they're producing legitimate "previous extra block slot" tiny blocks.

2. **Unfair Block Production Advantage**: Malicious miners can:
   - Produce more blocks than their fair share by extending beyond their time slot
   - Respond to network conditions or transaction pools opportunistically
   - Front-run transactions by mining blocks outside normal scheduling

3. **Network-Wide Trust Degradation**: Since the validation logic explicitly allows pre-round timestamps (line 46-48 in TimeSlotValidationProvider), honest nodes will accept these blocks, degrading the integrity of the consensus schedule across the network.

4. **Exploitability Against Round-Robin Fairness**: The AEDPoS consensus depends on orderly round-robin block production. This bypass allows miners to subvert that fairness by producing blocks when they shouldn't have the right to do so.

While this doesn't directly steal funds or corrupt token balances, it corrupts a critical consensus mechanism that ensures fair block production ordering, which is fundamental to blockchain security.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly feasible due to:

**Low Technical Barriers:**
- Attacker only needs to be a legitimate active miner (no special privileges required)
- Attack requires simple manipulation of consensus extra data before signing (standard miner capability)
- No special network conditions, timing windows, or coordination required

**Simple Execution:**
1. Record own `ActualMiningTimes` from previous rounds (normal mining records)
2. Modify `Round` object when generating tiny blocks (straightforward serialization/deserialization)
3. Sign and broadcast (standard block production)

**High Success Rate:**
- No randomness or race conditions
- Works across any round transition where attacker was active in both rounds
- Can be repeated indefinitely in every round
- Detection is difficult since blocks carry valid signatures and pass all validation checks

**Rational Incentive:**
- Miners seeking to maximize block production (and rewards) have direct incentive
- Risk of detection is low since validation explicitly allows the malicious pattern
- No self-harm or cost beyond running modified mining software

The only prerequisite is that the attacker must be an active miner, but this is precisely the threat model for consensus validation - the system should detect and reject malicious behavior from active miners.

## Recommendation

Implement the following fixes to validate `ActualMiningTimes` integrity:

**1. Add Freshness Validation:**
Modify `CheckMinerTimeSlot()` to validate that timestamps claiming to be from "previous extra block slot" actually occurred within a reasonable window (e.g., within the previous round's timeframe) and verify the miner was actually the extra block producer.

**2. Include ActualMiningTimes in Hash Validation (Partial):**
While `ActualMiningTimes` need to accumulate during a round, consider including a commitment or merkle root of the current `ActualMiningTimes` state in the validation hash, or at minimum validate that provided timestamps are monotonically increasing and within reasonable bounds.

**3. Add Cross-Round Validation:**
In `RecoverFromTinyBlock()`, validate that provided `ActualMiningTimes` are not older than the current round start time, except for the specific case where:
- The miner is the extra block producer of the previous round
- The timestamp is within the previous round's extra block slot window
- The round transition has just occurred

**4. Strengthen Validation Pipeline:**
Add a dedicated `ActualMiningTimesValidationProvider` to the tiny block validation pipeline that explicitly checks timestamp freshness and prevents cross-round timestamp injection.

**Sample Fix (Conceptual):**

```csharp
// In RecoverFromTinyBlock - add validation before merging
public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
{
    if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
        !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
        return this;

    var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
    var roundStartTime = GetRoundStartTime();
    
    // Validate ActualMiningTimes freshness
    foreach (var timestamp in providedInformation.ActualMiningTimes)
    {
        // Only allow pre-round timestamps if this is a legitimate extra block scenario
        if (timestamp < roundStartTime && 
            !IsLegitimateExtraBlockTimestamp(timestamp, pubkey))
        {
            // Reject stale timestamps from previous rounds
            return this;
        }
    }
    
    var minerInRound = RealTimeMinersInformation[pubkey];
    minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
    minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
    
    return this;
}
```

## Proof of Concept

Due to the complexity of the AEDPoS consensus system and the need to set up a complete test environment with multiple miners, rounds, and blockchain state, a full executable test would require significant test infrastructure. However, the vulnerability can be demonstrated through the following logical proof:

**Given State:**
- Miner M was active in Round N and produced blocks with timestamps [T₁=1000, T₂=1010, T₃=1020]
- Round N+1 starts at T_start=2000
- Miner M's expected time slot in Round N+1 is [T_expected=2100, T_end=2200]
- Current time is T_current=2300 (outside M's slot)

**Attack Steps:**
1. M generates legitimate tiny block consensus data via `GetConsensusExtraDataForTinyBlock()` which would normally add T_current=2300
2. M deserializes the `Round` object and replaces `ActualMiningTimes` with [T₁=1000] from Round N  
3. M includes modified `Round` in block header and signs

**Validation Result:**
- `RecoverFromTinyBlock()` merges T₁=1000 into baseRound (line 44 of Round_Recover.cs)
- `CheckMinerTimeSlot()` retrieves latestActualMiningTime = 1000
- Check: 1000 < 2100 (expected time)? YES → execute lines 46-48
- Check: 1000 < 2000 (round start)? YES → return TRUE (pass validation)
- Block is accepted despite being produced at T=2300 (outside time slot)

The key validation logic paths are:
1. Hash validation cannot detect the modification (ActualMiningTimes cleared at line 193 of Round.cs)
2. Time slot validation passes due to old timestamp (lines 46-48 of TimeSlotValidationProvider.cs)
3. No other validator checks ActualMiningTimes freshness (only 3 validators for tiny blocks per lines 65-74 of AEDPoSContract_Validation.cs)

This proves the time slot validation can be bypassed through ActualMiningTimes injection.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-127)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-75)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```
