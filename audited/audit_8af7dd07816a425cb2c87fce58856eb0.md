### Title
Missing Public Key Length Validation in Cross-Chain Miner Information Update Allows Invalid Addresses and Token Loss

### Summary
The `UpdateInformationFromCrossChain()` function accepts miner public keys from parent chain consensus data without validating their length, allowing keys of any size to be stored and later used for token distribution. When invalid-length keys are converted to addresses via `Address.FromPublicKey()`, tokens are sent to addresses that don't correspond to valid keypairs, resulting in permanent fund loss.

### Finding Description

The vulnerability exists in `UpdateInformationFromCrossChain()` where public keys from `RealTimeMinersInformation` are extracted and stored without length validation: [1](#0-0) 

The keys (hex strings) are converted to `ByteString` via `ByteStringHelper.FromHexString()` which accepts any valid hex string regardless of length: [2](#0-1) 

The underlying conversion uses `ByteArrayHelper.HexStringToByteArray()` which simply converts hex pairs to bytes without length checks: [3](#0-2) 

These invalid-length keys are subsequently used in `DistributeResourceTokensToPreviousMiners()` where they're converted to addresses: [4](#0-3) 

`Address.FromPublicKey()` accepts byte arrays of any length and simply hashes them to create an address, without validating that the input is a valid ECDSA public key: [5](#0-4) 

Valid ECDSA public keys should be either 65 bytes (130 hex chars, uncompressed) or 33 bytes (66 hex chars, compressed), but the function accepts keys of any length including invalid sizes like 10 hex chars or 200 hex chars.

### Impact Explanation

**Direct Fund Loss**: Tokens distributed to addresses derived from invalid-length public keys are permanently unrecoverable since these addresses don't correspond to any valid keypair. The amount lost per distribution equals `balance / minerList.Count` for each resource token symbol (transaction fees and rental fees).

**Consensus Data Corruption**: The side chain stores an incorrect view of the parent chain's miner list, with invalid public keys that cannot represent actual miners.

**Cascading Failures**: If these invalid keys are used in other consensus operations that expect valid public key formats, it could cause operational failures in the consensus mechanism.

The severity is Medium because while the immediate exploitability is limited (requires invalid keys to exist in parent chain data first), the lack of defensive validation creates a critical single point of failure. If upstream systems (Election contract, parent chain consensus) fail to validate key lengths, the side chain has no protection against fund loss.

### Likelihood Explanation

**Attack Complexity**: An attacker would need to get invalid-length public keys into the parent chain's consensus data, which requires:
1. Registering a candidate with invalid pubkey via the Election contract's `AnnounceElectionFor` method (which also lacks length validation): [6](#0-5) 

2. Locking 100,000 native tokens as election deposit: [7](#0-6) 

3. Getting the invalid-pubkey candidate elected (requires votes or low competition)

**Preconditions**: The cross-chain validation service validates that proposed data matches cached parent chain data, but this validation is structural - it doesn't check key validity: [8](#0-7) 

**Detection**: Invalid keys would likely be noticed quickly as consensus operations might fail, but tokens would already be lost by that point.

**Economic Rationality**: The attack cost (election lock) versus potential gain (disruption, small token theft from distributions) makes direct exploitation economically questionable, but the vulnerability remains a real risk vector if upstream validation fails.

### Recommendation

**Immediate Fix**: Add public key length validation in `UpdateInformationFromCrossChain()`:

```csharp
var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
foreach (var key in minersKeys)
{
    var keyBytes = ByteArrayHelper.HexStringToByteArray(key);
    Assert(keyBytes.Length == 33 || keyBytes.Length == 65, 
        $"Invalid public key length: {keyBytes.Length}. Expected 33 (compressed) or 65 (uncompressed) bytes.");
}
```

**Defense-in-Depth**: Also add validation in:
1. `AnnounceElectionFor()` in Election contract to reject invalid-length pubkeys
2. `Address.FromPublicKey()` to assert valid ECDSA public key lengths
3. Miner list generation functions to validate all pubkeys before creating rounds

**Test Cases**: Add regression tests for:
- Attempting to update cross-chain information with invalid pubkey lengths (should fail)
- Verifying token distribution only occurs to valid-length public keys
- Election candidate registration rejecting invalid pubkey formats

### Proof of Concept

**Required Initial State**:
- Side chain with parent chain indexing enabled
- Consensus contract with token balance for distribution

**Attack Steps**:
1. On parent chain: Call `AnnounceElectionFor` with `pubkey = "AABBCC"` (6 hex chars = 3 bytes, invalid)
2. Lock required election deposit (100,000 tokens)
3. Manipulate votes or wait for low competition to get elected
4. Parent chain includes this miner in consensus data
5. Side chain receives and indexes parent chain block via cross-chain contract
6. `UpdateInformationFromCrossChain()` accepts the invalid pubkey without validation
7. On next distribution, `DistributeResourceTokensToPreviousMiners()` executes
8. Invalid pubkey converted: `"AABBCC"` → 3 bytes → hashed → address with no corresponding keypair
9. Tokens transferred to this invalid address are permanently lost

**Expected Result**: Invalid pubkey rejected with "Invalid public key length" error

**Actual Result**: Invalid pubkey accepted, stored in miner list, and used for token distribution to unrecoverable address

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L57-61)
```csharp
        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L84-94)
```csharp
            foreach (var pubkey in minerList)
            {
                var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
                Context.LogDebug(() => $"Will send {amount} {symbol}s to {pubkey}");
                State.TokenContract.Transfer.Send(new TransferInput
                {
                    To = address,
                    Amount = amount,
                    Symbol = symbol
                });
            }
```

**File:** src/AElf.Types/Helper/ByteStringHelper.cs (L21-24)
```csharp
        public static ByteString FromHexString(string hexString)
        {
            return ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(hexString));
        }
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-19)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
        }
```

**File:** src/AElf.Types/Types/Address.cs (L37-41)
```csharp
        public static Address FromPublicKey(byte[] bytes)
        {
            var hash = bytes.ComputeHash().ComputeHash();
            return new Address(hash);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataValidationService.cs (L161-166)
```csharp
            if (!parentChainBlockDataList[i].Equals(parentChainBlockData))
            {
                Logger.LogDebug(
                    $"Incorrect parent chain data. Parent chain height: {targetHeight}.");
                return false;
            }
```
