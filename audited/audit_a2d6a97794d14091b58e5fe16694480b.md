### Title
NFT Collection Symbol Collision Enables Namespace Hijacking via SEED NFT Manipulation

### Summary
The MultiToken contract enforces mutual exclusion between base token symbols (e.g., "TARGET") and their corresponding NFT collection symbols (e.g., "TARGET-0") through `CheckTokenAndCollectionExists`, but allows SEED NFTs to be created for collection symbols. An attacker who obtains a SEED NFT for "TARGET-0" can register the collection symbol first, permanently blocking the legitimate owner with a SEED NFT for "TARGET" from creating their token, resulting in irreversible namespace hijacking.

### Finding Description

The root cause lies in the interaction between three code components:

1. **Hardcoded Collection Symbol Construction**: [1](#0-0) 
   The collection suffix is hardcoded as "0", and [2](#0-1)  constructs collection symbols as `{prefix}-0`.

2. **Mutual Exclusion Enforcement**: [3](#0-2) 
   When creating any token or NFT collection, this function checks that BOTH the base symbol AND its collection symbol (prefix + "-0") do not exist. This applies to both regular token creation and NFT collection creation per [4](#0-3) 

3. **Symbol Type Classification**: [5](#0-4) 
   Symbols ending in "-0" are classified as `NftCollection`, enabling them to be created as standalone tokens.

4. **Insufficient SEED NFT Validation**: [6](#0-5) 
   When creating SEED NFTs, the code explicitly allows `ownedSymbol` to be of type `NftCollection` (only rejecting type `Nft`), and calls `CheckTokenAndCollectionExists(ownedSymbol)` to verify the namespace is available.

The vulnerability execution path:
1. SEED issuer creates SEED NFT with `ownedSymbol="TARGET-0"` (passes validation at line 47)
2. Attacker obtains this SEED NFT
3. Attacker calls `Create()` with symbol "TARGET-0" [7](#0-6) 
4. Symbol classified as `NftCollection`, routed to `CreateNFTCollection()` [8](#0-7) 
5. SEED NFT validation passes [9](#0-8) 
6. Token "TARGET-0" is registered
7. Legitimate owner with SEED NFT for "TARGET" attempts creation but fails because `CheckTokenAndCollectionExists("TARGET")` checks that "TARGET-0" doesn't exist (line 290-292), which now fails

### Impact Explanation

**Critical Severity - Permanent Namespace Hijacking:**

- **Token Creation DoS**: Legitimate token creators are permanently blocked from using their SEED NFTs, as the mutual exclusion check at [10](#0-9)  ensures "TARGET" cannot be created if "TARGET-0" exists.

- **Economic Loss**: SEED NFTs are consumed on use (burned at [11](#0-10) ). Victims lose valuable SEED NFTs without being able to create their intended tokens.

- **Brand Squatting**: Attackers can preemptively register collection symbols for high-value brand names, permanently denying legitimate trademark holders their namespace.

- **Irreversibility**: No recovery mechanism exists; once "TARGET-0" is registered, "TARGET" can never be created, and vice versa.

### Likelihood Explanation

**Medium-to-High Likelihood:**

**Attacker Capabilities Required:**
- Obtain SEED NFT with `ownedSymbol` set to a collection symbol ending in "-0"
- This requires either SEED issuer cooperation (social engineering, insider threat) or exploiting permissive SEED issuance policies

**Feasibility Factors:**
- Code explicitly permits SEED NFTs for collection symbols [12](#0-11) 
- No ownership relationship enforcement between "PREFIX" and "PREFIX-0" symbols
- SEED issuance depends on governance/administrative processes which may not distinguish between base and collection symbols

**Attack Complexity:** Low once SEED NFT is obtained
- Single `Create()` transaction with valid SEED NFT
- No sophisticated contract interactions required
- Front-running opportunity if legitimate and malicious SEED NFTs exist simultaneously

**Detection Constraints:** Difficult to prevent
- Distinguishing legitimate collection creation from malicious squatting is challenging at protocol level
- No on-chain indicators of intended symbol ownership

### Recommendation

**Immediate Mitigation - Restrict SEED NFT Owned Symbols:**

Modify SEED NFT creation validation to explicitly forbid collection symbols:

```csharp
// In TokenContract_NFT_Actions.cs, CreateNFTInfo function around line 46-47
var ownedSymbolType = GetSymbolType(ownedSymbol);
Assert(ownedSymbolType == SymbolType.Token, "OwnedSymbol must be base token type only, not collection.");
``` [13](#0-12) 

**Long-term Solution - Enforce Ownership Relationship:**

Option 1: Remove mutual exclusion check, allow both "PREFIX" and "PREFIX-0" to coexist independently.

Option 2: Implement hierarchical ownership where only the owner of "PREFIX" SEED NFT can create "PREFIX-0" collection:
- Store base symbol ownership in `SymbolSeedMap`
- Validate that collection creation requester owns corresponding base symbol SEED
- Automatically grant collection creation rights to base symbol owners

**Test Cases:**
1. Attempt to create SEED NFT with `ownedSymbol="TEST-0"` - should fail
2. Verify SEED NFT with `ownedSymbol="TEST"` can create both "TEST" token and have rights to "TEST-0" collection
3. Ensure no race condition between "PREFIX" and "PREFIX-0" creation

### Proof of Concept

**Initial State:**
- "SEED-0" collection exists [14](#0-13) 
- Parliament controller has authority to create SEED NFTs

**Exploitation Steps:**

1. **Malicious SEED NFT Creation:**
   - Parliament/SEED issuer creates SEED NFT "SEED-1" with:
     - `ExternalInfo[__seed_owned_symbol] = "BRAND-0"`
     - `ExternalInfo[__seed_exp_time] = {future_timestamp}`
   - Issue to Attacker address

2. **Attacker Creates Collection:**
   ```
   Attacker.Call(TokenContract.Create, {
     Symbol: "BRAND-0",
     TokenName: "Brand Collection",
     TotalSupply: 1,
     // ... other params
   })
   ```
   - GetSymbolType("BRAND-0") returns `NftCollection`
   - CheckSeedNFT validates ownership of "SEED-1"
   - Token "BRAND-0" registered successfully
   - SEED NFT "SEED-1" burned

3. **Victim Blocked from Creation:**
   - Legitimate owner receives SEED NFT "SEED-2" with `ownedSymbol="BRAND"`
   - Victim.Call(TokenContract.Create, {Symbol: "BRAND", ...})
   - CheckTokenAndCollectionExists("BRAND") executes
   - Line 290-291: constructs `collectionSymbol = "BRAND-0"`
   - Line 292: CheckTokenExists("BRAND-0") fails (already exists)
   - **Transaction reverts with "Token already exists"**

**Expected vs Actual Result:**
- **Expected**: Legitimate owner with "BRAND" SEED NFT can create token
- **Actual**: Creation permanently fails due to pre-existing "BRAND-0"

**Success Condition:** Attacker successfully blocks namespace while consuming victim's SEED NFT value

### Notes

This vulnerability stems from a design flaw in namespace management rather than a coding error. The hardcoded "-0" suffix for collections combined with mutual exclusion checking creates an exploitable race condition. While the intended design likely assumes SEED NFTs are only issued for base symbols, the code does not enforce this assumption, leaving the protocol vulnerable to namespace squatting attacks if SEED issuance policies are not strictly controlled off-chain.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L22-22)
```csharp
    public const string CollectionSymbolSuffix = "0";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L23-23)
```csharp
    public const string SeedCollectionSymbol = "SEED-0";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L76-79)
```csharp
    private string GetCollectionSymbol(string symbolPrefix)
    {
        return $"{symbolPrefix}-{TokenContractConstants.CollectionSymbolSuffix}";
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L280-281)
```csharp
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L285-293)
```csharp
    private void CheckTokenAndCollectionExists(string symbol)
    {
        var symbols = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        var tokenSymbol = symbols.First();
        CheckTokenExists(tokenSymbol);
        var collectionSymbol = symbols.First() + TokenContractConstants.NFTSymbolSeparator +
                               TokenContractConstants.CollectionSymbolSuffix;
        CheckTokenExists(collectionSymbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L10-13)
```csharp
    private Empty CreateNFTCollection(CreateInput input)
    {
        return CreateToken(input, SymbolType.NftCollection);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L46-49)
```csharp
            var ownedSymbolType = GetSymbolType(ownedSymbol);
            Assert(ownedSymbolType != SymbolType.Nft, "Invalid OwnedSymbol.");
            CheckSymbolLength(ownedSymbol, ownedSymbolType);
            CheckTokenAndCollectionExists(ownedSymbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```
