### Title
Missing ContractAddress Validation in ChangeConnectorController Allows Governance Bypass Through Malicious Controller

### Summary
The `ChangeConnectorController` method lacks validation that the new controller's `ContractAddress` must be one of the legitimate governance contracts (Parliament, Association, or Referendum). An attacker can deploy a malicious contract that implements `ValidateOrganizationExist` to always return true, then convince the Parliament to approve setting this malicious contract as the controller, granting the attacker unauthorized direct control over critical connector management functions.

### Finding Description
The vulnerability exists in the `ChangeConnectorController` method which only performs two checks: [1](#0-0) 

The authorization check at line 305 ensures the caller is the current controller, and line 306 validates organization existence through `CheckOrganizationExist`. However, `CheckOrganizationExist` implementation does not validate that `input.ContractAddress` is a legitimate governance contract: [2](#0-1) 

This method accepts ANY contract address and calls its `ValidateOrganizationExist` method. An attacker can deploy a malicious contract with this method returning true for any address.

The `ConnectorController` is used to authorize critical operations: [3](#0-2) [4](#0-3) [5](#0-4) 

The authorization check only verifies that `Context.Sender` equals the controller's `OwnerAddress`: [6](#0-5) 

Once the malicious controller is set, the attacker can directly invoke these methods without governance approval.

In contrast, the CrossChain contract properly validates the `ContractAddress`: [7](#0-6) 

### Impact Explanation
**Critical Authorization Bypass**: An attacker gains unauthorized control over connector management and fee configuration, bypassing the intended governance model.

**Specific Harms**:
1. **Price Manipulation**: Through `UpdateConnector`, the attacker can modify connector weights, directly affecting Bancor pricing formulas and potentially draining reserves or manipulating token prices
2. **Fee Extraction**: Through `SetFeeRate`, the attacker can set arbitrary fees (up to 100%) to extract value from all buy/sell transactions
3. **Market Disruption**: Through `AddPairConnector` and `EnableConnector`, the attacker can add malicious connectors or disable legitimate ones, disrupting the token conversion market
4. **Governance Circumvention**: Once set, the attacker maintains permanent direct control without requiring any governance approval for subsequent actions

The impact is quantifiable: all users performing token conversions through the TokenConverter contract are affected, and the attacker can manipulate an unlimited amount of value passing through the converter.

### Likelihood Explanation
**Attack Complexity**: Medium

**Required Capabilities**:
1. **Contract Deployment**: Attacker must deploy a malicious contract implementing `ValidateOrganizationExist`. On mainnet, this requires either:
   - Governance approval for contract deployment (if `ContractDeploymentAuthorityRequired` is true)
   - Direct deployment ability (if false, common in testnets) [8](#0-7) 

2. **Governance Proposal Approval**: Attacker must convince Parliament to approve a proposal calling `ChangeConnectorController` with the malicious `AuthorityInfo`. This is feasible because:
   - Parliament members may not scrutinize the `ContractAddress` field, assuming the validation is sufficient
   - The proposal appears legitimate if the malicious contract address resembles a governance contract
   - Social engineering or insider attacks can facilitate approval

**Execution Path**:
1. Deploy malicious contract with `ValidateOrganizationExist` always returning true
2. Create Parliament proposal to change controller with `AuthorityInfo{ContractAddress: maliciousContract, OwnerAddress: attackerAddress}`
3. Parliament approves and executes the proposal
4. `CheckOrganizationExist` calls malicious contract, returns true
5. Controller is updated to attacker's address
6. Attacker directly calls `UpdateConnector`, `SetFeeRate`, etc.

**Detection Difficulty**: The malicious `ContractAddress` may not be detected during normal proposal review processes if members only verify the `OwnerAddress` or assume existing validations are comprehensive.

### Recommendation
**Immediate Fix**: Add explicit validation that `ContractAddress` must be one of the three legitimate governance contracts:

```csharp
public override Empty ChangeConnectorController(AuthorityInfo input)
{
    AssertPerformedByConnectorController();
    
    // Initialize contract references if needed
    if (State.ParliamentContract.Value == null)
        State.ParliamentContract.Value = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    if (State.AssociationContract.Value == null)
        State.AssociationContract.Value = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    if (State.ReferendumContract.Value == null)
        State.ReferendumContract.Value = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    // Validate ContractAddress is a legitimate governance contract
    Assert(
        input.ContractAddress == State.ParliamentContract.Value ||
        input.ContractAddress == State.AssociationContract.Value ||
        input.ContractAddress == State.ReferendumContract.Value,
        "ContractAddress must be Parliament, Association, or Referendum contract");
    
    Assert(CheckOrganizationExist(input), "new controller does not exist");
    State.ConnectorController.Value = input;
    return new Empty();
}
```

**Additional State Variables**: Add contract reference states to `TokenConverterContractState.cs`: [9](#0-8) 

**Test Cases**: Add tests verifying:
1. Rejection when `ContractAddress` is not a governance contract
2. Rejection when `ContractAddress` is a malicious contract
3. Success when using legitimate Parliament/Association/Referendum addresses

### Proof of Concept
**Initial State**:
- ConnectorController: `{ContractAddress: ParliamentContract, OwnerAddress: DefaultParliamentOrg}`

**Attack Steps**:
1. **Deploy Malicious Contract** (MaliciousAuth.cs):
```csharp
public override BoolValue ValidateOrganizationExist(Address input)
{
    return new BoolValue { Value = true }; // Always returns true
}
```

2. **Create Parliament Proposal**:
   - Target: TokenConverterContract.ChangeConnectorController
   - Input: `AuthorityInfo{ContractAddress: MaliciousAuthContract, OwnerAddress: AttackerAddress}`

3. **Parliament Approves Proposal** (assuming members don't detect malicious ContractAddress)

4. **Proposal Executed**:
   - `Context.Sender` = DefaultParliamentOrg (passes authorization check)
   - `CheckOrganizationExist` calls MaliciousAuthContract.ValidateOrganizationExist(AttackerAddress) → returns true
   - `State.ConnectorController.Value` = `{ContractAddress: MaliciousAuthContract, OwnerAddress: AttackerAddress}`

5. **Attacker Gains Control**:
   - Attacker calls `UpdateConnector` directly
   - `AssertPerformedByConnectorController` checks `Context.Sender == AttackerAddress` → passes
   - Attacker modifies connector weights, manipulating prices

**Expected Result**: Transaction should fail with "ContractAddress must be a legitimate governance contract"

**Actual Result**: Attacker successfully becomes controller and gains unauthorized control over connector management and fee settings

**Success Condition**: After step 4, `GetControllerForManageConnector().OwnerAddress == AttackerAddress` and attacker can directly modify connectors without governance approval.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-110)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L260-267)
```csharp
    public override Empty SetFeeRate(StringValue input)
    {
        AssertPerformedByConnectorController();
        var feeRate = AssertedDecimal(input.Value);
        Assert(IsBetweenZeroAndOne(feeRate), "Fee rate has to be a decimal between 0 and 1.");
        State.FeeRate.Value = feeRate.ToString(CultureInfo.InvariantCulture);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L303-309)
```csharp
    public override Empty ChangeConnectorController(AuthorityInfo input)
    {
        AssertPerformedByConnectorController();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.ConnectorController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L397-403)
```csharp
    private void AssertPerformedByConnectorController()
    {
        if (State.ConnectorController.Value == null) State.ConnectorController.Value = GetDefaultConnectorController();

        Assert(Context.Sender == State.ConnectorController.Value.OwnerAddress,
            "Only manager can perform this action.");
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L61-74)
```csharp
    public override Empty ChangeCrossChainIndexingController(AuthorityInfo input)
    {
        AssertCrossChainIndexingControllerAuthority(Context.Sender);
        SetContractStateRequired(State.ParliamentContract, SmartContractConstants.ParliamentContractSystemName);
        Assert(
            input.ContractAddress == State.ParliamentContract.Value &&
            ValidateParliamentOrganization(input.OwnerAddress), "Invalid authority input.");
        State.CrossChainIndexingController.Value = input;
        Context.Fire(new CrossChainIndexingControllerChanged
        {
            AuthorityInfo = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L309-322)
```csharp
    public override Address DeploySmartContract(ContractDeploymentInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        // AssertDeploymentProposerAuthority(Context.Origin);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address =
            DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
                DecideNonSystemContractAuthor(contractProposingInput?.Proposer, Context.Sender), false,
                input.ContractOperation?.Deployer, input.ContractOperation?.Salt);
        return address;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs (L9-22)
```csharp
public class TokenConverterContractState : ContractState
{
    internal TokenContractContainer.TokenContractReferenceState TokenContract { get; set; }
    internal ParliamentContractContainer.ParliamentContractReferenceState ParliamentContract { get; set; }
    internal DividendPoolContractContainer.DividendPoolContractReferenceState DividendPoolContract { get; set; }

    public StringState BaseTokenSymbol { get; set; }
    public StringState FeeRate { get; set; }
    public MappedState<string, Connector> Connectors { get; set; }
    public MappedState<string, MethodFees> TransactionFees { get; set; }
    public MappedState<string, long> DepositBalance { get; set; }
    public SingletonState<AuthorityInfo> ConnectorController { get; set; }
    public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
}
```
