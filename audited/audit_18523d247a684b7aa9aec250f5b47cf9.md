### Title
Authorization Contract Address Validation Bypass in ChangeMethodFeeController Allows Controller Hijacking

### Summary
The `ChangeMethodFeeController` function lacks validation that the `input.ContractAddress` is a legitimate authorization contract (Parliament, Association, or Referendum). An attacker can deploy a malicious contract that always returns `true` for `ValidateOrganizationExist`, then through a governance proposal, change the method fee controller to an arbitrary address or `address(0)`, resulting in complete control over method fees or permanent controller lockout.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController` function where the organization existence check can be bypassed: [1](#0-0) 

The validation relies on `CheckOrganizationExist` which performs an inter-contract call to the provided contract address: [2](#0-1) 

**Root Cause**: The function calls `Context.Call` on the attacker-controlled `authorityInfo.ContractAddress` without verifying it's a legitimate system authorization contract. The function assumes any contract address provided is trustworthy and will correctly implement `ValidateOrganizationExist`.

**Why Protections Fail**: 
- Line 27 only checks that the current controller is the caller, not that the new controller is valid
- Line 28-29 check if the organization "exists" by calling the provided contract, but this contract can be malicious
- No whitelist or validation that `input.ContractAddress` is Parliament, Association, or Referendum

**Execution Path**:
1. Attacker deploys a malicious contract implementing:
   ```csharp
   public BoolValue ValidateOrganizationExist(Address input) {
       return new BoolValue { Value = true };
   }
   ```
2. Current controller (e.g., Parliament default organization) receives a governance proposal to call `ChangeMethodFeeController`
3. Proposal appears legitimate (e.g., "Migrate to Association governance")
4. Governance members approve without verifying the contract address
5. Proposal executes with `input.ContractAddress` = malicious contract, `input.OwnerAddress` = attacker or `address(0)`
6. Validation passes because malicious contract returns `true`
7. Controller is hijacked

### Impact Explanation

**Critical Impact - Complete Method Fee Control or Permanent DoS**:

1. **Controller Hijacking (OwnerAddress = attacker)**:
   - Attacker gains exclusive control via `SetMethodFee` function: [3](#0-2) 
   - Can set method fees to 0 (eliminating transaction costs, breaking tokenomics)
   - Can set fees to `MAX_VALUE` (DoS all token operations)
   - Affects every user and operation on the Token contract

2. **Permanent Controller Lockout (OwnerAddress = address(0)**:
   - Controller set to `address(0)`, making line 27 check impossible: `Context.Sender == address(0)` never true
   - Method fee controller becomes permanently immutable
   - No recovery mechanism exists
   - System stuck with current fee configuration forever

**Affected Parties**: All token users, protocol governance, system integrity.

**Severity Justification**: 
- Breaks critical authorization invariant for method fee management
- Enables complete bypass of governance controls
- Can render the system permanently misconfigured

### Likelihood Explanation

**Medium Likelihood - Realistic Through Governance Social Engineering**:

**Attacker Capabilities Required**:
- Ability to deploy contracts on AElf (publicly available)
- Ability to create governance proposals (available to whitelisted proposers or organization members)
- Social engineering skills to craft convincing proposal descriptions

**Attack Complexity**: Moderate
1. Deploy malicious contract (straightforward, contracts pass code validation if using allowed APIs: [4](#0-3) )
2. Create governance proposal with plausible description
3. Wait for approval (requires majority vote)
4. Execute proposal

**Feasibility Conditions**:
- Governance members may not manually verify contract addresses against system contract registry
- Proposals with titles like "Upgrade to Association Governance" appear routine
- No on-chain validation distinguishes legitimate from malicious contract addresses
- Contract address validation is NOT part of standard governance review process

**Detection Constraints**: 
- No automatic validation occurs during proposal creation
- Manual review required to detect malicious contract address
- Once executed, damage is immediate and irreversible

**Economic Rationality**: Attack cost is minimal (gas for deployment + proposal), potential gain is complete protocol control or DoS.

### Recommendation

**Primary Fix - Validate Contract Address Against System Contracts**:

Add validation that `input.ContractAddress` is one of the legitimate authorization contracts before line 28:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    
    // Add validation: contract address must be a known authorization contract
    var parliamentAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    var associationAddress = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    var referendumAddress = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    Assert(
        input.ContractAddress == parliamentAddress || 
        input.ContractAddress == associationAddress || 
        input.ContractAddress == referendumAddress,
        "Invalid authorization contract address."
    );
    
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    State.MethodFeeController.Value = input;
    return new Empty();
}
```

**Additional Protection - Validate OwnerAddress Non-Zero**:

```csharp
Assert(input.OwnerAddress != null && input.OwnerAddress.Value.Length > 0, 
       "Owner address cannot be empty.");
```

**Test Cases**:
1. Test `ChangeMethodFeeController` with non-system contract address → should fail
2. Test with `address(0)` as OwnerAddress → should fail  
3. Test with arbitrary deployed contract implementing `ValidateOrganizationExist` → should fail
4. Test with valid Parliament/Association/Referendum addresses → should succeed

**Apply Same Fix to All Affected Contracts**:
- Genesis contract: [5](#0-4) 
- All other ACS1 implementations showing same pattern in grep results

### Proof of Concept

**Initial State**:
- Token contract deployed with default Parliament controller
- Parliament default organization controls method fees

**Attack Steps**:

1. **Deploy Malicious Contract**:
   ```csharp
   public class MaliciousAuthContract : ContractBase {
       public override BoolValue ValidateOrganizationExist(Address input) {
           return new BoolValue { Value = true }; // Always returns true
       }
   }
   ```
   Deploy to address: `MALICIOUS_CONTRACT_ADDRESS`

2. **Create Governance Proposal**:
   - Target: Token Contract
   - Method: `ChangeMethodFeeController`
   - Parameters: 
     - `ContractAddress`: `MALICIOUS_CONTRACT_ADDRESS`
     - `OwnerAddress`: `ATTACKER_ADDRESS`
   - Description: "Migrate method fee governance to Association contract for improved flexibility"

3. **Social Engineering**:
   - Proposal appears legitimate to governance members
   - Members approve without validating contract address against system contracts

4. **Proposal Execution**:
   - Line 27: Check passes (caller is Parliament organization)
   - Line 28: Calls `MALICIOUS_CONTRACT_ADDRESS.ValidateOrganizationExist(ATTACKER_ADDRESS)`
   - Malicious contract returns `true`
   - Line 29: Assertion passes
   - Line 31: Controller changed to `(MALICIOUS_CONTRACT_ADDRESS, ATTACKER_ADDRESS)`

5. **Post-Exploitation**:
   - Attacker now controls method fees via `SetMethodFee`
   - Can set arbitrary fees or disable fee collection
   - Original governance cannot revert (line 27 check now requires attacker as sender)

**Expected Result**: Transaction should fail with "Invalid authorization contract address"

**Actual Result**: Transaction succeeds, controller hijacked to attacker address

**Success Condition**: `GetMethodFeeController()` returns `OwnerAddress = ATTACKER_ADDRESS` with `ContractAddress = MALICIOUS_CONTRACT_ADDRESS`

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** src/AElf.CSharp.CodeOps/Validators/Whitelist/IWhitelistValidator.cs (L1-10)
```csharp
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Volo.Abp.DependencyInjection;

namespace AElf.CSharp.CodeOps.Validators.Whitelist;

public class WhitelistValidator : WhitelistValidatorBase, ITransientDependency
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```
