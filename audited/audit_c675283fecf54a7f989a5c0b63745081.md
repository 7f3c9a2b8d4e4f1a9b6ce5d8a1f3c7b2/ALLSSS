### Title
Unvalidated Consensus Data in Side Chain Genesis Allows Unapproved Miner Set

### Summary
The `GetInitialConsensusInformation()` method captures the parent chain's current miner list at the exact moment `CreateSideChain` executes, without any explicit validation or governance approval of which specific miners will control the new side chain. This creates a temporal disconnect between when side chain creation is approved and when the miner list is captured, potentially allowing a compromised or colluding subset of parent chain miners to become genesis validators on the side chain without explicit authorization.

### Finding Description

The vulnerability exists in the side chain creation flow spanning multiple components: [1](#0-0) 

When `CreateSideChain` executes (callable only by the governance controller), it calls `GetChainInitializationData()` at line 157-158: [2](#0-1) 

This helper method calls `GetInitialConsensusInformation()` at line 530, which queries the consensus contract: [3](#0-2) 

The consensus contract returns the **current** active miner list at that exact moment: [4](#0-3) 

This miner list comes directly from the current round's active miners: [5](#0-4) 

The side chain then uses this data without validation during initialization: [6](#0-5) 

**Root Cause:** There is no mechanism to:
1. Specify or approve which miners should be in the side chain genesis
2. Validate that the miner list matches any expected or approved set
3. Ensure temporal consistency between proposal approval and execution
4. Allow side chain creators to review the actual miner list before finalization

### Impact Explanation

**Consensus Integrity Compromise:**
- Side chain initializes with an unapproved miner set from genesis block
- If malicious miners control the parent chain consensus at execution time, they become genesis validators
- These miners have complete control over the side chain from inception, including block production, transaction validation, and consensus decisions

**Governance Bypass:**
- The governance process approves "create a side chain" but never explicitly approves "create a side chain with miners X, Y, Z"
- There's no audit trail of which specific miners were intended vs. actually deployed
- Side chain users have no visibility into validator selection process

**Temporal Attack Surface:**
- Time gap between proposal approval (could be hours/days) and execution creates uncertainty
- Different miners may be active at proposal time vs. execution time
- Malicious miners can time their active slots to coincide with side chain creation execution

**Affected Parties:**
- All users and contracts on the newly created side chain
- Side chain token holders and asset owners
- Applications building on the compromised side chain

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an elected miner on the parent chain (requires staking and election process)
- Or coordinate with current miners to time execution during their slots
- Ability to monitor pending governance proposals to identify side chain creation timing

**Attack Complexity:**
- **Medium**: Requires miner status but exploitation is straightforward once achieved
- Governance proposal timing is somewhat predictable after approval
- No technical sophistication needed beyond being a miner

**Feasibility Conditions:**
- Side chain creation proposals go through standard governance (observable)
- Execution timing is deterministic after approval
- Miner rotation follows predictable patterns based on consensus rounds

**Scenarios:**
1. **Compromised Miner**: Single compromised parent chain miner is in active set during execution
2. **Miner Collusion**: Subset of miners coordinate to time their slots with side chain creation
3. **Unintended Selection**: Even without malice, wrong/inappropriate miners become genesis validators without review

**Detection Constraints:**
- No on-chain validation to detect inappropriate miner selection
- No alerting mechanism for miner list changes between proposal and execution
- Side chain creators only discover actual miner list after deployment

### Recommendation

**Immediate Fix:**

1. **Capture Miner List at Proposal Time:**
   Modify `RequestSideChainCreation` and `ProposeNewSideChain` to snapshot and include the intended miner list in the proposal: [7](#0-6) 

   Store the miner list as part of `SideChainCreationRequestState` for validation during execution.

2. **Add Validation in CreateSideChain:**
   Verify that the current miner list matches or is approved as part of the creation request: [8](#0-7) 

   Add assertion: `Assert(ApprovedMinerList.Equals(CurrentMinerList) || ExplicitOverrideApproved, "Miner list mismatch")`

3. **Add Explicit Miner List Parameter:**
   Allow `SideChainCreationRequest` to specify expected miners and fail creation if they don't match current state.

**Invariant to Enforce:**
- The miner list used in `ChainInitializationData.ChainInitializationConsensusInfo.InitialConsensusData` MUST be explicitly approved or verified against the proposal

**Test Cases:**
1. Test that side chain creation fails if miner list changed between proposal and execution
2. Test that governance explicitly approves specific miner list
3. Test that side chain initialization rejects mismatched miner data

### Proof of Concept

**Initial State:**
- Parent chain has active miners: [Alice, Bob, Carol, Dave, Eve]
- Governance organization configured and functional

**Attack Steps:**

1. **Proposal Phase (T=0):**
   - Honest actor proposes side chain creation
   - Active miners at proposal time: [Alice, Bob, Carol]
   - Governance reviews and approves proposal
   - Expected: Side chain should use miners [Alice, Bob, Carol]

2. **Waiting Period (T=0 to T=N):**
   - Consensus rounds progress normally
   - Miner set rotates based on DPoS consensus
   - Malicious miners [Dave, Eve] enter active set through normal rotation

3. **Execution Phase (T=N):**
   - `ReleaseSideChainCreation` called after approval
   - `CreateSideChain` executes at line 121-167
   - `GetInitialConsensusInformation()` captures **current** miners: [Dave, Eve, Alice]
   - Side chain initializes with [Dave, Eve, Alice] - NOT the reviewed set

4. **Result:**
   - Side chain deployed with unapproved miner composition
   - [Dave, Eve] have 2/3 control from genesis (can manipulate consensus)
   - No validation caught the mismatch
   - No audit trail shows discrepancy

**Success Condition:**
- Side chain genesis block contains miners that were NOT explicitly approved in the governance proposal
- Demonstrates temporal disconnect and lack of validation

**Expected vs Actual:**
- **Expected:** Side chain uses miners reviewed during governance approval
- **Actual:** Side chain uses whoever happens to be mining at execution time

---

**Notes:**

The vulnerability stems from a fundamental design flaw where consensus initialization data is captured at execution time rather than being explicitly specified and validated as part of the governance approval process. Even if all parent chain miners are considered "trusted" through the election mechanism, the lack of explicit approval for side chain genesis miners represents a governance gap and temporal consistency violation. The side chain's security is bootstrapped from parent chain consensus without proper validation of which specific validators will have genesis control.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L121-167)
```csharp
    public override Int32Value CreateSideChain(CreateSideChainInput input)
    {
        // side chain creation should be triggered by organization address.
        AssertSideChainLifetimeControllerAuthority(Context.Sender);

        var proposedSideChainCreationRequestState = State.ProposedSideChainCreationRequestState[input.Proposer];
        State.ProposedSideChainCreationRequestState.Remove(input.Proposer);
        var sideChainCreationRequest = input.SideChainCreationRequest;
        Assert(
            proposedSideChainCreationRequestState != null &&
            proposedSideChainCreationRequestState.SideChainCreationRequest.Equals(sideChainCreationRequest),
            "Side chain creation failed without proposed data.");
        AssertValidSideChainCreationRequest(sideChainCreationRequest, input.Proposer);

        State.SideChainSerialNumber.Value = State.SideChainSerialNumber.Value.Add(1);
        var serialNumber = State.SideChainSerialNumber.Value;
        var chainId = GetChainId(serialNumber);
        State.AcceptedSideChainCreationRequest[chainId] = sideChainCreationRequest;

        // lock token
        ChargeSideChainIndexingFee(input.Proposer, sideChainCreationRequest.LockedTokenAmount, chainId);

        var sideChainInfo = new SideChainInfo
        {
            Proposer = input.Proposer,
            SideChainId = chainId,
            SideChainStatus = SideChainStatus.Active,
            IndexingPrice = sideChainCreationRequest.IndexingPrice,
            IsPrivilegePreserved = sideChainCreationRequest.IsPrivilegePreserved,
            CreationTimestamp = Context.CurrentBlockTime,
            CreationHeightOnParentChain = Context.CurrentHeight,
            IndexingFeeController = CreateDefaultOrganizationForIndexingFeePriceManagement(input.Proposer)
        };
        State.SideChainInfo[chainId] = sideChainInfo;
        State.CurrentSideChainHeight[chainId] = 0;

        var chainInitializationData =
            GetChainInitializationData(sideChainInfo, sideChainCreationRequest);
        State.SideChainInitializationData[sideChainInfo.SideChainId] = chainInitializationData;

        Context.Fire(new SideChainCreatedEvent
        {
            ChainId = chainId,
            Creator = input.Proposer
        });
        return new Int32Value { Value = chainId };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L218-224)
```csharp
    private ByteString GetInitialConsensusInformation()
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var miners = State.CrossChainInteractionContract.GetChainInitializationInformation.Call(new BytesValue());
        return miners.Value;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L360-388)
```csharp
    private SideChainCreationRequestState ProposeNewSideChain(SideChainCreationRequest request, Address proposer)
    {
        var sideChainLifeTimeController = GetSideChainLifetimeController();
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput =
                new CreateProposalInput
                {
                    ContractMethodName = nameof(CreateSideChain),
                    ToAddress = Context.Self,
                    ExpiredTime =
                        Context.CurrentBlockTime.AddSeconds(SideChainCreationProposalExpirationTimePeriod),
                    Params = new CreateSideChainInput { SideChainCreationRequest = request, Proposer = proposer }
                        .ToByteString(),
                    OrganizationAddress = sideChainLifeTimeController.OwnerAddress
                },
            OriginProposer = Context.Sender
        };
        Context.SendInline(sideChainLifeTimeController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput);
        var sideChainCreationRequest = new SideChainCreationRequestState
        {
            SideChainCreationRequest = request,
            ExpiredTime = proposalCreationInput.ProposalInput.ExpiredTime,
            Proposer = proposer
        };
        return sideChainCreationRequest;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L516-557)
```csharp
    private ChainInitializationData GetChainInitializationData(SideChainInfo sideChainInfo,
        SideChainCreationRequest sideChainCreationRequest)
    {
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var res = new ChainInitializationData
        {
            CreationHeightOnParentChain = sideChainInfo.CreationHeightOnParentChain,
            ChainId = sideChainInfo.SideChainId,
            Creator = sideChainInfo.Proposer,
            CreationTimestamp = sideChainInfo.CreationTimestamp,
            ChainCreatorPrivilegePreserved = sideChainInfo.IsPrivilegePreserved,
            ParentChainTokenContractAddress = State.TokenContract.Value
        };

        var initialConsensusInfo = GetInitialConsensusInformation();
        res.ChainInitializationConsensusInfo = new ChainInitializationConsensusInfo
            { InitialConsensusData = initialConsensusInfo };

        var nativeTokenInformation = GetNativeTokenInfo().ToByteString();
        res.NativeTokenInfoData = nativeTokenInformation;

        var resourceTokenInformation = GetResourceTokenInfo().ToByteString();
        res.ResourceTokenInfo = new ResourceTokenInfo
        {
            ResourceTokenListData = resourceTokenInformation,
            InitialResourceAmount = { sideChainCreationRequest.InitialResourceAmount }
        };

        if (IsPrimaryTokenNeeded(sideChainCreationRequest))
        {
            var sideChainTokenInformation =
                GetTokenInfo(sideChainCreationRequest.SideChainTokenCreationRequest.SideChainTokenSymbol)
                    .ToByteString();
            res.ChainPrimaryTokenInfo = new ChainPrimaryTokenInfo
            {
                ChainPrimaryTokenData = sideChainTokenInformation,
                SideChainTokenInitialIssueList = { sideChainCreationRequest.SideChainTokenInitialIssueList }
            };
        }

        return res;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L13-23)
```csharp
    public override BytesValue GetChainInitializationInformation(BytesValue input)
    {
        return new BytesValue
        {
            Value = new MinerListWithRoundNumber
            {
                MinerList = GetCurrentMinerList(new Empty()),
                RoundNumber = State.CurrentRoundNumber.Value
            }.ToByteString()
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L31-42)
```csharp
    public override MinerList GetCurrentMinerList(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var round)
            ? new MinerList
            {
                Pubkeys =
                {
                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))
                }
            }
            : new MinerList();
    }
```

**File:** src/AElf.Blockchains.SideChain/AEDPoSContractInitializationDataProvider.cs (L24-43)
```csharp
    public AEDPoSContractInitializationData GetContractInitializationData()
    {
        var sideChainInitializationData =
            AsyncHelper.RunSync(_sideChainInitializationDataProvider.GetChainInitializationDataAsync);

        var aedPoSContractInitializationData = new AEDPoSContractInitializationData
        {
            InitialMinerList = sideChainInitializationData == null
                ? _consensusOptions.InitialMinerList
                : MinerListWithRoundNumber.Parser
                    .ParseFrom(sideChainInitializationData.ChainInitializationConsensusInfo.InitialConsensusData)
                    .MinerList.Pubkeys.Select(p => p.ToHex()).ToList(),
            StartTimestamp = sideChainInitializationData?.CreationTimestamp ?? _consensusOptions.StartTimestamp,
            PeriodSeconds = _consensusOptions.PeriodSeconds,
            MiningInterval = _consensusOptions.MiningInterval,
            IsSideChain = true
        };

        return aedPoSContractInitializationData;
    }
```
