### Title
Incomplete Secret Sharing Reconstruction Enables Mining Order Manipulation via Predictable Fallback Hash

### Summary
The secret sharing reconstruction mechanism requires decrypted pieces from ALL miners to reconstruct a miner's previous in-value, but there is no validation enforcing miners to include decrypted pieces for others. When reconstruction fails due to incomplete data, the system falls back to a deterministic fake hash, allowing attackers to predict a target miner's signature and manipulate mining order for the next round.

### Finding Description

The vulnerability exists across three key code locations:

**Location 1: Incomplete Decryption Data Collection** [1](#0-0) 

The `ExtractInformationToUpdateConsensus` function filters `DecryptedPieces` to only include miners who already have entries with `v.DecryptedPieces.ContainsKey(pubkey)`. This means if other miners haven't added decrypted pieces to the round state (by not mining or not including them in their `UpdateValue` calls), those entries won't be included.

**Location 2: Strict Reconstruction Requirement** [2](#0-1) 

The `RevealSharedInValues` function requires `DecryptedPieces.Count < minersCount` to skip reconstruction. Even if only ONE miner's decrypted piece is missing, the entire reconstruction fails and continues to the next miner.

**Location 3: Predictable Fallback Hash** [3](#0-2) 

When reconstruction fails and the target miner also didn't reveal their `PreviousInValue`, `SupplyCurrentRoundInformation` uses `HashHelper.ComputeFrom(miner)` as a fake hash. This is deterministic and computable by attackers who know the miner's state.

**Location 4: Decrypted Pieces Distribution** [4](#0-3) 

The `PerformSecretSharing` function distributes decrypted pieces to miners' state, but there is NO validation that miners must include a minimum number of decrypted pieces.

**Location 5: Mining Order Determined by Signature** [5](#0-4) 

The signature (calculated from `InValue`) is converted to an integer and used to determine `SupposedOrderOfNextRound`, making the mining order predictable when a fake hash is used.

**Root Cause:** There is no validation in the consensus transaction validation logic that miners must include decrypted pieces for all other miners. The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`, not the completeness of decrypted pieces. [6](#0-5) 

### Impact Explanation

**Consensus Integrity Compromise:**

1. **Mining Order Manipulation**: Attackers can predict the target miner's signature when reconstruction fails, allowing them to know in advance which time slot that miner will get in the next round. This enables strategic block production timing attacks.

2. **Random Number Bias**: The AEDPoS random number generation mechanism relies on unpredictable `InValue` secrets from all miners. When fake hashes replace real secrets, the randomness is compromised. The random number is used for critical functions via ACS6. [7](#0-6) 

3. **Consensus Fairness**: The signature calculation XORs all miners' signatures together. Using predictable values breaks the security assumption that miners cannot predict others' contributions. [8](#0-7) 

**Affected Parties:**
- Target miners whose order becomes predictable
- Users relying on random number generation (lottery contracts, etc.)
- Overall consensus fairness and security

**Severity Justification:** HIGH - While this doesn't directly steal funds, it undermines fundamental consensus security properties (unpredictability, fairness) that the entire blockchain relies upon.

### Likelihood Explanation

**Attacker Capabilities Required:**

The attack can succeed in two scenarios:

1. **Miner Coalition Attack**: A coalition controlling >33% of miners (to ensure at least one entry is missing from `DecryptedPieces`) can coordinate to not include decrypted pieces for a target miner. This only requires passive non-action (omitting data) rather than active malicious behavior.

2. **Offline Target Attack**: If the target miner is offline for an extended period and doesn't reveal their `PreviousInValue`, any single malicious miner can avoid adding decrypted pieces to trigger the fake hash fallback.

**Attack Complexity:** LOW
- Miners simply omit `DecryptedPieces` entries from their `UpdateValueInput`
- No complex cryptographic operations or timing requirements
- The off-chain `SecretSharingService` generates decrypted pieces, but miners control what they include on-chain [9](#0-8) 

**Feasibility Conditions:**
- No validation enforces decrypted piece inclusion
- No penalties for not including pieces (evil miner detection only checks missed time slots) [10](#0-9) 

**Detection Difficulty:** MEDIUM - The attack leaves no obvious trace since miners can claim technical issues prevented decryption. Distinguishing malicious omission from legitimate failures is difficult.

**Economic Rationality:** HIGH - The cost is zero (just omit data), while benefits include order manipulation advantages for strategic block production.

### Recommendation

**Fix 1: Enforce Minimum Decrypted Pieces Threshold**

Add validation in `UpdateValueValidationProvider` to require miners include decrypted pieces for at least 2/3 of other miners (matching the secret sharing threshold):

```csharp
private bool ValidateDecryptedPieces(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var decryptedPiecesCount = extraData.Round.RealTimeMinersInformation[validationContext.SenderPubkey]
        .DecryptedPieces.Count;
    var minersCount = extraData.Round.RealTimeMinersInformation.Count;
    var minimumRequired = minersCount.Mul(2).Div(3);
    
    return decryptedPiecesCount >= minimumRequired;
}
```

Add this check to `ValidateHeaderInformation` method at: [11](#0-10) 

**Fix 2: Penalize Missing Decrypted Pieces**

Extend the evil miner detection logic to track miners who consistently fail to provide decrypted pieces: [12](#0-11) 

**Fix 3: Improve Fallback Mechanism**

Instead of a predictable fake hash, use a hash chain based on previous block hashes and timestamps to introduce unpredictability:

```csharp
if (previousInValue == null)
{
    previousInValue = HashHelper.XorAndCompute(
        Context.PreviousBlockHash,
        HashHelper.ComputeFrom(Context.CurrentBlockTime.ToByteArray()),
        HashHelper.ComputeFrom(miner)
    );
    signature = previousInValue;
}
```

**Test Cases:**
1. Test that `UpdateValue` fails when decrypted pieces count < 2/3 threshold
2. Test that reconstruction succeeds with exactly 2/3 pieces
3. Test that miners providing insufficient pieces are marked as suspicious
4. Test fallback hash unpredictability under various scenarios

### Proof of Concept

**Initial State:**
- 7 active miners: A, B, C, D, E, F, G
- Target: Miner A
- Attackers: Miners B, C, D (43% coalition)

**Attack Sequence:**

**Round N:**
1. Miner A produces block and calls `UpdateValue`
2. Miner A's `UpdateValueInput` includes `EncryptedPieces` for all 7 miners
3. `PerformSecretSharing` adds these encrypted pieces to Miner A's round state [13](#0-12) 

**Round N+1:**
4. Miners B, C, D produce blocks but intentionally omit Miner A's decrypted piece from their `UpdateValueInput.DecryptedPieces`
5. When other miners call `ExtractInformationToUpdateConsensus`, the filter at line 26-28 only finds decrypted pieces from E, F, G (3 entries)
6. Miner A's `DecryptedPieces.Count` = 3 < 7 (minersCount)
7. Miner A goes offline and doesn't reveal their `PreviousInValue`

**Round N+2 (NextRound transition):**
8. `SupplyCurrentRoundInformation` is called to fill missing values
9. For Miner A: `PreviousInValue` is null (reconstruction failed at line 36 of `RevealSharedInValues`)
10. `InValue` from previous round is also null (Miner A was offline)
11. System uses fake hash: `previousInValue = HashHelper.ComputeFrom(miner)` (line 208) [14](#0-13) 

**Expected Result:** 
Miner A's `InValue` should be unpredictable, derived from their secret value.

**Actual Result:**
Miner A's `InValue` is `HashHelper.ComputeFrom(miner)`, which is deterministic and computable by attackers who know Miner A's state (public information).

**Success Condition:**
Attackers can compute Miner A's signature for round N+2 and predict their `FinalOrderOfNextRound` for round N+3, enabling strategic block production timing.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L26-28)
```csharp
        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L171-221)
```csharp
    private void SupplyCurrentRoundInformation()
    {
        var currentRound = GetCurrentRoundInformation(new Empty());
        Context.LogDebug(() => $"Before supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
        var notMinedMiners = currentRound.RealTimeMinersInformation.Values.Where(m => m.OutValue == null).ToList();
        if (!notMinedMiners.Any()) return;
        TryToGetPreviousRoundInformation(out var previousRound);
        foreach (var miner in notMinedMiners)
        {
            Context.LogDebug(() => $"Miner pubkey {miner.Pubkey}");

            Hash previousInValue = null;
            Hash signature = null;

            // Normal situation: previous round information exists and contains this miner.
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
            }

            if (previousInValue == null)
            {
                // Handle abnormal situation.

                // The fake in value shall only use once during one term.
                previousInValue = HashHelper.ComputeFrom(miner);
                signature = previousInValue;
            }

            // Fill this two fields at last.
            miner.InValue = previousInValue;
            miner.Signature = signature;

            currentRound.RealTimeMinersInformation[miner.Pubkey] = miner;
        }

        TryToUpdateRoundInformation(currentRound);
        Context.LogDebug(() => $"After supply:\n{currentRound.ToString(Context.RecoverPublicKey().ToHex())}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L125-138)
```csharp
            if (!secretSharingInformation.PreviousRound.RealTimeMinersInformation.ContainsKey(pubkey)) continue;

            var encryptedShares =
                secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].EncryptedPieces;
            if (!encryptedShares.Any() || !encryptedShares.ContainsKey(selfPubkey)) continue;
            var interestingMessage = encryptedShares[selfPubkey];
            var senderPublicKey = ByteArrayHelper.HexStringToByteArray(pubkey);

            var decryptedPiece =
                await _accountService.DecryptMessageAsync(senderPublicKey, interestingMessage.ToByteArray());
            decryptedPieces[pubkey] = decryptedPiece;
            secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].DecryptedPieces[selfPubkey]
                = ByteString.CopyFrom(decryptedPiece);
        }
```
