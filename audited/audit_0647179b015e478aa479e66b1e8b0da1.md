### Title
Non-Whitelisted Contract Deployers Lose Exclusive Authorship, Allowing Anyone to Propose Updates

### Summary
When non-whitelisted users deploy contracts, `DecideNonSystemContractAuthor()` assigns Contract Zero as the author instead of the deployer. This centralizes control because `AssertAuthorityByContractInfo()` allows anyone to propose updates to contracts authored by Contract Zero, removing the deployer's exclusive control and significantly increasing the attack surface for malicious update proposals.

### Finding Description

The vulnerability exists in the contract authorship assignment logic during deployment: [1](#0-0) 

When `DeploySmartContract()` is called after proposal approval, it determines the contract author: [2](#0-1) 

The `DecideNonSystemContractAuthor()` function checks if the proposer is in the deployment whitelist. If the proposer is NOT whitelisted, it returns `Context.Self` (Contract Zero's address) as the author rather than the actual deployer.

The critical flaw is in the update authorization check: [3](#0-2) 

This check is used when proposing contract updates: [4](#0-3) 

The condition `contractInfo.Author == Context.Self || address == contractInfo.Author` means:
- If the author is Contract Zero (`Context.Self`), **the check always passes** regardless of who is proposing
- If the author is a regular user, only that user can propose updates

**Root Cause**: The authorization logic fails to distinguish between "Contract Zero as the system" and "Contract Zero as a contract author". When Contract Zero is the author, the permission check becomes meaningless.

**Why Existing Protections Fail**: While governance approval is still required to execute updates, the authorization barrier for *proposing* updates is removed. Instead of only the contract deployer being able to propose updates, **anyone** can propose updates to contracts authored by Contract Zero.

### Impact Explanation

**Primary Impact - Authorization Bypass**:
- Original deployers of contracts lose exclusive control over their contracts when they're not in the proposer whitelist
- Any user can propose updates to contracts authored by Contract Zero, bypassing the intended authorization model
- This creates an asymmetric control model where whitelisted deployers retain exclusive control, but non-whitelisted deployers do not

**Secondary Impact - Increased Attack Surface**:
- Attack surface for malicious updates increases dramatically (from 1 authorized user to all users)
- Enables social engineering attacks where malicious actors propose seemingly benign updates to governance
- Governance faces increased overhead reviewing proposals from arbitrary users rather than just contract authors
- Potential for proposal spam attacks overwhelming the governance system

**Who Is Affected**:
- Non-whitelisted users deploying contracts on shared side chains
- Any users deploying contracts when not in the ContractDeploymentController's proposer whitelist
- The governance system dealing with increased proposal volume

**Severity Justification**: Medium severity because:
1. Authorization model is fundamentally broken for non-whitelisted deployers
2. Malicious updates still require governance approval (defense-in-depth)
3. Realistic exploitation scenario on shared side chains where "anyone can deploy"
4. Concrete harm: loss of exclusive control and increased governance attack surface

### Likelihood Explanation

**Attacker Capabilities**:
- Attacker needs only standard user account capabilities
- No special permissions or resources required
- Can deploy contracts through normal proposal process

**Attack Complexity**: Low
1. Deploy a contract as a non-whitelisted user → Contract Zero becomes author
2. Propose malicious update to that contract (or any other Contract Zero-authored contract)
3. Use social engineering to convince governance to approve

**Feasibility Conditions**: Highly feasible
- Shared side chains explicitly allow "anyone to propose contracts" per documentation
- Main chain/exclusive side chain users not in whitelist also affected
- No economic barriers beyond normal proposal costs [5](#0-4) 

**Detection Constraints**: 
- Test evidence shows this is expected behavior for non-whitelisted deployers: [6](#0-5) [7](#0-6) 

- However, tests also show whitelisted users retain authorship: [8](#0-7) 

**Probability**: High for shared side chains, Medium for other deployments where users may not be whitelisted.

### Recommendation

**Immediate Fix - Distinguish Contract Zero System vs Author Roles**:

Modify `AssertAuthorityByContractInfo()` to NOT automatically grant permission when author is Contract Zero:

```csharp
private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
{
    // Remove the automatic pass for Context.Self
    Assert(address == contractInfo.Author, "No permission.");
}
```

**Better Approach - Assign Deployer as Author**:

Modify `DecideNonSystemContractAuthor()` to always return the proposer/sender:

```csharp
private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
{
    // Always assign deployer as author, regardless of whitelist status
    return proposer ?? sender;
}
```

**Alternative - Explicit Authorization for Non-Authors**:

If governance control is intended, make it explicit through a separate permission check rather than abusing the author field:

```csharp
private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
{
    bool isAuthor = address == contractInfo.Author;
    bool isGovernance = address == State.ContractDeploymentController.Value.OwnerAddress;
    Assert(isAuthor || isGovernance, "No permission.");
}
```

**Invariant Checks to Add**:
1. Contract author should always be the actual deployer/proposer
2. Only the contract author should be able to propose updates (unless explicit governance override)
3. Test that non-whitelisted users deploying contracts retain authorship

**Test Cases**:
1. Deploy contract as non-whitelisted user → verify deployer is author (not Contract Zero)
2. Non-author attempts to propose update → should fail with "No permission"
3. Governance attempts to update via explicit override mechanism → should succeed

### Proof of Concept

**Initial State**:
- Chain configured with `ContractDeploymentAuthorityRequired = true`
- ContractDeploymentController whitelist contains only miners
- UserA is not in the whitelist

**Exploitation Steps**:

1. **UserA deploys contract**:
   - UserA calls `ProposeNewContract(contractCode)`
   - Governance approves both proposals
   - Contract deploys with `Author = BasicContractZeroAddress` (not UserA)
   - UserA has lost exclusive control

2. **AttackerB proposes malicious update**:
   - AttackerB calls `ProposeUpdateContract(contractAddress, maliciousCode)`
   - `AssertAuthorityByContractInfo` check passes because `contractInfo.Author == Context.Self`
   - Proposal created successfully (should have failed for non-author)

3. **Social engineering governance**:
   - AttackerB convinces governance the update is legitimate
   - Governance approves malicious update
   - Contract compromised

**Expected vs Actual**:
- **Expected**: Only UserA (contract deployer) can propose updates
- **Actual**: Anyone including AttackerB can propose updates because author is Contract Zero

**Success Condition**: 
- AttackerB successfully creates update proposal for contract they didn't deploy
- Verify by checking proposal exists and AttackerB is not the contract author

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L257-266)
```csharp
    private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
    {
        if (!State.ContractDeploymentAuthorityRequired.Value)
            return sender;

        var contractDeploymentController = State.ContractDeploymentController.Value;
        var isProposerInWhiteList = ValidateProposerAuthority(contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposer);
        return isProposerInWhiteList ? proposer : Context.Self;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-183)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L317-321)
```csharp
        var address =
            DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
                DecideNonSystemContractAuthor(contractProposingInput?.Proposer, Context.Sender), false,
                input.ContractOperation?.Deployer, input.ContractOperation?.Salt);
        return address;
```

**File:** docs-sphinx/getting-started/smart-contract-development/deployment.md (L44-46)
```markdown
- Main Chain: only current miners have the permission to propose contract
- Exclusive Side Chain: only side chain creator are allowed to propose contract
- Shared Side Chain: anyone can propose contract 
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L248-249)
```csharp
        var creator = ContractDeployed.Parser.ParseFrom(deploymentResult.Logs[1].Indexed[0]).Author;
        creator.ShouldBe(BasicContractZeroAddress);
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L822-826)
```csharp
        var creator = ContractDeployed.Parser
            .ParseFrom(deploymentResult.Logs.First(l => l.Name.Contains(nameof(ContractDeployed))).Indexed[0])
            .Author;

        creator.ShouldBe(BasicContractZeroAddress);
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L928-932)
```csharp
        var creator = ContractDeployed.Parser
            .ParseFrom(deploymentResult.Logs.First(l => l.Name.Contains(nameof(ContractDeployed))).Indexed[0])
            .Author;

        creator.ShouldBe(AnotherMinerAddress);
```
