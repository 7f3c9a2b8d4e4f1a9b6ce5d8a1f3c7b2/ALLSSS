### Title
Vote Contract Option Length Validation Bypass Causes Permanent Option Denial of Service

### Summary
The Vote contract's `Register` method fails to validate option lengths during voting item creation, allowing options exceeding 1024 bytes to be added. Subsequently, the `RemoveOption` method validates option length before checking existence, preventing legitimate sponsors from removing these oversized options and causing permanent denial of service on voting item management.

### Finding Description

The vulnerability exists due to inconsistent option length validation across different methods in the Vote contract.

**Root Cause - Missing Validation in Register:**

The `Register` method creates voting items by calling `AssertValidNewVotingItem`, which only validates the voting item ID, timestamp range, and snapshot number, but completely omits option length validation. [1](#0-0) 

Options from the input are directly copied into the voting item without any length checks: [2](#0-1) 

The `OptionLengthLimit` constant is defined as 1024 bytes: [3](#0-2) 

**Blocking Validation in RemoveOption:**

The `RemoveOption` method validates option length at line 307 BEFORE checking if the option exists at line 308. This order prevents removal of any option exceeding 1024 bytes, even if it legitimately exists in the voting item: [4](#0-3) 

**Consistent Validation in Other Methods:**

In contrast, `AddOption` properly validates option lengths through the `AssertOption` helper: [5](#0-4) 

Similarly, the `Vote` method validates option lengths before accepting votes: [6](#0-5) 

The `RemoveOptions` (plural) method also has the same blocking validation issue: [7](#0-6) 

### Impact Explanation

**Operational Denial of Service:**
- Sponsors who create voting items with options >1024 bytes (whether accidentally or intentionally) permanently lose the ability to remove those options
- The voting item becomes polluted with unremovable, invalid options
- No recovery mechanism exists since both `RemoveOption` and `RemoveOptions` enforce the length check

**Unusable Options:**
- Users cannot vote for options exceeding 1024 bytes because the `Vote` method rejects them with "Invalid input"
- These options exist in the voting item but are completely non-functional

**Governance Impact:**
- The Election contract uses the Vote contract to manage candidate options
- If candidate public keys or identifiers exceed 1024 bytes (which is possible with certain encoding schemes), they become permanently stuck in the voting system
- This could disrupt election processes and candidate management

**State Pollution:**
- Invalid options persist indefinitely in contract state
- Storage costs are incurred for unusable data
- The maximum option count (64) could be reached with invalid options, preventing addition of valid ones

### Likelihood Explanation

**High Likelihood:**
- Any sponsor can trigger this condition simply by registering a voting item with long options
- No special permissions or preconditions required beyond being a sponsor
- The `Register` method is a public entry point accessible to all users
- No validation error occurs during registration, making the issue non-obvious until removal is attempted

**Realistic Attack Scenarios:**

1. **Accidental Trigger:** A sponsor using programmatically generated option strings (e.g., serialized data structures, long descriptions, or encoded public keys) exceeds the limit without realizing it due to lack of validation feedback.

2. **Intentional Self-DoS:** A malicious or compromised sponsor could intentionally create voting items with oversized options to permanently lock them in an invalid state.

3. **Cross-Contract Integration:** When the Vote contract is called by other contracts (like Election), those contracts may pass options exceeding 1024 bytes, resulting in permanently unmanageable voting items.

**Economic Feasibility:**
- Attack cost: Only standard transaction fees for calling `Register`
- No token locks or deposits required
- No complex setup or multi-step exploitation needed

**Detection Difficulty:**
- The `Register` transaction succeeds without any warning
- The issue only becomes apparent when `RemoveOption` is called later
- No events or logs indicate the presence of oversized options

### Recommendation

**Primary Fix - Add Validation to Register:**

Modify the `AssertValidNewVotingItem` method to validate all option lengths during registration:

```csharp
private Hash AssertValidNewVotingItem(VotingRegisterInput input)
{
    var votingItemId = input.GetHash(Context.Sender);
    Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");
    
    // Add option length validation
    foreach (var option in input.Options)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, 
            $"Option length cannot exceed {VoteContractConstants.OptionLengthLimit} characters.");
    }
    
    if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;
    Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");
    
    Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");
    return votingItemId;
}
```

**Alternative Fix - Remove Length Check from RemoveOption:**

If there's a legitimate use case for oversized options, remove the length validation from `RemoveOption` and `RemoveOptions` to allow cleanup of any existing options:

```csharp
public override Empty RemoveOption(RemoveOptionInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
    // Remove this line: Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
    Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
    votingItem.Options.Remove(input.Option);
    State.VotingItems[votingItem.VotingItemId] = votingItem;
    return new Empty();
}
```

**Test Cases to Add:**

1. Test registering a voting item with options exceeding 1024 bytes (should fail with validation error)
2. Test that all existing tests with valid option lengths continue to pass
3. Add integration tests with the Election contract to ensure candidate identifiers stay within limits

### Proof of Concept

**Initial State:**
- Sponsor has sufficient tokens and permissions to create voting items
- Token contract is initialized with accepted currency in whitelist

**Exploitation Steps:**

1. **Create Voting Item with Oversized Option:**
```csharp
var longOption = new string('A', 1025); // 1025 bytes > 1024 limit
var input = new VotingRegisterInput
{
    StartTimestamp = Timestamp.FromDateTime(DateTime.UtcNow),
    EndTimestamp = Timestamp.FromDateTime(DateTime.UtcNow.AddDays(7)),
    AcceptedCurrency = "ELF",
    IsLockToken = true,
    TotalSnapshotNumber = 1,
    Options = { longOption, "ValidOption" }
};

// This succeeds - no validation error
var result = await VoteContractStub.Register.SendAsync(input);
// result.TransactionResult.Status == TransactionResultStatus.Mined
```

2. **Attempt to Remove the Oversized Option:**
```csharp
var removeInput = new RemoveOptionInput
{
    VotingItemId = votingItemId,
    Option = longOption
};

// This fails with "Invalid input" at line 307
var removeResult = await VoteContractStub.RemoveOption.SendWithExceptionAsync(removeInput);
// removeResult.TransactionResult.Status == TransactionResultStatus.Failed
// removeResult.TransactionResult.Error.Contains("Invalid input")
```

3. **Verify Option Remains in Voting Item:**
```csharp
var votingItem = await VoteContractStub.GetVotingItem.CallAsync(
    new GetVotingItemInput { VotingItemId = votingItemId });
// votingItem.Options.Contains(longOption) == true
// Option is permanently stuck
```

**Expected vs Actual Result:**
- **Expected:** Sponsor can remove any option they added, or registration fails if options are invalid
- **Actual:** Registration succeeds with invalid options, but removal is permanently blocked, causing denial of service

**Success Condition:**
The vulnerability is confirmed when a voting item contains an option >1024 bytes that cannot be removed by the legitimate sponsor due to the length validation in `RemoveOption`.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L49-49)
```csharp
            Options = { input.Options },
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L292-296)
```csharp
    private void AssertOption(VotingItem votingItem, string option)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(!votingItem.Options.Contains(option), "Option already exists.");
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L303-312)
```csharp
    public override Empty RemoveOption(RemoveOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
        votingItem.Options.Remove(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L326-339)
```csharp
    public override Empty RemoveOptions(RemoveOptionsInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        foreach (var option in input.Options)
        {
            Assert(votingItem.Options.Contains(option), "Option doesn't exist.");
            Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
            votingItem.Options.Remove(option);
        }

        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-381)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L6-6)
```csharp
    public const int OptionLengthLimit = 1024;
```
