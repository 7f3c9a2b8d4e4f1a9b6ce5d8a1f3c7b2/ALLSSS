# Audit Report

## Title
Unauthorized Round Termination by Non-Extra-Block-Producer Miners

## Summary
The AEDPoS consensus contract fails to validate that only the designated extra block producer can terminate rounds via NextRound/NextTerm transactions. Any miner who has produced their normal block can prematurely terminate the round, violating the fundamental consensus invariant that requires the extra block producer to complete this role.

## Finding Description

The AEDPoS consensus mechanism designates a specific miner as the "extra block producer" for each round, calculated via `CalculateNextExtraBlockProducerOrder()` and marked with the `IsExtraBlockProducer` flag. [1](#0-0)  This extra block producer is intended to terminate the round after all miners have mined their blocks. [2](#0-1) 

However, the behavior determination logic in `GetConsensusBehaviour()` returns termination behaviors (NextRound/NextTerm) for ANY miner who has produced their block (`OutValue != null`) and whose time slot has passed, without checking if they are the designated extra block producer. [3](#0-2) 

The validation system contains multiple providers, but none verify extra block producer authorization:

- `MiningPermissionValidationProvider` only checks miner list membership [4](#0-3) 

- `TimeSlotValidationProvider` validates time slot spacing but not miner authorization for round termination [5](#0-4) 

- `RoundTerminateValidationProvider` only validates round/term number increments [6](#0-5) 

The validation logic for NextRound and NextTerm behaviors does not include any check for extra block producer status. [7](#0-6) 

Even in the execution phase, `PreCheck()` only verifies the miner is in the miner list, not whether they are authorized as the extra block producer. [8](#0-7) 

Notably, the `IsCurrentMiner` view method DOES correctly check for extra block producer authorization during the extra block time slot [9](#0-8) , but this check is not integrated into the transaction validation flow.

## Impact Explanation

**Consensus Integrity Violation**: The core consensus rule that only the designated extra block producer should terminate rounds is violated. This breaks the fundamental scheduling mechanism where each miner gets their allocated time slot before round completion.

**Operational Disruption**: When a non-extra-block-producer miner terminates the round early, subsequent miners in the round lose their opportunity to produce blocks. This disrupts the fair rotation of mining responsibilities and the deterministic mining schedule that AEDPoS consensus relies upon.

**Reward Misallocation**: Miners who lose their time slots due to premature round termination miss out on mining rewards, creating unfair economic outcomes. The attacker gains a competitive advantage by controlling when rounds end.

**Potential Consensus Instability**: Multiple miners could simultaneously attempt to terminate the round once their time slots pass, potentially leading to competing round termination blocks and temporary consensus disagreement among nodes.

The severity is **High** because this directly violates a critical consensus invariant that ensures fair and deterministic block production scheduling.

## Likelihood Explanation

**Attacker Capabilities**: Any registered miner in the current round can exploit this vulnerability. No special permissions beyond standard miner status are required.

**Attack Complexity**: Low. The attacker simply:
1. Produces their normal block (setting `OutValue`)
2. Waits for their time slot to pass
3. Calls the public `GetConsensusCommand` method
4. Receives NextRound/NextTerm behavior
5. Produces the terminating block

**Preconditions**: 
- Miner must be in the current round's miner list (standard requirement)
- Miner must have produced their normal block
- Current time must be past the miner's time slot
- The actual extra block producer must not have terminated yet

**Economic Incentive**: A malicious miner can deny competitors their time slots, manipulate which miners participate in round completion, and potentially gain timing advantages for transaction inclusion.

The likelihood is **High** because this can occur through normal operations when miners' logic incorrectly triggers round termination, or intentionally by malicious actors seeking unfair advantages.

## Recommendation

Add a validation provider `ExtraBlockProducerValidationProvider` that checks whether the sender is authorized to terminate the current round:

```csharp
public class ExtraBlockProducerValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        
        // Only validate for round termination behaviors
        if (extraData.Behaviour != AElfConsensusBehaviour.NextRound && 
            extraData.Behaviour != AElfConsensusBehaviour.NextTerm)
        {
            validationResult.Success = true;
            return validationResult;
        }
        
        // Get the designated extra block producer
        var extraBlockProducer = validationContext.BaseRound.GetExtraBlockProducerInformation();
        
        // Verify the sender is the designated extra block producer
        if (extraBlockProducer.Pubkey != validationContext.SenderPubkey)
        {
            validationResult.Message = $"Only the designated extra block producer ({extraBlockProducer.Pubkey}) can terminate the round. Sender: {validationContext.SenderPubkey}";
            return validationResult;
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Then register this provider in the validation logic:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new ExtraBlockProducerValidationProvider()); // Add this
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new ExtraBlockProducerValidationProvider()); // Add this
    break;
```

## Proof of Concept

A proof of concept would demonstrate:
1. Multiple miners in a round
2. Miner A (not the extra block producer) produces their normal block
3. Miner A's time slot passes
4. Miner A calls `GetConsensusCommand` and receives NextRound behavior
5. Miner A successfully executes a NextRound transaction
6. Round terminates prematurely, before Miners B, C, D get their turns
7. Miners B, C, D lose their time slots and rewards

The test would verify that the validation passes even though Miner A is not the designated extra block producer, confirming the absence of authorization checks.

## Notes

While the `IsCurrentMiner` view method correctly validates extra block producer authorization for query purposes, this check is not integrated into the transaction validation pipeline. The vulnerability exists because the contract assumes miners will follow the behavior commands honestly, but provides no enforcement mechanism to prevent unauthorized round termination.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-65)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L60-64)
```csharp
    /// <summary>
    ///     In current AElf Consensus design, each miner produce his block in one time slot, then the extra block producer
    ///     produce a block to terminate current round and confirm the mining order of next round.
    ///     So totally, the time of one round is:
    ///     MiningInterval * MinersCount + MiningInterval.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-82)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L10-47)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) return ValidationForNextRound(validationContext);

        if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) return ValidationForNextTerm(validationContext);

        validationResult.Success = true;
        return validationResult;
    }

    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```
