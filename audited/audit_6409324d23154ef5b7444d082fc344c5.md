### Title
Mining Order Manipulation Through Unvalidated TuneOrderInformation in UpdateValue

### Summary
An authorized miner can manipulate the mining order of the next consensus round by including malicious `TuneOrderInformation` in their `UpdateValue` transaction. This data is applied directly to state without validation, allowing the attacker to assign favorable mining positions to themselves and disrupt the fair rotation of consensus duties.

### Finding Description

The vulnerability exists in the `ProcessUpdateValue` function where `TuneOrderInformation` from user input is directly applied to all miners' `FinalOrderOfNextRound` values without validation. [1](#0-0) 

The `FinalOrderOfNextRound` field determines each miner's position in the subsequent consensus round: [2](#0-1) 

**Why protections fail:**

1. During `ValidateBeforeExecution`, the `RecoverFromUpdateValue` function has an authorization check that prevents unauthorized miners from proceeding: [3](#0-2) 

However, this check only prevents UNAUTHORIZED miners. Authorized miners pass this check and their provided round data (including malicious order assignments) is copied: [4](#0-3) 

2. The validation providers for `UpdateValue` behavior do not include any validator that checks the correctness of `FinalOrderOfNextRound` values: [5](#0-4) 

The `NextRoundMiningOrderValidationProvider` that validates mining orders is only added for `NextRound` behavior, not `UpdateValue`: [6](#0-5) 

3. The `ValidateConsensusAfterExecution` contains a logic error where it modifies `currentRound` via `RecoverFromUpdateValue` and then compares it to itself: [7](#0-6) 

Since `RecoverFromUpdateValue` returns `this` (modifying the object in place), both `currentRound` and `headerInformation.Round` point to the same modified object after line 91, making the hash comparison on line 100-101 always succeed. [8](#0-7) 

### Impact Explanation

**Consensus Integrity Violation (High Severity):**

A malicious authorized miner can manipulate the mining order for the next consensus round, causing:

1. **Unfair Mining Advantages**: The attacker can assign themselves multiple consecutive mining slots (e.g., positions 1, 2, 3), violating the fair rotation principle of AEDPoS consensus.

2. **Miner Exclusion**: By manipulating `FinalOrderOfNextRound` assignments, the attacker can effectively prevent specific miners from mining in their intended time slots or push them to less favorable positions.

3. **Consensus Liveness Disruption**: Manipulation of mining order can disrupt the expected timing and flow of consensus, potentially affecting block production rate and Last Irreversible Block (LIB) finalization.

4. **Compound Effects**: Since each round's order affects subsequent rounds, a persistent attacker mining regularly can maintain ongoing manipulation of consensus order across multiple rounds.

The integrity of the entire AEDPoS consensus mechanism depends on the fairness and correctness of mining order assignments. This vulnerability directly undermines that critical invariant.

### Likelihood Explanation

**High Likelihood:**

**Attacker Capabilities Required:**
- Must be an authorized miner in the current consensus round
- This is achievable in production as miners are elected through the Election contract
- Any of the active miners could become malicious

**Attack Complexity:**
- LOW - The attacker simply needs to modify the `TuneOrderInformation` field in their `UpdateValueInput` before submitting
- The `UpdateValueInput` is constructed client-side via `ExtractInformationToUpdateConsensus`: [9](#0-8) 

- The attacker can modify values before submission without any cryptographic barriers

**Feasibility Conditions:**
- Requires being selected as a miner (realistic through normal election process)
- No special privileges beyond being an active miner
- Attack succeeds deterministically once executed

**Detection Difficulty:**
- Other nodes would see manipulated mining orders in the next round
- However, by design, order variations can occur legitimately through the conflict resolution mechanism in `ApplyNormalConsensusData`
- Distinguishing malicious manipulation from legitimate order changes requires comparing against independently calculated expected orders

**Economic Rationality:**
- Attack cost is minimal (just transaction fees for UpdateValue)
- Benefit is significant mining advantage and potential for MEV extraction through control of block ordering

### Recommendation

**Immediate Fix:**

1. **Add Order Validation for UpdateValue**: Implement a validator that checks `TuneOrderInformation` values are correctly calculated according to consensus rules. Add this validator to the UpdateValue validation providers: [5](#0-4) 

The validator should:
- Verify that `SupposedOrderOfNextRound` values match `GetAbsModulus(signature, minersCount) + 1` as calculated in: [10](#0-9) 

- Verify that `FinalOrderOfNextRound` assignments follow the conflict resolution rules: [11](#0-10) 

- Ensure no duplicate or invalid order values

2. **Fix ValidateConsensusAfterExecution Logic**: Clone `currentRound` before calling `RecoverFromUpdateValue` to enable proper comparison:

```csharp
var expectedRound = currentRound.Clone();
expectedRound.RecoverFromUpdateValue(headerInformation.Round, headerInformation.SenderPubkey.ToHex());
if (expectedRound.GetHash(isContainPreviousInValue) != currentRound.GetHash(isContainPreviousInValue))
{
    // Validation failure
}
```

3. **Add Unit Tests**: Create test cases that attempt to submit UpdateValue with manipulated TuneOrderInformation and verify they are rejected.

### Proof of Concept

**Initial State:**
- Current consensus round has 5 miners: M1, M2, M3, M4, M5
- M2 is the attacker (authorized miner)
- Current round mining progressing normally
- Each miner should have fair, calculated order in next round

**Attack Steps:**

1. M2's turn to produce block with UpdateValue
2. M2 constructs `UpdateValueInput` with malicious `TuneOrderInformation`:
   - Sets their own `FinalOrderOfNextRound` = 1 (first position)
   - Sets M1's `FinalOrderOfNextRound` = 5 (last position)
   - Manipulates other orders to their advantage

3. M2 submits UpdateValue transaction with this malicious input

4. `ValidateBeforeExecution` runs:
   - `RecoverFromUpdateValue` checks M2 is authorized (line 10-12) → PASSES
   - Copies malicious orders to baseRound (lines 22-30)
   - `MiningPermissionValidationProvider` checks M2 in miner list → PASSES
   - No validator checks order correctness → PASSES

5. `ProcessUpdateValue` executes:
   - Lines 259-260 apply malicious `TuneOrderInformation` to state
   - State now contains corrupted `FinalOrderOfNextRound` values

6. `ValidateConsensusAfterExecution` runs:
   - Compares object to itself due to bug → PASSES

**Result:**
- Next round's mining order generated from corrupted values
- M2 mines first instead of their calculated position
- M1 pushed to last position instead of calculated position
- Consensus order integrity violated

**Expected vs Actual:**
- Expected: Mining order based on signatures and consensus algorithm rules
- Actual: Mining order manipulated by attacker's chosen values
- Success Condition: M2's mining position in next round matches their malicious assignment rather than algorithmic calculation

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L10-12)
```csharp
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L32-32)
```csharp
        return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L87-101)
```csharp
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-44)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);

        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);

        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-40)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```
