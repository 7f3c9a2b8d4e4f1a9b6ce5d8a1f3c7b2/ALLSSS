# Audit Report

## Title
Negative Profit Values Propagated Without Validation Leading to Incorrect View Data and Lost Claims

## Summary
The Profit Contract stores negative amounts in `DistributedProfitsMap` to represent burned tokens during delay distribution periods. These negative values propagate through view methods without validation and cause beneficiaries to permanently lose claim rights to these periods during `ClaimProfits`, as `lastProfitPeriod` is incremented even when no tokens are transferred.

## Finding Description

The vulnerability exists across multiple components of the Profit Contract:

**1. Negative Value Storage in BurnProfits:**
When a scheme has `DelayDistributePeriodCount > 0`, the early periods have `totalShares = 0` because no beneficiaries have reached their start period yet. [1](#0-0)  During distribution, this triggers the BurnProfits path [2](#0-1)  which explicitly stores negative amounts to represent burned tokens. [3](#0-2) 

**2. Unvalidated Return in View Methods:**
The `GetProfitAmount()` view method retrieves and returns these values directly without validation. [4](#0-3)  The calculation chain passes negative amounts through `ProfitAllPeriods` [5](#0-4)  to `SafeCalculateProfits` [6](#0-5)  which performs arithmetic without validating that amounts are non-negative. [7](#0-6) 

**3. Lost Claims During ClaimProfits:**
During `ClaimProfits`, when the calculated amount is negative or zero, the transfer condition fails [8](#0-7)  so no tokens are transferred to the beneficiary. However, `lastProfitPeriod` is still incremented outside this condition, [9](#0-8)  permanently marking these periods as "claimed" even though the beneficiary received nothing.

**Execution Flow:**
1. Manager creates scheme with `DelayDistributePeriodCount = 3`
2. Beneficiaries are added in period 1, their `StartPeriod` is set to period 4 [10](#0-9) 
3. Manager distributes profits in periods 1, 2, 3 (before beneficiaries' start periods)
4. These distributions find `totalShares = 0` and burn the tokens with negative storage
5. Beneficiary queries profits and receives negative values
6. Beneficiary claims profits: periods 1-3 increment `lastProfitPeriod` without transferring tokens
7. Beneficiary permanently loses access to those periods

## Impact Explanation

**Direct Financial Loss:**
Beneficiaries permanently lose their proportional share of profits that were supposed to be distributed in delay periods. For a scheme with `DelayDistributePeriodCount = 3` distributing 1,000 ELF per period, each beneficiary loses claim rights to approximately 3,000 ELF worth of periods. This affects ALL beneficiaries added during or before the delay period window.

**Data Integrity Violation:**
View methods return negative profit values, which is semantically incorrect and misleads users, UIs, and off-chain systems about actual claimable amounts. The `ProfitsClaimed` event is never emitted for these periods [11](#0-10)  breaking audit trails and accounting systems.

**Affected Parties:**
- Early adopters in any scheme using delayed distribution
- All beneficiaries whose `StartPeriod` falls after initial distribution periods
- External systems relying on accurate profit view data

## Likelihood Explanation

**Trigger Conditions - All Normal Operation:**
1. `DelayDistributePeriodCount > 0` is a documented feature for staged distribution
2. Adding beneficiaries from early periods is standard operation
3. Distributing profits during delay periods is required/expected behavior
4. Beneficiaries querying and claiming profits is normal user activity

**Probability: HIGH**
- Automatically occurs in every scheme using `DelayDistributePeriodCount > 0`
- No special permissions or attack vectors required
- Affects the first N periods where N = `DelayDistributePeriodCount`
- Already present in any deployed delayed distribution schemes
- Cannot be avoided while using the documented delay feature

## Recommendation

**Fix 1: Separate Tracking for Burned Periods**
Instead of storing negative amounts, add a separate flag `IsBurned` to `DistributedProfitsInfo`:
```csharp
// In proto definition
message DistributedProfitsInfo {
    bool is_burned = X;  // New field
    // ... existing fields
}

// In BurnProfits
distributedProfitsInfo.IsBurned = true;
distributedProfitsInfo.AmountsMap.Add(symbol, 0);  // Store 0 instead of negative

// In ProfitAllPeriods
if (distributedProfitsInformation.IsBurned) {
    continue;  // Skip this period, don't increment lastProfitPeriod
}
```

**Fix 2: Conditional Period Increment**
Only increment `lastProfitPeriod` when tokens are actually transferred:
```csharp
// In ProfitAllPeriods around line 908
if (!isView)
{
    if (distributedProfitsInformation.IsReleased && amount > 0)
    {
        // ... existing transfer code ...
        lastProfitPeriod = period + 1;  // Move inside the condition
    }
    // Don't increment if no transfer occurred
}
```

**Fix 3: View Method Validation**
Add validation in view methods to never return negative values:
```csharp
// In GetProfitAmount
return new Int64Value
{
    Value = allProfitsMapResult.AllProfitsMap.TryGetValue(input.Symbol, out var value) 
        ? Math.Max(0, value)  // Never return negative
        : 0
};
```

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_NegativeProfits_LostClaims_Test()
{
    const int delayDistributePeriodCount = 3;
    const int contributeAmount = 100_000;
    var creator = Creators[0];
    var beneficiary = Accounts[11].Address;

    // Create scheme with delayed distribution
    await creator.CreateScheme.SendAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true,
        DelayDistributePeriodCount = delayDistributePeriodCount
    });

    var schemeId = (await creator.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = Address.FromPublicKey(CreatorKeyPair[0].PublicKey) }
    )).SchemeIds.First();

    // Add beneficiary in period 1
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiary, Shares = 100 }
    });

    var balanceBefore = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = beneficiary, Symbol = "ELF" }
    )).Balance;

    // Distribute profits in delay periods 1, 2, 3
    for (var period = 1; period <= 3; period++)
    {
        await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeId = schemeId,
            Amount = contributeAmount,
            Symbol = "ELF"
        });
        await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeId = schemeId,
            Period = period
        });
    }

    // VULNERABILITY: GetProfitAmount returns negative value
    var profitAmount = await creator.GetProfitAmount.CallAsync(new GetProfitAmountInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiary,
        Symbol = "ELF"
    });
    
    profitAmount.Value.ShouldBeLessThan(0); // View returns negative!

    // Claim profits - should get tokens but doesn't
    await Creators[0].ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiary
    });

    var balanceAfter = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = beneficiary, Symbol = "ELF" }
    )).Balance;

    // VULNERABILITY: Balance unchanged - beneficiary received NOTHING
    (balanceAfter - balanceBefore).ShouldBe(0);

    // VULNERABILITY: But periods are marked as claimed - cannot re-claim
    var profitDetails = await creator.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiary
    });
    profitDetails.Details.First().LastProfitPeriod.ShouldBeGreaterThan(3); // Periods lost forever
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-486)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L551-551)
```csharp
                distributedProfitsInfo.AmountsMap.Add(symbol, -amount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L881-895)
```csharp
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L897-905)
```csharp
                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L908-908)
```csharp
                    lastProfitPeriod = period + 1;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L62-70)
```csharp
    public override Int64Value GetProfitAmount(GetProfitAmountInput input)
    {
        var allProfitsMapResult = GetAllProfitsMap(input.SchemeId, input.Beneficiary, input.Symbol);

        return new Int64Value
        {
            Value = allProfitsMapResult.AllProfitsMap.TryGetValue(input.Symbol, out var value) ? value : 0
        };
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L130-130)
```csharp
            var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod),true, symbol);
```
