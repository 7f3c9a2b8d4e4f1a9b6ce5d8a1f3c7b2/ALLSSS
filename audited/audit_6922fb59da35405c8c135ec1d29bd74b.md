### Title
Missing Validation Allows Negative AutoDistributeThreshold Values, Inverting Distribution Logic

### Summary
The `CreateScheme()` function does not validate `AutoDistributeThreshold` values, allowing negative amounts to be set. This causes the auto-distribution logic in `RegisterForProfits()` to malfunction by inverting the threshold check, triggering distribution on every registration regardless of actual balance, defeating the threshold mechanism entirely.

### Finding Description

The `CreateScheme()` function accepts `AutoDistributeThreshold` values without any validation: [1](#0-0) 

The protobuf definition allows `int64` values which can be negative: [2](#0-1) 

In `RegisterForProfits()`, the auto-distribution logic checks if the virtual address balance is less than the threshold value: [3](#0-2) 

The critical flaw is at the comparison logic: when `threshold.Value` is negative and `balance` is non-negative (token balances are always >= 0), the condition `balance < threshold.Value` evaluates to FALSE. This causes the code to skip the `continue` statement and proceed to trigger auto-distribution. For example, if threshold is -1000 and balance is 100, then `100 < -1000` is FALSE, so distribution occurs.

When distribution is triggered, `AmountsMap[symbol] = 0` is set, which causes the Profit contract to distribute ALL available balance: [4](#0-3) 

This inverts the intended threshold logic: instead of triggering when balance exceeds threshold, it triggers on EVERY `RegisterForProfits` call regardless of balance amount.

### Impact Explanation

**Operational Impact on Distribution Mechanism:**
- The threshold feature becomes completely dysfunctional, triggering distribution when it shouldn't
- Every `RegisterForProfits` call forces an immediate distribution, even with minimal or zero accumulated balance
- Scheme managers lose control over distribution timing and batch optimization
- Results in excessive gas costs from frequent small distributions instead of economical batch distributions
- Early beneficiaries receive premature distributions before meaningful profit accumulation
- Breaks the economic design of threshold-based profit distribution systems

**Affected Parties:**
- TokenHolder schemes using auto-distribution thresholds
- All beneficiaries participating in affected schemes
- Scheme managers who inadvertently set negative values

**Severity Justification (Medium):**
The vulnerability causes significant operational dysfunction and economic inefficiency but requires the scheme manager to misconfigure their own scheme. It doesn't directly enable fund theft but fundamentally breaks the intended distribution mechanics.

### Likelihood Explanation

**Feasible Preconditions:**
- Scheme manager must call `CreateScheme()` with negative threshold values
- Can occur accidentally through UI bugs, input errors, or misunderstanding of parameter semantics
- No validation exists to prevent or warn about this misconfiguration

**Attack Complexity:**
- Extremely simple: just provide negative values in `CreateScheme()` call
- No special permissions or complex state manipulation required
- Affects the scheme manager's own scheme (self-inflicted unless combined with social engineering)

**Execution Practicality:**
- Fully executable within standard AElf contract semantics
- Every subsequent `RegisterForProfits` call demonstrates the bug
- Observable through unexpected distribution events and period increments

**Detection Constraints:**
- No error messages or warnings indicate the misconfiguration
- Behavior appears as frequent distributions rather than obvious failure
- Difficult to debug without understanding the inverted logic

**Likelihood Assessment (Medium):**
While requiring scheme manager action, the complete lack of input validation makes accidental misconfiguration realistic, especially with negative numbers being valid `int64` values in the protobuf schema.

### Recommendation

**Code-Level Mitigation:**

Add validation in `CreateScheme()` to reject non-positive threshold values:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Validate AutoDistributeThreshold values
    if (input.AutoDistributeThreshold != null && input.AutoDistributeThreshold.Any())
    {
        Assert(input.AutoDistributeThreshold.All(t => t.Value > 0), 
            "AutoDistributeThreshold values must be positive.");
    }
    
    // ... existing code ...
}
```

**Invariant Checks:**
- All `AutoDistributeThreshold` values must be strictly positive (> 0)
- Zero thresholds should be rejected (use empty map for "no auto-distribution")
- Consider adding maximum threshold validation to prevent overflow issues

**Test Cases:**
1. Test `CreateScheme()` with negative threshold values - should revert
2. Test `CreateScheme()` with zero threshold values - should revert  
3. Test `CreateScheme()` with very large positive values - should succeed
4. Test `RegisterForProfits()` behavior with various positive thresholds - verify correct triggering logic
5. Regression test ensuring distributions only occur when balance >= threshold

### Proof of Concept

**Required Initial State:**
- TokenHolder contract deployed and initialized
- User has sufficient tokens for scheme operations

**Exploitation Steps:**

1. **Create scheme with negative threshold:**
```
CreateScheme({
    Symbol: "ELF",
    MinimumLockMinutes: 0,
    AutoDistributeThreshold: {
        "ELF": -1000  // Negative threshold
    }
})
```
Expected: Should reject or warn
Actual: Accepts negative value without validation

2. **Contribute small amount of profits:**
```
ContributeProfits({
    SchemeManager: <scheme_manager_address>,
    Symbol: "ELF",
    Amount: 100  // Only 100 tokens
})
```

3. **First user registers for profits:**
```
RegisterForProfits({
    SchemeManager: <scheme_manager_address>,
    Amount: 10
})
```
Expected: No distribution (balance 100 < threshold 1000)
Actual: Distribution triggered because `100 < -1000` is FALSE, causing immediate distribution of all 100 tokens

4. **Verify unexpected behavior:**
    - Check scheme period: incremented to 2 (should still be 1)
    - Check virtual address balance: 0 (distributed prematurely)
    - Repeat RegisterForProfits with new contribution: triggers distribution every time

**Success Condition:**
The negative threshold causes auto-distribution to trigger on every `RegisterForProfits` call regardless of accumulated balance, confirming the inverted logic vulnerability.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L179-206)
```csharp
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }
```

**File:** protobuf/token_holder_contract.proto (L63-70)
```text
message CreateTokenHolderProfitSchemeInput {
    // The token symbol.
    string symbol = 1;
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 2;
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 3;
}
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L437-444)
```csharp
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
```
