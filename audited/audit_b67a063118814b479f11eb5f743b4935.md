### Title
Missing Authorization Contract Whitelist Validation in ChangeMethodFeeController

### Summary
The `CheckOrganizationExist()` function in TokenConverterContract accepts any contract address as a valid authorization contract without validation. An attacker who gains governance approval could change the MethodFeeController to a malicious contract that bypasses proper authorization, resulting in permanent loss of governance control over method fees.

### Finding Description

The vulnerability exists in the `CheckOrganizationExist()` function: [1](#0-0) 

The function accepts `authorityInfo.ContractAddress` and calls `ValidateOrganizationExist` on it without verifying the contract is a legitimate system authorization contract (Parliament, Association, or Referendum).

The exploit path:
1. Attacker deploys a malicious contract implementing `ValidateOrganizationExist` to always return `true`
2. Through governance (Parliament default org) or if already controlling the fee controller, a proposal is created to call `ChangeMethodFeeController`: [2](#0-1) 

3. The only authorization check verifies the sender is the current controller owner, but doesn't validate the NEW controller contract: [3](#0-2) 

4. The malicious contract's `ValidateOrganizationExist` returns `true`, passing validation
5. The controller is permanently changed to the malicious contract under attacker control

**Root Cause**: No validation that `authorityInfo.ContractAddress` is one of the three legitimate system authorization contracts. The codebase has mechanisms to verify system contracts: [4](#0-3) 

But this validation pattern is not applied to authorization contract addresses. This same vulnerability exists across ALL contracts implementing ACS1. [5](#0-4) [6](#0-5) 

### Impact Explanation

**Direct Impact:**
- Complete and permanent loss of governance control over TokenConverter method fees
- Attacker can set fees to zero (enabling spam/resource exhaustion) or extremely high values (denial of service)
- Recovery requires attacker cooperation since the malicious controller must approve any governance changes

**Scope:**
This vulnerability affects not just TokenConverter but ALL contracts using the same ACS1 pattern, including:
- MultiToken (critical: controls all token operations)
- Treasury, Profit, TokenHolder (economic system)
- Parliament, Association, Referendum (governance itself)
- Election, Consensus, CrossChain (core protocols)

**Severity Justification:**
HIGH severity because:
1. Enables permanent governance takeover of critical system parameters
2. Nearly impossible to recover without attacker cooperation
3. Affects multiple critical system contracts
4. No technical barriers prevent exploitation once governance approval obtained

### Likelihood Explanation

**Attack Complexity:** MODERATE
- Requires deploying a malicious contract (low cost)
- Requires governance approval through social engineering or mistake
- No technical exploit needed - just missing validation

**Feasibility Conditions:**
- Governance participants may not carefully verify contract addresses in proposals
- Addresses are long hex strings difficult to validate manually
- No UI/tooling warnings about non-standard authorization contracts
- Proposals might be approved if presented convincingly

**Attacker Capabilities:**
- Can deploy contracts (available to any user)
- Must convince governance to approve a proposal (social engineering)
- Does NOT require compromising validator keys or exploiting code bugs

**Probability Reasoning:**
While requiring governance interaction, this is realistic because:
1. No technical validation exists to catch mistakes
2. Governance due diligence may be insufficient for complex proposals
3. Once exploited, persistence makes it high impact
4. Defense-in-depth principle: contracts should validate inputs even from trusted sources

### Recommendation

**Immediate Fix:**
Add validation to `CheckOrganizationExist()` to ensure the contract address is one of the three legitimate system authorization contracts:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract is a legitimate authorization contract
    var systemContracts = Context.GetSystemContractNameToAddressMapping();
    var parliamentAddress = systemContracts.Values.FirstOrDefault(a => 
        a == Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName));
    var associationAddress = systemContracts.Values.FirstOrDefault(a => 
        a == Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName));
    var referendumAddress = systemContracts.Values.FirstOrDefault(a => 
        a == Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName));
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress ||
        authorityInfo.ContractAddress == associationAddress ||
        authorityInfo.ContractAddress == referendumAddress,
        "Invalid authorization contract address.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Apply System-Wide:**
The same fix must be applied to ALL contracts using this pattern: [7](#0-6) 

**Test Cases:**
1. Verify `ChangeMethodFeeController` succeeds with valid Parliament/Association/Referendum addresses
2. Verify it FAILS with arbitrary contract addresses
3. Verify it FAILS with EOA (externally owned account) addresses
4. Test across all affected contracts

### Proof of Concept

**Initial State:**
- TokenConverter deployed with MethodFeeController = Parliament default org
- Attacker deploys MaliciousAuthContract with:
  ```csharp
  public override BoolValue ValidateOrganizationExist(Address input) {
      return new BoolValue { Value = true }; // Always returns true
  }
  ```

**Exploit Steps:**

1. **Create Parliament Proposal** (requires 2/3 BP approval through social engineering):
   ```
   ProposalInput = {
       ToAddress: TokenConverterContractAddress,
       MethodName: "ChangeMethodFeeController",
       Params: new AuthorityInfo {
           ContractAddress: MaliciousAuthContractAddress,
           OwnerAddress: AttackerAddress
       }
   }
   ```

2. **Parliament Approves & Releases** (assuming social engineering success)

3. **Execute Proposal:**
   - Line 25 check passes: `Context.Sender == State.MethodFeeController.Value.OwnerAddress` (Parliament executes)
   - Line 26 calls `CheckOrganizationExist(input)` with malicious contract
   - Line 73 calls `MaliciousAuthContract.ValidateOrganizationExist(AttackerAddress)`
   - Returns `true` (no validation of contract legitimacy)
   - Line 29: `State.MethodFeeController.Value = input` (attacker now controls)

**Expected:** Validation should fail - malicious contract is not a system authorization contract

**Actual:** Validation passes - attacker gains permanent control over method fees

**Success Condition:** `GetMethodFeeController()` returns `{ContractAddress: MaliciousAuthContract, OwnerAddress: AttackerAddress}` and attacker can now call `SetMethodFee` without any authorization checks.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L196-203)
```csharp
    private void AssertSystemContractOrLockWhiteListAddress(string symbol)
    {
        var symbolState = State.LockWhiteLists[symbol];
        var isInWhiteList = symbolState != null && symbolState[Context.Sender];
        var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Values;
        var isSystemContractAddress = systemContractAddresses.Contains(Context.Sender);
        Assert(isInWhiteList || isSystemContractAddress, "No Permission.");
    }
```

**File:** src/AElf.Sdk.CSharp/SmartContractConstants.cs (L18-19)
```csharp
    public static readonly Hash ParliamentContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Parliament");
```

**File:** src/AElf.Sdk.CSharp/SmartContractConstants.cs (L32-36)
```csharp
    public static readonly Hash ReferendumContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Referendum");

    public static readonly Hash AssociationContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Association");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```
