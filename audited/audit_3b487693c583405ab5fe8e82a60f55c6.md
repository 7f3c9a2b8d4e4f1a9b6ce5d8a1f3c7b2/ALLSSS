### Title
Precision Loss in Individual Beneficiary Profit Claims Locks Tokens Permanently

### Summary
The `SafeCalculateProfits()` function performs decimal conversion with truncation when calculating individual beneficiary profit shares. When multiple beneficiaries claim from the same period, the sum of their truncated claims can be less than the total distributed amount, permanently locking the remainder in the period's virtual address with no recovery mechanism.

### Finding Description

The root cause is in the `SafeCalculateProfits()` function which converts long integers to decimal, performs division, and converts back to long with truncation: [1](#0-0) 

This function is used in two contexts with different consequences:

1. **Sub-scheme distribution** (safe): When distributing to sub-schemes, a `remainAmount` is tracked and any rounding remainder is transferred to individual beneficiaries: [2](#0-1) 

2. **Individual beneficiary claims** (vulnerable): When beneficiaries claim their profits via `ProfitAllPeriods()`, each claim is calculated independently without remainder tracking: [3](#0-2) 

The critical issue is that each period has its own unique virtual address generated by hashing the scheme ID and period number: [4](#0-3) 

When `DistributeProfits` is called, it creates a `DistributedProfitsInfo` for that period's virtual address containing the total amount and total shares: [5](#0-4) 

Each beneficiary then independently calculates their share using the truncating `SafeCalculateProfits()`. The funds are transferred from the period's virtual address to the beneficiary: [6](#0-5) 

**Why existing protections fail:**
- No remainder tracking exists for individual beneficiary claims
- Each claim is independent - the contract doesn't verify that the sum of all claims equals the distributed amount
- Once a period is complete, its virtual address balance cannot be accessed through any contract function
- There is no admin rescue function to recover locked tokens

### Impact Explanation

**Direct Fund Impact:**
Tokens are permanently locked in period virtual addresses. For example:
- 3 beneficiaries with equal shares (1 each, total 3)
- Period distributes 100 tokens
- Each beneficiary receives: `(long)(100 * 1 / 3) = (long)(33.333...) = 33` tokens
- Total claimed: 99 tokens
- **Locked forever: 1 token**

**Scale and Accumulation:**
- Occurs in every distribution where `(totalAmount * shares / totalShares)` produces a non-zero remainder after truncation
- Common scenarios: any odd number of equal beneficiaries, any shares that don't evenly divide the amount
- Across hundreds of schemes over thousands of periods, this could lock millions of tokens
- The locked tokens are economically irrecoverable as virtual addresses have no owner

**Who is affected:**
- All beneficiaries lose a proportional amount (the locked remainder)
- The protocol loses economic efficiency as locked tokens are removed from circulation
- Token holders indirectly affected by reduced token utility

### Likelihood Explanation

**Probability: HIGH**
- Happens automatically in normal profit distribution operations
- No attacker action required - natural consequence of the rounding logic
- Mathematical certainty: occurs whenever shares don't evenly divide amounts

**Entry Point:**
Standard profit claiming flow accessible to all beneficiaries via `ClaimProfits()`: [7](#0-6) 

**Realistic Conditions:**
- Any scheme with 3+ equal beneficiaries and amounts not divisible by the number of beneficiaries
- Any scheme where shares are not perfect divisors of distributed amounts
- No special permissions or attack setup required

**Frequency:**
- Occurs on every profit distribution period for affected schemes
- Given typical profit distribution patterns, this likely affects most schemes

### Recommendation

**Immediate Fix:**
Implement remainder tracking for individual beneficiary claims similar to sub-scheme distribution. Modify `ProfitAllPeriods()` to:

1. Track the total amount claimed by all beneficiaries in a period
2. Assign the last beneficiary to claim the remaining balance instead of their calculated share, OR
3. Implement a "dust collection" mechanism where remainders below a threshold are sent to the scheme manager or burned

**Code-level Mitigation:**
```
// In ProfitAllPeriods, after calculating amount for each beneficiary:
// Track total claimed for this period
// For the last beneficiary claiming from a period:
if (isLastBeneficiary) {
    var actualBalance = State.TokenContract.GetBalance.Call(new GetBalanceInput {
        Owner = distributedPeriodProfitsVirtualAddress,
        Symbol = symbol
    }).Balance;
    amount = actualBalance; // Give remainder to last claimer
}
```

**Invariant Check:**
Add assertion that after all beneficiaries claim, the period's virtual address balance is zero or within acceptable dust threshold.

**Test Cases:**
1. Test with 3 equal beneficiaries and 100 tokens (should distribute 33, 33, 34)
2. Test with prime number shares and non-divisible amounts
3. Verify no tokens remain locked after all claims complete

### Proof of Concept

**Initial State:**
- Create a profit scheme with 3 beneficiaries: Alice, Bob, and Charlie
- Each beneficiary has 1 share (total shares = 3)
- No sub-schemes

**Transaction Sequence:**

1. **Manager calls DistributeProfits:**
   - Scheme ID: [scheme_id]
   - Period: 1
   - Amount: 100 ELF tokens
   - Result: 100 tokens transferred to period 1's virtual address
   - `DistributedProfitsInfo.AmountsMap["ELF"] = 100`
   - `DistributedProfitsInfo.TotalShares = 3`

2. **Alice calls ClaimProfits:**
   - Calculates: `SafeCalculateProfits(1, 100, 3) = (long)(33.333...) = 33`
   - Receives: 33 ELF tokens
   - Virtual address balance: 67 ELF

3. **Bob calls ClaimProfits:**
   - Calculates: `SafeCalculateProfits(1, 100, 3) = (long)(33.333...) = 33`
   - Receives: 33 ELF tokens
   - Virtual address balance: 34 ELF

4. **Charlie calls ClaimProfits:**
   - Calculates: `SafeCalculateProfits(1, 100, 3) = (long)(33.333...) = 33`
   - Receives: 33 ELF tokens
   - Virtual address balance: **1 ELF (permanently locked)**

**Expected Result:** All 100 tokens distributed (33 + 33 + 34)

**Actual Result:** Only 99 tokens distributed (33 + 33 + 33), with 1 token permanently locked in the period 1 virtual address

**Success Condition:** Query the balance of period 1's virtual address after all claims - it will show 1 ELF token that can never be recovered.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-583)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L606-649)
```csharp
    private long DistributeProfitsForSubSchemes(string symbol, long totalAmount, Scheme scheme, long totalShares)
    {
        Context.LogDebug(() => $"Sub schemes count: {scheme.SubSchemes.Count}");
        var remainAmount = totalAmount;
        foreach (var subSchemeShares in scheme.SubSchemes)
        {
            Context.LogDebug(() => $"Releasing {subSchemeShares.SchemeId}");

            // General ledger of this sub profit scheme.
            var subItemVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeShares.SchemeId);

            if (State.TokenContract.Value == null)
                State.TokenContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

            var distributeAmount = SafeCalculateProfits(subSchemeShares.Shares, totalAmount, totalShares);
            if (distributeAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = subItemVirtualAddress,
                        Amount = distributeAmount,
                        Symbol = symbol
                    }.ToByteString());

            remainAmount = remainAmount.Sub(distributeAmount);

            // Update current_period of detail of sub profit scheme.
            var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
            foreach (var detail in subItemDetail.Details) detail.LastProfitPeriod = scheme.CurrentPeriod;

            State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress] = subItemDetail;

            // Update sub scheme.
            var subScheme = State.SchemeInfos[subSchemeShares.SchemeId];
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
            }
        }

        return remainAmount;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L750-785)
```csharp
    public override Empty ClaimProfits(ClaimProfitsInput input)
    {
        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null) throw new AssertionException("Scheme not found.");
        var beneficiary = input.Beneficiary ?? Context.Sender;
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][beneficiary];
        if (profitDetails == null) throw new AssertionException("Profit details not found.");

        Context.LogDebug(
            () => $"{Context.Sender} is trying to profit from {input.SchemeId.ToHex()} for {beneficiary}.");

        // LastProfitPeriod is set as 0 at the very beginning, and be updated as current period every time when it is claimed.
        // What's more, LastProfitPeriod can also be +1 more than endPeroid, for it always points to the next period to claim.
        // So if LastProfitPeriod is 0, that means this profitDetail hasn't be claimed before, so just check whether it is a valid one;
        // And if a LastProfitPeriod is larger than EndPeriod, it should not be claimed, and should be removed later.
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
        var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();

        Context.LogDebug(() =>
            $"Profitable details: {profitableDetails.Aggregate("\n", (profit1, profit2) => profit1.ToString() + "\n" + profit2)}");

        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
        // Only can get profit from last profit period to actual last period (profit.CurrentPeriod - 1),
        // because current period not released yet.
        for (var i = 0; i < profitableDetailCount; i++)
        {
            var profitDetail = profitableDetails[i];
            if (profitDetail.LastProfitPeriod == 0)
                // This detail never performed profit before.
                profitDetail.LastProfitPeriod = profitDetail.StartPeriod;

            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-912)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L51-60)
```csharp
    private Address GetDistributedPeriodProfitsVirtualAddress(Hash schemeId, long period)
    {
        return Context.ConvertVirtualAddressToContractAddress(
            GeneratePeriodVirtualAddressFromHash(schemeId, period));
    }

    private Hash GeneratePeriodVirtualAddressFromHash(Hash schemeId, long period)
    {
        return HashHelper.XorAndCompute(schemeId, HashHelper.ComputeFrom(period));
    }
```
