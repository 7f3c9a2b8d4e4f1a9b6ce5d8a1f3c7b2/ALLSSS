### Title
Consensus Denial of Service via Malicious FinalOrderOfNextRound Values Due to Incorrect Distinct Validation

### Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` function contains a critical bug where it calls `.Distinct()` on `MinerInRound` objects instead of their `FinalOrderOfNextRound` values, failing to validate uniqueness of mining orders. A malicious miner can exploit this by crafting a `NextRoundInput` with duplicate `FinalOrderOfNextRound` values that pass validation but cause permanent consensus halt when the subsequent round attempts to use these corrupted order values.

### Finding Description

**Root Cause Location:** [1](#0-0) 

The validation incorrectly calls `.Distinct()` on a collection of `MinerInRound` objects rather than on their `FinalOrderOfNextRound` values. Since `MinerInRound` is a protobuf-generated class where each miner is a distinct object instance, the distinct count will always equal the number of miner objects regardless of whether their `FinalOrderOfNextRound` values are duplicates.

**Expected vs Actual Behavior:**

The validation should check: `providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0).Select(m => m.FinalOrderOfNextRound).Distinct().Count()` to validate uniqueness of the order VALUES, not the object instances.

**Exploitation Path:**

1. During round N+1 transition, a malicious miner crafts a `NextRoundInput` where:
   - `Order` and `ExpectedMiningTime` values are correctly set for round N+1 mining
   - `FinalOrderOfNextRound` values are set to malicious duplicates (e.g., all set to 1) for round N+2
   - Fake `OutValue` hashes are included to match the miner count

2. The validation process runs: [2](#0-1) 

The buggy `NextRoundMiningOrderValidationProvider` passes because it only validates that the count of distinct OBJECTS equals the count of miners with OutValue, not that FinalOrderOfNextRound VALUES are unique. [3](#0-2) 

The `CheckRoundTimeSlots()` validation passes because it validates time slots for round N+1's `Order` field (which is correct), not the malicious `FinalOrderOfNextRound` values for round N+2.

3. The malicious round data is stored: [4](#0-3) 

4. When generating round N+2, the system uses the corrupted `FinalOrderOfNextRound` values: [5](#0-4) 

All miners receive the same `Order` value (e.g., Order=1), resulting in identical `ExpectedMiningTime` values calculated as `currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(1))`.

5. Any attempt to propose round N+2 fails validation: [6](#0-5) 

The `baseMiningInterval` calculation results in 0 (since miners at indices 0 and 1 have identical timestamps), causing validation failure: "Mining interval must greater than 0."

**Why Existing Protections Fail:** [7](#0-6) 

The `RoundTerminateValidationProvider` only validates that `InValue` is null, not `OutValue` or `FinalOrderOfNextRound`, allowing the malicious values to pass.

### Impact Explanation

**Concrete Impact:**
- **Consensus Halt**: Permanent denial of service of the entire blockchain consensus mechanism
- **Block Production Cessation**: No new blocks can be produced after round N+1 completes
- **Network Paralysis**: All validators unable to progress to round N+2 due to validation failure
- **Irreversible Damage**: No automatic recovery mechanism exists; manual intervention required

**Severity: HIGH**
- Single malicious validator can halt the entire network
- Affects all network participants and all on-chain operations
- Complete operational shutdown with no built-in recovery
- Violates the critical invariant: "Correct round transitions and time-slot validation, miner schedule integrity"

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a current validator with the ability to propose `NextRound`
- Requires ability to craft custom `NextRoundInput` data (standard capability)
- No special privileges beyond being in the validator set required

**Attack Complexity: Low**
- Single transaction to `NextRound` with malicious data
- No timing constraints or race conditions
- No need for collusion with other validators
- Straightforward to construct the malicious payload

**Feasibility Conditions:**
- Attacker is an active validator in current round (realistic)
- Attacker's turn to propose round transition (occurs naturally in rotation)
- No economic cost beyond transaction fees

**Detection Constraints:**
- Malicious `FinalOrderOfNextRound` values appear valid during round N+1
- Attack only manifests when round N+2 generation is attempted
- Difficult to identify malicious actor after the fact

**Probability: High** - The attack is practical, low-cost, and requires only standard validator capabilities.

### Recommendation

**Immediate Fix:**

Modify the validation in `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` to check uniqueness of `FinalOrderOfNextRound` VALUES:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Add this line
    .Distinct()
    .Count();
```

**Additional Validations to Add:**

1. Validate that `FinalOrderOfNextRound` values are within valid range [1, minersCount]
2. Validate that `OutValue` should be null in newly generated rounds (add check in `RoundTerminateValidationProvider`)
3. Add validation to ensure `Order` values in `ProvidedRound` match `FinalOrderOfNextRound` from `BaseRound`

**Test Cases:**

1. Test that `NextRoundInput` with duplicate `FinalOrderOfNextRound` values is rejected
2. Test that `NextRoundInput` with out-of-range `FinalOrderOfNextRound` values is rejected
3. Test that only miners who actually mined can have non-zero `FinalOrderOfNextRound`
4. Test regression: ensure legitimate round transitions still work correctly

### Proof of Concept

**Initial State:**
- Blockchain at round N with 5 validators: A, B, C, D, E
- All validators have valid `FinalOrderOfNextRound` values set during round N

**Attack Sequence:**

1. **Malicious Validator A prepares NextRoundInput for round N+1:**
   - Correctly sets `Order` values based on round N's `FinalOrderOfNextRound` 
   - Sets malicious `FinalOrderOfNextRound` for round N+2:
     - Validator A: FinalOrderOfNextRound = 1
     - Validator B: FinalOrderOfNextRound = 1 (duplicate)
     - Validator C: FinalOrderOfNextRound = 1 (duplicate)
     - Validator D: FinalOrderOfNextRound = 1 (duplicate)
     - Validator E: FinalOrderOfNextRound = 1 (duplicate)
   - Sets fake `OutValue` hashes for all 5 validators

2. **Validator A calls `NextRound(maliciousInput)`:**
   - `NextRoundMiningOrderValidationProvider` checks: 5 distinct objects with FinalOrderOfNextRound > 0, 5 miners with OutValue != null → 5 == 5 ✓ PASSES (incorrect)
   - `CheckRoundTimeSlots` validates round N+1 time slots (correctly spaced) → ✓ PASSES
   - `RoundTerminateValidationProvider` checks InValue is null → ✓ PASSES
   - Malicious round N+1 data is stored

3. **Round N+1 completes normally** (Order values for N+1 are correct)

4. **Any validator attempts to call `NextRound` for round N+2:**
   - Calls `GenerateNextRoundInformation` using stored round N+1 data
   - All 5 validators assigned Order = 1 (from corrupted FinalOrderOfNextRound)
   - All 5 validators have ExpectedMiningTime = T + (miningInterval * 1) = T + 4000ms
   - Creates `NextRoundInput` and calls `NextRound`

5. **Validation fails:**
   - `CheckRoundTimeSlots` executes
   - `baseMiningInterval = miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime = 0`
   - Validation returns: "Mining interval must greater than 0."
   - Transaction REVERTS

**Expected Result:** Round N+2 successfully created with proper time slot spacing

**Actual Result:** All attempts to create round N+2 fail validation, consensus permanently halted

**Success Condition:** Blockchain stuck at end of round N+1, unable to produce new blocks

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-158)
```csharp
        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-47)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L32-34)
```csharp
        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```
