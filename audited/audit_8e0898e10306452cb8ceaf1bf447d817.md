### Title
Miner List Manipulation in Round Transitions Enables LIB Height Manipulation

### Summary
The `GetSortedImpliedIrreversibleBlockHeights()` function receives its `specificPublicKeys` parameter from `GetMinedMiners()`, which reads from the current round's `RealTimeMinersInformation` dictionary. [1](#0-0)  This dictionary can be manipulated by malicious miners during `NextRound` or `NextTerm` operations because validation providers fail to verify that the provided round's miner list matches the expected miners, allowing attackers to inject arbitrary public keys or exclude honest miners, thereby manipulating the Last Irreversible Block (LIB) height calculation.

### Finding Description

**Root Cause:**
When miners submit `NextRoundInput` or `NextTermInput`, the input directly populates the `RealTimeMinersInformation` dictionary without validation that the miner public keys match the expected list. [2](#0-1) 

**Attack Path:**
1. Malicious miner calls public `NextRound()` method [3](#0-2) 
2. Input is processed via `ProcessConsensusInformation()` and `ProcessNextRound()` [4](#0-3) 
3. The `PreCheck()` only validates the sender is in the current/previous miner list, not the content of the provided round [5](#0-4) 
4. Validation providers check round number, term number, and internal consistency but NOT whether the miner public keys match expected miners:
   - `MiningPermissionValidationProvider` only checks sender is in base round [6](#0-5) 
   - `NextRoundMiningOrderValidationProvider` only checks internal consistency [7](#0-6) 
   - `RoundTerminateValidationProvider` only checks round/term numbers [8](#0-7) 
5. Malicious round with manipulated `RealTimeMinersInformation` is stored [9](#0-8) 
6. During subsequent block production, LIB calculation retrieves the corrupted round [10](#0-9) 
7. `GetMinedMiners()` returns miners from the manipulated list [11](#0-10) 
8. These manipulated public keys are passed to `GetSortedImpliedIrreversibleBlockHeights()` [12](#0-11) 
9. LIB calculation uses filtered heights from manipulated miner list [13](#0-12) 

**Why Protections Fail:**
For `NextRound` within a term, the miner list should remain constant (same miners as current round), but there's no validation enforcing this. [14](#0-13)  For `NextTerm`, the miner list should match `GetVictories()` from the Election Contract, but the provided round is accepted without comparison. [15](#0-14) 

### Impact Explanation

**Direct Consensus Integrity Compromise:**
- Attacker can exclude honest miners with high implied irreversible block heights, preventing LIB from advancing correctly
- Attacker can include colluding or fake miners with low implied heights to artificially lower the LIB
- Manipulated LIB directly impacts chain finality guarantees

**Cross-Chain Security Breach:**
Cross-chain verification relies on LIB height for security. [16](#0-15)  A manipulated LIB can enable:
- Acceptance of invalid cross-chain transfers
- Double-spend attacks across chains
- Compromise of side-chain security

**Mining Rewards Misallocation:**
The miner list determines mining rewards distribution. [17](#0-16)  Fake miners in the list can steal rewards from legitimate miners.

**Chain Reorganization Risk:**
Incorrect LIB allows deeper reorganizations than intended, enabling sophisticated double-spend attacks and undermining protocol security guarantees.

**Severity:** CRITICAL - Core consensus mechanism integrity is violated, affecting chain finality, cross-chain security, and economic incentives.

### Likelihood Explanation

**Attacker Capabilities:**
Any current miner can execute this attack. The only prerequisite is passing `PreCheck()`, which merely requires being in the current or previous round's miner list - a standard requirement for miners.

**Attack Complexity:**
Low to Medium. Attacker must:
1. Be an active miner (feasible for adversarial miners)
2. Construct `NextRoundInput`/`NextTermInput` with modified `RealTimeMinersInformation`
3. Submit via public `NextRound()`/`NextTerm()` methods
4. No cryptographic bypass or complex state manipulation required

**Feasibility Conditions:**
- Attack works immediately once attacker becomes a miner
- No special timing or coordination required
- Works on both MainChain and SideChains
- No economic barrier beyond normal miner participation

**Detection Constraints:**
The attack is difficult to detect in real-time because:
- Validation passes successfully
- Round data appears structurally valid
- Only detailed comparison of expected vs actual miner lists would reveal manipulation

**Probability:** HIGH - Any compromised or adversarial miner can execute this attack with minimal effort and high success rate.

### Recommendation

**Immediate Mitigation - Add Miner List Validation:**

For `NextRound` behavior in `RoundTerminateValidationProvider`:
```
Add validation after line 29 to verify that providedRound.RealTimeMinersInformation.Keys 
exactly matches validationContext.BaseRound.RealTimeMinersInformation.Keys
``` [8](#0-7) 

For `NextTerm` behavior:
```
Add validation to verify that providedRound.RealTimeMinersInformation.Keys 
matches GetVictories() from Election Contract (for MainChain) 
or matches current round miners (for SideChain when election unavailable)
``` [18](#0-17) 

**Invariant to Enforce:**
- Within a term: `NextRound.RealTimeMinersInformation.Keys == CurrentRound.RealTimeMinersInformation.Keys`
- Term change: `NextTerm.RealTimeMinersInformation.Keys == GetVictories().Pubkeys` (MainChain) or fallback to current miners (SideChain)

**Test Cases:**
1. Attempt `NextRound` with extra miner - should fail validation
2. Attempt `NextRound` with missing miner - should fail validation
3. Attempt `NextRound` with reordered but same miners - should succeed
4. Attempt `NextTerm` with miners not matching Election Contract - should fail validation

### Proof of Concept

**Initial State:**
- Current round has legitimate miners: [A, B, C, D] with public keys
- Miner A is compromised/adversarial
- Miner B has high ImpliedIrreversibleBlockHeight contributing to LIB

**Attack Steps:**
1. Miner A monitors current round state via `GetCurrentRoundInformation()` [19](#0-18) 
2. Miner A constructs malicious `NextRoundInput`:
   - Sets correct RoundNumber = CurrentRound.RoundNumber + 1
   - Creates `RealTimeMinersInformation` = [A, C, D, X] where X is attacker-controlled and B (honest high-LIB miner) is excluded
   - Sets appropriate mining orders and timestamps
3. Miner A calls `NextRound(maliciousInput)` [3](#0-2) 
4. Validation passes because:
   - Miner A is in current round ✓
   - Round number increments correctly ✓
   - No validation checks if [A, C, D, X] == [A, B, C, D]
5. Malicious round is stored in `State.Rounds[newRoundNumber]` [20](#0-19) 
6. Next block's LIB calculation retrieves this corrupted round
7. `GetMinedMiners()` returns [A, C, D, X] instead of [A, B, C, D]
8. `GetSortedImpliedIrreversibleBlockHeights([A, C, D, X])` excludes honest miner B's high LIB contribution
9. Calculated LIB is artificially lowered or stalled

**Expected Result:** Validation should reject the malicious round with mismatched miner list

**Actual Result:** Malicious round is accepted and stored, LIB calculation is compromised

**Success Condition:** Transaction succeeds, round with [A, C, D, X] is stored, subsequent LIB calculations exclude miner B's contributions

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-112)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L240-240)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L272-281)
```csharp
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-56)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L21-24)
```csharp
    public override Round GetCurrentRoundInformation(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var currentRound) ? currentRound : new Round();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-280)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```
