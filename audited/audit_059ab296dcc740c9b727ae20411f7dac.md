### Title
Broken ImpliedIrreversibleBlockHeight Validation Allows Consensus Finality Manipulation

### Summary
The `LibInformationValidationProvider` validation logic is fundamentally broken because `RecoverFromUpdateValue` executes before validation, making the comparison check ineffective. Additionally, the `!= 0` check allows miners to submit `ImpliedIrreversibleBlockHeight = 0` even after chain progression, bypassing validation entirely and potentially disrupting Last Irreversible Block (LIB) calculation.

### Finding Description

The validation flow in `ValidateBeforeExecution` calls `RecoverFromUpdateValue` before passing the round data to validators: [1](#0-0) 

The `RecoverFromUpdateValue` method copies the `ImpliedIrreversibleBlockHeight` from the provided round to the base round: [2](#0-1) 

After this recovery, both `baseRound[pubkey].ImpliedIrreversibleBlockHeight` and `providedRound[pubkey].ImpliedIrreversibleBlockHeight` contain the same value. The validation then compares these equal values: [3](#0-2) 

Since the values are equal after recovery, the condition `baseRound > providedRound` on lines 25-26 can **never** be true, rendering this validator completely non-functional.

Additionally, line 24 contains a `!= 0` check that skips validation entirely when `ImpliedIrreversibleBlockHeight = 0`. This allows a miner to submit a regressed value of 0 after the chain has progressed (e.g., from height 1000 to 0), bypassing all validation.

When a miner submits `ImpliedIrreversibleBlockHeight = 0`, the value is written directly to state: [4](#0-3) 

This regressed value then affects LIB calculation, as miners with `ImpliedIrreversibleBlockHeight = 0` are filtered out: [5](#0-4) 

### Impact Explanation

**Consensus Finality Disruption**: A malicious miner can submit `ImpliedIrreversibleBlockHeight = 0` to exclude themselves from LIB calculations. If multiple miners coordinate this attack, the number of valid participants could fall below the consensus threshold: [6](#0-5) 

When the count falls below `MinersCountOfConsent` (2/3 + 1), the LIB calculation returns 0, effectively stalling chain finality. This impacts:
- **Cross-chain operations**: Cross-chain indexing depends on LIB heights for security
- **Transaction finality**: Users cannot rely on transaction irreversibility
- **Network integrity**: Consensus mechanism degradation

The broader issue is that the validation is completely non-functional, meaning **no regression checks are being performed** on this critical consensus parameter.

### Likelihood Explanation

**Attack Prerequisites**:
- Requires control of a miner node (trusted role in DPoS)
- Miner must modify node software to submit `ImpliedIrreversibleBlockHeight = 0`
- Standard block production code always sets this to current height: [7](#0-6) 

**Attack Complexity**: Low - once a miner node is compromised, submitting a zero value is trivial.

**Detection**: The attack would be immediately visible in block data and LIB progression metrics.

**Economic Rationality**: Limited - a miner would be disrupting their own network, though this could be part of a larger attack or governance dispute.

**Probability**: Medium-Low - Requires malicious miner but attack is simple to execute.

### Recommendation

**Fix 1 - Remove Early Recovery**: Move `RecoverFromUpdateValue` to AFTER validation, or validate against the original state before recovery:

```csharp
// In ValidateBeforeExecution
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
{
    // Validate BEFORE recovery
    validationProviders.Add(new LibInformationValidationProvider());
    var service = new HeaderInformationValidationService(validationProviders);
    var validationResult = service.ValidateInformation(validationContext);
    if (!validationResult.Success) return validationResult;
    
    // Only recover after successful validation
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
}
```

**Fix 2 - Enforce Monotonicity**: Change the validation to properly check for regression:

```csharp
// In LibInformationValidationProvider.ValidateHeaderInformation
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
{
    var baseHeight = baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
    var providedHeight = providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
    
    // Allow 0 only during initialization (when base is also 0)
    if (baseHeight > 0 && providedHeight < baseHeight)
    {
        validationResult.Message = $"ImpliedIrreversibleBlockHeight regression: {providedHeight} < {baseHeight}";
        return validationResult;
    }
}
```

**Fix 3 - Add Invariant Check**: In `ProcessUpdateValue`, add defensive validation:

```csharp
var currentHeight = minerInRound.ImpliedIrreversibleBlockHeight;
Assert(updateValueInput.ImpliedIrreversibleBlockHeight >= currentHeight || currentHeight == 0,
       "ImpliedIrreversibleBlockHeight cannot decrease");
```

### Proof of Concept

**Initial State**:
- Chain at height 1000
- Miner A has `ImpliedIrreversibleBlockHeight = 990` in state
- System expects monotonically increasing heights

**Attack Steps**:
1. Miner A modifies their node to produce a block with `UpdateValueInput.ImpliedIrreversibleBlockHeight = 0`
2. Block enters `ValidateBeforeExecution`:
   - Line 19: `baseRound` fetched from state has `ImpliedIrreversibleBlockHeight = 990`
   - Line 47: `RecoverFromUpdateValue` copies 0 to `baseRound`, now `baseRound[A].ImpliedIrreversibleBlockHeight = 0`
   - Validation context created with modified `baseRound`
3. In `LibInformationValidationProvider.ValidateHeaderInformation`:
   - Line 24: `providedRound[A].ImpliedIrreversibleBlockHeight != 0` evaluates to `false` (0 != 0 is false)
   - Entire validation block skipped
   - Returns `Success = true`
4. `ProcessUpdateValue` line 248 writes 0 to state
5. In next round's LIB calculation, Miner A excluded (line 15 filters out `ImpliedIrreversibleBlockHeight <= 0`)

**Expected Result**: Validation should reject the regression from 990 to 0

**Actual Result**: Validation passes, state updated with regressed value, miner excluded from consensus finality

**Success Condition**: Block is accepted with `ImpliedIrreversibleBlockHeight = 0` despite previous higher value in state, demonstrated by state query showing the regressed value.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-20)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```
