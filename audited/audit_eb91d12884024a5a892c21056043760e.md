### Title
NFT Type Namespace Collision Allows Conflicting Bidirectional Mappings

### Summary
The `AddNFTType()` function fails to validate that a new full name doesn't collide with existing short names, allowing creation of conflicting bidirectional mappings. This breaks the NFT type system's invariant where short names and full names must maintain distinct namespaces, causing incorrect symbol generation and type categorization for NFT protocols.

### Finding Description

The vulnerability exists in the `AddNFTType()` function's validation logic. [1](#0-0) 

The NFT contract maintains two bidirectional state mappings:
- `NFTTypeFullNameMap`: maps short names (2-char) → full names
- `NFTTypeShortNameMap`: maps full names → short names (2-char) [2](#0-1) 

During initialization, default types are registered (e.g., "AR" ↔ "Art", "MU" ↔ "Music"). [3](#0-2) 

**Root Cause:**
Line 138 only checks if `fullName` already exists as a key in `NFTTypeShortNameMap`, but fails to check if `fullName` already exists as a value in `NFTTypeFullNameMap` (i.e., is already used as a short name). This allows a scenario where:
- Initial state: `NFTTypeFullNameMap["AR"] = "Art"` and `NFTTypeShortNameMap["Art"] = "AR"`
- Parliament approves: `AddNFTType(shortName="MX", fullName="AR")`
- Line 137 passes: `NFTTypeFullNameMap["MX"]` is null ✓
- Line 138 passes: `NFTTypeShortNameMap["AR"]` is null ✓ (because "AR" is a key in the other map, not this one)
- Result: Creates `NFTTypeFullNameMap["MX"] = "AR"` and `NFTTypeShortNameMap["AR"] = "MX"`

Now "AR" serves dual purposes: both as a short name (for "Art") AND as a full name (for the new type with short name "MX").

**Why Existing Protections Fail:**
The validation assumes that checking `NFTTypeShortNameMap[fullName] == null` is sufficient to prevent duplicates, but it doesn't account for namespace collision where the full name space and short name space must remain distinct.

### Impact Explanation

**Direct Operational Impact - NFT Type System Corruption:**

1. **Incorrect Symbol Generation:** When users create NFT protocols with `nftType="AR"` (now a valid input), the `GetSymbol()` function lookups `NFTTypeShortNameMap["AR"]` and returns "MX", creating symbols like "MX123456" instead of expected "AR" prefix. [4](#0-3) 

2. **Type Categorization Confusion:** NFT protocols get stored with mismatched type-to-symbol relationships:
   - Protocol created with `nftType="AR"` has symbol prefix "MX"
   - Protocol created with `nftType="Art"` has symbol prefix "AR"
   - This breaks the expected 1:1 correspondence between type names and symbol prefixes

3. **Cross-Chain Operation Inconsistency:** When `CrossChainCreate()` processes symbols starting with "MX", it retrieves `NFTTypeFullNameMap["MX"] = "AR"` and treats "AR" as the full name, but "AR" was originally intended to be a short name. [5](#0-4) 

**Affected Parties:**
- NFT protocol creators who expect consistent type-to-symbol mappings
- Users and applications that categorize NFTs based on symbol prefixes
- Cross-chain NFT operations relying on accurate type mappings
- NFT marketplaces and explorers that filter by type

**Severity Justification - Medium:**
While this doesn't directly cause fund loss, it corrupts a critical system invariant, making NFT type categorization unreliable and potentially causing operational failures in dependent systems.

### Likelihood Explanation

**Preconditions:**
- Requires parliament default address authorization [6](#0-5) 
- Governance must approve an `AddNFTType` proposal with a collision

**Attack Complexity - Low:**
This is not a "trusted role compromise" scenario but a **validation gap** that can manifest through:
1. **Accidental Misconfiguration:** Parliament members may approve a proposal like `AddNFTType(shortName="MX", fullName="AR")` without realizing "AR" is already used as a short name
2. **Lack of Awareness:** The existing validation check at line 138 gives false confidence that all collisions are prevented
3. **Legitimate Governance Error:** No malicious intent needed - simple oversight in proposal review

**Feasibility - High:**
- Entry point is a real public method accessible via governance
- No complex state manipulation required
- Executable under normal AElf contract semantics
- The validation logic flaw makes this trivially exploitable once parliament approves

**Detection Constraints:**
The contract provides no warnings or additional checks to help governance detect this collision before approval.

### Recommendation

**Code-Level Mitigation:**

Add an additional validation check in `AddNFTType()` to ensure the new `fullName` doesn't collide with any existing short names:

```csharp
public override Empty AddNFTType(AddNFTTypeInput input)
{
    AssertSenderIsParliamentDefaultAddress();
    InitialNFTTypeNameMap();
    var fullName = input.FullName;
    Assert(input.ShortName.Length == 2, "Incorrect short name.");
    Assert(State.NFTTypeFullNameMap[input.ShortName] == null, $"Short name {input.ShortName} already exists.");
    Assert(State.NFTTypeShortNameMap[fullName] == null, $"Full name {fullName} already exists.");
    
    // ADD THIS CHECK:
    Assert(State.NFTTypeFullNameMap[fullName] == null, 
           $"Full name {fullName} conflicts with an existing short name.");
    
    State.NFTTypeFullNameMap[input.ShortName] = fullName;
    State.NFTTypeShortNameMap[fullName] = input.ShortName;
    // ... rest of function
}
```

**Invariant to Enforce:**
For all valid NFT types, the following must hold:
- `shortName ≠ fullName` (names must be from distinct namespaces)
- If `NFTTypeFullNameMap[S] = F`, then `NFTTypeFullNameMap[F]` must be null
- If `NFTTypeShortNameMap[F] = S`, then `NFTTypeShortNameMap[S]` must be null

**Test Cases:**
1. Test adding a type where `fullName` equals an existing `shortName` (should fail)
2. Test adding a type where `shortName` equals an existing `fullName` (should fail)
3. Test adding valid distinct names (should succeed)
4. Test bidirectional lookup consistency after each addition

### Proof of Concept

**Initial State (after contract initialization):**
```
NFTTypeFullNameMap["AR"] = "Art"
NFTTypeShortNameMap["Art"] = "AR"
```

**Step 1:** Parliament approves and executes:
```
AddNFTType(shortName="MX", fullName="AR")
```

**Step 2:** Validation checks execute:
- Line 137: `Assert(NFTTypeFullNameMap["MX"] == null)` → **PASS** (MX not used)
- Line 138: `Assert(NFTTypeShortNameMap["AR"] == null)` → **PASS** (AR not a key in this map)

**Step 3:** State updates create collision:
```
NFTTypeFullNameMap["MX"] = "AR"  // AR now used as fullName
NFTTypeShortNameMap["AR"] = "MX" // AR treated as fullName
```

**Resulting Corrupted State:**
```
NFTTypeFullNameMap["AR"] = "Art"  // AR as shortName
NFTTypeFullNameMap["MX"] = "AR"   // AR as fullName - COLLISION!
NFTTypeShortNameMap["Art"] = "AR"
NFTTypeShortNameMap["AR"] = "MX"
```

**Step 4:** User creates NFT protocol:
```
Create(nftType="AR", protocolName="Test", ...)
```

**Expected Result:** Should fail (AR is a short name, not a full name) OR create symbol "AR123456"

**Actual Result:** 
- `GetSymbol("AR")` looks up `NFTTypeShortNameMap["AR"]` → returns "MX"
- Creates symbol "MX123456" with `nft_type="AR"` stored
- **Type-to-symbol mapping inconsistency confirmed** ✓

**Success Condition:** The bidirectional mapping invariant is violated, and NFT protocols can be created with mismatched type names and symbol prefixes, confirming the vulnerability.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L89-93)
```csharp
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L137-138)
```csharp
        Assert(State.NFTTypeFullNameMap[input.ShortName] == null, $"Short name {input.ShortName} already exists.");
        Assert(State.NFTTypeShortNameMap[fullName] == null, $"Full name {fullName} already exists.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L171-182)
```csharp
    private void AssertSenderIsParliamentDefaultAddress()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        if (State.ParliamentDefaultAddress.Value == null)
            State.ParliamentDefaultAddress.Value =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());

        Assert(Context.Sender == State.ParliamentDefaultAddress.Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L35-36)
```csharp
    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L44-60)
```csharp
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;

        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }
```
