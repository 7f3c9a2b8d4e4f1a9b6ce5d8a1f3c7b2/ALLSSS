# Audit Report

## Title
Unchecked Return Value in GetMaximumBlocksCount Causes NullReferenceException and Potential Consensus DoS

## Summary
The private `GetMaximumBlocksCount()` method in the AEDPoS consensus contract fails to check the boolean return value from `TryToGetCurrentRoundInformation`, allowing execution to proceed with a null `currentRound` object. This causes a NullReferenceException when accessing round properties, potentially disrupting critical consensus operations during block production and causing denial-of-service.

## Finding Description

The `GetMaximumBlocksCount()` method contains a defensive programming violation where it calls `TryToGetCurrentRoundInformation(out var currentRound)` but ignores the return value that indicates whether the operation succeeded. [1](#0-0) 

When `TryToGetCurrentRoundInformation` fails, it returns `false` and sets the `round` parameter to `null`. This occurs when either `State.CurrentRoundNumber.Value` equals 0 or when the round information doesn't exist in state: [2](#0-1) 

Despite this failure condition, the code immediately proceeds to access properties of the potentially null `currentRound` object: [3](#0-2) 

Additionally, in the Abnormal status branch, the code accesses `currentRound.RealTimeMinersInformation.Count`: [4](#0-3) 

This contrasts sharply with proper usage patterns elsewhere in the codebase. For example, `ValidateBeforeExecution` correctly checks the return value: [5](#0-4) 

View methods also implement the correct pattern: [6](#0-5) 

The vulnerable condition occurs during the initialization window. `InitialAElfConsensusContract` validates that `CurrentRoundNumber` is 0 but doesn't set it: [7](#0-6) 

Only later does `FirstRound` set the value to 1: [8](#0-7) 

## Impact Explanation

**HIGH severity** - This vulnerability affects consensus-critical operations through multiple attack vectors:

1. **Public Method Exposure**: The vulnerability is exposed through a public view method that can be called by anyone: [9](#0-8) 

2. **Consensus Operation Disruption**: The method is called during critical consensus processing in `ProcessConsensusInformation`, which handles all consensus behaviors (UpdateValue, TinyBlock, NextRound, NextTerm): [10](#0-9) 

3. **Block Production Impact**: The method is also called when generating consensus commands for miners to determine their next action: [11](#0-10) 

When the NullReferenceException occurs, it causes transaction failure. If triggered during internal consensus processing, it disrupts block production and could halt chain progression. The defensive programming failure makes the consensus system fragile to edge cases, state inconsistencies, or timing issues during chain startup.

## Likelihood Explanation

**MEDIUM-HIGH likelihood** - The vulnerability has realistic trigger conditions:

1. **Reachable Entry Point**: The public `GetMaximumBlocksCount(Empty input)` view method can be called by any user without authorization checks.

2. **Feasible Preconditions**: The vulnerability triggers when:
   - `State.CurrentRoundNumber.Value` is 0 (during the initialization period between `InitialAElfConsensusContract` and `FirstRound`)
   - Round information for the current round number doesn't exist in state (potential state corruption or race condition)

3. **Initialization Window**: During genesis block initialization, there is a documented two-step process where `CurrentRoundNumber` is temporarily in an invalid state.

4. **Defensive Pattern Violation**: The "Try" pattern with boolean return values exists precisely to handle failure cases defensively. The code's failure to check the return value violates this pattern and creates systemic fragility.

While normal operation should maintain valid round state after initialization, edge cases during chain startup, state corruption, or race conditions could trigger this vulnerability. The presence of proper checks elsewhere in the codebase confirms this is a recognized failure mode that should be handled.

## Recommendation

Add a return value check after calling `TryToGetCurrentRoundInformation` and handle the failure case appropriately:

```csharp
private int GetMaximumBlocksCount()
{
    if (!TryToGetCurrentRoundInformation(out var currentRound))
    {
        // Return default value during initialization or error states
        return AEDPoSContractConstants.MaximumTinyBlocksCount;
    }
    
    var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
    var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
    var currentHeight = Context.CurrentHeight;
    var currentRoundNumber = currentRound.RoundNumber;
    
    // ... rest of the method
}
```

This matches the defensive pattern used in other parts of the codebase and ensures the method can safely handle edge cases during initialization or state inconsistencies.

## Proof of Concept

```csharp
// Test to demonstrate the vulnerability
[Fact]
public async Task GetMaximumBlocksCount_WithUninitializedRound_ShouldNotThrowNullReference()
{
    // Setup: Deploy consensus contract but only call InitialAElfConsensusContract
    // Do NOT call FirstRound, leaving CurrentRoundNumber at 0
    
    var consensusContract = GetConsensusContract();
    
    // Initialize without setting round information
    await consensusContract.InitialAElfConsensusContract.SendAsync(new InitialAElfConsensusContractInput
    {
        PeriodSeconds = 604800,
        MinerIncreaseInterval = 31536000
    });
    
    // At this point, State.CurrentRoundNumber.Value == 0
    // TryToGetCurrentRoundInformation will return false and set currentRound to null
    
    // Attempt to call GetMaximumBlocksCount
    // This will throw NullReferenceException when accessing currentRound.ConfirmedIrreversibleBlockRoundNumber
    var exception = await Assert.ThrowsAsync<NullReferenceException>(async () =>
    {
        await consensusContract.GetMaximumBlocksCount.CallAsync(new Empty());
    });
    
    // Vulnerability confirmed: NullReferenceException occurs instead of graceful handling
    Assert.NotNull(exception);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L12-14)
```csharp
    public override Int32Value GetMaximumBlocksCount(Empty input)
    {
        return new Int32Value { Value = GetMaximumBlocksCount() };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L24-24)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L25-28)
```csharp
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L52-52)
```csharp
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L21-24)
```csharp
    public override Round GetCurrentRoundInformation(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var currentRound) ? currentRound : new Round();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L24-24)
```csharp
        Assert(State.CurrentRoundNumber.Value == 0 && !State.Initialized.Value, "Already initialized.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L77-81)
```csharp
        Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");

        /* Initial settings. */
        State.CurrentTermNumber.Value = 1;
        State.CurrentRoundNumber.Value = 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L67-69)
```csharp
        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L48-51)
```csharp
                var consensusCommand =
                    new ConsensusCommandProvider(new TinyBlockCommandStrategy(currentRound, pubkey,
                        currentBlockTime, GetMaximumBlocksCount())).GetConsensusCommand();
                return consensusCommand;
```
