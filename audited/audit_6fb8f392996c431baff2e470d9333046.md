### Title
Predictable NFT Symbol Generation Enables Selective Participation Attack

### Summary
The `GenerateSymbolNumber()` function uses the previous block's random hash as its randomness source, which is publicly known before transactions execute in the current block. Attackers can predict the exact symbol number they would receive and selectively submit NFT creation transactions only when they would obtain desirable symbols, effectively monopolizing valuable vanity symbol numbers over time.

### Finding Description

**Code Location:** [1](#0-0) 

**Root Cause:**
The `GenerateSymbolNumber()` function retrieves random bytes by calling the consensus contract with `Context.CurrentHeight.Sub(1)` as the height parameter. [2](#0-1) 

This means transactions executing in block H request the random hash from block H-1. The consensus contract stores random hashes during block production via `State.RandomHashes[Context.CurrentHeight] = randomHash`. [3](#0-2) 

Once block H-1 is finalized, `State.RandomHashes[H-1]` becomes publicly readable through the `GetRandomHash` and `GetRandomBytes` view methods. [4](#0-3) 

Both methods are explicitly marked as view methods in the protocol definitions, making them publicly accessible without restrictions. [5](#0-4) 

**Why Existing Protections Fail:**
1. **Context.Sender inclusion**: While the function combines `Context.Sender` with the random bytes, this doesn't prevent prediction because the attacker is computing their own outcome with their own address. [6](#0-5) 

2. **Collision check**: The `do-while` loop only prevents duplicate symbols, not predictability. [7](#0-6) 

3. **FIFO transaction ordering**: AElf's transaction pool uses time-based FIFO ordering, not gas-based priority. However, this doesn't prevent the attack because the attacker can predict their symbol before submitting and only participate when favorable.

### Impact Explanation

**Concrete Harm:**
- **Value Extraction**: NFT symbols with desirable patterns (e.g., "AR111111", "AR888888", "AR123456", sequential digits, palindromes) have intrinsic market value similar to vanity addresses or premium domain names. Attackers can monopolize these valuable symbols.

- **Fairness Violation**: The NFT protocol creation process is supposed to provide equal opportunity for all users to receive symbols. Predictability undermines this fundamental fairness assumption.

- **Market Manipulation**: Attackers can accumulate portfolios of premium symbols and either hold them ransom or sell them at inflated prices, extracting value from legitimate NFT creators.

**Affected Parties:**
- Legitimate NFT protocol creators who cannot compete fairly for desirable symbols
- The NFT ecosystem as a whole, where trust in fair symbol allocation is compromised
- End users who may pay premiums for protocols with desirable symbols

**Severity Justification:**
This is a **Critical** severity issue because:
1. It enables systematic value extraction over time
2. It undermines the core fairness principle of the NFT protocol
3. It's undetectable to normal users who assume randomness
4. The attack can be executed repeatedly with minimal cost

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Ability to read blockchain state (standard node query capability)
2. Ability to compute hash functions (standard cryptographic operations)
3. Ability to submit transactions (basic blockchain participation)

**Attack Complexity: LOW**

**Execution Steps:**
1. Monitor each new block N being produced
2. After block N is finalized, read `RandomHash[N]` via `GetRandomHash(N)` view method
3. Compute predicted symbol for block N+1: `Hash(Hash(AttackerAddress) + RandomHash[N])`
4. Convert to symbol number using the same `ConvertHashToInt64` logic with current number length
5. If symbol is desirable (matches criteria like repeating digits), submit `Create` transaction
6. If symbol is not desirable, skip and wait for block N+1

**Feasibility Conditions:**
- No special privileges required
- Works on any NFT type
- Attack can be automated with simple monitoring scripts
- Economic cost is minimal (only transaction fees for desirable symbols)

**Detection Constraints:**
- Attack is indistinguishable from normal usage
- Attacker submits legitimate Create transactions
- No abnormal transaction patterns visible on-chain
- Can be executed from multiple addresses to avoid pattern detection

**Probability: HIGH** - The attack is practical, profitable, and undetectable. Any rational attacker monitoring the blockchain can execute it.

### Recommendation

**Immediate Fix:**
Modify `GenerateSymbolNumber()` to use the CURRENT block's random hash instead of the previous block's. This ensures the randomness is not known until after the transaction is already committed to a block:

```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    // Use CURRENT height instead of CurrentHeight.Sub(1)
    var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
    {
        Value = Context.CurrentHeight  // Changed from Context.CurrentHeight.Sub(1)
    }.ToBytesValue());
    
    var randomHash = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(Context.Sender),
        HashHelper.ComputeFrom(randomBytes)
    );
    
    long randomNumber;
    do
    {
        randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
    } while (State.IsCreatedMap[randomNumber]);

    return randomNumber;
}
```

**Additional Hardening:**
1. Include transaction hash in the randomness computation: `HashHelper.ComputeFrom(Context.TransactionId)`
2. Add block timestamp to further increase entropy
3. Consider commit-reveal scheme for high-value symbol creation

**Testing Requirements:**
1. Verify randomness cannot be predicted before block execution
2. Test that symbol distribution remains uniform
3. Ensure collision detection still functions correctly
4. Add integration tests simulating prediction attempts

### Proof of Concept

**Initial State:**
- Block H-1 has just been finalized
- `State.RandomHashes[H-1]` contains value `0xabcd...`
- Attacker address is `0x1234...`
- Current symbol number length is 8 digits

**Attack Sequence:**

**Step 1:** Attacker reads public state
```
randomHash_H1 = GetRandomHash(H-1)  // Returns 0xabcd... (publicly readable)
```

**Step 2:** Attacker computes predicted symbol
```
attackerHash = Hash(AttackerAddress) = Hash(0x1234...)
combinedHash = Hash(attackerHash + randomHash_H1)
predictedNumber = ConvertHashToInt64(combinedHash, 10000000, 100000000)
// Result: 77777777 (highly desirable repeating digits)
```

**Step 3:** Attacker submits Create transaction
```
Create({
    NftType: "Art",
    ProtocolName: "My NFT",
    ...
})
// This transaction will be included in block H
```

**Step 4:** Transaction executes in block H
```
GetSymbol("Art") is called
GenerateSymbolNumber() uses RandomHash[H-1] = 0xabcd...
Computes Hash(Hash(AttackerAddress) + 0xabcd...)
Generates symbol number: 77777777
Returns symbol: "AR77777777"
```

**Expected vs Actual:**
- **Expected (by design)**: Random, unpredictable symbol assignment
- **Actual**: Attacker successfully claims "AR77777777" as predicted

**Success Condition:** Attacker receives the exact symbol number they predicted (77777777), demonstrating complete predictability of the supposedly random symbol generation process.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L117-129)
```csharp
    public override Hash GetRandomHash(Int64Value input)
    {
        Assert(input.Value > 1, "Invalid block height.");
        Assert(Context.CurrentHeight >= input.Value, "Block height not reached.");
        return State.RandomHashes[input.Value] ?? Hash.Empty;
    }

    public override BytesValue GetRandomBytes(BytesValue input)
    {
        var height = new Int64Value();
        height.MergeFrom(input.Value);
        return GetRandomHash(height).ToBytesValue();
    }
```

**File:** protobuf/aedpos_contract.proto (L143-145)
```text
    rpc GetRandomHash (google.protobuf.Int64Value) returns (aelf.Hash) {
        option (aelf.is_view) = true;
    }
```
