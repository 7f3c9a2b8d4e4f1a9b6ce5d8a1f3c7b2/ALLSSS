### Title
Mining Order Manipulation via Selective InValue Revelation in AEDPoS Consensus

### Summary
The `ValidatePreviousInValue()` function allows miners to bypass InValue revelation by submitting `Hash.Empty`, which is explicitly permitted by design. This enables miners to calculate two possible mining orders for the next round—one based on revealing their true InValue and one based on the deterministic fake value—and selectively choose whichever order benefits them more, breaking the randomness guarantee of the consensus protocol.

### Finding Description

The vulnerability exists in the validation logic for the UpdateValue consensus behavior. When a miner produces a block in round N, they publish an `OutValue = Hash(InValue)`. In the subsequent round N+1, they should reveal their `InValue` as `PreviousInValue` to prove they didn't manipulate the randomness. [1](#0-0) 

However, the validation explicitly allows `Hash.Empty` as a valid `PreviousInValue`, completely bypassing the commit-reveal validation. This is not just for genesis cases—it's a deliberate design choice: [2](#0-1) 

When a miner doesn't reveal their InValue (submits `Hash.Empty`), the system uses a deterministic fake value for signature calculation: [3](#0-2) 

The signature directly determines the miner's order in the next round through a modulo operation: [4](#0-3) 

**Root Cause**: The fake value `Hash(pubkey + height)` is completely deterministic and predictable. A miner can calculate both possible signatures in advance:
- `signature_real = CalculateSignature(true_InValue)` 
- `signature_fake = CalculateSignature(Hash(pubkey + height))`

From these, they derive both possible mining orders for round N+2, then choose to reveal or withhold their InValue based on which order is more favorable.

**Why Protections Fail**:
1. The evil miner detection only checks missed time slots, not InValue manipulation: [5](#0-4) 

2. Secret sharing can eventually reveal the true InValue, but there's no retroactive validation comparing the revealed value against the signature that was actually used during block production. [6](#0-5) 

By the time the InValue is reconstructed via secret sharing, the miner has already gained their advantage by producing blocks in their chosen favorable position.

### Impact Explanation

**Consensus Integrity Violation**: The core security assumption of AEDPoS randomness is broken. The commit-reveal scheme for InValues is designed to prevent miners from biasing the random selection of mining order. By allowing selective revelation, miners can manipulate their position in the mining schedule.

**Reward Misallocation**: Mining order directly impacts block production rewards:
- Miners can position themselves to produce consecutive blocks
- They can avoid unfavorable positions (e.g., last slot which is more prone to missed blocks)
- Multiple colluding miners can coordinate their selective revelations to dominate block production

**Quantified Damage**: 
- Each miner can bias their order from a uniform 1/(N miners) probability to ~2/(N miners) by choosing between two options
- With N=17 miners (2N+1 where N=8 initially), this represents an ~11.7% advantage
- Over time, this compounds to significant additional rewards
- Coordinated attacks by multiple miners amplify the advantage exponentially

**Affected Parties**: All honest miners and token holders are affected as the consensus randomness guarantee is violated, leading to unfair reward distribution and potential centralization of block production.

### Likelihood Explanation

**Attacker Capabilities**: Any active block producer can exploit this. Requirements:
- Be an elected miner (already producing blocks)
- Ability to compute hash functions and perform modulo arithmetic
- Access to public blockchain data (all signatures from previous round)

**Attack Complexity**: LOW
1. Monitor current round N signatures (publicly available on-chain)
2. Calculate `signature_option_A = XOR(real_InValue, aggregated_signatures)`
3. Calculate `signature_option_B = XOR(Hash(pubkey + height), aggregated_signatures)`
4. Compute `order_A = (signature_option_A % miner_count) + 1`
5. Compute `order_B = (signature_option_B % miner_count) + 1`
6. Choose to set `PreviousInValue = real_InValue` if order_A is better, else `PreviousInValue = Hash.Empty`

**Feasibility**: The attack is practical and undetectable:
- All required information is public or self-generated
- The validation explicitly permits `Hash.Empty`
- No monitoring or detection mechanism exists
- The comment in code confirms this behavior is intentional, not a bug

**Economic Rationality**: The cost is zero (no additional transaction fees, no penalty), while the benefit is consistent additional block rewards over time. Any rational profit-maximizing miner would exploit this.

**Detection Constraints**: None. The system treats `Hash.Empty` as valid, and there's no retrospective validation even when secret sharing reveals the true InValue later.

### Recommendation

**Immediate Fix**: Remove the `Hash.Empty` bypass except for legitimate genesis/initialization cases:

```csharp
private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;

    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
        return true; // Miner wasn't in previous round (new miner case)

    if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) 
        return true;

    var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
    var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
    
    // Remove this bypass - only allow for first round of term
    if (previousInValue == Hash.Empty) {
        // Only allow Hash.Empty for first round of current term
        if (validationContext.ExtraData.Round.RoundNumber == 
            State.FirstRoundNumberOfEachTerm[validationContext.ExtraData.Round.TermNumber]) {
            return true;
        }
        return false; // Reject Hash.Empty for regular rounds
    }

    return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
}
```

**Additional Mitigations**:
1. Add retroactive validation in `RevealSharedInValues` that checks if the reconstructed InValue matches what the signature calculation implies was used
2. Implement slashing penalties for miners whose revealed InValue (via secret sharing) doesn't match their signature
3. Make secret sharing mandatory rather than optional via the configuration flag
4. Add monitoring to detect systematic pattern of Hash.Empty submissions by specific miners

**Test Cases**:
- Test that regular miners cannot submit `Hash.Empty` in normal rounds
- Test that genesis/term-transition cases still work correctly
- Test that secret sharing validation catches InValue/signature mismatches
- Test penalty application for manipulation attempts

### Proof of Concept

**Initial State**:
- 17 miners (N=8, so 2N+1=17) are active
- Current round is N
- Attacker is miner with pubkey "AttackerPubkey"
- Attacker generated `InValue_N` and published `OutValue_N = Hash(InValue_N)` in round N

**Attack Steps**:

**Step 1**: At end of round N, collect all signatures
- Query `GetRoundInformation(N)` to get all 17 miners' signatures
- Aggregate them: `agg_sig = XOR(sig_miner1, sig_miner2, ..., sig_miner17)`

**Step 2**: Calculate both possible signatures for round N+1
- Option A: `sig_A = XOR(InValue_N, agg_sig)` (using real InValue)
- Option B: `sig_B = XOR(Hash("AttackerPubkey" + height), agg_sig)` (using fake value)

**Step 3**: Calculate resulting orders for round N+2
- `order_A = (sig_A.ToInt64() % 17) + 1`
- `order_B = (sig_B.ToInt64() % 17) + 1`

**Step 4**: Make strategic choice
- If `order_A` is more favorable (e.g., order_A = 3 vs order_B = 15):
  - Submit `UpdateValue` with `PreviousInValue = InValue_N`
- If `order_B` is more favorable (e.g., order_B = 2 vs order_A = 16):
  - Submit `UpdateValue` with `PreviousInValue = Hash.Empty`

**Expected Result**: 
- Validation passes (returns true) regardless of choice
- Attacker gets their chosen favorable order in round N+2
- No penalty or detection occurs

**Actual Result**: 
- System accepts both options as valid
- Attacker successfully manipulates mining order
- Over multiple rounds, attacker consistently gets better-than-average positions
- Statistical analysis would show non-uniform distribution of orders for exploiting miners

**Success Condition**: Attacker can demonstrate, over 100 rounds, that their average order position is significantly better than the expected uniform distribution (p-value < 0.01 in statistical test).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L96-108)
```csharp
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-53)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
```
