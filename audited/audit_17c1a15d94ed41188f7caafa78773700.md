# Audit Report

## Title
Insufficient Miner Selection in GetVictories() Leads to Undersized Consensus Round

## Summary
The `GetVictories()` function in the Election contract contains a logic error that incorrectly limits backup miner selection to `currentMiners.Count` instead of the actual number of available backups (`backups.Count`). When the target miner count increases over time but there are insufficient valid candidates, this bug causes consensus rounds to be generated with fewer miners than configured, violating a critical protocol invariant.

## Finding Description

The vulnerability exists in the private `GetVictories(List<string> currentMiners)` method at line 72. [1](#0-0) 

When there are insufficient valid candidates with votes, the function attempts to fill the gap using backup miners constructed from current miners and initial miners. However, the bug occurs when selecting from the backups list - it uses `Math.Min(diff, currentMiners.Count)` instead of `Math.Min(diff, backups.Count)`.

**Execution Path:**

1. The AEDPoS consensus contract's miner count auto-increments over time via `GetAutoIncreasedMinersCount()`, adding 2 miners every `MinerIncreaseInterval` seconds. [2](#0-1) 

2. This increased count is communicated to the Election contract via `UpdateMinersCount()`, updating `State.MinersCount.Value`. [3](#0-2) 

3. During term transition, `GenerateFirstRoundOfNextTerm()` calls `TryToGetVictories()` to obtain the new miner list. [4](#0-3) 

4. `TryToGetVictories()` invokes the Election contract's `GetVictories()` method. [5](#0-4) 

5. If `validCandidates.Count < State.MinersCount.Value`, the backups list is constructed (lines 66-69), but line 72 incorrectly takes only `Math.Min(diff, currentMiners.Count)` miners instead of utilizing all available backups.

6. The undersized miner list is returned and used to generate the new consensus round via `GenerateFirstRoundOfNewTerm()`, which simply iterates over the provided miners without validation. [6](#0-5) 

**Concrete Example:**
- Target: `State.MinersCount.Value = 10`
- Valid candidates with votes: 2
- Previous term miners: 5
- Available backups (after construction): 8
- **Current buggy behavior**: Takes `Math.Min(8, 5) = 5` backups → Total: 2 + 5 = 7 miners (3 short)
- **Expected behavior**: Should take `Math.Min(8, 8) = 8` backups → Total: 2 + 8 = 10 miners

## Impact Explanation

This bug directly violates the consensus miner schedule integrity:

**Consensus Degradation**: The blockchain operates with fewer block producers than configured, reducing decentralization, network security, and liveness guarantees.

**State Inconsistency**: `State.MinersCount.Value` indicates N miners should participate, but actual consensus rounds contain < N miners, creating a mismatch between configuration and reality.

**Reward Misallocation Risk**: Mining reward and profit distribution calculations that rely on the configured miner count will be incorrect, potentially affecting per-miner payouts.

**Protocol Invariant Violation**: The critical invariant that consensus rounds must contain exactly `State.MinersCount.Value` miners is broken. No validation exists in the round generation logic to catch this mismatch.

This is **HIGH severity** because it directly compromises consensus integrity, a foundational protocol guarantee.

## Likelihood Explanation

This vulnerability has **MEDIUM-HIGH likelihood** of occurring naturally:

**No Attacker Required**: This is a logic bug that triggers under normal network conditions, not through malicious action.

**Realistic Trigger Conditions**:
1. The miner count automatically increases every `MinerIncreaseInterval` (configured in production as 1 year) by 2 miners, starting from `SupposedMinersCount = 17`. [7](#0-6) 

2. Low voter participation or insufficient candidate onboarding results in `validCandidates.Count < State.MinersCount.Value` - a realistic scenario during network growth or periods of low engagement.

3. The previous term had fewer miners than the new auto-incremented target - inevitable during the growth phase.

**Natural Occurrence**: In a growing network where miner count targets increase but community participation lags, this condition will manifest without any adversarial behavior.

**Detection**: The bug produces visible symptoms (undersized rounds) but no runtime assertion prevents the invalid state, allowing it to persist.

## Recommendation

Fix line 72 to use `backups.Count` instead of `currentMiners.Count`:

```csharp
victories.AddRange(backups.OrderBy(p => p)
    .Take(Math.Min(diff, backups.Count))  // FIXED: Use backups.Count
    .Select(v => ByteStringHelper.FromHexString(v)));
```

Additionally, add validation in `GenerateFirstRoundOfNewTerm()` or after `TryToGetVictories()` to assert that the returned miner count matches expectations and log warnings if mismatches occur.

## Proof of Concept

```csharp
[Fact]
public async Task GetVictories_InsufficientBackups_ReturnsUndersizedList()
{
    // Setup: Increase miners count to 10
    await AEDPoSContractStub.SetMaximumMinersCount.SendAsync(new Int32Value { Value = 10 });
    
    // Only 2 candidates with votes (simulating low participation)
    var candidate1 = ValidationDataCenterKeyPairs[0];
    var candidate2 = ValidationDataCenterKeyPairs[1];
    await AnnounceElectionAsync(candidate1);
    await AnnounceElectionAsync(candidate2);
    await VoteToCandidateAsync(VoterKeyPairs[0], candidate1.PublicKey.ToHex(), 100 * 86400, 100);
    await VoteToCandidateAsync(VoterKeyPairs[1], candidate2.PublicKey.ToHex(), 100 * 86400, 100);
    
    // Advance to next term with 5 current miners (simulating previous smaller term)
    await NextTerm(BootMinerKeyPair);
    
    // Get victories
    var victories = await ElectionContractStub.GetVictories.CallAsync(new Empty());
    
    // Bug: Should return 10 miners but returns only 7 (2 valid + min(8, 5) backups)
    victories.Value.Count.ShouldBe(10); // This will FAIL, demonstrating the bug
    // Actual count will be 7, not 10
}
```

**Notes**

The existing test cases in `ElectionTests.cs` do not catch this bug because they test scenarios where `InitialCoreDataCenterCount = 5` remains constant, never exercising the dynamic miner count increase scenario. [8](#0-7) 

The vulnerability is particularly insidious because it silently allows the system to operate in a degraded state without transaction failure, making it difficult to detect in production until consensus performance degrades noticeably.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-45)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```

**File:** test/AElf.Contracts.Election.Tests/GQL/ElectionTests.cs (L337-384)
```csharp
    public async Task ElectionContract_GetVictories_NoCandidate_Test()
    {
        // To get previous round information.
        await NextRound(BootMinerKeyPair);

        var victories = (await ElectionContractStub.GetVictories.CallAsync(new Empty())).Value
            .Select(p => p.ToHex()).ToList();

        // Same as initial miners.
        victories.Count.ShouldBe(EconomicContractsTestConstants.InitialCoreDataCenterCount);
        foreach (var initialMiner in InitialCoreDataCenterKeyPairs.Select(kp => kp.PublicKey.ToHex()))
            victories.ShouldContain(initialMiner);
    }

    [Fact]
    public async Task ElectionContract_GetVictories_CandidatesNotEnough_Test()
    {
        // To get previous round information.
        await NextRound(BootMinerKeyPair);

        var keyPairs = ValidationDataCenterKeyPairs
            .Take(EconomicContractsTestConstants.InitialCoreDataCenterCount - 1).ToList();
        foreach (var keyPair in keyPairs) await AnnounceElectionAsync(keyPair);

        var victories = (await ElectionContractStub.GetVictories.CallAsync(new Empty())).Value
            .Select(p => p.ToHex()).ToList();

        // Same as initial miners.
        victories.Count.ShouldBe(EconomicContractsTestConstants.InitialCoreDataCenterCount);
        foreach (var initialMiner in InitialCoreDataCenterKeyPairs.Select(kp => kp.PublicKey.ToHex()))
            victories.ShouldContain(initialMiner);
    }

    [Fact]
    public async Task ElectionContract_GetVictories_NoValidCandidate_Test()
    {
        await NextRound(BootMinerKeyPair);

        foreach (var keyPair in ValidationDataCenterKeyPairs) await AnnounceElectionAsync(keyPair);

        var victories = (await ElectionContractStub.GetVictories.CallAsync(new Empty())).Value
            .Select(p => p.ToHex()).ToList();

        // Same as initial miners.
        victories.Count.ShouldBe(EconomicContractsTestConstants.InitialCoreDataCenterCount);
        foreach (var initialMiner in InitialCoreDataCenterKeyPairs.Select(kp => kp.PublicKey.ToHex()))
            victories.ShouldContain(initialMiner);
    }
```
