### Title
Premature State Removal in CreateSideChain Causes Permanent Proposal Data Loss on Validation Failure

### Summary
The `CreateSideChain` function removes the proposer's side chain creation request state before completing validation checks. If any subsequent validation fails (such as insufficient token allowance), the proposer's proposal data is permanently lost and cannot be recovered, forcing them to restart the entire governance approval process.

### Finding Description

The vulnerability exists in the `CreateSideChain` function where state deletion occurs prematurely: [1](#0-0) 

The state is removed at line 127, but critical validations occur afterwards:
1. Lines 129-132 assert the state is not null and matches the input
2. Line 133 calls `AssertValidSideChainCreationRequest` which performs multiple validations including: [2](#0-1) 

Key validations that can fail AFTER state removal include:
- **Allowance check** (lines 108-117 in helper): Verifies the proposer still has sufficient token allowance approved for the contract
- **Organization collision check** (lines 103-105 in helper): Checks if the organization has an unexpired proposal
- **Resource token validation** (line 127 in helper)
- **Token info validation** (line 133 in helper)
- **Initial issue list validation** (lines 134-136 in helper)

The root cause is a violation of the state management invariant: state should only be modified after all validations that depend on or validate that state have completed successfully. The current implementation removes state optimistically, assuming all subsequent validations will pass.

### Impact Explanation

**Operational DoS Impact:**
- When validation fails post-removal, the proposer's `ProposedSideChainCreationRequestState` entry is permanently deleted from contract state
- The proposer cannot retry or recover their approved proposal
- They must call `RequestSideChainCreation` again, creating a new proposal that requires full Parliament approval (voting, consensus building, time delays)
- The governance work already invested (proposal creation, voting, approval) is entirely wasted

**Realistic Failure Scenario:**
The most likely failure is the allowance check. Between proposal submission and governance execution (which can take significant time), a proposer may:
- Reduce their allowance for security reasons
- Use their allowance for other operations
- Have their allowance reduced by another contract interaction

Since the initial `RequestSideChainCreation` validates allowance but `CreateSideChain` re-validates it, any reduction in allowance between these two calls will trigger the vulnerability.

**Affected Parties:**
- Proposers who have successfully gone through governance approval
- The governance system itself (wasted voting effort)
- The broader ecosystem waiting for side chain deployment

### Likelihood Explanation

**Feasible Preconditions:**
- Proposer successfully calls `RequestSideChainCreation` with sufficient allowance
- Proposal goes through Parliament voting and approval (normal governance flow)
- Between approval and execution, proposer's allowance drops below required amount

**Execution Practicality:**
This is highly practical because:
1. The governance approval process takes time (days to weeks typically), creating a large time window
2. Token allowances are routinely managed for security - users often reduce allowances when not actively needed
3. Allowances can be consumed by other contract operations without the proposer realizing the impact on their pending side chain proposal
4. No warning or grace period exists - the state is immediately deleted on validation failure

**Attack Complexity:**
This is not an intentional attack but a design flaw that causes accidental state corruption. A malicious proposer could intentionally trigger this to waste governance resources, but the more common case is accidental triggering.

**Probability:**
Medium probability because:
- Time window between proposal and execution is substantial
- Allowance management is common and encouraged for security
- Users may not realize their pending proposal depends on maintaining allowance until execution

### Recommendation

**Code-Level Mitigation:**

Move state removal to occur AFTER all validations pass. Modify `CreateSideChain` as follows:

```csharp
public override Int32Value CreateSideChain(CreateSideChainInput input)
{
    AssertSideChainLifetimeControllerAuthority(Context.Sender);
    
    var proposedSideChainCreationRequestState = State.ProposedSideChainCreationRequestState[input.Proposer];
    var sideChainCreationRequest = input.SideChainCreationRequest;
    
    // Validate BEFORE removing state
    Assert(
        proposedSideChainCreationRequestState != null &&
        proposedSideChainCreationRequestState.SideChainCreationRequest.Equals(sideChainCreationRequest),
        "Side chain creation failed without proposed data.");
    AssertValidSideChainCreationRequest(sideChainCreationRequest, input.Proposer);
    
    // Only remove state after all validations pass
    State.ProposedSideChainCreationRequestState.Remove(input.Proposer);
    
    // Continue with side chain creation...
    State.SideChainSerialNumber.Value = State.SideChainSerialNumber.Value.Add(1);
    // ... rest of function
}
```

**Invariant to Add:**
Add explicit check that state removal only occurs after successful validation: "State.ProposedSideChainCreationRequestState[proposer] shall only be removed after all validation assertions have passed."

**Test Case:**
Add test that verifies proposal data persists when CreateSideChain fails validation:
1. Create proposal with sufficient allowance
2. Get governance approval  
3. Reduce proposer allowance below required amount
4. Attempt CreateSideChain execution (should fail)
5. Verify ProposedSideChainCreationRequestState still contains proposer's data
6. Restore allowance and retry - should succeed

### Proof of Concept

**Initial State:**
- Proposer has approved 100 tokens allowance for CrossChainContract
- Proposer calls `RequestSideChainCreation` requesting 100 tokens locked
- Validation passes, proposal created and stored in `State.ProposedSideChainCreationRequestState[proposer]`
- Proposal ID generated and submitted to Parliament

**Transaction Steps:**

1. **Governance Approval:** Parliament members vote and approve the proposal (takes several days)

2. **Allowance Reduction:** During waiting period, proposer reduces allowance to 50 tokens for security reasons or other token operations

3. **Execution Attempt:** Parliament releases proposal, triggering `CreateSideChain`:
   - Line 124: Authority check passes (caller is Parliament organization)
   - Line 126: Retrieves `proposedSideChainCreationRequestState` (contains valid data)
   - **Line 127: State.ProposedSideChainCreationRequestState.Remove(input.Proposer)** - State deleted!
   - Lines 129-132: Null and equality checks pass
   - Line 133: Calls `AssertValidSideChainCreationRequest`
   - Helper lines 108-117: Allowance check **FAILS** (50 < 100)
   - Transaction reverts with "Allowance not enough"

4. **Post-Failure State:**
   - Transaction failed, side chain not created
   - `State.ProposedSideChainCreationRequestState[proposer]` is **permanently empty**
   - Proposer cannot retry even after restoring allowance
   - Must call `RequestSideChainCreation` again and restart governance process

**Expected vs Actual Result:**
- **Expected:** Validation failure should leave state intact, allowing retry after fixing allowance
- **Actual:** Validation failure permanently deletes state, requiring complete governance restart

**Success Condition for Exploit:**
State corruption is confirmed when attempting to query `State.ProposedSideChainCreationRequestState[proposer]` after failed execution returns null, despite the proposal having been properly created and approved.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L126-133)
```csharp
        var proposedSideChainCreationRequestState = State.ProposedSideChainCreationRequestState[input.Proposer];
        State.ProposedSideChainCreationRequestState.Remove(input.Proposer);
        var sideChainCreationRequest = input.SideChainCreationRequest;
        Assert(
            proposedSideChainCreationRequestState != null &&
            proposedSideChainCreationRequestState.SideChainCreationRequest.Equals(sideChainCreationRequest),
            "Side chain creation failed without proposed data.");
        AssertValidSideChainCreationRequest(sideChainCreationRequest, input.Proposer);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L100-137)
```csharp
    private void AssertValidSideChainCreationRequest(SideChainCreationRequest sideChainCreationRequest,
        Address proposer)
    {
        var proposedRequest = State.ProposedSideChainCreationRequestState[Context.Sender];
        Assert(proposedRequest == null || Context.CurrentBlockTime >= proposedRequest.ExpiredTime,
            "Request side chain creation failed.");

        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var allowance = State.TokenContract.GetAllowance.Call(new GetAllowanceInput
        {
            Owner = proposer,
            Spender = Context.Self,
            Symbol = Context.Variables.NativeSymbol
        }).Allowance;

        Assert(
            allowance >= sideChainCreationRequest.LockedTokenAmount,
            "Allowance not enough.");

        Assert(
            sideChainCreationRequest.IndexingPrice >= 0 &&
            sideChainCreationRequest.LockedTokenAmount >= sideChainCreationRequest.IndexingPrice,
            "Invalid chain creation request.");

        if (!sideChainCreationRequest.IsPrivilegePreserved)
            return; // there is no restriction for non-exclusive side chain creation

        AssertValidResourceTokenAmount(sideChainCreationRequest);

        if (!IsPrimaryTokenNeeded(sideChainCreationRequest))
            return;

        // assert primary token to create
        AssertValidSideChainTokenInfo(sideChainCreationRequest.SideChainTokenCreationRequest);
        Assert(sideChainCreationRequest.SideChainTokenInitialIssueList.Count > 0 &&
               sideChainCreationRequest.SideChainTokenInitialIssueList.All(issue => issue.Amount > 0),
            "Invalid side chain token initial issue list.");
    }
```
