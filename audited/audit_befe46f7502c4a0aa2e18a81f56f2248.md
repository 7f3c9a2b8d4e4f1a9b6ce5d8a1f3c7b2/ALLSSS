# Audit Report

## Title
Retroactive Threshold Changes Allow Invalidation of Already-Approved Proposals

## Summary
The Parliament contract (and Association/Referendum contracts) evaluates proposal approval status dynamically against the current organization threshold rather than snapshotting thresholds at proposal creation time. This allows threshold changes to retroactively invalidate already-approved proposals, breaking the fundamental governance invariant that approved proposals remain approved.

## Finding Description

The vulnerability exists because proposals do not snapshot approval thresholds at creation time. The `ProposalInfo` structure stores only vote counts (approvals, rejections, abstentions) without any threshold snapshot field. [1](#0-0) 

When a proposal is created, only the organization address is stored as a reference, with no threshold values captured. [2](#0-1) 

The `ChangeOrganizationThreshold` function directly updates the organization's threshold in storage without any consideration for existing proposals. [3](#0-2) 

When `Release` is called, it retrieves the organization from storage (line 136) and checks approval status using the **current** threshold (line 137), not the threshold that was active when votes were cast. [4](#0-3) 

The `IsReleaseThresholdReached` function dynamically evaluates approval by comparing vote counts against the organization's current threshold values from storage. [5](#0-4)  The actual threshold comparison happens in `CheckEnoughVoteAndApprovals` which uses the current `organization.ProposalReleaseThreshold`. [6](#0-5) 

The `GetProposal` view function also calculates `ToBeReleased` dynamically using the current organization state, meaning the same proposal's approval status can change over time. [7](#0-6) 

**Attack Flow:**
1. Organization has 50% approval threshold
2. Proposal P1 receives 60% approval and shows `ToBeReleased = true`
3. Attacker creates proposal P2 to call `ChangeOrganizationThreshold` with 70% threshold
4. P2 gets approved under current 50% threshold and is released
5. Now P1 only has 60% but needs 70% - `Release(P1)` reverts with "Not approved"
6. P1 is permanently blocked despite legitimate approval under original rules

## Impact Explanation

This vulnerability breaks a fundamental governance security invariant: **once a proposal reaches the required approval threshold, it should remain approved and executable**. 

The impact is **HIGH** because:

1. **Governance Manipulation**: Malicious actors can strategically increase thresholds to block specific approved proposals from executing, enabling censorship of legitimate governance actions

2. **Predictability Loss**: Governance participants cannot rely on approval status - a proposal showing `ToBeReleased = true` may become unreleasable moments later

3. **Accidental Invalidation**: Legitimate threshold adjustments can unintentionally block approved proposals, even without malicious intent

4. **Protocol-Wide Impact**: This affects all three governance contracts (Parliament, Association, Referendum) as confirmed by identical implementations. [8](#0-7) 

5. **Governance Deadlock**: Critical proposals (like emergency responses or system upgrades) approved under current rules can be retroactively blocked

## Likelihood Explanation

The likelihood is **MEDIUM-HIGH** because:

**Attacker Requirements:**
- Must be an authorized proposer (common for organization members)
- Must convince enough members to approve a threshold change (achievable if attacker has influence or during legitimate threshold discussions)

**Attack Complexity: LOW**
- Uses only standard governance operations (CreateProposal, Approve, Release)
- No special privileges or exploit techniques required
- Can be executed through normal governance workflow

**Feasibility:**
- The existing test suite shows threshold changes are a normal operation [9](#0-8) 
- Can occur accidentally during legitimate governance threshold adjustments
- No technical barriers prevent this attack

**Detection: DIFFICULT**
- Threshold changes appear as legitimate governance actions
- The retroactive effect on existing proposals is not immediately obvious
- No events or warnings indicate affected proposals

## Recommendation

Implement threshold snapshotting at proposal creation time:

1. **Add threshold snapshot to ProposalInfo:**
```protobuf
message ProposalInfo {
    // ... existing fields ...
    acs3.ProposalReleaseThreshold creation_threshold = 14; // Snapshot at creation
}
```

2. **Store threshold during proposal creation:**
```csharp
private Hash CreateNewProposal(CreateProposalInput input)
{
    var organization = State.Organizations[input.OrganizationAddress];
    var proposal = new ProposalInfo
    {
        // ... existing fields ...
        CreationThreshold = organization.ProposalReleaseThreshold // Snapshot
    };
    State.Proposals[proposalId] = proposal;
    return proposalId;
}
```

3. **Use snapshotted threshold in Release:**
```csharp
public override Empty Release(Hash proposalId)
{
    var proposalInfo = GetValidProposal(proposalId);
    Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
    
    // Use snapshotted threshold instead of current
    Assert(IsReleaseThresholdReached(proposalInfo, proposalInfo.CreationThreshold), 
           "Not approved.");
    
    // ... rest of release logic ...
}
```

4. **Update IsReleaseThresholdReached signature to accept threshold directly:**
```csharp
private bool IsReleaseThresholdReached(ProposalInfo proposal, ProposalReleaseThreshold threshold)
{
    var parliamentMembers = GetCurrentMinerList();
    // Use provided threshold parameter instead of fetching from organization
}
```

This ensures proposals are evaluated against the threshold that was active when they were created and voted on, preventing retroactive invalidation.

## Proof of Concept

```csharp
[Fact]
public async Task RetroactiveThresholdChange_InvalidatesApprovedProposal()
{
    // Setup: Create organization with 50% threshold
    var organizationAddress = await CreateOrganizationAsync(
        minimalApprovalThreshold: 5000,  // 50%
        maximalAbstentionThreshold: 2000,
        maximalRejectionThreshold: 2000,
        minimalVoteThreshold: 5000
    );

    // Create proposal P1 with 60% approval
    var proposal1Id = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
    await ApproveAsync(InitialMinersKeyPairs[0], proposal1Id); // Approver 1
    await ApproveAsync(InitialMinersKeyPairs[1], proposal1Id); // Approver 2
    await ApproveAsync(InitialMinersKeyPairs[2], proposal1Id); // Approver 3
    await ApproveAsync(InitialMinersKeyPairs[3], proposal1Id); // Approver 4
    await ApproveAsync(InitialMinersKeyPairs[4], proposal1Id); // Approver 5
    await ApproveAsync(InitialMinersKeyPairs[5], proposal1Id); // Approver 6
    // 6/10 = 60% approval, meets 50% threshold

    // Verify P1 is ready for release
    var proposal1 = await ParliamentContractStub.GetProposal.CallAsync(proposal1Id);
    proposal1.ToBeReleased.ShouldBeTrue(); // P1 shows as approved

    // Create proposal P2 to increase threshold to 70%
    var thresholdChangeInput = new ProposalReleaseThreshold
    {
        MinimalApprovalThreshold = 7000, // 70%
        MinimalVoteThreshold = 7000,
        MaximalAbstentionThreshold = 2000,
        MaximalRejectionThreshold = 2000
    };
    var proposal2Input = new CreateProposalInput
    {
        ContractMethodName = nameof(ParliamentContractStub.ChangeOrganizationThreshold),
        ToAddress = ParliamentContractAddress,
        Params = thresholdChangeInput.ToByteString(),
        ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(2),
        OrganizationAddress = organizationAddress
    };
    var proposal2Id = await ParliamentContractStub.CreateProposal.SendAsync(proposal2Input);

    // Approve and release P2 (meets current 50% threshold with 60% approval)
    await ApproveAsync(InitialMinersKeyPairs[0], proposal2Id.Output);
    await ApproveAsync(InitialMinersKeyPairs[1], proposal2Id.Output);
    await ApproveAsync(InitialMinersKeyPairs[2], proposal2Id.Output);
    await ApproveAsync(InitialMinersKeyPairs[3], proposal2Id.Output);
    await ApproveAsync(InitialMinersKeyPairs[4], proposal2Id.Output);
    await ApproveAsync(InitialMinersKeyPairs[5], proposal2Id.Output);
    
    await ParliamentContractStub.Release.SendAsync(proposal2Id.Output);

    // Verify threshold was changed
    var org = await ParliamentContractStub.GetOrganization.CallAsync(organizationAddress);
    org.ProposalReleaseThreshold.MinimalApprovalThreshold.ShouldBe(7000);

    // VULNERABILITY: P1 is now retroactively invalid
    var proposal1After = await ParliamentContractStub.GetProposal.CallAsync(proposal1Id);
    proposal1After.ToBeReleased.ShouldBeFalse(); // P1 now shows as NOT approved!

    // Attempting to release P1 fails
    var releaseResult = await ParliamentContractStub.Release.SendWithExceptionAsync(proposal1Id);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
    
    // P1 had 60% approval, was legitimately approved under 50% threshold,
    // but now cannot execute because threshold increased to 70%
}
```

### Citations

**File:** protobuf/parliament_contract.proto (L116-143)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L36-48)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var parliamentMembers = GetCurrentMinerList();
        var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
        if (isAbstained)
            return false;

        return CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L225-253)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId, 
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L147-160)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L225-248)
```csharp
    public override ProposalOutput GetProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        if (proposal == null) return new ProposalOutput();

        var organization = State.Organizations[proposal.OrganizationAddress];

        return new ProposalOutput
        {
            ProposalId = proposalId,
            ContractMethodName = proposal.ContractMethodName,
            ExpiredTime = proposal.ExpiredTime,
            OrganizationAddress = proposal.OrganizationAddress,
            Params = proposal.Params,
            Proposer = proposal.Proposer,
            ToAddress = proposal.ToAddress,
            ToBeReleased = Validate(proposal) && IsReleaseThresholdReached(proposal, organization),
            ApprovalCount = proposal.Approvals.Count,
            RejectionCount = proposal.Rejections.Count,
            AbstentionCount = proposal.Abstentions.Count,
            Title = proposal.Title,
            Description = proposal.Description
        };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-216)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L792-852)
```csharp
    public async Task Change_OrganizationThreshold_Test()
    {
        // await InitializeParliamentContracts();
        var minimalApprovalThreshold = 3000;
        var maximalAbstentionThreshold = 3000;
        var maximalRejectionThreshold = 3000;
        var minimalVoteThreshold = 3000;
        var organizationAddress = await CreateOrganizationAsync(minimalApprovalThreshold,
            maximalAbstentionThreshold, maximalRejectionThreshold, minimalVoteThreshold);
        var proposalId = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
        await ApproveAsync(InitialMinersKeyPairs[0], proposalId);
        var proposal = await ParliamentContractStub.GetProposal.CallAsync(proposalId);
        proposal.ToBeReleased.ShouldBeTrue();

        {
            var proposalReleaseThresholdInput = new ProposalReleaseThreshold
            {
                MinimalVoteThreshold = 6000
            };
            var createProposalInput = new CreateProposalInput
            {
                ContractMethodName = nameof(ParliamentContractStub.ChangeOrganizationThreshold),
                ToAddress = ParliamentContractAddress,
                Params = proposalReleaseThresholdInput.ToByteString(),
                ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(2),
                OrganizationAddress = organizationAddress
            };
            var changeProposal = await ParliamentContractStub.CreateProposal.SendAsync(createProposalInput);
            changeProposal.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
            var changeProposalId = changeProposal.Output;
            await ApproveAsync(InitialMinersKeyPairs[0], changeProposalId);
            var result = await ParliamentContractStub.Release.SendWithExceptionAsync(changeProposalId);
            result.TransactionResult.Error.ShouldContain("Invalid organization.");
        }
        {
            var proposalReleaseThresholdInput = new ProposalReleaseThreshold
            {
                MinimalVoteThreshold = 6000,
                MinimalApprovalThreshold = minimalApprovalThreshold
            };
            var createProposalInput = new CreateProposalInput
            {
                ContractMethodName = nameof(ParliamentContractStub.ChangeOrganizationThreshold),
                ToAddress = ParliamentContractAddress,
                Params = proposalReleaseThresholdInput.ToByteString(),
                ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(2),
                OrganizationAddress = organizationAddress
            };
            var changeProposal = await ParliamentContractStub.CreateProposal.SendAsync(createProposalInput);
            changeProposal.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
            var changeProposalId = changeProposal.Output;
            await ApproveAsync(InitialMinersKeyPairs[0], changeProposalId);
            var result = await ParliamentContractStub.Release.SendAsync(changeProposalId);
            result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            var organizationInfo = await ParliamentContractStub.GetOrganization.CallAsync(organizationAddress);
            organizationInfo.ProposalReleaseThreshold.MinimalVoteThreshold.ShouldBe(proposalReleaseThresholdInput
                .MinimalVoteThreshold);
            organizationInfo.ProposalReleaseThreshold.MinimalApprovalThreshold.ShouldBe(minimalApprovalThreshold);
        }
    }
```
