### Title
Vote Counting Inconsistency Allows Proposals to Pass with Insufficient Current Member Participation

### Summary
The `CheckEnoughVoteAndApprovals` function in Association_Helper.cs contains a critical inconsistency: it filters approvals by current organization membership when checking `MinimalApprovalThreshold`, but does not filter the total vote count when checking `MinimalVoteThreshold`. This allows proposals to be released with votes from removed members counting toward participation requirements, enabling governance decisions with significantly less current member engagement than intended.

### Finding Description

The vulnerability exists in the `CheckEnoughVoteAndApprovals` method where two different vote counting approaches are used: [1](#0-0) 

The approval count correctly filters to only include current organization members using `organization.OrganizationMemberList.Contains`.

However, the total vote threshold check does not apply any membership filtering: [2](#0-1) 

This counts ALL addresses in `proposal.Abstentions`, `proposal.Approvals`, and `proposal.Rejections` without verifying they are current members.

In contrast, other threshold checks in the same file correctly filter by membership: [3](#0-2) [4](#0-3) 

**Root Cause**: When members vote via `Approve`, `Reject`, or `Abstain` methods, membership is verified at voting time: [5](#0-4) 

However, if these members are subsequently removed from the organization via the `RemoveMember` function: [6](#0-5) 

Their addresses remain in the proposal's vote lists but are no longer in `organization.OrganizationMemberList`. At proposal release time, the inconsistent filtering causes their votes to count toward `MinimalVoteThreshold` but not toward specific approval/rejection/abstention thresholds.

### Impact Explanation

This vulnerability undermines the governance integrity of Association organizations by allowing proposals to pass with artificially inflated participation metrics:

**Concrete Scenario:**
- Organization with 10 current members
- Governance requires `MinimalVoteThreshold = 9` (90% participation) and `MinimalApprovalThreshold = 5` (50% approval)
- Attack: 5 current members approve a proposal, 4 additional members vote and are then removed
- Result: Proposal passes with only 5/10 (50%) current member participation, but the system counts 9 total votes including the 4 removed members

**Harm:**
- Governance decisions executed without the intended level of current member support
- `MinimalVoteThreshold` parameter becomes meaningless as it can be satisfied with non-member votes
- Organizations lose the ability to enforce minimum participation requirements
- Malicious proposals can pass with coordinated member removal timing

**Affected Parties:**
- All Association organizations relying on `MinimalVoteThreshold` for participation guarantees
- Organization members whose governance rights are diluted
- Systems trusting Association contract governance decisions

**Severity Justification:** Critical - This directly violates governance invariants and allows proposals to execute with insufficient democratic support, affecting all Association-based governance in the AElf ecosystem.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to influence enough current members to vote for a proposal (requires social engineering or legitimate support)
- Ability to create and execute a secondary proposal to remove members (requires meeting the organization's governance thresholds)

**Attack Complexity:** Medium
1. Create malicious proposal P1
2. Obtain minimum required approvals from current members
3. Obtain additional votes from other members
4. Create proposal P2 to remove the additional voters from step 3
5. Execute P2 through normal governance process
6. Release P1, which now passes `MinimalVoteThreshold` with removed members' votes

**Feasibility Conditions:**
- Organizations must use `MinimalVoteThreshold` parameter (commonly used for participation requirements)
- Time gap between voting and proposal release allows for member removal (normal operation)
- Attacker needs sufficient influence to pass one removal proposal (feasible in compromised governance)

**Detection/Operational Constraints:**
- Member removal is a legitimate governance action and cannot be blocked
- The inconsistency is in core threshold logic, not easily detectable
- No events or checks warn about counting non-member votes

**Probability Reasoning:** High likelihood in adversarial scenarios where attackers have minority control or during governance disputes, as the attack requires only standard governance capabilities and exploits intended functionality.

### Recommendation

**Fix the vote threshold check to filter by current membership:**

Modify `CheckEnoughVoteAndApprovals` to count only current member votes for the `MinimalVoteThreshold` check. The total vote count calculation should be changed from:

```csharp
var isVoteThresholdReached =
    proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
    organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

To:

```csharp
var totalMemberVoteCount = 
    proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
    proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
    proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
var isVoteThresholdReached = 
    totalMemberVoteCount >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**Invariant Check to Add:**
Assert that all vote threshold calculations use consistent membership filtering. Add validation in `IsReleaseThresholdReached` to verify vote counts only include current members.

**Test Cases to Prevent Regression:**
1. Test that proposals with removed member votes fail `MinimalVoteThreshold` check
2. Test that member removal after voting correctly invalidates their vote toward all thresholds
3. Test boundary cases where removed votes are exactly the difference between passing and failing
4. Test that `MinimalVoteThreshold` accurately reflects current member participation percentage

### Proof of Concept

**Initial State:**
- Create Association organization with 10 members: M1, M2, M3, M4, M5, M6, M7, M8, M9, M10
- Set thresholds: `MinimalApprovalThreshold = 5`, `MinimalVoteThreshold = 9`, `MaximalRejectionThreshold = 3`, `MaximalAbstentionThreshold = 3`
- All 10 addresses are in `ProposerWhiteList` and `OrganizationMemberList`

**Attack Sequence:**
1. M1 creates proposal P1 (malicious action)
2. M1, M2, M3, M4, M5 call `Approve(P1)` - proposal.Approvals = [M1, M2, M3, M4, M5]
3. M6, M7, M8, M9 call `Approve(P1)` - proposal.Approvals = [M1, M2, M3, M4, M5, M6, M7, M8, M9]
4. M1 creates proposal P2 to remove M6, M7, M8, M9 from organization
5. Organization executes P2 via `Release(P2)` - `organization.OrganizationMemberList` now contains only [M1, M2, M3, M4, M5, M10]
6. M1 calls `Release(P1)`

**Expected Result (Correct Behavior):**
- `CheckEnoughVoteAndApprovals` should count only current member votes: 5 total votes
- `MinimalVoteThreshold` check fails: 5 < 9
- Proposal P1 cannot be released

**Actual Result (Vulnerable Behavior):**
- Approval check: 5 current member approvals >= 5 (PASS)
- Total vote check: 9 total votes (including 4 removed members) >= 9 (PASS)
- Proposal P1 is released with only 50% current member participation instead of required 90%

**Success Condition:**
Proposal P1 executes despite having only 5 out of 6 current members participating (83%), when `MinimalVoteThreshold` of 9 was intended to require 90% of the original 10-member organization to participate. The removed members' votes artificially inflate the participation count.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-38)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-44)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-52)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-130)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-273)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
```
