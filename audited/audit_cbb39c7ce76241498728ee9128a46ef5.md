### Title
Incomplete Reserved Metadata Keys Allow MultiToken Special Key Injection in NFT Protocol Creation

### Summary
The NFT contract's `GetNftMetadataReservedKeys()` function returns an incomplete list of reserved keys that excludes critical MultiToken contract special keys such as `__nft_create_chain_id` and callback-related keys. This allows protocol creators to inject these special keys during NFT protocol creation, potentially causing denial-of-service of NFT minting operations or enabling malicious callback execution during token transfers.

### Finding Description

The NFT contract defines a reserved metadata keys list in [1](#0-0)  that only includes five NFT-specific keys. However, the MultiToken contract defines additional special ExternalInfo keys in [2](#0-1)  including:
- `__nft_create_chain_id`: Restricts which chain can create NFT items
- `aelf_transfer_callback`, `aelf_lock_callback`, `aelf_unlock_callback`: Specify contract callbacks during operations
- `aelf_log_event`: Controls logging behavior
- `aelf_token_alias`: Sets token aliases

During NFT protocol creation, user-provided metadata is validated against the incomplete reserved list at [3](#0-2)  using [4](#0-3) . Since MultiToken special keys are not in this list, they pass validation and are included in the ExternalInfo passed to the MultiToken contract at [5](#0-4) .

The MultiToken contract stores this ExternalInfo without additional key validation at [6](#0-5) . Subsequently, these injected keys affect protocol behavior - for example, `__nft_create_chain_id` is enforced during NFT item creation at [7](#0-6) , and callback keys trigger arbitrary contract calls during transfers at [8](#0-7) .

### Impact Explanation

**Primary Impacts:**

1. **NFT Minting DoS**: A malicious protocol creator can set `__nft_create_chain_id` to an incorrect chain ID, preventing legitimate NFT item creation on the intended chain and effectively disabling the protocol's core functionality.

2. **Malicious Callback Execution**: Injection of callback keys (`aelf_transfer_callback`, `aelf_lock_callback`, `aelf_unlock_callback`) allows specification of arbitrary contract addresses and methods that will be invoked during every transfer, lock, or unlock operation. This enables:
   - Reentrancy attacks against users interacting with the protocol
   - Unauthorized state modifications during supposedly safe token operations
   - Gas griefing or DoS of transfer operations

3. **User Trust Exploitation**: Users who trust an NFT protocol creator may unknowingly interact with protocols containing hidden malicious callbacks, leading to unexpected fund loss or contract state corruption.

The severity is Medium because while the protocol creator must initially deploy the malicious protocol, unsuspecting users subsequently suffer the consequences during normal operations.

### Likelihood Explanation

**Attack Complexity**: Low - requires only standard NFT protocol creation with specially crafted metadata.

**Attacker Capabilities**: Any user can call the public `NFTContract.Create()` method. No special privileges required beyond normal protocol creation rights.

**Execution Steps**:
1. Attacker prepares CreateInput with metadata containing `{"__nft_create_chain_id": "999999"}` or `{"aelf_transfer_callback": "{malicious_contract_and_method}"}`
2. Calls `NFTContract.Create()` on mainchain
3. Metadata passes validation since these keys aren't in the reserved list
4. Protocol is created with malicious ExternalInfo
5. When users mint NFT items or transfer tokens, the injected keys take effect

**Detection Difficulty**: High - ExternalInfo is not prominently displayed, and users typically don't inspect protocol metadata before interacting.

**Economic Rationality**: The attack cost is minimal (just protocol creation transaction fees), while the impact on users can be significant. Likelihood assessment: Medium-High.

### Recommendation

**Immediate Fix**: Expand the reserved keys list in `GetNftMetadataReservedKeys()` to include all MultiToken contract special keys: [1](#0-0) 

Add the following keys to the returned list:
- `TokenContractConstants.NftCreateChainIdExternalInfoKey`
- `TokenContractConstants.TransferCallbackExternalInfoKey`
- `TokenContractConstants.LockCallbackExternalInfoKey`
- `TokenContractConstants.UnlockCallbackExternalInfoKey`
- `TokenContractConstants.LogEventExternalInfoKey`
- `TokenContractConstants.TokenAliasExternalInfoKey`
- `TokenContractConstants.SeedOwnedSymbolExternalInfoKey`
- `TokenContractConstants.SeedExpireTimeExternalInfoKey`

**Additional Safeguard**: Consider adding ExternalInfo key validation in the MultiToken contract's `AssertValidCreateInput()` method at [9](#0-8)  to enforce that only system contracts or whitelisted addresses can set special keys.

**Test Cases**: Add unit tests verifying that NFT protocol creation fails when metadata contains any MultiToken special keys.

### Proof of Concept

**Initial State**: Attacker has sufficient balance for protocol creation transaction fees.

**Attack Steps**:

1. Attacker prepares malicious CreateInput:
```
input.Metadata = {
  "__nft_create_chain_id": "9992731"  // Invalid chain ID
}
```

2. Attacker calls `NFTContract.Create(input)` on AELF mainchain

3. **Expected (Secure) Result**: Transaction should revert with "Metadata key __nft_create_chain_id is reserved."

4. **Actual (Vulnerable) Result**: Transaction succeeds. Protocol is created with the malicious ExternalInfo.

5. When any user attempts to mint NFT items for this protocol, the operation fails with "NFT create ChainId must be collection's NFT create chainId" at [10](#0-9) , effectively DoSing the entire protocol.

**Success Condition**: Protocol creation succeeds with injected special keys that shouldn't be user-controllable, demonstrating the incomplete validation.

**Notes**

The vulnerability stems from architectural inconsistency between the NFT and MultiToken contracts. The NFT contract validates only its own domain-specific keys, unaware that the MultiToken contract has additional special keys with security implications. This creates a confused deputy problem where the NFT contract inadvertently facilitates injection of MultiToken control parameters. While the protocol creator is the initial attacker, the downstream impact falls on protocol users who have no visibility into the injected metadata.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L97-107)
```csharp
    private List<string> GetNftMetadataReservedKeys()
    {
        return new List<string>
        {
            NftTypeMetadataKey,
            NftBaseUriMetadataKey,
            AssembledNftsKey,
            AssembledFtsKey,
            NftTokenIdReuseMetadataKey
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-26)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
    public const string LockCallbackExternalInfoKey = "aelf_lock_callback";
    public const string UnlockCallbackExternalInfoKey = "aelf_unlock_callback";
    public const string LogEventExternalInfoKey = "aelf_log_event";
    public const string TokenAliasExternalInfoKey = "aelf_token_alias";
    public const int DELEGATEE_MAX_COUNT = 24;
    public const char NFTSymbolSeparator = '-';
    public const int NFTSymbolMaxLength = 30;
    public const string UserContractMethodFeeKey = "UserContractMethodFee";
    public const string CollectionSymbolSuffix = "0";
    public const string SeedCollectionSymbol = "SEED-0";
    public const string SeedOwnedSymbolExternalInfoKey = "__seed_owned_symbol";
    public const string SeedExpireTimeExternalInfoKey = "__seed_exp_time";
    public const string NftCreateChainIdExternalInfoKey = "__nft_create_chain_id";
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L32-34)
```csharp
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L186-186)
```csharp
        if (input.Metadata != null) AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L118-123)
```csharp
    private void AssertMetadataKeysAreCorrect(IEnumerable<string> metadataKeys)
    {
        var reservedMetadataKey = GetNftMetadataReservedKeys();
        foreach (var metadataKey in metadataKeys)
            Assert(!reservedMetadataKey.Contains(metadataKey), $"Metadata key {metadataKey} is reserved.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L22-28)
```csharp
        if (nftCollectionInfo.ExternalInfo != null && nftCollectionInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.NftCreateChainIdExternalInfoKey,
                out var nftCreateChainId) && long.TryParse(nftCreateChainId, out var nftCreateChainIdLong))
        {
            Assert(nftCreateChainIdLong == Context.ChainId,
                "NFT create ChainId must be collection's NFT create chainId");
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L341-347)
```csharp
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }
```
