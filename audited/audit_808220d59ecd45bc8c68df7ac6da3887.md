### Title
Missing Authorization Check in ContributeProfits Allows Unauthorized Profit Contributions and Forced Auto-Distributions

### Summary
The `ContributeProfits()` function in TokenHolderContract lacks authorization validation, allowing any user to contribute profits to any scheme without the scheme manager's permission. When combined with the `AutoDistributeThreshold` mechanism, this enables attackers to force premature profit distributions by contributing tokens to push the balance over the threshold, disrupting the scheme manager's intended distribution schedule.

### Finding Description

The `ContributeProfits()` function only validates that the target scheme exists but does not verify that the caller has permission from the scheme manager. [1](#0-0) 

Specifically, at line 102, the function calls `GetValidScheme(input.SchemeManager)` which only checks if the scheme exists, not whether `Context.Sender` is authorized. [2](#0-1) 

This is inconsistent with other scheme management methods like `AddBeneficiary` which properly validate authorization by calling `GetValidScheme(Context.Sender)`, ensuring only the scheme manager can modify the scheme. [3](#0-2) 

The root cause is that `GetValidScheme()` receives the manager address as a parameter instead of verifying that `Context.Sender` matches the manager. The underlying Profit contract's `ContributeProfits()` also lacks authorization checks. [4](#0-3) 

When a scheme has `AutoDistributeThreshold` configured, the `RegisterForProfits()` function automatically triggers profit distribution if the virtual address balance meets any threshold. An attacker can exploit this by contributing tokens to reach the threshold, forcing distribution. [5](#0-4) 

### Impact Explanation

**Loss of Scheme Manager Control**: The scheme manager loses control over the timing of profit distributions. Even though `DistributeProfits()` itself requires authorization, the auto-distribution mechanism bypasses this when triggered through `RegisterForProfits()`. [6](#0-5) 

**Forced Premature Distribution**: An attacker can force distribution before the scheme manager intends by:
1. Contributing enough tokens to reach the AutoDistributeThreshold
2. Waiting for any user to call RegisterForProfits (or calling it themselves)
3. Triggering automatic distribution without manager approval

**Operational Disruption**: This violates the authorization invariant that scheme managers should maintain exclusive control over distribution timing and scheme operations. While the attacker must spend real tokens, they can grief the manager's operational schedule at relatively low cost.

**Severity Justification**: Medium severity - does not directly steal funds or corrupt beneficiary shares, but violates authorization controls and allows operational disruption of profit distribution schedules, particularly affecting schemes relying on AutoDistributeThreshold for automated management.

### Likelihood Explanation

**Reachable Entry Point**: `ContributeProfits()` is a public method callable by any address with no restrictions. [7](#0-6) 

**Attacker Capabilities**: The attacker only needs:
- Sufficient tokens of the target symbol
- Token approval for the TokenHolder contract (via standard Approve mechanism)
- Knowledge of the target scheme manager address

**Execution Practicality**: The attack is straightforward:
1. Identify a scheme with AutoDistributeThreshold set
2. Calculate needed contribution amount to reach threshold  
3. Approve TokenHolder contract and call ContributeProfits
4. Wait for next RegisterForProfits call to trigger auto-distribution

**Economic Rationality**: While the attacker must spend real tokens, the cost can be minimal (just enough to push over threshold) and may be worthwhile for:
- Competitors wanting to disrupt distribution timing
- Malicious actors targeting specific schemes
- Accidental misuse by users not understanding the permission model

**Detection Constraints**: No authorization check exists, so the transaction will succeed normally. Test coverage confirms lack of authorization validation - there are tests for `DistributeProfits_Without_Authority_Test` but none for ContributeProfits authorization. [8](#0-7) 

### Recommendation

**Authorization Check**: Add authorization validation to `ContributeProfits()` to ensure only the scheme manager can contribute profits:

```csharp
public override Empty ContributeProfits(ContributeProfitsInput input)
{
    var scheme = GetValidScheme(input.SchemeManager);
    Assert(Context.Sender == input.SchemeManager, 
           "Only scheme manager can contribute profits.");
    // ... rest of implementation
}
```

**Alternative Approach**: If allowing public contributions is intentional design, add an explicit opt-in flag in the scheme creation:

```csharp
message CreateTokenHolderProfitSchemeInput {
    string symbol = 1;
    int64 minimum_lock_minutes = 2;
    map<string, int64> auto_distribute_threshold = 3;
    bool allow_public_contributions = 4; // New field
}
```

Then check this flag in ContributeProfits before allowing non-manager contributions.

**Test Cases**: Add regression test `ContributeProfits_Without_Authority_Test` similar to the existing DistributeProfits authorization test to validate that unauthorized contributions are rejected.

### Proof of Concept

**Initial State**:
- SchemeManager Alice creates a TokenHolder scheme for symbol "ELF"
- AutoDistributeThreshold set to 10,000 ELF  
- Alice contributes 9,900 ELF to the scheme
- Scheme has beneficiaries registered

**Attack Sequence**:
1. Attacker Bob approves TokenHolder contract to spend 100 ELF
2. Bob calls `ContributeProfits(scheme_manager: Alice, amount: 100, symbol: "ELF")`
3. Transaction succeeds despite Bob not being the scheme manager
4. Virtual address balance is now 10,000 ELF (reaching threshold)
5. Any user calling `RegisterForProfits()` triggers auto-distribution via lines 179-206
6. Profits are distributed prematurely without Alice's explicit approval

**Expected Result**: Transaction at step 2 should fail with "Only scheme manager can contribute profits."

**Actual Result**: Transaction succeeds, allowing Bob to force distribution timing by pushing balance over AutoDistributeThreshold.

**Success Condition**: After step 3, verify that balance reached 10,000 ELF despite Bob not being authorized, and that subsequent RegisterForProfits call triggers unwanted auto-distribution.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-39)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L100-129)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.Self,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        State.TokenContract.Approve.Send(new ApproveInput
        {
            Spender = State.ProfitContract.Value,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        State.ProfitContract.ContributeProfits.Send(new Profit.ContributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Symbol = input.Symbol,
            Amount = input.Amount
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L131-147)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager, true);
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
        var distributeProfitsInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
        if (input.AmountsMap != null && input.AmountsMap.Any()) distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

        State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
        scheme.Period = scheme.Period.Add(1);
        State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L178-206)
```csharp
        // Check auto-distribute threshold.
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-284)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-666)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }

        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null)
        {
            throw new AssertionException("Scheme not found.");
        }
```

**File:** protobuf/token_holder_contract.proto (L32-34)
```text
    // Contribute profit to a scheme.
    rpc ContributeProfits (ContributeProfitsInput) returns (google.protobuf.Empty) {
    }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L288-303)
```csharp
    public async Task DistributeProfits_Without_Authority_Test()
    {
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "Test"
        });
        var senderWithoutAuthority =
            GetTester<TokenHolderContractImplContainer.TokenHolderContractImplStub>(TokenHolderContractAddress,
                UserKeyPairs.First());
        var distributeRet = await senderWithoutAuthority.DistributeProfits.SendWithExceptionAsync(
            new DistributeProfitsInput
            {
                SchemeManager = Starter
            });
        distributeRet.TransactionResult.Error.ShouldContain("No permission to distribute profits");
    }
```
