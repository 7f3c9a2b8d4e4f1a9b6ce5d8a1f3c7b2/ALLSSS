### Title
Resource Exhaustion in GetCandidateVoteWithAllRecords Due to Unbounded Vote Record Retrieval

### Summary
The `GetCandidateVoteWithAllRecords()` view method attempts to retrieve and return all active and withdrawn vote records for a candidate without any pagination or size limits. Popular candidates who accumulate thousands of vote records over time will cause this query to retrieve excessive data, potentially exhausting memory, timing out, or crashing query services. This creates a denial-of-service vulnerability for retrieving vote information from popular candidates.

### Finding Description

The vulnerability exists in the `GetCandidateVoteWithAllRecords()` method which retrieves all voting records for a candidate without pagination: [1](#0-0) 

The method first calls `GetCandidateVoteWithRecords(input)` which makes a cross-contract call to the Vote contract passing ALL active voting record IDs: [2](#0-1) 

Then it retrieves ALL withdrawn voting record IDs in a second cross-contract call. The Vote contract's `GetVotingRecords` method has no size limits and simply iterates through all provided IDs: [3](#0-2) 

Vote records accumulate indefinitely in the `CandidateVote` structure. Each vote adds to `ObtainedActiveVotingRecordIds` and withdrawn votes move to `ObtainedWithdrawnVotingRecordIds` but are never deleted: [4](#0-3) [5](#0-4) 

The protobuf definitions show these are unbounded `repeated` fields with no maximum size constraints: [6](#0-5) [7](#0-6) 

Notably, the same contract implements pagination correctly in `GetPageableCandidateInformation` with a hard limit of 20 items per query, demonstrating awareness of the need for pagination: [8](#0-7) 

However, this pattern was not applied to `GetCandidateVoteWithAllRecords` or the similar `GetElectorVoteWithAllRecords` method.

### Impact Explanation

**Operational Denial-of-Service**: Query services become unresponsive or crash when attempting to retrieve vote information for popular candidates. A candidate with 10,000 accumulated votes would cause retrieval of 10,000+ `VotingRecord` objects (each containing timestamps, addresses, amounts, and other data totaling ~200+ bytes), resulting in 2+ MB of data being loaded, transformed, and serialized in a single query.

**Affected Parties**: 
- API node operators serving view method queries experience service degradation or crashes
- Users and applications attempting to query candidate voting information for popular candidates
- Monitoring and analytics systems that need to track voting patterns

**Severity Justification**: HIGH severity because:
1. The attack vector is trivial (single view method call)
2. No authentication or cost required
3. Popular candidates will naturally accumulate thousands of votes over months of operation
4. The DoS affects critical election information retrieval
5. Similar patterns exist in `GetElectorVoteWithAllRecords`, multiplying the attack surface

### Likelihood Explanation

**Attacker Capabilities Required**: None - any user can call the public view method with zero cost.

**Attack Complexity**: Minimal - simply call `GetCandidateVoteWithAllRecords` with a popular candidate's public key.

**Feasibility Conditions**: 
- Popular candidates naturally accumulate thousands of votes through normal system operation
- Vote records are never pruned or archived, growing indefinitely
- The state size limit of 128KB applies to individual state writes, not view method return values or cross-contract call responses [9](#0-8) 

**Detection/Prevention**: No rate limiting or size checks exist in the view method execution path. The vulnerability manifests immediately when querying candidates with large voting histories.

**Probability Assessment**: HIGH - this will inevitably occur in production as popular candidates accumulate voting records over time through legitimate system usage.

### Recommendation

1. **Implement Pagination**: Add pagination parameters to `GetCandidateVoteWithAllRecords` following the pattern used in `GetPageableCandidateInformation`:

```csharp
public override CandidateVote GetCandidateVoteWithAllRecords(GetCandidateVoteWithRecordsInput input)
{
    var votes = State.CandidateVotes[input.CandidatePubkey];
    if (votes == null) return new CandidateVote();
    
    // Enforce maximum page size
    var activeStart = Math.Min(input.ActiveStart, votes.ObtainedActiveVotingRecordIds.Count);
    var activeLength = Math.Min(Math.Min(input.ActiveLength, 100), 
                                 votes.ObtainedActiveVotingRecordIds.Count - activeStart);
    
    var withdrawnStart = Math.Min(input.WithdrawnStart, votes.ObtainedWithdrawnVotingRecordIds.Count);
    var withdrawnLength = Math.Min(Math.Min(input.WithdrawnLength, 100),
                                    votes.ObtainedWithdrawnVotingRecordIds.Count - withdrawnStart);
    
    // Retrieve only requested page of active records
    var activeIds = votes.ObtainedActiveVotingRecordIds.Skip(activeStart).Take(activeLength).ToList();
    // Similar for withdrawn records...
}
```

2. **Add Corresponding Protobuf Changes**: Define paginated input message with start/length parameters for both active and withdrawn records.

3. **Apply Same Fix to GetElectorVoteWithAllRecords**: The elector records method has the identical vulnerability and requires the same pagination pattern.

4. **Add Integration Tests**: Create test cases with candidates/electors having 1000+ vote records to verify pagination works correctly and queries don't timeout.

5. **Consider Archive Mechanism**: For very old withdrawn votes, implement an optional archival process to reduce the working set of records that need pagination.

### Proof of Concept

**Initial State:**
- Candidate C has registered for election
- Over 6 months of operation, 5,000 different voters have voted for candidate C
- 3,000 of those votes have been withdrawn
- Candidate C now has 2,000 active vote record IDs and 3,000 withdrawn vote record IDs in state

**Attack Steps:**
1. Attacker (or any user/application) calls: `GetCandidateVoteWithAllRecords(StringValue{Value: C.PublicKey})`
2. The method loads all 5,000 vote IDs from candidate state
3. Makes cross-contract call to Vote contract with 2,000 active IDs
4. Makes second cross-contract call with 3,000 withdrawn IDs  
5. Vote contract attempts to load and serialize 5,000 `VotingRecord` objects
6. Election contract transforms all 5,000 records to `ElectionVotingRecord` format
7. Attempts to serialize and return ~1MB+ protobuf message

**Expected Result:** Query completes and returns all records

**Actual Result:** Query times out, consumes excessive memory, or crashes the query service due to attempting to process thousands of records in a single operation

**Success Condition:** Repeated calls to this method for popular candidates cause API nodes to become unresponsive, demonstrating the denial-of-service impact.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L240-258)
```csharp
    public override GetPageableCandidateInformationOutput GetPageableCandidateInformation(PageInformation input)
    {
        var output = new GetPageableCandidateInformationOutput();
        var candidates = State.Candidates.Value;

        var count = candidates.Value.Count;
        if (count <= input.Start) return output;

        var length = Math.Min(Math.Min(input.Length, 20), candidates.Value.Count.Sub(input.Start));
        foreach (var candidate in candidates.Value.Skip(input.Start).Take(length))
            output.Value.Add(new CandidateDetail
            {
                CandidateInformation = State.CandidateInformationMap[candidate.ToHex()],
                ObtainedVotesAmount = GetCandidateVote(new StringValue { Value = candidate.ToHex() })
                    .ObtainedActiveVotedVotesAmount
            });

        return output;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L268-286)
```csharp
    public override CandidateVote GetCandidateVoteWithRecords(StringValue input)
    {
        var votes = State.CandidateVotes[input.Value];
        if (votes == null)
            return new CandidateVote();

        var obtainedRecords = State.VoteContract.GetVotingRecords.Call(new GetVotingRecordsInput
        {
            Ids = { votes.ObtainedActiveVotingRecordIds }
        }).Records;
        var index = 0;
        foreach (var record in obtainedRecords)
        {
            var voteId = votes.ObtainedActiveVotingRecordIds[index++];
            votes.ObtainedActiveVotingRecords.Add(TransferVotingRecordToElectionVotingRecord(record, voteId));
        }

        return votes;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L288-305)
```csharp
    public override CandidateVote GetCandidateVoteWithAllRecords(StringValue input)
    {
        var votes = GetCandidateVoteWithRecords(input);

        //get withdrawn records
        var obtainedWithdrawnRecords = State.VoteContract.GetVotingRecords.Call(new GetVotingRecordsInput
        {
            Ids = { votes.ObtainedWithdrawnVotingRecordIds }
        }).Records;
        var index = 0;
        foreach (var record in obtainedWithdrawnRecords)
        {
            var voteId = votes.ObtainedWithdrawnVotingRecordIds[index++];
            votes.ObtainedWithdrawnVotesRecords.Add(TransferVotingRecordToElectionVotingRecord(record, voteId));
        }

        return votes;
    }
```

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L8-13)
```csharp
    public override VotingRecords GetVotingRecords(GetVotingRecordsInput input)
    {
        var votingRecords = new VotingRecords();
        votingRecords.Records.AddRange(input.Ids.Select(id => State.VotingRecords[id]));
        return votingRecords;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L546-571)
```csharp
    private long UpdateCandidateInformation(string candidatePublicKey, long amount, Hash voteId)
    {
        var candidateVotes = State.CandidateVotes[candidatePublicKey];
        if (candidateVotes == null)
        {
            candidateVotes = new CandidateVote
            {
                Pubkey = ByteStringHelper.FromHexString(candidatePublicKey),
                ObtainedActiveVotingRecordIds = { voteId },
                ObtainedActiveVotedVotesAmount = amount,
                AllObtainedVotedVotesAmount = amount
            };
        }
        else
        {
            candidateVotes.ObtainedActiveVotingRecordIds.Add(voteId);
            candidateVotes.ObtainedActiveVotedVotesAmount =
                candidateVotes.ObtainedActiveVotedVotesAmount.Add(amount);
            candidateVotes.AllObtainedVotedVotesAmount =
                candidateVotes.AllObtainedVotedVotesAmount.Add(amount);
        }

        State.CandidateVotes[candidatePublicKey] = candidateVotes;

        return candidateVotes.ObtainedActiveVotedVotesAmount;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L650-660)
```csharp
        // Update Candidate's Votes information.
        var newestPubkey = GetNewestPubkey(votingRecord.Option);
        var candidateVotes = State.CandidateVotes[newestPubkey];

        Assert(candidateVotes != null, $"Newest pubkey {newestPubkey} is invalid. Old pubkey is {votingRecord.Option}");

        candidateVotes.ObtainedActiveVotingRecordIds.Remove(input);
        candidateVotes.ObtainedWithdrawnVotingRecordIds.Add(input);
        candidateVotes.ObtainedActiveVotedVotesAmount =
            candidateVotes.ObtainedActiveVotedVotesAmount.Sub(votingRecord.Amount);
        State.CandidateVotes[newestPubkey] = candidateVotes;
```

**File:** protobuf/election_contract.proto (L348-363)
```text
message CandidateVote {
    // The active voting record ids obtained.
    repeated aelf.Hash obtained_active_voting_record_ids = 1;
    // The active voting record ids that were withdrawn.
    repeated aelf.Hash obtained_withdrawn_voting_record_ids = 2;
    // The total number of active votes obtained.
    int64 obtained_active_voted_votes_amount = 3;
    // The total number of votes obtained.
    int64 all_obtained_voted_votes_amount = 4;
    // The active voting records.
    repeated ElectionVotingRecord obtained_active_voting_records = 5;
    // The voting records that were withdrawn.
    repeated ElectionVotingRecord obtained_withdrawn_votes_records = 6;
    // Public key for candidate.
    bytes pubkey = 7;
}
```

**File:** protobuf/vote_contract.proto (L259-267)
```text
message GetVotingRecordsInput {
    // The vote ids.
    repeated aelf.Hash ids = 1;
}

message VotingRecords {
    // The voting records.
    repeated VotingRecord records = 1;
}
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```
