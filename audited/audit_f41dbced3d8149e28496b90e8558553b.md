# Audit Report

## Title
NFT Item ID Leading Zero Bypass Allows Duplicate NFT Creation for Same Logical Item

## Summary
The MultiToken contract's NFT validation accepts item IDs with arbitrary leading zeros (e.g., "1", "01", "001") due to a permissive regex pattern. Since NFT symbols are stored using the exact string without normalization and the case-insensitive uniqueness check (`ToUpper()`) does not normalize numeric characters, different leading zero variants like "COLLECTION-1" and "COLLECTION-01" are treated as completely separate NFTs. This violates the fundamental NFT uniqueness invariant, allowing unlimited duplicate NFTs to be created for any given item number.

## Finding Description

The vulnerability stems from the interaction between validation logic and storage mechanisms in the NFT creation flow.

**Root Cause - Permissive Validation:**
The `IsValidItemId()` method uses the regex pattern `^[0-9]+$` which accepts any sequence of digits without restricting leading zeros. [1](#0-0) 

This validation is invoked during symbol type determination where the item ID portion is extracted and validated but never normalized. [2](#0-1) 

**Why Uniqueness Checks Fail:**
When checking if an NFT already exists, the contract performs two checks: exact symbol lookup and case-insensitive existence check. [3](#0-2) 

The critical flaw is that `symbol.ToUpper()` only uppercases alphabetic characters and does NOT normalize numeric digits. Therefore:
- "COLLECTION-1".ToUpper() = "COLLECTION-1"
- "COLLECTION-01".ToUpper() = "COLLECTION-01"
- These are different storage keys and both pass the uniqueness check.

**Storage Without Normalization:**
NFT symbols are stored directly as keys in state storage without any normalization of the item ID component. [4](#0-3) 

**Execution Flow:**
1. Collection owner creates NFT collection "TEST-0"
2. Owner calls `Create` with symbol "TEST-1" (TotalSupply=1) - succeeds [5](#0-4) 
3. Owner calls `Create` with symbol "TEST-01" (TotalSupply=1) - also succeeds as it's a different storage key
4. Owner calls `Create` with symbol "TEST-001" (TotalSupply=1) - also succeeds
5. Each variant is registered as a separate token with independent TokenInfo, supply, and balances [6](#0-5) 

Authorization check only verifies the caller is the collection owner, which is standard for NFT creation. [7](#0-6) 

## Impact Explanation

**NFT Uniqueness Invariant Violation:**
This fundamentally breaks the core assumption that each NFT item ID within a collection represents a unique digital asset. Multiple on-chain NFTs can exist for what should be a single logical item.

**Direct Supply Inflation:**
Each leading zero variant creates an independent NFT with its own TotalSupply. For ERC-721 style NFTs intended to have TotalSupply=1 per item, an attacker can create unlimited "copies" ("COLLECTION-01", "COLLECTION-001", etc.), each with TotalSupply=1.

**Ownership and Authenticity Confusion:**
Different users can own different variants ("COLLECTION-1" vs "COLLECTION-00001") of what appears to be the same NFT. Marketplaces and applications that normalize display ("Item #1") would show these as identical items, but they have completely separate on-chain ownership, balances, and state.

**Fraud Potential:**
A malicious collection owner could:
- Sell "COLLECTION-1" as the authentic NFT to one buyer
- Later mint "COLLECTION-01", "COLLECTION-001" and sell those to other buyers
- Claim each is legitimate since all pass validation
- Exploit different normalization behaviors across platforms and wallets

**Protocol-Wide Impact:**
This affects ALL NFT collections created through the MultiToken contract, as the validation logic applies universally to all NFT symbol validation.

## Likelihood Explanation

**Publicly Accessible Entry Point:**
The `Create` method is publicly accessible and routes to NFT creation for symbols matching the NFT pattern. No special permissions beyond standard NFT creation requirements are needed.

**Attacker Requirements:**
The attacker must be the collection owner, which is the standard authorization for creating NFTs within a collection. This is not a privilege escalation - it's a protocol logic flaw that allows legitimate collection owners to bypass uniqueness guarantees.

**Trivial Execution:**
The attack requires only standard NFT creation calls:
1. Create collection "TEST-0" (standard)
2. Call `Create` with "TEST-1" (succeeds)
3. Call `Create` with "TEST-01" (also succeeds - vulnerability)
4. Repeat with "TEST-001", "TEST-0001", etc.

No complex state manipulation, transaction ordering, or timing requirements exist.

**Detection Difficulty:**
The vulnerability is difficult to detect because:
- The test suite lacks test cases for leading zero scenarios (confirmed via code inspection) [8](#0-7) 
- Visual displays typically show "Item #1" for all variants
- Each variant passes all validation checks successfully
- No warnings or exceptional events are emitted

**Economic Rationality:**
The attack cost equals standard NFT creation cost. No additional gas or economic barriers exist beyond creating legitimate NFTs, making it economically viable for any value theft.

## Recommendation

**Normalize Item IDs Before Storage:**
Parse the item ID portion as an integer and convert it back to a string without leading zeros before any storage or comparison operations:

```csharp
private string NormalizeItemId(string itemId)
{
    // Parse as long to remove leading zeros, then convert back
    if (long.TryParse(itemId, out var numericId))
    {
        return numericId.ToString();
    }
    return itemId; // Fallback for edge cases
}
```

**Update CheckTokenExists:**
Apply normalization in the uniqueness check:
```csharp
private void CheckTokenExists(string symbol)
{
    // Split and normalize if NFT symbol
    var parts = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
    if (parts.Length == 2 && IsValidItemId(parts[1]))
    {
        var normalizedSymbol = $"{parts[0]}-{NormalizeItemId(parts[1])}";
        // Check using normalized symbol
        var existing = GetTokenInfo(normalizedSymbol);
        Assert(existing == null || existing.Equals(new TokenInfo()), "Token already exists.");
        Assert(!State.InsensitiveTokenExisting[normalizedSymbol.ToUpper()], "Token already exists.");
    }
    else
    {
        // Existing logic for non-NFT tokens
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(new TokenInfo()), "Token already exists.");
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
}
```

**Update Storage:**
Normalize before storing in RegisterTokenInfo and all other state operations to ensure consistent keys.

## Proof of Concept

```csharp
[Fact]
public async Task NFT_LeadingZero_Bypass_Creates_Duplicate_NFTs()
{
    // Setup: Create NFT collection
    var collectionSymbol = "TEST-";
    await CreateNftCollectionAsync(new TokenInfo
    {
        Symbol = collectionSymbol,
        TokenName = "Test Collection",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = Accounts[0].Address,
        Owner = Accounts[0].Address,
        IssueChainId = _chainId
    });

    // Create NFT with item ID "1"
    var nftSymbol1 = "TEST-1";
    var result1 = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = nftSymbol1,
        TokenName = "NFT Item 1",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = Accounts[0].Address,
        Owner = Accounts[0].Address,
        IsBurnable = true,
        IssueChainId = _chainId
    });
    result1.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify NFT "TEST-1" exists
    var tokenInfo1 = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = nftSymbol1 });
    tokenInfo1.Symbol.ShouldBe(nftSymbol1);
    tokenInfo1.TotalSupply.ShouldBe(1);

    // VULNERABILITY: Create NFT with leading zero "01" - should fail but succeeds
    var nftSymbol01 = "TEST-01";
    var result01 = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = nftSymbol01,
        TokenName = "NFT Item 01",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = Accounts[0].Address,
        Owner = Accounts[0].Address,
        IsBurnable = true,
        IssueChainId = _chainId
    });
    
    // This should fail with "Token already exists" but it succeeds
    result01.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify both NFTs exist as separate tokens
    var tokenInfo01 = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = nftSymbol01 });
    tokenInfo01.Symbol.ShouldBe(nftSymbol01);
    tokenInfo01.TotalSupply.ShouldBe(1);
    
    // PROOF: Two separate NFTs exist for the same logical item #1
    tokenInfo1.Symbol.ShouldNotBe(tokenInfo01.Symbol); // Different symbols
    // Both represent "Item #1" logically but are stored separately
    
    // Can continue with "TEST-001", "TEST-0001", etc. - all succeed
    var nftSymbol001 = "TEST-001";
    var result001 = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = nftSymbol001,
        TokenName = "NFT Item 001",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = Accounts[0].Address,
        Owner = Accounts[0].Address,
        IsBurnable = true,
        IssueChainId = _chainId
    });
    result001.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // All three NFTs exist independently for what should be a single unique item
    var tokenInfo001 = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = nftSymbol001 });
    tokenInfo001.Symbol.ShouldBe(nftSymbol001);
}
```

## Notes

This vulnerability affects the core NFT uniqueness guarantee of the MultiToken contract. While the attacker must be the collection owner (standard authorization for NFT creation), this is NOT a privilege escalation - it's a protocol design flaw that allows legitimate collection owners to bypass fundamental uniqueness constraints. The issue is that the protocol should enforce NFT uniqueness regardless of who creates them, and the current implementation fails to do so due to lack of item ID normalization.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L23-26)
```csharp
    private bool IsValidItemId(string symbolItemId)
    {
        return Regex.IsMatch(symbolItemId, "^[0-9]+$");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L232-233)
```csharp
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L48-116)
```csharp
    private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
    {
        AssertValidCreateInput(input, symbolType);
        if (symbolType == SymbolType.Token || symbolType == SymbolType.NftCollection)
        {
            // can not call create on side chain
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
        }

        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };

        if (IsAliasSettingExists(tokenInfo))
        {
            Assert(symbolType == SymbolType.NftCollection, "Token alias can only be set for NFT Item.");
            SetTokenAlias(tokenInfo);
        }

        CheckTokenExists(tokenInfo.Symbol);
        RegisterTokenInfo(tokenInfo);
        if (string.IsNullOrEmpty(State.NativeTokenSymbol.Value))
        {
            Assert(Context.Variables.NativeSymbol == input.Symbol, "Invalid native token input.");
            State.NativeTokenSymbol.Value = input.Symbol;
        }

        var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Select(m => m.Value);
        var isSystemContractAddress = input.LockWhiteList.All(l => systemContractAddresses.Contains(l));
        Assert(isSystemContractAddress, "Addresses in lock white list should be system contract addresses");
        foreach (var address in input.LockWhiteList) State.LockWhiteLists[input.Symbol][address] = true;

        Context.LogDebug(() => $"Token created: {input.Symbol}");

        Context.Fire(new TokenCreated
        {
            Symbol = tokenInfo.Symbol,
            TokenName = tokenInfo.TokenName,
            TotalSupply = tokenInfo.TotalSupply,
            Decimals = tokenInfo.Decimals,
            Issuer = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            ExternalInfo = tokenInfo.ExternalInfo,
            Owner = tokenInfo.Owner
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L35-36)
```csharp
        var owner = nftCollectionInfo.Owner ?? nftCollectionInfo.Issuer;
        Assert(Context.Sender == owner && owner == input.Owner, "NFT owner must be collection's owner");
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/SymbolValidationTest.cs (L11-22)
```csharp
    [Theory]
    [InlineData("ELF", true)]
    [InlineData("ELF-", false)]
    [InlineData("ABC-123", true)]
    [InlineData("abc-1", true)]
    [InlineData("ABC-ABC", false)]
    [InlineData("ABC--", false)]
    [InlineData("121-1", true)]
    public void SymbolValidation(string symbol, bool isValid)
    {
        Regex.IsMatch(symbol, RegexPattern).ShouldBe(isValid);
    }
```
