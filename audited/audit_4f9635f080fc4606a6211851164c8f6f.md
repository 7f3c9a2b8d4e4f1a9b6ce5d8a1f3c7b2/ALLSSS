### Title
Unhandled Exception in GetIndexingProposalStatus View Method Causes DoS of Proposal Status Monitoring

### Summary
The `GetIndexingProposalStatus` view method in the CrossChain contract makes unguarded `Context.Call` invocations to query the authorization contract. When these calls fail due to authorization contract unavailability, misconfiguration, or invalid state, the method throws `ContractCallException`, preventing ANY proposal status queries and creating a complete denial-of-service condition for cross-chain indexing governance monitoring.

### Finding Description

The vulnerability exists in the `GetIndexingProposalStatus` method [1](#0-0) , which is marked as a view method [2](#0-1) .

The method iterates through pending cross-chain indexing proposals and calls the authorization contract to retrieve proposal information without exception handling [3](#0-2) .

According to the `Context.Call` implementation, when the transaction trace is unsuccessful, it throws `ContractCallException` [4](#0-3) , specifically at line 221.

The exception type is defined as a standard smart contract bridge exception [5](#0-4) .

A codebase-wide search confirms that NO contract code uses try-catch blocks around `Context.Call` operations, as this pattern is generally acceptable for action methods that can fail. However, for view methods that serve as critical monitoring interfaces, this creates an availability vulnerability.

The CrossChain indexing controller is initialized during contract deployment [6](#0-5)  and can be changed via governance [7](#0-6) , creating scenarios where the authorization contract address could become invalid or point to an upgraded/unavailable contract.

### Impact Explanation

**Operational Impact - HIGH:**
- Complete denial-of-service for querying cross-chain indexing proposal status
- External clients (UIs, monitoring tools, governance dashboards) cannot check ANY proposal status when even ONE call fails
- Prevents governance participants from determining when proposals are ready for release
- Blocks monitoring of critical cross-chain data indexing operations

**Governance Impact - HIGH:**
- Cross-chain indexing proposals are fundamental to parent/side-chain communication
- Inability to query proposal status disrupts the governance workflow for cross-chain operations
- Affects visibility into the `ToBeReleased` status, expiration times, and approval progress for ALL pending proposals

**Affected Parties:**
- Chain operators monitoring cross-chain indexing
- Governance participants needing to coordinate proposal releases
- External applications relying on proposal status data
- Chain monitoring and alerting systems

The severity is HIGH for operational impact because this is not just about one failed call - it's about the complete unavailability of a critical monitoring function when state becomes inconsistent.

### Likelihood Explanation

**Feasible Preconditions:**
1. Authorization contract address becomes invalid (during upgrades, misconfigurations)
2. Authorization contract GetProposal method fails internally
3. Invalid proposal IDs stored in pending proposals state
4. Authorization contract not properly deployed after system upgrade
5. State inconsistency between CrossChain contract and authorization contracts

**Attack Complexity:** LOW to NONE
- This is not an attack but a natural operational failure scenario
- Requires no attacker capabilities - occurs due to system state issues
- Common during contract upgrades and governance transitions

**Execution Practicality:** HIGH
- The `GetIndexingProposalStatus` method is a public view method accessible to anyone
- The failure is deterministic once problematic state exists
- The condition persists until state is manually corrected

**Probability:** MEDIUM-HIGH
- Contract upgrades are regular operational activities
- Controller changes occur through governance actions
- The risk increases during system maintenance windows
- Once triggered, the condition is persistent and observable

### Recommendation

**Code-level Mitigation:**

Wrap the `Context.Call` in exception handling to ensure robustness:

```csharp
public override GetIndexingProposalStatusOutput GetIndexingProposalStatus(Empty input)
{
    var res = new GetIndexingProposalStatusOutput();
    var pendingCrossChainIndexingProposal = State.IndexingPendingProposal.Value;
    if (pendingCrossChainIndexingProposal == null)
        return res;

    var crossChainIndexingController = GetCrossChainIndexingController();
    foreach (var chainIndexingProposal in pendingCrossChainIndexingProposal.ChainIndexingProposalCollections.Values)
    {
        var pendingChainIndexingProposalStatus = new PendingChainIndexingProposalStatus();
        
        try
        {
            var proposalInfo = Context.Call<ProposalOutput>(crossChainIndexingController.ContractAddress,
                nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.GetProposal),
                chainIndexingProposal.ProposalId);
            
            // Validate non-null and non-default values
            if (proposalInfo != null && proposalInfo.ProposalId != null)
            {
                pendingChainIndexingProposalStatus.ToBeReleased =
                    proposalInfo.ToBeReleased &&
                    proposalInfo.OrganizationAddress == crossChainIndexingController.OwnerAddress;
                pendingChainIndexingProposalStatus.ExpiredTime = proposalInfo.ExpiredTime;
            }
        }
        catch (ContractCallException ex)
        {
            // Log error but continue processing other proposals
            Context.LogDebug(() => $"Failed to get proposal {chainIndexingProposal.ProposalId}: {ex.Message}");
            // Set default/error state for this proposal
            pendingChainIndexingProposalStatus.ToBeReleased = false;
        }
        
        pendingChainIndexingProposalStatus.Proposer = chainIndexingProposal.Proposer;
        pendingChainIndexingProposalStatus.ProposalId = chainIndexingProposal.ProposalId;
        pendingChainIndexingProposalStatus.ProposedCrossChainBlockData =
            chainIndexingProposal.ProposedCrossChainBlockData;
        res.ChainIndexingProposalStatus[chainIndexingProposal.ChainId] = pendingChainIndexingProposalStatus;
    }

    return res;
}
```

**Invariant Checks:**
- Add validation that authorization contract address is valid before calling
- Check that authorization contract is deployed and responsive
- Validate proposal IDs exist before querying

**Test Cases:**
- Test with invalid authorization contract address
- Test with non-existent proposal IDs
- Test with authorization contract that throws exceptions
- Test that other proposals are still queryable when one fails
- Test during contract upgrade scenarios

### Proof of Concept

**Initial State:**
1. CrossChain contract is deployed and initialized
2. Cross-chain indexing proposals are created and stored in `State.IndexingPendingProposal`
3. CrossChain indexing controller is configured with authorization contract address

**Exploitation Steps:**

Step 1: Normal Operation
- Call `GetIndexingProposalStatus()` â†’ Returns proposal status successfully

Step 2: Create Failure Condition (any of these scenarios)
- Upgrade authorization contract to new address without updating controller
- Authorization contract becomes unavailable
- Store invalid proposal ID in pending proposals through state manipulation
- Change controller to point to non-existent contract address

Step 3: Trigger DoS
- Call `GetIndexingProposalStatus()` 
- `Context.Call` at line 172 throws `ContractCallException`
- Entire method fails with exception
- NO proposal status can be queried

**Expected vs Actual Result:**
- **Expected**: View method should return available data, skip problematic proposals, or return partial results
- **Actual**: Entire method fails, preventing ANY proposal status queries

**Success Condition for Exploit:**
- Any external call to `GetIndexingProposalStatus` fails with `ContractCallException`
- All proposal monitoring functionality becomes unavailable
- Condition persists until state is manually corrected through governance intervention

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L161-187)
```csharp
    public override GetIndexingProposalStatusOutput GetIndexingProposalStatus(Empty input)
    {
        var res = new GetIndexingProposalStatusOutput();
        var pendingCrossChainIndexingProposal = State.IndexingPendingProposal.Value;
        if (pendingCrossChainIndexingProposal == null)
            return res;

        var crossChainIndexingController = GetCrossChainIndexingController();
        foreach (var chainIndexingProposal in pendingCrossChainIndexingProposal.ChainIndexingProposalCollections.Values)
        {
            var pendingChainIndexingProposalStatus = new PendingChainIndexingProposalStatus();
            var proposalInfo = Context.Call<ProposalOutput>(crossChainIndexingController.ContractAddress,
                nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.GetProposal),
                chainIndexingProposal.ProposalId);
            pendingChainIndexingProposalStatus.Proposer = chainIndexingProposal.Proposer;
            pendingChainIndexingProposalStatus.ProposalId = chainIndexingProposal.ProposalId;
            pendingChainIndexingProposalStatus.ToBeReleased =
                proposalInfo.ToBeReleased &&
                proposalInfo.OrganizationAddress == crossChainIndexingController.OwnerAddress;
            pendingChainIndexingProposalStatus.ExpiredTime = proposalInfo.ExpiredTime;
            pendingChainIndexingProposalStatus.ProposedCrossChainBlockData =
                chainIndexingProposal.ProposedCrossChainBlockData;
            res.ChainIndexingProposalStatus[chainIndexingProposal.ChainId] = pendingChainIndexingProposalStatus;
        }

        return res;
    }
```

**File:** protobuf/cross_chain_contract.proto (L84-86)
```text
    rpc GetIndexingProposalStatus (google.protobuf.Empty) returns (GetIndexingProposalStatusOutput) {
        option (aelf.is_view) = true;
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L199-226)
```csharp
    public T Call<T>(Address fromAddress, Address toAddress, string methodName, ByteString args)
        where T : IMessage<T>, new()
    {
        var trace = AsyncHelper.RunSync(async () =>
        {
            var chainContext = new ChainContext
            {
                BlockHash = TransactionContext.PreviousBlockHash,
                BlockHeight = TransactionContext.BlockHeight - 1,
                StateCache = CachedStateProvider.Cache
            };

            var tx = new Transaction
            {
                From = fromAddress,
                To = toAddress,
                MethodName = methodName,
                Params = args
            };
            return await _transactionReadOnlyExecutionService.ExecuteAsync(chainContext, tx, CurrentBlockTime);
        });

        if (!trace.IsSuccessful()) throw new ContractCallException(trace.Error);

        var obj = new T();
        obj.MergeFrom(trace.ReturnValue);
        return obj;
    }
```

**File:** src/AElf.Kernel.SmartContract.Shared/ISmartContractBridgeContext.cs (L159-185)
```csharp
public class ContractCallException : SmartContractBridgeException
{
    //
    // For guidelines regarding the creation of new exception types, see
    //    http://msdn.microsoft.com/library/default.asp?url=/library/en-us/cpgenref/html/cpconerrorraisinghandlingguidelines.asp
    // and
    //    http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dncscol/html/csharp07192001.asp
    //

    public ContractCallException()
    {
    }

    public ContractCallException(string message) : base(message)
    {
    }

    public ContractCallException(string message, Exception inner) : base(message, inner)
    {
    }

    protected ContractCallException(
        SerializationInfo info,
        StreamingContext context) : base(info, context)
    {
    }
}
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L47-59)
```csharp
    public override Empty SetInitialIndexingControllerAddress(Address input)
    {
        Assert(State.CrossChainIndexingController.Value == null, "Already initialized.");
        var parliamentContractAddress = State.ParliamentContract.Value;
        Assert(parliamentContractAddress == Context.Sender, "No permission.");
        var initialAuthorityInfo = new AuthorityInfo
        {
            OwnerAddress = input,
            ContractAddress = parliamentContractAddress
        };
        State.CrossChainIndexingController.Value = initialAuthorityInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L61-74)
```csharp
    public override Empty ChangeCrossChainIndexingController(AuthorityInfo input)
    {
        AssertCrossChainIndexingControllerAuthority(Context.Sender);
        SetContractStateRequired(State.ParliamentContract, SmartContractConstants.ParliamentContractSystemName);
        Assert(
            input.ContractAddress == State.ParliamentContract.Value &&
            ValidateParliamentOrganization(input.OwnerAddress), "Invalid authority input.");
        State.CrossChainIndexingController.Value = input;
        Context.Fire(new CrossChainIndexingControllerChanged
        {
            AuthorityInfo = input
        });
        return new Empty();
    }
```
