### Title
Delisted Candidates Can Continue Mining Using Stale RealTimeMinersInformation in AEDPoS

### Summary
The `ValidateHeaderInformation()` function in the AEDPoS consensus contract only verifies that the sender exists in the `RealTimeMinersInformation` map. It does not check with the Election contract to determine whether the miner is still a valid current candidate. As a result, a miner that has been delisted from the candidate set in the Election contract can continue to mine and produce blocks until the end of the current round, leading to potential consensus and reward integrity issues.

### Finding Description
The root cause is in `MiningPermissionValidationProvider.cs`, where mining permission checks are based solely on the `RealTimeMinersInformation` snapshot from the round stored in StateDb; there is no query to the Election contract regarding the sender's current status as a candidate or their vote count. As shown, the function only ensures the `SenderPubkey` exists in the current round's miner information, but never references the Election contract or its state.

The Election contract's `QuitElection` function can set a candidate's status to not current, but this does not cause `RealTimeMinersInformation` to be updated immediately. As a result, unless the consensus round state is refreshed, a removed or banned candidate can continue to participate in consensus and receive mining rewards.

**Relevant execution flow:**
1. Miner is successfully delisted/banned from candidacy via the Election contract.
2. Until the next consensus round, their pubkey remains present in `RealTimeMinersInformation`.
3. The consensus contract checks only for membership in this set during block production permission checks, so the miner is still authorized to mine.
4. The risk persists until the next round is generated, which updates the miner list.

### Impact Explanation
This gap allows a miner who has been delisted (either voluntarily or forcibly, including for malicious conduct) to participate in consensus, propose blocks, and potentially affect consensus finality and protocol economics beyond their legitimate term. It undermines governance actions (like immediate banning), can result in unauthorized block rewards, and may open the door to censorship or protocol abuse by entities explicitly supposed to be excluded from mining. The severity is high due to its direct undermining of consensus and governance decisions.

### Likelihood Explanation
This scenario is fully reachable by external actors:
- Miners can be delisted through valid Election contract actions.
- After delisting, as long as their entry remains in `RealTimeMinersInformation`, they remain eligible to mine due to lack of Election contract integration in the mining permission validation flow.
- No sophisticated attacker capabilities are required; execution is consistent with AElf contract semantics and observable in normal network operations after candidate deletion.
- The exploit remains undetected until the next round update.

### Recommendation
Integrate a real-time check in the mining permission validation logic (i.e., in `ValidateHeaderInformation()`) to confirm with the Election contract that the sender remains a current candidate with valid status, prior to authorizing block production. Alternatively, implement an immediate update to the current round's miner set upon delisting in the Election contract, to ensure consensus and candidate lists are always consistent.

Add regression tests to ensure a banned or delisted miner cannot produce blocks after status loss, even prior to the next consensus round update.

### Proof of Concept

**Initial State:**  
- Pubkey X is a candidate and current miner, present in `RealTimeMinersInformation`.

**Exploit Steps:**  
1. Another actor calls the Election contract to delist or ban Pubkey X (e.g., via `QuitElection`).
2. Pubkey X is no longer a current candidate, but is still in the (old) miner list in AEDPoS round info.
3. Pubkey X continues to submit blocks for the duration of the round. `ValidateHeaderInformation()` authorizes their mining since X is in `RealTimeMinersInformation`.
4. Pubkey X receives consensus rewards and potentially disrupts protocol integrity.

**Success Condition:**  
- Pubkey X, no longer a candidate, mines at least one additional block post-delisting, confirmed by rewards or block signatures.

---

#### Citations [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

---

**Notes:**  
- The vulnerability is limited to a finite time window (until the next round transition) but this can be a significant period, depending on protocol round parameters.
- No Election contract calls or checks are present in the mining-permission validation hot path, confirming the report's premise.
- Fixing requires either proactive or on-demand cross-contract state synchronization.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L129-140)
```csharp
    public MinerList GetMinerList()
    {
        return new MinerList
        {
            Pubkeys = { RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
    }

    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-280)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });

        // Update candidate information.
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;

        // Remove candidate public key from the Voting Item options.
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
        var dataCenterList = State.DataCentersRankingList.Value;
        if (dataCenterList.DataCenters.ContainsKey(pubkey))
        {
            dataCenterList.DataCenters[pubkey] = 0;
            UpdateDataCenterAfterMemberVoteAmountChanged(dataCenterList, pubkey, true);
            State.DataCentersRankingList.Value = dataCenterList;
        }

        var managedCandidatePubkey = State.ManagedCandidatePubkeysMap[Context.Sender];
        managedCandidatePubkey.Value.Remove(ByteString.CopyFrom(pubkeyBytes));
        if (managedCandidatePubkey.Value.Any())
            State.ManagedCandidatePubkeysMap[Context.Sender] = managedCandidatePubkey;
        else
            State.ManagedCandidatePubkeysMap.Remove(Context.Sender);

        State.CandidateSponsorMap.Remove(pubkey);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L282-300)
```csharp
    private void QuitElection(byte[] recoveredPublicKey)
    {
        var publicKeyByteString = ByteString.CopyFrom(recoveredPublicKey);

        Assert(State.Candidates.Value.Value.Contains(publicKeyByteString), "Target is not a candidate.");

        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        if (State.AEDPoSContract.Value != null)
            Assert(
                !State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
                    .Contains(publicKeyByteString),
                "Current miners cannot quit election.");

        State.Candidates.Value.Value.Remove(publicKeyByteString);
    }

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L20-35)
```csharp
    private void UpdateProducedBlocksNumberOfSender(Round input)
    {
        var senderPubkey = Context.RecoverPublicKey().ToHex();

        // Update produced block number of transaction sender.
        if (input.RealTimeMinersInformation.ContainsKey(senderPubkey))
            input.RealTimeMinersInformation[senderPubkey].ProducedBlocks =
                input.RealTimeMinersInformation[senderPubkey].ProducedBlocks.Add(1);
        else
            // If the sender isn't in miner list of next term.
            State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
            {
                Pubkey = senderPubkey,
                RecentlyProducedBlocks = 1
            });
    }
```
