### Title
Inconsistent Profit Detail Matching Logic Enables Wrong Profit Detail Extension for Votes with Identical Weight

### Summary
The `GetProfitDetailByElectionVotingRecord()` function in the Election contract and the `FixProfitDetail()` function in the Profit contract use different fallback matching strategies when dealing with legacy profit details (where Id is null). This inconsistency allows an attacker with multiple old votes of identical weight to extend the wrong profit detail, potentially resurrecting expired votes and claiming unauthorized welfare profits.

### Finding Description

**Root Cause:**

The Election contract's `GetProfitDetailByElectionVotingRecord()` function uses `LastOrDefault` when falling back to Shares-based matching: [1](#0-0) 

However, the Profit contract's `FixProfitDetail()` function uses `OrderBy(d => d.StartPeriod).FirstOrDefault` for the same fallback scenario: [2](#0-1) 

**Why Protections Fail:**

When a voter has multiple legacy profit details (Id=null) with identical Shares values, these two functions will return **different** profit details:
- Election contract returns the **last** matching profit detail
- Profit contract returns the **first** matching profit detail (ordered by StartPeriod)

This mismatch occurs in the `ExtendVoterWelfareProfits()` flow where `GetProfitDetailByElectionVotingRecord()` is used to check if a profit detail exists: [3](#0-2) 

The check at line 141 validates the existence of a profit detail, but the subsequent `FixProfitDetail` call at line 144 may operate on a completely different profit detail.

**Vote Weight Calculation:**

Multiple votes can have identical weight when they have the same amount and lock time, as weight is calculated using a deterministic compound interest formula: [4](#0-3) [5](#0-4) 

### Impact Explanation

**Direct Fund Impact:**

An attacker who owns multiple old votes (created before the Id feature was implemented) with identical weights can exploit this vulnerability to:

1. **Resurrect Expired Profit Details**: Extend the EndPeriod of an already-expired profit detail (one that has passed its intended end period) by pretending to extend a different active vote
2. **Unauthorized Profit Claiming**: Continue claiming welfare profits from the welfare scheme beyond the legitimate period, stealing from the shared profit pool
3. **Manipulation of Profit Distribution**: The attacker's extended profit detail continues to hold shares in the welfare scheme, diluting rewards for legitimate beneficiaries

**Who Is Affected:**

- **Direct victims**: All legitimate welfare scheme beneficiaries who receive reduced profit shares due to the attacker's unauthorized extended participation
- **Protocol integrity**: The election reward distribution mechanism is compromised, as intended time-based reward limits are bypassed

**Severity Justification:**

This is HIGH severity because:
- It allows direct theft of protocol funds through unauthorized profit claiming
- The exploit requires only ownership of votes (legitimate user action), no special privileges
- Legacy data (Id=null profit details) still exists in production systems
- Impact scales with the attacker's vote amounts and number of exploitable vote combinations

### Likelihood Explanation

**Attacker Capabilities:**

- Requires owning multiple votes with identical weights (same amount + lock time)
- Can intentionally create such votes by voting with identical parameters
- No special permissions or privileged roles needed
- Only requires calling the public `ChangeVotingOption` method [6](#0-5) 

**Attack Complexity:**

- **Low complexity**: Simple transaction call with normal parameters
- **Precondition feasibility**: Legacy profit details with Id=null exist for all votes created before the ProfitDetailId feature was added
- **Execution practicality**: All steps executable through standard contract calls without requiring any off-chain manipulation

**Probability Reasoning:**

- **High probability** for legacy systems: All systems that have votes predating the Id feature are vulnerable
- **Moderate probability** for new systems: While new votes have proper Id tracking, attackers can intentionally create multiple votes with identical weights to maintain future exploitability
- **Detection difficulty**: The attack appears as a legitimate vote change operation; the mismatched profit detail extension is not easily detectable

### Recommendation

**Code-Level Mitigation:**

1. **Align matching strategies**: Change `GetProfitDetailByElectionVotingRecord()` to use the same ordered matching as `FixProfitDetail()`:

```csharp
if (profitDetail == null)
{
    // Use same ordering as FixProfitDetail for consistency
    profitDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
        .FirstOrDefault(d => d.Shares == electionVotingRecord.Weight);
}
```

Location to fix: [7](#0-6) 

2. **Add validation**: After `FixProfitDetail` returns, verify that the correct profit detail was modified by checking the returned or updated state

3. **Data migration**: For existing legacy profit details, implement a migration function to backfill the Id field with corresponding vote IDs

**Invariant Checks to Add:**

- Assert that when extending a profit detail, the profit detail's identifying characteristics (StartPeriod, original EndPeriod) match expected values for the specific vote being extended
- Add logging to track which profit detail was actually modified during extension operations

**Test Cases:**

1. Create multiple votes with identical weights (Id=null scenario)
2. Attempt to extend one vote and verify the correct profit detail is extended (not a different one)
3. Verify that expired profit details cannot be resurrected through extension of other votes
4. Test with various orderings of StartPeriod values to ensure consistent behavior

### Proof of Concept

**Required Initial State:**

- Voter Alice has 3 legacy votes (all created before ProfitDetailId feature, so Id=null):
  - Vote A: Amount=1000, LockTime=31536000 seconds (365 days), Weight=1500, StartPeriod=1, EndPeriod=12
  - Vote B: Amount=1000, LockTime=31536000 seconds (365 days), Weight=1500, StartPeriod=5, EndPeriod=16  
  - Vote C: Amount=1000, LockTime=31536000 seconds (365 days), Weight=1500, StartPeriod=10, EndPeriod=21
- Current period: 13 (Vote A has expired, Vote B expires soon, Vote C is active)
- All three profit details exist with Id=null and Shares=1500

**Transaction Steps:**

1. Alice calls `ChangeVotingOption` for Vote B with `IsResetVotingTime=true`
2. System calls `ExtendVoterWelfareProfits(VoteB.Id)`
3. `GetProfitDetailByElectionVotingRecord` searches for VoteB's profit detail:
   - Tries Id match: fails (all Ids are null)
   - Falls back to `LastOrDefault(d => d.Shares == 1500)`: returns **Vote C's profit detail** (StartPeriod=10)
4. Check passes: extendingDetail != null
5. `FixProfitDetail` is called with ProfitDetailId=VoteB.Id, Shares=1500, EndPeriod=37 (new extended period)
6. `FixProfitDetail` searches:
   - Tries Id match: fails (all Ids are null)
   - Falls back to `OrderBy(StartPeriod).FirstOrDefault(d => d.Shares == 1500)`: returns **Vote A's profit detail** (StartPeriod=1)
7. Vote A's profit detail is updated: EndPeriod changes from 12 to 37

**Expected vs Actual Result:**

- **Expected**: Vote B's profit detail (StartPeriod=5) should be extended to EndPeriod=37
- **Actual**: Vote A's profit detail (StartPeriod=1) is extended to EndPeriod=37, resurrecting an expired vote
- **Success condition**: Vote A (which expired at period 12) can now claim welfare profits until period 37, while Vote B remains at EndPeriod=16

**Concrete Harm:**

Alice can now claim welfare profits for Vote A from period 13 to 37 (24 additional periods), despite that vote having legitimately expired. This represents unauthorized extraction of funds from the shared welfare profit pool.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L23-38)
```csharp
    public override Empty ChangeVotingOption(ChangeVotingOptionInput input)
    {
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input.VoteId);
        Assert(Context.Sender == votingRecord.Voter, "No permission to change current vote's option.");
        var actualLockedSeconds = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockingSeconds = State.LockTimeMap[input.VoteId];
        Assert(actualLockedSeconds < claimedLockingSeconds, "This vote already expired.");

        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L140-159)
```csharp
        var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
        if (extendingDetail != null)
        {
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
        }
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L177-182)
```csharp
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
        // However, in the old world, profitDetail.Id is null, so use Shares.
        if (profitDetail == null)
        {
            profitDetail = profitDetails.Details.LastOrDefault(d => d.Shares == electionVotingRecord.Weight);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L284-289)
```csharp
        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L352-352)
```csharp
            Weight = GetVotesWeight(votingRecord.Amount, lockSeconds),
```
