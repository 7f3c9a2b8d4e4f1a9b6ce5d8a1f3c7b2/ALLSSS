### Title
Execution Observer Threshold Exceeded via Excessive ResourceTokenCharged Event Aggregation

### Summary
The `PayResourceTokens` function contains nested loops that process aggregated resource token charges from the previous block without bounds checking. An attacker can execute approximately 200+ unique contracts in a single block, creating a `TotalResourceTokensMaps` structure that exceeds AElf's 15,000 method call limit when processed, causing the `DonateResourceToken` system transaction to fail and preventing resource token collection.

### Finding Description

The vulnerability exists in the nested loop structure at: [1](#0-0) 

The outer loop iterates over `billMaps.Value` (repeated `ContractTotalResourceTokens` entries) and the inner loop iterates over `bill.TokensMap.Value` (map of token symbols to amounts). Each inner loop iteration performs approximately 19-22 method calls including:

- `GetBalance` call which internally makes 4 method calls: [2](#0-1) 

- `ModifyBalance` calls (2-3 per iteration) which each make 6 method calls: [3](#0-2) 

- Context.Fire events, State operations, and arithmetic methods

The `TotalResourceTokensMaps` input to `DonateResourceToken` is populated by aggregating `ResourceTokenCharged` events from the previous block: [4](#0-3) 

The aggregation creates one entry per unique contract address, with each entry containing a map of token symbols. An attacker can execute many unique contracts in a single block (block limit: 512 transactions), with each firing `ResourceTokenCharged` events for typically 4 resource token types (READ, WRITE, NET, TRAFFIC): [5](#0-4) 

AElf enforces execution observer limits of 15,000 method calls per transaction: [6](#0-5) 

When this threshold is exceeded, a `RuntimeCallThresholdExceededException` is thrown: [7](#0-6) 

**Calculation:** With 200 unique contracts × 4 tokens = 800 iterations × 19 method calls/iteration = 15,200 method calls, which exceeds the 15,000 limit.

The `DonateResourceToken` method is called as a system transaction once per block: [8](#0-7) 

It is generated by the system transaction generator: [9](#0-8) 

There are no bounds checks on the size of `TotalResourceTokensMaps.Value` before processing, and the block transaction limit (512) provides sufficient capacity for an attacker to trigger this condition: [10](#0-9) 

### Impact Explanation

**Operational Impact - Resource Token Collection Failure:**
- The `DonateResourceToken` system transaction fails when execution observer threshold is exceeded
- Resource tokens charged from contracts in the affected block are not collected or donated to the dividend pool (main chain) or consensus address (side chain)
- Contracts paid resource fees but the intended recipients don't receive them
- This disrupts the resource token economy and dividend distribution mechanism

**Economic Loss:**
- Resource tokens worth potentially significant value remain uncollected
- Users expecting dividend distributions from resource token donations don't receive their share
- The attack can be repeated across multiple blocks to cause sustained disruption

**Affected Parties:**
- Token holders expecting dividends from resource token donations
- The protocol's economic incentive structure
- System integrity and expected operational behavior

**Severity Justification:** Medium - causes operational disruption and economic loss but doesn't directly enable fund theft or compromise consensus integrity. The impact is limited to disruption of one economic subsystem rather than total system compromise.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Deploy or access 200+ unique smart contracts (cost: contract deployment fees)
- Execute these contracts in transactions within a single block (cost: transaction fees × 200+)
- Sufficient funds to pay for deployment and execution

**Attack Complexity:** Medium
- Requires deploying multiple contracts first (one-time setup cost)
- Requires coordinating 200+ transactions to be included in a single block
- Block transaction limit of 512 provides sufficient capacity
- No special permissions required beyond transaction submission

**Economic Rationality:**
- Attack cost: deployment fees for 200 contracts + execution fees for 200+ transactions
- In AElf, these costs are non-trivial but achievable for a motivated attacker with sufficient capital
- Potential gains: disruption of resource token collection, potential market manipulation if timed with other actions

**Execution Practicality:**
- Entry point is reachable: `DonateResourceToken` is a public method called as system transaction
- Attack steps are executable under normal AElf contract semantics
- No reliance on timing attacks or race conditions beyond normal transaction ordering
- Attacker can repeatedly execute the attack across multiple blocks

**Detection Constraints:**
- Failed system transactions would appear in block logs
- May not immediately trigger alerts if monitoring is insufficient
- Pattern of many unique contract executions in single blocks could be detected retrospectively

**Probability Assessment:** Medium - The attack is technically and economically feasible for a well-funded attacker, though it requires significant upfront investment and would likely be detected after initial execution.

### Recommendation

**1. Add Bounds Checking on TotalResourceTokensMaps Size:**

Add validation in `DonateResourceToken` after line 925:
```csharp
const int MaxContractEntries = 150;
const int MaxTotalIterations = MaxContractEntries * 5; // Conservative estimate for tokens per contract
var totalIterations = input.Value.Sum(c => c.TokensMap.Value.Count);
Assert(input.Value.Count <= MaxContractEntries, 
    $"Too many contract entries: {input.Value.Count}. Maximum: {MaxContractEntries}");
Assert(totalIterations <= MaxTotalIterations,
    $"Total iterations would exceed limit: {totalIterations}. Maximum: {MaxTotalIterations}");
```

**2. Implement Batch Processing:**

For maps exceeding the threshold, process in chunks:
- Split `TotalResourceTokensMaps` into batches of safe size
- Store unprocessed entries in state
- Process remaining batches in subsequent blocks
- Track processing progress with state variable

**3. Optimize Method Call Count:**

Within `PayResourceTokens`:
- Cache `GetBalance` results for frequently accessed addresses/symbols
- Batch state read/write operations where possible
- Consider lazy evaluation for logging operations

**4. Add Governance-Controlled Limits:**

Store `MaxContractEntries` as a configurable parameter that can be adjusted by Parliament if execution costs change.

**5. Monitoring and Alerts:**

- Track `ResourceTokenCharged` event counts per block
- Alert when counts approach 150+ unique contracts
- Monitor `DonateResourceToken` transaction results for failures

**6. Test Cases:**

Add tests validating:
- Execution with 150 unique contracts (should succeed)
- Execution with 250 unique contracts (should fail gracefully or batch process)
- Verification that execution observer threshold is not exceeded at maximum allowed size
- Batch processing functionality if implemented

### Proof of Concept

**Required Initial State:**
- Attacker has sufficient funds for contract deployment and transaction execution fees
- Attacker deploys 220 simple smart contracts (can be minimal contracts that just execute successfully)

**Attack Steps:**

1. **Preparation Phase:**
   - Attacker deploys 220 simple smart contracts to the blockchain
   - Each contract can be minimal (e.g., a simple function that performs basic operations)

2. **Attack Execution (Block N):**
   - Attacker prepares 220 transactions, each calling a different deployed contract
   - Submits all 220 transactions to the transaction pool
   - Miner includes these transactions in Block N (within the 512 transaction limit)
   - Each contract execution triggers `ChargeResourceToken`, firing `ResourceTokenCharged` events for 4 resource token types (READ, WRITE, NET, TRAFFIC)

3. **Event Aggregation (Block N processing):**
   - `ResourceTokenChargedLogEventProcessor.ProcessAsync` aggregates all events
   - Creates `TotalResourceTokensMaps` with 220 contract entries
   - Each entry has 4 token symbols in `TokensMap.Value`
   - Total nested loop iterations will be: 220 × 4 = 880

4. **System Transaction Generation (Block N+1):**
   - `DonateResourceTransactionGenerator` retrieves the `TotalResourceTokensMaps` for Block N
   - Generates `DonateResourceToken` system transaction with this data
   - Miner includes this system transaction in Block N+1

5. **Execution Failure (Block N+1 execution):**
   - `DonateResourceToken` calls `PayResourceTokens`
   - Nested loops execute 880 iterations
   - Each iteration performs ~19 method calls
   - Total: 880 × 19 = 16,720 method calls
   - `ExecutionObserver.CallCount()` reaches 15,000 and throws `RuntimeCallThresholdExceededException`

**Expected vs Actual Result:**

- **Expected:** `DonateResourceToken` successfully processes all resource token charges, transfers tokens from contract addresses to dividend pool/consensus address, fires `ResourceTokenClaimed` events, completes with status SUCCESS

- **Actual:** `DonateResourceToken` transaction fails during execution with:
  - Transaction status: FAILED
  - Error message: "Contract call threshold 15000 exceeded" (`RuntimeCallThresholdExceededException`)
  - Resource tokens remain in contract addresses, uncollected
  - No `ResourceTokenClaimed` events fired
  - Dividend pool/consensus address balances unchanged

**Success Condition:**

Query the transaction result for the `DonateResourceToken` system transaction in Block N+1 and verify:
- `TransactionResult.Status == FAILED`
- `TransactionResult.Error` contains "RuntimeCallThresholdExceededException" or "Contract call threshold 15000 exceeded"
- Verify resource token balances: contract addresses still hold their resource tokens instead of being transferred to dividend pool/consensus

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L566-600)
```csharp
    public override Empty ChargeResourceToken(ChargeResourceTokenInput input)
    {
        AssertTransactionGeneratedByPlugin();
        Context.LogDebug(() => $"Start executing ChargeResourceToken.{input}");
        if (input.Equals(new ChargeResourceTokenInput()))
        {
            return new Empty();
        }

        var bill = new TransactionFeeBill();
        foreach (var pair in input.CostDic)
        {
            Context.LogDebug(() => $"Charging {pair.Value} {pair.Key} tokens.");
            var existingBalance = GetBalance(Context.Sender, pair.Key);
            Assert(existingBalance >= pair.Value,
                $"Insufficient resource of {pair.Key}. Need balance: {pair.Value}; Current balance: {existingBalance}.");
            bill.FeesMap.Add(pair.Key, pair.Value);
        }

        foreach (var pair in bill.FeesMap)
        {
            Context.Fire(new ResourceTokenCharged
            {
                Symbol = pair.Key,
                Amount = pair.Value,
                ContractAddress = Context.Sender
            });
            if (pair.Value == 0)
            {
                Context.LogDebug(() => $"Maybe incorrect charged resource fee of {pair.Key}: it's 0.");
            }
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L913-953)
```csharp
    public override Empty DonateResourceToken(TotalResourceTokensMaps input)
    {
        AssertSenderIsCurrentMiner();
        var donateResourceTokenExecuteHeight = State.DonateResourceTokenExecuteHeight.Value;
        if (donateResourceTokenExecuteHeight == 0)
        {
            donateResourceTokenExecuteHeight = Context.CurrentHeight;
        }

        Assert(donateResourceTokenExecuteHeight == Context.CurrentHeight,
            $"This method already executed in height {State.DonateResourceTokenExecuteHeight.Value}");
        State.DonateResourceTokenExecuteHeight.Value = donateResourceTokenExecuteHeight.Add(1);
        Context.LogDebug(() => $"Start donate resource token. {input}");
        State.LatestTotalResourceTokensMapsHash.Value = HashHelper.ComputeFrom(input);
        Context.LogDebug(() =>
            $"Now LatestTotalResourceTokensMapsHash is {State.LatestTotalResourceTokensMapsHash.Value}");

        var isMainChain = true;
        if (State.DividendPoolContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            if (treasuryContractAddress == null)
            {
                isMainChain = false;
            }
            else
            {
                State.DividendPoolContract.Value = treasuryContractAddress;
            }
        }

        PayResourceTokens(input, isMainChain);

        if (!isMainChain)
        {
            PayRental();
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L960-1017)
```csharp
    private void PayResourceTokens(TotalResourceTokensMaps billMaps, bool isMainChain)
    {
        foreach (var bill in billMaps.Value)
        {
            foreach (var feeMap in bill.TokensMap.Value)
            {
                var symbol = feeMap.Key;
                var amount = feeMap.Value;
                // Check balance in case of insufficient balance.
                var existingBalance = GetBalance(bill.ContractAddress, symbol);
                if (amount > existingBalance)
                {
                    var owned = amount.Sub(existingBalance);
                    var currentOwning = State.OwningResourceToken[bill.ContractAddress][symbol].Add(owned);
                    State.OwningResourceToken[bill.ContractAddress][symbol] = currentOwning;
                    Context.Fire(new ResourceTokenOwned
                    {
                        Symbol = symbol,
                        Amount = currentOwning,
                        ContractAddress = bill.ContractAddress
                    });
                    amount = existingBalance;
                }

                if (amount > 0)
                {
                    ModifyBalance(bill.ContractAddress, symbol, -amount);
                    var receiver = Context.Self;
                    if (isMainChain)
                    {
                        Context.LogDebug(() => $"Adding {amount} of {symbol}s to dividend pool.");
                        // Main Chain.
                        ModifyBalance(receiver, symbol, amount);
                        State.DividendPoolContract.Donate.Send(new DonateInput
                        {
                            Symbol = symbol,
                            Amount = amount
                        });
                    }
                    else
                    {
                        Context.LogDebug(() => $"Adding {amount} of {symbol}s to consensus address account.");
                        // Side Chain
                        receiver =
                            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
                        ModifyBalance(receiver, symbol, amount);
                    }
                    Context.Fire(new ResourceTokenClaimed
                    {
                        Symbol = symbol,
                        Amount = amount,
                        Payer = bill.ContractAddress,
                        Receiver = receiver
                    });
                }
            }
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L116-125)
```csharp
    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L166-172)
```csharp
    private long GetBalance(Address address, string symbol)
    {
        AssertValidInputAddress(address);
        var actualSymbol = GetActualTokenSymbol(symbol);
        Assert(!string.IsNullOrWhiteSpace(actualSymbol), "Invalid symbol.");
        return State.Balances[address][actualSymbol];
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForResourceFee/ResourceTokenChargedLogEventProcessor.cs (L48-96)
```csharp
    public override async Task ProcessAsync(Block block, Dictionary<TransactionResult, List<LogEvent>> logEventsMap)
    {
        var blockHash = block.GetHash();
        var blockHeight = block.Height;
        var totalResourceTokensMaps = new TotalResourceTokensMaps
        {
            BlockHash = blockHash,
            BlockHeight = blockHeight
        };

        foreach (var logEvent in logEventsMap.Values.SelectMany(logEvents => logEvents))
        {
            var eventData = new ResourceTokenCharged();
            eventData.MergeFrom(logEvent);
            if (eventData.Symbol == null || eventData.Amount == 0)
                continue;

            if (totalResourceTokensMaps.Value.Any(b => b.ContractAddress == eventData.ContractAddress))
            {
                var oldBill =
                    totalResourceTokensMaps.Value.First(b => b.ContractAddress == eventData.ContractAddress);
                if (oldBill.TokensMap.Value.ContainsKey(eventData.Symbol))
                    oldBill.TokensMap.Value[eventData.Symbol] += eventData.Amount;
                else
                    oldBill.TokensMap.Value.Add(eventData.Symbol, eventData.Amount);
            }
            else
            {
                var contractTotalResourceTokens = new ContractTotalResourceTokens
                {
                    ContractAddress = eventData.ContractAddress,
                    TokensMap = new TotalResourceTokensMap
                    {
                        Value =
                        {
                            { eventData.Symbol, eventData.Amount }
                        }
                    }
                };
                totalResourceTokensMaps.Value.Add(contractTotalResourceTokens);
            }
        }

        await _totalTotalResourceTokensMapsProvider.SetTotalResourceTokensMapsAsync(new BlockIndex
        {
            BlockHash = blockHash,
            BlockHeight = blockHeight
        }, totalResourceTokensMaps);
    }
```

**File:** docs-sphinx/architecture/smart-contract/restrictions/others.rst (L10-16)
```text
Execution observer
------------------

- AElf's contract patcher will patch method call count observer for your contract. This is used to prevent infinitely method call like recursion. The number of method called in your contract will be counted during transaction execution. The observer will pause transaction execution if the number exceeds 15,000. The limit adjustment is governed by ``Parliament``.

- AElf's contract patcher will patch method branch count observer for your contract. This is used to prevent infinitely loop case. The number of code control transfer in your contract will be counted during transaction execution. The observer will pause transaction execution if the number exceeds 15,000. The limit adjustment is governed by ``Parliament``.
  The control transfer opcodes in C# contract are shown as below.
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L21-27)
```csharp
    public void CallCount()
    {
        if (_callThreshold != -1 && _callCount == _callThreshold)
            throw new RuntimeCallThresholdExceededException($"Contract call threshold {_callThreshold} exceeded.");

        _callCount++;
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForResourceFee/DonateResourceTransactionGenerator.cs (L28-75)
```csharp
    public async Task<List<Transaction>> GenerateTransactionsAsync(Address from, long preBlockHeight,
        Hash preBlockHash)
    {
        var generatedTransactions = new List<Transaction>();

        var chainContext = new ChainContext
        {
            BlockHash = preBlockHash,
            BlockHeight = preBlockHeight
        };

        var tokenContractAddress =
            await _smartContractAddressService.GetAddressByContractNameAsync(chainContext,
                TokenSmartContractAddressNameProvider.StringName);

        if (tokenContractAddress == null) return generatedTransactions;

        var totalResourceTokensMaps = await _totalResourceTokensMapsProvider.GetTotalResourceTokensMapsAsync(
            chainContext);

        ByteString input;
        if (totalResourceTokensMaps != null && totalResourceTokensMaps.BlockHeight == preBlockHeight &&
            totalResourceTokensMaps.BlockHash == preBlockHash)
            // If totalResourceTokensMaps match current block.
            input = totalResourceTokensMaps.ToByteString();
        else
            input = new TotalResourceTokensMaps
            {
                BlockHash = preBlockHash,
                BlockHeight = preBlockHeight
            }.ToByteString();

        generatedTransactions.AddRange(new List<Transaction>
        {
            new()
            {
                From = from,
                MethodName = nameof(TokenContractImplContainer.TokenContractImplStub.DonateResourceToken),
                To = tokenContractAddress,
                RefBlockNumber = preBlockHeight,
                RefBlockPrefix = BlockHelper.GetRefBlockPrefix(preBlockHash),
                Params = input
            }
        });

        Logger.LogTrace("Tx DonateResourceToken generated.");
        return generatedTransactions;
    }
```

**File:** src/AElf.Kernel.TransactionPool/TransactionOptions.cs (L21-21)
```csharp
    public static int BlockTransactionLimit { get; set; } = 512;
```
