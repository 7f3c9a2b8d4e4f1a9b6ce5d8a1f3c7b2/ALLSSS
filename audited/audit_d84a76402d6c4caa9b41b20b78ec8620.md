### Title
Election Bypass via Unchecked Miner List in NextTerm Consensus Transition

### Summary
The `NextTerm` consensus method accepts arbitrary miner lists in `NextTermInput.RealTimeMinersInformation` without validating them against the Election contract's `GetVictories` results. A malicious current-term miner can include themselves and exclude legitimate election winners in the next term, completely bypassing the democratic election system that should determine block producers.

### Finding Description

**Root Cause:**

The `NextTermInput.Create()` method directly copies `RealTimeMinersInformation` from a provided `Round` object without any validation: [1](#0-0) 

When `ProcessNextTerm` executes, it blindly trusts this input and sets the miner list for the next term: [2](#0-1) 

The miners are extracted directly from `nextRound.RealTimeMinersInformation.Keys` (line 189) and set via `SetMinerList` (line 190), which only checks if the term's miner list was previously set, not whether the miners are legitimate: [3](#0-2) 

**Why Protections Fail:**

The pre-execution validation only checks structural correctness (round/term number increments), NOT miner list correctness: [4](#0-3) [5](#0-4) 

The post-execution validation compares the header round hash with the state round hash, but since state was just updated from the header in `ProcessNextTerm`, they match. This validation is designed for intra-round miner replacements, not term transitions: [6](#0-5) 

**Honest Path (Not Enforced):**

The intended behavior calls `GenerateFirstRoundOfNextTerm` which queries the Election contract: [7](#0-6) 

This method calls `TryToGetVictories` to retrieve legitimate election winners: [8](#0-7) 

The Election contract's `GetVictories` returns top candidates by vote weight: [9](#0-8) 

However, **no validation enforces that the executed NextTermInput matches these election results**.

### Impact Explanation

**Direct Consensus Integrity Violation:**
- Complete bypass of the election system, which is the fundamental security mechanism for decentralizing block production
- Malicious miner can maintain mining privileges indefinitely regardless of vote results
- Legitimate election winners are excluded from consensus participation
- Attacker can inject arbitrary addresses (including Sybil identities) as miners

**Systemic Damage:**
- Breaks the core governance model where token holders elect block producers
- Centralizes consensus power to a single malicious actor
- All mining rewards for the entire term (potentially millions in native tokens) flow to attacker-controlled addresses
- Subsequent terms can be perpetually controlled since the attacker remains a miner

**Affected Parties:**
- Token holders: their votes become meaningless
- Legitimate election winners: denied mining rights and rewards
- Entire network: centralized and vulnerable to censorship/double-spend

**Severity Justification:**
CRITICAL - This violates the fundamental invariant that "miner schedule integrity" must be maintained. It enables permanent capture of the consensus layer by any current miner, destroying the decentralized trust model.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be a current-term miner (required to produce NextTerm block)
- No special privileges beyond normal mining rights
- Can execute attack unilaterally

**Attack Complexity:**
- LOW - Attacker simply provides malicious `Round` object to `NextTermInput.Create()`
- No need to compromise cryptographic primitives or exploit race conditions
- Single transaction achieves complete control

**Feasibility Conditions:**
- Attacker is scheduled to produce the block that triggers term transition
- In a typical 7-miner setup with equal time slots, each miner has ~14% chance per term
- Over multiple terms, probability approaches certainty
- Economic incentive is massive: continued mining rewards vs. losing election

**Detection Constraints:**
- Validation passes all checks (only validates round/term number increments)
- Transaction appears structurally valid
- No on-chain mechanism to detect the attack until term already changed
- By the time honest nodes detect wrong miners, state is already committed

**Probability Assessment:**
HIGH - Any losing miner has clear economic incentive to execute this. The attack is simple, has no technical barriers beyond being a current miner, and provides deterministic success with enormous payout (continued mining rewards).

### Recommendation

**Immediate Fix:**

Add validation in `ProcessNextTerm` to verify the miner list matches Election contract results:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // CRITICAL: Validate miners against Election contract victories
    if (State.IsMainChain.Value && State.ElectionContract.Value != null)
    {
        var victories = State.ElectionContract.GetVictories.Call(new Empty());
        var expectedMiners = new HashSet<string>(
            victories.Value.Select(v => v.ToHex())
        );
        var actualMiners = new HashSet<string>(
            nextRound.RealTimeMinersInformation.Keys
        );
        
        Assert(
            expectedMiners.SetEquals(actualMiners),
            "Miner list must exactly match Election contract victories."
        );
    }
    
    // ... rest of existing logic
}
```

**Alternative/Additional Validation:**

Add check in `RoundTerminateValidationProvider.ValidationForNextTerm`:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Existing term number check
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // NEW: Validate miner list against Election victories
    // (requires passing Election contract state to validator or querying within)
    
    return new ValidationResult { Success = true };
}
```

**Test Cases:**

1. Test that NextTerm with non-election miners is rejected
2. Test that excluded election winners cause transaction failure
3. Test that duplicate miners in RealTimeMinersInformation are rejected
4. Verify honest NextTerm with correct GetVictories results succeeds

### Proof of Concept

**Initial State:**
- Term T with miners [M1, M2, M3, M4, M5]
- Election results for Term T+1: [E1, E2, E3, E4, E5] (M1 lost election)
- M1 is scheduled to produce the block triggering NextTerm

**Attack Sequence:**

1. **M1 prepares malicious Round:**
   ```
   Round maliciousRound = new Round {
       RoundNumber = currentRound.RoundNumber + 1,
       TermNumber = currentRound.TermNumber + 1,
       RealTimeMinersInformation = {
           { "M1_pubkey", new MinerInRound {...} },  // M1 includes themselves
           { "M2_pubkey", new MinerInRound {...} },
           { "M3_pubkey", new MinerInRound {...} },
           { "M4_pubkey", new MinerInRound {...} },
           { "M5_pubkey", new MinerInRound {...} }
           // E1, E2, E3, E4, E5 are NOT included despite winning election
       },
       ...
   };
   ```

2. **M1 creates malicious NextTermInput:** [10](#0-9) 

3. **Validation passes:**
   - Round number: T.RoundNumber + 1 ✓
   - Term number: T.TermNumber + 1 ✓
   - InValues are null ✓
   - **NO check that miners match GetVictories** ✗

4. **ProcessNextTerm executes:**
   - Line 163: Converts input to Round (contains malicious miners)
   - Line 189: Extracts M1-M5 as miners (NOT E1-E5)
   - Line 190: `SetMinerList` succeeds (first time setting Term T+1 miners)

5. **Result:**
   - Term T+1 miners are [M1, M2, M3, M4, M5] (WRONG)
   - Should be [E1, E2, E3, E4, E5] (from GetVictories)
   - M1 bypassed election and maintained mining power
   - Legitimate winners E1-E5 excluded from consensus

**Success Condition:**
Query `State.MinerListMap[T+1]` after attack - it contains M1's pubkey despite M1 losing the election, and excludes legitimate winners E1-E5.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-190)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L172-179)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextTerm), NextTermInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L41-70)
```csharp
    public override PubkeyList GetVictories(Empty input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        var currentMiners = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(k => k.ToHex()).ToList();
        return new PubkeyList { Value = { GetVictories(currentMiners) } };
    }

    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

```
