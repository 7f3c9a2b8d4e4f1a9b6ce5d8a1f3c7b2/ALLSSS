### Title
NextTerm Consensus Data Injection via Missing Round Validation

### Summary
A malicious miner producing a NextTerm block can inject arbitrary consensus Round data that bypasses validation and corrupts the blockchain's consensus state. While the `GenerateFirstRoundOfNewTerm` function itself correctly uses contract state, validation does not verify that submitted `NextTermInput` matches what this function would generate, allowing attackers to manipulate critical consensus fields including the Last Irreversible Block (LIB) height and miner scheduling information.

### Finding Description

The vulnerability exists in the NextTerm validation flow, not in `GenerateFirstRoundOfNewTerm` itself. The function at lines 47-54 correctly delegates to the first overload using data from contract state. [1](#0-0) 

However, when a miner produces a NextTerm block, they submit a `NextTermInput` containing Round data via the public `NextTerm` method: [2](#0-1) 

This input is converted to a Round object and processed without regenerating and comparing to expected values: [3](#0-2) 

The validation for NextTerm only applies `RoundTerminateValidationProvider`, which checks basic invariants (round number +1, term number +1, InValues null) but does NOT validate Round data integrity: [4](#0-3) [5](#0-4) 

Critically, `LibInformationValidationProvider` which prevents LIB regression is only applied to UpdateValue, not NextTerm: [6](#0-5) 

The `ValidateConsensusAfterExecution` compares the header to post-execution state, but if both contain the same malicious data, validation passes: [7](#0-6) 

A malicious miner controls block header contents and can craft both the ConsensusExtraData header and NextTermInput transaction with matching corrupted values, bypassing all validation.

### Impact Explanation

**Consensus Integrity Compromise (CRITICAL):**
1. **LIB Manipulation**: Attacker can set `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` to arbitrary values (lines 244-245 show these should be preserved from current round): [8](#0-7) 

   - Setting LIB too low: Regresses finality guarantees, causes already-finalized blocks to be reconsidered, breaks cross-chain indexing assumptions
   - Setting LIB too high: Premature finality of unconfirmed blocks, potential for invalid cross-chain operations
   - Cross-chain modules rely on LIB for security, as documented in cross-chain usage of irreversible block heights

2. **Miner Schedule Manipulation**: Attacker can modify `RealTimeMinersInformation` including Order, ExpectedMiningTime, and other consensus-critical fields, disrupting time-slot validation and consensus timing for the entire term.

3. **Reward Tracking Corruption**: Manipulating `ExtraBlockProducerOfPreviousRound` affects reward distribution tracking (line 254): [9](#0-8) 

The corrupted state persists as the new term's foundation until subsequent UpdateValue transactions recalculate some values, creating a critical vulnerability window affecting all nodes and cross-chain operations.

### Likelihood Explanation

**Highly Feasible Attack:**

**Attacker Capabilities**: Any current miner scheduled to produce the NextTerm block (occurs once per term period, typically every few days). No special privileges beyond normal miner status required.

**Attack Complexity**: LOW
1. Miner queries `GetConsensusExtraData` to understand expected format
2. Modifies returned Round data with malicious values
3. Creates matching `NextTermInput` transaction using `NextTermInput.Create`: [10](#0-9) 

4. Includes both in produced block with valid signature
5. Validation checks pass (round/term +1, consistent header/state)

**Economic Rationality**: Malicious miner gains strategic advantage through:
- Manipulating miner timing to favor their own time slots
- Disrupting competitors' expected mining windows
- Potential cross-chain exploitation during LIB confusion window
- Cost is only block production (already their turn), no additional expense

**Detection Difficulty**: Corrupted Round data appears valid to basic checks. Only detected by comparing to what `GenerateFirstRoundOfNextTerm` would have generated, which current validation does not perform.

### Recommendation

**1. Add NextTerm Round Regeneration Validation:**

In `ValidateBeforeExecution`, for NextTerm behavior, regenerate the expected Round using `GenerateFirstRoundOfNextTerm` and compare all critical fields to the provided Round:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new NextTermRoundIntegrityValidationProvider()); // NEW
    validationProviders.Add(new LibInformationValidationProvider()); // ADD LIB checks
    break;
```

**2. Implement NextTermRoundIntegrityValidationProvider:**

Create a new validation provider that:
- Calls `GenerateFirstRoundOfNextTerm` internally to compute expected Round
- Compares critical fields: ConfirmedIrreversibleBlockHeight, ConfirmedIrreversibleBlockRoundNumber, miner list, orders, expected times
- Fails validation if any mismatch detected

**3. Apply LIB Validation to NextTerm:**

Add `LibInformationValidationProvider` to NextTerm validation (currently only applied to UpdateValue) to prevent LIB regression: [11](#0-10) 

**4. Test Cases:**

Add tests verifying:
- NextTerm with modified LIB values is rejected
- NextTerm with altered miner orders/times is rejected  
- NextTerm with incorrect ExtraBlockProducerOfPreviousRound is rejected
- Only exact match to `GenerateFirstRoundOfNextTerm` output is accepted

### Proof of Concept

**Initial State:**
- Current term N, round 100
- ConfirmedIrreversibleBlockHeight = 1000
- Malicious miner M is next in line to produce NextTerm block

**Attack Steps:**

1. Malicious miner M's turn arrives for term transition
2. M queries `GetConsensusExtraData` with NextTerm behavior: [12](#0-11) 

3. M receives correct Round with ConfirmedIrreversibleBlockHeight = 1000
4. M modifies Round: sets ConfirmedIrreversibleBlockHeight = 500 (regression)
5. M creates malicious `NextTermInput` with modified Round
6. M produces block with matching malicious header ConsensusExtraData and NextTermInput transaction
7. Validation in `ValidateBeforeExecution` checks only: RoundNumber = 101, TermNumber = N+1, InValues = null → PASSES [5](#0-4) 

8. `ProcessNextTerm` executes, storing malicious Round with LIB=500: [13](#0-12) 

9. `ValidateConsensusAfterExecution` compares header (LIB=500) to state (LIB=500) → PASSES
10. Block accepted, LIB regressed from 1000 to 500

**Expected Result**: Validation should reject the block for LIB regression and Round data mismatch

**Actual Result**: Block accepted, consensus state corrupted with LIB=500, affecting all subsequent consensus operations and cross-chain indexing until next UpdateValue recalculates LIB

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L47-54)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval, Timestamp currentBlockTime, Round currentRound)
    {
        var round = GenerateFirstRoundOfNewTerm(miningInterval, currentBlockTime, currentRound.RoundNumber,
            currentRound.TermNumber);
        round.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        round.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L244-245)
```csharp
        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L254-254)
```csharp
        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L8-34)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```
