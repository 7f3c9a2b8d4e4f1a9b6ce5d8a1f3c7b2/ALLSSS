### Title
Unvalidated `TuneOrderInformation` Allows Consensus Disruption via Negative Mining Orders

### Summary
Malicious validators can inject negative `FinalOrderOfNextRound` values through the `TuneOrderInformation` field in `UpdateValueInput`, which propagate to become negative `Order` values in subsequent rounds. This causes mining time calculations to produce timestamps in the past and disrupts the consensus mining schedule, potentially preventing valid round transitions.

### Finding Description

**Root Cause:** The `ProcessUpdateValue` function directly applies miner-provided `TuneOrderInformation` values to state without validation: [1](#0-0) 

The `FinalOrderOfNextRound` field is defined as `int32` in the protobuf, allowing values from -2^31 to 2^31-1: [2](#0-1) 

**Exploitation Path:**

1. A malicious validator calls `UpdateValue` with a crafted `UpdateValueInput` containing negative values in `TuneOrderInformation`
2. These negative values are written directly to `FinalOrderOfNextRound` in the current round state
3. During next round generation, `GenerateNextRoundInformation` sorts miners by `FinalOrderOfNextRound` and uses these values as the `Order` for the next round: [3](#0-2) 

4. Negative `Order` values cause `ExpectedMiningTime` calculations to produce timestamps in the past (line 33: `currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order))`)
5. The logic for assigning orders to non-mining validators breaks because `ableOrders` only considers positive range `[1, minersCount]`: [4](#0-3) 

**Inadequate Protection:** The `NextRoundMiningOrderValidationProvider` checks `FinalOrderOfNextRound > 0` but validates the wrong data structure: [5](#0-4) 

This checks `ProvidedRound` (the generated next round), which doesn't have `FinalOrderOfNextRound` set—only `Order` is set during generation. The validation is ineffective at preventing negative orders.

### Impact Explanation

**Consensus Integrity Compromise:**
- Validators with negative `Order` values have mining time slots in the past, disrupting the intended mining schedule
- The `ableOrders` allocation logic fails to properly assign orders to validators who didn't mine, potentially causing order collisions or gaps
- Round transition validation in `CheckRoundTimeSlots` may reject rounds with invalid time intervals, causing DoS of consensus progression [6](#0-5) 

**Affected Parties:**
- All network participants experience consensus disruption
- Legitimate validators cannot produce blocks if round transitions fail
- Applications depending on consistent block production face service interruptions

**Severity:** Medium—while this doesn't directly steal funds, it can halt consensus and prevent all chain operations.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an authorized validator (in the current or previous round's miner list) [7](#0-6) 

**Attack Complexity:** Low
- Craft `UpdateValueInput` with negative values in `TuneOrderInformation` dictionary
- Call the public `UpdateValue` method: [8](#0-7) 

**Detection Probability:** Medium
- Attack succeeds immediately (values written to state)
- Impact becomes visible during next round generation
- May trigger validation failures in `CheckRoundTimeSlots`, alerting operators

**Economic Feasibility:** Moderate
- Requires validator privileges (must be elected)
- Attacker risks detection and reputation loss
- No direct financial gain, only disruption

### Recommendation

**Immediate Fix:** Add bounds validation in `ProcessUpdateValue` before applying `TuneOrderInformation`:

```csharp
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    Assert(tuneOrder.Value > 0 && tuneOrder.Value <= currentRound.RealTimeMinersInformation.Count,
        $"Invalid FinalOrderOfNextRound value: {tuneOrder.Value}");
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}
```

**Additional Hardening:**
1. Validate that `TuneOrderInformation` keys correspond to actual miners in the current round
2. Verify no duplicate `FinalOrderOfNextRound` values are assigned
3. Fix `NextRoundMiningOrderValidationProvider` to check `BaseRound.FinalOrderOfNextRound` or `ProvidedRound.Order` instead of `ProvidedRound.FinalOrderOfNextRound`
4. Add integration tests verifying rejection of negative and out-of-bounds order values

### Proof of Concept

**Initial State:**
- Round N with 5 validators (orders 1-5)
- Attacker is validator with order 3

**Attack Steps:**
1. Attacker constructs `UpdateValueInput` with legitimate consensus data
2. Sets `TuneOrderInformation["AttackerPubkey"] = -1` 
3. Calls `UpdateValue(maliciousInput)`
4. Transaction executes successfully, writing -1 to state

**Expected vs Actual:**
- **Expected:** Validation rejects negative order, transaction reverts
- **Actual:** No validation occurs, -1 is written to `currentRound.RealTimeMinersInformation["AttackerPubkey"].FinalOrderOfNextRound`

**Observable Impact:**
- When `GenerateNextRoundInformation` is called, attacker is sorted first (order -1)
- Attacker's `ExpectedMiningTime` in round N+1 is in the past
- `CheckRoundTimeSlots` may reject the round with message "Mining interval must greater than 0" (if intervals become negative) or round transition succeeds with broken schedule

**Success Condition:** Attacker's `FinalOrderOfNextRound` in state equals -1, demonstrating lack of validation

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** protobuf/aedpos_contract.proto (L289-290)
```text
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-33)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-47)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-101)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
```
