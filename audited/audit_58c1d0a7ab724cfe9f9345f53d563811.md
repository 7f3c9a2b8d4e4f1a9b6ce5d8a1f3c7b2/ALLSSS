### Title
Missing Validation of ChainInitializationData Completeness Causes Side Chain Initialization Failures

### Summary
The `GetChainInitializationData()` view method only validates that the returned data is non-null but does not verify field completeness. When side chain initialization providers consume this data, they directly access nested fields and parse protobuf bytes without null checks, causing exceptions if critical fields like `ResourceTokenInfo`, `ChainInitializationConsensusInfo`, or serialized token data are missing or empty. This results in side chain initialization failure and potential creation of vulnerable chains with incorrect economic or consensus parameters.

### Finding Description

The vulnerability exists across three code locations:

**1. Data Construction Without Validation** [1](#0-0) 

The helper method constructs `ChainInitializationData` by calling external system contracts (`GetInitialConsensusInformation()`, `GetNativeTokenInfo()`, `GetResourceTokenInfo()`, `GetTokenInfo()`) without validating that returned data is complete and non-null before storing.

**2. Insufficient Read Validation** [2](#0-1) 

The view method only checks if the entire object is null (`Assert(res != null, "Side chain not found.")`) but does not validate that required fields are populated. Proto3 deserialization can produce objects with default/null field values if data is corrupted.

**3. Unsafe Data Consumption** [3](#0-2) 

This provider directly accesses `sideChainInitializationData.ResourceTokenInfo.InitialResourceAmount` and `sideChainInitializationData.ResourceTokenInfo.ResourceTokenListData` without null checks. If `ResourceTokenInfo` is null, this throws `NullReferenceException`. [4](#0-3) 

Directly parses `initializationData.NativeTokenInfoData` and `initializationData.ResourceTokenListData` without checking if they are null or empty. Empty ByteString parsing will throw exceptions. [5](#0-4) 

Parses `sideChainInitializationData.ChainInitializationConsensusInfo.InitialConsensusData` without null checks. If the consensus info is null or empty, parsing fails.

**Root Cause**: The system relies on external contract calls during data construction that can return null/empty values if parent chain system contracts are not properly initialized. Proto3 lacks required field enforcement, allowing incomplete data to be stored and retrieved.

### Impact Explanation

**Operational DoS Impact**: When incomplete initialization data is stored and retrieved, side chain initialization fails with unhandled exceptions during the genesis block creation process. The side chain cannot start, and all locked tokens for that side chain become permanently inaccessible since the chain ID is consumed but the chain never becomes operational.

**Vulnerable Chain Creation**: If partial data passes through (e.g., consensus data present but resource token data missing), the side chain may initialize but with incorrect economic parameters, leading to:
- Missing resource tokens → transactions cannot be executed (require resource fees)
- Incorrect consensus parameters → block production fails
- Wrong native token configuration → chain economy broken

**Affected Parties**: 
- Side chain creators lose locked indexing fee deposits
- All users who intended to use the side chain lose access to planned functionality
- Parent chain state is polluted with unusable side chain entries

**Severity Justification**: HIGH - Complete denial of service for side chain initialization with permanent fund lock and no recovery mechanism once bad data is stored.

### Likelihood Explanation

**Preconditions Required**:
1. Parent chain system contracts (Token or Consensus contracts) in invalid/uninitialized state
2. OR storage corruption at database level
3. OR race condition during system contract upgrades
4. `CreateSideChain` executed during these conditions

**Attack Complexity**: MEDIUM - Does not require attacker action; can occur naturally during:
- Chain upgrades when system contracts are being redeployed
- Parent chain initialization issues
- Storage corruption events (rare but documented in blockchain systems)
- Configuration errors in parent chain setup

**Feasibility**: The vulnerability is exploitable without direct attacker involvement. System administrators or governance executing side chain creation during parent chain maintenance windows would trigger the issue. Once triggered, impact is permanent.

**Detection Constraints**: Current code has no validation to detect incomplete data before storage or consumption, making the issue invisible until side chain initialization fails.

**Probability Reasoning**: MEDIUM-LOW under normal operations, but MEDIUM-HIGH during parent chain upgrades or maintenance windows when multiple chains are being managed.

### Recommendation

**1. Add Field Completeness Validation in View Method** [2](#0-1) 

Add validation after retrieving data:
```
Assert(res.ChainInitializationConsensusInfo != null && 
       !res.ChainInitializationConsensusInfo.InitialConsensusData.IsEmpty, 
       "Consensus initialization data incomplete");
Assert(res.ResourceTokenInfo != null && 
       !res.ResourceTokenInfo.ResourceTokenListData.IsEmpty, 
       "Resource token data incomplete");
Assert(!res.NativeTokenInfoData.IsEmpty, "Native token data incomplete");
Assert(res.ParentChainTokenContractAddress != null, "Parent token contract address missing");
```

**2. Add Validation During Data Construction** [6](#0-5) 

Validate external contract call results before using them:
```
var initialConsensusInfo = GetInitialConsensusInformation();
Assert(!initialConsensusInfo.IsEmpty, "Failed to get consensus information");

var nativeTokenInformation = GetNativeTokenInfo();
Assert(nativeTokenInformation != null, "Failed to get native token info");

var resourceTokenInformation = GetResourceTokenInfo();
Assert(resourceTokenInformation != null && resourceTokenInformation.Value.Count > 0, 
       "Failed to get resource token info");
```

**3. Add Defensive Null Checks in Consumption Providers** [3](#0-2) 

Add null checks before accessing nested fields:
```
if (sideChainInitializationData.ResourceTokenInfo == null)
    throw new InvalidDataException("ResourceTokenInfo is null");
```

**4. Add Test Cases**:
- Test side chain creation when token contract returns null token info
- Test side chain creation when consensus contract returns empty data
- Test retrieval of ChainInitializationData with missing fields
- Test side chain initialization with incomplete data scenarios

### Proof of Concept

**Initial State**:
1. Parent chain with Token and Consensus contracts deployed
2. Token contract in partially initialized state (native token created but resource tokens not registered)
3. Side chain creation proposal approved

**Exploitation Steps**:

1. **Trigger Data Construction**: Call `CreateSideChain` when resource tokens are not registered
   - `GetResourceTokenInfo()` returns empty `TokenInfoList`
   - Data stored with empty `ResourceTokenInfo.ResourceTokenListData`

2. **Data Retrieval**: Side chain node calls `GetChainInitializationData(chainId)`
   - Returns data with empty resource token list
   - No validation error triggered

3. **Side Chain Initialization**: Side chain attempts genesis block creation
   - `TokenContractInitializationProvider` executes
   - Line 36: `TokenInfoList.Parser.ParseFrom(initializationData.ResourceTokenListData)` called with empty ByteString
   - **Result**: `InvalidProtocolBufferException` thrown
   - **Actual**: Side chain initialization fails, chain never starts
   - **Expected**: Validation should have prevented storing/retrieving incomplete data

**Success Condition**: Side chain initialization crashes with parsing exception, proving incomplete data causes operational DoS. Locked tokens for side chain indexing remain permanently locked as chain ID is consumed but chain is non-functional.

### Notes

The vulnerability is particularly concerning because:
1. **Proto3 Behavior**: Protocol Buffers v3 removed the "required" field keyword, making all fields optional by default. Deserialization succeeds even with missing data, producing objects with default values.
2. **No Recovery Path**: Once incomplete data is stored in the parent chain state for a side chain ID, there is no mechanism to update or fix it. The side chain ID is permanently associated with bad initialization data.
3. **Cross-Contract Dependencies**: The vulnerability spans multiple layers (contract → RPC → side chain node), making it difficult to detect and mitigate at any single point.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L516-557)
```csharp
    private ChainInitializationData GetChainInitializationData(SideChainInfo sideChainInfo,
        SideChainCreationRequest sideChainCreationRequest)
    {
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var res = new ChainInitializationData
        {
            CreationHeightOnParentChain = sideChainInfo.CreationHeightOnParentChain,
            ChainId = sideChainInfo.SideChainId,
            Creator = sideChainInfo.Proposer,
            CreationTimestamp = sideChainInfo.CreationTimestamp,
            ChainCreatorPrivilegePreserved = sideChainInfo.IsPrivilegePreserved,
            ParentChainTokenContractAddress = State.TokenContract.Value
        };

        var initialConsensusInfo = GetInitialConsensusInformation();
        res.ChainInitializationConsensusInfo = new ChainInitializationConsensusInfo
            { InitialConsensusData = initialConsensusInfo };

        var nativeTokenInformation = GetNativeTokenInfo().ToByteString();
        res.NativeTokenInfoData = nativeTokenInformation;

        var resourceTokenInformation = GetResourceTokenInfo().ToByteString();
        res.ResourceTokenInfo = new ResourceTokenInfo
        {
            ResourceTokenListData = resourceTokenInformation,
            InitialResourceAmount = { sideChainCreationRequest.InitialResourceAmount }
        };

        if (IsPrimaryTokenNeeded(sideChainCreationRequest))
        {
            var sideChainTokenInformation =
                GetTokenInfo(sideChainCreationRequest.SideChainTokenCreationRequest.SideChainTokenSymbol)
                    .ToByteString();
            res.ChainPrimaryTokenInfo = new ChainPrimaryTokenInfo
            {
                ChainPrimaryTokenData = sideChainTokenInformation,
                SideChainTokenInitialIssueList = { sideChainCreationRequest.SideChainTokenInitialIssueList }
            };
        }

        return res;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L154-159)
```csharp
    public override ChainInitializationData GetChainInitializationData(Int32Value input)
    {
        var res = State.SideChainInitializationData[input.Value];
        Assert(res != null, "Side chain not found.");
        return res;
    }
```

**File:** src/AElf.Blockchains.SideChain/TokenContractInitializationDataProvider.cs (L25-44)
```csharp
        return new TokenContractInitializationData
        {
            Creator = sideChainInitializationData.Creator,
            ResourceAmount = sideChainInitializationData.ResourceTokenInfo.InitialResourceAmount.ToDictionary(
                kv => kv.Key.ToUpper(),
                kv => kv.Value),
            NativeTokenInfoData = sideChainInitializationData.NativeTokenInfoData,
            PrimaryTokenInfoData = sideChainInitializationData.ChainPrimaryTokenInfo?.ChainPrimaryTokenData,
            ResourceTokenListData = sideChainInitializationData.ResourceTokenInfo.ResourceTokenListData,
            TokenInitialIssueList =
                sideChainInitializationData.ChainPrimaryTokenInfo?.SideChainTokenInitialIssueList
                    .Select(t => new TokenInitialIssue { Address = t.Address, Amount = t.Amount }).ToList(),
            RegisteredOtherTokenContractAddresses = new Dictionary<int, Address>
            {
                {
                    _sideChainInitializationDataProvider.ParentChainId,
                    sideChainInitializationData.ParentChainTokenContractAddress
                }
            }
        };
```

**File:** src/AElf.Kernel.Token/TokenContractInitializationProvider.cs (L34-36)
```csharp
            var nativeTokenInfo = TokenInfo.Parser.ParseFrom(initializationData.NativeTokenInfoData);
            var resourceTokenList =
                TokenInfoList.Parser.ParseFrom(initializationData.ResourceTokenListData);
```

**File:** src/AElf.Blockchains.SideChain/AEDPoSContractInitializationDataProvider.cs (L29-42)
```csharp
        var aedPoSContractInitializationData = new AEDPoSContractInitializationData
        {
            InitialMinerList = sideChainInitializationData == null
                ? _consensusOptions.InitialMinerList
                : MinerListWithRoundNumber.Parser
                    .ParseFrom(sideChainInitializationData.ChainInitializationConsensusInfo.InitialConsensusData)
                    .MinerList.Pubkeys.Select(p => p.ToHex()).ToList(),
            StartTimestamp = sideChainInitializationData?.CreationTimestamp ?? _consensusOptions.StartTimestamp,
            PeriodSeconds = _consensusOptions.PeriodSeconds,
            MiningInterval = _consensusOptions.MiningInterval,
            IsSideChain = true
        };

        return aedPoSContractInitializationData;
```
