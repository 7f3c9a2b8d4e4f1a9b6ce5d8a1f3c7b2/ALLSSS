### Title
Cumulative Allowance Exploitation via Misleading GetAvailableAllowance Math.Max Logic

### Summary
The `GetAvailableAllowance` function uses `Math.Max` to display the maximum allowance across different types (specific, collection wildcard, all-symbol wildcard), misleading users into believing this represents the total transferable amount. However, the actual enforcement in `DoTransferFrom` allows sequential consumption of multiple independent allowances for the same token, enabling spenders to transfer significantly more tokens than the displayed "available" amount suggests.

### Finding Description

The vulnerability exists in the interaction between the view function `GetAvailableAllowance` [1](#0-0)  and the enforcement logic in `DoTransferFrom` [2](#0-1) .

**Root Cause:**
The allowance system supports three independent allowance types stored at different symbol keys:
- Specific symbol allowances (e.g., `State.Allowances[owner][spender]["ELF"]`)
- NFT collection wildcards (e.g., `State.Allowances[owner][spender]["ABC-*"]`)
- All-symbol wildcards (e.g., `State.Allowances[owner][spender]["*"]`)

The `GetAvailableAllowance` function uses `Math.Max` [3](#0-2)  to display only the maximum single-source allowance, suggesting this is the total available. However, the actual `GetAllowance` enforcement function [4](#0-3)  implements a fallback strategy that tries each allowance type in sequence, deducting from whichever is used.

**Why Protections Fail:**
Each allowance type is stored independently and decremented separately [5](#0-4) . When a specific allowance is exhausted, subsequent transfers can still utilize wildcard allowances for the same token. No check prevents cumulative consumption of multiple allowance types for identical tokens.

### Impact Explanation

**Direct Fund Impact:**
Token owners who set multiple allowance types (e.g., 100 tokens for specific symbol + 50 tokens for "*" wildcard) can have up to 150 tokens transferred, despite `GetAvailableAllowance` displaying only 100 (the maximum). This represents a 50% excess in the example case.

**Quantified Damage:**
- For a user approving 1000 ELF specifically and 500 ELF via "*", a spender can transfer 1500 ELF total
- The misleading display (1000) causes users to believe they've limited exposure to 1000 ELF
- Actual exposure is 150% of the displayed amount

**Affected Parties:**
- All token holders using the wildcard approval feature
- Particularly critical for high-value token holders and DeFi integrations
- NFT collection owners approving collection-wide access

**Severity Justification:**
This is a Critical vulnerability because it directly enables unauthorized token transfers beyond intended approval limits, with no way for users to detect the cumulative behavior from the provided view function.

### Likelihood Explanation

**Attacker Capabilities:**
Any approved spender can exploit this by simply calling `TransferFrom` multiple times. No special privileges or complex setup required beyond normal approval flow.

**Attack Complexity:**
Low. The exploitation path is straightforward:
1. Wait for owner to approve multiple allowance types (specific + wildcard)
2. Call `TransferFrom` to exhaust specific allowance
3. Call `TransferFrom` again to utilize wildcard allowance
4. Total transferred exceeds what `GetAvailableAllowance` displayed

**Feasibility Conditions:**
- Owner must set multiple allowance types (specific + wildcard, or collection + wildcard)
- This is likely as users may:
  - Set specific allowances for known use cases
  - Add wildcard allowances for convenience
  - Not realize these are cumulative

**Detection Constraints:**
The existing test suite [6](#0-5)  does not validate the cumulative total behavior, only individual allowance type usage. The undocumented wildcard feature makes this behavior unexpected.

**Probability:**
High. The misleading `GetAvailableAllowance` function creates a false sense of security, and the feature is accessible through standard `Approve` [7](#0-6)  and `TransferFrom` [8](#0-7)  methods.

### Recommendation

**Code-Level Mitigation:**

1. **Fix GetAvailableAllowance to show cumulative total:**
   Modify the function to return the SUM of all applicable allowances instead of Math.Max, accurately representing total transferable amount.

2. **Add explicit documentation:**
   Document in comments and external documentation that allowances are cumulative across types, not mutually exclusive alternatives.

3. **Consider adding a cumulative allowance view:**
   Implement `GetTotalAvailableAllowance` that explicitly calculates and returns the sum of all allowance types.

4. **Alternative: Make allowances mutually exclusive:**
   Modify `GetAllowance` to consume from a single allowance pool by consolidating specific and wildcard approvals into a unified tracking mechanism.

**Invariant Checks:**
- Assert that displayed available allowance >= actual remaining transferable amount
- Add events that clearly indicate which allowance type is being consumed
- Implement warnings when multiple allowance types exist for the same effective token

**Test Cases:**
- Verify cumulative transfer scenario: specific allowance (100) + wildcard allowance (50) = 150 total transferable
- Test that GetAvailableAllowance accurately reflects total remaining across all types
- Validate that users cannot be misled about actual approval exposure

### Proof of Concept

**Required Initial State:**
- Token "ELF" exists and is transferable
- Owner has 1000 ELF balance
- Spender has 0 ELF balance

**Transaction Steps:**

1. **Owner approves specific allowance:**
   ```
   Approve(spender: SpenderAddress, symbol: "ELF", amount: 100)
   State.Allowances[Owner][Spender]["ELF"] = 100
   ```

2. **Owner approves wildcard allowance:**
   ```
   Approve(spender: SpenderAddress, symbol: "*", amount: 50)
   State.Allowances[Owner][Spender]["*"] = 50
   ```

3. **Check displayed allowance (misleading):**
   ```
   GetAvailableAllowance(owner: Owner, spender: Spender, symbol: "ELF")
   Returns: 100 (Math.Max(100, 50))
   ```

4. **Spender transfers first batch:**
   ```
   TransferFrom(from: Owner, to: Spender, symbol: "ELF", amount: 100)
   Uses specific allowance: State.Allowances[Owner][Spender]["ELF"] = 0
   Spender balance: 100 ELF
   ```

5. **Spender transfers second batch (exploitation):**
   ```
   TransferFrom(from: Owner, to: Spender, symbol: "ELF", amount: 50)
   Uses wildcard allowance: State.Allowances[Owner][Spender]["*"] = 0
   Spender balance: 150 ELF
   ```

**Expected vs Actual Result:**
- **Expected** (based on GetAvailableAllowance): Maximum 100 ELF transferable
- **Actual**: 150 ELF transferred (50% more than displayed)

**Success Condition:**
Spender successfully transfers total of 150 ELF despite GetAvailableAllowance initially showing only 100 ELF available, demonstrating the cumulative allowance exploitation.

**Notes**

This vulnerability stems from a UX/design flaw where the display function (`GetAvailableAllowance`) using `Math.Max` creates a false expectation that allowances are alternative strategies rather than cumulative limits. The lack of documentation about wildcard allowances [9](#0-8)  exacerbates the issue, as users have no way to understand the cumulative behavior. While the tests demonstrate individual allowance type functionality [10](#0-9) , none validate the critical cumulative scenario where multiple allowance types are exploited sequentially for the same token.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L64-87)
```csharp
    public override GetAllowanceOutput GetAvailableAllowance(GetAllowanceInput input)
    {
        var result = new GetAllowanceOutput
        {
            Symbol = input.Symbol,
            Owner = input.Owner,
            Spender = input.Spender,
        };
        var symbol = input.Symbol;
        var allowance = State.Allowances[input.Owner][input.Spender][symbol];
        if (CheckSymbolIdentifier(symbol))
        {
            result.Allowance = allowance;
            return result;
        }
        var symbolType = GetSymbolType(symbol);
        allowance = Math.Max(allowance, GetAllSymbolAllowance(input.Owner,input.Spender,out _));
        if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
        {
            allowance = Math.Max(allowance, GetNftCollectionAllSymbolAllowance(input.Owner, input.Spender, symbol, out _));
        }
        result.Allowance = allowance;
        return result;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L97-116)
```csharp
    private long GetAllowance(Address from, Address spender, string sourceSymbol, long amount,
        out string allowanceSymbol)
    {
        allowanceSymbol = sourceSymbol;
        var allowance = State.Allowances[from][spender][sourceSymbol];
        if (allowance >= amount) return allowance;
        var tokenType = GetSymbolType(sourceSymbol);
        if (tokenType == SymbolType.Token)
        {
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }
        else
        {
            allowance = GetNftCollectionAllSymbolAllowance(from, spender, sourceSymbol, out allowanceSymbol);
            if (allowance >= amount) return allowance;
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }

        return allowance;
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenApplicationTests.cs (L536-649)
```csharp
    public async Task MultiTokenContract_TransferFrom_Nft_Global_Test()
    {
        await CreateNft();
        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Symbol = "ABC-1",
            Amount = 100,
            To = DefaultAddress,
            Memo = "test"
        });
        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Symbol = "ABC-1",
            Amount = 200,
            To = User1Address,
            Memo = "test"
        });
        var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = DefaultAddress,
            Symbol = "ABC-1"
        });
        balance.Balance.ShouldBe(100);
        balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = User1Address,
            Symbol = "ABC-1"
        });
        balance.Balance.ShouldBe(200);
        await TokenContractStub.Approve.SendAsync(new ApproveInput
        {
            Amount = 1000,
            Symbol = "*",
            Spender = User1Address
        });
        
        await TokenContractStub.Approve.SendAsync(new ApproveInput
        {
            Amount = 1,
            Symbol = "ABC-*",
            Spender = User1Address
        });
        var allowance = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
        {
            Owner = DefaultAddress,
            Spender = User1Address,
            Symbol = "ABC-1"
        });
        allowance.Allowance.ShouldBe(0);
        allowance = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
        {
            Owner = DefaultAddress,
            Spender = User1Address,
            Symbol = "ELF"
        });
        allowance.Allowance.ShouldBe(0);
        {
            var realAllowance = await TokenContractStub.GetAvailableAllowance.CallAsync(new GetAllowanceInput
            {
                Owner = DefaultAddress,
                Spender = User1Address,
                Symbol = "ABC-1"
            });
            realAllowance.Allowance.ShouldBe(1000);
        }
        {
            var realAllowance = await TokenContractStub.GetAvailableAllowance.CallAsync(new GetAllowanceInput
            {
                Owner = DefaultAddress,
                Spender = User1Address,
                Symbol = "ELF"
            });
            realAllowance.Allowance.ShouldBe(1000);
        }
        var user1Stub =
            GetTester<TokenContractImplContainer.TokenContractImplStub>(TokenContractAddress, User1KeyPair);
        var result2 = await user1Stub.TransferFrom.SendAsync(new TransferFromInput
        {
            Amount = 50,
            From = DefaultAddress,
            Memo = "test",
            Symbol = "ABC-1",
            To = User1Address
        }); 
        result2.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        {
            var realAllowance = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
            {
                Owner = DefaultAddress,
                Spender = User1Address,
                Symbol = "ABC-1"
            });
            realAllowance.Allowance.ShouldBe(0);
        }
        allowance = await TokenContractStub.GetAvailableAllowance.CallAsync(new GetAllowanceInput
        {
            Owner = DefaultAddress,
            Spender = User1Address,
            Symbol = "ABC-1"
        });
        allowance.Allowance.ShouldBe(1000-50);
        balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = DefaultAddress,
            Symbol = "ABC-1"
        });
        balance.Balance.ShouldBe(50);
        balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = User1Address,
            Symbol = "ABC-1"
        });
        balance.Balance.ShouldBe(250);
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenApplicationTests.cs (L734-805)
```csharp
    public async Task MultiTokenContract_TransferFrom_Token_Test()
    {
        await CreateAndIssueToken();
        await TokenContractStub.Approve.SendAsync(new ApproveInput
        {
            Amount = 100_00000000,
            Symbol = "*",
            Spender = User1Address
        });
        var allowance = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
        {
            Owner = DefaultAddress,
            Spender = User1Address,
            Symbol = "SSS"
        });
        allowance.Allowance.ShouldBe(0);
        {
            var realAllowance = await TokenContractStub.GetAvailableAllowance.CallAsync(new GetAllowanceInput
            {
                Owner = DefaultAddress,
                Spender = User1Address,
                Symbol = "SSS"
            });
            realAllowance.Allowance.ShouldBe(100_00000000);
        }
        allowance = await TokenContractStub.GetAllowance.CallAsync(new GetAllowanceInput
        {
            Owner = DefaultAddress,
            Spender = User1Address,
            Symbol = "ELF"
        });
        allowance.Allowance.ShouldBe(0);
        {
            var realAllowance = await TokenContractStub.GetAvailableAllowance.CallAsync(new GetAllowanceInput
            {
                Owner = DefaultAddress,
                Spender = User1Address,
                Symbol = "SSS"
            });
            realAllowance.Allowance.ShouldBe(100_00000000);
        }
        var user1Stub =
            GetTester<TokenContractImplContainer.TokenContractImplStub>(TokenContractAddress, User1KeyPair);
        var result2 = await user1Stub.TransferFrom.SendAsync(new TransferFromInput
        {
            Amount = 50_00000000,
            From = DefaultAddress,
            Memo = "test",
            Symbol = "SSS",
            To = User1Address
        }); 
        result2.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        allowance = await TokenContractStub.GetAvailableAllowance.CallAsync(new GetAllowanceInput
        {
            Owner = DefaultAddress,
            Spender = User1Address,
            Symbol = "SSS"
        });
        allowance.Allowance.ShouldBe(100_00000000-50_00000000);
        var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = DefaultAddress,
            Symbol = "SSS"
        });
        balance.Balance.ShouldBe(TotalSupply - 50_00000000);
        balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = User1Address,
            Symbol = "SSS"
        });
        balance.Balance.ShouldBe(50_00000000);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L254-259)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransferFrom(input.From, input.To, Context.Sender, tokenInfo.Symbol, input.Amount, input.Memo);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L261-268)
```csharp
    public override Empty Approve(ApproveInput input)
    {
        AssertValidInputAddress(input.Spender);
        var actualSymbol = GetActualTokenSymbol(input.Symbol);
        AssertValidApproveTokenAndAmount(actualSymbol, input.Amount);
        Approve(input.Spender, actualSymbol, input.Amount);
        return new Empty();
    }
```

**File:** docs/resources/smart-contract-apis/multi-token.md (L99-138)
```markdown
## Allowances.

Allowances allow some entity (in fact an address) to authorize another address to transfer tokens on his behalf (see **TransferFrom**). There are two methods available for controlling this, namely **Approve** and **UnApprove**.

### **Approve**

``` Proto
rpc Approve (ApproveInput) returns (google.protobuf.Empty) { }

message ApproveInput {
    aelf.Address spender = 1;
    string symbol = 2;
    sint64 amount = 3;
}
```

The approve action increases the allowance from the *Sender* to the **Spender** address, enabling the Spender to call **TransferFrom**.

- **spender** the address that will have it's allowance increased.
- **symbol** the symbol of the token to approve.
- **amount** the amount of tokens to approve.

### **UnApprove**

``` Proto
rpc UnApprove (UnApproveInput) returns (google.protobuf.Empty) { }

message UnApproveInput {
    aelf.Address spender = 1;
    string symbol = 2;
    sint64 amount = 3;
}
```

This is the reverse operation for **Approve**, it will decrease the allowance.

- **spender** the address that will have it's allowance decreased.
- **symbol** the symbol of the token to un-approve.
- **amount** the amount of tokens to un-approve.

```
