### Title
Unhandled Exception in GetAmountToPayFromReturn() Full Formula Path Causes Transaction Failure

### Summary
The `GetAmountToPayFromReturn()` function in BancorHelper has asymmetric exception handling where the simplified formula case (equal connector weights) is protected by try-catch, but the full formula case (different connector weights) lacks exception handling. This allows unhandled exceptions when users attempt to buy token amounts equal to or exceeding the connector balance, causing transaction failures with cryptic error messages instead of graceful handling.

### Finding Description

The vulnerability exists in the `GetAmountToPayFromReturn()` function where exception handling is inconsistent between two execution paths. [1](#0-0) 

The simplified formula path (when `wf == wt`) is protected by a try-catch block that handles exceptions and throws a meaningful `AssertionException` with the message "Insufficient account balance to deposit". [2](#0-1) 

However, the full formula path (when `wf != wt`) has no exception handling. This path can throw unhandled exceptions in multiple scenarios:

1. **Division by Zero (Line 91)**: When `amountToReceive == toConnectorBalance`, the expression `bt / (bt - a)` causes division by zero since `bt - a = 0`.

2. **Invalid Domain for Ln() (Line 93)**: The `Ln()` function requires its input to be in the range (0, 2). [3](#0-2) 

   When `amountToReceive` approaches `toConnectorBalance`, the value `x = bt / (bt - a)` becomes very large (> 2), triggering an `InvalidValueException`.

This function is called from the public `Buy()` method without any validation that `input.Amount < toConnectorBalance`: [4](#0-3) 

The Buy() method performs no pre-validation on the amount, allowing the unhandled exception to propagate when connector weights differ.

### Impact Explanation

**Operational Impact:**
- The `Buy()` function becomes unavailable for token pairs with different connector weights when users attempt to purchase amounts equal to or exceeding the available balance
- Transactions fail with cryptic low-level exceptions (division by zero, InvalidValueException) instead of the clear "Insufficient account balance to deposit" message
- Inconsistent behavior creates confusion - identical scenarios (buying too much) are handled differently based on whether weights are equal or not

**Affected Users:**
- All users attempting to buy tokens from connector pairs with non-equal weights
- Common scenario when users max out their purchase or make calculation errors
- No funds are lost, but transaction fees are wasted on failed transactions

**Severity Justification (Medium):**
- No direct financial loss or theft
- Operational availability impact on core token conversion functionality
- High exploitability but low severity impact (DoS without permanent damage)
- Violates principle of consistent error handling and defense in depth

### Likelihood Explanation

**Attacker Capabilities:**
- Any user with a wallet can trigger this issue
- No special permissions, governance control, or privileged access required
- No need to compromise any system components

**Attack Complexity:**
- Trivial to execute: simply call `Buy()` with `input.Amount >= GetSelfBalance(toConnector)`
- No complex setup or multi-step exploitation required
- Can be triggered unintentionally by legitimate users making mistakes

**Feasibility Conditions:**
- Requires token pair with `fromConnectorWeight != toConnectorWeight` (common in Bancor implementations)
- User must attempt to buy amount >= available balance (common edge case)
- No special blockchain state or timing requirements

**Probability:**
- **Very High** - this is a standard edge case that users will encounter regularly
- Users attempting to "buy max" or making calculation errors will trigger this
- The simplified formula case (equal weights) shows developers anticipated this scenario but only protected one path

### Recommendation

**Code-Level Mitigation:**

1. Extend the try-catch block to cover the full formula path:

```csharp
public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
    long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
{
    // ... validation code ...
    
    decimal bf = fromConnectorBalance;
    var wf = fromConnectorWeight;
    decimal bt = toConnectorBalance;
    var wt = toConnectorWeight;
    decimal a = amountToReceive;
    
    try
    {
        if (wf == wt)
            return (long)(bf / (bt - a) * a);
        
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
    }
    catch
    {
        throw new AssertionException("Insufficient account balance to deposit");
    }
}
```

2. Add explicit validation in the `Buy()` method before calling `GetAmountToPayFromReturn()`:

```csharp
public override Empty Buy(BuyInput input)
{
    var toConnector = State.Connectors[input.Symbol];
    Assert(toConnector != null, "[Buy]Can't find to connector.");
    Assert(toConnector.IsPurchaseEnabled, "can't purchase");
    
    var toBalance = GetSelfBalance(toConnector);
    Assert(input.Amount < toBalance, "Insufficient connector balance for purchase amount.");
    
    // ... rest of Buy() logic ...
}
```

**Invariant Checks:**
- `amountToReceive < toConnectorBalance` must hold before price calculation
- Both execution paths (wf == wt and wf != wt) should have identical error handling behavior

**Test Cases:**
- Test buying exact connector balance (amount == balance) with equal weights
- Test buying exact connector balance with different weights
- Test buying more than connector balance (amount > balance) with both equal and different weights
- Test buying 99.9% of connector balance to verify Ln() domain handling

### Proof of Concept

**Required Initial State:**
1. TokenConverter contract initialized with two connectors having different weights (e.g., wf=0.5, wt=0.6)
2. Connector pair enabled for trading
3. toConnector has balance of 100,000 tokens

**Transaction Steps:**

1. User calls `Buy()` with:
   - `Symbol`: target token symbol
   - `Amount`: 100,000 (equal to toConnectorBalance)
   - `PayLimit`: 0 (no limit)

2. Execution flow:
   - Line 120: `BancorHelper.GetAmountToPayFromReturn()` is called
   - Since `wf != wt` (0.5 != 0.6), simplified formula is skipped
   - Line 91: `x = 100000 / (100000 - 100000) = 100000 / 0` → **Division by Zero Exception**

**Expected vs Actual Result:**
- **Expected**: Transaction fails with clear error "Insufficient account balance to deposit" (like the equal weights case)
- **Actual**: Transaction fails with unhandled division by zero exception or InvalidValueException

**Alternative PoC (near-boundary case):**

1. User calls `Buy()` with `Amount`: 99,000 (99% of balance)
2. Line 91: `x = 100000 / 1000 = 100`
3. Line 93: `Ln(100)` is called
4. Line 132: `Math.Abs(1 - 100) = 99 >= 1` → **InvalidValueException: "must be 0 < a < 2"**

**Success Condition:**
Transaction fails with unhandled exception instead of graceful AssertionException, confirming asymmetric error handling vulnerability.

---

**Notes:**

The vulnerability is confirmed valid because:
- It creates an operational DoS vector for a core contract function
- It demonstrates inconsistent security posture between code paths
- It has high likelihood (trivial to trigger) with medium impact (availability but not integrity)
- The existing try-catch for the simplified case proves developers knew this edge case needed protection but only applied it to one path

While not critical (no funds are stolen), this represents a code quality and reliability issue that violates defensive programming principles and should be fixed to ensure consistent error handling across all execution paths.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L80-89)
```csharp
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L131-132)
```csharp
        if (Math.Abs(x) >= 1)
            throw new InvalidValueException("must be 0 < a < 2");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```
