# Audit Report

## Title
NFT Symbol Alias Resolution Bypass in ACS2 Resource Path Declaration Allows Parallel Execution Race Conditions

## Summary
The MultiToken contract's `GetResourceInfo` method declares resource paths using raw transaction parameter symbols, while the actual `TransferFrom` execution resolves NFT aliases to their real symbols before accessing state. This mismatch causes transactions accessing the same underlying state to be incorrectly parallelized, enabling allowance double-spending and balance corruption through race conditions.

## Finding Description

The vulnerability stems from a fundamental architectural mismatch between pre-execution resource path declaration and runtime state access in the presence of NFT aliases.

**Resource Path Declaration Phase:**

The `GetResourceInfo` method receives raw transaction parameters and must declare all state paths that will be accessed during execution. For `TransferFrom`, it parses the symbol directly from transaction bytes and uses it to construct state paths. [1](#0-0) 

The method calls `AddPathForAllowance` with the raw symbol, which uses `GetSymbolType` to classify the symbol and determine which allowance paths to declare. [2](#0-1) 

Critically, `GetSymbolType` classifies symbols based solely on the presence of a hyphen separator. An alias like "SEED" (without hyphen) returns `SymbolType.Token`, not recognizing it as an NFT alias. [3](#0-2) 

**Runtime Execution Phase:**

During actual execution, `TransferFrom` calls `AssertValidToken` which invokes `GetTokenInfo` to validate the token. [4](#0-3) 

The `GetTokenInfo` method performs alias resolution by checking `State.SymbolAliasMap`, returning the actual token symbol (e.g., "SEED-123") when given an alias (e.g., "SEED"). [5](#0-4) 

The resolved symbol is then used in all subsequent state access operations, including balance and allowance checks in `DoTransferFrom`. [6](#0-5) 

**NFT Alias System:**

The system explicitly supports NFT aliases through the `SetSymbolAlias` method, which maps shorter alias strings to full NFT symbols in `State.SymbolAliasMap`. [7](#0-6) 

**Root Cause:**

By ACS2 design, `GetResourceInfo` executes pre-transaction without state access, making alias resolution impossible. This creates an irreconcilable mismatch: declared paths use the alias string (e.g., `Allowances[from][spender]["SEED"]`), while runtime accesses the resolved symbol (e.g., `Allowances[from][spender]["SEED-123"]`). The parallel execution engine treats these as non-conflicting paths, allowing concurrent execution of transactions that actually access the same state.

## Impact Explanation

**HIGH Severity** due to direct financial impact and protocol invariant violation:

1. **Allowance Double-Spending**: Two concurrent `TransferFrom` transactions (one using alias, one using actual symbol) can both read the same allowance value before either deduction, allowing total transfers exceeding the approved amount. This enables theft of NFTs beyond authorized limits.

2. **Balance Corruption**: Parallel balance updates create race conditions where the final state reflects only one transaction's modification, causing the other's balance changes to be lost. This results in incorrect balances that don't match actual token movements.

3. **ACS2 Protocol Violation**: The fundamental ACS2 guarantee—that `GetResourceInfo` declares all accessed paths—is broken. This undermines the entire parallel execution safety model and could affect other contracts relying on correct path declaration.

4. **Broad Scope**: Affects all NFT collections where aliases have been set, which is an intended and encouraged feature for usability.

## Likelihood Explanation

**HIGH Likelihood** due to straightforward attack requirements and normal user capabilities:

**Attacker Prerequisites:**
- Own an NFT collection (achievable via SEED NFT or whitelist)
- Set alias via public `SetSymbolAlias` method
- Submit multiple transactions to mempool

**Execution Practicality:**
- All attack steps use standard public methods
- No privileged access or trusted role compromise required
- Timing requirement (concurrent submission) is easily achievable
- Economic cost is minimal (standard transaction fees)

**Feasibility Conditions:**
- Victim must approve allowances (collection-wide or specific)
- Attacker sets alias (owner capability)
- Submit transactions in same block grouping window (routine)

**Detection Difficulty:**
- Transactions appear legitimate (normal `TransferFrom` calls)
- No reverts or obvious errors occur
- State corruption manifests as subtle discrepancies
- No post-execution validation catches the path mismatch

The alias feature is intentionally designed for production use, making this a practical attack vector whenever aliases exist in the system.

## Recommendation

**Primary Fix**: Resolve aliases during path declaration by reading alias mappings as ReadPaths and including both aliased and resolved symbol paths in WritePaths.

**Implementation Approach**:

1. Modify `GetResourceInfo` for `TransferFrom` to add alias mapping as a ReadPath:
   - Add `GetPath(nameof(TokenContractState.SymbolAliasMap), args.Symbol)` to ReadPaths

2. In `AddPathForAllowance`, declare paths for both the input symbol AND its potential resolution:
   - First declare paths using the provided symbol
   - Then declare paths using `GetPath(nameof(TokenContractState.SymbolAliasMap), symbol)` to access potential alias
   - If symbol format suggests it could be an alias (no hyphen), also declare paths for potential NFT format `symbol-*`

3. Consider declaring conservative path sets when symbol classification is ambiguous, accepting reduced parallelization to ensure safety.

**Alternative Fix**: Disable alias usage in `TransferFrom` by rejecting alias symbols and requiring callers to use actual symbols, though this reduces usability.

## Proof of Concept

A test demonstrating the vulnerability would:

1. Create NFT collection "TEST-0" and item "TEST-1"
2. Set alias "TEST" mapping to "TEST-1" 
3. Approve allowance of 1 for "TEST-1"
4. Submit two `TransferFrom` transactions concurrently:
   - Transaction A: `TransferFrom(owner, recipient1, "TEST", 1)` (using alias)
   - Transaction B: `TransferFrom(owner, recipient2, "TEST-1", 1)` (using actual symbol)
5. Observe both transactions succeed despite only 1 allowance being approved
6. Verify `GetResourceInfo` returned different WritePaths for the two transactions, causing incorrect parallelization

The test would require access to the parallel execution engine to verify path mismatch and concurrent execution behavior.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L40-64)
```csharp
            case nameof(TransferFrom):
            {
                var args = TransferFromInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), args.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.LockWhiteLists), args.Symbol, txn.From.ToString())
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };
                AddPathForAllowance(resourceInfo, args.From.ToString(), txn.From.ToString(), args.Symbol);
                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L71-82)
```csharp
    private void AddPathForAllowance(ResourceInfo resourceInfo, string from, string spender, string symbol)
    {
        resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender, symbol));
        resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender,
            GetAllSymbolIdentifier()));
        var symbolType = GetSymbolType(symbol);
        if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
        {
            resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender,
                GetNftCollectionAllSymbolIdentifier(symbol)));
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L254-259)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransferFrom(input.From, input.To, Context.Sender, tokenInfo.Symbol, input.Amount, input.Memo);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L738-779)
```csharp
    public override Empty SetSymbolAlias(SetSymbolAliasInput input)
    {
        // Alias setting can only work for NFT Item for now.
        // And the setting exists on the TokenInfo of the NFT Collection.

        // Can only happen on Main Chain.
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "Symbol alias setting only works on MainChain.");

        var collectionSymbol = GetNftCollectionSymbol(input.Symbol, true);

        // For now, token alias can only be set once.
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");

        CheckTokenAlias(input.Alias, collectionSymbol);

        var collectionTokenInfo = GetTokenInfo(collectionSymbol);
        if (collectionTokenInfo == null)
        {
            throw new AssertionException($"NFT Collection {collectionSymbol} not found.");
        }

        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");

        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);

        State.SymbolAliasMap[input.Alias] = input.Symbol;

        Context.LogDebug(() => $"Token alias added: {input.Symbol} -> {input.Alias}");

        Context.Fire(new SymbolAliasAdded
        {
            Symbol = input.Symbol,
            Alias = input.Alias
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```
