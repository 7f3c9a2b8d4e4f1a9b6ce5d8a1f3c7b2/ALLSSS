# Audit Report

## Title
Negative DepositBalance Due to Missing Validation in Sell Operation Allows Cross-Connector Balance Contamination

## Summary
The `Sell` function in TokenConverterContract calculates the amount of base tokens to return using the Bancor formula with the sum of `VirtualBalance` and `DepositBalance`, but only decrements `DepositBalance` without validating that the amount to receive does not exceed the actual deposit balance. Since multiple connector pairs share the same base token pool in the contract, this allows sell operations to succeed by draining tokens allocated to other connectors, causing the affected connector's `DepositBalance` to become negative and breaking accounting integrity.

## Finding Description

The vulnerability exists in the `Sell` function where Bancor pricing calculation and balance accounting are misaligned. [1](#0-0) 

The `GetSelfBalance` helper function returns the sum of virtual and actual balances for deposit account connectors. [2](#0-1) 

After calculating `amountToReceive` based on this combined balance, the contract transfers base tokens and then decrements only `DepositBalance` without validation. [3](#0-2) 

**Root Cause**: There is no validation ensuring `amountToReceive <= State.DepositBalance[toConnector.Symbol]` before the subtraction. The SafeMath `Sub()` operation uses checked arithmetic but only prevents overflow/underflow at type boundaries, not negative values within valid range. [4](#0-3) 

**Why Existing Protections Fail**: The base token transfer checks the contract's **total** base token balance across all connectors, not the per-connector `DepositBalance`. The system initializes multiple connector pairs that share the same base token in the `InitializeTokenConverterContract` method. [5](#0-4) 

A sell operation on one connector can succeed by using tokens allocated to another connector's `DepositBalance`, leaving the first connector with a negative `DepositBalance`. The `DepositBalance` state variable is defined as a simple mapped long value with no inherent non-negativity constraint. [6](#0-5) 

## Impact Explanation

**Direct Fund Impact**:
- `DepositBalance` can become negative, violating the critical invariant that deposit balances must be non-negative
- Users can extract more base tokens from a specific connector than actually allocated to it
- Cross-connector contamination allows draining one connector's reserves through sells on another connector

**Accounting Integrity Broken**:
- The `GetDepositConnectorBalance` view function returns incorrect values when `DepositBalance` is negative. [7](#0-6) 
- When `State.DepositBalance[ntSymbol]` is negative, the returned total balance appears lower than `VirtualBalance` alone
- All subsequent Bancor calculations for affected connectors use corrupted balance data, leading to incorrect pricing

**Affected Parties**:
- Users trading on connectors with negative `DepositBalance` receive incorrect prices
- Connectors whose reserves are drained become insolvent while showing positive virtual balances
- System-wide accounting diverges from actual token holdings over time

The severity is **Medium** due to broken accounting and fund misallocation, though exploitation requires accumulating significant resource tokens and depends on the relative sizes of virtual vs. deposit balances across connector pairs.

## Likelihood Explanation

**Reachable Entry Point**: The `Sell` function is a public method callable by any user with no special authorization requirements.

**Attacker Capabilities**:
1. Attacker must first acquire resource tokens (e.g., READ, WRITE) by buying them or receiving transfers
2. Attacker needs sufficient capital to buy enough tokens to trigger large sell returns
3. No privileged access required

**Feasible Preconditions**:
- Multiple connector pairs exist in production (verified in economic initialization with constants defining initial balances). [8](#0-7) 
- At least one connector has large `VirtualBalance` (10,000,000 tokens) but potentially small `DepositBalance`
- Other connectors have sufficient `DepositBalance` to cover the total contract transfer
- The Bancor formula calculates returns based on virtual+deposit but only deposit gets decremented

**Execution Practicality**: The attack is realistic because resource tokens can be purchased at market rates, and the system intentionally uses large virtual balances with potentially smaller deposit balances during initialization.

## Recommendation

Add validation before decrementing `DepositBalance` in the `Sell` function to ensure `amountToReceive` does not exceed the available deposit balance:

```csharp
// Before line 193-194 in TokenConverterContract.cs
Assert(amountToReceive <= State.DepositBalance[toConnector.Symbol], 
    "Insufficient deposit balance for this connector.");

State.DepositBalance[toConnector.Symbol] = 
    State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

Alternatively, use only the actual `DepositBalance` (not including `VirtualBalance`) when calculating `amountToReceive` through the Bancor formula, or ensure that `VirtualBalance` is properly accounted for separately and doesn't affect the deposit balance calculations.

## Proof of Concept

A proof of concept would require setting up a test with the following scenario:

1. Initialize TokenConverter with multiple connector pairs (e.g., READ/NTREAD and WRITE/NTWRITE)
2. Enable connectors with:
   - NTREAD: VirtualBalance = 10,000,000, DepositBalance = 1,000
   - NTWRITE: VirtualBalance = 10,000,000, DepositBalance = 50,000
3. Purchase large amount of READ tokens
4. Sell READ tokens such that Bancor formula calculates amountToReceive = 5,000 (less than total virtual+deposit but greater than NTREAD's DepositBalance)
5. Verify that:
   - Transfer succeeds (contract has 51,000 total)
   - NTREAD's DepositBalance becomes negative (-4,000)
   - GetDepositConnectorBalance returns incorrect value

The test would demonstrate that `State.DepositBalance[toConnector.Symbol].Sub(amountToReceive)` allows negative results when `amountToReceive > DepositBalance`, breaking the accounting invariant.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-212)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
        // Transfer sold token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = input.Symbol,
                From = Context.Sender,
                To = Context.Self,
                Amount = input.Amount
            });
        Context.Fire(new TokenSold
        {
            Symbol = input.Symbol,
            SoldAmount = input.Amount,
            BaseAmount = amountToReceive,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L58-61)
```csharp
        number1.Sub(5).ShouldBe(1UL);
        number2.Sub(5).ShouldBe(1L);
        Should.Throw<OverflowException>(() => { long.MaxValue.Sub(-5); });
        Should.Throw<OverflowException>(() => { ulong.MinValue.Sub(5); });
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L211-260)
```csharp
    private void InitializeTokenConverterContract()
    {
        State.TokenConverterContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName);
        var connectors = new List<Connector>
        {
            new()
            {
                Symbol = Context.Variables.NativeSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.5",
                VirtualBalance = EconomicContractConstants.NativeTokenConnectorInitialVirtualBalance
            }
        };
        foreach (var resourceTokenSymbol in Context.Variables
                     .GetStringArray(EconomicContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(EconomicContractConstants.PayRentalSymbolListName)))
        {
            var resourceTokenConnector = new Connector
            {
                Symbol = resourceTokenSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.ResourceTokenInitialVirtualBalance,
                RelatedSymbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsDepositAccount = false
            };
            var nativeTokenConnector = new Connector
            {
                Symbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
                RelatedSymbol = resourceTokenSymbol,
                IsDepositAccount = true
            };
            connectors.Add(resourceTokenConnector);
            connectors.Add(nativeTokenConnector);
        }

        State.TokenConverterContract.Initialize.Send(new InitializeInput
        {
            FeeRate = EconomicContractConstants.TokenConverterFeeRate,
            Connectors = { connectors },
            BaseTokenSymbol = Context.Variables.NativeSymbol
        });
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs (L19-19)
```csharp
    public MappedState<string, long> DepositBalance { get; set; }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L93-102)
```csharp
    public override Int64Value GetDepositConnectorBalance(StringValue symbolInput)
    {
        var connector = State.Connectors[symbolInput.Value];
        Assert(connector != null && !connector.IsDepositAccount, "token symbol is invalid");
        var ntSymbol = connector.RelatedSymbol;
        return new Int64Value
        {
            Value = State.Connectors[ntSymbol].VirtualBalance + State.DepositBalance[ntSymbol]
        };
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L5-21)
```csharp
    public const long NativeTokenConnectorInitialVirtualBalance = 100_000_00000000;

    // Token Converter Contract related.
    public const string TokenConverterFeeRate = "0.005";

    // Resource token related.
    public const long ResourceTokenTotalSupply = 500_000_000_00000000;

    public const int ResourceTokenDecimals = 8;

    //resource to sell
    public const long ResourceTokenInitialVirtualBalance = 100_000;

    public const string NativeTokenPrefix = "nt";

    public const long NativeTokenToResourceBalance = 10_000_000_00000000;

```
