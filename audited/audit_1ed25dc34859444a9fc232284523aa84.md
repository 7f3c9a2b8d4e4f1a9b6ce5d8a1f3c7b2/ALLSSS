# Audit Report

## Title
LockTimeMap Entries Not Removed After Withdrawal Causing Storage Bloat and Vote ID Reuse Denial of Service

## Summary
The Election contract's `Vote` method uses `LockTimeMap` to check if a vote already exists, but the `Withdraw` method never removes entries from this map. This causes two critical issues: (1) unbounded storage accumulation as `LockTimeMap` grows indefinitely, and (2) denial of service for users who provide custom tokens to generate deterministic vote IDs, as they cannot reuse those tokens after withdrawal.

## Finding Description

The vulnerability exists in the lifecycle management of the `LockTimeMap` state variable, which stores the lock duration for each vote.

**Vote Creation Flow**: The `Vote` method generates a vote ID and uses `LockTimeMap[voteId] == 0` as the existence check. If the value is zero (default for uninitialized entries), the vote is considered non-existent and creation proceeds. The lock time is then stored in the map. [1](#0-0) 

**Vote ID Generation**: When users provide a custom token in the `VoteMinerInput`, the same token always generates the same deterministic vote ID. This is documented as an intended feature. [2](#0-1) [3](#0-2) 

**Vote Withdrawal Flow**: The `Withdraw` method reads from `LockTimeMap` to validate that the lock period has expired, but crucially never removes the entry. While it removes the `WeightsAlreadyFixedMap` entry, the `LockTimeMap` entry persists indefinitely. [4](#0-3) [5](#0-4) 

**Vote Contract State**: The underlying Vote contract correctly tracks withdrawn votes by setting `IsWithdrawn = true` in the voting record, but the Election contract's `LockTimeMap` does not reflect this state change. [6](#0-5) 

**Attack Scenario**: 
1. User votes using custom token "X", generating voteId = `GenerateId(Self, "X")`
2. `LockTimeMap[voteId]` is set to 100 days
3. After 100 days, user withdraws successfully
4. `LockTimeMap[voteId]` still contains 100 days (not removed)
5. User attempts to vote again with token "X"
6. Same voteId is generated
7. Check `LockTimeMap[voteId] == 0` fails (value is 100 days)
8. Transaction reverts with "Vote already exists"
9. User is permanently blocked from reusing token "X"

## Impact Explanation

**Primary Impact - Denial of Service**: Users who utilize custom tokens for deterministic vote ID generation (for tracking, accounting, or automation purposes) are permanently prevented from reusing those tokens. This breaks the intended functionality where users should be able to vote again after withdrawing. The custom token feature is documented and tested, making this a legitimate use case. [7](#0-6) 

**Secondary Impact - Storage Bloat**: Every vote creates a permanent `LockTimeMap` entry. Over the lifetime of the chain with continuous voting activity, this leads to unbounded storage growth as the map accumulates entries that are never cleaned up.

**Tertiary Impact - Incorrect State Representation**: The contract uses `LockTimeMap` as an existence indicator, but this creates a semantic mismatch. Withdrawn votes (which have `IsWithdrawn = true` in the Vote contract) incorrectly appear as "existing" in the Election contract's logic, violating the principle that withdrawn votes should be treated as inactive.

## Likelihood Explanation

This issue has **HIGH** likelihood of occurrence:

**No Special Privileges Required**: The vulnerability affects the public `Vote` method accessible to all users. No governance approval, special roles, or elevated permissions are needed.

**Expected Usage Pattern**: Custom tokens are an explicitly documented feature with the proto field comment "Used to generate vote id". The test suite demonstrates this usage, confirming it as intended functionality rather than an edge case.

**Deterministic Occurrence**: Every withdrawal when using custom tokens results in the inability to reuse that token. The issue triggers automatically through normal contract usage without requiring special conditions or timing.

**Detection Difficulty**: Users discover the problem only when attempting to reuse a token post-withdrawal. The storage bloat occurs silently in the background.

## Recommendation

**Fix Option 1 (Preferred)**: Remove the `LockTimeMap` entry during withdrawal:

```csharp
public override Empty Withdraw(Hash input)
{
    // ... existing withdrawal logic ...
    
    if (!State.WeightsAlreadyFixedMap[input])
    {
        RemoveBeneficiaryOfVoter();
        State.WeightsAlreadyFixedMap.Remove(input);
    }
    
    // Add cleanup of LockTimeMap
    State.LockTimeMap.Remove(input);
    
    // ... rest of withdrawal logic ...
}
```

**Fix Option 2**: Query the Vote contract for proper existence checking instead of relying on `LockTimeMap`:

```csharp
public override Hash Vote(VoteMinerInput input)
{
    var voteId = GenerateVoteId(input);
    var votingRecord = State.VoteContract.GetVotingRecord.Call(voteId);
    Assert(votingRecord == null || votingRecord.IsWithdrawn, "Vote already exists.");
    State.LockTimeMap[voteId] = lockSeconds;
    // ... rest of vote logic ...
}
```

Option 1 is preferred as it solves both the DoS and storage bloat issues simultaneously.

## Proof of Concept

```csharp
[Fact]
public async Task LockTimeMap_VoteIdReuse_DoS_Test()
{
    // Setup: Announce election and get candidate
    var candidatesKeyPairs = await ElectionContract_AnnounceElection_Test();
    var candidateKeyPair = candidatesKeyPairs[0];
    
    const int lockTime = 100 * 60 * 60 * 24; // 100 days
    var customToken = HashHelper.ComputeFrom("my_custom_token");
    
    // Step 1: Vote with custom token
    var voteResult = await ElectionContractStub.Vote.SendAsync(new VoteMinerInput
    {
        CandidatePubkey = candidateKeyPair.PublicKey.ToHex(),
        Amount = 100,
        EndTimestamp = TimestampHelper.GetUtcNow().AddSeconds(lockTime),
        Token = customToken
    });
    voteResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var voteId = voteResult.Output;
    
    // Step 2: Fast forward past lock time
    BlockTimeProvider.SetBlockTime(TimestampHelper.GetUtcNow().AddDays(101));
    
    // Step 3: Withdraw successfully
    var withdrawResult = await ElectionContractStub.Withdraw.SendAsync(voteId);
    withdrawResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 4: Attempt to vote again with same custom token
    var secondVoteResult = await ElectionContractStub.Vote.SendAsync(new VoteMinerInput
    {
        CandidatePubkey = candidateKeyPair.PublicKey.ToHex(),
        Amount = 100,
        EndTimestamp = TimestampHelper.GetUtcNow().AddSeconds(lockTime),
        Token = customToken  // Same token as before
    });
    
    // VULNERABILITY: Transaction fails with "Vote already exists"
    // Expected: Should succeed since previous vote was withdrawn
    secondVoteResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    secondVoteResult.TransactionResult.Error.ShouldContain("Vote already exists");
}
```

## Notes

The vulnerability is confirmed through multiple verification points:
1. Code analysis shows `LockTimeMap` is set during vote creation but never removed
2. A comprehensive grep search confirms no removal code exists in the codebase
3. The existence check explicitly relies on `LockTimeMap[voteId] == 0`
4. Custom token usage is documented in the proto file and demonstrated in existing tests
5. The Vote contract maintains separate withdrawal state that is not synchronized with `LockTimeMap`

This is a production contract issue affecting normal user operations, not an edge case or theoretical vulnerability. The fix is straightforward: add `State.LockTimeMap.Remove(input)` to the withdrawal method.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L402-405)
```csharp
    private Hash GenerateVoteId(VoteMinerInput voteMinerInput)
    {
        if (voteMinerInput.Token != null)
            return Context.GenerateId(Context.Self, voteMinerInput.Token);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L432-434)
```csharp
        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L633-636)
```csharp
        var actualLockedTime = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockDays = State.LockTimeMap[input];
        Assert(actualLockedTime >= claimedLockDays,
            $"Still need {claimedLockDays.Sub(actualLockedTime).Div(86400)} days to unlock your token.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L665-669)
```csharp
        if (!State.WeightsAlreadyFixedMap[input])
        {
            RemoveBeneficiaryOfVoter();
            State.WeightsAlreadyFixedMap.Remove(input);
        }
```

**File:** protobuf/election_contract.proto (L297-298)
```text
    // Used to generate vote id.
    aelf.Hash token = 4;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L202-205)
```csharp
        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ElectionTests.cs (L246-248)
```csharp
            EndTimestamp = TimestampHelper.GetUtcNow().AddSeconds(lockTime),
            Token = HashHelper.ComputeFrom("token A")
        });
```
