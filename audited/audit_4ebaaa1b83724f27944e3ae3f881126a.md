### Title
MEV Frontrunning of EnableConnector Causes Undercollateralization via Balance Manipulation in GetNeededDeposit

### Summary
The `GetNeededDeposit()` function reads current token balances and total supply to calculate required base token deposits for enabling a connector. An attacker can frontrun `EnableConnector` transactions by transferring resource tokens to the TokenConverter contract, artificially inflating the balance and causing the calculation to return zero or insufficient deposit amounts. This results in undercollateralized connectors that cannot fulfill withdrawal obligations to sellers.

### Finding Description

The vulnerability exists in the interaction between `GetNeededDeposit()` and `EnableConnector()`:

**Location 1: GetNeededDeposit() reads manipulable state** [1](#0-0) 

The function queries current `TotalSupply` and the contract's token `balance`, then calculates `amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert`. If an attacker transfers tokens to the contract before this executes, `balance` increases, causing `amountOutOfTokenConvert` to decrease or become zero.

**Location 2: EnableConnector uses manipulated calculation without validation** [2](#0-1) 

The `EnableConnector` function has no access control restrictions (unlike other administrative functions) and no validation that the contract's balance is expected (typically zero before enabling). It blindly calls `GetNeededDeposit()` at line 276 and uses the potentially manipulated result to set `DepositBalance` at line 297.

**Location 3: DepositBalance directly set to manipulated value** [3](#0-2) 

The `DepositBalance` is SET (not added to) with the calculated `needDeposit.NeedAmount`. If this value is zero or artificially low due to balance manipulation, the connector becomes undercollateralized.

**Root Cause:** The calculation relies on reading state (token balance) that any external party can manipulate via simple token transfers before the transaction executes. There is no snapshot mechanism, balance consistency check, or validation that the balance represents an expected state.

**Why Protections Fail:** 
- No access control on `EnableConnector` (anyone can call it)
- No validation that contract balance is zero or within expected bounds before calculation
- No check to prevent re-enabling or overwriting existing DepositBalance
- No minimum deposit requirement or sanity check on calculated needDeposit

### Impact Explanation

**Direct Fund Impact - Loss of User Funds:**

When a connector is enabled with insufficient backing:
1. The `DepositBalance` (actual base token reserves) is set to the manipulated low value
2. The Bancor pricing formula uses `GetSelfBalance()` which combines `DepositBalance` with `VirtualBalance` [4](#0-3) 

3. While `VirtualBalance` is a constant pricing parameter, `DepositBalance` represents actual withdrawable funds
4. When users sell resource tokens, the contract attempts to transfer base tokens from its real balance [5](#0-4) 

5. The contract will run out of base tokens before all resource token holders can exit, causing insolvency

**Concrete Example:**
- Token X: TotalSupply = 1,000,000, should require 100,000 base tokens backing
- Attacker transfers 500,000 X tokens to contract before EnableConnector
- Calculation: amountOutOfTokenConvert = 1,000,000 - 500,000 - 500,000 = 0
- needDeposit = 0 (no backing calculated)
- Connector enabled with 1,000,000 resource tokens but 0 real base token reserves
- Last 100,000 base tokens worth of sellers cannot withdraw (100% loss for them)

**Who is Affected:**
- Resource token holders who attempt to sell after early traders deplete the insufficient reserves
- The protocol's reputation and trustworthiness
- Potentially the enabler who provided resource tokens but insufficient collateral

**Severity: HIGH** - Direct theft/loss of user funds through insolvency, affects critical pricing and reserve system.

### Likelihood Explanation

**Reachable Entry Point:** `EnableConnector` is a public method callable by anyone without access control restrictions (confirmed by test cases showing direct calls without authority setup). [6](#0-5) 

**Feasible Preconditions:**
1. A connector pair must be added via governance (`AddPairConnector`) but not yet enabled
2. Resource tokens must exist and be transferable
3. Attacker needs resource tokens to transfer (can be acquired on market or obtained if attacker is token holder)

**Execution Practicality:**
1. Attacker monitors mempool for pending `EnableConnector` transactions
2. Attacker submits higher-gas transaction to transfer tokens to TokenConverter contract address
3. Attacker's transaction executes first due to MEV priority
4. Victim's `EnableConnector` executes with manipulated balance state
5. All steps are standard blockchain operations, feasible on AElf

**Economic Rationality:**
- Attacker loses transferred tokens (cost: market value of tokens)
- However, if attacker IS the enabler (or colludes), they save on base token deposit
- Attack is profitable when: (saved deposit) > (value of transferred tokens)
- With low-liquidity or low-value resource tokens, this is economically viable
- Alternative: Pure griefing attack to damage protocol or specific token

**Attack Complexity:** Low - requires only basic MEV capabilities (transaction frontrunning) and standard token transfers.

**Detection:** Difficult to prevent at transaction time since token transfers are normal operations. No on-chain monitoring exists for abnormal balance changes before EnableConnector.

### Recommendation

**Immediate Mitigation - Add Balance Validation:**

1. In `EnableConnector`, add assertion before calling `GetNeededDeposit`:
```
var currentBalance = State.TokenContract.GetBalance.Call(
    new GetBalanceInput { Owner = Context.Self, Symbol = input.TokenSymbol }).Balance;
Assert(currentBalance == 0, "Contract must have zero balance before enabling connector");
```

2. Add check to prevent re-enabling:
```
Assert(!fromConnector.IsPurchaseEnabled, "Connector already enabled");
Assert(!toConnector.IsPurchaseEnabled, "Connector already enabled");
```

3. In `EnableConnector`, change DepositBalance from SET to ADD (line 297):
```
State.DepositBalance[toConnector.Symbol] = 
    State.DepositBalance[toConnector.Symbol].Add(needDeposit.NeedAmount);
```

**Invariant Checks to Add:**
- Assert contract balance is zero or within expected range before enabling
- Assert needDeposit meets minimum threshold relative to TotalSupply
- Add explicit check for connector already being enabled
- Emit event with expected vs actual balances for monitoring

**Test Cases to Prevent Regression:**
1. Test EnableConnector with non-zero contract balance (should fail)
2. Test frontrun scenario: transfer tokens then EnableConnector (should fail)
3. Test calling EnableConnector twice (should fail on second call)
4. Test that DepositBalance correctly accumulates if multiple deposits needed

### Proof of Concept

**Initial State:**
- Token X created with TotalSupply = 1,000,000
- Connector pair added for Token X via governance
- Token X distributed to users (900,000) and enabler Alice (100,000)
- Attacker Bob holds 400,000 Token X
- TokenConverter contract balance = 0

**Attack Sequence:**

1. **Alice prepares EnableConnector transaction:**
   - Parameter: `TokenSymbol = "X", AmountToTokenConvert = 100,000`
   - Expected: GetNeededDeposit calculates backing for 900,000 external tokens
   - Expected needDeposit: ~90,000 base tokens (hypothetical Bancor calculation)

2. **Bob monitors mempool and sees Alice's transaction**

3. **Bob frontruns with token transfer:**
   ```
   State.TokenContract.Transfer(
       Symbol: "X",
       To: TokenConverterContractAddress,  
       Amount: 400,000
   )
   ```
   - TokenConverter balance now = 400,000

4. **Alice's EnableConnector executes:**
   - GetNeededDeposit calculates: amountOutOfTokenConvert = 1,000,000 - 400,000 - 100,000 = 500,000
   - needDeposit calculated for 500,000 tokens: ~50,000 base tokens (instead of 90,000)
   - Alice transfers 100,000 Token X + 50,000 base tokens
   - DepositBalance set to 50,000 (insufficient!)

5. **Result State:**
   - Contract holds 500,000 Token X (400,000 from Bob + 100,000 from Alice)
   - DepositBalance = 50,000 base tokens
   - Should have 90,000 base tokens to back 900,000 external tokens
   - Deficit: 40,000 base tokens

**Expected vs Actual:**
- Expected: Connector enabled with 90,000 base token backing
- Actual: Connector enabled with 50,000 base token backing
- Success Condition: Last ~44% of sellers attempting to withdraw will fail due to insufficient reserves

**Verification:**
The attack succeeds if `DepositBalance` after EnableConnector is less than the properly calculated backing requirement, provable by comparing GetNeededDeposit results with and without the attacker's balance manipulation.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L62-73)
```csharp
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(
            new GetTokenInfoInput
            {
                Symbol = input.TokenSymbol
            });
        var balance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = input.TokenSymbol
            }).Balance;
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L186-194)
```csharp
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConvertConnectorTest.cs (L377-399)
```csharp
    public async Task EnableConnector_Success_Test()
    {
        await DefaultStub.Initialize.SendAsync(new InitializeInput
        {
            FeeRate = "0.005"
        });
        var tokenSymbol = "NETT";
        await CreateTokenAsync(tokenSymbol);
        await AddPairConnectorAsync(tokenSymbol);
        await TokenContractStub.Issue.SendAsync(new IssueInput
        {
            Amount = 99_9999_0000,
            To = DefaultSender,
            Symbol = tokenSymbol
        });
        var toBeBuildConnectorInfo = new ToBeConnectedTokenInfo
        {
            TokenSymbol = tokenSymbol,
            AmountToTokenConvert = 99_9999_0000
        };
        var deposit = await DefaultStub.GetNeededDeposit.CallAsync(toBeBuildConnectorInfo);
        deposit.NeedAmount.ShouldBe(100);
        await DefaultStub.EnableConnector.SendAsync(toBeBuildConnectorInfo);
```
