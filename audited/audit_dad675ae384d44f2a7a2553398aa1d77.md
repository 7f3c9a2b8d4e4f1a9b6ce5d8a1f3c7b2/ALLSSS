### Title
Quadratic Voting Implementation Broken - All Votes Cost Same Amount Due to Incorrect Vote Count Tracking

### Summary
The quadratic voting mechanism is fundamentally broken because `QuadraticVotesCountMap` uses unique `VoteId` values as keys, causing every vote to start with a fresh counter at zero. This defeats the core purpose of quadratic voting where subsequent votes should cost progressively more tokens. Instead, all votes cost the same flat rate (`TicketCost * 1`), allowing voters to acquire unlimited voting power at constant cost rather than increasing quadratic cost.

### Finding Description

The quadratic voting implementation tracks vote counts in `QuadraticVotesCountMap` using `VoteId` as the key. [1](#0-0) 

However, each vote generates a **unique** `VoteId` by incorporating `votingResult.VotesAmount` into the ID generation, which changes with every vote. [2](#0-1) 

Since `VotesAmount` is incremented with each vote, [3](#0-2)  every vote receives a different `VoteId`. This means:

1. **First vote by voter Alice**: Creates `VoteId1` → `QuadraticVotesCountMap[VoteId1]` starts at 0, increments to 1 → cost = `TicketCost * 1`
2. **Second vote by voter Alice**: Creates `VoteId2` → `QuadraticVotesCountMap[VoteId2]` starts at 0, increments to 1 → cost = `TicketCost * 1`
3. **Nth vote by voter Alice**: Creates `VoteIdN` → `QuadraticVotesCountMap[VoteIdN]` starts at 0, increments to 1 → cost = `TicketCost * 1`

The map should instead be keyed by `(Voter, VotingItemId, SnapshotNumber)` to accumulate a voter's vote count across multiple voting transactions. Currently, there is **no reset or decrement logic** anywhere - the map entries are write-once and abandoned. [4](#0-3) 

### Impact Explanation

**Severity: High** - This completely negates the fundamental mechanism of quadratic voting.

**Direct Governance Impact**: Quadratic voting is designed to prevent plutocracy by making it exponentially more expensive to dominate voting (1st vote costs 1 token, 2nd costs 2 more tokens, 3rd costs 3 more, etc.). With this bug:
- A voter wanting 100 votes should pay `TicketCost * (1+2+3+...+100) = TicketCost * 5,050` tokens
- Instead, they pay only `TicketCost * 100` tokens (50x cheaper)

**Who is affected**: All quadratic voting items where `IsQuadratic = true`. [5](#0-4) 

**Protocol damage**: 
- Wealthy voters can buy disproportionate influence cheaply
- Voting outcomes become plutocratic instead of quadratic
- Any governance decisions using quadratic voting are invalidated

### Likelihood Explanation

**Likelihood: Certain** - This bug activates automatically for any quadratic voting item.

**Attacker capabilities**: Any user can call the public `Vote()` method. [6](#0-5) 

**Attack complexity**: Trivial - simply call `Vote()` multiple times on the same voting item. Each call costs `TicketCost` instead of increasing.

**Preconditions**: Only requires a voting item registered with `IsQuadratic = true`. [7](#0-6) 

**Detection**: The bug is inherent in the design - no special conditions or timing needed. Every quadratic vote suffers from this issue.

**Economic rationality**: Exploiting this is economically beneficial with no downside - voters get maximum power for minimum cost.

### Recommendation

**Code-level fix**: Change the vote count tracking from per-VoteId to per-(Voter, VotingItemId, SnapshotNumber):

```csharp
// In VoteContractState.cs, replace:
public MappedState<Hash, long> QuadraticVotesCountMap { get; set; }

// With a composite key structure:
public MappedState<Address, Hash, long, long> QuadraticVotesCountMap { get; set; }
// Key: (Voter Address, VotingItemId, SnapshotNumber) -> Vote Count

// In VoteContract.cs Vote() method, replace lines 100-102 with:
var countKey = GetQuadraticVoteCountKey(input.Voter, input.VotingItemId, votingItem.CurrentSnapshotNumber);
var currentVotesCount = State.QuadraticVotesCountMap[input.Voter][input.VotingItemId][votingItem.CurrentSnapshotNumber].Add(1);
State.QuadraticVotesCountMap[input.Voter][input.VotingItemId][votingItem.CurrentSnapshotNumber] = currentVotesCount;
amount = votingItem.TicketCost.Mul(currentVotesCount);
```

**Reset logic**: When `TakeSnapshot()` is called, the count naturally resets for the new snapshot number (if per-snapshot accumulation is desired). [8](#0-7) 

**Withdraw handling**: When votes are withdrawn, decrement the count to allow re-voting at the correct price. [9](#0-8) 

**Test cases**: Add tests that:
1. Verify 1st vote costs `TicketCost * 1`, 2nd costs `TicketCost * 2`, 3rd costs `TicketCost * 3`
2. Verify count resets (or persists) correctly across snapshots based on intended behavior
3. Verify withdrawal correctly decrements the count

### Proof of Concept

**Initial state**:
1. Register a quadratic voting item with `IsQuadratic = true`, `TicketCost = 100`
2. Voter Alice has 10,000 tokens

**Exploit steps**:
1. Alice calls `Vote(votingItemId, option="A", amount=ignored)` 
   - Expected cost: 100 tokens (1st vote)
   - Actual cost: 100 tokens ✓
   
2. Alice calls `Vote(votingItemId, option="A", amount=ignored)` again
   - **Expected cost**: 200 tokens (2nd vote should cost 2x)
   - **Actual cost**: 100 tokens ✗ (Bug: costs same as first)
   
3. Alice calls `Vote()` 8 more times
   - **Expected total cost**: 100*(1+2+3+...+10) = 5,500 tokens
   - **Actual total cost**: 100*10 = 1,000 tokens ✗

**Success condition**: Alice has spent 1,000 tokens but gained 10 votes, when she should have spent 5,500 tokens. She saved 4,500 tokens (82% discount) while accumulating the same voting power.

**Result verification**: Check `VotingResult.Results["A"]` - it will show 10 vote weight (one per vote call) [10](#0-9)  but Alice only paid 1/5.5 of the intended token cost.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L90-90)
```csharp
    public override Empty Vote(VoteInput input)
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L94-103)
```csharp
        if (!votingItem.IsQuadratic)
        {
            amount = input.Amount;
        }
        else
        {
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L119-119)
```csharp
        UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L179-179)
```csharp
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L191-239)
```csharp
    public override Empty Withdraw(WithdrawInput input)
    {
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;

        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;

        if (votingItem.IsLockToken)
            State.TokenContract.Unlock.Send(new UnlockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                Amount = votingRecord.Amount,
                LockId = input.VoteId
            });

        Context.Fire(new Withdrawn
        {
            VoteId = input.VoteId
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L241-273)
```csharp
    public override Empty TakeSnapshot(TakeSnapshotInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);

        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");

        Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");

        // Update previous voting going information.
        var previousVotingResultHash = GetVotingResultHash(input.VotingItemId, votingItem.CurrentSnapshotNumber);
        var previousVotingResult = State.VotingResults[previousVotingResultHash];
        previousVotingResult.SnapshotEndTimestamp = Context.CurrentBlockTime;
        State.VotingResults[previousVotingResultHash] = previousVotingResult;

        Assert(votingItem.CurrentSnapshotNumber == input.SnapshotNumber,
            $"Can only take snapshot of current snapshot number: {votingItem.CurrentSnapshotNumber}, but {input.SnapshotNumber}");
        var nextSnapshotNumber = input.SnapshotNumber.Add(1);
        votingItem.CurrentSnapshotNumber = nextSnapshotNumber;
        State.VotingItems[votingItem.VotingItemId] = votingItem;

        // Initial next voting going information.
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L397-397)
```csharp
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
```

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L30-33)
```csharp
    /// <summary>
    ///     Vote Id -> Votes Count
    /// </summary>
    public MappedState<Hash, long> QuadraticVotesCountMap { get; set; }
```

**File:** protobuf/vote_contract.proto (L100-103)
```text
    // Is quadratic voting.
    bool is_quadratic = 7;
    // Quadratic voting item ticket cost.
    int64 ticket_cost = 8;
```
