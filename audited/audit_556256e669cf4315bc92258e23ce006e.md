### Title
Replaced Miner Can Skip Secret Revelation While Producing Next-Round Trigger Block

### Summary
In `GetConsensusExtraDataForNextRound()`, a miner who is being replaced (present in current round but not in next round) can produce the next-round trigger block but skip the `RevealSharedInValues()` call via an early return. This allows them to avoid reconstructing and revealing other miners' InValues from secret shares, breaking the secret sharing security model and potentially compromising consensus randomness.

### Finding Description

The vulnerability exists in `GetConsensusExtraDataForNextRound()` where a conditional check determines whether to call `RevealSharedInValues()`. [1](#0-0) 

When a miner is not present in the next round's miner list (replaced due to poor performance, governance decisions, etc.), the function returns early without calling `RevealSharedInValues()`. This is problematic because:

1. **Replaced miners can still produce next-round blocks**: The `PreCheck()` function validates that the block producer is in either the current or previous round miner list, not necessarily the next round: [2](#0-1) 

2. **Secret revelation is skipped**: When `RevealSharedInValues()` is bypassed, the function fails to reconstruct miners' InValues from Round N using Shamir's Secret Sharing. This function is responsible for decoding encrypted secret pieces: [3](#0-2) 

3. **Missing PreviousInValues lead to predictable fallbacks**: When miners in Round N+1 produce blocks without their PreviousInValue set (because it wasn't revealed), they fall back to using `previousRound.RealTimeMinersInformation[pubkey].InValue` or a predictable fake value: [4](#0-3) 

The fake value generation at line 96 is deterministic (`HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()))`), which breaks the unpredictability requirement for consensus randomness.

### Impact Explanation

**Consensus Security Degradation**: The secret sharing mechanism in AEDPoS is designed to ensure that miners' InValues (used for randomness generation) can be reconstructed even if individual miners go offline or act maliciously. By skipping `RevealSharedInValues()`, a replaced miner prevents this reconstruction for Round N+1.

**Randomness Compromise**: The signature calculation for determining miner order depends on PreviousInValue: [5](#0-4) 

When PreviousInValues are missing or use predictable fake values, the randomness of miner ordering in subsequent rounds is reduced. An attacker could potentially manipulate or predict block production order.

**Affected Parties**: 
- Miners who produced blocks in Round N but didn't explicitly reveal their InValue (e.g., due to network issues or going offline)
- The overall consensus security model which relies on Shamir's Secret Sharing threshold cryptography
- Future round order determination which depends on unpredictable signatures

**Severity Justification**: This breaks a critical security invariant of the consensus mechanism - that InValues should be reconstructable through secret sharing, not through fallback mechanisms or stored values.

### Likelihood Explanation

**Attacker Capabilities**: The attacker must be:
- A current miner (in Round N)
- Designated as the extra block producer for Round N
- Scheduled to be replaced and not included in Round N+1

**Attack Complexity**: Low to Medium
- Miner replacement is a normal occurrence (poor performance, governance votes, etc.)
- If a replaced miner happens to be the extra block producer, they automatically get the opportunity
- No special transaction crafting or complex exploits required - the vulnerability is triggered by normal block production

**Feasibility Conditions**:
1. Secret sharing must be enabled (checked via configuration): [6](#0-5) 

2. The replaced miner must be the extra block producer for the round
3. At least one other miner must have pending InValue reconstruction needs

**Detection/Operational Constraints**: 
- The exploit occurs during normal block production flow
- No obvious failure or revert occurs
- The missing secret revelation is subtle and may not be immediately detected
- Impact compounds over multiple rounds if the pattern continues

**Probability Reasoning**: Medium to High probability in active networks where miner lists change regularly through governance or performance-based replacement.

### Recommendation

**Primary Fix**: Remove the early return and always call `RevealSharedInValues()` regardless of whether the block producer is in the next round:

```diff
  private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
      string pubkey, AElfConsensusTriggerInformation triggerInformation)
  {
      GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
      
      nextRound.ExtraBlockProducerOfPreviousRound = pubkey;
      
-     if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
-         // This miner was replaced by another miner in next round.
-         return new AElfConsensusHeaderInformation
-         {
-             SenderPubkey = ByteStringHelper.FromHexString(pubkey),
-             Round = nextRound,
-             Behaviour = triggerInformation.Behaviour
-         };
      
-     RevealSharedInValues(currentRound, pubkey);
+     // Always reveal secrets regardless of whether producer is in next round
+     RevealSharedInValues(nextRound, pubkey);
      
+     if (nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
+     {
          nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
              nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
          Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
          nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
          nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
              .Add(Context.CurrentBlockTime);
+     }
      
      return new AElfConsensusHeaderInformation
      {
          SenderPubkey = ByteStringHelper.FromHexString(pubkey),
          Round = nextRound,
          Behaviour = triggerInformation.Behaviour
      };
  }
```

**Critical Note**: The fix should also pass `nextRound` instead of `currentRound` to `RevealSharedInValues()` so that InValues from Round N are revealed into Round N+1, not InValues from Round N-1 into Round N.

**Additional Invariant Checks**:
- Add assertion that if secret sharing is enabled, revealed InValue count meets a minimum threshold
- Log warning when fallback fake values are used for PreviousInValue
- Add monitoring for miners using predictable fallback values

**Test Cases**:
1. Test replaced miner producing next-round block with secret sharing enabled
2. Verify all miners' PreviousInValues are properly reconstructed regardless of block producer replacement status
3. Test that InValues from Round N are correctly revealed into Round N+1
4. Verify randomness properties of signature calculation with and without proper secret revelation

### Proof of Concept

**Initial State**:
- Secret sharing is enabled in configuration
- Round N has miners: [A, B, C, D, E]
- Round N+1 will have miners: [B, C, D, E, F] (Miner A is replaced)
- Miner A is the extra block producer for Round N
- Miner B produced a block in Round N but went offline before explicitly revealing their InValue
- Miner B's InValue was encrypted and shared as secret pieces during Round N

**Attack Steps**:
1. Time reaches the extra block mining time for Round N
2. Miner A (replaced) produces the next-round trigger block
3. `GetConsensusExtraDataForNextRound()` is called with Miner A as the block producer
4. Line 180 check: Miner A is NOT in `nextRound.RealTimeMinersInformation.Keys`
5. Early return at lines 182-187 executes, skipping `RevealSharedInValues(currentRound, pubkey)`
6. Round N+1 begins without Miner B's InValue being reconstructed from secret shares

**Expected Result**: 
- Miner B's InValue from Round N should be reconstructed using Shamir's Secret Sharing
- Stored as Miner B's PreviousInValue in Round N+1
- Used for proper signature calculation when Miner B produces blocks in Round N+1

**Actual Result**:
- Miner B's InValue is NOT reconstructed
- Miner B's PreviousInValue remains null/empty in Round N+1
- When Miner B produces their first block in Round N+1, they use fallback fake value: `HashHelper.ComputeFrom("B" + CurrentHeight.ToString())`
- This predictable value compromises the randomness of Miner B's signature and subsequent order determination

**Success Condition**: The secret sharing security model is bypassed, and consensus randomness is reduced through the use of predictable fallback values instead of properly reconstructed secret shares.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L94-108)
```csharp
            else
            {
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L180-187)
```csharp
        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
