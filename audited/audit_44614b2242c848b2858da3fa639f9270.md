# Audit Report

## Title
Unfair Extra Block Producer Selection Due to Unvalidated TuneOrderInformation and Validation Bypass

## Summary
The AEDPoS consensus contract allows miners to manipulate `FinalOrderOfNextRound` values through unvalidated `TuneOrderInformation` data in `UpdateValue` transactions, creating duplicate mining orders that bypass validation and systematically bias extra block producer selection towards miners with lower order values through a `.First()` fallback mechanism.

## Finding Description

The vulnerability involves three interconnected flaws in the consensus round generation and validation logic:

**1. Unvalidated TuneOrderInformation Manipulation**

When miners submit `UpdateValue` transactions, they can provide arbitrary `TuneOrderInformation` that directly modifies other miners' `FinalOrderOfNextRound` values without any validation: [1](#0-0) 

The `UpdateValueValidationProvider` only validates signature and previous in-value correctness, but completely ignores `TuneOrderInformation` contents: [2](#0-1) 

**2. Validation Bypass via Incorrect .Distinct() Usage**

The `NextRoundMiningOrderValidationProvider` attempts to detect duplicate orders but fails because it calls `.Distinct()` on entire `MinerInRound` objects rather than their `FinalOrderOfNextRound` values: [3](#0-2) 

This counts distinct miner objects, not distinct order values. Two miners with the same `FinalOrderOfNextRound` are considered distinct objects, allowing duplicates to pass validation.

**3. Deterministic Fallback Bias**

When `GenerateNextRoundInformation()` calculates the extra block producer order, it searches for a miner matching that order. If duplicate orders create gaps (e.g., two miners have order 3, leaving order 1 or 2 empty), the fallback mechanism selects `.First()`: [4](#0-3) 

Since miners are inserted in ascending `FinalOrderOfNextRound` order, `.First()` systematically favors miners with the lowest order values: [5](#0-4) 

**Exploitation Scenario**:
1. Malicious Miner D submits `UpdateValue` with `TuneOrderInformation = {A: 3, B: 3}`
2. Both Miner A and Miner B now have `FinalOrderOfNextRound = 3`
3. Validation passes because `.Distinct()` counts 2 distinct miner objects
4. Next round generation: orders 1-2 are gaps, both A and B have order 3
5. `CalculateNextExtraBlockProducerOrder()` returns order 1 or 2 (the gap)
6. Fallback triggers: `.First()` selects A or B (whoever has lowest pubkey in iteration order)
7. Miners with order 3 systematically favored for extra block producer role

## Impact Explanation

**Consensus Reward Manipulation**: Extra block producers receive additional mining rewards. By creating duplicate orders and exploiting the fallback bias, malicious miners can systematically increase their probability of selection, creating unfair reward accumulation over time.

**Mining Schedule Disruption**: Duplicate `FinalOrderOfNextRound` values result in duplicate `Order` values in the next round, causing multiple miners to have identical `ExpectedMiningTime`: [6](#0-5) 

This breaks the mining time slot allocation, potentially causing mining conflicts and consensus disruption.

**Fairness Violation**: The extra block producer role is designed to be distributed based on cryptographic randomness. The exploitable fallback mechanism violates this fairness principle, allowing strategic manipulation of consensus rewards.

## Likelihood Explanation

**High Likelihood**: 
- Any miner can submit `UpdateValue` transactions with malicious `TuneOrderInformation`
- No validation prevents arbitrary order manipulation
- The `.Distinct()` bug guarantees validation bypass
- Requires only a single malicious miner
- Exploitation is deterministic and repeatable

**No Protective Barriers**:
- `UpdateValueValidationProvider` ignores `TuneOrderInformation`
- `NextRoundMiningOrderValidationProvider` fails to detect duplicates
- No additional checks exist in the processing pipeline

## Recommendation

**Fix 1: Validate TuneOrderInformation Contents**

In `ProcessUpdateValue`, validate that `TuneOrderInformation` only contains miners whose orders actually need adjustment based on the current round state, and ensure no duplicates are created: [7](#0-6) 

**Fix 2: Correct the Validation Logic**

In `NextRoundMiningOrderValidationProvider`, call `.Distinct()` on the order values, not the miner objects:

```csharp
var distinctOrderCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Add this line
    .Distinct()
    .Count();
``` [8](#0-7) 

**Fix 3: Add Explicit Duplicate Detection**

Before applying `TuneOrderInformation`, verify no duplicate `FinalOrderOfNextRound` values would result.

## Proof of Concept

```csharp
[Fact]
public async Task Exploit_UnfairExtraBlockProducerSelection_Via_TuneOrderManipulation()
{
    // Setup: 5 miners in round
    var miners = new[] { "MinerA", "MinerB", "MinerC", "MinerD", "MinerE" };
    
    // Miners A, B, C have already mined with orders 1, 2, 4
    var currentRound = CreateRoundWithMiners(miners);
    currentRound.RealTimeMinersInformation["MinerA"].FinalOrderOfNextRound = 1;
    currentRound.RealTimeMinersInformation["MinerB"].FinalOrderOfNextRound = 2;
    currentRound.RealTimeMinersInformation["MinerC"].FinalOrderOfNextRound = 4;
    
    // Miner D exploits: sets malicious TuneOrderInformation
    var maliciousTuneOrders = new Dictionary<string, int>
    {
        { "MinerA", 3 },  // Move A to 3
        { "MinerB", 3 }   // Move B to 3 (duplicate!)
    };
    
    // Process Miner D's UpdateValue with malicious TuneOrderInformation
    await AEDPoSContract.UpdateValue(new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("D"),
        Signature = HashHelper.ComputeFrom("DSig"),
        SupposedOrderOfNextRound = 5,
        TuneOrderInformation = { maliciousTuneOrders }  // No validation!
    });
    
    // Verify duplicates created and validation bypassed
    var updatedRound = await AEDPoSContract.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.Equal(3, updatedRound.RealTimeMinersInformation["MinerA"].FinalOrderOfNextRound);
    Assert.Equal(3, updatedRound.RealTimeMinersInformation["MinerB"].FinalOrderOfNextRound);
    
    // Generate next round - triggers fallback
    updatedRound.GenerateNextRoundInformation(Context.CurrentBlockTime, 
        GetBlockchainStartTimestamp(), out var nextRound);
    
    // Verify gap exists (no miner has order 1 or 2) and fallback triggered
    var extraBlockProducer = nextRound.RealTimeMinersInformation.Values
        .First(m => m.IsExtraBlockProducer);
    
    // Fallback selected .First(), which is a miner with order 3 (A or B)
    Assert.True(extraBlockProducer.Pubkey == "MinerA" || 
                extraBlockProducer.Pubkey == "MinerB");
    Assert.Equal(3, extraBlockProducer.Order);
}
```

## Notes

This vulnerability combines three issues: unvalidated input manipulation, incorrect validation logic, and biased fallback selection. The exploitation is deterministic and can be executed by any miner, posing a significant threat to consensus fairness. The duplicate orders also break mining time slot allocation, potentially disrupting normal consensus operation beyond just reward distribution.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-26)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L33-33)
```csharp
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-65)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```
