### Title
Proposer Spoofing in User Contract Deployments - Hidden Author Identity Enables Malicious Contracts to Masquerade as System-Initiated

### Summary
User contract deployments via `DeployUserSmartContract` create Parliament proposals with both `Proposer` and `OriginProposer` set to the Genesis contract (Context.Self), making them indistinguishable from system-initiated proposals. The actual author/initiator is hidden in internal state with no public visibility during the approval process, allowing attackers to deploy malicious contracts under false pretenses of system authorization.

### Finding Description

The vulnerability exists in the `SendUserContractProposal` function which is called during user contract deployment and update operations. [1](#0-0) 

When a user calls `DeployUserSmartContract`, the system sets:
- `Proposer = Context.Self` (Genesis contract) in ContractProposingInput
- `OriginProposer = Context.Self` (Genesis contract) in CreateProposalBySystemContractInput
- `Author = Context.Sender` (actual user) in ContractProposingInput only [2](#0-1) 

The ContractProposingInput structure stores the Author field, but this is internal state with no public view method: [3](#0-2) 

When Parliament receives the proposal via `CreateProposalBySystemContract`, it validates that the `OriginProposer` (Genesis) is authorized, not the actual user: [4](#0-3) 

The resulting ProposalInfo stored in Parliament contains only the Proposer field (set to Genesis), with no OriginProposer or Author information: [5](#0-4) 

The proposal parameters contain UserContractDeploymentInput which has no author field: [6](#0-5) 

On the main chain, the authorization check allows any user to deploy contracts: [7](#0-6) 

### Impact Explanation

**Authorization/Governance Impact:**
- Attackers can deploy malicious contracts that appear to be system-initiated proposals from the Genesis contract
- Miners reviewing proposals via `GetProposal` see only "Proposer: Genesis Contract" with no indication of the actual initiator
- The `IsUserContract` flag in `CodeCheckRequired` event provides minimal differentiation but doesn't reveal WHO the user is
- Creates a false sense of system endorsement that could reduce code scrutiny during approval
- Completely breaks the accountability chain - the actual deployer is invisible during the critical approval window

**Operational Impact:**
- Undermines the proposal review process by hiding critical information about proposal origin
- Miners cannot assess whether the deployer is trustworthy or a known bad actor
- No transparency mechanism exists to query the Author before contract deployment
- Could enable social engineering attacks where malicious contracts gain approval under false pretenses

**Severity Justification: HIGH**
- Complete opacity during approval process for user-initiated contracts
- Any user on main chain can exploit this without special permissions
- Direct impact on governance security and contract deployment integrity
- No mitigating controls to reveal actual author during review

### Likelihood Explanation

**Reachable Entry Point:**
`DeployUserSmartContract` is a public method callable by any user on the main chain.

**Attacker Capabilities Required:**
- Main chain: Any user can call `DeployUserSmartContract` (no whitelist check)
- Side chain: User must be in Parliament proposer whitelist
- No special privileges, tokens, or roles required beyond basic transaction submission

**Attack Complexity: LOW**
1. Attacker calls `DeployUserSmartContract` with malicious contract code
2. System automatically creates proposal with Proposer=Genesis, OriginProposer=Genesis
3. Proposal appears in Parliament as system-initiated
4. Miners review without visibility to actual author
5. If approved, contract deploys with attacker as author (but only visible after deployment)

**Feasibility Conditions:**
- Main chain environment (side chains have whitelist restrictions)
- Miners must approve the proposal (but with reduced transparency)
- No additional barriers beyond standard proposal approval process

**Detection Constraints:**
- No on-chain mechanism to detect this spoofing during approval
- Author is only revealed after deployment, not during review
- CodeCheckRequired event shows IsUserContract=true but not the author
- Requires off-chain analysis of ContractProposingInput state to identify author

**Probability: HIGH**
This is not a theoretical vulnerability - it is the designed behavior for all user contract deployments. Every user contract deployment exhibits this proposer spoofing pattern, making it trivially exploitable.

### Recommendation

**Immediate Mitigation:**
Add the Author/Initiator field to the proposal params so miners can see who actually requested the deployment:

1. Modify `UserContractDeploymentInput` to include an author field:
```protobuf
message UserContractDeploymentInput {
    sint32 category = 1;
    bytes code = 2;
    aelf.Hash salt = 3;
    aelf.Address author = 4;  // ADD THIS
}
```

2. Populate this field in `SendUserContractProposal` from `Context.Sender`

3. Add a view method to query ContractProposingInput:
```protobuf
rpc GetContractProposingInput(aelf.Hash) returns (ContractProposingInput) {
    option (aelf.is_view) = true;
}
```

**Alternative Approach:**
Store the OriginProposer in Parliament's ProposalInfo structure so it's visible in proposal queries:
```protobuf
message ProposalInfo {
    ...
    aelf.Address proposer = 6;
    aelf.Address origin_proposer = 13;  // ADD THIS
    ...
}
```

**Invariant Checks:**
- Ensure all user contract proposals clearly identify the actual initiator
- Add validation that Author matches the transaction origin for user contracts
- Implement transparency requirements for all proposal types

**Test Cases:**
- Verify miners can query Author before approving user contract proposals
- Test that GetProposal returns sufficient information to identify proposal origin
- Validate that system-initiated and user-initiated proposals are distinguishable

### Proof of Concept

**Initial State:**
- Main chain with Parliament contract deployed
- Genesis contract initialized with CodeCheckController set
- Attacker has a regular account with no special permissions

**Attack Steps:**

1. **Attacker deploys malicious contract:**
   - Call `BasicContractZero.DeployUserSmartContract(UserContractDeploymentInput{category: 0, code: <malicious_bytecode>, salt: <random>})`
   - Transaction executes successfully

2. **System creates spoofed proposal:**
   - `SendUserContractProposal` stores: `ContractProposingInput{Proposer: GenesisAddress, Author: AttackerAddress, Status: CodeCheckProposed}`
   - Parliament proposal created with: `ProposalInfo{Proposer: GenesisAddress, ToAddress: GenesisAddress, ContractMethodName: "PerformDeployUserSmartContract"}`
   - `CodeCheckRequired` event fired with `IsUserContract: true` but no author info

3. **Miners review proposal:**
   - Call `Parliament.GetProposal(proposalId)`
   - **Result:** Proposer shows Genesis contract address, no indication of AttackerAddress
   - Call `UserContractDeploymentInput.Parser.ParseFrom(proposal.Params)`
   - **Result:** Only code, category, salt visible - no author field
   - No way to query ContractProposingInput.Author

4. **Expected behavior:**
   - Miners should see: "Proposed by User: [AttackerAddress]"
   
5. **Actual behavior:**
   - Miners see: "Proposed by: [GenesisAddress]" 
   - Proposal appears system-initiated
   - Attacker's identity completely hidden

**Success Condition:**
The proposal in Parliament shows Proposer=Genesis with no visibility to the actual attacker's address, enabling malicious contracts to appear as system-initiated proposals during the critical approval window.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L312-342)
```csharp
    private void SendUserContractProposal(Hash proposingInputHash, string releaseMethodName, ByteString @params)
    {
        var registered = State.ContractProposingInputMap[proposingInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var proposedInfo = new ContractProposingInput
        {
            Proposer = Context.Self,
            Status = ContractProposingInputStatus.CodeCheckProposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod()),
            Author = Context.Sender
        };
        State.ContractProposingInputMap[proposingInputHash] = proposedInfo;

        var codeCheckController = State.CodeCheckController.Value;
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName = releaseMethodName,
                Params = @params,
                OrganizationAddress = codeCheckController.OwnerAddress,
                ExpiredTime = proposedInfo.ExpiredTime
            },
            OriginProposer = Context.Self
        };

        Context.SendInline(codeCheckController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L344-357)
```csharp
    private void AssertUserDeployContract()
    {
        // Only the symbol of main chain or public side chain is native symbol.
        RequireTokenContractContractAddressSet();
        var primaryTokenSymbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;
        if (Context.Variables.NativeSymbol == primaryTokenSymbol)
        {
            return;
        }

        RequireParliamentContractAddressSet();
        var whitelist = State.ParliamentContract.GetProposerWhiteList.Call(new Empty());
        Assert(whitelist.Proposers.Contains(Context.Sender), "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L409-443)
```csharp
    public override DeployUserSmartContractOutput DeployUserSmartContract(UserContractDeploymentInput input)
    {
        AssertInlineDeployOrUpdateUserContract();
        AssertUserDeployContract();

        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        Context.LogDebug(() => "BasicContractZero - Deployment user contract hash: " + codeHash.ToHex());

        AssertContractNotExists(codeHash);

        if (input.Salt != null)
        {
            AssertContractAddressAvailable(Context.Sender, input.Salt);
        }

        var proposedContractInputHash = CalculateHashFromInput(input);
        SendUserContractProposal(proposedContractInputHash,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.PerformDeployUserSmartContract),
            input.ToByteString());

        // Fire event to trigger BPs checking contract code
        Context.Fire(new CodeCheckRequired
        {
            Code = input.Code,
            ProposedContractInputHash = proposedContractInputHash,
            Category = input.Category,
            IsSystemContract = false,
            IsUserContract = true
        });

        return new DeployUserSmartContractOutput
        {
            CodeHash = codeHash
        };
    }
```

**File:** protobuf/basic_contract_zero.proto (L68-77)
```text
message ContractProposingInput{
    // The address of proposer for contract deployment/update.
    aelf.Address proposer = 1;
    // The status of proposal.
    ContractProposingInputStatus status = 2;
    // The expiration time of proposal.
    google.protobuf.Timestamp expired_time = 3;
    // The author of the contract.
    aelf.Address author = 4;
}
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L68-76)
```csharp
    public override Hash CreateProposalBySystemContract(CreateProposalBySystemContractInput input)
    {
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Unauthorized to propose.");
        AssertIsAuthorizedProposer(input.ProposalInput.OrganizationAddress, input.OriginProposer);

        var proposalId = CreateNewProposal(input.ProposalInput);
        return proposalId;
    }
```

**File:** protobuf/parliament_contract.proto (L116-141)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
```

**File:** protobuf/acs0.proto (L164-170)
```text
message UserContractDeploymentInput {
    // The category of contract code(0: C#).
    sint32 category = 1;
    // The byte array of the contract code.
    bytes code = 2;
    aelf.Hash salt = 3;
}
```
