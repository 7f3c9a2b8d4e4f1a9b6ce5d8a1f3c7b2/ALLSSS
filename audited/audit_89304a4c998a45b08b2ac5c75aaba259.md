### Title
Empty Miner Lists Cause Zero Maximum Blocks Count Leading to Cascading Block Production Throttling

### Summary
When no miners successfully mine blocks in previous rounds (empty `MinedMinerListMap.Pubkeys`), the `GetMaximumBlocksCount()` function returns 0 due to empty set intersection. This triggers a cascading effect where `ResetLatestProviderToTinyBlocksCount` sets `BlocksCount` to -1, forcing all miners into NextRound behavior after producing a single block, severely throttling block production during network recovery periods.

### Finding Description

The vulnerability exists in the maximum blocks count calculation during Abnormal blockchain status. [1](#0-0) 

**Root Cause:**

When the blockchain enters Abnormal state (LIB not advancing), the code retrieves mined miner lists from previous two rounds and calculates their intersection. [2](#0-1) 

Miners are considered "mined" only if they have `SupposedOrderOfNextRound != 0`, which is set during `UpdateValue` processing. [3](#0-2) 

During severe network issues, if few or no miners successfully produce UpdateValue blocks in rounds N-1 and N-2, `GetMinedMiners()` returns empty lists, which are recorded in `MinedMinerListMap`. [4](#0-3) 

When both `previousRoundMinedMinerList.Pubkeys` and `previousPreviousRoundMinedMinerList.Pubkeys` are empty:
- `Intersect()` returns empty set with `Count() = 0`
- `factor = 0 * (threshold - distance) = 0`
- `Ceiling(0, count) = 0`
- `GetMaximumBlocksCount()` returns 0

**Cascading Failure:**

When any consensus information is processed, `ResetLatestProviderToTinyBlocksCount` is called with the maximum blocks count. [5](#0-4) 

When a different miner produces the next block, the function sets `BlocksCount = minersCountInTheory.Sub(1)`. [6](#0-5) 

With `minersCountInTheory = 0`, this results in `BlocksCount = -1`.

Subsequently, when that miner requests a consensus command, the negative BlocksCount forces NextRound behavior. [7](#0-6) 

**Why Protections Fail:**

1. Miners cannot produce TinyBlocks because `ActualMiningTimes.Count < 0` is always false. [8](#0-7) 

2. Each active miner gets `BlocksCount = -1` after producing one block, progressively forcing all miners into NextRound-only mode.

3. NextRound blocks have future-scheduled mining times, creating delays. [9](#0-8) 

### Impact Explanation

**Operational Impact:**

The vulnerability causes severe blockchain throughput degradation during network recovery:

1. **Tiny Block Elimination**: Intended high-throughput tiny blocks are completely disabled (maximum count = 0)

2. **Forced NextRound Throttling**: All miners are progressively forced into NextRound behavior after producing a single block, even though they could produce valid UpdateValue blocks

3. **Recovery Hindrance**: The mechanism meant to stabilize the network during Abnormal state actually makes recovery harder by over-restricting block production

4. **Throughput Collapse**: Block production rate drops to the minimum possible - only scheduled NextRound blocks with future mining times

**Affected Parties:**

- All network validators unable to produce blocks normally
- Users experiencing transaction processing delays
- Entire blockchain suffering from prolonged degraded state

**Severity Justification:**

While not causing direct fund loss, this creates a DoS condition on consensus operations during critical network stress periods when recovery is most needed. The cascading nature means the issue worsens as more miners attempt to participate.

### Likelihood Explanation

**Trigger Conditions:**

1. Network experiences instability for 2+ consecutive rounds
2. Few or no miners successfully produce UpdateValue blocks (due to network partitions, latency issues, or coordination failures)
3. Blockchain enters Abnormal status (LIB not advancing)
4. Empty `MinedMinerListMap.Pubkeys` entries exist for previous rounds

**Feasibility:**

- **No Attacker Required**: This is a natural failure mode during network issues
- **Reachable State**: Occurs through normal consensus flows during network stress
- **Execution Practicality**: Automatically triggered when `GetMaximumBlocksCount()` is called during Abnormal state
- **Probability**: Moderate - requires sustained network issues but represents a realistic failure scenario in distributed systems

**Complexity:**

Low complexity - the condition naturally arises during network instability without requiring sophisticated attack coordination.

### Recommendation

**Immediate Fix:**

Add a minimum threshold check in `GetMaximumBlocksCount()`:

```csharp
// After line 52
var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
    Math.Max(1, Ceiling(factor, currentRound.RealTimeMinersInformation.Count)));
```

This ensures `count` never falls below 1, allowing miners to produce at least UpdateValue blocks.

**Secondary Fix:**

In `ResetLatestProviderToTinyBlocksCount`, add validation:

```csharp
// At line 362
BlocksCount = Math.Max(0, minersCountInTheory.Sub(1))
```

This prevents `BlocksCount` from going negative when `minersCountInTheory = 0`.

**Invariant Checks:**

1. Assert `GetMaximumBlocksCount() >= 1` to guarantee minimum block production capability
2. Assert `State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount >= 0` after reset operations
3. Log warnings when empty `MinedMinerListMap.Pubkeys` are detected

**Test Cases:**

1. Test Abnormal state with empty previous round miner lists
2. Verify miners can still produce UpdateValue blocks when maximum count = 0
3. Test that `BlocksCount` never goes negative
4. Verify network can recover from prolonged empty miner list conditions

### Proof of Concept

**Initial State:**
- Round N-2 completes with no miners producing UpdateValue blocks
- `MinedMinerListMap[N-2].Pubkeys` is empty
- Round N-1 completes with no miners producing UpdateValue blocks  
- `MinedMinerListMap[N-1].Pubkeys` is empty
- Round N begins, LIB has not advanced
- Blockchain status = Abnormal (libRoundNumber + 2 < N < libRoundNumber + SevereStatusRoundsThreshold)

**Execution Steps:**

1. Miner A requests consensus command via `GetConsensusCommand()`
2. `GetMaximumBlocksCount()` is called:
   - Retrieves `MinedMinerListMap[N-1].Pubkeys` (empty)
   - Retrieves `MinedMinerListMap[N-2].Pubkeys` (empty)
   - `minersOfLastTwoRounds = empty.Intersect(empty).Count() = 0`
   - `factor = 0`
   - Returns `count = 0`
3. Miner A produces UpdateValue block
4. `ProcessConsensusInformation` executes:
   - Calls `ResetLatestProviderToTinyBlocksCount(0)`
   - Sets `BlocksCount = 0 - 1 = -1`
5. Miner A requests next consensus command
6. Check `State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0` passes
7. Returns NextRound command (forced)
8. Miner B produces a block, gets `BlocksCount = -1`
9. All active miners progressively get forced into NextRound behavior

**Expected Result:**
Miners should be able to produce UpdateValue blocks continuously to help network recover.

**Actual Result:**
All miners are forced to NextRound after one block, severely limiting throughput and hindering recovery.

**Success Condition:**
`GetMaximumBlocksCount()` returns 0 and `BlocksCount` becomes -1, forcing NextRound behavior for all miners.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L44-54)
```csharp
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L67-69)
```csharp
        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L223-230)
```csharp
    private void RecordMinedMinerListOfCurrentRound()
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        State.MinedMinerListMap.Set(currentRound.RoundNumber, new MinerList
        {
            Pubkeys = { currentRound.GetMinedMiners().Select(m => ByteStringHelper.FromHexString(m.Pubkey)) }
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L359-363)
```csharp
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-62)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L19-37)
```csharp
    public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
        bool mustExceededCurrentRound = false)
    {
        var miningInterval = GetMiningInterval();

        var minerInRound = RealTimeMinersInformation[pubkey];

        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }

        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
    }
```
