### Title
Vote Manipulation Through Member Removal After Rejection

### Summary
The Association contract allows organizations to manipulate proposal outcomes by removing members after they have cast rejection votes. The `IsProposalRejected()` function only counts rejections from current members, not members at the time of voting, enabling proposals that should be rejected to be released by strategically removing dissenting voters.

### Finding Description

The vulnerability exists in the interaction between vote recording and threshold calculation:

**Vote Recording (Reject function):**
When a member casts a rejection vote, the system verifies they are a current member and adds their address to the proposal's rejection list. [1](#0-0) 

**Threshold Calculation (IsProposalRejected):**
When checking if a proposal is rejected during release, the system counts only rejections from addresses that are currently in the organization member list, not those who were members when they voted. [2](#0-1) 

**Member Removal (RemoveMember):**
Organizations can remove members at any time without any checks for active proposals or existing votes. [3](#0-2) 

**Root Cause:**
The fundamental issue is that vote validity is re-evaluated at proposal release time based on current membership rather than being immutably recorded at vote time. The `proposal.Rejections.Count(organization.OrganizationMemberList.Contains)` filter dynamically invalidates past votes from removed members.

**Why Protections Fail:**
The organization validation only checks structural constraints (member count meets thresholds, no duplicates) but has no logic to prevent member manipulation during active voting periods. [4](#0-3) 

### Impact Explanation

**Concrete Harm:**
- Organizations can force through proposals that legitimately reached rejection thresholds by removing dissenting members after they vote
- Breaks the fundamental integrity of the governance system where votes should be final once cast
- Enables unauthorized proposal execution by manipulating the apparent vote count

**Severity Justification (HIGH):**
- Directly violates the "Authorization & Governance" critical invariant requiring correct organization threshold enforcement
- Allows bypassing rejection thresholds entirely through membership manipulation
- No limit on the number of proposals that can be manipulated
- Affects all Association-governed organizations in the AElf ecosystem

**Affected Parties:**
- Organization members whose rejection votes can be retroactively invalidated
- External parties relying on Association governance decisions
- Smart contracts controlled by manipulated Association organizations

### Likelihood Explanation

**Attacker Capabilities:**
The exploit requires organization-level control, meaning the organization itself (through a separate approved proposal) must execute the member removal. This is realistic because:
- Organizations can create proposals to modify their own membership
- A coalition controlling approval thresholds can remove dissenting members
- This is the intended attack surface for governance manipulation

**Attack Complexity:**
Low - requires only standard contract operations in sequence:
1. Wait for rejection votes on target proposal
2. Create and approve a proposal to remove those members
3. Release the member removal proposal
4. Release the original proposal (now no longer rejected)

**Feasibility Conditions:**
- Target proposal must have accumulated sufficient rejections to be blocked
- Attacker coalition must control enough approval votes to remove dissenting members
- All steps use public contract methods with no special permissions required

**Economic Rationality:**
If the proposal being forced through provides value (e.g., treasury withdrawal, contract upgrade, parameter change), the cost of creating and approving the member removal proposal is justified by the gain.

### Recommendation

**Immediate Fix:**
Snapshot the organization member list at the time each vote is cast and use that snapshot for threshold calculations. Modify the proposal structure to store:

```
message ProposalInfo {
    // existing fields...
    map<string, Address> rejection_member_snapshots = N;  // address -> member status at vote time
    map<string, Address> approval_member_snapshots = N+1;
    map<string, Address> abstention_member_snapshots = N+2;
}
```

**Threshold Calculation Updates:**
Change `IsProposalRejected()`, `CheckEnoughVoteAndApprovals()`, and `IsProposalAbstained()` to count all votes in the proposal without filtering by current membership, since membership validity was already verified at vote time.

**Alternative Approach:**
Add a check in `RemoveMember()` and `ChangeMember()` to prevent removal of members who have voted on any active (non-expired) proposals:

```csharp
// In RemoveMember():
AssertMemberHasNoActiveVotes(input, State.Organizations[Context.Sender]);
```

**Invariant to Enforce:**
Once cast, a vote's weight in threshold calculations must not change based on subsequent membership modifications.

**Test Cases:**
1. Create proposal, member votes reject, remove member, verify proposal still counts as rejected
2. Create proposal with rejection threshold=1, have 2 members reject, remove both members, verify proposal cannot be released
3. Test same scenarios for approvals and abstentions

### Proof of Concept

**Initial State:**
- Organization address: `ORG_ADDR`
- Members: `[A, B, C, D, E]` (5 members)
- `MaximalRejectionThreshold = 1` (more than 1 rejection blocks proposal)
- `MinimalApprovalThreshold = 3`

**Transaction Sequence:**

1. **Create Proposal X** (target proposal to manipulate)
   - Call: `CreateProposal(proposalX_input)` from authorized proposer
   - Result: `proposalX_id` created

2. **Members A and B vote to reject Proposal X**
   - Call: `Reject(proposalX_id)` from address A
   - Call: `Reject(proposalX_id)` from address B
   - Result: `proposal.Rejections = [A, B]`
   - At this point: `IsProposalRejected() = true` (2 rejections > 1 threshold)

3. **Create Proposal Y to remove members A and B**
   - Call: `CreateProposal(proposalY_input)` where proposalY calls `RemoveMember(A)` and `RemoveMember(B)`
   - Members C, D, E call `Approve(proposalY_id)`
   - Result: 3 approvals, meets threshold

4. **Release Proposal Y**
   - Call: `Release(proposalY_id)` from proposer
   - Result: Members A and B removed, organization members = `[C, D, E]`

5. **Release Proposal X** (should fail but succeeds)
   - Call: `Release(proposalX_id)` from proposer
   - **Expected Result:** Transaction reverts with "Not approved" because proposal was rejected
   - **Actual Result:** Transaction succeeds because `IsProposalRejected()` now counts 0 rejections (A and B no longer in member list)

**Success Condition:**
Step 5 succeeds when it should fail, proving that rejection votes were retroactively invalidated through member removal.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L143-161)
```csharp
    public override Empty Reject(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Rejections.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Reject),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```
