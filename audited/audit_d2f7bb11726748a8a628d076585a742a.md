### Title
Missing Validation Allows Beneficiaries with Impossible Profit Windows Leading to Permanent Fund Locking

### Summary
The `AddBeneficiary` function fails to validate that `EndPeriod >= CurrentPeriod + DelayDistributePeriodCount`, allowing beneficiaries to be added with `StartPeriod > EndPeriod`. These beneficiaries can never claim profits, but their shares remain counted in `scheme.TotalShares`, causing their proportional share of all future profits to be permanently locked in period virtual addresses.

### Finding Description

**Root Cause:**
The validation in `AddBeneficiary` only checks that `EndPeriod >= CurrentPeriod` [1](#0-0)  but the `StartPeriod` is calculated as `CurrentPeriod + DelayDistributePeriodCount` [2](#0-1) . This allows creation of `ProfitDetail` objects where `StartPeriod > EndPeriod`.

**Execution Path:**

1. **Beneficiary Addition:** When `AddBeneficiary` is called with `EndPeriod < CurrentPeriod + DelayDistributePeriodCount`, the beneficiary's shares are added to `scheme.TotalShares` [3](#0-2) , but a `ProfitDetail` is created with an impossible profit window (StartPeriod > EndPeriod) [4](#0-3) .

2. **Profit Distribution:** When `DistributeProfits` is called, the inflated `totalShares` (including invalid shares) is used [5](#0-4)  and cached for future periods [6](#0-5) . This totalShares value is stored in the distributed profits information [7](#0-6) .

3. **Failed Claims:** When the invalid beneficiary attempts to claim, their `ProfitDetail` is filtered out because the check `EndPeriod >= StartPeriod` fails [8](#0-7) . The beneficiary cannot claim any profits, and the cleanup code that removes shares from `TotalShares` [9](#0-8)  never executes because the detail is not in `profitableDetails`.

4. **Locked Funds:** Each period's profits are divided by the inflated `TotalShares`. The portion corresponding to invalid shares `(InvalidShares * AmountMap[symbol]) / TotalShares` [10](#0-9)  remains permanently locked in that period's virtual address, unclaimed.

### Impact Explanation

**Direct Fund Impact:**
Profits corresponding to invalid beneficiary shares are permanently locked in period virtual addresses. For each period where profits are distributed:
- Locked Amount = `(InvalidShares / TotalShares) × TotalProfitAmount`
- These funds cannot be recovered or redistributed to valid beneficiaries
- The impact compounds across all future periods until manually corrected

**Who Is Affected:**
- Invalid beneficiaries never receive any profits despite having shares allocated
- The protocol suffers permanent fund locking in multiple period virtual addresses
- If this occurs in automated systems (e.g., TokenHolder contract), it could affect many users simultaneously

**Severity Justification:**
Low severity because:
- Requires trusted party (manager or TokenHolder contract) to make configuration error
- Recovery mechanisms exist (`FixProfitDetail` and `RemoveBeneficiary`)
- Impact is bounded by the ratio of invalid shares to total shares
- Not exploitable by untrusted actors

### Likelihood Explanation

**Feasibility Conditions:**
This can occur when:
1. A scheme is created with `DelayDistributePeriodCount` (e.g., 20 periods for vesting)
2. Manager/TokenHolder contract adds beneficiary with `EndPeriod` that seems reasonable relative to `CurrentPeriod` (e.g., `CurrentPeriod + 10`)
3. The caller doesn't realize `StartPeriod` will be `CurrentPeriod + 20`, making `StartPeriod > EndPeriod`

**Realistic Scenarios:**
- **Automated Systems:** TokenHolder contract with incorrect EndPeriod calculation logic could affect many users
- **Configuration Errors:** Manager misunderstands the StartPeriod calculation and sets EndPeriod relative to CurrentPeriod instead of StartPeriod
- **Scheme Updates:** DelayDistributePeriodCount is increased after beneficiaries were planned with shorter EndPeriods

**Attack Complexity:**
- Single transaction to `AddBeneficiary` with misconfigured parameters
- No sophisticated exploitation required
- More likely to be an unintentional error than deliberate attack

**Detection:**
- Issue may go unnoticed until beneficiaries attempt to claim and receive nothing
- Funds remain locked but don't disappear, making detection possible through balance analysis

### Recommendation

**Code-Level Mitigation:**
Add validation in `AddBeneficiary` immediately after line 180:

```csharp
var calculatedStartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount);
Assert(input.EndPeriod >= calculatedStartPeriod || input.EndPeriod == long.MaxValue,
    $"Invalid end period. End period must be >= {calculatedStartPeriod} (CurrentPeriod + DelayDistributePeriodCount) or long.MaxValue for permanent beneficiaries.");
```

**Invariant Check:**
Enforce: `∀ ProfitDetail: StartPeriod ≤ EndPeriod OR EndPeriod = long.MaxValue`

**Test Cases:**
1. Test adding beneficiary with `EndPeriod = CurrentPeriod + DelayDistributePeriodCount - 1` (should fail)
2. Test adding beneficiary with `EndPeriod = CurrentPeriod + DelayDistributePeriodCount` (should succeed)
3. Test adding beneficiary with `EndPeriod = long.MaxValue` with any DelayDistributePeriodCount (should succeed)
4. Regression test: Verify existing valid beneficiary additions still work

### Proof of Concept

**Initial State:**
- Scheme exists with `CurrentPeriod = 10`, `DelayDistributePeriodCount = 20`, `TotalShares = 900`
- Valid beneficiaries hold 900 shares total

**Transaction Steps:**
1. Manager calls `AddBeneficiary`:
   - `SchemeId = [scheme_id]`
   - `BeneficiaryShare.Shares = 100`
   - `EndPeriod = 25` (seems like 15 periods into the future from CurrentPeriod)

2. Manager calls `DistributeProfits` for period 30:
   - `TotalShares = 1000` (includes invalid beneficiary)
   - Distributes 1000 ELF tokens
   - `CachedDelayTotalShares[30] = 1000`

3. Invalid beneficiary calls `ClaimProfits` for period 30:
   - Their `ProfitDetail` has `StartPeriod = 30`, `EndPeriod = 25`
   - Check `25 >= 30` fails at filter stage
   - Transaction completes but claims 0 tokens

4. Valid beneficiaries call `ClaimProfits`:
   - They receive `(900 / 1000) × 1000 = 900` ELF total
   - 100 ELF remains locked in period 30's virtual address forever

**Expected vs Actual Result:**
- **Expected:** Transaction reverts with "Invalid end period" error at step 1
- **Actual:** Invalid beneficiary is added, their 100 shares inflate TotalShares, and 100 ELF is permanently locked per distribution period

**Success Condition:**
Verify that 100 ELF remains in the period 30 virtual address after all valid beneficiaries have claimed, and the invalid beneficiary's shares remain in `scheme.TotalShares`.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L179-180)
```csharp
        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L182-182)
```csharp
        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L462-462)
```csharp
        var totalShares = scheme.TotalShares;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L466-466)
```csharp
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L567-567)
```csharp
        distributedProfitsInformation.TotalShares = totalShares;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-766)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-797)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```
