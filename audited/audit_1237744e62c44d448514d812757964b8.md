### Title
Malicious Miner Can Bypass Critical Consensus Validation By Manipulating ExtraData.Behaviour Field

### Summary
The consensus validation logic uses the `ExtraData.Behaviour` field from block headers to determine which validation providers to apply, but never validates that this Behaviour value matches what the consensus state actually requires. A malicious miner can set an arbitrary Behaviour value to skip critical validators like `RoundTerminateValidationProvider`, `NextRoundMiningOrderValidationProvider`, `UpdateValueValidationProvider`, or `LibInformationValidationProvider`, allowing them to produce consensus-invalid blocks that pass validation.

### Finding Description

The vulnerability exists in the consensus validation flow where the Behaviour field controls validation provider selection without verification.

**Root Cause:** The `ValidateBeforeExecution` method uses `extraData.Behaviour` directly to select which validation providers to instantiate, without verifying that this Behaviour matches what the current consensus state requires: [1](#0-0) 

The Behaviour value comes from the block header's ExtraData and is extracted without any validation beyond checking the sender's public key: [2](#0-1) 

The validation context stores this unchecked Behaviour: [3](#0-2) 

**Why Protections Fail:** While the codebase has deterministic logic to compute the correct Behaviour based on consensus state (in `ConsensusBehaviourProvider.GetConsensusBehaviour()`), this logic is ONLY used during block production by honest miners, not during validation: [4](#0-3) 

When a block arrives from another node, the validation flow never re-computes what Behaviour SHOULD be and compares it against the provided value. Instead, it trusts whatever Behaviour the block producer included.

**Validation Provider Selection Impact:**

Different Behaviours trigger different validators:
- `UPDATE_VALUE`: Adds `UpdateValueValidationProvider` (validates OutValue/PreviousInValue correctness) and `LibInformationValidationProvider` (validates LIB doesn't regress)
- `NEXT_ROUND`: Adds `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` (validates round number increments correctly)
- `NEXT_TERM`: Adds `RoundTerminateValidationProvider` (validates both round AND term number increments)
- `TINY_BLOCK` and `NOTHING`: Add NO additional validators beyond the basic three [5](#0-4) 

**Execution Path:**

1. Attacker produces a block as a valid miner
2. Consensus logic dictates they should use `NEXT_ROUND` behaviour (time to advance round)
3. Attacker instead sets `Behaviour = AElfConsensusBehaviour.UPDATE_VALUE` in their block's ExtraData
4. Block is broadcast to network
5. Other nodes receive block and call `ValidateBlockBeforeExecuteAsync`: [6](#0-5) 

6. ExtraData is extracted and passed to `ValidateConsensusBeforeExecution`: [7](#0-6) 

7. `ValidateBeforeExecution` uses the malicious Behaviour value to select validators, skipping `RoundTerminateValidationProvider` and `NextRoundMiningOrderValidationProvider`
8. Block passes validation despite being consensus-invalid
9. Round doesn't advance when it should, breaking consensus state machine

### Impact Explanation

**Consensus Integrity Violation:**
By manipulating the Behaviour field, an attacker can:

1. **Prevent Round Transitions:** Set Behaviour to `UPDATE_VALUE` or `TINY_BLOCK` when `NEXT_ROUND` is required, preventing the round from advancing. This blocks other miners from producing blocks and stalls the blockchain.

2. **Prevent Term Transitions:** Set Behaviour to `NEXT_ROUND` when `NEXT_TERM` is required, avoiding term number validation. This allows the attacker to extend the current term indefinitely and prevent new miner list updates from the election contract: [8](#0-7) 

3. **Bypass Secret Sharing Validation:** Set Behaviour to `TINY_BLOCK` when `UPDATE_VALUE` is required, skipping `UpdateValueValidationProvider` which validates OutValue and PreviousInValue correctness for the secret sharing mechanism: [9](#0-8) 

4. **Bypass LIB Validation:** Skip `LibInformationValidationProvider` which ensures the Last Irreversible Block height doesn't go backwards: [10](#0-9) 

**Who Is Affected:**
- All network participants suffer from stalled consensus
- New miners cannot join if term transitions are prevented
- Chain liveness is compromised
- Invalid consensus state can cascade to dependent systems

**Severity Justification:**
CRITICAL - Violates fundamental consensus invariants ("Correct round transitions and time-slot validation, miner schedule integrity"). A single malicious miner can DoS the entire network or manipulate the consensus state machine to their advantage.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be in the current miner list (requires staking ELF tokens and being elected/selected as a block producer)
- Can produce blocks with custom ExtraData
- No special privileges beyond normal miner rights needed

**Attack Complexity:**
LOW - The attack is straightforward:
1. When producing a block, generate ExtraData with the consensus contract's `GetConsensusExtraData` method as normal
2. Modify the Behaviour field in the resulting `AElfConsensusHeaderInformation` protobuf message: [11](#0-10) 

3. Sign and broadcast the block with the modified ExtraData

**Feasibility Conditions:**
- Attacker must wait for their time slot to produce blocks (guaranteed if they're in miner list)
- No additional consensus from other nodes required
- No complex state manipulation needed

**Detection/Operational Constraints:**
- Attack may appear as "miner produced invalid block" but the block passes validation
- Honest nodes cannot distinguish between malicious Behaviour manipulation and network issues
- No automatic recovery mechanism exists
- Manual intervention would be required to identify and remove the malicious miner

**Probability Assessment:**
HIGH - Any miner in the current miner list can execute this attack at will during their time slots. With financial incentives (e.g., preventing term change to maintain mining rewards, or attacking competitors), the attack is likely to occur.

### Recommendation

**Primary Mitigation:**
Add Behaviour verification in `ValidateBeforeExecution` before using it to select validation providers:

```csharp
// In AEDPoSContract_Validation.cs, after line 59 (after validationContext is created)

// Compute expected behaviour based on current consensus state
var expectedBehaviour = ComputeExpectedBehaviour(
    baseRound, 
    pubkey, 
    GetMaximumBlocksCount(), 
    Context.CurrentBlockTime
);

// Validate provided behaviour matches expected
if (extraData.Behaviour != expectedBehaviour)
{
    return new ValidationResult 
    { 
        Success = false, 
        Message = $"Invalid consensus behaviour. Expected: {expectedBehaviour}, Provided: {extraData.Behaviour}" 
    };
}
```

**Implementation Details:**
Extract the behaviour computation logic from `ConsensusBehaviourProvider.GetConsensusBehaviour()` into a shared method that can be called during both block production and validation: [12](#0-11) 

Ensure the computation is deterministic and uses only the consensus state available at validation time (previous block's state).

**Additional Invariant Checks:**
1. Validate that `NEXT_ROUND` behaviour only occurs when round should actually terminate
2. Validate that `NEXT_TERM` behaviour only occurs when both round AND term should terminate  
3. Validate that `TINY_BLOCK` behaviour only occurs within valid time slots and block count limits
4. Validate that `UPDATE_VALUE` behaviour only occurs for miners who haven't produced in current round

**Test Cases:**
1. Test that blocks with mismatched Behaviour (should be NEXT_ROUND but provides UPDATE_VALUE) fail validation
2. Test that blocks with correct Behaviour pass validation
3. Test all behaviour transition edge cases (first round, term changes, extra block producer, etc.)
4. Test that the validation logic exactly matches the production logic

### Proof of Concept

**Initial State:**
- Blockchain at height N with current round R
- Round R has completed (all miners produced blocks or time slots passed)
- Attacker is the next miner in order and should produce the round-terminating block
- Consensus logic dictates Behaviour should be `NEXT_ROUND` (determined by `ConsensusBehaviourProvider.GetConsensusBehaviour()`)

**Attack Steps:**
1. Attacker's node calls `GetConsensusCommand` which returns a command with `Behaviour = NEXT_ROUND` in the hint: [13](#0-12) 

2. During block production, attacker calls `GetConsensusExtraData` which would normally create ExtraData with `Behaviour = NEXT_ROUND`: [14](#0-13) 

3. Attacker modifies the trigger information input to `GetConsensusExtraData`, changing `triggerInformation.Behaviour` from `NEXT_ROUND` to `UPDATE_VALUE`: [15](#0-14) 

4. The contract generates ExtraData with `Behaviour = UPDATE_VALUE` and the attacker includes this in their block header

5. Attacker generates consensus transaction for `UpdateValue` instead of `NextRound`: [16](#0-15) 

6. Block is broadcast to network

**Expected Result:**
Block should be rejected with validation error: "Round should terminate but UPDATE_VALUE behaviour was used"

**Actual Result:**
Block passes validation because:
- `ValidateBeforeExecution` uses `UPDATE_VALUE` from ExtraData
- Only `UpdateValueValidationProvider` and `LibInformationValidationProvider` are applied
- `RoundTerminateValidationProvider` is never instantiated
- Round R doesn't advance to R+1
- Subsequent miners cannot produce blocks (their round data is for R+1)
- Consensus is stalled until manual intervention

**Success Condition:**
Attacker successfully produces a block that:
1. Passes all consensus validation checks
2. Contains wrong Behaviour value
3. Prevents round advancement
4. Blocks other miners from producing subsequent blocks

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-75)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L21-33)
```csharp
    public ByteString ExtractConsensusExtraData(BlockHeader header)
    {
        var consensusExtraData =
            _blockExtraDataService.GetExtraDataFromBlockHeader(_consensusExtraDataProvider.BlockHeaderExtraDataKey,
                header);
        if (consensusExtraData == null)
            return null;

        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L40-40)
```csharp
    public AElfConsensusHeaderInformation ExtraData { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusValidationProvider.cs (L58-78)
```csharp
    public async Task<bool> ValidateBlockBeforeExecuteAsync(IBlock block)
    {
        if (block.Header.Height == AElfConstants.GenesisBlockHeight)
            return true;

        var consensusExtraData = _consensusExtraDataExtractor.ExtractConsensusExtraData(block.Header);
        if (consensusExtraData == null || consensusExtraData.IsEmpty)
        {
            Logger.LogDebug($"Invalid consensus extra data {block}");
            return false;
        }

        var isValid = await _consensusService.ValidateConsensusBeforeExecutionAsync(new ChainContext
        {
            BlockHash = block.Header.PreviousBlockHash,
            BlockHeight = block.Header.Height - 1
        }, consensusExtraData.ToByteArray());
        if (!isValid) return false;

        return ValidateTransactionCount(block);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L137-147)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                Context.LogDebug(() =>
                    $"Previous in value in extra data:{round.RealTimeMinersInformation[pubkey.ToHex()].PreviousInValue}");
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** protobuf/aedpos_contract.proto (L303-310)
```text
message AElfConsensusHeaderInformation {
    // The sender public key.
    bytes sender_pubkey = 1;
    // The round information.
    Round round = 2;
    // The behaviour of consensus.
    AElfConsensusBehaviour behaviour = 3;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L26-33)
```csharp
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L40-43)
```csharp
            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;
```
