### Title
Method Fee Controller Permanent Lock via Dysfunctional Organization

### Summary
The `ChangeMethodFeeController()` function only validates that a target organization exists in state, but does not verify the organization is functional or capable of approving proposals. A malicious or compromised controller can intentionally set the controller to an organization with impossible approval thresholds (e.g., requiring 100% consensus with MaximalRejectionThreshold = 0), permanently locking the method fee controller and preventing any future fee changes.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController()` function which performs insufficient validation when changing the method fee controller authority. [1](#0-0) 

The function only calls `CheckOrganizationExist(input)` at line 26, which internally calls `ValidateOrganizationExist` on the governance contract: [2](#0-1) 

For Parliament organizations, this validation merely checks if the organization address exists in state: [3](#0-2) 

However, Parliament organizations can be created with thresholds that make proposal approval practically impossible. The validation logic allows creation of organizations with extreme thresholds: [4](#0-3) 

Where `AbstractVoteTotal = 10000` represents 100%: [5](#0-4) 

Test evidence confirms that organizations with `MinimalApprovalThreshold = 10000` (requiring 100% approval) and `MaximalRejectionThreshold = 0` (any single rejection blocks) are valid and can be created: [6](#0-5) 

The proposal approval logic requires unanimous consent when thresholds are set to extremes: [7](#0-6) 

With `MinimalApprovalThreshold = 10000`, the condition `approvedMemberCount * 10000 >= 10000 * parliamentMembers.Count` requires ALL parliament members to approve. Similarly, with `MaximalRejectionThreshold = 0`: [8](#0-7) 

Any single rejection (`rejectionMemberCount * 10000 > 0 * parliamentMembers.Count`) causes the proposal to fail.

For Association organizations, similar vulnerabilities exist where organizations can require 100% member approval or have all members/proposers lose access to their private keys: [9](#0-8) 

### Impact Explanation

**Governance Impact**: Permanent lockout of the method fee controller authority. Once the controller is set to a dysfunctional organization, no future proposals can be approved, making it impossible to:
- Adjust transaction fees in response to economic conditions
- Respond to fee-related attacks or exploits
- Update fee structures for new contract methods
- Restore normal governance operations

**Operational Impact**: Complete denial of service for method fee management. The Economic contract and all contracts using ACS1 method fees become unable to adapt their fee structures, potentially leading to:
- Economic dysfunction if fees become too high or too low
- Inability to respond to spam attacks requiring fee adjustments
- System-wide governance paralysis for this critical parameter

**Affected Parties**: All users and the entire protocol, as transaction fees affect every contract interaction and economic activity on the chain.

**Severity Justification**: CRITICAL - This creates an irreversible governance failure for a system-critical parameter. Unlike temporary DoS, this is a permanent state corruption with no recovery mechanism.

### Likelihood Explanation

**Attacker Capabilities**: Requires current method fee controller privileges. The attack premise is investigating whether a compromised or malicious controller can create permanent damage.

**Attack Complexity**: LOW
1. Create a Parliament organization with impossible thresholds (MinimalApprovalThreshold = 10000, MaximalRejectionThreshold = 0, MaximalAbstentionThreshold = 0)
2. Create a proposal through the current controller to call `ChangeMethodFeeController` with the dysfunctional organization
3. Approve and release the proposal
4. The new controller is permanently locked

**Feasibility Conditions**: 
- Attacker has current controller authority (the security question's premise)
- No additional technical barriers exist
- The dysfunctional organization creation is provably valid per test evidence
- The change passes all existing validation checks

**Detection/Operational Constraints**: The attack may not be immediately obvious, as the organization appears valid and exists in state. The dysfunction only becomes apparent when attempting to approve future proposals.

**Probability Reasoning**: HIGH likelihood given controller compromise. The attack is straightforward, irreversible, and passes all current validation checks. No special conditions or timing requirements exist.

### Recommendation

**Immediate Mitigation**: Add functional validation to `ChangeMethodFeeController`:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    // Add validation for functional thresholds
    AssertOrganizationIsFunctional(input);
    
    State.MethodFeeController.Value = input;
    return new Empty();
}

private void AssertOrganizationIsFunctional(AuthorityInfo authorityInfo)
{
    // For Parliament: Ensure thresholds are reasonable (e.g., < 95% approval required)
    // For Association: Ensure member list and proposer whitelist are non-empty and accessible
    // Reject organizations with MaximalRejectionThreshold = 0 or MaximalAbstentionThreshold = 0
    // Implementation depends on contract type returned by ValidateOrganizationExist
}
```

**Invariant Checks to Add**:
1. Maximum threshold limits (e.g., MinimalApprovalThreshold ≤ 9000 for 90% max)
2. Minimum rejection/abstention tolerance (e.g., MaximalRejectionThreshold ≥ 500 for 5% min)
3. Verify organization has active proposers/members with proven access

**Test Cases to Add**:
1. Test that `ChangeMethodFeeController` rejects organizations with 100% approval requirements
2. Test that organizations with zero rejection/abstention tolerance are rejected
3. Test attempting to lock the controller and verify the operation fails
4. Test the recommended validation logic prevents dysfunctional organizations

### Proof of Concept

**Initial State**:
- Economic contract deployed with default controller (Parliament default organization)
- Current controller has authority to change method fee controller

**Attack Steps**:

1. **Create Dysfunctional Parliament Organization**:
   ```
   Call Parliament.CreateOrganization with:
   - MinimalApprovalThreshold = 10000 (100% approval required)
   - MinimalVoteThreshold = 10000
   - MaximalAbstentionThreshold = 0 (any abstention blocks)
   - MaximalRejectionThreshold = 0 (any rejection blocks)
   - ProposerAuthorityRequired = false
   - ParliamentMemberProposingAllowed = true
   
   Result: Organization created successfully (passes validation)
   Note: dysfunctionalOrgAddress
   ```

2. **Create Proposal to Change Controller**:
   ```
   Through current controller organization:
   Call Parliament.CreateProposal to invoke:
   - ToAddress: Economic Contract Address
   - ContractMethodName: "ChangeMethodFeeController"
   - Params: AuthorityInfo {
       OwnerAddress: dysfunctionalOrgAddress,
       ContractAddress: Parliament Contract Address
     }
   
   Result: Proposal created with proposalId
   ```

3. **Approve and Release Proposal**:
   ```
   Sufficient parliament members approve the proposal
   Proposer calls Parliament.Release(proposalId)
   
   Result: ChangeMethodFeeController executes successfully
   Verification: Economic.GetMethodFeeController returns dysfunctionalOrgAddress
   ```

4. **Verify Permanent Lock**:
   ```
   Attempt to create any proposal through dysfunctionalOrgAddress
   Attempt to approve with all parliament members
   Result: Cannot achieve approval because:
   - If any member abstains: abstentionCount * 10000 > 0 → proposal abstained
   - If any member rejects: rejectionCount * 10000 > 0 → proposal rejected
   - Even with all approvals: requires 100% participation (impossible in practice)
   
   Try to change controller back: IMPOSSIBLE - no proposals can be approved
   Try to adjust method fees: IMPOSSIBLE - controller is locked
   ```

**Expected vs Actual Result**:
- Expected: `ChangeMethodFeeController` should reject dysfunctional organizations
- Actual: Change succeeds, permanently locking the controller with no recovery mechanism

**Success Condition**: The method fee controller is permanently set to an organization that cannot approve any proposals, confirmed by inability to execute any future controller changes or fee adjustments.

### Citations

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-70)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L187-196)
```csharp
        {
            createOrganizationInput.ProposalReleaseThreshold = proposalReleaseThreshold;
            createOrganizationInput.ProposalReleaseThreshold.MinimalApprovalThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MinimalVoteThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MaximalAbstentionThreshold = 0;
            createOrganizationInput.ProposalReleaseThreshold.MaximalRejectionThreshold = 0;
            var transactionResult =
                await minerParliamentContractStub.CreateOrganization.SendAsync(createOrganizationInput);
            transactionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```
