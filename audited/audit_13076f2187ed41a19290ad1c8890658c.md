### Title
Referendum Organizations Can Become Permanently Locked Through Invalid Configuration Changes

### Summary
Referendum contract organizations can only modify their thresholds and proposer whitelists through self-executed proposals. However, insufficient validation allows organizations to set configurations that make future proposals impossible to create or pass, resulting in permanent governance lock with no recovery mechanism. This can occur through malicious proposals or configuration errors.

### Finding Description

The Referendum contract allows organizations to modify their configuration exclusively through two self-call methods: `ChangeOrganizationThreshold` and `ChangeOrganizationProposerWhiteList`. Both methods enforce that only the organization itself (via `Context.Sender`) can execute these changes. [1](#0-0) [2](#0-1) 

To execute these methods, an organization must:
1. Have an authorized proposer create a proposal (checked via whitelist)
2. Gather sufficient votes to meet release thresholds
3. Release the proposal to execute the configuration change [3](#0-2) [4](#0-3) 

The root cause is insufficient validation in the `Validate(Organization)` method. While it prevents empty whitelists and enforces basic threshold relationships, it fails to prevent three critical locking scenarios: [5](#0-4) 

**Vulnerability 1 - Unreachable Whitelist Lock:**
The validation only checks if the whitelist is non-empty but does NOT validate whether the addresses are reachable, controlled by anyone, or capable of creating proposals. An organization can set its whitelist to contain only burn addresses, lost private keys, or non-cooperative parties. [6](#0-5) 

**Vulnerability 2 - Impossible Threshold Lock:**
The validation enforces `MinimalApprovalThreshold > 0` and `MinimalApprovalThreshold <= MinimalVoteThreshold`, but imposes NO upper bounds on any threshold values. An organization can set `MinimalVoteThreshold` or `MinimalApprovalThreshold` to values exceeding the token's circulating supply or practical voting capacity (e.g., `2^63-1`), making it mathematically impossible to pass any future proposals.

**Vulnerability 3 - Zero-Tolerance Lock:**
The validation only checks that `MaximalRejectionThreshold >= 0` and `MaximalAbstentionThreshold >= 0`, but does NOT prevent setting them to zero. If set to zero, even a single rejection or abstention vote would block proposal release, creating a practically impossible coordination requirement. [7](#0-6) 

### Impact Explanation

**Operational Impact - DoS of Governance:**
Once locked, the organization can never create, approve, or execute proposals again. This results in:
- Complete loss of governance control over the organization
- Any funds held in the organization's virtual address become permanently unrecoverable
- Any contracts or permissions controlled by the organization become permanently frozen

**Who Is Affected:**
- Organization members lose all governance rights
- Any value locked in the organization's virtual address is lost
- External contracts relying on the organization's governance are permanently blocked

**Severity Justification:**
HIGH severity because:
- Complete and permanent loss of governance functionality
- No admin override or recovery mechanism exists in the contract
- Funds become permanently unrecoverable
- Can be triggered by single successful malicious proposal OR configuration error [8](#0-7) 

### Likelihood Explanation

**Reachable Entry Point:**
Exploitation starts from the standard `CreateProposal` method, followed by normal approval and release flow - all are public and intended functionality.

**Attacker Capabilities:**
- **Malicious Attack:** Attacker only needs to be in the proposer whitelist and coordinate enough votes to pass ONE malicious configuration change proposal
- **Accidental Lock:** Honest configuration error by legitimate proposers (e.g., typo in threshold values, copying wrong addresses to whitelist)

**Attack Complexity:**
Low - the attack follows the normal proposal workflow without requiring any special privileges beyond being an authorized proposer and gathering sufficient votes to pass the locking proposal.

**Feasibility Conditions:**
- Organization must have lax enough thresholds that the attacker can gather sufficient approval votes for the malicious proposal
- OR honest mistake in setting new configuration values

**Economic Rationality:**
- Attack cost: Only the standard proposal and voting costs
- Potential gain: Denial of service against competitor organizations, grieving attacks, or extraction of value from organization members willing to pay ransom to restore governance
- Accidental occurrence: High probability in practice due to lack of bounds checking

**Detection/Prevention:**
No automated safeguards exist. Organizations must manually verify configuration changes before approval, but the contract provides no warnings about potentially locking configurations.

### Recommendation

**1. Add Upper Bound Validation for Thresholds:**
In the `Validate(Organization)` method, add checks to ensure thresholds are reasonable and achievable:
```csharp
// In Referendum_Helper.cs Validate method, add:
Assert(proposalReleaseThreshold.MinimalVoteThreshold <= MaxReasonableThreshold, 
    "MinimalVoteThreshold exceeds maximum allowed value.");
Assert(proposalReleaseThreshold.MinimalApprovalThreshold <= MaxReasonableThreshold,
    "MinimalApprovalThreshold exceeds maximum allowed value.");
```

**2. Add Minimum Threshold Validation for Rejection/Abstention:**
```csharp
// Prevent zero-tolerance configurations that block all proposals
Assert(proposalReleaseThreshold.MaximalRejectionThreshold >= MinReasonableRejectionThreshold,
    "MaximalRejectionThreshold too restrictive.");
Assert(proposalReleaseThreshold.MaximalAbstentionThreshold >= MinReasonableAbstentionThreshold,
    "MaximalAbstentionThreshold too restrictive.");
```

**3. Add Whitelist Continuity Check:**
Before allowing whitelist changes, verify that at least one current whitelist member remains in the new whitelist, or require a special multi-signature override:
```csharp
// In ChangeOrganizationProposerWhiteList
var currentWhitelist = organization.ProposerWhiteList;
var hasOverlap = input.Proposers.Any(p => currentWhitelist.Contains(p));
Assert(hasOverlap || IsEmergencyOverride(), 
    "New whitelist must contain at least one current proposer.");
```

**4. Add Token Supply Validation:**
Query the token contract to get total/circulating supply and ensure thresholds don't exceed it:
```csharp
var tokenInfo = GetTokenInfo(organization.TokenSymbol);
Assert(proposalReleaseThreshold.MinimalVoteThreshold <= tokenInfo.Supply,
    "MinimalVoteThreshold exceeds token supply.");
```

**5. Add Test Cases:**
- Test attempting to set whitelist with only unreachable addresses
- Test attempting to set thresholds exceeding token supply
- Test attempting to set zero rejection/abstention tolerance
- Test recovery mechanisms if implemented

### Proof of Concept

**Initial State:**
- Organization created with reasonable thresholds: MinimalVoteThreshold = 1000, MinimalApprovalThreshold = 600
- Whitelist contains: [Alice, Bob]
- Token supply: 10,000 tokens
- Alice holds proposal creation rights

**Attack Sequence (Unreachable Whitelist Lock):**

1. **Malicious Proposal Creation:**
   Alice creates a proposal to call `ChangeOrganizationProposerWhiteList` with new whitelist = [BurnAddress_0x000...dead] where BurnAddress is a known burn address with no private keys.

2. **Proposal Approval:**
   Voters approve the proposal with 600+ votes (meeting MinimalApprovalThreshold).

3. **Proposal Release:**
   Alice calls `Release(proposalId)`, which executes the whitelist change.

4. **Lock Verification:**
   - New whitelist contains only BurnAddress (no one controls private keys)
   - No one can create new proposals (AssertIsAuthorizedProposer fails for all real users)
   - Organization permanently locked - cannot change whitelist back since no authorized proposer exists

**Attack Sequence (Impossible Threshold Lock):**

1. **Malicious Proposal Creation:**
   Alice creates a proposal to call `ChangeOrganizationThreshold` with MinimalVoteThreshold = 9223372036854775807 (2^63-1, max int64).

2. **Proposal Approval & Release:**
   Current members approve and release using existing (achievable) thresholds.

3. **Lock Verification:**
   - New MinimalVoteThreshold = 9223372036854775807 tokens
   - Token supply = 10,000 tokens
   - Impossible to gather 9223372036854775807 votes
   - All future proposals permanently unreleasable
   - Organization permanently locked

**Expected vs Actual Result:**
- **Expected:** Validation should reject configurations that would lock the organization
- **Actual:** Invalid configurations pass validation and permanently lock the organization with no recovery mechanism

**Success Condition:** 
After executing either attack sequence, attempt to create and release a new proposal to restore original configuration - this will fail, confirming permanent lock.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-59)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-137)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L13-16)
```csharp
    public static bool Empty(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Count() == 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/ReferendumState.cs (L9-20)
```csharp
public class ReferendumState : ContractState
{
    internal TokenContractContainer.TokenContractReferenceState TokenContract { get; set; }
    internal ParliamentContractContainer.ParliamentContractReferenceState ParliamentContract { get; set; }

    public BoolState Initialized { get; set; }
    public MappedState<Address, Hash, Receipt> LockedTokenAmount { get; set; }
    public MappedState<Address, Organization> Organizations { get; set; }
    public MappedState<Hash, ProposalInfo> Proposals { get; set; }
    public MappedState<string, MethodFees> TransactionFees { get; set; }
    public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
}
```
