# Audit Report

## Title
Input Collision Vulnerability in Token Hash Calculation Allows Cross-Protocol Balance Manipulation

## Summary
The NFT contract's `CalculateTokenHash` function concatenates symbol and tokenId strings without a delimiter, enabling different (symbol, tokenId) pairs to produce identical hashes. This causes multiple distinct tokens to share the same storage slots for balances, allowances, and metadata, potentially enabling unauthorized token transfers.

## Finding Description

The vulnerability exists in the `CalculateTokenHash` function which computes token identifiers by simple string concatenation: [1](#0-0) 

This implementation lacks a delimiter between symbol and tokenId, allowing input collisions. For example:
- Symbol="AR123456789" + tokenId=0 → "AR1234567890"
- Symbol="AR1234567" + tokenId=890 → "AR1234567890"

Both concatenations produce identical strings, resulting in the same hash value.

**Affected State Mappings:**

All critical NFT state uses this colliding tokenHash as the storage key:

Balance storage: [2](#0-1) 

Allowance storage: [3](#0-2) 

NFT metadata storage: [4](#0-3) 

**Exploitation Path:**

1. Attacker identifies a target NFT protocol with symbol "AR123456789" and valuable tokens at tokenId=0
2. Attacker creates a token "AR1234567" in MultiToken contract (requires seed NFT acquisition or CreateWhitelist access): [5](#0-4) 

3. Attacker registers the protocol via `CrossChainCreate` which only validates that the token exists and the first 2 characters are a valid NFT type: [6](#0-5) 

4. Attacker mints tokens with tokenId=890, producing the colliding hash
5. Transfer operations manipulate the shared balance pool: [7](#0-6) 

The vulnerability affects all state-modifying operations including Transfer, TransferFrom, Approve, Burn, and Recast, as they all rely on the tokenHash for state lookups.

## Impact Explanation

**Direct Fund Impact:**
- Attackers can transfer tokens from the shared balance pool that they don't legitimately own, as the balance check operates on the combined balance: [8](#0-7) 

- Victims holding tokens in colliding protocols lose control over their balances
- Balance queries return incorrect aggregated values across different protocols

**Severity Justification:**
HIGH - Direct token theft is possible. While exploitation requires seed NFT acquisition or whitelist access, the fundamental design flaw enables theft of arbitrary amounts once collision conditions are met. The NFT contract generates symbols with minimum 9-digit numbers: [9](#0-8) 

However, CrossChainCreate accepts any symbol without length validation beyond the first 2 characters, and MultiToken allows creating tokens with shorter symbols (up to 10 characters for regular tokens): [10](#0-9) 

## Likelihood Explanation

**Attacker Capabilities Required:**
1. Create a colliding token in MultiToken contract via seed NFT acquisition or being in the CreateWhitelist
2. Call `CrossChainCreate` in NFT contract (permissionless once token exists)
3. Mint tokens with calculated tokenId to produce the collision
4. Execute transfer operations

**Feasibility Assessment:**
The attack complexity is MEDIUM - requires understanding the concatenation vulnerability and calculating collision parameters, but no cryptographic attacks are needed. The primary constraint is seed NFT availability. The MultiToken contract requires either CreateWhitelist membership or a valid seed NFT: [11](#0-10) 

**Probability Assessment:**
MEDIUM overall - If seed NFTs for arbitrary symbols are tradeable or purchasable, feasibility is HIGH. If seed NFTs are tightly controlled through whitelist mechanisms, feasibility is LOW. However, the fundamental design flaw persists regardless of access control, and the probability increases over time as more protocols deploy.

## Recommendation

Add a delimiter between symbol and tokenId in the hash calculation to prevent input collisions:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}-{tokenId}");
}
```

Alternatively, use structured hashing that ensures collision resistance:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(symbol),
        HashHelper.ComputeFrom(tokenId)
    );
}
```

Additionally, consider adding symbol format validation in `CrossChainCreate` to enforce consistent symbol lengths matching those generated by the `Create` method.

## Proof of Concept

```csharp
[Fact]
public async Task TokenHashCollision_EnablesBalanceTheft()
{
    // Setup: Create first protocol "AR123456789" and mint tokenId=0
    var symbol1 = "AR123456789";
    var tokenId1 = 0L;
    await CreateProtocolAndMint(symbol1, tokenId1, UserA, quantity: 100);
    
    // Attack: Create colliding protocol "AR1234567" via CrossChainCreate
    var symbol2 = "AR1234567";
    var tokenId2 = 890L;
    
    // Both produce hash("AR1234567890")
    var hash1 = await NFTContract.CalculateTokenHash.CallAsync(new CalculateTokenHashInput
    {
        Symbol = symbol1,
        TokenId = tokenId1
    });
    
    var hash2 = await NFTContract.CalculateTokenHash.CallAsync(new CalculateTokenHashInput
    {
        Symbol = symbol2,
        TokenId = tokenId2
    });
    
    // Verify collision
    hash1.ShouldBe(hash2);
    
    // Attacker creates symbol2 in MultiToken (requires seed NFT)
    await CreateTokenInMultiToken(symbol2);
    await NFTContract.CrossChainCreate.SendAsync(new CrossChainCreateInput { Symbol = symbol2 });
    
    // Attacker mints at colliding tokenId
    await NFTContract.Mint.SendAsync(new MintInput
    {
        Symbol = symbol2,
        TokenId = tokenId2,
        Owner = Attacker
    });
    
    // Attacker can now transfer from shared balance pool
    var balanceBefore = await NFTContract.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = symbol1,
        TokenId = tokenId1,
        Owner = UserA
    });
    
    await NFTContract.Transfer.SendAsync(new TransferInput
    {
        Symbol = symbol2,
        TokenId = tokenId2,
        To = Attacker,
        Amount = 50 // Stealing from UserA's balance
    });
    
    // Verify theft: UserA's balance decreased despite attacker using different symbol
    var balanceAfter = await NFTContract.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = symbol1,
        TokenId = tokenId1,
        Owner = UserA
    });
    
    balanceAfter.Balance.ShouldBe(balanceBefore.Balance - 50);
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L21-24)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        DoTransfer(tokenHash, Context.Sender, input.To, input.Amount);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L46-55)
```csharp
    private void DoTransfer(Hash tokenHash, Address from, Address to, long amount)
    {
        if (amount < 0) throw new AssertionException("Invalid transfer amount.");

        if (amount == 0) return;

        Assert(State.BalanceMap[tokenHash][from] >= amount, "Insufficient balance.");
        State.BalanceMap[tokenHash][from] = State.BalanceMap[tokenHash][from].Sub(amount);
        State.BalanceMap[tokenHash][to] = State.BalanceMap[tokenHash][to].Add(amount);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L64-66)
```csharp
            var allowance = State.AllowanceMap[tokenHash][input.From][Context.Sender];
            Assert(allowance >= input.Amount, "Not approved.");
            State.AllowanceMap[tokenHash][input.From][Context.Sender] = allowance.Sub(input.Amount);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L439-441)
```csharp
        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L118-131)
```csharp
    private void CheckSeedNFT(string symbolSeed, String symbol)
    {
        Assert(!string.IsNullOrEmpty(symbolSeed), "Seed NFT does not exist.");
        var tokenInfo = GetTokenInfo(symbolSeed);
        Assert(tokenInfo != null, "Seed NFT does not exist.");
        Assert(State.Balances[Context.Sender][symbolSeed] > 0, "Seed NFT balance is not enough.");
        Assert(tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.SeedOwnedSymbolExternalInfoKey, out var ownedSymbol) && ownedSymbol == symbol,
            "Invalid OwnedSymbol.");
        Assert(tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                   out var expirationTime)
               && long.TryParse(expirationTime, out var expirationTimeLong) &&
               Context.CurrentBlockTime.Seconds <= expirationTimeLong, "OwnedSymbol is expired.");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L79-93)
```csharp
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L7-7)
```csharp
    public const int SymbolMaxLength = 10;
```
