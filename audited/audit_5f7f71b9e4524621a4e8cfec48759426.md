### Title
Multi-Identity Continuous Block Limit Bypass via Controlled Miner Rotation

### Summary
An entity controlling multiple elected miner positions can bypass the continuous block production limit by rotating between different pubkeys. The `ResetLatestProviderToTinyBlocksCount` function resets the block counter when a different pubkey produces a block, allowing an attacker with multiple miner identities to collectively produce significantly more continuous blocks than the intended 8-block limit, increasing fork probability and delaying Last Irreversible Block (LIB) advancement.

### Finding Description

The vulnerability exists in the interaction between the continuous block validation and the counter reset mechanism. [1](#0-0) 

The validation checks if the current sender's pubkey matches the last producer and if their counter is negative. If the pubkey differs, validation passes on line 26, allowing the new miner to proceed. [2](#0-1) 

The root cause is in the counter reset logic: [3](#0-2) 

When a different pubkey produces a block (lines 358-363), the counter resets to `minersCountInTheory - 1` instead of tracking cumulative continuous blocks across related entities.

The election system permits a single admin to manage multiple candidate pubkeys without restrictions: [4](#0-3) [5](#0-4) 

The election system selects top candidates by vote count with no prevention of multiple pubkeys controlled by one entity: [6](#0-5) 

The consensus command generation enforces NextRound only when the same pubkey exceeds the limit: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Impact**: The continuous block limit exists to prevent forks and ensure round progression. The stated purpose is "to avoid too many forks" as documented in the GetMaximumBlocksCount method comments. An entity controlling N elected miners with consecutive or nearby time slots can produce up to `N × 8` continuous blocks instead of the intended maximum of 8.

**Concrete Harm**:
- **Increased Fork Probability**: With 3 controlled miners, an attacker produces 24 continuous blocks instead of 8, tripling fork risk
- **LIB Delay**: Excessive continuous blocks without round changes delay Last Irreversible Block advancement, affecting finality
- **Consensus Dominance**: Controlled miners can dominate block production within their time slots, potentially censoring transactions
- **Blockchain Health**: Violates the design invariant that limits continuous blocks to maintain consensus stability

**Affected Parties**: All network participants relying on timely finality and fair block production.

**Severity**: MEDIUM-HIGH - Impacts consensus stability and finality guarantees, though requires significant preconditions.

### Likelihood Explanation

**Attacker Capabilities Required**:
1. Register multiple candidates (each requiring 100,000 ELF deposit) [8](#0-7) 

2. Obtain sufficient votes to get multiple candidates elected as miners
3. Coordinate block production across controlled miners during their respective time slots

**Attack Complexity**: MEDIUM
- Entry points are publicly accessible (AnnounceElection, miner consensus commands)
- No cryptographic or technical barriers beyond capital and voting requirements
- Execution is straightforward once preconditions are met

**Feasibility Conditions**:
- Economic barrier: N × 100,000 ELF for N candidates
- Social/governance requirement: Maintain votes for multiple candidates
- Time slot coordination: Requires miners to be within same or consecutive rounds

**Probability Assessment**: MEDIUM
- High capital requirement (hundreds of thousands of ELF) limits casual exploitation
- Voting requirement adds governance friction
- However, for well-funded attackers or colluding entities, this is achievable
- No technical detection mechanism exists to identify related miner identities

**Mitigation Present**: Partial - Dynamic adjustment during severe blockchain status reduces limit to 1, but only activates reactively after harm occurs. [9](#0-8) 

### Recommendation

**Code-Level Mitigation**:

1. **Implement Entity-Level Tracking**: Modify the continuous block counter to track aggregate blocks across miners with shared admin addresses. Update `ResetLatestProviderToTinyBlocksCount` to:
   - Check if the new miner shares the same admin as the previous miner
   - If shared admin detected, decrement the existing counter instead of resetting
   - Only reset counter when a miner from a different admin entity produces a block

2. **Add Admin Diversity Check**: In the election contract, enforce a limit on the number of candidates from a single admin that can be simultaneously elected. Modify `GetVictories` to distribute elected positions across diverse admin addresses.

3. **Enhance Validation**: Strengthen `ContinuousBlocksValidationProvider` to query candidate admin information and validate cumulative block production across related identities:
   ```
   // Check if sender shares admin with previous producer
   var senderAdmin = GetCandidateAdmin(senderPubkey);
   var previousAdmin = GetCandidateAdmin(latestPubkey);
   if (senderAdmin == previousAdmin) {
       // Use accumulated counter, don't reset
   }
   ```

**Invariant Checks**:
- Maximum continuous blocks from any single entity (admin-grouped) must not exceed MaximumTinyBlocksCount
- Track and enforce per-entity (not just per-pubkey) block production limits

**Test Cases**:
1. Test scenario where single admin controls 3 miners in consecutive time slots
2. Verify that collective block production is capped at MaximumTinyBlocksCount
3. Test that legitimate diverse miners can still produce their allocated blocks
4. Verify backward compatibility with existing single-miner scenarios

### Proof of Concept

**Initial State**:
- Attacker Entity X has 300,000 ELF tokens
- Network has 17 miner positions available
- Current round has normal blockchain status

**Attack Steps**:

1. **Register Multiple Candidates**:
   - Entity X calls `AnnounceElection` or `AnnounceElectionFor` three times with different pubkeys (Miner A, B, C)
   - Locks 300,000 ELF total (100k per candidate)
   - Sets same admin address for all three candidates

2. **Get Elected**:
   - Entity X uses capital or coordination to secure votes for all three candidates
   - All three candidates rank in top 17 by votes
   - `GetVictories` returns Miner A, B, and C in the elected miner list

3. **Execute Block Production Bypass**:
   - Round begins, miners assigned orders (e.g., A=order 5, B=order 6, C=order 7)
   - **Miner A's time slot**: Produces 8 tiny blocks
     - Counter: 7→6→5→4→3→2→1→0 (approaching limit)
   - **Miner B's time slot**: Produces first block
     - Counter RESETS to 7 (different pubkey detected)
     - Produces 8 tiny blocks: 7→6→5→4→3→2→1→0
   - **Miner C's time slot**: Produces first block
     - Counter RESETS to 7 again
     - Produces 8 tiny blocks: 7→6→5→4→3→2→1→0

**Expected Result**: Each miner forced to NextRound after 8 blocks (total: 24 blocks across 3 rounds)

**Actual Result**: Entity X produces 24 continuous blocks within a single round period without triggering NextRound enforcement, bypassing the intended 8-block limit

**Success Condition**: `State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount` resets to positive value on each miner switch, allowing continued tiny block production beyond the intended per-entity limit.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L26-27)
```csharp
        validationResult.Success = true;
        return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L104-106)
```csharp
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L129-131)
```csharp
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-83)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-66)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
```
