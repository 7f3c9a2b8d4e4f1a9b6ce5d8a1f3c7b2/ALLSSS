# Audit Report

## Title
Incorrect Miner Count Calculation When Current Round Has Fewer Than Initial Miners

## Summary
The `GetMinersCount()` function in the AEDPoS consensus contract contains a logic error that returns the constant value of 17 miners instead of the time-based auto-increased count when the current round has fewer than 17 active miners. This prevents the network from growing to its intended decentralization level based on blockchain age.

## Finding Description

The vulnerability exists in the `GetMinersCount()` private method that calculates the target number of miners for the network. [1](#0-0) 

The function uses a flawed conditional check `input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount` to decide whether to apply the time-based auto-increase calculation. When the current round has fewer than 17 miners, it returns `Math.Min(17, MaximumMinersCount)` and completely bypasses the blockchain age calculation.

The correct behavior should calculate the target miner count based ONLY on blockchain age (time elapsed since genesis), similar to the `GetAutoIncreasedMinersCount()` helper method. [2](#0-1) 

**Execution Flow:**

1. During term transitions, `ProcessNextTerm()` calls `UpdateMinersCountToElectionContract()` [3](#0-2) 

2. This invokes `GetMinersCount(input)` with the new round as input [4](#0-3) 

3. The incorrect value is sent to the Election contract via `UpdateMinersCount` [5](#0-4) 

4. The Election contract stores this value in `State.MinersCount.Value` and uses it to determine how many block producers to select in `GetVictories()` [6](#0-5) 

**Example Scenario:**
- Blockchain has been running for 1 year, so the time-based calculation should return 25 miners
- Current term has only 15 active miners (due to bootstrap or temporary issues)
- `GenerateFirstRoundOfNextTerm()` creates a new round with 15 miners from victories [7](#0-6) 
- `GetMinersCount(nextRound)` sees 15 < 17 and returns 17 instead of 25
- Election contract now targets 17 miners for future elections instead of 25
- Network remains at lower decentralization level until manually corrected

## Impact Explanation

This vulnerability has direct impact on network security and decentralization:

1. **Reduced Block Producers**: The Election contract's `GetVictories()` method selects fewer miners than intended (e.g., 17 instead of 25), reducing consensus participation by up to 32% in the example scenario.

2. **Reduced Validation Data Centers**: The `GetValidationDataCenterCount()` calculation multiplies MinersCount by 5, so incorrect miner count caps data center slots at 85 instead of 125 (40 fewer slots). [8](#0-7) 

3. **Network Centralization**: Fewer block producers means reduced decentralization, making the network more vulnerable to censorship and coordinated attacks.

4. **Persistent Effect**: Once set incorrectly during a term transition, the miners count remains at the lower value affecting multiple subsequent terms until governance intervention or natural growth above the threshold.

The protocol's intended auto-increase mechanism based on blockchain maturity is completely bypassed, violating a core consensus security guarantee.

## Likelihood Explanation

This vulnerability triggers automatically during normal blockchain operations without requiring any attacker action:

**Preconditions:**
- Blockchain has been running long enough that the time-based auto-increased count exceeds 17
- Current round has fewer than 17 active miners

**Trigger Scenarios:**
1. **Bootstrap Phase**: When the blockchain is initializing and the miner set is still building up to the initial 17 miners
2. **Post-Disruption Recovery**: After temporary network issues cause active miners to drop below 17
3. **First Term Transition**: When transitioning from genesis to the first elected term with insufficient candidates

**Call Sites:**
The vulnerable function is invoked during:
- Term transitions via `UpdateMinersCountToElectionContract()` (most common)
- Round 1 completion in `ProcessNextRound()` [9](#0-8) 
- Governance actions in `SetMaximumMinersCount()` [10](#0-9) 

**Probability:** Medium to High - occurs automatically whenever the system enters a state with < 17 active miners during any of the above operations, which is realistic during network growth phases or recovery from disruptions.

## Recommendation

Remove the current miner count check and calculate the target miners count based solely on blockchain age, consistent with `GetAutoIncreasedMinersCount()`:

```csharp
private int GetMinersCount(Round input)
{
    if (State.BlockchainStartTimestamp.Value == null) 
        return AEDPoSContractConstants.SupposedMinersCount;

    if (!TryToGetRoundInformation(1, out _)) 
        return 0;
    
    // Calculate based only on blockchain age, not current miner count
    var autoIncreasedCount = AEDPoSContractConstants.SupposedMinersCount.Add(
        (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
        .Div(State.MinerIncreaseInterval.Value).Mul(2));
    
    return Math.Min(autoIncreasedCount, State.MaximumMinersCount.Value);
}
```

This ensures the target miner count always reflects the network's intended growth based on time, independent of temporary fluctuations in active miner count.

## Proof of Concept

The following test demonstrates the vulnerability by showing that when a blockchain has aged enough to support 25 miners, but the current round only has 15 miners, the function incorrectly returns 17:

```csharp
[Fact]
public async Task GetMinersCount_ShouldUseBlockchainAge_NotCurrentMinerCount()
{
    // Setup: Blockchain has been running for sufficient time to support 25 miners
    // Assume MinerIncreaseInterval = 31536000 (1 year in seconds)
    // After 4 years: 17 + (4 * 365 * 24 * 60 * 60 / 31536000) * 2 = 17 + 8 = 25
    
    // Create a round with only 15 miners (below SupposedMinersCount of 17)
    var testRound = new Round
    {
        RealTimeMinersInformation = 
        {
            // Add 15 miners
            { "miner1", new MinerInRound { Pubkey = "miner1" } },
            { "miner2", new MinerInRound { Pubkey = "miner2" } },
            // ... (add 13 more miners)
        }
    };
    
    // Call GetMinersCount with this round
    var result = GetMinersCount(testRound);
    
    // BUG: Returns 17 instead of 25
    // Expected: 25 (based on 4 years blockchain age)
    // Actual: 17 (because testRound has < 17 miners, bypasses age calculation)
    Assert.Equal(25, result); // This will FAIL, proving the bug
}
```

**Notes:**
- The constant `AEDPoSContractConstants.SupposedMinersCount` is defined as 17 [11](#0-10) 
- The vulnerability is confirmed by comparing with the correct implementation in `GetAutoIncreasedMinersCount()` which lacks the flawed current-count check
- The Election contract's dependency on this value for `GetVictories()` selection propagates the impact throughout the consensus system

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L117-137)
```csharp
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L176-176)
```csharp
        UpdateMinersCountToElectionContract(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L406-409)
```csharp
    private int GetValidationDataCenterCount()
    {
        return GetMinersCount(new Empty()).Value.Mul(5);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```
