### Title
Null Reference Vulnerability in GetProfitDetails Causes Downstream Transaction Failures

### Summary
The `GetProfitDetails` view method in the Profit contract returns `null` when querying non-existent beneficiary records, but multiple downstream callers in TokenHolder and Election contracts access the `Details` property without null checks. This causes `NullReferenceException` and transaction failures, leading to denial-of-service of critical profit distribution and voting functions.

### Finding Description

**Root Cause:**

The `GetProfitDetails` method directly returns the value from `State.ProfitDetailsMap` without any null checking: [1](#0-0) 

When accessing a non-existent key in `MappedState`, the underlying `Provider.Get` returns `null` bytes, and `SerializationHelper.Deserialize<ProfitDetails>(null)` returns `default(ProfitDetails)` which is `null` for reference types: [2](#0-1) [3](#0-2) 

**Vulnerable Downstream Callers:**

1. **TokenHolderContract.AddBeneficiary** - Accesses `detail.Details.Any()` without null check when adding new beneficiaries: [4](#0-3) 

2. **TokenHolderContract.RemoveBeneficiary** - Chains `.Details.Single()` directly on the return value: [5](#0-4) 

3. **ElectionContract.GetProfitDetailByElectionVotingRecord** - Accesses `profitDetails.Details.FirstOrDefault()` without null check: [6](#0-5) 

**Why Existing Protections Fail:**

The Profit contract's own `GetAllProfitsMap` method demonstrates the CORRECT pattern with a null check: [7](#0-6) 

However, `GetProfitDetails` lacks this protection, exposing callers to null reference exceptions.

### Impact Explanation

**Operational Denial of Service:**

1. **TokenHolder.AddBeneficiary** - This is the CRITICAL case. When adding a NEW beneficiary who doesn't exist in the profit scheme yet (normal expected flow), `GetProfitDetails` returns `null`. Accessing `detail.Details.Any()` throws `NullReferenceException`, causing transaction failure. This **completely breaks the ability to add beneficiaries** to TokenHolder profit schemes, rendering the core dividend distribution mechanism non-functional.

2. **TokenHolder.RemoveBeneficiary** - Calling this with a non-existent beneficiary address causes immediate crash. While less common than AddBeneficiary, a scheme manager could accidentally (or maliciously in their own scheme) trigger this, resulting in failed transactions.

3. **Election.ChangeVotingOption** - When voters change their vote with `IsResetVotingTime=true`, if profit details are somehow missing (edge case), the transaction fails, preventing vote changes.

**Affected Users:**
- All TokenHolder scheme managers cannot add new beneficiaries
- Users attempting to modify beneficiary lists experience transaction failures
- Voters may be unable to change voting options
- Profit distribution mechanisms become unreliable

### Likelihood Explanation

**TokenHolder.AddBeneficiary (VERY HIGH Likelihood):**
- **Reachable Entry Point**: Public RPC method defined in protobuf: [8](#0-7) 

- **Normal User Flow**: Adding a NEW beneficiary to a profit scheme is the standard operation. The first time ANY beneficiary is added, `GetProfitDetails` will return `null` because no prior profit details exist.

- **Preconditions**: Caller must be a scheme manager (authorized via `GetValidScheme` check): [9](#0-8) 

- **Execution Practicality**: Trivial - any scheme manager calling `AddBeneficiary` with a new address will trigger this.

**TokenHolder.RemoveBeneficiary (MEDIUM Likelihood):**
- Same entry point accessibility and authorization as AddBeneficiary
- Requires calling with non-existent beneficiary address (less common but possible through user error or malicious self-DoS)

**Election.ChangeVotingOption (LOW Likelihood):**
- Requires existing vote with missing profit details (edge case)
- Called via `ExtendVoterWelfareProfits` when `IsResetVotingTime=true`: [10](#0-9) 

### Recommendation

**Immediate Fix for Profit Contract:**

Add null check in `GetProfitDetails` to return empty `ProfitDetails` instead of `null`:

```csharp
public override ProfitDetails GetProfitDetails(GetProfitDetailsInput input)
{
    var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];
    return profitDetails ?? new ProfitDetails();
}
```

**Defensive Fixes for Downstream Callers:**

1. **TokenHolderContract.AddBeneficiary** - Add null check before accessing Details:
```csharp
var detail = State.ProfitContract.GetProfitDetails.Call(...);
if (detail != null && detail.Details.Any())
{
    // existing logic
}
```

2. **TokenHolderContract.RemoveBeneficiary** - Add validation:
```csharp
var details = State.ProfitContract.GetProfitDetails.Call(...);
Assert(details != null && details.Details.Any(), "Beneficiary not found in scheme.");
var detail = details.Details.Single();
```

3. **ElectionContract.GetProfitDetailByElectionVotingRecord** - Add null check:
```csharp
var profitDetails = State.ProfitContract.GetProfitDetails.Call(...);
if (profitDetails == null) return null;
```

**Test Cases:**

Add regression tests verifying:
- `GetProfitDetails` with non-existent scheme/beneficiary returns empty `ProfitDetails`, not `null`
- `AddBeneficiary` succeeds when called on new beneficiary (first-time add)
- `RemoveBeneficiary` fails gracefully with clear error for non-existent beneficiary

### Proof of Concept

**Initial State:**
1. Deploy TokenHolder and Profit contracts
2. Create a TokenHolder profit scheme via `CreateScheme`
3. Scheme exists but has zero beneficiaries

**Attack Steps:**

**Scenario 1: Break AddBeneficiary (Normal User Flow)**
```
1. As scheme manager, call TokenHolderContract.AddBeneficiary({
     Beneficiary: <NewUserAddress>,
     Shares: 100
   })
   
2. Internal flow:
   - GetValidScheme succeeds (manager authorized)
   - Calls ProfitContract.GetProfitDetails(SchemeId, NewUserAddress)
   - Returns null (beneficiary never existed in profit scheme)
   - Accesses detail.Details.Any() → NullReferenceException
   
3. Transaction fails with null reference error
4. No beneficiaries can ever be added to the scheme
```

**Scenario 2: Crash RemoveBeneficiary**
```
1. As scheme manager, call TokenHolderContract.RemoveBeneficiary({
     Beneficiary: <NonExistentAddress>,
     Amount: 0
   })
   
2. Internal flow:
   - Calls GetProfitDetails(SchemeId, NonExistentAddress)
   - Returns null
   - Attempts .Details.Single() → NullReferenceException
   
3. Transaction fails
```

**Expected Result:** Both transactions should complete successfully or fail with clear error messages.

**Actual Result:** Both transactions throw `NullReferenceException`, causing complete transaction failure and rendering the affected functions unusable.

**Success Condition:** Ability to add first beneficiary to any TokenHolder profit scheme is completely blocked, confirming the vulnerability causes denial-of-service of core functionality.

---

**Notes:**

The most critical impact is on `TokenHolder.AddBeneficiary` which breaks for ALL new beneficiaries (not just edge cases). This represents a HIGH severity operational DoS vulnerability that prevents the normal functioning of the profit distribution system. The vulnerability exists because the Profit contract's view method returns `null` (following standard `MappedState` behavior for non-existent keys), but callers assume it always returns a valid `ProfitDetails` object. The fix is straightforward: return an empty `ProfitDetails` instance instead of `null`.

### Citations

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L46-49)
```csharp
    public override ProfitDetails GetProfitDetails(GetProfitDetailsInput input)
    {
        return State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L108-110)
```csharp
        var profitDetails = State.ProfitDetailsMap[schemeId][beneficiary];

        if (profitDetails == null) return new GetAllProfitsMapOutput();
```

**File:** src/AElf.Types/Helper/SerializationHelper.cs (L88-91)
```csharp
        public static T Deserialize<T>(byte[] bytes)
        {
            if (bytes == null)
                return default;
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L95-108)
```csharp
    private ValuePair LoadKey(TKey key)
    {
        var path = GetSubStatePath(key.ToString());
        var bytes = Provider.Get(path);
        var value = SerializationHelper.Deserialize<TEntity>(bytes);
        var originalValue = SerializationHelper.Deserialize<TEntity>(bytes);

        return new ValuePair
        {
            OriginalValue = originalValue,
            Value = value,
            IsDeleted = false
        };
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L40-46)
```csharp
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L74-79)
```csharp
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-281)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L33-37)
```csharp
        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L170-177)
```csharp
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
```

**File:** protobuf/token_holder_contract.proto (L24-25)
```text
    rpc AddBeneficiary (AddTokenHolderBeneficiaryInput) returns (google.protobuf.Empty) {
    }
```
