# Audit Report

## Title
Missing Validation of Decrypted Secret Pieces Allows Consensus Randomness Manipulation

## Summary
The AEDPoS consensus mechanism's secret sharing implementation fails to validate that decrypted pieces correspond to committed encrypted pieces. Malicious miners can submit arbitrary bytes as "decrypted" pieces, causing incorrect InValue reconstruction that manipulates signature calculations and miner ordering in subsequent rounds, breaking the VRF randomness property of the consensus mechanism.

## Finding Description

The secret sharing mechanism in AEDPoS consensus uses a commit-reveal scheme where miners commit to an `OutValue = Hash(InValue)` and later reveal the `InValue` through decrypted secret pieces. However, the protocol is missing a critical verification step.

**Vulnerable Entry Point:**

The `UpdateLatestSecretPieces()` function blindly accepts and stores decrypted pieces from miners without any validation: [1](#0-0) 

This function iterates through provided decrypted pieces and stores them directly in the round state without checking their authenticity.

**Missing Validation in InValue Reconstruction:**

When `RevealSharedInValues()` reconstructs a miner's InValue from the collected decrypted pieces, it performs no validation that the reconstructed value matches the originally committed OutValue: [2](#0-1) 

The function uses `SecretSharingHelper.DecodeSecret()` to reconstruct the InValue and computes its hash, but **never validates this against the miner's committed OutValue** from the previous round. The critical missing check is: `Hash(DecodeSecret(decryptedPieces)) == OutValue`.

**Impact on Consensus:**

The fake PreviousInValue is later used in `SupplyCurrentRoundInformation()` to calculate signatures for miners who didn't produce blocks: [3](#0-2) 

This signature directly affects miner ordering through the `CalculateSignature()` method, which XORs the previousInValue with all existing signatures: [4](#0-3) 

The resulting signature value determines `FinalOrderOfNextRound` through modulo calculation: [5](#0-4) 

**Why Existing Protections Fail:**

1. **Validation Only Checks Self:** The `UpdateValueValidationProvider` only validates the block producer's own PreviousInValue against their previous OutValue, not other miners' revealed values: [6](#0-5) 

2. **No Cryptographic Authentication:** The ECDH+AES encryption provides confidentiality (only the intended recipient can decrypt) but not authenticity. There's no mechanism to prove the claimed decryption is correct without access to the private key.

3. **Off-Chain Service Mirrors Vulnerability:** The off-chain `SecretSharingService` has the same issue - it reconstructs InValues without validation: [7](#0-6) 

## Impact Explanation

**Consensus Integrity Breach:**
- Malicious miners can manipulate which miners get assigned to which time slots in subsequent rounds
- This breaks the unpredictability guarantee of the VRF-based consensus mechanism  
- Attackers can increase their own mining frequency or favor/punish specific miners

**Concrete Attack Scenario:**
1. Round N: Miner A commits `OutValue_A = Hash(InValue_A)` and shares encrypted pieces
2. Round N+1: Malicious Miner B, instead of decrypting Miner A's encrypted piece properly, submits arbitrary fake bytes as the "decrypted" piece
3. Round N+1: `RevealSharedInValues()` uses these fake pieces to reconstruct an incorrect `InValue_A'`  
4. Round N+2: If Miner A didn't mine in Round N+1, `SupplyCurrentRoundInformation()` uses the fake `InValue_A'` to calculate Miner A's signature
5. Result: Miner A gets assigned the wrong order in the next round based on the manipulated signature

**Protocol Damage:**
- Violates the "correct round transitions and miner schedule integrity" invariant
- Undermines fairness of block production opportunities
- Enables strategic manipulation of consensus order for economic gain
- Network security is compromised as consensus randomness is foundational to the protocol

## Likelihood Explanation

**Attacker Capabilities:**
- Must be a current miner (realistic - these are elected positions available to any qualified participant)
- Requires secret sharing to be enabled (typically enabled by default for consensus randomness)
- No special privileges needed beyond normal miner status

**Attack Complexity:**
- Low complexity - attacker simply modifies their off-chain service to submit arbitrary bytes as "decrypted" pieces instead of performing actual decryption
- No complex cryptographic attacks required
- Can be executed during normal block production workflow

**Feasibility Conditions:**
- Secret sharing must be enabled (checked via `IsSecretSharingEnabled()`)
- Target miners must have submitted encrypted pieces in previous rounds (normal behavior)
- Attacker needs to be producing blocks when the UpdateValue behavior occurs

**Detection Difficulty:**
- Very hard to detect on-chain - fake decrypted pieces are indistinguishable from real ones in the contract state
- No way to verify claimed decryption without the recipient's private key
- Would require extensive off-chain statistical analysis to identify anomalies in miner ordering patterns

**Economic Rationality:**
- Attack cost: Minimal (just submitting incorrect data during normal mining operations)
- Potential gain: Improved mining positions, ability to favor allies or punish competitors, increased block rewards
- Risk: Low (undetectable through normal validation mechanisms)

## Recommendation

Add validation in `RevealSharedInValues()` to verify that reconstructed InValues match the committed OutValues:

```csharp
var revealedInValue =
    HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// Add this validation check:
if (revealedInValue != anotherMinerInPreviousRound.OutValue)
{
    Context.LogDebug(() => $"Invalid revealed InValue for {publicKeyOfAnotherMiner}");
    continue; // Skip this miner's invalid revelation
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

Similarly, add the same validation in the off-chain `SecretSharingService.RevealPreviousInValues()` method to prevent propagation of invalid data.

## Proof of Concept

```csharp
[Fact]
public async Task SecretSharing_MaliciousDecryptedPieces_ManipulatesConsensus()
{
    // Setup: Initialize consensus with multiple miners
    await InitializeConsensusAsync();
    
    // Round N: Honest Miner A commits OutValue and shares encrypted pieces
    var minerAKeyPair = InitialCoreDataCenterKeyPairs[0];
    var minerBKeyPair = InitialCoreDataCenterKeyPairs[1];
    
    var honestInValue = HashHelper.ComputeFrom("honest_secret");
    var honestOutValue = HashHelper.ComputeFrom(honestInValue);
    
    // Miner A encrypts and shares pieces in Round N
    await ProduceNormalBlock(minerAKeyPair, honestInValue);
    
    // Round N+1: Malicious Miner B submits FAKE decrypted piece
    var fakeDecryptedPiece = ByteString.CopyFrom(HashHelper.ComputeFrom("fake").ToByteArray());
    
    var maliciousUpdateInput = new UpdateValueInput
    {
        DecryptedPieces = { { minerAKeyPair.PublicKey.ToHex(), fakeDecryptedPiece } },
        // ... other required fields
    };
    
    await ProduceBlockWithUpdateValue(minerBKeyPair, maliciousUpdateInput);
    
    // Round N+2: Check if Miner A's order was manipulated
    var currentRound = await GetCurrentRound();
    var minerAPreviousInValue = currentRound.RealTimeMinersInformation[minerAKeyPair.PublicKey.ToHex()].PreviousInValue;
    
    // Verify that the reconstructed InValue does NOT match the honest commitment
    var reconstructedOutValue = HashHelper.ComputeFrom(minerAPreviousInValue);
    
    // This assertion proves the vulnerability: fake pieces caused wrong InValue reconstruction
    reconstructedOutValue.ShouldNotBe(honestOutValue);
    
    // Further verify this affects miner ordering
    var manipulatedSignature = currentRound.CalculateSignature(minerAPreviousInValue);
    var honestSignature = currentRound.CalculateSignature(honestInValue);
    
    // Signatures differ, proving consensus manipulation
    manipulatedSignature.ShouldNotBe(honestSignature);
}
```

**Notes:**

This vulnerability represents a fundamental flaw in the secret sharing verification mechanism. The commit-reveal scheme is incomplete - it has the commit phase (OutValue) and reveal phase (decrypted pieces â†’ InValue) but lacks the crucial verification phase that ensures revealed values match commitments. This allows any miner to "reveal" arbitrary values for other miners, completely breaking the randomness properties the scheme is designed to provide.

The attack is particularly dangerous because:
1. It's undetectable on-chain (no way to verify decryption correctness without private keys)
2. It can be executed silently during normal operations
3. It compounds over rounds, allowing sustained manipulation of consensus ordering
4. The economic incentives strongly favor exploitation (low cost, high potential gain)

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-146)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-52)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L186-199)
```csharp
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-114)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L40-48)
```csharp
        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L164-176)
```csharp
            // Reveal another miner's in value for target round:

            var orders = minerInRound.DecryptedPieces.Select((t, i) =>
                    round.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    minerInRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = minerInRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```
