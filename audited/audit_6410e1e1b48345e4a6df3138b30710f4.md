# Audit Report

## Title
Unauthorized Round Termination Due to Missing Extra Block Producer Validation in Side Chain Consensus

## Summary
The AEDPoS side chain consensus allows any miner whose time slot has passed to produce `NextRound` blocks that terminate the current round, instead of restricting this privilege to the designated extra block producer. This occurs because `SideChainConsensusBehaviourProvider` unconditionally returns `NextRound` behavior, and the validation pipeline fails to verify the sender's authority as the extra block producer.

## Finding Description

The AEDPoS consensus protocol designates exactly one miner per round as the "extra block producer" who is responsible for producing the final block that terminates the round and initiates the next round. This is explicitly documented in the protocol design. [1](#0-0) 

The vulnerability consists of two parts:

**Part 1: Unconditional Behavior Assignment**

When a side chain miner's time slot passes, the `SideChainConsensusBehaviourProvider` unconditionally returns `NextRound` behavior without checking if that miner is the designated extra block producer: [2](#0-1) 

This method is invoked when `ConsensusBehaviourProviderBase.GetConsensusBehaviour()` determines that a miner's time slot has passed: [3](#0-2) 

The behavior is then used to generate a consensus command that creates a `TerminateRoundCommandStrategy`: [4](#0-3) 

**Part 2: Missing Validation**

The consensus contract has an `IsCurrentMiner()` method that correctly checks if a miner is authorized to mine, including validation of extra block producer status during the extra block time slot: [5](#0-4) 

However, this authorization check is **never invoked** during consensus validation. The `ValidateBeforeExecution` method for `NextRound` behavior only adds general validation providers: [6](#0-5) 

These validators perform only structural checks:

- `MiningPermissionValidationProvider` verifies miner list membership, not extra block producer status: [7](#0-6) 

- `TimeSlotValidationProvider` validates the new round's time slot structure but doesn't check sender authority: [8](#0-7) 

- `RoundTerminateValidationProvider` only checks round number correctness and InValue fields: [9](#0-8) 

The `ProcessNextRound` execution also only verifies miner list membership in its `PreCheck()`: [10](#0-9) 

## Impact Explanation

This vulnerability breaks a fundamental consensus invariant: that each round must be terminated by exactly one designated extra block producer. The protocol calculates which miner should be the extra block producer through deterministic logic: [11](#0-10) 

**Concrete Harms:**

1. **Consensus Integrity Violation**: Multiple miners can simultaneously produce valid `NextRound` blocks when their time slots pass, even though only one should have this authority. This violates the deterministic round progression mechanism.

2. **Potential Blockchain Forks**: If multiple miners produce competing `NextRound` blocks at similar times, different nodes may accept different blocks, causing temporary chain inconsistency or forks.

3. **Protocol Design Violation**: The extra block mining time is specifically calculated to occur after all normal miners have finished: [12](#0-11) 

However, any miner whose normal time slot has passed can now produce the round-terminating block prematurely.

4. **Network Stability**: The predictability of round transitions is compromised, affecting applications that depend on deterministic block timing and mining schedules.

## Likelihood Explanation

**Extremely High Likelihood** - This is not an "attack" requiring malicious intent; it occurs naturally during normal side chain operations:

1. **Attacker Prerequisites**: Only requires being a current miner in the side chain (normal operational status)

2. **Trigger Conditions**: 
   - Miner's time slot passes (inevitable during normal operation)
   - Miner calls `GetConsensusCommand` (standard consensus operation performed by all miners): [13](#0-12) 
   - Receives `NextRound` behavior and produces corresponding block

3. **No Barriers**: No economic cost, no special privileges required, uses standard public methods

4. **High Probability Scenario**: In a typical network with 4+ miners, any non-extra-block-producer whose time slot has passed (75%+ of miners) will receive `NextRound` behavior when querying for their next command.

## Recommendation

Add extra block producer validation to the consensus validation pipeline. Specifically:

1. **Create a new validation provider** `ExtraBlockProducerValidationProvider` that checks:
   - For `NextRound` behavior, verify the sender is the designated extra block producer
   - Use the existing `IsCurrentMiner()` logic or check `currentRound.RealTimeMinersInformation[senderPubkey].IsExtraBlockProducer`

2. **Add the provider to ValidateBeforeExecution** for `NextRound` and `NextTerm` behaviors:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new ExtraBlockProducerValidationProvider()); // NEW
    break;
```

3. **Alternative fix**: Modify `ConsensusBehaviourProviderBase.GetConsensusBehaviour()` to check if the miner is the extra block producer before calling `GetConsensusBehaviourToTerminateCurrentRound()`, returning `Nothing` for non-extra-block-producers.

## Proof of Concept

Test demonstrating that a non-extra-block-producer miner receives `NextRound` behavior:

```csharp
[Fact]
public async Task NonExtraBlockProducer_Can_Get_NextRound_Behavior()
{
    // Setup: Complete first round with all miners producing blocks
    await CompleteFirstRoundWithAllMiners();
    
    // Get current round information
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Identify the extra block producer
    var extraBlockProducer = currentRound.RealTimeMinersInformation
        .First(m => m.Value.IsExtraBlockProducer).Key;
    
    // Pick a different miner (non-extra-block-producer)
    var nonExtraBlockProducer = currentRound.RealTimeMinersInformation.Keys
        .First(k => k != extraBlockProducer);
    
    // Set time to after this miner's time slot has passed
    var minerInfo = currentRound.RealTimeMinersInformation[nonExtraBlockProducer];
    BlockTimeProvider.SetBlockTime(minerInfo.ExpectedMiningTime.AddMilliseconds(
        currentRound.GetMiningInterval() + 1000));
    
    // This miner should NOT get NextRound behavior, but they do
    KeyPairProvider.SetKeyPair(GetKeyPairForPubkey(nonExtraBlockProducer));
    var consensusCommand = await AEDPoSContractStub.GetConsensusCommand
        .CallAsync(ByteStringHelper.FromHexString(nonExtraBlockProducer).ToBytesValue());
    
    var hint = AElfConsensusHint.Parser.ParseFrom(consensusCommand.Hint);
    
    // VULNERABILITY: Non-extra-block-producer gets NextRound behavior
    hint.Behaviour.ShouldBe(AElfConsensusBehaviour.NextRound); // This passes but shouldn't
}
```

This test proves that any miner whose time slot has passed receives `NextRound` behavior, regardless of whether they are the designated extra block producer.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L61-64)
```csharp
    ///     In current AElf Consensus design, each miner produce his block in one time slot, then the extra block producer
    ///     produce a block to terminate current round and confirm the mining order of next round.
    ///     So totally, the time of one round is:
    ///     MiningInterval * MinersCount + MiningInterval.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L20-22)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-82)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L39-44)
```csharp
            case AElfConsensusBehaviour.NextRound:
            case AElfConsensusBehaviour.NextTerm:
                return new ConsensusCommandProvider(
                        new TerminateRoundCommandStrategy(currentRound, pubkey, currentBlockTime,
                            behaviour == AElfConsensusBehaviour.NextTerm))
                    .GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-34)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-65)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L117-122)
```csharp
    public Timestamp GetExtraBlockMiningTime()
    {
        return RealTimeMinersInformation.OrderBy(m => m.Value.Order).Last().Value
            .ExpectedMiningTime
            .AddMilliseconds(GetMiningInterval());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-46)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();
```
