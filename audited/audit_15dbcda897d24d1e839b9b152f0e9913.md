# Audit Report

## Title
Permanent Loss of Profits Beyond 10th Detail Due to Hardcoded Claiming Limit

## Summary
The Profit contract enforces a hardcoded limit of 10 profit details per claim transaction, causing users with more than 10 active profit details to permanently lose access to profits from details beyond the 10th position. This affects Election voters who vote multiple times, as each vote creates a separate profit detail. The vulnerability is exacerbated by a critical discrepancy: view functions correctly calculate ALL entitled profits, but the claiming mechanism only processes the first 10 details.

## Finding Description

The vulnerability stems from a hardcoded constant that restricts profit claiming to exactly 10 profit details per transaction.

**Hardcoded Limit:**
The constant `ProfitReceivingLimitForEachTime = 10` is defined and immutable. [1](#0-0) 

**ClaimProfits Processing Restriction:**
The `ClaimProfits` function enforces this limit by capping the number of processable details. [2](#0-1) 

Only the first `profitableDetailCount` (maximum 10) profit details are processed in the claiming loop. [3](#0-2) 

**Critical Update Logic:**
Only processed details have their `LastProfitPeriod` updated through the `ProfitAllPeriods` call. Details beyond index 10 never enter this loop, so their `LastProfitPeriod` remains stale, preventing future processing.

**Removal Condition Prevents Cleanup:**
Profit details are only removed when they are fully expired and claimed. [4](#0-3) 

If the first 10 details haven't fully expired (which can take years for long lock periods), they continuously block access to details 11+.

**Election Voting Creates Multiple Details:**
Each vote in the Election contract creates a separate profit detail, making accumulation of >10 details common for active voters. [5](#0-4) 

**View Function Discrepancy - The Smoking Gun:**
The view function `GetAllProfitsMap` reveals the true extent of the issue. It correctly calculates profits for ALL profit details (not just first 10), but distinguishes between total entitled profits and claimable profits. [6](#0-5) 

Line 125 iterates through ALL available details, calculating total profits in `allProfitsDict`. However, line 132 restricts claimable profits to only the first 10 details (`if(i >= profitableDetailCount) continue`). This creates a scenario where users can SEE their full entitled profits but CANNOT CLAIM them.

**No Mechanism to Select Details:**
The `ClaimProfitsInput` message only accepts `scheme_id` and `beneficiary`—there is no parameter to specify which profit details to process. [7](#0-6) 

Users are permanently stuck with the first 10 details in chronological order until they expire.

## Impact Explanation

**Direct Financial Loss:**
- Users with 15 profit details lose access to 5 details worth of profits indefinitely
- If all details have equal weight, this represents a 33% loss of entitled rewards
- For users with 20 details, the loss reaches 50%
- The view function (`GetAllProfitsMap`) shows users their full entitled amount, creating false expectations while the actual claiming is permanently capped

**Affected User Groups:**
- **Election Voters:** The primary affected group. Active voters who vote multiple times (voting for different candidates, changing votes, re-voting after withdrawal) naturally accumulate >10 profit details. The Election system encourages multiple votes for maximizing rewards.
- **Long Lock Period Users:** Users who vote with 1-3 year lock periods face extended blocking periods, as their first 10 details won't expire for years.
- **Any Profit Beneficiaries:** Any user added to profit schemes >10 times with different periods faces the same issue.

**Severity Justification - HIGH:**
1. **Direct Fund Loss:** Permanent and unrecoverable loss of entitled profits
2. **Affects Normal Behavior:** Voting multiple times is expected, encouraged, and necessary for optimal participation
3. **Silent Failure:** No error messages, reverts, or warnings. Users silently lose funds while transactions appear successful
4. **False UI Expectations:** The discrepancy between view functions (showing all profits) and claiming functions (limiting to 10) means users believe they have more claimable profits than they actually do
5. **Scales with Engagement:** More active participants suffer greater losses—penalizing the most engaged users

## Likelihood Explanation

**Trivial to Trigger:**
1. Vote 11 times in the Election contract (each vote creates a profit detail)
2. Call `ClaimProfits` to claim rewards
3. Observe that only profits from the first 10 votes are claimable
4. Details 11+ are permanently inaccessible until the first 10 expire

**No Special Privileges Required:**
This affects normal users through standard contract usage—no admin access, special permissions, or attack vectors needed.

**High Probability:**
- The Election system encourages multiple votes over time (changing preferences, maximizing rewards, voting for different candidates)
- Lock periods of 1-3 years are common, meaning the first 10 details remain "active" for extended periods
- Engaged community members who regularly participate in governance will naturally accumulate >10 details
- With continuous profit period distributions (common in schemes like CitizenWelfare), the first 10 details remain perpetually profitable, permanently blocking access to 11+

**Not Easily Detectable:**
- View functions show full entitled profits, giving users false confidence
- No error messages or transaction failures
- Users may not realize they're losing funds until they manually inspect their profit detail count
- The gap between "entitled profits" (from view) and "claimable profits" (actual) is not clearly communicated

**Realistic Preconditions:**
All conditions for this vulnerability are normal operational states:
- Multiple votes per user (expected behavior)
- Continuous profit distributions (standard for active schemes)
- Long lock periods (encouraged for higher rewards)
- No unusual contract states or edge cases required

**Probability Assessment: HIGH** - This will affect any user who votes more than 10 times in the Election system, which is a common and expected occurrence for engaged participants over months/years of operation.

## Recommendation

**Solution 1: Remove the Hardcoded Limit (Preferred)**
Remove the 10-detail restriction entirely and allow users to claim all available profits in a single transaction. If gas limits are a concern, add an optional `maxDetailsToProcess` parameter to `ClaimProfitsInput` that defaults to unlimited but allows users to control gas costs.

**Solution 2: Process All Details with Pagination**
Modify `ClaimProfits` to automatically continue processing from detail 11+ on subsequent calls. Track the last processed detail index and resume from there, ensuring all details eventually get processed.

**Solution 3: Add Detail Selection**
Add an optional parameter to `ClaimProfitsInput` allowing users to specify which profit details (by ID) to process. This gives users control over which details to claim when they have >10.

**Solution 4: Automatic Detail Consolidation**
Implement a mechanism to automatically consolidate multiple profit details for the same beneficiary into fewer details, preventing accumulation beyond 10.

**Immediate Mitigation:**
At minimum, add clear documentation and UI warnings that:
1. Only the first 10 details are processed per claim
2. Users with >10 details will have inaccessible profits
3. Display both "total entitled" and "currently claimable" amounts separately in views

**Code Fix Example (Solution 1 - Preferred):**
```csharp
// In ProfitContract.cs ClaimProfits method, replace:
var profitableDetailCount = Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);

// With:
var profitableDetailCount = profitableDetails.Count; // Process all details
```

## Proof of Concept

**Scenario:**
1. User votes 15 times in Election contract → 15 profit details created
2. Profit scheme distributes rewards for period 1
3. User calls `ClaimProfits`:
   - Only details 1-10 are processed
   - Details 11-15 never have their `LastProfitPeriod` updated
   - Details 11-15 remain stuck at period 0
4. Profit scheme distributes rewards for period 2
5. User calls `ClaimProfits` again:
   - Details 1-10 are profitable again (if not expired) and get processed
   - Details 11-15 still stuck, never processed
6. User calls `GetAllProfitsMap`:
   - Shows profits from ALL 15 details in `AllProfitsMap`
   - Shows profits from only 10 details in `OneTimeClaimableProfitsMap`
   - User can SEE the full amount but CANNOT CLAIM it

**Expected Behavior:**
All 15 profit details should be processed, and all entitled profits should be claimable.

**Actual Behavior:**
Only the first 10 details are ever processed. Details 11-15 are permanently inaccessible until the first 10 fully expire (which could take years for long lock periods). The view function creates a false expectation by showing all profits as if they were claimable.

**Loss Quantification:**
If each detail has equal voting weight and the scheme distributes 1000 ELF per period:
- User is entitled to: (1000 ELF × 15 details) / total_scheme_shares
- User can claim: (1000 ELF × 10 details) / total_scheme_shares
- **Permanent loss: 33% of entitled profits**

---

**Notes:**
- This vulnerability breaks the fundamental invariant that users can claim all profits they are entitled to
- The discrepancy between view functions and claim functions is particularly deceptive
- The issue compounds over time as more engaged users accumulate more profit details
- No workaround exists for users beyond waiting years for the first 10 details to expire
- The hardcoded limit appears to be a gas optimization that was never intended to cause permanent fund loss

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L5-5)
```csharp
    public const int ProfitReceivingLimitForEachTime = 10;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L772-773)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L777-785)
```csharp
        for (var i = 0; i < profitableDetailCount; i++)
        {
            var profitDetail = profitableDetails[i];
            if (profitDetail.LastProfitPeriod == 0)
                // This detail never performed profit before.
                profitDetail.LastProfitPeriod = profitDetail.StartPeriod;

            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-789)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L125-135)
```csharp
        for (var i = 0; i < availableDetails.Count; i++)
        {
            var profitDetail = availableDetails[i];
            if (profitDetail.LastProfitPeriod == 0) profitDetail.LastProfitPeriod = profitDetail.StartPeriod;
            
            var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod),true, symbol);
            AddProfitToDict(allProfitsDict, totalProfitsDictForEachProfitDetail);
            if(i >= profitableDetailCount) continue;
            var claimableProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount,true, symbol);
            AddProfitToDict(claimableProfitsDict, claimableProfitsDictForEachProfitDetail);
        }
```

**File:** protobuf/profit_contract.proto (L217-222)
```text
message ClaimProfitsInput {
    // The scheme id.
    aelf.Hash scheme_id = 1;
    // The address of beneficiary.
    aelf.Address beneficiary = 2;
}
```
