### Title
Self-Validating Authorization Contract Bypass Enables Complete Governance Circumvention

### Summary
The `ValidateProposerAuthority()` function trusts return values from external authorization contracts without proper validation. The `ChangeContractDeploymentController()` method uses self-referential validation via `CheckOrganizationExist()`, allowing a malicious authorization contract to pass validation by lying about itself, then permanently bypass all proposer whitelist checks for contract deployments.

### Finding Description

The vulnerability exists in the contract deployment authorization flow: [1](#0-0) 

This function blindly trusts the `BoolValue.Value` returned by the authorization contract. It's called in `DecideNonSystemContractAuthor()`: [2](#0-1) 

The critical flaw is in how new controllers are validated in `ChangeContractDeploymentController()`: [3](#0-2) 

The `CheckOrganizationExist()` validation is self-referential: [4](#0-3) 

**Root Cause**: The new controller contract validates itself. A malicious contract can return `true` for both `ValidateOrganizationExist` and `ValidateProposerInWhiteList` regardless of actual parameters, passing validation while providing no real authorization enforcement.

**Why Protections Fail**: 
- No verification that the controller implements ACS3 correctly
- No system contract whitelist check
- No comparison against known legitimate governance contracts (Parliament/Association/Referendum)
- The validation contract IS the contract being validated (circular trust)

### Impact Explanation

**Complete Governance Bypass**: Once a malicious controller is approved and set, it returns `true` for all `ValidateProposerInWhiteList` calls, making `DecideNonSystemContractAuthor()` always return the proposer as author instead of the Genesis contract. This allows:

1. **Unauthorized Contract Deployment**: Any address can become contract author, bypassing organization approval requirements
2. **Arbitrary Code Deployment**: Attackers can deploy malicious contracts with chosen authors
3. **Permanent Damage**: No mechanism exists to detect or revert a malicious controller once set
4. **Protocol-Wide Impact**: All future contract deployments are compromised, affecting the entire chain's security model

**Who Is Affected**: The entire blockchain network, as contract deployment governance is a critical security boundary.

**Severity Justification**: Critical - violates the fundamental authorization invariant, permanently compromises governance controls, and enables arbitrary malicious contract deployment.

### Likelihood Explanation

**Attacker Capabilities Required**:
1. Deploy a malicious smart contract implementing the ACS3 interface
2. Obtain governance approval for controller change (social engineering or compromise of governance participants)

**Attack Complexity**: Medium - requires deploying a contract and creating a governance proposal, but the malicious contract code is trivial:
```csharp
public override BoolValue ValidateOrganizationExist(Address input) => new BoolValue { Value = true };
public override BoolValue ValidateProposerInWhiteList(ValidateProposerInWhiteListInput input) => new BoolValue { Value = true };
```

**Feasibility Conditions**: 
- Governance participants may approve the change if presented as a "new governance model" or "improved authorization system"
- No technical mechanism exists to distinguish malicious from legitimate controllers during approval
- The self-validation flaw makes it impossible for honest governance to detect the attack at validation time

**Detection Constraints**: The malicious controller appears valid during `CheckOrganizationExist()`, making detection during the approval process extremely difficult without manual code review by governance participants.

**Probability Assessment**: Medium-High likelihood given:
- Self-validation flaw guarantees bypass once approved
- Social engineering governance is a known attack vector
- No automated defense mechanisms exist

### Recommendation

**Immediate Mitigation**:
1. Maintain a whitelist of approved authorization contract addresses (Parliament, Association, Referendum system contracts)
2. Add validation in `ChangeContractDeploymentController()`:

```csharp
public override Empty ChangeContractDeploymentController(AuthorityInfo input)
{
    AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
    
    // NEW: Validate controller is a known system contract
    var systemContracts = Context.GetSystemContractNameToAddressMapping();
    var isSystemContract = systemContracts.Values.Contains(input.ContractAddress);
    Assert(isSystemContract, "Controller must be a system contract.");
    
    // Validate organization using CURRENT controller, not new one
    var currentController = State.ContractDeploymentController.Value;
    var organizationExist = Context.Call<BoolValue>(
        currentController.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        input.OwnerAddress).Value;
    Assert(organizationExist, "Invalid authority input.");
    
    State.ContractDeploymentController.Value = input;
    return new Empty();
}
```

**Invariant Checks to Add**:
- Controller contract must be in system contract mapping
- Organization validation must use current controller, not new controller
- Add event logging for controller changes with old and new values for monitoring

**Test Cases**:
1. Attempt to set non-system-contract as controller → should fail
2. Attempt to set controller with non-existent organization → should fail (validated by current controller)
3. Verify legitimate controller change (Parliament → Association) still works
4. Verify malicious contract returning always-true cannot be set as controller

### Proof of Concept

**Initial State**:
- Genesis contract initialized with Parliament as `ContractDeploymentController`
- Attacker deploys `MaliciousAuthContract` implementing:
  - `ValidateOrganizationExist(Address) => true`
  - `ValidateProposerInWhiteList(ValidateProposerInWhiteListInput) => true`

**Attack Steps**:
1. Attacker creates Parliament proposal to call `ChangeContractDeploymentController` with:
   - `ContractAddress = MaliciousAuthContract`
   - `OwnerAddress = AttackerAddress`

2. Proposal passes governance (social engineering: "improved governance model")

3. Proposal executes → `CheckOrganizationExist()` calls `MaliciousAuthContract.ValidateOrganizationExist(AttackerAddress)` → returns `true` → validation passes

4. `State.ContractDeploymentController.Value` now points to `MaliciousAuthContract`

5. Any user calls `ProposeNewContract()` → creates proposal → eventually calls `DecideNonSystemContractAuthor(proposer, sender)` → calls `ValidateProposerAuthority(MaliciousAuthContract, AttackerAddress, proposer)` → malicious contract returns `true` → proposer becomes contract author (bypassing whitelist)

**Expected Result**: Controller change should be rejected due to invalid/non-system contract

**Actual Result**: Malicious controller is accepted and all future deployments bypass governance

**Success Condition**: Any address can deploy contracts with themselves as author without governance approval

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L246-255)
```csharp
    private bool ValidateProposerAuthority(Address contractAddress, Address organizationAddress, Address proposer)
    {
        return Context.Call<BoolValue>(contractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateProposerInWhiteList),
            new ValidateProposerInWhiteListInput
            {
                OrganizationAddress = organizationAddress,
                Proposer = proposer
            }).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L257-266)
```csharp
    private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
    {
        if (!State.ContractDeploymentAuthorityRequired.Value)
            return sender;

        var contractDeploymentController = State.ContractDeploymentController.Value;
        var isProposerInWhiteList = ValidateProposerAuthority(contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposer);
        return isProposerInWhiteList ? proposer : Context.Self;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L366-373)
```csharp
    public override Empty ChangeContractDeploymentController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.ContractDeploymentController.Value = input;
        return new Empty();
    }
```
