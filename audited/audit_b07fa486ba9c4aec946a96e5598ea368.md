### Title
Unbounded Loop DoS in MinersCount Reduction via SyncSubsidyInfoAfterReduceMiner

### Summary
When `MinersCount` is drastically reduced through governance action, the `SyncSubsidyInfoAfterReduceMiner` method attempts to remove all excess candidates from `DataCentersRankingList` in a single transaction without batching or upper bound checks. This can result in hundreds of iterations with cross-contract calls to `ProfitContract.RemoveBeneficiary`, potentially exceeding gas limits and causing a Denial of Service that prevents legitimate miner count adjustments.

### Finding Description

The vulnerability exists in the `SyncSubsidyInfoAfterReduceMiner` method which is invoked when `UpdateMinersCount` is called by the consensus contract: [1](#0-0) 

The `SyncSubsidyInfoAfterReduceMiner` implementation performs an unbounded loop over all excess candidates: [2](#0-1) 

The method calculates `validDataCenterCount` as `MinersCount * 5`: [3](#0-2) 

**Root Cause:** The `DataCentersRankingList` can grow up to the previous `validDataCenterCount` limit. When candidates announce election, they are added to the list if space permits: [4](#0-3) 

**Attack Vector:** 
1. Governance sets `MaximumMinersCount` to a high value (e.g., 100) via parliament proposal
2. Over time, up to 500 candidates (100 * 5) are added to `DataCentersRankingList`
3. Governance reduces `MaximumMinersCount` to a low value (e.g., 1)
4. `UpdateMinersCount` triggers `SyncSubsidyInfoAfterReduceMiner`
5. The method attempts to remove 495 candidates (500 - 5) in one transaction
6. Each removal requires a cross-contract call to `ProfitContract.RemoveBeneficiary`: [5](#0-4) 

Each `RemoveBeneficiary` call involves complex state operations including nested loops: [6](#0-5) 

**Why Protections Fail:**
- No maximum iteration limit on the removal loop
- No batching mechanism for processing large candidate lists
- No circuit breaker for excessive gas consumption
- Cross-contract calls compound the gas cost

### Impact Explanation

**Operational Impact - DoS of Governance Function:**
- The `UpdateMinersCount` function becomes unusable when a large reduction is needed
- Emergency governance actions to reduce miner count during security incidents would fail
- The system cannot adapt to changing network conditions requiring miner count adjustments

**Quantified Impact:**
- If `DataCentersRankingList` contains 500 entries and `MinersCount` is reduced to 1:
  - 495 iterations of `OrderBy().Take().ToList()` operation
  - 495 cross-contract calls to `ProfitContract.RemoveBeneficiary`
  - Each `RemoveBeneficiary` may trigger additional nested loops based on `DelayDistributePeriodCount`
  - Total gas consumption could easily exceed block gas limits

**Who is Affected:**
- Network governance requiring rapid miner count adjustments
- Emergency response scenarios needing immediate miner count reduction
- Long-term network evolution requiring scaling down

### Likelihood Explanation

**Attacker Capabilities Required:**
- Parliament governance control to manipulate `MaximumMinersCount` (for malicious scenario)
- OR legitimate governance decisions creating the vulnerable state

**Feasibility:**
- **High** - The vulnerable state can occur through legitimate operations:
  1. Network starts with high miner count to encourage participation
  2. Over time, hundreds of candidates join and accumulate in `DataCentersRankingList`
  3. Network decides to reduce miner count for efficiency/security reasons
  4. DoS occurs during the reduction attempt

**Execution Practicality:**
- Entry point is governance-controlled but the issue affects legitimate use cases
- No special transaction manipulation required
- The vulnerable condition naturally emerges from normal system evolution

**Detection Constraints:**
- The vulnerability may not be discovered until an actual reduction attempt fails
- Testing typically uses small candidate counts (as seen in test with 25 candidates) [7](#0-6) 

**Probability:** MEDIUM-HIGH - While requiring governance action, the scenario is realistic for any long-running network that needs to scale down miner participation.

### Recommendation

**Immediate Mitigation:**
Implement batched removal with a maximum iteration limit per transaction:

```csharp
private void SyncSubsidyInfoAfterReduceMiner()
{
    var rankingList = State.DataCentersRankingList.Value;
    if (rankingList == null) return;
    
    var validDataCenterCount = GetValidationDataCenterCount();
    if (rankingList.DataCenters.Count <= validDataCenterCount) return;
    
    // Add iteration limit
    const int MAX_REMOVALS_PER_TX = 50;
    var diffCount = Math.Min(
        rankingList.DataCenters.Count.Sub(validDataCenterCount),
        MAX_REMOVALS_PER_TX
    );
    
    var toRemoveList = rankingList.DataCenters
        .OrderBy(x => x.Value)
        .Take(diffCount)
        .ToList();
        
    foreach (var kv in toRemoveList)
    {
        rankingList.DataCenters.Remove(kv.Key);
        RemoveBeneficiary(kv.Key);
    }
    
    State.DataCentersRankingList.Value = rankingList;
}
```

**Additional Measures:**
1. Add a state variable tracking pending removals
2. Implement a separate `ContinueSyncSubsidyInfo` method for multi-transaction processing
3. Add pre-validation in `UpdateMinersCount` to warn if the operation will exceed limits
4. Emit events for monitoring progress of large reductions

**Test Cases:**
1. Test with 500+ candidates and reduction to minimal miner count
2. Verify gas consumption stays within block limits
3. Test multi-transaction completion of large reductions
4. Verify all subsidy removals complete correctly across batches

### Proof of Concept

**Initial State:**
1. Deploy contracts with `MaximumMinersCount` = 100
2. 500 candidates announce election (filling `DataCentersRankingList` to capacity)
3. Each candidate receives votes, becoming part of the data center ranking

**Exploit Steps:**
1. Parliament creates proposal to call `AEDPoSContract.SetMaximumMinersCount(1)`
2. Proposal is approved and released
3. `SetMaximumMinersCount` executes: [8](#0-7) 

4. This calls `ElectionContract.UpdateMinersCount` with new count = 1
5. `SyncSubsidyInfoAfterReduceMiner` attempts to remove 495 candidates
6. Transaction runs out of gas or exceeds execution limits

**Expected Result:**
- Miner count successfully updated to 1
- Excess candidates removed from `DataCentersRankingList`
- Subsidy beneficiaries properly cleaned up

**Actual Result:**
- Transaction fails due to gas limit exceeded
- `MinersCount` may be updated but `DataCentersRankingList` cleanup incomplete
- System enters inconsistent state where miner count doesn't match data center list
- Future `UpdateMinersCount` calls continue to fail, permanently blocking miner count adjustments

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L359-377)
```csharp
    private void SyncSubsidyInfoAfterReduceMiner()
    {
        var rankingList = State.DataCentersRankingList.Value;
        if (rankingList == null)
            return;
        var validDataCenterCount = GetValidationDataCenterCount();
        if (rankingList.DataCenters.Count <= validDataCenterCount) return;
        Context.LogDebug(() => "sync DataCenter after reduce bp");
        var diffCount = rankingList.DataCenters.Count.Sub(validDataCenterCount);
        var toRemoveList = rankingList.DataCenters.OrderBy(x => x.Value)
            .Take(diffCount).ToList();
        foreach (var kv in toRemoveList)
        {
            rankingList.DataCenters.Remove(kv.Key);
            RemoveBeneficiary(kv.Key);
        }

        State.DataCentersRankingList.Value = rankingList;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L406-409)
```csharp
    private int GetValidationDataCenterCount()
    {
        return GetMinersCount(new Empty()).Value.Mul(5);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L112-116)
```csharp
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L797-807)
```csharp
    private void RemoveBeneficiary(string candidatePubkey, Address profitsReceiver = null)
    {
        var beneficiaryAddress = GetBeneficiaryAddress(candidatePubkey, profitsReceiver);
        var previousSubsidyId = GenerateSubsidyId(candidatePubkey, beneficiaryAddress);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            Beneficiary = beneficiaryAddress,
            ProfitDetailId = previousSubsidyId
        });
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-263)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);

        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }

        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());

        return new Empty();
    }
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ElectionTests.cs (L1838-1887)
```csharp
    public async Task ElectionContract_UpdateMinerCount_ReduceBp_Test()
    {
        var voter = VoterKeyPairs.First();
        var voteAmount = 100;
        var span = 100;
        var lockTime = 120 * 60 * 60 * 24;
        var fullCount = 5.Mul(5);
        foreach (var keyPair in ValidationDataCenterKeyPairs.Take(fullCount))
        {
            await AnnounceElectionAsync(keyPair);
            await VoteToCandidateAsync(voter, keyPair.PublicKey.ToHex(), lockTime, voteAmount);
            voteAmount = voteAmount.Add(span);
        }

        var minerCount = 3;
        await NextRound(InitialCoreDataCenterKeyPairs[0]);
        var dataCenterList = await ElectionContractStub.GetDataCenterRankingList.CallAsync(new Empty());
        dataCenterList.DataCenters.Count.ShouldBe(fullCount);
        var diffCount = fullCount.Sub(minerCount.Mul(5));
        var subsidy = ProfitItemsIds[ProfitType.BackupSubsidy];
        foreach (var keyPair in ValidationDataCenterKeyPairs.Take(diffCount))
        {
            var profitDetail = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
            {
                SchemeId = subsidy,
                Beneficiary = Address.FromPublicKey(keyPair.PublicKey)
            });
            profitDetail.Details[0].EndPeriod.ShouldNotBe(0);
            profitDetail.Details.Count.ShouldBe(1);
        }

        await ResetMinerCount(minerCount);
        await NextTerm(InitialCoreDataCenterKeyPairs[0]);
        var newMinerCount = await ElectionContractStub.GetMinersCount.CallAsync(new Empty());
        newMinerCount.Value.ShouldBe(minerCount);
        var dataCenterListAfterReduceBp =
            await ElectionContractStub.GetDataCenterRankingList.CallAsync(new Empty());

        dataCenterList.DataCenters.Count.Sub(dataCenterListAfterReduceBp.DataCenters.Count).ShouldBe(diffCount);
        foreach (var keyPair in ValidationDataCenterKeyPairs.Take(diffCount))
        {
            dataCenterListAfterReduceBp.DataCenters.ContainsKey(keyPair.PublicKey.ToHex()).ShouldBeFalse();
            var profitDetail = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
            {
                SchemeId = subsidy,
                Beneficiary = Address.FromPublicKey(keyPair.PublicKey)
            });
            profitDetail.Details[0].EndPeriod.ShouldBe(0);
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```
