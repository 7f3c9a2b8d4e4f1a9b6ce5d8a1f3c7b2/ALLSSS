### Title
NFT Symbol Alias Resolution Bypass in ACS2 Resource Path Declaration Allows Parallel Execution Race Conditions

### Summary
The `GetResourceInfo` method uses raw transaction parameter symbols to declare resource paths, while the actual `TransferFrom` execution resolves NFT aliases to their real symbols before accessing state. This mismatch causes GetResourceInfo to declare incorrect resource paths, allowing transactions that access the same state variables to be incorrectly parallelized, leading to race conditions in balance and allowance updates.

### Finding Description

The vulnerability exists in the interaction between three components:

**1. Resource Path Declaration (GetResourceInfo):**
The ACS2 `GetResourceInfo` implementation uses the raw `args.Symbol` directly from transaction parameters without alias resolution to generate state paths. [1](#0-0) 

For `TransferFrom`, it declares WritePaths using the literal symbol string: `Balances[from][args.Symbol]`, `Balances[to][args.Symbol]`, and calls `AddPathForAllowance` with `args.Symbol`. [2](#0-1) 

The `AddPathForAllowance` method uses `GetSymbolType` to classify the symbol and determine which allowance paths to add. Critically, if the symbol is an alias (e.g., "ABC" mapping to "ABC-1"), `GetSymbolType("ABC")` returns `SymbolType.Token` since it has no '-' separator. [3](#0-2) 

**2. Runtime Symbol Resolution (TransferFrom):**
At execution time, `TransferFrom` resolves aliases before accessing state: [4](#0-3) 

The `AssertValidToken` call invokes `GetTokenInfo`, which resolves aliases via `State.SymbolAliasMap`: [5](#0-4) 

The resolved `tokenInfo.Symbol` is then used in all state access operations, including balance modifications and allowance checks.

**3. NFT Alias System:**
The system allows NFT items to have shorter aliases. For example, NFT "SEED-123" can have alias "SEED": [6](#0-5) 

The alias mapping is stored in `State.SymbolAliasMap`: [7](#0-6) 

**Root Cause:**
GetResourceInfo operates on raw transaction parameters and cannot access state (by ACS2 design - it runs pre-execution for parallel scheduling). Therefore, it cannot resolve aliases. This creates a critical mismatch: declared paths use the alias string, while runtime access uses the resolved actual symbol.

**Why Existing Protections Fail:**
- `GetSymbolType` correctly validates symbol format but cannot detect aliases (they look like regular tokens)
- `AddPathForAllowance` correctly adds paths based on symbol classification, but uses the wrong (aliased) symbol
- The alias resolution in `GetTokenInfo` works correctly, but happens AFTER path declaration
- There is no validation that GetResourceInfo declared paths match actual runtime access

### Impact Explanation

**Concrete Harm:**
1. **Allowance Double-Spending:** Two transactions can consume the same NFT collection allowance in parallel, each seeing the initial balance, leading to over-spending beyond approved amounts.

2. **Balance Corruption:** Parallel transfers involving aliased and real symbols can cause race conditions where balance updates are lost, resulting in incorrect final balances.

3. **ACS2 Contract Violation:** The fundamental ACS2 guarantee that declared resource paths match actual access is broken, undermining the entire parallel execution safety model.

**Affected Parties:**
- NFT holders who set collection-wide allowances for spenders
- Users who hold multiple NFTs from the same collection
- Any contract relying on ACS2 parallel execution correctness

**Severity Justification:**
HIGH severity because:
- Allows theft through allowance bypass (direct fund impact)
- Corrupts critical state (balances, allowances)
- Violates core protocol invariant (ACS2 parallel execution safety)
- Affects all NFTs with aliases (potentially large scope)

### Likelihood Explanation

**Attacker Capabilities Required:**
- Create an NFT collection (requires SEED NFT or whitelist)
- Set aliases for NFT items (requires ownership)
- Submit multiple transactions simultaneously

**Attack Complexity:**
MEDIUM - Requires understanding of alias system and parallel execution timing, but no special privileges beyond NFT ownership.

**Feasibility Conditions:**
1. Victim must have approved collection-wide allowance OR hold balance of multiple NFTs from same collection
2. Alias must be set for at least one NFT in the collection
3. Attacker must submit transactions during the same block grouping window

**Execution Practicality:**
- All steps use standard public methods (SetSymbolAlias, TransferFrom)
- No trusted role compromise needed
- Timing requirements are achievable (submit multiple transactions to mempool)
- Economic cost is reasonable (normal transaction fees)

**Detection Constraints:**
Difficult to detect because:
- Looks like normal TransferFrom usage
- No revert or obvious error
- State corruption manifests as subtle balance discrepancies
- Post-execution validation may not catch the path mismatch

**Probability:** HIGH - The alias feature is intended for use, making this a practical attack vector whenever aliases exist.

### Recommendation

**Immediate Fix:**
Modify `GetResourceInfo` to resolve aliases before path generation:

1. In `TokenContract_ACS2_StatePathsProvider.cs`, add alias resolution before using symbol:
   - For Transfer: resolve `args.Symbol` 
   - For TransferFrom: resolve `args.Symbol` and `args.From` symbol references
   - Use resolved symbol in all `GetPath` calls and `AddPathForAllowance`

2. Create a helper method that resolves aliases using only transaction-available data:
   ```
   private string ResolveSymbolForResourcePath(string symbolOrAlias)
   {
       // Check if this looks like an alias (no separator, not a known token format)
       // Return resolved symbol or original if not an alias
       // Must work without state access - may need to add metadata to transaction
   }
   ```

**Alternative Solution:**
If alias resolution in GetResourceInfo is not feasible (due to ACS2 state-less constraint):

1. Disable aliases entirely, OR
2. Modify TransferFrom to reject alias usage - require actual symbols only
3. Add transaction parameter validation that rejects aliases at parsing stage

**Invariant Checks to Add:**
- Assert that GetResourceInfo declared paths match actual paths accessed during execution
- Add post-execution validation that flags path mismatches
- Test that parallel execution with aliases is properly detected as conflicting

**Test Cases:**
1. Create NFT collection with multiple items
2. Set alias for one item
3. Set collection-wide allowance
4. Submit parallel TransferFrom: one using alias, one using real symbol from same collection
5. Verify: transactions are detected as conflicting and NOT parallelized
6. Verify: allowance correctly decrements only once per transfer
7. Verify: no balance corruption occurs

### Proof of Concept

**Initial State Setup:**
1. Create NFT collection "TEST-0"
2. Mint NFT items "TEST-1" and "TEST-2" to victim address
3. Set alias "TST" for "TEST-1" via SetSymbolAlias
4. Victim approves spender with collection allowance: `Approve(spender, "TEST-*", 100)`
5. Initial state: `Allowances[victim][spender]["TEST-*"] = 100`

**Attack Transaction Sequence:**
Submit simultaneously (same block):
- T1: `TransferFrom(from=victim, to=attacker1, symbol="TST", amount=60)` [uses alias]
- T2: `TransferFrom(from=victim, to=attacker2, symbol="TEST-2", amount=60)` [uses real symbol]

**GetResourceInfo Analysis:**
- T1 declares WritePaths: 
  - `Balances[victim]["TST"]` 
  - `Balances[attacker1]["TST"]`
  - `Allowances[victim][spender]["TST"]`
  - `Allowances[victim][spender]["*"]`
  - (No "TEST-*" because "TST" classified as Token)

- T2 declares WritePaths:
  - `Balances[victim]["TEST-2"]`
  - `Balances[attacker2]["TEST-2"]`  
  - `Allowances[victim][spender]["TEST-2"]`
  - `Allowances[victim][spender]["*"]`
  - `Allowances[victim][spender]["TEST-*"]`

- Overlapping paths: Only `Allowances[victim][spender]["*"]`
- Non-overlapping critical path: `Allowances[victim][spender]["TEST-*"]` missing from T1

**Runtime Execution (Parallel):**
- T1 resolves "TST" â†’ "TEST-1"
- Both T1 and T2 read `Allowances[victim][spender]["TEST-*"] = 100`
- T1 consumes 60, writes back 40
- T2 consumes 60, writes back 40 (race condition)
- Final state: `Allowances[victim][spender]["TEST-*"] = 40` (should be -20, transfer should fail)

**Success Condition:**
Both transfers succeed with 60 tokens each (120 total) despite only 100 collection allowance approved, demonstrating the allowance double-spend vulnerability.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L40-64)
```csharp
            case nameof(TransferFrom):
            {
                var args = TransferFromInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), args.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.LockWhiteLists), args.Symbol, txn.From.ToString())
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };
                AddPathForAllowance(resourceInfo, args.From.ToString(), txn.From.ToString(), args.Symbol);
                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L71-82)
```csharp
    private void AddPathForAllowance(ResourceInfo resourceInfo, string from, string spender, string symbol)
    {
        resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender, symbol));
        resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender,
            GetAllSymbolIdentifier()));
        var symbolType = GetSymbolType(symbol);
        if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
        {
            resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender,
                GetNftCollectionAllSymbolIdentifier(symbol)));
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L254-259)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransferFrom(input.From, input.To, Context.Sender, tokenInfo.Symbol, input.Amount, input.Memo);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L738-779)
```csharp
    public override Empty SetSymbolAlias(SetSymbolAliasInput input)
    {
        // Alias setting can only work for NFT Item for now.
        // And the setting exists on the TokenInfo of the NFT Collection.

        // Can only happen on Main Chain.
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "Symbol alias setting only works on MainChain.");

        var collectionSymbol = GetNftCollectionSymbol(input.Symbol, true);

        // For now, token alias can only be set once.
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");

        CheckTokenAlias(input.Alias, collectionSymbol);

        var collectionTokenInfo = GetTokenInfo(collectionSymbol);
        if (collectionTokenInfo == null)
        {
            throw new AssertionException($"NFT Collection {collectionSymbol} not found.");
        }

        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");

        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);

        State.SymbolAliasMap[input.Alias] = input.Symbol;

        Context.LogDebug(() => $"Token alias added: {input.Symbol} -> {input.Alias}");

        Context.Fire(new SymbolAliasAdded
        {
            Symbol = input.Symbol,
            Alias = input.Alias
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L286-294)
```csharp
    private string GetActualTokenSymbol(string aliasOrSymbol)
    {
        if (State.TokenInfos[aliasOrSymbol] == null)
        {
            return State.SymbolAliasMap[aliasOrSymbol] ?? aliasOrSymbol;
        }

        return aliasOrSymbol;
    }
```
