### Title
In-Flight Proposal Approval Invalidation via Member Removal Causes Governance Denial of Service

### Summary
The Association contract's `RemoveMember` function immediately decrements the organization member count, and the `Release` function dynamically recalculates approval counts by filtering through the current member list. This allows approved proposals to become unreleasable if members who voted for them are later removed, even though the proposals had previously met the `MinimalApprovalThreshold` requirement.

### Finding Description

The vulnerability exists in the interaction between member removal and proposal release validation: [1](#0-0) 

When `Count()` is called, it returns the current size of the member list immediately. [2](#0-1) 

The `RemoveMember` function immediately removes a member from `organization.OrganizationMemberList.OrganizationMembers` and updates the state. The validation only ensures the organization itself remains valid (thresholds don't exceed new member count), but does not check for impact on existing proposals. [3](#0-2) 

When `Release` is called, it retrieves the current organization state (with potentially reduced membership) and validates approval thresholds. [4](#0-3) 

The critical flaw is in `CheckEnoughVoteAndApprovals`: it counts approvals by filtering `proposal.Approvals` through `organization.OrganizationMemberList.Contains`. If a member who approved is no longer in the organization, their approval is not counted, even though they were a valid member when they approved. [5](#0-4) 

Proposals store only the `organization_address` reference and a list of approver addresses, not a snapshot of the member list at proposal creation time. This means approval validation always uses the current member list state.

### Impact Explanation

**Concrete Harm:**
- **Governance Denial of Service**: Critical proposals that have already met approval thresholds become permanently unreleasable if enough approving members are subsequently removed
- **Configuration Lock**: Organizations cannot execute time-sensitive governance actions (threshold changes, emergency responses, contract upgrades) if approving members are removed before release
- **Operational Deadlock**: An organization could become unable to execute any proposals if coordinated member removal targets all approvers systematically

**Affected Parties:**
- All Association-based multi-signature organizations
- Proposals awaiting release that depend on members who might be removed
- Governance systems relying on Association contracts for critical operations

**Severity Justification:**
This is a HIGH severity issue because it breaks a core governance invariant: a proposal that achieved required approvals should remain executable. The attack requires no special privileges beyond normal organization operation and can render governance inoperable.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires ability to create and pass proposals for member removal
- This is a normal organization capability, not a privileged action
- Any organization member in the proposer whitelist can initiate RemoveMember proposals

**Attack Complexity:**
LOW - The attack sequence is straightforward:
1. Wait for a proposal to accumulate approvals
2. Create RemoveMember proposal(s) targeting members who approved
3. Get those removal proposals approved and released
4. Original proposal now fails MinimalApprovalThreshold check

**Feasibility Conditions:**
- Organizations with member churn (adding/removing members is normal operation)
- Long-lived proposals (higher exposure window)
- Organizations with MinimalApprovalThreshold close to total member count
- No technical barriers prevent this scenario

**Detection/Operational Constraints:**
- Member removal is legitimate governance activity, difficult to distinguish malicious from benign
- No warnings or checks alert users that active proposals will be affected
- The issue manifests only when attempting to release the affected proposal

**Probability Assessment:**
MEDIUM-HIGH - This can occur through both malicious intent and accidental operational mistakes. Organizations frequently adjust membership, and there are no safeguards preventing removal of members with outstanding votes on active proposals.

### Recommendation

**Code-Level Mitigation:**

1. **Add Active Proposal Check to RemoveMember:**
   Before allowing member removal in `RemoveMember` (Association.cs line 266-280), check if the member has voted on any active (non-expired, non-released) proposals. Either:
   - Prevent removal if member has active votes, or
   - Automatically maintain approval validity by snapshotting member list per proposal

2. **Snapshot Member List at Proposal Creation:**
   Modify `ProposalInfo` structure to store a snapshot of `OrganizationMemberList` at creation time, and validate against this snapshot instead of current organization state:
   ```
   message ProposalInfo {
       ...
       OrganizationMemberList member_list_snapshot = 14;
   }
   ```
   Update `CheckEnoughVoteAndApprovals` to use `proposal.MemberListSnapshot.Contains` instead of `organization.OrganizationMemberList.Contains`.

3. **Add Invariant Check:**
   In the `Validate` method called by `RemoveMember`, add:
   ```csharp
   // Check no active proposals would be invalidated
   var activeProposals = GetActiveProposalsByOrganization(Context.Sender);
   foreach (var proposal in activeProposals)
   {
       var wouldBeValid = ValidateProposalWithRemovedMember(proposal, memberToRemove);
       Assert(wouldBeValid, "Cannot remove member with votes on active proposals");
   }
   ```

**Test Cases:**
- Create proposal, get approvals meeting threshold, remove approving member, attempt release (should handle gracefully)
- Verify member removal blocked if they have votes on active proposals
- Test proposal release uses snapshot member list, not current member list

### Proof of Concept

**Initial State:**
- Organization with 5 members: [Member1, Member2, Member3, Member4, Member5]
- ProposalReleaseThreshold.MinimalApprovalThreshold = 3
- ProposalReleaseThreshold.MinimalVoteThreshold = 3

**Attack Sequence:**

1. **Member1 creates Proposal A** (e.g., to change organization configuration)
   - ProposalA.OrganizationAddress = OrganizationX
   - ProposalA.Approvals = []

2. **Members 1, 2, and 3 approve Proposal A**
   - ProposalA.Approvals = [Member1, Member2, Member3]
   - Current approval count: 3 (meets MinimalApprovalThreshold of 3) âœ“

3. **Member4 creates Proposal B to remove Member1**
   - ProposalB calls RemoveMember(Member1)

4. **Members 2, 3, 4 approve and Member2 releases Proposal B**
   - RemoveMember executes successfully
   - Organization.OrganizationMemberList.OrganizationMembers = [Member2, Member3, Member4, Member5]
   - Organization.OrganizationMemberList.Count() now returns 4

5. **Member1 attempts to release Proposal A**
   - Release calls IsReleaseThresholdReached(ProposalA, Organization)
   - CheckEnoughVoteAndApprovals calculates:
     - approvedMemberCount = ProposalA.Approvals.Count(Organization.OrganizationMemberList.Contains)
     - = [Member1, Member2, Member3].Count(IsIn[Member2, Member3, Member4, Member5])
     - = 2 (only Member2 and Member3 count; Member1 not in current member list)
   - isApprovalEnough = (2 >= 3) = false
   - Assert fails with "Not approved."

**Expected vs Actual Result:**
- **Expected**: Proposal A should be releasable since it met approval requirements when voted
- **Actual**: Proposal A fails release with "Not approved" assertion, despite having had sufficient approvals

**Success Condition:**
The attack succeeds if Proposal A, which previously met MinimalApprovalThreshold, becomes unreleasable after member removal, demonstrating governance denial of service.

### Citations

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L7-10)
```csharp
    public int Count()
    {
        return organizationMembers_.Count;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** protobuf/association_contract.proto (L87-92)
```text
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
```
