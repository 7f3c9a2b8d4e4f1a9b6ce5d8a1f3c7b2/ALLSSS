### Title
Missing Consensus Behaviour Validation Allows Miners to Force Incorrect Round Transitions

### Summary
The `GetConsensusBlockExtraData()` function accepts a miner-provided `AElfConsensusBehaviour` value directly from `triggerInformation` without validating it matches the correct behaviour for the current consensus state. This allows malicious miners to force premature round transitions (NextRound instead of UpdateValue), incorrect term changes (NextTerm instead of NextRound), or bypass consensus participation, disrupting the consensus mechanism integrity.

### Finding Description

The vulnerability exists in the consensus behaviour determination and validation flow: [1](#0-0) 

The `GetConsensusBlockExtraData()` function receives `triggerInformation.Behaviour` from the caller and directly uses it in a switch statement to determine which consensus logic to execute, without validating this behaviour is correct for the current state.

The correct behaviour should be determined by `ConsensusBehaviourProviderBase.GetConsensusBehaviour()`: [2](#0-1) 

This method calculates the expected behaviour based on round state, miner status, time slots, and other consensus parameters. However, when `GetConsensusExtraData()` is called: [3](#0-2) 

It passes the miner-provided input directly to `GetConsensusBlockExtraData()` without comparing the provided behaviour against what `GetConsensusBehaviour()` would return.

The validation in `ValidateBeforeExecution()` only checks behaviour-specific data validity: [4](#0-3) 

For NextRound/NextTerm, `RoundTerminateValidationProvider` validates the round/term data structure: [5](#0-4) 

But it never validates WHETHER a round termination should occur at this point - only that IF it occurs, the data is structurally correct (round number increments, InValues are null).

The validation providers check mining permission, time slots, and continuous blocks, but none recalculate the expected behaviour to compare against the provided one.

### Impact Explanation

A malicious miner can manipulate consensus state transitions, causing:

1. **Premature Round Transitions**: Force NextRound when UpdateValue should occur, skipping normal consensus participation by other miners and disrupting the round schedule.

2. **Incorrect Term Changes**: On main chains, force NextTerm instead of NextRound, causing unintended miner list changes, election snapshot timing issues, and treasury/reward distribution disruptions.

3. **Consensus Participation Bypass**: Use TinyBlock when UpdateValue is required, or UpdateValue when NextRound is needed, preventing proper round termination and consensus progression.

4. **LIB Calculation Disruption**: Incorrect round transitions affect Last Irreversible Block height calculations, potentially impacting cross-chain operations and finality guarantees.

5. **Economic Impact**: Incorrect term transitions trigger premature mining reward distributions, treasury releases, and election snapshots, affecting the entire economic model.

The impact is protocol-wide as consensus integrity is fundamental to all blockchain operations including token transfers, contract execution, and cross-chain communication.

### Likelihood Explanation

**Attacker Capabilities**: Any miner in the current miner list can execute this attack. Miners are expected participants with block production rights.

**Attack Complexity**: Low. The attacker only needs to:
1. Call `GetConsensusCommand()` to see the expected behaviour
2. Construct `AElfConsensusTriggerInformation` with a different behaviour
3. Generate structurally valid data for that behaviour (e.g., increment round number, null InValues for NextRound)
4. Submit the block with this manipulated consensus information

**Feasibility Conditions**: 
- Attacker must be a current miner (achievable through election or already being in miner set)
- No special permissions beyond normal mining rights required
- Attack is repeatable and can be executed at any time during the attacker's time slot

**Detection Constraints**: The attack may not be immediately obvious as the data passes all structural validations. Detection requires comparing expected vs actual behaviour off-chain.

**Probability**: MEDIUM-HIGH. While it requires a compromised miner, the attack is straightforward once miner status is obtained, and the economic incentive exists if the attacker benefits from disrupting consensus or manipulating term/round timing.

### Recommendation

Add behaviour validation in `ValidateBeforeExecution()` to verify the provided behaviour matches the expected behaviour:

```csharp
private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
{
    // ... existing code ...
    
    // Add behaviour validation
    var expectedBehaviour = IsMainChain
        ? new MainChainConsensusBehaviourProvider(baseRound, extraData.SenderPubkey.ToHex(),
                GetMaximumBlocksCount(), Context.CurrentBlockTime, 
                GetBlockchainStartTimestamp(), State.PeriodSeconds.Value)
            .GetConsensusBehaviour()
        : new SideChainConsensusBehaviourProvider(baseRound, extraData.SenderPubkey.ToHex(),
                GetMaximumBlocksCount(), Context.CurrentBlockTime)
            .GetConsensusBehaviour();
    
    if (extraData.Behaviour != expectedBehaviour)
        return new ValidationResult { 
            Success = false, 
            Message = $"Incorrect consensus behaviour. Expected: {expectedBehaviour}, Provided: {extraData.Behaviour}" 
        };
    
    // ... rest of existing validation ...
}
```

This ensures the miner-provided behaviour matches what the consensus rules dictate for the current state, preventing arbitrary behaviour manipulation.

**Additional Test Cases**:
- Test that UpdateValue cannot be replaced with NextRound during normal time slot
- Test that NextRound cannot be replaced with NextTerm on side chains
- Test that TinyBlock cannot be used when UpdateValue is required
- Test that miners cannot force round transitions outside their designated termination slot

### Proof of Concept

**Initial State**:
- Current round number: 5
- Current term: 1
- Miner A is in the miner list with order 3
- Miner A has OutValue = null (hasn't mined this round)
- Current time is within Miner A's time slot
- Expected behaviour: UpdateValue

**Attack Steps**:

1. Miner A calls `GetConsensusCommand()` with their public key
   - Result: ConsensusCommand with hint containing behaviour = UpdateValue

2. Miner A maliciously constructs `AElfConsensusTriggerInformation`:
   - Sets `behaviour = NextRound` (instead of UpdateValue)
   - Generates next round data with round_number = 6
   - Sets all miners' InValue = null in next round
   - Provides valid cryptographic values (signature, random number)

3. Miner A generates block with this consensus extra data

4. Other nodes validate via `ValidateConsensusBeforeExecution()`:
   - `MiningPermissionValidationProvider`: PASS (Miner A is in list)
   - `TimeSlotValidationProvider`: PASS (within time slot)
   - `ContinuousBlocksValidationProvider`: PASS (not too many blocks)
   - `RoundTerminateValidationProvider`: PASS (round_number = 5 + 1 = 6, InValues null)
   - **Missing check**: Is NextRound the correct behaviour? NOT VALIDATED

5. Block is accepted, round transitions to 6 prematurely

**Expected Result**: Block rejected with "Expected UpdateValue, got NextRound"

**Actual Result**: Block accepted, round transitions incorrectly, other miners' consensus participation in round 5 is bypassed

**Success Condition**: Current round number changes from 5 to 6 without proper consensus completion, demonstrating the miner successfully forced an incorrect round transition.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L13-53)
```csharp
    private BytesValue GetConsensusBlockExtraData(BytesValue input, bool isGeneratingTransactions = false)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);

        Assert(triggerInformation.Pubkey.Any(), "Invalid pubkey.");

        TryToGetCurrentRoundInformation(out var currentRound);

        var publicKeyBytes = triggerInformation.Pubkey;
        var pubkey = publicKeyBytes.ToHex();

        var information = new AElfConsensusHeaderInformation();
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
        }

        if (!isGeneratingTransactions) information.Round.DeleteSecretSharingInformation();

        return information.ToBytesValue();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-59)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```
