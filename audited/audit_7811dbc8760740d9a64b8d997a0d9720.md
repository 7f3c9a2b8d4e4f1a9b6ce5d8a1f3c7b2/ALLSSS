# Audit Report

## Title
Treasury Accepts Unfavorable Prices Due to Missing Slippage Protection on Token Conversion

## Summary
The Treasury contract converts donated non-native tokens to native tokens without implementing slippage protection. When `ConvertToNativeToken` calls `TokenConverterContract.Sell`, it omits the `ReceiveLimit` parameter, which defaults to 0 and bypasses the price validation check. This allows the Treasury to accept arbitrarily unfavorable exchange rates, resulting in direct financial losses on every convertible token donation.

## Finding Description
The vulnerability exists in the token conversion flow when non-native tokens are donated to the Treasury. The `Donate` method determines if a donated token can be converted to the native token and triggers the conversion. [1](#0-0) 

The `ConvertToNativeToken` private method performs the actual conversion by calling the TokenConverter's `Sell` method, but only passes the `Symbol` and `Amount` parameters, completely omitting the `ReceiveLimit` parameter: [2](#0-1) 

The `ReceiveLimit` parameter in the `SellInput` message is specifically designed to provide slippage protection. According to the protocol definition, it represents the minimum amount of base tokens that must be received, and "0 is no limit": [3](#0-2) 

In the TokenConverter's `Sell` method implementation, the price validation check uses an OR condition that bypasses validation when `ReceiveLimit` equals 0: [4](#0-3) 

Since the first condition `input.ReceiveLimit == 0` evaluates to true when no limit is set, the entire assertion passes regardless of the actual exchange rate received. This means the Treasury will accept any price the Bancor formula calculates, no matter how unfavorable.

The Bancor pricing formula is deterministic and directly depends on connector balances, making it predictable and manipulable through trades: [5](#0-4) 

## Impact Explanation
This vulnerability results in direct financial loss to the Treasury, which is a critical protocol component holding significant value for distribution to miners, voters, and other stakeholders.

**Direct Financial Loss**: On every donation of convertible non-native tokens, the Treasury accepts whatever exchange rate exists at the moment of execution, with zero protection against:
- Deliberately manipulated prices (attacker front-runs with trades to worsen the rate)
- Normal market volatility (price moves unfavorably between donation initiation and execution)
- Large donation slippage (no minimum received amount means accepting poor rates on large conversions)

**Cumulative Impact**: Since the `Donate` method is public and can be called by anyone, this affects every single convertible token donation. [6](#0-5) 

The losses compound over time, directly reducing:
- Mining rewards available for distribution
- Subsidy pools for candidates
- Welfare rewards for citizens/voters
- Overall protocol economic sustainability

**Attack Scenarios**:
1. **Direct manipulation**: Attacker manipulates Bancor pool prices, then triggers donation themselves
2. **Opportunistic timing**: Attacker observes donation patterns and manipulates prices accordingly
3. **Passive losses**: Even without malicious actors, normal volatility causes Treasury to receive suboptimal rates

## Likelihood Explanation
**High Likelihood** - The vulnerability is easily exploitable because:

1. **Public Entry Point**: The `Donate` method has no access controls - anyone can trigger token donations and conversions. [7](#0-6) 

2. **Deterministic Price Calculation**: The Bancor formula is deterministic and publicly calculable. Anyone can predict the exact impact of trades on conversion rates by reading connector balances on-chain.

3. **No Price Protection**: The complete absence of slippage protection means the Treasury accepts ANY rate, making it vulnerable to both:
   - Malicious price manipulation (attacker trades before/during donations)
   - Normal market conditions (volatility during high-activity periods)

4. **Repeatable Exploitation**: The attack can be executed on every donation transaction, making this a persistent drain on Treasury resources rather than a one-time exploit.

5. **Low Attack Barriers**: 
   - No privileged access required
   - Anyone can trade on TokenConverter to influence prices
   - Simple timing or direct donation triggering enables exploitation

## Recommendation
Implement slippage protection by passing a `ReceiveLimit` parameter when calling `TokenConverterContract.Sell`. The Treasury should calculate an acceptable minimum based on current market rates with a reasonable slippage tolerance (e.g., 1-5%).

**Recommended fix**:
```csharp
private void ConvertToNativeToken(string symbol, long amount)
{
    State.TokenContract.Approve.Send(new ApproveInput
    {
        Spender = State.TokenConverterContract.Value,
        Symbol = symbol,
        Amount = amount
    });

    // Calculate expected return and apply slippage tolerance
    var pairConnector = State.TokenConverterContract.GetPairConnector.Call(new TokenSymbol { Symbol = symbol });
    var expectedReturn = CalculateExpectedReturn(pairConnector, amount);
    var minAcceptableReturn = expectedReturn * 95 / 100; // 5% slippage tolerance

    State.TokenConverterContract.Sell.Send(new SellInput
    {
        Symbol = symbol,
        Amount = amount,
        ReceiveLimit = minAcceptableReturn  // ADD THIS PARAMETER
    });

    Context.SendInline(Context.Self, nameof(DonateAll), new DonateAllInput
    {
        Symbol = Context.Variables.NativeSymbol
    });
}
```

Additionally, consider:
- Making the slippage tolerance configurable via governance
- Emitting events when conversions occur with rate information for transparency
- Implementing minimum/maximum donation amounts to prevent dust attacks or excessive single conversions

## Proof of Concept
```csharp
// POC Test - demonstrates Treasury accepts any price without ReceiveLimit

[Fact]
public async Task Treasury_AcceptsUnfavorablePrice_WhenNoReceiveLimitSet()
{
    // Setup: Deploy contracts and initialize token converter with RESOURCE token
    await InitializeContracts();
    await SetupResourceTokenConnector();
    
    // Attacker manipulates pool: Buy large amount of RESOURCE to deplete connector
    await AttackerBuysResourceTokens(largeAmount: 1000000);
    
    // Victim donates RESOURCE tokens to Treasury
    // Treasury will convert at the now-unfavorable rate with no protection
    var donationAmount = 10000;
    var donateResult = await TreasuryContract.Donate.SendAsync(new DonateInput
    {
        Symbol = "RESOURCE",
        Amount = donationAmount
    });
    
    // Verify: Treasury received significantly less ELF than fair market rate
    // due to manipulated pool, but transaction succeeded (no revert)
    Assert.True(donateResult.TransactionResult.Status == TransactionResultStatus.Mined);
    
    var treasuryBalance = await GetTreasuryNativeBalance();
    var fairMarketValue = CalculateFairPrice(donationAmount);
    var actualReceived = treasuryBalance;
    
    // Demonstrates Treasury accepted unfavorable price (e.g., 50% loss)
    Assert.True(actualReceived < fairMarketValue * 50 / 100);
}
```

## Notes
While the claim mentions "front-running" in the traditional MEV sense, the vulnerability is valid regardless of transaction ordering mechanisms. The core issue is the **complete absence of slippage protection**, which exposes the Treasury to:

1. **Price manipulation through normal trading** - Attackers don't need mempool visibility; they can manipulate prices through standard TokenConverter trades and then trigger or time donations
2. **Normal market volatility** - Even without malicious actors, market price movements between donation initiation and execution cause Treasury to receive unfavorable rates
3. **Deterministic exploitation** - The Bancor formula is public and calculable, allowing precise price impact predictions

The Treasury being exempt from conversion fees [8](#0-7)  does not mitigate this vulnerability - it only means Treasury doesn't pay the fee percentage, but still suffers from price manipulation or volatility with no minimum price protection.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L174-251)
```csharp
    public override Empty Donate(DonateInput input)
    {
        Assert(input.Amount > 0, "Invalid amount of donating. Amount needs to be greater than 0.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        if (!State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = input.Symbol }).Value)
            return new Empty();

        if (State.TokenConverterContract.Value == null)
            State.TokenConverterContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName);

        var isNativeSymbol = input.Symbol == Context.Variables.NativeSymbol;
        var canExchangeWithNativeSymbol =
            isNativeSymbol ||
            State.TokenConverterContract.IsSymbolAbleToSell
                .Call(new StringValue { Value = input.Symbol }).Value;

        if (Context.Sender != Context.Self)
            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = Context.Self,
                Symbol = input.Symbol,
                Amount = input.Amount,
                Memo = "Donate to treasury."
            });

        var needToConvert = !isNativeSymbol && canExchangeWithNativeSymbol;
        if (needToConvert)
        {
            ConvertToNativeToken(input.Symbol, input.Amount);
        }
        else
        {
            State.TokenContract.Approve.Send(new ApproveInput
            {
                Symbol = input.Symbol,
                Amount = input.Amount,
                Spender = State.ProfitContract.Value
            });

            State.ProfitContract.ContributeProfits.Send(new ContributeProfitsInput
            {
                SchemeId = State.TreasuryHash.Value,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            var donatesOfCurrentBlock = State.DonatedDividends[Context.CurrentHeight];
            if (donatesOfCurrentBlock != null && Context.Variables.NativeSymbol == input.Symbol &&
                donatesOfCurrentBlock.Value.ContainsKey(Context.Variables.NativeSymbol))
                donatesOfCurrentBlock.Value[Context.Variables.NativeSymbol] = donatesOfCurrentBlock
                    .Value[Context.Variables.NativeSymbol].Add(input.Amount);
            else
                donatesOfCurrentBlock = new Dividends
                {
                    Value =
                    {
                        { input.Symbol, input.Amount }
                    }
                };

            State.DonatedDividends[Context.CurrentHeight] = donatesOfCurrentBlock;

            Context.Fire(new DonationReceived
            {
                From = Context.Sender,
                Symbol = input.Symbol,
                Amount = input.Amount,
                PoolContract = Context.Self
            });
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L676-680)
```csharp
        State.TokenConverterContract.Sell.Send(new SellInput
        {
            Symbol = symbol,
            Amount = amount
        });
```

**File:** protobuf/token_converter_contract.proto (L140-142)
```text
    // Limits on tokens obtained by selling. If the token obtained is less than this value, the sale will be abandoned.
    // And 0 is no limit.
    int64 receive_limit = 3;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L176-177)
```csharp
        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L180-180)
```csharp
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```
