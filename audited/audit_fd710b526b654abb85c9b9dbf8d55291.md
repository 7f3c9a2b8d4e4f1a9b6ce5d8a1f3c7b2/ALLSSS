### Title
Missing Validation Allows Future Irreversible Block Height in NextRound Consensus Transitions

### Summary
The `NextRoundInput.Create()` method copies `ConfirmedIrreversibleBlockHeight` from round data without validating that it does not exceed the current block height. This allows a malicious miner to inject a future LIB height during NextRound transitions, violating the critical invariant that the Last Irreversible Block must never be ahead of the current blockchain tip, potentially causing consensus disruption and integer underflows.

### Finding Description

The vulnerability exists in the NextRound consensus flow where the `ConfirmedIrreversibleBlockHeight` (LIB) is propagated without bounds validation.

**Root Cause:**

The `NextRoundInput.Create()` method directly copies `ConfirmedIrreversibleBlockHeight` from the provided round parameter without any validation: [1](#0-0) 

When generating the next round information, the LIB height is simply copied from the current round without validation: [2](#0-1) 

**Why Protections Fail:**

1. The `ProcessNextRound()` method receives the `NextRoundInput` and stores it via `AddRoundInformation()` without validating the LIB height against the current block height: [3](#0-2) 

2. The validation providers for NextRound behavior (`NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider`) are configured in the validation flow: [4](#0-3) 

3. However, `RoundTerminateValidationProvider` only validates round number increment and InValue nullness, NOT LIB bounds: [5](#0-4) 

4. The `LibInformationValidationProvider` that performs LIB validation is ONLY applied to UpdateValue behavior, not NextRound: [6](#0-5) 

5. Even `LibInformationValidationProvider` only checks that LIB doesn't go DOWN, not that it stays within the current block height bounds: [7](#0-6) 

**Execution Path:**

The NextRound transaction is generated from consensus extra data: [8](#0-7) 

### Impact Explanation

**Consensus Integrity Violation:**

The system now violates the fundamental invariant that the Last Irreversible Block cannot be ahead of the current blockchain tip. This breaks the core consensus guarantee that "irreversible" blocks actually exist.

**Integer Underflow in Critical Path:**

The `GetMaximumBlocksCount()` method calculates the distance to LIB height, which will underflow when LIB is in the future: [9](#0-8) 

At line 63, `currentHeight.Sub(libBlockHeight)` will produce incorrect results when `libBlockHeight > currentHeight`, potentially triggering incorrect "Severe" consensus status and disrupting block production.

**Cross-Chain Impact:**

If LIB is used as an anchor point for cross-chain verification (common in blockchain systems), a future LIB could allow verification of blocks that don't exist yet, enabling potential cross-chain attacks.

**Severity:** CRITICAL - Violates core consensus invariant, can disrupt consensus operation, and potentially enables cross-chain attacks.

### Likelihood Explanation

**Attacker Capabilities:**

The attacker must be an active miner in the current miner list with the ability to produce blocks. This is a privileged but realistic role in a DPoS consensus system.

**Attack Complexity:**

The attack is straightforward:
1. When producing a NextRound block, the miner modifies the consensus extra data to set `nextRound.ConfirmedIrreversibleBlockHeight` to any value higher than the current block height
2. The validation passes because no validator checks this constraint
3. The invalid LIB is stored and persists across subsequent rounds

**Feasibility:**

The attack is highly feasible because:
- No cryptographic barriers prevent modifying consensus extra data
- The validation gap is absolute - there is no check at all
- Once injected, the invalid LIB propagates to future rounds
- Detection may be delayed as the system continues operating

**Economic Rationality:**

A malicious miner could disrupt consensus with minimal cost beyond normal block production. The attack could be used to:
- Trigger consensus instability during critical periods
- Manipulate cross-chain verification if applicable
- Create confusion about blockchain state finality

**Probability:** HIGH - Clear validation gap with realistic attacker capabilities and straightforward execution.

### Recommendation

**Immediate Fix:**

Add LIB bounds validation in the NextRound flow. In `AEDPoSContract_Validation.cs`, add `LibInformationValidationProvider` to NextRound behavior validation:

```csharp
case AElfConsensusBehaviour.NextRound:
    // Is sender's order of next round correct?
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    // ADD THIS LINE:
    validationProviders.Add(new LibInformationValidationProvider());
    break;
```

**Enhanced Validation:**

Strengthen `LibInformationValidationProvider` to validate against current block height:

```csharp
// In LibInformationValidationProvider.ValidateHeaderInformation()
// Add after line 21:
if (providedRound.ConfirmedIrreversibleBlockHeight > validationContext.CurrentHeight)
{
    validationResult.Message = "LIB height cannot exceed current block height.";
    return validationResult;
}
```

**Additional Safeguard:**

Add defensive check in `ProcessNextRound()` before storing:

```csharp
// In ProcessNextRound(), before line 156:
Assert(nextRound.ConfirmedIrreversibleBlockHeight <= Context.CurrentHeight,
    "Confirmed irreversible block height cannot exceed current height.");
```

**Test Cases:**

1. Test NextRound with `ConfirmedIrreversibleBlockHeight = CurrentHeight + 1` - should reject
2. Test NextRound with `ConfirmedIrreversibleBlockHeight = CurrentHeight` - should accept
3. Test that LIB validation applies to both UpdateValue and NextRound behaviors
4. Test that `GetMaximumBlocksCount()` handles edge cases safely

### Proof of Concept

**Initial State:**
- Current block height: 1000
- Current round number: 10
- Current `ConfirmedIrreversibleBlockHeight`: 900 (valid)
- Attacker is active miner in miner list

**Attack Steps:**

1. Attacker's turn to produce NextRound block at height 1001
2. Attacker calls `GetConsensusExtraData` to generate consensus header information
3. **Attack:** Before including in block, attacker modifies the consensus extra data:
   - Set `nextRound.ConfirmedIrreversibleBlockHeight = 2000` (future height, 999 blocks ahead)
4. Attacker includes modified consensus data in block header
5. Block validation executes:
   - `ValidateConsensusBeforeExecution` runs with validators for NextRound
   - `NextRoundMiningOrderValidationProvider` - PASS (only checks mining order)
   - `RoundTerminateValidationProvider` - PASS (only checks round number increment)
   - NO validator checks `ConfirmedIrreversibleBlockHeight <= 1001`
6. `NextRound` transaction executes via `ProcessNextRound`
7. `AddRoundInformation` stores the round with `ConfirmedIrreversibleBlockHeight = 2000`

**Expected Result:**
Transaction should be rejected due to invalid LIB height

**Actual Result:**
Transaction succeeds, system now has `ConfirmedIrreversibleBlockHeight = 2000` when current height is 1001, violating the invariant

**Success Condition:**
Query round state after block execution shows `ConfirmedIrreversibleBlockHeight > CurrentHeight`, confirming invariant violation

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L164-171)
```csharp
            case AElfConsensusBehaviour.NextRound:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextRound), NextRoundInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-67)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```
