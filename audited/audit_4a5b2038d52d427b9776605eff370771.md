# Audit Report

## Title
Insufficient Validation of Next Round Miner List Allows Consensus Manipulation

## Summary
The `ValidationForNextRound` method in `RoundTerminateValidationProvider` only validates that the round number increments by one and that all `InValue` fields are null, but fails to validate the integrity of `RealTimeMinersInformation`. This allows a malicious miner to produce a NextRound block with an arbitrary miner list (e.g., duplicate themselves, exclude legitimate miners) which will pass validation and be stored in consensus state, enabling them to monopolize block production and rewards in the next round.

## Finding Description

The vulnerability exists in the validation logic for NextRound consensus behavior. The `ValidationForNextRound` method performs only two checks: [1](#0-0) 

**Root Cause**: The validation only verifies:
1. Round number is exactly `BaseRound.RoundNumber + 1`
2. All miners have `InValue == null`

**Missing Critical Validations**:
- No check that the miner list in `extraData.Round.RealTimeMinersInformation` matches the current round's miner list
- No check that each miner appears exactly once (no duplicates)
- No check that the total number of miners is correct
- No validation of miner identities beyond the `InValue` field

The companion validator `NextRoundMiningOrderValidationProvider` also fails to prevent this attack: [2](#0-1) 

This validator checks that miners with `FinalOrderOfNextRound > 0` equals miners with `OutValue != null` in the provided round. However, in a legitimately generated next round that hasn't been mined yet, both values are 0 for all miners, so this check becomes `0 == 0` and passes regardless of which miners are included.

**Execution Path**:

The `NextRound` method is publicly accessible: [3](#0-2) 

Validation occurs before execution through the validation providers: [4](#0-3) 

The `ProcessNextRound` method stores the malicious round directly without validating miner list composition: [5](#0-4) 

The round is stored via `AddRoundInformation` which performs no miner list integrity checks: [6](#0-5) 

Crucially, `SetMinerList` (which updates the official miner list) is only called during `ProcessNextTerm`, NOT during `ProcessNextRound`: [7](#0-6) 

The legitimate next round generation properly maintains the miner list from the current round: [8](#0-7) 

However, an attacker can bypass this legitimate generation by directly calling the public `NextRound` method with malicious input.

The authorization check in `PreCheck` only verifies that the sender is in the current or previous miner list, not that the proposed next round has valid miners: [9](#0-8) 

## Impact Explanation

**Consensus Integrity Breach**: An attacker who is a current miner can manipulate the consensus protocol by:
- Adding multiple instances of themselves to the next round (e.g., 5 copies of attacker's pubkey with different orders)
- Removing legitimate miners from the next round
- Arbitrarily rearranging time slots and mining orders

**Block Reward Theft**: If an attacker adds 5 instances of themselves and removes all other miners:
- They can mine all blocks in round N+1
- They receive 100% of block rewards for that round instead of their fair share (e.g., 20% in a 5-miner setup)
- Other legitimate miners receive no rewards despite being entitled to them

**Network Disruption**: 
- Legitimate miners cannot produce blocks in the manipulated round
- Chain progression depends entirely on the attacker
- The attacker can create sustained DoS by repeatedly manipulating subsequent rounds

**Severity Justification**: This represents a critical impact on consensus mechanism integrity, enabling direct theft of block rewards from honest miners and potential for sustained network disruption. This violates the fundamental invariant of "correct round transitions and miner schedule integrity."

## Likelihood Explanation

**Attacker Capabilities**: 
- Must be a current miner (in the active miner set) - a realistic constraint
- Must be able to produce blocks during their time slot - standard miner capability
- Requires only standard miner privileges, no special authorization needed

**Attack Complexity**: Low
- Single transaction call to public `NextRound` method
- Simple construction of malicious `NextRoundInput` with modified `RealTimeMinersInformation`
- No complex state manipulation or timing requirements beyond normal block production

**Feasibility Conditions**:
- Attacker waits for their block production opportunity during a round transition
- Produces one block with malicious consensus extra data
- All current miners have this opportunity periodically (when they should trigger NextRound)

**Detection Constraints**:
The post-execution validation only checks hash equality between header and stored state, which will match for malicious data: [10](#0-9) 

The malicious round will appear valid in state with correct round number. Other miners will notice they cannot mine, but the attacker has already captured control of the round.

**Economic Rationality**: Highly profitable - cost is minimal (one block production), gain is all block rewards for an entire round (potentially hundreds or thousands of blocks depending on round length).

**Probability**: High - any current miner can execute this attack during their extra block production slot.

## Recommendation

Add explicit miner list validation to the `ValidationForNextRound` method:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing checks
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Validate miner list composition
    var currentMiners = validationContext.BaseRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    var nextMiners = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    
    // Check that miner lists match exactly
    if (currentMiners.Count != nextMiners.Count)
        return new ValidationResult { Message = "Next round miner count does not match current round." };
    
    if (!currentMiners.SequenceEqual(nextMiners))
        return new ValidationResult { Message = "Next round miner list does not match current round." };
    
    return new ValidationResult { Success = true };
}
```

This ensures that:
1. The number of miners remains consistent
2. The exact set of miners is preserved (no additions, removals, or duplicates)
3. Only the mining order changes, not the miner identities

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMinerCanManipulateNextRoundMinerList()
{
    // Setup: Initialize consensus with 5 miners [A, B, C, D, E]
    var initialMiners = new[] { "MinerA", "MinerB", "MinerC", "MinerD", "MinerE" };
    await InitializeConsensusWithMiners(initialMiners);
    
    // Advance to a state where MinerA can produce NextRound block
    await AdvanceToRoundTransition("MinerA");
    
    // MinerA crafts malicious NextRoundInput with duplicate of themselves
    var maliciousNextRound = new Round
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        RealTimeMinersInformation = 
        {
            ["MinerA"] = new MinerInRound { Pubkey = "MinerA", Order = 1, InValue = null },
            ["MinerA_Duplicate1"] = new MinerInRound { Pubkey = "MinerA", Order = 2, InValue = null },
            ["MinerA_Duplicate2"] = new MinerInRound { Pubkey = "MinerA", Order = 3, InValue = null },
            ["MinerA_Duplicate3"] = new MinerInRound { Pubkey = "MinerA", Order = 4, InValue = null },
            ["MinerA_Duplicate4"] = new MinerInRound { Pubkey = "MinerA", Order = 5, InValue = null }
        }
    };
    
    var maliciousInput = NextRoundInput.Create(maliciousNextRound, randomNumber);
    
    // Attack: MinerA calls NextRound with malicious input
    var result = await ConsensusStub.NextRound.SendAsync(maliciousInput);
    
    // Verify: The malicious round passes validation and is stored
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Next round now has MinerA in all 5 positions
    var storedNextRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    storedNextRound.RoundNumber.ShouldBe(currentRound.RoundNumber + 1);
    storedNextRound.RealTimeMinersInformation.Values.All(m => m.Pubkey == "MinerA").ShouldBeTrue();
    
    // Impact: MinerA can now mine all blocks and receive 100% of rewards
    // Legitimate miners B, C, D, E cannot produce blocks
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-91)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```
