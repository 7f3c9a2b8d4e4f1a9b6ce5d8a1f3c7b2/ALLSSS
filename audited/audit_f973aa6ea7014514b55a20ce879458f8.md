### Title
Vote ID Collision Causing Permanent Denial of Service for Specific Candidate Vote Counts

### Summary
The `GenerateVoteId()` function generates vote IDs based on the candidate's current active vote amount, but the `LockTimeMap` is never cleaned up after vote withdrawal. This allows previously-used vote count values to become permanently "poisoned," preventing any future votes from being created when the candidate's vote count returns to those values, effectively causing a Denial of Service.

### Finding Description

The vulnerability exists in the vote ID generation and withdrawal mechanism:

**Vote ID Generation Logic:**
The `GenerateVoteId()` function reads the current `ObtainedActiveVotedVotesAmount` for a candidate and uses it to generate a deterministic vote ID. [1](#0-0) 

**Vote Creation Check:**
The `Vote()` function asserts that the generated vote ID doesn't already exist by checking if `LockTimeMap[voteId] == 0`. [2](#0-1) 

**Missing Cleanup in Withdrawal:**
The `Withdraw()` function decreases the candidate's `ObtainedActiveVotedVotesAmount` but never removes the corresponding entry from `LockTimeMap`. [3](#0-2) 

The `LockTimeMap` state variable is defined to track vote lock times. [4](#0-3) 

While `WeightsAlreadyFixedMap` is explicitly cleaned up during withdrawal, `LockTimeMap` is not. [5](#0-4) 

**Root Cause:**
The vote ID generation depends on a mutable value (active vote count) that can decrease and cycle back to previous values, but the collision-detection map (`LockTimeMap`) persists indefinitely. This creates a scenario where vote IDs can collide across different time periods.

### Impact Explanation

**Denial of Service Impact:**
- Legitimate users cannot vote for a candidate when the candidate's active vote count matches any previously-used count value
- An attacker can deliberately "poison" multiple vote count values (0, 1, 2, ..., N) by voting at each count level and later withdrawing
- Since vote amounts are arbitrary, an attacker could poison hundreds or thousands of count values with relatively small capital
- Once poisoned, these count values remain unusable permanently, as `LockTimeMap` entries are never cleared

**Affected Users:**
- All future voters attempting to vote for affected candidates
- The candidates themselves, who cannot receive new votes when counts cycle back
- The election system's integrity, as vote distribution becomes distorted

**Severity Justification:**
HIGH - This breaks a core function of the Election contract. The voting mechanism is fundamental to the governance system, and preventing users from voting constitutes a critical operational failure.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to vote for candidates (public function, any user)
- Sufficient tokens to vote (minimal - even 1 token per vote count value)
- Patience to wait for lock periods to expire before withdrawing

**Attack Complexity:**
LOW - The attack sequence is straightforward:
1. Vote for a candidate with small amounts at sequential vote count values
2. Wait for lock periods to expire
3. Withdraw all votes
4. All those count values are now permanently unusable

**Feasibility Conditions:**
- Vote counts naturally cycle back to previous values as users withdraw votes
- Even without malicious intent, normal vote/withdraw patterns will gradually accumulate poisoned count values
- The candidate's vote count starting from 0 is especially vulnerable, as this is the initial state

**Economic Rationality:**
- Attack cost is minimal: only gas fees + temporary token locking
- Tokens are returned after withdrawal, so capital cost is near zero
- High impact relative to minimal cost makes this highly exploitable

**Probability:**
HIGH - This will occur naturally through normal operations even without malicious actors, as vote counts regularly decrease when users withdraw.

### Recommendation

**Immediate Fix:**
Add explicit cleanup of `LockTimeMap` entries in the `Withdraw()` function:

```csharp
public override Empty Withdraw(Hash input)
{
    // ... existing withdrawal logic ...
    
    // Add this line after successful withdrawal validation:
    State.LockTimeMap.Remove(input);
    
    return new Empty();
}
```

Insert this cleanup after line 636 (after the lock time validation passes) or at the end of the withdrawal logic before line 678.

**Additional Safeguards:**
1. Consider changing the vote ID generation algorithm to include additional entropy that doesn't depend on mutable vote counts (e.g., block height, transaction hash, or sequential nonce)
2. Document the `Token` parameter in `VoteMinerInput` more clearly as the recommended way to avoid collisions
3. Add cleanup to other vote-related functions that might leave stale `LockTimeMap` entries (e.g., `ChangeVotingOption`)

**Test Cases:**
1. Test voting → withdrawing → voting again with same candidate at same vote count (should succeed after fix)
2. Test multiple sequential votes at different counts followed by withdrawals in reverse order
3. Test that `LockTimeMap` entries are properly cleaned up after withdrawal

### Proof of Concept

**Initial State:**
- Candidate C has 0 active votes
- `LockTimeMap` is empty

**Step 1 - Attacker votes 100 tokens:**
- Transaction: `Vote(candidate: C, amount: 100, endTimestamp: now + minLockTime)`
- `GenerateVoteId()` reads `candidateVotesCount = 0`
- Generates `voteId_A = Hash(contractAddress + C.pubkey + 0)`
- Sets `LockTimeMap[voteId_A] = minLockTime`
- Updates `CandidateVotes[C].ObtainedActiveVotedVotesAmount` to 100
- Result: Transaction succeeds ✓

**Step 2 - Another user votes 50 tokens:**
- Transaction: `Vote(candidate: C, amount: 50, endTimestamp: now + minLockTime)`
- `GenerateVoteId()` reads `candidateVotesCount = 100`
- Generates `voteId_B = Hash(contractAddress + C.pubkey + 100)`
- Transaction succeeds ✓
- Current state: `ObtainedActiveVotedVotesAmount = 150`

**Step 3 - Time passes, lock period expires**

**Step 4 - Attacker withdraws 100 tokens:**
- Transaction: `Withdraw(voteId_A)`
- Updates `CandidateVotes[C].ObtainedActiveVotedVotesAmount` from 150 to 50
- **Does NOT remove `LockTimeMap[voteId_A]`** (remains non-zero)
- Result: Withdrawal succeeds ✓

**Step 5 - Second user withdraws 50 tokens:**
- Transaction: `Withdraw(voteId_B)`
- Updates `CandidateVotes[C].ObtainedActiveVotedVotesAmount` from 50 to 0
- **Does NOT remove `LockTimeMap[voteId_B]`**
- Result: Withdrawal succeeds ✓
- Current state: `ObtainedActiveVotedVotesAmount = 0` (back to initial!)

**Step 6 - Legitimate user tries to vote:**
- Transaction: `Vote(candidate: C, amount: 200, endTimestamp: now + minLockTime)`
- `GenerateVoteId()` reads `candidateVotesCount = 0`
- Generates `voteId_C = Hash(contractAddress + C.pubkey + 0)`
- **Collision: `voteId_C == voteId_A`** (same hash inputs)
- Assert fails: `State.LockTimeMap[voteId_C] != 0`
- Result: **Transaction reverts with "Vote already exists."** ✗

**Expected Result:** User should be able to vote successfully

**Actual Result:** Transaction fails due to vote ID collision with a withdrawn vote

**Success Condition for Exploit:** Any attempt to vote when `candidateVotesCount = 0` will permanently fail for this candidate, constituting a successful Denial of Service.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L407-411)
```csharp
        var candidateVotesCount =
            State.CandidateVotes[voteMinerInput.CandidatePubkey]?.ObtainedActiveVotedVotesAmount ?? 0;
        return Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(voteMinerInput.CandidatePubkey.GetBytes(),
                candidateVotesCount.ToBytes(false)));
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L432-434)
```csharp
        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L658-660)
```csharp
        candidateVotes.ObtainedActiveVotedVotesAmount =
            candidateVotes.ObtainedActiveVotedVotesAmount.Sub(votingRecord.Amount);
        State.CandidateVotes[newestPubkey] = candidateVotes;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L665-669)
```csharp
        if (!State.WeightsAlreadyFixedMap[input])
        {
            RemoveBeneficiaryOfVoter();
            State.WeightsAlreadyFixedMap.Remove(input);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L35-38)
```csharp
    /// <summary>
    ///     Vote Id -> Lock Time (seconds)
    /// </summary>
    public MappedState<Hash, long> LockTimeMap { get; set; }
```
