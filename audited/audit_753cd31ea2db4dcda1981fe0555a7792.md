### Title
Blockchain Start Timestamp Can Be Manipulated During Genesis Round Leading to Incorrect Term Change Schedule

### Summary
The `_blockchainStartTimestamp` parameter is set during the transition from round 1 to round 2 using the first miner's `ActualMiningTime` without validation. Since block timestamps are only validated to prevent future times (not past times), and `ActualMiningTimes` are excluded from hash verification, the first miner can set an arbitrary past timestamp during round 1, causing all subsequent term change calculations to be incorrect.

### Finding Description

The vulnerability exists in the blockchain initialization process where the blockchain start timestamp is set without validation: [1](#0-0) 

During round 1, when miners produce blocks, their `ActualMiningTime` is populated from `Context.CurrentBlockTime`: [2](#0-1) 

This `ActualMiningTime` is later extracted and processed without validation: [3](#0-2) [4](#0-3) 

The critical issue is that `ActualMiningTimes` are explicitly excluded from hash-based validation: [5](#0-4) 

Block timestamp validation only prevents timestamps more than 4 seconds in the future, with NO validation against past timestamps: [6](#0-5) [7](#0-6) 

The developers acknowledge this issue in their code comments: [8](#0-7) 

### Impact Explanation

The manipulated blockchain start timestamp directly impacts term change logic, which determines when consensus terms transition: [9](#0-8) 

The term change check uses the formula: `(blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds)`. If the blockchain start timestamp is set to a past value:

- **Elapsed time appears artificially inflated**: Terms change prematurely
- **Governance schedule disrupted**: Miner elections, Treasury releases, and term-dependent governance operations occur at incorrect times
- **Reward distribution affected**: Token holder dividends and mining rewards tied to term numbers are distributed incorrectly
- **Permanent damage**: Once set during round 1→2 transition, the blockchain start timestamp cannot be corrected [10](#0-9) [11](#0-10) 

This affects Treasury releases tied to term numbers: [12](#0-11) 

### Likelihood Explanation

**Attack Feasibility: HIGH**

The attack is executable during blockchain genesis (round 1) when the first miners produce blocks. The attacker needs to be one of the initial miners, which is realistic during blockchain launch.

**Attack Steps:**
1. During round 1 (blockchain genesis), the attacker-controlled miner produces blocks with `block.Header.Time` set to a timestamp significantly in the past (e.g., 1 year ago)
2. These blocks pass validation since only future timestamps beyond 4 seconds are rejected
3. The consensus contract populates `ActualMiningTime` with `Context.CurrentBlockTime` (the manipulated timestamp)
4. When any miner triggers the transition from round 1 to round 2 via `NextRound`, the blockchain start timestamp is permanently set to the manipulated value
5. All subsequent term change checks use this incorrect baseline

**Attack Complexity: LOW**
- Single-step manipulation during genesis
- No complex transaction sequences required
- No economic barriers (mining during genesis is part of normal operations)

**Detection Difficulty: HIGH**
- The manipulation occurs during expected mining operations
- No anomalous transaction patterns
- The incorrect timestamp becomes "ground truth" for the chain

### Recommendation

**Immediate Fix:**

Add validation when setting the blockchain start timestamp to ensure it represents a reasonable value relative to the actual block time: [13](#0-12) 

Recommended changes:
1. In `ProcessNextRound` when `currentRound.RoundNumber == 1`, validate that `actualBlockchainStartTimestamp` is within an acceptable range of `Context.CurrentBlockTime` (e.g., not more than a few minutes in the past)
2. Add assertion: `Assert(Context.CurrentBlockTime - actualBlockchainStartTimestamp < new Duration { Seconds = 300 }, "Blockchain start timestamp too far in the past");`
3. Include `ActualMiningTimes` in the hash calculation for round verification, or add explicit validation of `ActualMiningTime` in `ProcessUpdateValue`

**Additional Validation:**

Add infrastructure-level validation to enforce monotonic increasing block timestamps:
- Validate that `block.Header.Time >= previousBlock.Header.Time`
- Add this check in `BlockValidationProvider.ValidateBeforeAttachAsync`

**Test Cases:**
1. Test attempting to set round 1 block timestamps significantly in the past
2. Test term change calculations with various blockchain start timestamps
3. Test that ActualMiningTime values cannot deviate significantly from block execution time

### Proof of Concept

**Initial State:**
- Fresh blockchain at genesis (round 0)
- `FirstRound` has been called to initialize round 1
- First miner is ready to produce blocks

**Attack Sequence:**

1. **Attacker produces first block in round 1** with manipulated timestamp:
   - Set `block.Header.Time = Timestamp { Seconds = TimestampHelper.GetUtcNow().Seconds - 31536000 }` (1 year in the past)
   - This passes validation (only checks `Time < UtcNow + 4 seconds`)
   
2. **Block execution** populates state:
   - `Context.CurrentBlockTime` equals the past timestamp
   - `ActualMiningTimes.Add(Context.CurrentBlockTime)` stores the past timestamp
   - State updated successfully

3. **Any miner triggers NextRound** (round 1 → round 2):
   - `SetBlockchainStartTimestamp` is called with the past timestamp
   - `State.BlockchainStartTimestamp.Value = actualBlockchainStartTimestamp` (1 year in the past)

4. **Subsequent term change checks** behave incorrectly:
   - Current time: `Timestamp { Seconds = UtcNow }`
   - Blockchain start: `Timestamp { Seconds = UtcNow - 31536000 }`
   - Elapsed: 31536000 seconds (~365 days)
   - With `PeriodSeconds = 604800` (7 days): Term number calculated as ~52 instead of 1
   - Term changes occur immediately and repeatedly at incorrect intervals

**Expected Result:** Blockchain start timestamp set to actual first block time

**Actual Result:** Blockchain start timestamp set to manipulated past value, causing all term changes to be calculated incorrectly based on artificially inflated elapsed time

**Success Condition:** Term number increases prematurely due to the manipulated blockchain start timestamp, disrupting the consensus term schedule and all term-dependent operations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L117-123)
```csharp
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L62-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L42-42)
```csharp
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L193-193)
```csharp
            checkableMinerInRound.ActualMiningTimes.Clear();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L239-243)
```csharp
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
    }
```

**File:** src/AElf.Kernel.Core/Blockchain/Application/IBlockValidationProvider.cs (L133-139)
```csharp
        if (block.Header.Height != AElfConstants.GenesisBlockHeight &&
            block.Header.Time.ToDateTime() - TimestampHelper.GetUtcNow().ToDateTime() >
            KernelConstants.AllowedFutureBlockTimeSpan.ToTimeSpan())
        {
            Logger.LogDebug("Future block received {Block}, {BlockTime}", block, block.Header.Time.ToDateTime());
            return Task.FromResult(false);
        }
```

**File:** src/AElf.Kernel.Types/KernelConstants.cs (L19-19)
```csharp
    public static Duration AllowedFutureBlockTimeSpan = new() { Seconds = 4 };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L22-25)
```csharp
        /// <summary>
        ///     The blockchain start timestamp is incorrect during the first round,
        ///     don't worry, we can return NextRound without hesitation.
        ///     Besides, return only NextRound for single node running.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L30-35)
```csharp
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L85-89)
```csharp
    private void SetBlockchainStartTimestamp(Timestamp timestamp)
    {
        Context.LogDebug(() => $"Set start timestamp to {timestamp}");
        State.BlockchainStartTimestamp.Value = timestamp;
    }
```
