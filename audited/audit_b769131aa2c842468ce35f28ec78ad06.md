### Title
Unvalidated Secret Sharing Revelations Allow Consensus State Poisoning via First-Write-Wins Policy

### Summary
The `UpdateLatestSecretPieces()` function accepts `RevealedInValues` from trigger information without on-chain validation and implements a first-write-wins policy that prevents corrections. An attacker can inject malicious `PreviousInValue` data for other miners, which persists to state and gets used in `SupplyCurrentRoundInformation()` to calculate signatures, corrupting consensus randomness and round transitions.

### Finding Description

The vulnerability exists in the interaction between three components:

1. **No Validation of RevealedInValues**: In `UpdateLatestSecretPieces()`, revealed in values from trigger information are directly applied to the round state without any cryptographic verification: [1](#0-0) 

2. **First-Write-Wins Policy**: The check at lines 150-151 prevents overwriting an already-set `PreviousInValue`, creating a race condition where the first miner to reveal a value locks it in permanently: [2](#0-1) 

3. **State Persistence Without Check**: During transaction execution, `PerformSecretSharing()` writes these unvalidated values directly to state: [3](#0-2) 

4. **Malicious Values Are Used**: The poisoned state is consumed by `SupplyCurrentRoundInformation()`, which reads the attacker-controlled `PreviousInValue` from state and uses it to calculate consensus signatures: [4](#0-3) 

The signature calculation incorporates the malicious value into consensus randomness: [5](#0-4) 

**Root Cause**: The contract trusts off-chain secret sharing reconstruction without on-chain verification. While the `UpdateValueValidationProvider` validates a miner's own `PreviousInValue`: [6](#0-5) 

This validation only applies to the block producer's own value, not to the `RevealedInValues` they provide for other miners.

### Impact Explanation

**Consensus State Corruption**: An attacker can inject incorrect `PreviousInValue` data for victim miners who failed to mine in previous rounds. When `NextRound` is triggered, `SupplyCurrentRoundInformation()` is called: [7](#0-6) 

It processes miners who didn't mine (OutValue is null): [8](#0-7) 

And calculates their signatures using the poisoned `PreviousInValue` from state: [4](#0-3) 

**Specific Harms**:
- **Randomness Manipulation**: Signatures feed into consensus randomness generation, affecting random number generation for the blockchain
- **Miner Order Manipulation**: Incorrect signatures can influence the calculated mining order for subsequent rounds via the XOR-based signature mechanism
- **Consensus Integrity**: The round information stored on-chain becomes corrupted with incorrect cryptographic values
- **Cascading Effects**: Incorrect values persist across multiple rounds until affected miners successfully mine again

The severity is Medium because while it affects consensus integrity, it requires attacker miner status and the impact is on signature calculations rather than direct fund theft.

### Likelihood Explanation

**Attacker Capabilities Required**:
- Must be a scheduled miner with block production rights
- Must modify node software to inject arbitrary `RevealedInValues` in trigger information
- Must produce a block before honest miners reveal correct values

**Attack Complexity**: Medium
- The trigger information is generated by the attacker's own node, making injection straightforward [9](#0-8) 
- No cryptographic proof is required on-chain
- The first-write-wins policy ensures persistence

**Feasibility Conditions**:
- Target miners must have failed to mine in previous rounds (creating the need for secret sharing revelation)
- Attacker must produce a block during the vulnerable window
- Detection is difficult as revealed values appear legitimate without comparing against proper secret sharing reconstruction

**Probability**: Medium - requires specific conditions but exploitation is practical for a malicious miner who can time their block production appropriately.

### Recommendation

1. **Add On-Chain Validation**: Implement cryptographic verification of revealed in values against the decrypted pieces stored in the round information. Before accepting a `RevealedInValue`, verify it can be reconstructed from the available `DecryptedPieces`:

```csharp
// In UpdateLatestSecretPieces, add validation before setting:
if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
{
    var targetMiner = updatedRound.RealTimeMinersInformation[revealedInValue.Key];
    if (targetMiner.DecryptedPieces.Count >= minimumThreshold)
    {
        // Verify the revealed value matches reconstruction from pieces
        var reconstructed = ReconstructFromPieces(targetMiner.DecryptedPieces);
        if (reconstructed != revealedInValue.Value)
        {
            Context.LogDebug("Invalid revealed in value detected, skipping");
            continue;
        }
    }
    
    if (targetMiner.PreviousInValue == Hash.Empty || targetMiner.PreviousInValue == null)
        targetMiner.PreviousInValue = revealedInValue.Value;
}
```

2. **Add Validation Provider**: Create a new `RevealedInValuesValidationProvider` that verifies revealed values before block acceptance, similar to how `UpdateValueValidationProvider` works.

3. **Allow Corrections with Proof**: Modify the check to allow overwriting if a cryptographic proof demonstrates the existing value is incorrect and the new value is properly reconstructed.

### Proof of Concept

**Initial State**:
- Round N: Miner C is scheduled but fails to mine (goes offline)
- Miner C has previously shared encrypted pieces with other miners
- Round N+1: Attacker A and honest Miner B are both scheduled to mine

**Attack Sequence**:

1. Attacker A modifies their node's `SecretSharingService` to return malicious values instead of proper reconstruction in `GetRevealedInValues()`

2. Attacker A's turn arrives first in Round N+1, produces block with:
   - `RevealedInValues = { "MinerC_Pubkey" -> Hash_Malicious }`

3. Block generation calls `UpdateLatestSecretPieces()`:
   - No validation performed on `Hash_Malicious`
   - Line 152 sets: `updatedRound.RealTimeMinersInformation["MinerC_Pubkey"].PreviousInValue = Hash_Malicious`

4. Transaction executes, `PerformSecretSharing()` at line 296 writes to state:
   - `State.Rounds[currentRoundNumber]["MinerC_Pubkey"].PreviousInValue = Hash_Malicious`

5. Honest Miner B's turn arrives, attempts to reveal correct value `Hash_Correct`
   - `UpdateLatestSecretPieces()` line 150 check: `PreviousInValue` already set
   - Line 151 condition fails, correction is **rejected**

6. Round N+2 begins, `NextRound()` calls `SupplyCurrentRoundInformation()` at line 163
   - Line 191 reads: `previousInValue = currentRound["MinerC_Pubkey"].PreviousInValue` â†’ gets `Hash_Malicious`
   - Line 199 calculates: `signature = previousRound.CalculateSignature(Hash_Malicious)`
   - Wrong signature is stored in consensus state

**Expected Result**: Miner C's `PreviousInValue` should be the correct reconstruction from secret sharing

**Actual Result**: Miner C's `PreviousInValue` is the attacker's malicious value, and incorrect signatures are calculated, corrupting consensus randomness

**Success Condition**: Verify that `State.Rounds[N+1]["MinerC_Pubkey"].PreviousInValue == Hash_Malicious` and subsequent signature calculations use this incorrect value.

### Notes

The vulnerability stems from trusting off-chain secret sharing reconstruction without on-chain verification. The design assumes all miners compute revelations honestly, but provides no mechanism to detect or correct malicious revelations. The first-write-wins policy at lines 150-151, intended to prevent duplicate updates, becomes an attack enabler by permanently locking in the first (potentially malicious) value.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-165)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L175-176)
```csharp
        var notMinedMiners = currentRound.RealTimeMinersInformation.Values.Where(m => m.OutValue == null).ToList();
        if (!notMinedMiners.Any()) return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L112-114)
```csharp
            var revealedInValues = _secretSharingService.GetRevealedInValues(hint.RoundId);
            foreach (var revealedInValue in revealedInValues)
                trigger.RevealedInValues.Add(revealedInValue.Key, revealedInValue.Value);
```
