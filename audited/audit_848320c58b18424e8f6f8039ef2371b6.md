### Title
Maximum Blocks Count Can Return Zero Leading to Severe Throughput Degradation in Abnormal Status

### Summary
When the blockchain enters Abnormal mining status and no miners appear in both of the last two rounds, `GetMaximumBlocksCount()` returns 0 instead of a positive minimum. This prevents miners from producing tiny blocks, reducing throughput by 87.5% and creating an operational denial-of-service condition where only one block per time slot can be produced.

### Finding Description

In `GetMaximumBlocksCount()`, when the blockchain mining status is Abnormal (LIB is 2-8 rounds behind), the function calculates a dynamic maximum blocks count: [1](#0-0) 

The calculation retrieves mined miner lists from the previous two rounds and finds their intersection: [2](#0-1) 

When `minersOfLastTwoRounds` equals 0 (no common miners between rounds N-1 and N-2), the `factor` becomes 0. The `Ceiling` function then returns 0: [3](#0-2) 

Subsequently, `Math.Min(MaximumTinyBlocksCount, 0)` returns 0. This value is used in consensus behavior determination: [4](#0-3) 

When `_maximumBlocksCount` is 0, the condition `ActualMiningTimes.Count < 0` is always false, preventing miners from producing TinyBlock behavior. The same check at line 110 also fails.

This is inconsistent with the Severe status handling, which explicitly returns 1 as a minimum: [5](#0-4) 

### Impact Explanation

**Throughput Degradation:**
Under normal conditions with `MaximumTinyBlocksCount = 8`, miners can produce up to 8 tiny blocks per time slot. When this bug triggers and returns 0, miners can only produce 1 UPDATE_VALUE block per time slot, representing an 87.5% reduction in maximum throughput. [6](#0-5) 

**Operational DoS:**
- Transaction backlog accumulates as the network cannot process normal load
- Users experience severe delays or inability to transact
- Critical governance proposals may fail to execute timely
- The network becomes effectively unusable despite consensus continuing

**Affected Parties:**
All network participants suffer when the blockchain enters this degraded state during periods when it's already under stress (Abnormal status indicates LIB is falling behind).

### Likelihood Explanation

**Entry Point:**
The function is called during consensus command generation, reachable from any block production cycle: [7](#0-6) 

**Preconditions:**
1. Blockchain must be in Abnormal status (LIB is 2-8 rounds behind current round)
2. No miners from round N-1 also mined in round N-2 (minersOfLastTwoRounds = 0)

**Feasibility:**
These conditions can occur naturally during network stress or partitioning. The MinedMinerListMap can contain empty lists when no miners successfully mine in a round: [8](#0-7) [9](#0-8) 

If `GetMinedMiners()` returns an empty list (when no miner has `SupposedOrderOfNextRound != 0`), the MinerList for that round will be empty, causing the intersection count to be 0.

### Recommendation

**Immediate Fix:**
Add a minimum floor value of 1 in the Abnormal status branch, consistent with Severe status handling:

```csharp
var count = Math.Max(1, Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
    Ceiling(factor, currentRound.RealTimeMinersInformation.Count)));
```

**Additional Safeguards:**
1. Add validation that `minersOfLastTwoRounds` is checked before calculation
2. Consider logging when this edge case occurs for monitoring
3. Add unit tests covering scenarios where mined miner lists are empty or disjoint

**Invariant to Enforce:**
`GetMaximumBlocksCount()` must always return a value >= 1 to ensure the blockchain maintains minimum operational throughput.

### Proof of Concept

**Initial State:**
1. Blockchain is at round N with LIB at round N-5 (Abnormal status: LIB + 2 < N < LIB + 8)
2. Round N-2 had miners {A, B} successfully mine (recorded in MinedMinerListMap[N-2])
3. Round N-1 had miners {C, D} successfully mine (recorded in MinedMinerListMap[N-1])
4. No common miners between the two rounds

**Execution:**
1. Miner calls consensus to get command for producing next block
2. `GetMaximumBlocksCount()` is invoked
3. Retrieves `previousRoundMinedMinerList = {C, D}` and `previousPreviousRoundMinedMinerList = {A, B}`
4. Calculates `minersOfLastTwoRounds = {C,D}.Intersect({A,B}).Count() = 0`
5. Calculates `factor = 0 * (SevereStatusRoundsThreshold - (N - LIB)) = 0`
6. Calls `Ceiling(0, minerCount)` which returns 0
7. Returns `Math.Min(8, 0) = 0`

**Result:**
- Expected: Minimum blocks count of at least 1 to maintain network operation
- Actual: Returns 0, preventing any tiny block production and degrading throughput by 87.5%
- Success Condition: Network enters severe performance degradation state where only 1 block per time slot is possible

**Notes**

The vulnerability occurs specifically in the Abnormal status path and represents an inconsistency with the explicitly enforced minimum of 1 in the Severe status path. While the Abnormal status is meant to reduce blocks count to prevent forking when network health degrades, returning 0 goes too far and creates an operational DoS condition. The fix is straightforward: apply the same minimum floor of 1 that exists in the Severe status handling.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L42-55)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L81-85)
```csharp
    private static int Ceiling(int num1, int num2)
    {
        var flag = num1 % num2;
        return flag == 0 ? num1.Div(num2) : num1.Div(num2).Add(1);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-62)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L46-52)
```csharp
            case AElfConsensusBehaviour.TinyBlock:
            {
                var consensusCommand =
                    new ConsensusCommandProvider(new TinyBlockCommandStrategy(currentRound, pubkey,
                        currentBlockTime, GetMaximumBlocksCount())).GetConsensusCommand();
                return consensusCommand;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L223-236)
```csharp
    private void RecordMinedMinerListOfCurrentRound()
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        State.MinedMinerListMap.Set(currentRound.RoundNumber, new MinerList
        {
            Pubkeys = { currentRound.GetMinedMiners().Select(m => ByteStringHelper.FromHexString(m.Pubkey)) }
        });

        // Remove information out of date.
        var removeTargetRoundNumber = currentRound.RoundNumber.Sub(3);
        if (removeTargetRoundNumber > 0 && State.MinedMinerListMap[removeTargetRoundNumber] != null)
            State.MinedMinerListMap.Remove(removeTargetRoundNumber);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```
