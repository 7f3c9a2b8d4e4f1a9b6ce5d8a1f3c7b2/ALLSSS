### Title
Missing Signature Verification Allows Miners to Manipulate Next Round Order Selection

### Summary
The `ApplyNormalConsensusData` function uses an unverified signature hash to calculate `supposedOrderOfNextRound`, which determines a miner's position in the next consensus round. A malicious miner can submit arbitrary signature values during block production to control their mining order, breaking the fairness and randomness guarantees of the AEDPoS consensus mechanism.

### Finding Description

The vulnerability exists in the consensus data processing flow where miners provide signature values that directly influence their order in subsequent rounds, but these signatures are never cryptographically verified.

**Root Cause**: In `ApplyNormalConsensusData`, the signature parameter is converted to an integer and used to calculate the miner's next round order: [1](#0-0) 

This `supposedOrderOfNextRound` value (ranging from 1 to `minersCount`) determines the miner's position in the next round and is stored without any verification that the signature was correctly calculated.

**Expected Behavior**: The signature should be computed deterministically using `CalculateSignature`: [2](#0-1) 

During normal block production, this calculation happens in: [3](#0-2) [4](#0-3) [5](#0-4) 

**Validation Failure**: The `UpdateValueValidationProvider` only checks that the signature field is non-empty: [6](#0-5) 

There is **no validation** that the provided signature equals what `CalculateSignature` would produce from the previous round data and the miner's `previousInValue`.

**Attack Execution Path**:

1. Malicious miner modifies their node software to generate consensus extra data with arbitrary signature value instead of calling `CalculateSignature`

2. During their block production turn, `GetConsensusExtraData` is called which invokes `ApplyNormalConsensusData` with the manipulated signature: [7](#0-6) 

3. The consensus extra data (containing malicious signature) is included in the block header

4. When other nodes validate the block, `ValidateConsensusBeforeExecution` is called: [8](#0-7) 

5. The validation passes because only non-null/non-empty is checked, not correctness

6. The system generates an `UpdateValue` transaction from the malicious consensus extra data: [9](#0-8) 

7. The transaction executes via `ProcessUpdateValue` and stores the arbitrary signature: [10](#0-9) 

8. The malicious signature affects the miner's `SupposedOrderOfNextRound` which was already set during step 2

### Impact Explanation

**Consensus Integrity Violation**: The vulnerability breaks a critical consensus invariant - that mining order should be determined fairly based on deterministic, verifiable computations from all miners' contributions. A malicious miner can now unilaterally choose their position in the next round.

**Concrete Harms**:

1. **Unfair Mining Advantage**: Miner can select position 1 to mine the first block of each round, gaining consistent first-mover advantage for transaction ordering and MEV extraction

2. **Block Reward Manipulation**: Early positions in rounds may have advantages in earning block rewards and transaction fees

3. **Randomness Corruption**: The manipulated signature becomes part of the XOR chain used in future `CalculateSignature` calls, potentially affecting randomness generation for other consensus decisions

4. **Coordinated Attacks**: Multiple colluding miners can manipulate their orders to create favorable sequences (e.g., mining consecutive blocks)

5. **Fairness Breakdown**: Honest miners who follow the protocol correctly are disadvantaged compared to attackers who can choose optimal positions

**Severity Justification**: CRITICAL - This violates the fundamental fairness guarantee of the consensus mechanism. Any miner can exploit this undetectably to gain systematic advantages over honest miners, undermining trust in the consensus protocol's integrity.

### Likelihood Explanation

**Attacker Capabilities**: 
- Attacker must be an active miner (in the miner list)
- Must have ability to modify their consensus node software
- No special privileges beyond normal miner status required

**Attack Complexity**: LOW
- Simple modification: replace `CalculateSignature` call with arbitrary hash value
- No timing constraints beyond normal block production
- No complex transaction sequences needed
- Can be automated in modified node software

**Feasibility**: HIGH
- Entry point is the standard block production process every miner participates in
- Precondition (being a miner) is realistic for this attack vector
- No economic barriers - costs only normal block production
- Attack is undetectable on-chain since validation never checks signature correctness

**Detection Constraints**: 
- Other nodes cannot distinguish malicious signature from correct one without re-computing `CalculateSignature`
- No anomaly detection exists for this attack
- Manipulation appears as valid consensus data

**Probability**: HIGH - Any rational miner seeking competitive advantage would exploit this, and multiple miners likely already have if they discovered this independently.

### Recommendation

**Immediate Fix**: Add signature verification in `UpdateValueValidationProvider`:

```csharp
private bool ValidateSignature(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;
    
    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
        return true;
    
    var providedSignature = extraData.Round.RealTimeMinersInformation[publicKey].Signature;
    var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
    
    if (previousInValue == null || previousInValue == Hash.Empty) 
        return true;
    
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
    
    return providedSignature == expectedSignature;
}
```

Add this check to the validation chain: [11](#0-10) 

**Additional Hardening**:

1. Add invariant checks in `ApplyNormalConsensusData` before accepting signature values
2. Add test cases verifying that manipulated signatures cause validation failure
3. Consider adding on-chain monitoring for suspicious order selection patterns
4. Review other consensus fields for similar missing verification issues

### Proof of Concept

**Initial State**:
- Round N has 5 miners: [A, B, C, D, E] with orders [1, 2, 3, 4, 5]
- Miner C (attacker) wants to be first in Round N+1 instead of random assignment

**Attack Steps**:

1. During Round N, when it's Miner C's turn to produce block:
   - Normal flow would call `previousRound.CalculateSignature(previousInValue)` → produces hash `H_correct`
   - Attacker modifies code to find hash `H_malicious` where `|H_malicious.ToInt64() % 5| + 1 = 1`

2. Miner C includes `H_malicious` in consensus extra data instead of `H_correct`

3. Block is proposed with malicious consensus data

4. Validation executes:
   - `NewConsensusInformationFilled`: Checks `H_malicious != null` ✓ PASS
   - `ValidatePreviousInValue`: Checks `hash(previousInValue) == previousOutValue` ✓ PASS
   - **Missing**: Check `H_malicious == CalculateSignature(previousInValue)` ✗ NEVER CHECKED

5. Transaction executes: `supposedOrderOfNextRound = |H_malicious.ToInt64() % 5| + 1 = 1`

6. Miner C is assigned position 1 in Round N+1

**Expected Result**: Validation should reject block because signature doesn't match expected value

**Actual Result**: Block is accepted, Miner C successfully manipulates their order to position 1

**Success Condition**: Attacker can repeatably choose their next round position by selecting appropriate signature hash values

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L101-101)
```csharp
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L106-106)
```csharp
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L144-146)
```csharp
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-244)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
```
