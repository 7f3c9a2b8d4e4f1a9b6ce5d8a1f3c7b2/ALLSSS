# Audit Report

## Title
Missing LIB Height Monotonicity Validation in NextRound and NextTerm Behaviors Allows Consensus Disruption

## Summary
The consensus validation logic only applies `LibInformationValidationProvider` to `UpdateValue` behavior, allowing malicious miners to submit `NextRound` or `NextTerm` transactions with artificially decreased Last Irreversible Block (LIB) values. This violates the critical LIB monotonicity invariant and can trigger false "Severe" blockchain status, severely degrading consensus performance.

## Finding Description

The `ValidateBeforeExecution` method conditionally adds validation providers based on consensus behavior. [1](#0-0) 

The `LibInformationValidationProvider` validates that LIB values cannot decrease by comparing the base round's LIB against the provided round's LIB. [2](#0-1) 

However, this critical validation is **only added for `UpdateValue` behavior** (line 82), not for `NextRound` or `NextTerm`. The alternative validators for these behaviors do not check LIB monotonicity. [3](#0-2) [4](#0-3) 

Both `NextRoundInput` and `NextTermInput` contain `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` fields that are preserved when converting to Round objects. [5](#0-4) [6](#0-5) 

The consensus transaction generation uses the Round from consensus extra data directly. [7](#0-6) 

When `ProcessNextRound` or `ProcessNextTerm` executes, the Round object with potentially decreased LIB values is stored directly via `AddRoundInformation`. [8](#0-7) [9](#0-8) 

The stored LIB values are then used by `GetMaximumBlocksCount` to evaluate blockchain health status. [10](#0-9) 

If the LIB round number is artificially decreased, the blockchain can falsely enter "Severe" status when `currentRoundNumber >= libRoundNumber + SevereStatusRoundsThreshold`, severely limiting block production. [11](#0-10) 

## Impact Explanation

**Critical Consensus Disruption:**
- A malicious miner can trigger false "Severe" blockchain status by decreasing LIB round numbers in their NextRound/NextTerm submissions
- When in "Severe" status, maximum blocks count is reduced to 1, severely degrading blockchain throughput and transaction processing capacity
- The `IrreversibleBlockHeightUnacceptable` event is fired inappropriately, potentially triggering emergency responses in monitoring systems

**Consensus Integrity Violation:**
- The fundamental invariant that LIB never decreases is violated
- Round state contains incorrect LIB information that affects subsequent consensus operations
- Applications and services relying on LIB information for finality guarantees receive corrupted data

**Affected Components:**
- All consensus participants experience degraded performance
- Cross-chain operations may be affected by incorrect LIB information
- Monitoring and alerting systems receive false signals

## Likelihood Explanation

**High Likelihood:**
- Attack requires only miner privileges, which are normal network participants
- Extra block producers trigger NextRound regularly (every round)
- Any miner can trigger NextTerm during term transitions (approximately every 7 days)
- The exploit is straightforward: provide consensus extra data with decreased LIB values
- No additional cryptographic material or special authorization required beyond being an active miner

**Detection Difficulty:**
- The malicious transaction appears valid to all current validation checks
- By the time incorrect LIB values are detected, the state has already been corrupted
- Recovery requires manual intervention or protocol-level fixes

## Recommendation

Add `LibInformationValidationProvider` to the validation pipeline for both `NextRound` and `NextTerm` behaviors:

```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.UpdateValue:
        validationProviders.Add(new UpdateValueValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider());
        break;
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
        break;
}
```

This ensures that LIB monotonicity is validated for all consensus behaviors that include LIB fields, preventing malicious miners from submitting rounds with decreased LIB values.

## Proof of Concept

A proof of concept would require:
1. Setting up a test node as an active miner in the consensus set
2. Obtaining the current round's LIB values (e.g., `ConfirmedIrreversibleBlockHeight = 1000`, `ConfirmedIrreversibleBlockRoundNumber = 50`)
3. When it's the miner's turn to produce the NextRound block, crafting consensus extra data with:
   - Behavior: `NextRound`
   - Round information with `ConfirmedIrreversibleBlockHeight = 500` (decreased)
   - Round information with `ConfirmedIrreversibleBlockRoundNumber = 25` (decreased)
4. Submitting the block with this consensus extra data
5. Observing that validation passes (no LIB check for NextRound)
6. Verifying the round is stored with decreased LIB values
7. Observing that `GetMaximumBlocksCount` falsely triggers "Severe" status due to large gap between current round and decreased LIB round number

The vulnerability is confirmed by code inspection showing the missing `LibInformationValidationProvider` in the NextRound/NextTerm validation pipelines.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L16-17)
```csharp
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L34-35)
```csharp
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L164-171)
```csharp
            case AElfConsensusBehaviour.NextRound:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextRound), NextRoundInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-39)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L58-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```
