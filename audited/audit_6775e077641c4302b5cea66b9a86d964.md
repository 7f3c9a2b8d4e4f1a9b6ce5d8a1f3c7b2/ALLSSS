# Audit Report

## Title
Missing Signature and Mining Order Validation Allows Manipulation of Consensus Schedule

## Summary
The AEDPoS consensus contract accepts arbitrary `Signature` and `SupposedOrderOfNextRound` values from miners without validating their correctness. This allows malicious miners to manipulate their mining position in subsequent rounds, breaking the fairness guarantees of the consensus schedule.

## Finding Description

The AEDPoS consensus mechanism relies on cryptographic signatures to determine mining order for the next round. The expected flow is:

1. A miner's signature should be calculated as `previousRound.CalculateSignature(previousInValue)`, which XORs the InValue with all previous round signatures [1](#0-0) 

2. The supposed order for the next round should be derived from this signature using `GetAbsModulus(signature.ToInt64(), minersCount) + 1` [2](#0-1) 

3. This calculated order becomes the miner's position in the next round [3](#0-2) 

However, when `ProcessUpdateValue` executes, it blindly accepts these values from the `UpdateValueInput` without validation:

- The `Signature` field is directly assigned without verification [4](#0-3) 

- The `SupposedOrderOfNextRound` is directly assigned without checking it matches the signature calculation [5](#0-4) 

- The `TuneOrderInformation` field allows arbitrary modification of other miners' orders [6](#0-5) 

The validation providers fail to catch this manipulation:

- `UpdateValueValidationProvider` only checks that the signature field is non-empty and that `PreviousInValue` hashes to `previousOutValue`, but does NOT validate the signature was calculated correctly [7](#0-6) 

- `NextRoundMiningOrderValidationProvider` only validates during `NextRound` behavior (not `UpdateValue`), and even then only checks that the count of distinct orders equals miners who mined, not that each order was correctly calculated [8](#0-7) 

## Impact Explanation

This vulnerability fundamentally breaks the fairness and unpredictability of the AEDPoS consensus schedule:

1. **Mining Position Manipulation**: A malicious miner can choose to always mine first (by setting a signature where `signature.ToInt64() % minersCount == 0`) or select any other favorable position, enabling MEV extraction and transaction ordering advantages.

2. **Schedule Disruption**: Through `TuneOrderInformation`, the attacker can manipulate other miners' positions, pushing competitors to unfavorable slots or creating denial-of-service conditions.

3. **Consensus Integrity Failure**: The randomness and fairness that the signature-based ordering is designed to provide becomes meaningless when miners can choose arbitrary values.

4. **Difficult Detection**: The manipulated values are stored in contract state as if legitimate, making off-chain detection require re-computation and comparison of expected signatures.

This represents a critical failure of consensus security guarantees, as the mining schedule determines block production rights, reward distribution, and ultimately chain progression.

## Likelihood Explanation

**High Likelihood** - The attack is practical and economically rational:

- **Entry Point**: `UpdateValue` is a public method callable by any miner [9](#0-8) 

- **Preconditions**: The attacker only needs to be a valid miner in the current miner list, which is checked by `MiningPermissionValidationProvider` during validation [10](#0-9) 

- **Execution**: A malicious miner can modify their node to provide arbitrary signature and order values instead of calculating them correctly. The contract accepts these values because no validation verifies correctness.

- **Cost**: Minimal (only transaction fees), while benefits include favorable mining positions and potential MEV opportunities.

## Recommendation

Add validation in `UpdateValueValidationProvider` or `ProcessUpdateValue` to verify:

1. **Signature Correctness**: Re-calculate the expected signature using `previousRound.CalculateSignature(input.PreviousInValue)` and verify it matches `input.Signature`.

2. **Order Consistency**: Verify that `input.SupposedOrderOfNextRound` equals `GetAbsModulus(input.Signature.ToInt64(), minersCount) + 1`.

3. **TuneOrderInformation Validation**: Add constraints on which miners can tune orders and implement conflict resolution logic with validation.

Example validation logic:
```csharp
// In UpdateValueValidationProvider.ValidateHeaderInformation:
if (TryToGetPreviousRound(out var prevRound) && input.PreviousInValue != Hash.Empty)
{
    var expectedSignature = prevRound.CalculateSignature(input.PreviousInValue);
    if (input.Signature != expectedSignature)
        return new ValidationResult { Message = "Invalid signature calculation." };
    
    var expectedOrder = GetAbsModulus(input.Signature.ToInt64(), minersCount) + 1;
    if (input.SupposedOrderOfNextRound != expectedOrder)
        return new ValidationResult { Message = "Order does not match signature." };
}
```

## Proof of Concept

A malicious miner can exploit this by:

1. Obtaining their mining time slot as a valid miner
2. Instead of using the normal consensus transaction generation, crafting a custom `UpdateValueInput` with:
   - Valid `OutValue` (hash of their InValue)
   - Valid `PreviousInValue` (if applicable)
   - **Arbitrary** `Signature` value chosen such that `signature.ToInt64() % minersCount` gives their desired position
   - **Arbitrary** `SupposedOrderOfNextRound` matching their desired position
3. Calling `UpdateValue` directly with this crafted input
4. All validators pass because:
   - `MiningPermissionValidationProvider`: Attacker is in miner list ✓
   - `TimeSlotValidationProvider`: Mining in their time slot ✓
   - `UpdateValueValidationProvider`: Signature non-null ✓, PreviousInValue valid ✓
   - But no validator checks signature correctness or order derivation
5. The manipulated values are stored in state
6. In the next round generation, the attacker's manipulated `FinalOrderOfNextRound` becomes their actual mining position

The attack succeeds because the contract trusts miner-provided values without cryptographic verification.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-244)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-49)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-101)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-82)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```
