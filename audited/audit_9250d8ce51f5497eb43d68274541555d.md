# Audit Report

## Title
Banned Miners Can Continue Producing Blocks for One Round Due to Missing Ban Status Check in Mining Permission Validation

## Summary
The AEDPoS consensus mechanism has a critical timing vulnerability where miners detected as evil (having missed ≥4,320 time slots over 3 days) can continue producing blocks for exactly one additional round. This occurs because `MiningPermissionValidationProvider` only checks if a miner exists in `RealTimeMinersInformation.Keys` without verifying their ban status in `BannedPubkeyMap`, and evil miner detection happens after the next round has already been generated.

## Finding Description

The vulnerability stems from a fundamental timing gap in the consensus state machine's round transition flow.

**Root Cause:**

The mining permission validation only performs a simple key existence check without consulting the Election contract's ban status: [1](#0-0) 

The `ConsensusValidationContext` used by all validation providers contains no reference to the Election contract state or `BannedPubkeyMap`: [2](#0-1) 

**Timing Vulnerability Flow:**

1. **Round Generation (Block Creation Phase):** When the extra block producer generates the next round, it calls `GenerateNextRoundInformation` which queries the Election contract for evil miners: [3](#0-2) 

The `GetMinerReplacementInformation` method checks `BannedPubkeyMap`: [4](#0-3) 

However, at this point in time, the miner has NOT yet been marked as banned because detection happens later during block execution.

2. **Round Execution (Block Execution Phase):** After the NextRound block is created and executed, `ProcessNextRound` is called, which detects evil miners based on missed time slots: [5](#0-4) 

The evil miner threshold is 4,320 missed time slots (3 days): [6](#0-5) 

Detection logic: [7](#0-6) 

3. **Ban Status Update:** The Election contract's `UpdateCandidateInformation` finally sets the ban flag: [8](#0-7) 

**The Critical Gap:**

Because round generation happens BEFORE evil miner marking (during the extra block producer's block creation), the banned miner remains in Round N+1's `RealTimeMinersInformation`. The validation system instantiates providers without access to ban status: [9](#0-8) 

The next round's extra data is generated by calling: [10](#0-9) 

The evil miner can produce blocks during Round N+1 because validation passes. Only when Round N+2 is generated does `GetEvilMinersPubkeys` finally find them in `BannedPubkeyMap` and remove them from the active miner list.

## Impact Explanation

**Consensus Integrity Breach:**
- Evil miners who demonstrated unreliability (missing 4,320 time slots over 3 days) continue participating in consensus for one additional round
- They can produce blocks, vote on consensus decisions, and influence the blockchain state during this grace period
- This undermines the fundamental security guarantee that unreliable miners are promptly removed

**Reward Misallocation:**
- Banned miners receive mining rewards for any blocks they produce during Round N+1
- These rewards should have gone to the alternative candidates who were supposed to replace them
- The economic incentive structure is violated as punished miners are temporarily rewarded

**Weakened Punishment Mechanism:**
- The evil miner detection system is designed to maintain network reliability by removing consistently failing nodes
- The one-round delay creates a known exploitation window where miners can continue earning despite being marked for removal
- Malicious actors can factor this grace period into their attack strategies

**Chain Stability Risk:**
- Miners with a proven history of missing blocks can continue producing blocks inconsistently
- This reduces the predictability and reliability of block production during the affected round
- Other honest miners and users experience the consequences of dealing with an unreliable node that should have been removed

## Likelihood Explanation

**Certainty: Guaranteed**
- This is not an exploitable vulnerability requiring attacker action but rather an inherent architectural flaw in the consensus state machine
- The vulnerability triggers automatically and deterministically whenever any miner reaches the evil miner threshold
- No special conditions, permissions, or timing manipulation required

**Triggering Frequency:**
- Occurs every time a miner accumulates ≥4,320 missed time slots and the detection mechanism activates
- The frequency depends on network conditions and miner behavior, but the vulnerability is always present when the conditions are met

**No Mitigation Available:**
- Validators cannot prevent the banned miner from producing blocks during Round N+1 because the validation logic has no access to ban status
- The architecture fundamentally separates round generation (which needs ban status) from validation (which doesn't have it)
- Even with perfect network conditions, the timing gap exists by design

**Observable On-Chain:**
- The continued participation of banned miners is fully visible in the blockchain
- Events like `EvilMinerDetected` are fired, yet the miner continues producing blocks
- This creates apparent inconsistency between the ban events and actual block production

## Recommendation

**Immediate Fix - Add Ban Status Check to Validation:**

Modify `MiningPermissionValidationProvider` to query the Election contract's `BannedPubkeyMap`:

```csharp
public class MiningPermissionValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        // NEW: Check if miner is banned
        if (validationContext.IsMinerBanned(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is banned.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
}
```

**Extend ConsensusValidationContext:**

Add Election contract reference and ban status checking capability:

```csharp
public class ConsensusValidationContext
{
    // ... existing fields ...
    
    public IElectionContract ElectionContract { get; set; }
    
    public bool IsMinerBanned(string pubkey)
    {
        return ElectionContract?.IsPubkeyBanned(pubkey) ?? false;
    }
}
```

**Update ValidateBeforeExecution:**

Inject the Election contract reference when creating the validation context in `AEDPoSContract_Validation.cs`.

**Alternative Architectural Fix:**

Consider reordering operations so that evil miner detection and banning occurs BEFORE next round generation, though this would require more extensive refactoring of the consensus flow.

## Proof of Concept

```csharp
[Fact]
public async Task BannedMiner_ContinuesProducingBlocks_ForOneRound()
{
    // Setup: Initialize AEDPoS with 17 miners, Round N
    var initialMiners = GenerateMiners(17);
    await InitializeAEDPoS(initialMiners);
    
    // Step 1: Simulate evil miner accumulating 4,320+ missed time slots over 3 days
    var evilMinerPubkey = initialMiners[0];
    await SimulateMissedTimeSlots(evilMinerPubkey, timeSlotsToMiss: 4320);
    
    // Step 2: Trigger round transition from N to N+1
    // Extra block producer generates Round N+1 BEFORE evil miner is marked
    var roundN = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    var extraBlockProducer = GetExtraBlockProducer(roundN);
    
    // Extra block producer creates NextRound block
    await ProduceNextRoundBlock(extraBlockProducer);
    
    // Verify: Evil miner is now marked as banned in BannedPubkeyMap
    var isBanned = await ElectionContract.GetCandidateInformation.CallAsync(
        new StringValue { Value = evilMinerPubkey });
    Assert.True(isBanned.IsEvilNode); // Banned flag is set
    
    var bannedStatus = await ElectionContract.IsPubkeyBanned.CallAsync(
        new StringValue { Value = evilMinerPubkey });
    Assert.True(bannedStatus.Value); // In BannedPubkeyMap
    
    // Step 3: Verify evil miner is STILL in Round N+1's RealTimeMinersInformation
    var roundN1 = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.Contains(evilMinerPubkey, roundN1.RealTimeMinersInformation.Keys);
    
    // Step 4: Evil miner produces a block during Round N+1 - should succeed!
    var evilMinerTimeSlot = roundN1.RealTimeMinersInformation[evilMinerPubkey].ExpectedMiningTime;
    await AdvanceTimeTo(evilMinerTimeSlot);
    
    var blockResult = await ProduceBlock(evilMinerPubkey);
    Assert.True(blockResult.Success); // VULNERABILITY: Banned miner can still produce blocks!
    
    // Step 5: Verify evil miner received mining rewards
    var minerBalance = await TokenContract.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(evilMinerPubkey)),
        Symbol = "ELF"
    });
    Assert.True(minerBalance.Balance > previousBalance); // Received rewards despite being banned
    
    // Step 6: Trigger transition to Round N+2
    await ProduceNextRoundBlock(GetExtraBlockProducer(roundN1));
    
    // Step 7: NOW the evil miner is finally removed
    var roundN2 = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.DoesNotContain(evilMinerPubkey, roundN2.RealTimeMinersInformation.Keys);
    
    // Attempt to produce block in Round N+2 should fail
    var evilMinerTimeSlotN2 = roundN2.RealTimeMinersInformation.Values
        .First().ExpectedMiningTime;
    await AdvanceTimeTo(evilMinerTimeSlotN2);
    
    var blockResultN2 = await ProduceBlock(evilMinerPubkey);
    Assert.False(blockResultN2.Success); // Finally rejected
}
```

## Notes

This vulnerability represents a systematic architectural flaw rather than a simple implementation bug. The separation between round generation (which queries ban status) and block validation (which doesn't) creates an unavoidable one-round window where banned miners retain their privileges. The issue affects the core security guarantees of the AEDPoS consensus mechanism and allows miners who have demonstrably failed their duties to continue earning rewards and participating in consensus despite being marked for removal. The fix requires either adding ban status checks to the validation pipeline or fundamentally reordering the consensus state machine operations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L8-41)
```csharp
public class ConsensusValidationContext
{
    public long CurrentTermNumber { get; set; }
    public long CurrentRoundNumber { get; set; }

    /// <summary>
    ///     We can trust this because we already validated the pubkey
    ///     during `AEDPoSExtraDataExtractor.ExtractConsensusExtraData`
    /// </summary>
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();

    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;

    /// <summary>
    ///     Previous round information fetch from StateDb.
    /// </summary>
    public Round PreviousRound { get; set; }

    /// <summary>
    ///     This filed is to prevent one miner produces too many continues blocks
    ///     (which may cause problems to other parts).
    /// </summary>
    public LatestPubkeyToTinyBlocksCount LatestPubkeyToTinyBlocksCount { get; set; }

    public AElfConsensusHeaderInformation ExtraData { get; set; }
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-306)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-75)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-176)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```
