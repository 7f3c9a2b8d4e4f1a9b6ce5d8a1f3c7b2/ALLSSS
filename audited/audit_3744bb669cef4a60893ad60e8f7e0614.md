### Title
Non-Deterministic Extra Block Producer Selection Leads to Consensus Breakdown

### Summary
The `GetExtraBlockProducerInformation()` method uses `.First()` on a protobuf MapField without explicit ordering, which has undefined iteration order. If multiple miners have `IsExtraBlockProducer = true`, different nodes will non-deterministically select different extra block producers, causing consensus failure. No validation exists to enforce the invariant that exactly one miner must be the extra block producer.

### Finding Description

The vulnerability exists in `GetExtraBlockProducerInformation()` which retrieves the extra block producer from the current round: [1](#0-0) 

The `RealTimeMinersInformation` field is defined as a protobuf map: [2](#0-1) 

Protobuf maps in C# are implemented as `MapField<TKey, TValue>`, which does **not guarantee iteration order**. The codebase explicitly handles this determinism requirement elsewhere by using explicit sorting: [3](#0-2) 

However, the problematic `First()` call has no such ordering. By design, only ONE miner should have `IsExtraBlockProducer = true`, set during round generation: [4](#0-3) [5](#0-4) 

**Critical Gap**: Round data enters the system through external input via `NextRoundInput` and `NextTermInput`, which are converted directly to `Round` objects: [6](#0-5) [7](#0-6) 

The `AddRoundInformation()` method stores rounds without validation: [8](#0-7) 

None of the validation providers check for exactly one extra block producer: [9](#0-8) [10](#0-9) 

### Impact Explanation

This vulnerability causes **complete consensus breakdown**:

1. **Consensus Integrity Violation**: When `GetExtraBlockProducerInformation()` is called to determine who produces the extra block for round termination, different nodes may return different miners due to non-deterministic map iteration. [11](#0-10) [12](#0-11) 

2. **Blockchain Halt**: Nodes will not agree on:
   - Which miner should produce the next block
   - Block validation results
   - Round transition timing

3. **Network Fork**: Different subsets of nodes may follow different miners, creating irreconcilable chain forks.

4. **Affected Parties**: ALL network participants - validators cannot reach consensus, users cannot transact, the entire blockchain becomes non-functional.

### Likelihood Explanation

**Likelihood: HIGH** - The attack is practical and requires minimal sophistication:

1. **Entry Point**: The `NextRound` and `NextTerm` methods are publicly callable by any current miner: [13](#0-12) 

2. **Attacker Capabilities**: Any miner in the active set can:
   - Generate a `NextRoundInput` or `NextTermInput` with multiple miners having `IsExtraBlockProducer = true`
   - Submit this as a consensus transaction
   - The contract will accept and store this invalid state

3. **Attack Complexity**: LOW
   - Simply modify the `MinerInRound` objects to set multiple `IsExtraBlockProducer` flags to `true` before creating the input
   - No complex state manipulation or timing requirements

4. **Detection**: DIFFICULT
   - The invalid state is silently accepted
   - Consensus failure appears as a network issue rather than malicious input
   - No validation logs or rejection occurs

5. **Economic Rationality**: An adversarial miner could halt the network to:
   - Short blockchain-dependent applications
   - Extort the network for recovery
   - Attack competitors running on the chain

### Recommendation

1. **Add Validation in NextRound/NextTerm Processing**:
   ```csharp
   private void ValidateExtraBlockProducerUniqueness(Round round)
   {
       var extraBlockProducerCount = round.RealTimeMinersInformation.Values
           .Count(m => m.IsExtraBlockProducer);
       Assert(extraBlockProducerCount == 1, 
           $"Exactly one extra block producer required, found {extraBlockProducerCount}");
   }
   ```
   Call this before `AddRoundInformation()` in both `ProcessNextRound` and `ProcessNextTerm`.

2. **Add Deterministic Ordering in GetExtraBlockProducerInformation**:
   ```csharp
   private MinerInRound GetExtraBlockProducerInformation()
   {
       return RealTimeMinersInformation
           .OrderBy(bp => bp.Key) // Sort by pubkey for determinism
           .First(bp => bp.Value.IsExtraBlockProducer).Value;
   }
   ```

3. **Add Validation Provider**: Create `ExtraBlockProducerValidationProvider` that enforces uniqueness for all round-changing behaviors.

4. **Add Test Cases**:
   - Test that submitting a round with zero extra block producers is rejected
   - Test that submitting a round with multiple extra block producers is rejected
   - Test that `GetExtraBlockProducerInformation()` with sorted input returns consistent results

### Proof of Concept

**Required Initial State**:
- Active miner with permission to submit consensus transactions
- Current round in progress

**Attack Steps**:

1. Miner generates next round normally using `GenerateNextRoundInformation()`

2. Miner modifies the generated round to set multiple `IsExtraBlockProducer` flags:
   ```
   nextRound.RealTimeMinersInformation["miner1"].IsExtraBlockProducer = true;
   nextRound.RealTimeMinersInformation["miner2"].IsExtraBlockProducer = true;
   ```

3. Miner creates `NextRoundInput` with the modified round and submits via `NextRound()` transaction

4. Contract calls `ToRound()` which preserves all `IsExtraBlockProducer` flags without validation

5. Contract calls `AddRoundInformation()` which stores the invalid round state

6. When any node calls `GetExtraBlockProducerInformation()` via consensus command generation:
   - Node A's MapField iterates as: `{miner1, miner2}` → returns `miner1`
   - Node B's MapField iterates as: `{miner2, miner1}` → returns `miner2`

7. **Expected Result**: All nodes agree on one extra block producer
   **Actual Result**: Nodes disagree, consensus breaks down, blockchain halts

**Success Condition**: Network cannot produce the next block because nodes expect different miners to be the extra block producer, causing validation failures and chain forks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** protobuf/aedpos_contract.proto (L243-247)
```text
message Round {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
```

**File:** src/AElf.Kernel.SmartContractExecution/Application/BlockExecutingService.cs (L216-230)
```csharp
        };
        foreach (var returnSet in executionReturnSetCollection.Executed)
        {
            foreach (var change in returnSet.StateChanges)
            {
                blockStateSet.Changes[change.Key] = change.Value;
                blockStateSet.Deletes.Remove(change.Key);
            }

            foreach (var delete in returnSet.StateDeletes)
            {
                blockStateSet.Deletes.AddIfNotContains(delete.Key);
                blockStateSet.Changes.Remove(delete.Key);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-66)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L27-28)
```csharp
            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-38)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MiningTimeArrangingService.cs (L22-25)
```csharp
        public static Timestamp ArrangeExtraBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
        {
            return round.ArrangeAbnormalMiningTime(pubkey, currentBlockTime);
        }
```
