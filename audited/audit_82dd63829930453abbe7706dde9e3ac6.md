### Title
Missing OutValue Uniqueness Check Allows Miners to Manipulate Mining Order Through Duplicate UpdateValue Submissions

### Summary
The `NewConsensusInformationFilled()` validation function fails to verify that a miner has not already submitted an OutValue in the current round, allowing malicious miners to overwrite their previously committed OutValue. This violates the consensus invariant that each miner should commit exactly once per round, enabling mining order manipulation for the next round and breaking the randomness property of the AEDPoS consensus mechanism.

### Finding Description

The vulnerability exists in the validation flow for UpdateValue consensus transactions: [1](#0-0) 

The `NewConsensusInformationFilled()` method only validates that the ProvidedRound (newly submitted data) contains a non-null OutValue with bytes, but does not check whether the BaseRound (current state from StateDb) already has an OutValue set for this miner.

The root cause is compounded by the validation flow in `ValidateBeforeExecution()`: [2](#0-1) 

Before validation occurs, `RecoverFromUpdateValue` is called, which overwrites the BaseRound's OutValue: [3](#0-2) 

This means the original OutValue from BaseRound is lost before the validation provider can check it. When validation runs, both BaseRound and ProvidedRound contain the new OutValue, making it impossible to detect that the miner already had an OutValue set.

According to the AEDPoS consensus design, each miner should call UpdateValue once per round (their first block), and subsequent blocks should use TinyBlock behavior. However, the contract-side validation does not enforce this - it only exists as client-side guidance: [4](#0-3) 

When a duplicate UpdateValue is processed, the old OutValue is simply overwritten: [5](#0-4) 

### Impact Explanation

**Consensus Integrity Violation**: The attack allows a malicious miner to change their committed OutValue mid-round after observing other miners' submissions. Since mining order for the next round is calculated based on the signature (which derives from OutValue), this enables:

1. **Mining Order Manipulation**: The attacker can selectively choose between multiple OutValues to optimize their position in the next round's mining schedule. The order calculation uses the signature value modulo miner count: [6](#0-5) 

2. **Randomness Manipulation**: The InValue/OutValue commitment scheme is designed to provide unpredictable randomness for determining mining order. By allowing OutValue changes after commitment, the attacker can bias this randomness.

3. **Fairness Compromise**: Honest miners commit to their OutValue in their first block and cannot change it, while the attacker can adaptively choose the optimal OutValue based on other miners' submissions.

The severity is High because it directly undermines the core security property of the consensus mechanism - that miners must commit to randomness before seeing others' commitments.

### Likelihood Explanation

**Attack Complexity**: Low - The attacker only needs to:
1. Be an elected miner with a time slot
2. Modify their node software to generate multiple UpdateValue transactions instead of using TinyBlock after the first block
3. Submit the first UpdateValue with OutValue A in block height H
4. Submit the second UpdateValue with OutValue B in block height H+1 (same round)

**Preconditions**: The attacker must be an elected miner, which requires staking tokens and receiving votes. However, once elected, executing the attack requires no additional privileges or complex state manipulation.

**Detection Constraints**: The per-block execution check prevents multiple UpdateValue calls in the same block: [7](#0-6) 

However, this only prevents same-block duplicates, not same-round duplicates across multiple blocks, which is the vulnerability scenario.

**Economic Rationality**: The attack cost is minimal - only transaction fees for the additional blocks. The benefit is significant: favorable positioning in the next round's mining schedule, potentially allowing more blocks to be mined or earlier time slots.

**Probability**: High - Any malicious miner can execute this attack whenever they desire a better mining position in the next round.

### Recommendation

**Primary Fix**: Add validation in `UpdateValueValidationProvider` to check that the miner's OutValue in the original BaseRound (before recovery) is null:

```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    // NEW: Check that miner hasn't already submitted OutValue in current round
    var baseRoundMinerInfo = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    if (baseRoundMinerInfo.OutValue != null && baseRoundMinerInfo.OutValue.Value.Any())
    {
        return false; // Miner already submitted OutValue in this round
    }
    
    // Existing check for ProvidedRound
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    return minerInRound.OutValue != null && minerInRound.Signature != null &&
           minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
}
```

**Alternative Fix**: Move the BaseRound validation check before the `RecoverFromUpdateValue` call in `ValidateBeforeExecution()`: [8](#0-7) 

Add before line 46:
```csharp
// For UpdateValue, ensure miner hasn't already submitted OutValue this round
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
{
    var minerPubkey = extraData.SenderPubkey.ToHex();
    if (baseRound.RealTimeMinersInformation.ContainsKey(minerPubkey))
    {
        var existingOutValue = baseRound.RealTimeMinersInformation[minerPubkey].OutValue;
        if (existingOutValue != null && existingOutValue.Value.Any())
        {
            return new ValidationResult { Success = false, Message = "Miner already submitted OutValue in current round." };
        }
    }
}
```

**Test Cases**: Add regression tests verifying:
1. First UpdateValue in a round succeeds
2. Second UpdateValue in same round is rejected with appropriate error
3. UpdateValue followed by TinyBlock succeeds (correct behavior)
4. UpdateValue in new round succeeds after previous round completed

### Proof of Concept

**Initial State**:
- Current round N with 5 miners
- Attacker is Miner 1 with time slot at T0+4s
- Attacker's OutValue in BaseRound is null (hasn't mined yet)

**Attack Sequence**:

1. **Block Height H (T0+4s)**: Attacker produces first block with UpdateValue
   - Input: OutValue = Hash(InValue_A), Signature = S_A
   - Validation: NewConsensusInformationFilled checks ProvidedRound has OutValue ✓
   - Result: Round state updated with OutValue = Hash(InValue_A)

2. **Block Height H+1 (T0+5s)**: Attacker produces second block with UpdateValue (instead of TinyBlock)
   - Input: OutValue = Hash(InValue_B), Signature = S_B (different from A)
   - Validation flow:
     - BaseRound loaded from state (has OutValue = Hash(InValue_A))
     - RecoverFromUpdateValue overwrites BaseRound.OutValue with Hash(InValue_B)
     - NewConsensusInformationFilled checks ProvidedRound has OutValue ✓
     - ValidatePreviousInValue passes ✓
   - Result: Round state updated with OutValue = Hash(InValue_B), overwriting A

3. **Impact**: 
   - Expected: Mining order for round N+1 based on Hash(InValue_A)
   - Actual: Mining order for round N+1 based on Hash(InValue_B)
   - Attacker chose InValue_B to optimize their position in next round

**Success Condition**: The second UpdateValue transaction is accepted and modifies the attacker's SupposedOrderOfNextRound and FinalOrderOfNextRound values: [9](#0-8) 

This demonstrates the attacker's ability to manipulate their mining order after seeing other miners' commitments, violating the consensus randomness property.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-18)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-62)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L242-247)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-22)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```
