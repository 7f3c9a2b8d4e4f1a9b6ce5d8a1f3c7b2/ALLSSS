### Title
Deposit Underfunding via AmountToTokenConvert Manipulation in EnableConnector

### Summary
The `EnableConnector()` function allows an attacker to artificially reduce the required base token deposit by setting a high `AmountToTokenConvert` value. While these tokens are transferred to the contract, the deposit balance is set to the reduced amount, creating a severe mismatch between available token supply and backing reserves. This breaks the Bancor pricing invariant and enables purchase of tokens at manipulated prices, leading to deposit pool depletion.

### Finding Description

The vulnerability exists in the interaction between `GetNeededDeposit()` and `EnableConnector()` functions: [1](#0-0) 

In `GetNeededDeposit()`, the calculation subtracts `AmountToTokenConvert` from tokens requiring deposit backing. This assumes those tokens reduce the "outside supply" that needs backing. [2](#0-1) 

The `needDeposit` is calculated only for the remaining `amountOutOfTokenConvert`. [3](#0-2) 

In `EnableConnector()`, the `AmountToTokenConvert` tokens are actually transferred to the contract, making them part of the tradeable supply. [4](#0-3) 

**Critical Issue**: The `DepositBalance` is set to only the reduced `needDeposit` amount, not accounting for the tokens now held in the contract. [5](#0-4) 

When `Buy()` operations occur, `GetSelfBalance()` returns the actual token balance for the resource connector and the inadequate `DepositBalance` for the deposit connector, breaking the Bancor reserve ratio. [6](#0-5) 

No authorization check exists on `EnableConnector()` - any caller with the required tokens can enable a connector that governance has added.

### Impact Explanation

**Direct Fund Impact:**
- An attacker can create a token with total supply 10,000,000
- Call `EnableConnector` with `AmountToTokenConvert = 9,999,000`
- This reduces `amountOutOfTokenConvert` to only 1,000 tokens
- Required deposit calculated for 1,000 tokens ≈ 0.01% of proper amount
- Contract now holds 9,999,000 tokens backed by deposit for only 1,000
- Users can purchase these tokens at artificially low prices via Bancor formula
- The minimal deposit pool is rapidly drained
- Attacker loses tokens but causes economic damage to protocol

**Protocol Damage:**
- Breaks Bancor pricing mechanism's fundamental reserve backing invariant
- Creates markets with 99.9%+ underfunded reserves
- Enables massive arbitrage opportunities
- Undermines trust in TokenConverter pricing
- Can be repeated for multiple token pairs

**Affected Parties:**
- TokenConverter contract loses economic integrity
- Users who rely on fair Bancor pricing get manipulated prices
- Legitimate token projects have compromised markets
- Protocol reputation and economic security damaged

### Likelihood Explanation

**Reachable Entry Point:**
Public method `EnableConnector()` is callable by anyone without authorization checks. Only requires connector to be pre-configured by governance via `AddPairConnector()`.

**Feasible Preconditions:**
- Attacker creates their own token (standard capability)
- Governance adds connector for token (social engineering or legitimate listing)
- Attacker must have token supply to transfer (self-issued)
- Attacker must provide minimal deposit (extremely low cost)

**Execution Practicality:**
- Single transaction call to `EnableConnector()`
- Standard token transfer operations via MultiToken contract
- No complex timing or state requirements
- Deterministic outcome

**Economic Rationality:**
- Cost: minimal deposit (~0.01% of proper amount) + transaction fees
- Impact: disrupts entire token pair market, creates arbitrage, damages protocol
- Viable for griefing, market manipulation, or coordinated attacks
- Even losing the transferred tokens may be acceptable for malicious actors

**Detection/Operational Constraints:**
- On-chain action is visible but may appear legitimate
- No automatic detection mechanism exists
- Damage occurs immediately upon enabling
- Cannot be easily reverted once connector is enabled

**Probability: HIGH** - The attack is straightforward, low-cost, and achieves significant impact. Any token issuer can exploit this once governance adds their connector.

### Recommendation

**Immediate Fix:**
Modify `EnableConnector()` to validate that deposit backs ALL tokens that will be in the contract:

```
1. Calculate total tradeable supply = balance + AmountToTokenConvert
2. Calculate required deposit for total tradeable supply
3. Require depositor to provide full backing amount
4. Set DepositBalance to account for entire tradeable supply
```

**Code-Level Mitigation:**
In `GetNeededDeposit()`, change the calculation to:
```csharp
var amountRequiringDeposit = tokenInfo.TotalSupply - balance; // Don't subtract AmountToTokenConvert
```

Or alternatively in `EnableConnector()`, add validation:
```csharp
var totalTradeableSupply = balance + input.AmountToTokenConvert;
Assert(needDeposit.NeedAmount >= CalculateRequiredDeposit(totalTradeableSupply), 
    "Insufficient deposit for tradeable token supply");
```

**Additional Protections:**
1. Add authorization check: only connector controller can call `EnableConnector()`
2. Add assertion to prevent enabling already-enabled connectors
3. Implement deposit ratio bounds checking (e.g., min 50% reserve ratio)
4. Add events and monitoring for deposit ratio anomalies

**Test Cases:**
1. Test enabling with AmountToTokenConvert = 99% of supply, verify deposit is sufficient
2. Test that post-enable pricing matches expected Bancor calculations
3. Test that deposit cannot be underfunded regardless of AmountToTokenConvert value
4. Test unauthorized callers cannot enable connectors

### Proof of Concept

**Initial State:**
- Token "ATTACK" created with total supply: 10,000,000
- All tokens issued to attacker address
- Governance adds pair connector: weight 0.05/0.05, virtual balance 1,000,000
- Contract balance of ATTACK: 0

**Attack Sequence:**

1. Attacker calls `EnableConnector()`:
   - `TokenSymbol = "ATTACK"`
   - `AmountToTokenConvert = 9,999,000`

2. `GetNeededDeposit()` executes:
   - `amountOutOfTokenConvert = 10,000,000 - 0 - 9,999,000 = 1,000`
   - `needDeposit = BancorHelper.GetAmountToPayFromReturn(1,000,000, 0.05, 10,000,000, 0.05, 1,000)`
   - With equal weights: `needDeposit ≈ 100` base tokens

3. `EnableConnector()` completes:
   - Transfers 100 base tokens from attacker
   - Transfers 9,999,000 ATTACK tokens to contract
   - Sets `DepositBalance[(NT)ATTACK] = 100`
   - Enables both connectors

**Result:**
- Contract holds 9,999,000 tradeable ATTACK tokens
- Deposit backing = 100 base tokens (should be ~999,900)
- Reserve ratio = 0.001% (should be ~50%)

**Expected vs Actual:**
- **Expected**: Deposit should back entire tradeable supply (~999,900 base tokens)
- **Actual**: Deposit only backs 1,000 tokens (100 base tokens)
- **Gap**: 99.99% underfunded reserve pool

**Success Condition:**
Users can now buy ATTACK tokens at prices calculated with `fromConnectorBalance = 100 + 1,000,000 virtual = 1,000,100` and `toConnectorBalance = 9,999,000`, resulting in prices ~1000x cheaper than properly backed market, completely draining the 100 token deposit after minimal purchases.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-73)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L74-84)
```csharp
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-275)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L287-295)
```csharp
        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L297-297)
```csharp
        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```
