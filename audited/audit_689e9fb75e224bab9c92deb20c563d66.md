### Title
Incorrect CachedDelayTotalShares Corruption via Premature Beneficiary Removal Leading to Profit Loss

### Summary
When a beneficiary is removed during the delay window (between addition period P and their StartPeriod P+D), the RemoveProfitDetails function incorrectly uses `scheme.CurrentPeriod` as the key for all removed shares, causing RemoveBeneficiary to subtract these shares from CachedDelayTotalShares entries that were set before the beneficiary even existed. This results in under-counted or zero total shares for affected periods, causing legitimate beneficiaries' profits to be burned.

### Finding Description

The vulnerability exists in the interaction between `RemoveProfitDetails` and `RemoveBeneficiary`: [1](#0-0) [2](#0-1) 

At this critical line, ALL removed profit details are added to RemovedDetails using `scheme.CurrentPeriod` as the key, regardless of when the beneficiary was actually added to the scheme. [3](#0-2) 

The RemoveBeneficiary function then subtracts these shares from CachedDelayTotalShares for periods CurrentPeriod through CurrentPeriod+DelayDistributePeriodCount-1.

**Root Cause**: When a beneficiary is added at period P with DelayDistributePeriodCount D: [4](#0-3) 

Their StartPeriod is set to P+D, and their shares are immediately added to scheme.TotalShares. Each subsequent distribution caches this total, so the beneficiary's shares first appear in CachedDelayTotalShares[P+D] (set during period P's distribution).

If the beneficiary is removed at period R where P < R < P+D:
- Code subtracts shares from Cached[R], Cached[R+1], ..., Cached[R+D-1]
- But beneficiary only exists in Cached[P+D], Cached[P+D+1], ..., Cached[R+D-1]
- Result: Cached[R] through Cached[P+D-1] are incorrectly reduced

**Why Protections Fail**: The removal is permitted because: [5](#0-4) 

A beneficiary added with EndPeriod < CurrentPeriod + DelayDistributePeriodCount can be removed once EndPeriod < CurrentPeriod, triggering the vulnerability without requiring CanRemoveBeneficiaryDirectly.

### Impact Explanation

**Direct Fund Loss**: When CachedDelayTotalShares for a period is incorrectly reduced to zero or near-zero: [6](#0-5) [7](#0-6) 

The distribution uses totalShares = 0, causing profits to be burned instead of distributed to legitimate beneficiaries.

**Quantified Damage**: 
- For each affected period with corrupted cache, 100% of that period's profit is lost
- If DelayDistributePeriodCount = 3 and attack executed at optimal timing, up to 2 periods of profit can be destroyed
- Affects ALL legitimate beneficiaries who should receive profit from corrupted periods

**Who is Affected**: All beneficiaries who were entitled to profits from periods whose CachedDelayTotalShares entries get corrupted.

**Severity Justification**: HIGH - Direct protocol fund loss through profit burning, affects multiple periods, exploitable without special privileges beyond scheme management.

### Likelihood Explanation

**Attacker Capabilities**: 
- Must be scheme manager (authorized via Context.Sender check) or TokenHolder contract [8](#0-7) 

**Attack Complexity**: Low
1. Add beneficiary with EndPeriod = CurrentPeriod (minimum allowed)
2. Wait one period for distribution to complete
3. Remove beneficiary (now EndPeriod < CurrentPeriod)
4. CachedDelayTotalShares corruption occurs automatically

**Feasibility Conditions**:
- Scheme must exist with DelayDistributePeriodCount > 1
- Attacker controls scheme manager role (legitimate role, not compromise)
- No additional permissions required if using EndPeriod expiration method

**Detection Constraints**: Difficult to detect as operations appear legitimate (adding/removing beneficiaries are normal operations)

**Probability**: HIGH - The attack scenario is straightforward, requires no special conditions beyond normal scheme management operations, and the vulnerable code path executes deterministically.

### Recommendation

**Code-Level Mitigation**: Modify RemoveProfitDetails to track the actual period when each beneficiary was added, not just use CurrentPeriod for all removals:

```csharp
// In RemoveProfitDetails, replace line 358:
// Instead of: removedDetails.TryAdd(scheme.CurrentPeriod, profitDetail.Shares);
// Track the period when shares actually entered cached values:
var firstCachedPeriod = Math.Max(profitDetail.StartPeriod, scheme.CurrentPeriod);
removedDetails.TryAdd(firstCachedPeriod, profitDetail.Shares);
```

Or alternatively, in RemoveBeneficiary, adjust the update loop:

```csharp
// Modify lines 247-249 to only update periods where beneficiary actually existed:
var startUpdatePeriod = Math.Max(removedMinPeriod, /* period when beneficiary was added + D */);
for (var removedPeriod = startUpdatePeriod;
     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
     removedPeriod++)
```

**Invariant Checks**: Add assertion that CachedDelayTotalShares values never become negative or unexpectedly zero during removal operations.

**Test Cases**: Add test covering:
1. Add beneficiary at period P with EndPeriod = P
2. Remove at period P+1 (before StartPeriod = P+D)
3. Verify CachedDelayTotalShares[P+1] through CachedDelayTotalShares[P+D-1] remain unchanged
4. Verify only CachedDelayTotalShares[P+D] onwards are updated

### Proof of Concept

**Initial State**:
- Create scheme with DelayDistributePeriodCount = 3
- Period 0: Add beneficiary A (1000 shares, EndPeriod = 100, StartPeriod = 3)
- Period 0: Distribute → CachedDelayTotalShares[3] = 1000, CurrentPeriod = 1
- Period 1: Distribute → CachedDelayTotalShares[4] = 1000, CurrentPeriod = 2

**Attack Steps**:
1. Period 2 (CurrentPeriod = 2): Add beneficiary B (1000 shares, **EndPeriod = 2**), TotalShares = 2000
2. Period 2: Distribute → CachedDelayTotalShares[5] = 2000, CurrentPeriod = 3
3. Period 3 (CurrentPeriod = 3): B's EndPeriod (2) < CurrentPeriod (3), call RemoveBeneficiary for B
   - RemoveProfitDetails returns {3: 1000}
   - Updates CachedDelayTotalShares[3] = 1000 - 1000 = **0**
   - Updates CachedDelayTotalShares[4] = 1000 - 1000 = **0**
   - Updates CachedDelayTotalShares[5] = 2000 - 1000 = 1000
4. Period 4: DistributeProfits uses CachedDelayTotalShares[4] = **0** → totalShares = 0 → **profit burned**

**Expected Result**: CachedDelayTotalShares[4] should remain 1000 (B was not included when it was set at period 1)

**Actual Result**: CachedDelayTotalShares[4] becomes 0, causing period 4's profit to be burned instead of distributed to beneficiary A

**Success Condition**: Verify that calling GetDistributedProfitsInfo for period 4 shows TotalShares = 0 and profits were burned (negative AmountsMap value), confirming the corruption and fund loss.

### Citations

**File:** contract/AElf.Contracts.Profit/Models/RemovedDetails.cs (L8-18)
```csharp
        public void TryAdd(long key, long value)
        {
            if (ContainsKey(key))
            {
                this[key] = this[key].Add(value);
            }
            else
            {
                this[key] = value;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L237-239)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L243-258)
```csharp
        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L358-358)
```csharp
                removedDetails.TryAdd(scheme.CurrentPeriod, profitDetail.Shares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-486)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);
```
