### Title
Missing Upper Bound Validation on Method Fee Allows Economic Denial of Service

### Summary
The `SetMethodFee` function in VoteContract (and all ACS1 implementations) lacks upper bound validation on the `BasicFee` parameter, only checking `amount >= 0`. An attacker with controller access can set fees to values approaching `long.MaxValue` (9.2 quintillion), making methods economically unusable for all users since no realistic token balance could cover such fees.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:** The validation function `AssertValidToken` only enforces a lower bound check: [2](#0-1) 

The validation performs:
1. Check `amount >= 0` (line 101) - prevents negative fees only
2. Check token exists and is available for method fees
3. **NO upper bound validation whatsoever**

**Why Protections Fail:**
The method fee controller defaults to the Parliament default organization: [3](#0-2) 

If this governance controller is compromised or acts maliciously, they can set `BasicFee` to extreme values like `9_000_000_000_00000000` (90 billion tokens with 8 decimals).

**Execution Path:**
When users attempt to call a method with such fees, the fee charging mechanism fails because their balance is insufficient: [4](#0-3) 

The transaction returns "Transaction fee not enough" and reverts, effectively DOSing the function.

### Impact Explanation

**Concrete Harm:**
- Methods become **permanently economically inaccessible** to all users
- Typical token supplies are far below required amounts (e.g., ElectionTokenTotalSupply = 1 billion tokens): [5](#0-4) 
- Setting a fee of 90 billion tokens would exceed the entire circulating supply by 90x
- This creates a **complete operational DOS** of critical contract functions

**Affected Parties:**
- All users of the VoteContract (and any ACS1 contract)
- Protocol governance and voting mechanisms become unusable
- No remediation possible without governance action (which may also be DOSed)

**Severity Justification:** HIGH - Complete denial of service of contract functionality with no recovery mechanism if governance methods themselves are DOSed.

### Likelihood Explanation

**Attacker Capabilities:** Requires controller access (governance control) - the question explicitly assumes "attacker with controller access" meaning governance is compromised.

**Attack Complexity:** Trivial - single `SetMethodFee` transaction with malicious parameters.

**Feasibility Conditions:**
- Governance compromise through: key compromise, malicious insider, social engineering, or proposal manipulation
- No additional technical barriers once controller access obtained

**Economic Rationality:** 
- Zero cost to execute (just one transaction)
- Devastating impact (DOS of entire contract)
- Motivated by: ransom demands, competitive sabotage, malicious governance actors

**Detection:** Difficult to detect before execution; once set, damage is immediate and visible.

### Recommendation

**Code-Level Mitigation:**
Add maximum fee validation in `AssertValidToken` function (line 101):

```csharp
// Define reasonable maximum (e.g., 10,000 tokens = 10_000_00000000)
private const long MaxBasicFee = 10_000_00000000;

private void AssertValidToken(string symbol, long amount)
{
    Assert(amount >= 0, "Invalid amount.");
    Assert(amount <= MaxBasicFee, "Fee exceeds maximum allowed value.");
    // ... rest of validation
}
```

**Invariant Checks:**
- Enforce `0 <= BasicFee <= MaxBasicFee` for all method fee settings
- Make `MaxBasicFee` governance-adjustable but with its own reasonable upper limit

**Test Cases:**
1. Test `SetMethodFee` with `BasicFee = long.MaxValue` - should fail
2. Test `SetMethodFee` with `BasicFee = MaxBasicFee + 1` - should fail  
3. Test `SetMethodFee` with `BasicFee = MaxBasicFee` - should succeed
4. Verify transaction fee charging fails gracefully with extreme fees

### Proof of Concept

**Initial State:**
- VoteContract deployed with default Parliament controller
- Controller compromised/malicious

**Attack Sequence:**
1. Controller calls `SetMethodFee` with:
   ```
   MethodName: "Register"
   Fees: [{ Symbol: "ELF", BasicFee: 9_000_000_000_00000000 }]
   ``` [6](#0-5) 

2. Transaction succeeds (passes `amount >= 0` check)

3. Any user attempts to call `Register` method

4. Fee charging mechanism calculates required fee: 90 billion ELF tokens

5. User's balance checked (assume 1,000 ELF - realistic amount)

6. Charging fails: `existingBalance (1,000) < amountToChargeBaseFee (90 billion)`

7. Transaction reverts with "Transaction fee not enough"

**Expected Result:** User successfully calls `Register` with reasonable fee

**Actual Result:** All users unable to call `Register` - method is economically DOSed

**Success Condition:** Method permanently unusable until governance reverses the fee setting (which may itself be DOSed if governance methods have same malicious fees)

---

**Notes:**
This vulnerability pattern exists across ALL ACS1 implementations in the codebase (Parliament, Association, Referendum, Election, Treasury, Token, etc.) [7](#0-6) [8](#0-7) 

The absence of upper bounds violates defense-in-depth principles and creates systemic risk across the entire protocol.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L71-85)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L99-108)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L118-125)
```csharp
        ModifyBalance(fromAddress, bill, allowanceBill);
        var chargingOutput = new ChargeTransactionFeesOutput { Success = chargingResult };
        if (!chargingResult)
            chargingOutput.ChargingInformation = "Transaction fee not enough.";
        
        Context.LogDebug(() => "TryToChargeTransactionFee End");
        Context.LogDebug(() => "ChargeTransactionFees End");
        return chargingOutput;
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L25-25)
```csharp
    public const long ElectionTokenTotalSupply = 1_000_000_000_00000000;
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L80-89)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L76-85)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```
