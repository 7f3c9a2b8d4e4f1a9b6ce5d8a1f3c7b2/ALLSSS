### Title
Last Irreversible Block (LIB) Progression Can Be Prevented Through Insufficient Miner Overlap Between Consecutive Rounds

### Summary
The LIB calculation in the AEDPoS consensus contract returns 0 when fewer than MinersCountOfConsent (2/3+1) miners who produced blocks in the current round also produced blocks in the previous round. This condition can occur both in legitimate operational scenarios (network recovery, mid-term miner replacements) and through Byzantine coordination, causing LIB to freeze indefinitely while block production continues, breaking finality guarantees and cross-chain operations.

### Finding Description

The vulnerability exists in the `LastIrreversibleBlockHeightCalculator.Deconstruct()` method [1](#0-0) .

The method calculates LIB by:
1. Getting miners who produced blocks in the current round [2](#0-1) 
2. Retrieving their `ImpliedIrreversibleBlockHeight` values from the previous round [3](#0-2) 
3. Checking if the count meets the consensus threshold [4](#0-3) 

The `GetSortedImpliedIrreversibleBlockHeights` method filters to only include miners with `ImpliedIrreversibleBlockHeight > 0` [5](#0-4) , which requires they produced a block in the previous round.

Miners set their `ImpliedIrreversibleBlockHeight` to `Context.CurrentHeight` when producing blocks [6](#0-5) . When generating new rounds, `MinerInRound` instances are created without explicitly initializing this field [7](#0-6) , defaulting to 0.

The `MinersCountOfConsent` threshold is calculated as `RealTimeMinersInformation.Count * 2 / 3 + 1` [8](#0-7) .

**Why Existing Protections Fail:**

The LIB update check prevents regression [9](#0-8)  but doesn't prevent the LIB from freezing at its current value. There are no explicit safeguards requiring minimum miner overlap between rounds, and the system relies on natural stabilization for recovery.

**Trigger Conditions:**

1. **Network Recovery**: After network partitions or failures, when miners resume producing but with insufficient overlap from the previous round
2. **Mid-Term Miner Replacements**: When evil miners are replaced [10](#0-9) , new miners lack previous round data
3. **Byzantine Coordination**: Miners deliberately alternate participation to minimize consecutive round overlap

### Impact Explanation

**Critical Consensus Invariant Violated**: The "LIB height rules" invariant requiring correct LIB progression is broken, causing:

1. **Cross-Chain Operations Failure**: The LIB is essential for cross-chain indexing and verification [11](#0-10)  (reference from search results). When LIB freezes, cross-chain data cannot be safely indexed, breaking parent-chain and side-chain synchronization.

2. **Finality Guarantees Compromised**: Applications and users rely on the `IrreversibleBlockFound` event [12](#0-11)  for transaction finality. A frozen LIB means no new blocks become irreversible, leaving all recent transactions in an unfinalized state indefinitely.

3. **Operational Deception**: Block production continues normally while finality is secretly frozen, potentially misleading applications into accepting transactions as finalized when they are not.

4. **System-Wide Impact**: All entities relying on LIB for security guarantees are affected, including cross-chain bridges, exchanges, and smart contracts depending on block finality.

**Severity: High** - Breaks critical consensus functionality and cross-chain operations while appearing operational.

### Likelihood Explanation

**Feasibility: Medium to High**

**Legitimate Trigger Scenarios** (No Byzantine Behavior Required):
- Network disruptions causing inconsistent miner participation across rounds (common in distributed systems)
- Mid-term evil miner replacements when >1/3 of miners exceed the tolerable missed time slots threshold [13](#0-12)  (4320 slots = 3 days, per search results)
- System recovery scenarios after outages

**Byzantine Attack Scenario**:
- Requires >1/3 of miners to coordinate alternating participation
- Miners who skip blocks accumulate penalties [14](#0-13)  but can sustain the attack for extended periods
- Economic cost: Mining reward loss during skipped rounds, eventual evil node marking after 3 days

**Attack Complexity**: Low to Medium
- Legitimate triggers require no attacker action
- Byzantine coordination requires >1/3 miner collusion
- No sophisticated exploit logic needed

**Detection**: Difficult - the chain continues producing blocks normally, masking the LIB freeze until cross-chain operations fail or applications check finality explicitly.

**Recovery**: Relies on natural stabilization when miner participation normalizes, with no explicit recovery mechanism or circuit breakers.

### Recommendation

**Immediate Mitigations:**

1. **Add Fallback LIB Calculation**: When the primary calculation returns 0 due to insufficient overlap, implement a fallback that uses the minimum `ImpliedIrreversibleBlockHeight` from all miners who produced in the previous round (not filtered by current round producers):

```
if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
{
    // Fallback: use conservative LIB from all previous round miners
    var allPreviousHeights = _previousRound.RealTimeMinersInformation.Values
        .Where(m => m.ImpliedIrreversibleBlockHeight > 0)
        .Select(m => m.ImpliedIrreversibleBlockHeight)
        .ToList();
    
    if (allPreviousHeights.Any())
    {
        allPreviousHeights.Sort();
        libHeight = allPreviousHeights[0]; // Most conservative estimate
        return;
    }
    
    libHeight = 0;
    return;
}
```

2. **Fix Code Quality Issue**: Add explicit return statement at line 22 [15](#0-14)  to prevent execution flow issues.

3. **Add Monitoring**: Implement alerts when LIB hasn't advanced for N consecutive rounds to detect the condition early.

4. **Enhance LIB Validation**: Add checks in the cross-chain contract to reject operations when LIB hasn't advanced beyond a maximum staleness threshold.

**Long-Term Solutions:**

1. **Minimum Overlap Requirement**: Enforce that rounds cannot progress unless there's sufficient miner overlap with the previous round.

2. **Gradual Recovery Mechanism**: Implement logic that gradually increases the LIB even with partial overlap, using weighted averages or relaxed thresholds after detecting stalled LIB.

3. **Test Coverage**: Add regression tests for scenarios including network recovery, mid-term miner replacements, and Byzantine alternating participation patterns.

### Proof of Concept

**Initial State:**
- 7 active miners in the consensus set (A, B, C, D, E, F, G)
- MinersCountOfConsent = 7 * 2 / 3 + 1 = 5
- LIB at block height 1000

**Exploitation Sequence:**

**Round N-1 (Block Heights 1001-1007):**
1. Only miners A, B, and C produce their blocks (3 miners)
2. Miners D, E, F, G miss their time slots (legitimate: network partition, or Byzantine: coordinated skipping)
3. Extra block producer finalizes the round
4. Each of A, B, C has `ImpliedIrreversibleBlockHeight` set to their respective block heights (1001-1003)

**Round N (Block Heights 1008-1014):**
1. Miners D, E, F, and G produce their blocks (4 miners)
2. Miners A, B, C miss their time slots (network recovers for different subset, or coordinated alternation)
3. When any miner produces in Round N, LIB calculation executes:
   - `minedMiners` = [D, E, F, G] (4 pubkeys)
   - Check Round N-1 for these miners' `ImpliedIrreversibleBlockHeight`
   - D, E, F, G didn't produce in Round N-1, so they have `ImpliedIrreversibleBlockHeight = 0`
   - `impliedIrreversibleHeights` filters out 0 values, resulting in empty list
   - Count = 0 < MinersCountOfConsent (5)
   - Returns `libHeight = 0`
4. Due to check at line 272, LIB doesn't regress but also doesn't advance (stays at 1000)

**Round N+1 (Block Heights 1015-1021):**
1. Repeat alternating pattern: miners A, B, C, and one other produce
2. Again, insufficient overlap with Round N
3. LIB remains frozen at 1000

**Expected Result:** LIB should advance to heights beyond 1000 as blocks become irreversible.

**Actual Result:** LIB remains frozen at 1000 indefinitely while blocks 1001+ continue being produced without finality. Cross-chain operations referencing blocks above 1000 fail or remain pending. Applications waiting for finality never receive confirmation.

**Success Condition:** Monitoring shows `IrreversibleBlockFound` events stop firing, `ConfirmedIrreversibleBlockHeight` remains at 1000 across multiple rounds, and cross-chain indexing cannot progress beyond block 1000.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-56)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L272-281)
```csharp
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-256)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
```

**File:** src/AElf.CrossChain/CrossChainModuleEventHandler.cs (L1-1)
```csharp
using System.Threading.Tasks;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L1-1)
```csharp
namespace AElf.Contracts.Consensus.AEDPoS;
```
