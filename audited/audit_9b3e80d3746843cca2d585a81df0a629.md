### Title
Secret Sharing Mechanism Completely Broken in NextRound Transitions - Revealed InValues Lost

### Summary
The `RevealSharedInValues()` function computes and writes revealed InValues to the `currentRound` object during NextRound transitions, but these modifications are never persisted. The function returns `nextRound` instead, which does not contain the revealed values, causing complete loss of the secret sharing mechanism's output and breaking consensus integrity for miners who failed to produce blocks in the previous round.

### Finding Description

In `GetConsensusExtraDataForNextRound()`, the execution flow has a critical flaw: [1](#0-0) 

The function first generates `nextRound` from `currentRound` at line 176, then calls `RevealSharedInValues(currentRound, pubkey)` at line 189. The problem is that `RevealSharedInValues` modifies the **wrong Round object**: [2](#0-1) 

At line 52, revealed InValues are written to `currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue`. However, the function returns `nextRound` (lines 198-203 of GetConsensusBlockExtraData.cs), not `currentRound`. The `currentRound` modifications are never persisted.

When `ProcessNextRound` is called, it persists only the `nextRound` data: [3](#0-2) 

At line 156, `AddRoundInformation(nextRound)` persists the round to state: [4](#0-3) 

The revealed PreviousInValue fields computed by secret sharing reconstruction are completely lost. Moreover, `GenerateNextRoundInformation` does not copy PreviousInValue fields from currentRound to nextRound: [5](#0-4) 

Lines 29-36 show only `Pubkey`, `Order`, `ExpectedMiningTime`, `ProducedBlocks`, and `MissedTimeSlots` are copied - no `PreviousInValue`.

### Impact Explanation

**Consensus Integrity Breakdown**: The PreviousInValue field is critical for consensus security:
- Used in signature calculation for randomness generation
- Validated to ensure `HashHelper.ComputeFrom(previousInValue) == previousOutValue`
- Required for maintaining the consensus chain across rounds [6](#0-5) [7](#0-6) 

Without revealed PreviousInValues for miners who failed to produce blocks in the previous round, the secret sharing mechanism serves no purpose during NextRound transitions. These miners cannot participate correctly in subsequent consensus operations, breaking the integrity of random number generation and consensus signatures.

**Affected Parties**: All miners who did not produce blocks in round N will have missing PreviousInValue in round N+1, affecting their ability to participate in consensus validation and random number generation.

**Severity**: HIGH - This completely breaks the secret sharing security mechanism for round transitions, undermining consensus unpredictability and fairness.

### Likelihood Explanation

**Occurrence**: This bug is triggered **automatically** during every NextRound transition when secret sharing is enabled. It is not an exploit requiring attacker action, but a design flaw in normal protocol operation.

**Preconditions**: 
- Secret sharing must be enabled (checked via `IsSecretSharingEnabled()`)
- At least one NextRound transition occurs
- At least one miner failed to produce blocks in the previous round

**Complexity**: CERTAIN - This is guaranteed to fail in normal operation whenever secret sharing is enabled and round transitions occur.

**Detection**: The issue is masked because the UpdateValue flow uses a different code path (`UpdateLatestSecretPieces` with `triggerInformation.RevealedInValues`), but NextRound transitions have no such mechanism and the on-chain computed values are lost.

### Recommendation

**Immediate Fix**: Modify `GetConsensusExtraDataForNextRound` to apply revealed values to `nextRound` instead of `currentRound`. Either:

**Option 1** - Pass `nextRound` to `RevealSharedInValues`:
```csharp
RevealSharedInValues(nextRound, pubkey); // Change from currentRound to nextRound
```

**Option 2** - Use trigger information like UpdateValue does:
```csharp
if (IsSecretSharingEnabled())
{
    UpdateLatestSecretPieces(nextRound, pubkey, triggerInformation);
}
```

**Invariant Check**: Add assertion that after NextRound processing, all miners who didn't produce blocks in previous round but had sufficient encrypted/decrypted pieces should have non-null PreviousInValue.

**Test Cases**: 
1. Verify secret sharing reveals work correctly in NextRound transitions
2. Test partial revelation scenarios (some miners have insufficient pieces)
3. Verify PreviousInValue propagates correctly from round N to round N+1

### Proof of Concept

**Initial State**:
- Round N with 5 miners (A, B, C, D, E)
- Miner C failed to produce block in round N
- Miner C's InValue was secret-shared among other miners
- All miners have provided sufficient encrypted/decrypted pieces

**Transaction Steps**:
1. Miner E triggers NextRound behavior
2. `GetConsensusExtraDataForNextRound` is called
3. `GenerateNextRoundInformation` creates round N+1 without PreviousInValue for any miner
4. `RevealSharedInValues(currentRound, E)` executes, computing C's revealed InValue and writing to `currentRound.RealTimeMinersInformation[C].PreviousInValue`
5. Function returns `nextRound` (not `currentRound`)
6. `NextRoundInput.Create(nextRound, randomNumber)` creates input without C's revealed value
7. `ProcessNextRound` persists round N+1 to state
8. `State.Rounds[N+1]` contains NULL PreviousInValue for miner C

**Expected Result**: Miner C should have a valid PreviousInValue in round N+1 reconstructed via secret sharing.

**Actual Result**: Miner C has NULL PreviousInValue in round N+1 because the computed value was written to `currentRound` (which was never persisted) instead of `nextRound`.

**Success Condition**: Query `State.Rounds[N+1].RealTimeMinersInformation[C].PreviousInValue` and observe it is NULL/Hash.Empty despite sufficient secret shares existing.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-125)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```
