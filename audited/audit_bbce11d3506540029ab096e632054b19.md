# Audit Report

## Title
Predictable NFT Symbol Number Generation Enables Miner Front-Running and Selective Symbol Claiming

## Summary
The `GenerateSymbolNumber()` function in the NFT contract uses randomness from the previous block height combined with the attacker-controllable `Context.Sender` parameter, allowing miners/validators to predict and selectively claim desirable NFT protocol symbol numbers before including transactions in blocks.

## Finding Description

The vulnerability exists in the NFT protocol symbol generation mechanism. When a user calls the `Create()` method to create a new NFT protocol, the system assigns a symbol by combining a two-letter prefix (e.g., "AR" for Art) with a random number generated by `GenerateSymbolNumber()`. [1](#0-0) 

The critical flaw is in how this random number is generated. The function retrieves random bytes using the **previous block's** height (`Context.CurrentHeight.Sub(1)`), which queries publicly-stored random hashes that are already finalized when a miner is producing the current block: [2](#0-1) 

The randomness source comes from the consensus contract's `GetRandomBytes` method, which simply returns the stored random hash for the requested block height: [3](#0-2) 

These random hashes are stored in a public mapping (`State.RandomHashes`) that is populated during consensus processing: [4](#0-3) [5](#0-4) 

**Attack Mechanism:**

When a miner produces block H:
1. Block H-1 is already finalized, and `State.RandomHashes[H-1]` is publicly accessible on-chain state
2. The miner controls which transactions to include in block H and their ordering
3. The only variable in the symbol generation is `Context.Sender` (the transaction sender address)
4. The miner can compute `Hash(Hash(SenderAddress) || Hash(RandomBytes[H-1]))` offline for multiple addresses they control
5. The miner selects the address that yields the most desirable symbol number and submits that transaction
6. Competing user transactions are either excluded or included later with less favorable symbols

While the consensus mechanism uses VRF (Verifiable Random Function) to ensure miners cannot arbitrarily choose random hashes, this does NOT prevent:
- **Predictability**: Historical random hashes are publicly stored and readable
- **Selective Inclusion**: Miners control transaction ordering within blocks
- **Sender Manipulation**: Attackers can try multiple controlled addresses offline
- **No Commit-Reveal**: There is no mechanism to hide user intent before randomness is finalized

## Impact Explanation

This vulnerability breaks the protocol's fairness guarantee for NFT symbol allocation. Symbol numbers may have market value similar to vanity addresses or special license plates. Lower sequential numbers (e.g., "AR100001"), memorable patterns, or early numbers in new NFT categories could command premium prices in the marketplace.

**Concrete Harms:**

1. **Unfair Competitive Advantage**: Miners can systematically claim the most desirable symbol numbers while regular users receive random allocations

2. **Front-Running Capability**: When miners observe pending NFT Create transactions in the mempool that would generate valuable symbols, they can submit their own optimized transactions first and exclude or delay the original transactions

3. **Market Distortion**: Early adopters who are not miners lose access to prestigious symbol numbers during critical NFT protocol launches

4. **Protocol Integrity Violation**: The use of "random number generation" implies unbiased allocation, but miners can game the system

**Severity: MEDIUM** - This is not direct fund theft or supply manipulation, but it creates systematic unfair advantages that undermine protocol integrity in a potentially valuable asset allocation mechanism.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be an elected validator/miner in the AEDPoS consensus system (realistic - validators are elected through standard governance)
- Requires basic technical knowledge to compute hash outputs offline
- Can control multiple addresses for symbol optimization

**Attack Complexity: LOW**

The attack is straightforward to execute:
1. Read `State.RandomHashes[CurrentHeight - 1]` from public contract state
2. For each controlled address, compute: `Hash(Hash(Address) || Hash(RandomHash))` and convert to symbol number
3. Select the address yielding the most desirable symbol
4. Submit NFT Create transaction from that address
5. Include it in the block being produced

**Detection Difficulty: HIGH**

- Appears as normal NFT protocol creation on-chain
- No cryptographic evidence of manipulation
- Can be disguised as "lucky" symbol allocation
- Only statistical analysis showing miners' abnormal clustering at desirable numbers would reveal the pattern over time

**Economic Rationality:**
- Attack cost: Minimal (only transaction fees)
- Potential benefit: Market premium on desirable symbols
- Risk: Low (reputation damage only if pattern detected, no slashing or technical penalties)

**Probability: HIGH** for miners with economic incentives in NFT markets.

## Recommendation

Implement a commit-reveal scheme to prevent miners from knowing the final symbol outcome before committing to include the transaction:

1. **Commit Phase**: User submits a commitment hash containing their intended NFT type and a secret nonce
2. **Reveal Phase**: After the commitment is included in a block, user reveals the actual inputs in a subsequent transaction
3. **Symbol Generation**: Use the random hash from the reveal transaction's block height, combined with the committed secret, ensuring miners cannot predict outcomes at commit time

Alternatively, use transaction-specific randomness by incorporating `Context.TransactionId` (which miners cannot predict before including the transaction) into the hash computation instead of only using `Context.Sender`.

## Proof of Concept

While I cannot provide a complete executable test without access to the full test harness, the vulnerability can be demonstrated with the following conceptual test:

**Test Setup:**
1. Deploy NFT contract on testnet
2. Validator account prepares 100 different controlled addresses
3. Query current block height H and read `State.RandomHashes[H]`

**Exploitation Steps:**
```
For each address A1 to A100:
    compute hash = Hash(Hash(A) || Hash(RandomHashes[H]))
    compute symbolNumber = ConvertToInt64(hash)
    store mapping: A -> symbolNumber
    
Sort addresses by symbolNumber
Select address with most desirable number (e.g., lowest value)

When producing block H+1:
    Include Create transaction from selected address
    Result: Claim desirable symbol number
```

**Expected Result:** The validator consistently obtains symbol numbers in the lowest percentile (e.g., top 10%) across multiple NFT protocol creations, with statistical significance far exceeding random chance.

**Notes:**

This vulnerability represents a fairness issue rather than a critical security exploit. The actual economic impact depends on whether NFT protocol symbols develop market value in practice. However, the systematic nature of the unfair advantage undermines protocol integrity and user trust, particularly during high-value NFT category launches where early/sequential symbol numbers may be perceived as prestigious or collectible.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L71-77)
```csharp
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L119-129)
```csharp
        Assert(input.Value > 1, "Invalid block height.");
        Assert(Context.CurrentHeight >= input.Value, "Block height not reached.");
        return State.RandomHashes[input.Value] ?? Hash.Empty;
    }

    public override BytesValue GetRandomBytes(BytesValue input)
    {
        var height = new Int64Value();
        height.MergeFrom(input.Value);
        return GetRandomHash(height).ToBytesValue();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L53-53)
```csharp
    public MappedState<long, Hash> RandomHashes { get; set; }
```
