### Title
Malicious DecryptedPieces Can Corrupt Secret Sharing Reconstruction Due to Improper Signed BigInteger Handling

### Summary
The Shamir secret sharing reconstruction in `DecodeSecret` is vulnerable to manipulation through crafted `DecryptedPieces` byte arrays that produce negative BigInteger values. Malicious miners can submit byte arrays where the most significant byte has the high bit set, causing incorrect finite field arithmetic and corrupting the revealed InValues stored in consensus state.

### Finding Description

The vulnerability exists in the secret sharing reconstruction flow: [1](#0-0) 

At line 47, `DecryptedPieces` values are converted to byte arrays without validation. These are passed to `SecretSharingHelper.DecodeSecret`: [2](#0-1) 

The BigInteger constructor interprets byte arrays as signed integers in little-endian format. If the most significant byte has the high bit set (â‰¥ 0x80), the value becomes negative: [3](#0-2) 

The critical flaw is at line 61 where standard modulo is used: [4](#0-3) 

In C#, the `%` operator returns negative results for negative operands. The codebase provides an `Abs()` extension method to handle this correctly: [5](#0-4) 

However, `DecodeSecret` does not use this extension method, causing incorrect finite field arithmetic.

The attack vector is through `UpdateValue` where miners submit `DecryptedPieces` without validation: [6](#0-5) 

The validation provider only checks OutValue, Signature, and PreviousInValue, not the DecryptedPieces content: [7](#0-6) 

When transitioning to the next round, `RevealSharedInValues` is called on-chain: [8](#0-7) 

This reconstructs InValues using the corrupted DecryptedPieces and stores incorrect PreviousInValues in consensus state: [9](#0-8) 

### Impact Explanation

**Consensus Integrity Violation**: The attack corrupts the consensus state by storing incorrect `PreviousInValue` data for victim miners. This violates the "Correct round transitions and time-slot validation, miner schedule integrity" invariant.

**Affected Parties**: 
- Victim miners whose InValues are incorrectly reconstructed
- All nodes that rely on accurate consensus state
- The protocol's Byzantine fault tolerance guarantees are weakened

**Concrete Harm**:
1. Corrupted consensus state persists on-chain
2. Incorrect PreviousInValues may affect subsequent validation in edge cases
3. If reward calculations or slashing mechanisms depend on accurate InValue revelation, they could be manipulated
4. The revealed values serve as fallback when miners fail to produce blocks, potentially causing unfair penalties

**Severity Justification**: Medium severity because while it corrupts consensus state and could affect reward distribution or future validation, it does not directly enable fund theft or immediate chain halt. The impact is on consensus integrity and fairness rather than direct financial loss.

### Likelihood Explanation

**Attacker Capabilities**: The attacker must be a miner in the current consensus round, which is a permissioned but achievable position.

**Attack Complexity**: Low - the attacker simply needs to craft byte arrays where the MSB is set (e.g., `[0xFF, 0xFF, ...]`) and submit them as DecryptedPieces in their UpdateValue transaction.

**Feasible Preconditions**:
1. Attacker is an active miner (realistic in a DPoS system)
2. Victim has published EncryptedPieces in the previous round (normal operation)
3. No cryptographic validation exists to verify DecryptedPieces match EncryptedPieces

**Execution Steps**:
1. Wait for victim to publish EncryptedPieces in round N-1
2. In round N, submit UpdateValue with crafted DecryptedPieces containing byte arrays like `[0xFF, 0xFF, ...]`
3. When any miner triggers NextRound transition, RevealSharedInValues executes on-chain
4. Corrupted PreviousInValue is stored in consensus state

**Detection Difficulty**: The malicious byte arrays appear as valid serialized BigIntegers, making detection challenging without explicit range validation.

**Economic Rationality**: The attack costs only transaction fees, which are minimal compared to potential gains from corrupting competitor miners' reputation or reward calculations.

### Recommendation

**Immediate Fix**: Modify `DecodeSecret` to properly handle negative BigInteger values in finite field arithmetic:

```csharp
// In SecretSharingHelper.DecodeSecret at line 61, change from:
result %= SecretSharingConsts.FieldPrime;

// To:
result = result.Abs(); // Use the Abs() extension method
```

**Additional Validation**: Add range validation for DecryptedPieces in the contract:

```csharp
// In AEDPoSContract_ProcessConsensusInformation.cs PerformSecretSharing
foreach (var decryptedPiece in input.DecryptedPieces)
{
    var value = new BigInteger(decryptedPiece.Value.ToByteArray());
    Assert(value >= BigInteger.Zero && value < SecretSharingConsts.FieldPrime, 
           "DecryptedPiece value out of valid range");
    // ... existing code
}
```

**Cryptographic Proof**: Consider adding zero-knowledge proofs or verifiable decryption to ensure DecryptedPieces are legitimate decryptions of EncryptedPieces.

**Test Cases**: Add unit tests for negative BigInteger handling:
- Test DecodeSecret with crafted byte arrays that produce negative values
- Verify correct reconstruction despite malicious inputs
- Test the full RevealSharedInValues flow with crafted DecryptedPieces

### Proof of Concept

**Initial State**:
- 3 miners (A, B, C) in the consensus round
- Miner B is the attacker
- Miner A has published EncryptedPieces in round N-1 with OutValue = Hash(actualInValue)

**Attack Steps**:

1. **Round N - Attacker Submission**:
   - Miner B calls `UpdateValue` with crafted DecryptedPieces
   - For Miner A's entry, submit byte array: `[0xFF, 0xFF, 0xFF, 0xFF]`
   - This byte array produces BigInteger value = -1 when passed to `new BigInteger()`
   - Transaction succeeds because no validation exists

2. **Round N - NextRound Transition**:
   - Any miner (e.g., Miner C) triggers NextRound
   - `GetConsensusExtraDataForNextRound` calls `RevealSharedInValues`
   - `DecodeSecret` is executed with B's crafted bytes for A
   - At line 50: `numerator = new BigInteger([0xFF, 0xFF, 0xFF, 0xFF]) = -1`
   - At line 61: `result %= FieldPrime` may return negative value
   - Incorrect InValue is computed and hashed
   - `currentRound.RealTimeMinersInformation[A].PreviousInValue = wrongHash`

3. **Verification**:
   - Expected: PreviousInValue = Hash(actualInValue)
   - Actual: PreviousInValue = Hash(incorrectlyReconstructedValue)
   - Consensus state is corrupted

**Success Condition**: The stored PreviousInValue for Miner A does not match `Hash(actualInValue)`, proving the reconstruction was corrupted by the negative BigInteger handling flaw.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L46-50)
```csharp
            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L52-52)
```csharp
            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L50-50)
```csharp
                var numerator = new BigInteger(sharedParts[i]);
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L61-61)
```csharp
                result %= SecretSharingConsts.FieldPrime;
```

**File:** test/AElf.Cryptography.Tests/SecretSharingTest.cs (L37-41)
```csharp
        var dataArray = new byte[] { 0xff, 0xff };
        var rawData = new BigInteger(dataArray);
        rawData.ShouldBe(-1);
        var absData = rawData.Abs();
        absData.ShouldBe(SecretSharingConsts.FieldPrime - 1);
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingExtensions.cs (L39-43)
```csharp
        public static BigInteger Abs(this BigInteger integer)
        {
            return (integer % SecretSharingConsts.FieldPrime + SecretSharingConsts.FieldPrime) %
                   SecretSharingConsts.FieldPrime;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```
