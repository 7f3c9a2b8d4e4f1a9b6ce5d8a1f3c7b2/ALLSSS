### Title
Consensus Corruption via Unvalidated Round Fields in NextRound Transition

### Summary
The `NextRoundInput.Create()` and `ToRound()` methods lack validation, and critical consensus fields (`ConfirmedIrreversibleBlockHeight`, `ExtraBlockProducerOfPreviousRound`, `MainChainMinersRoundNumber`, `IsMinerListJustChanged`, `RoundIdForValidation`) are excluded from hash-based validation. A malicious block producer can inject a NextRound transaction with manipulated values for these fields, bypassing both before-execution validation (which only checks `RoundNumber` and `InValues`) and after-execution validation (which uses hash comparison excluding these fields), enabling consensus state corruption.

### Finding Description

**Root Cause:**

The `NextRoundInput.Create()` method at [1](#0-0)  simply copies all fields from a `Round` object without any validation. Similarly, `ToRound()` at [2](#0-1)  converts back to `Round` without validation.

**Validation Gap - Before Execution:**

For NextRound behavior, only `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` are applied [3](#0-2) . The `RoundTerminateValidationProvider.ValidationForNextRound()` only validates two fields [4](#0-3) :
- Round number must increment by 1
- InValues must be null

Critically, `LibInformationValidationProvider` does NOT run for NextRound behavior [5](#0-4) , meaning `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` are unvalidated.

**Validation Gap - After Execution:**

The `ValidateConsensusAfterExecution()` method compares Round hashes [6](#0-5) . However, `GetCheckableRound()` only includes `RoundNumber`, `TermNumber`, `RealTimeMinersInformation` (with exclusions), and `BlockchainAge` [7](#0-6) .

**Excluded Fields (Not in Hash):**
- `MainChainMinersRoundNumber`
- `ExtraBlockProducerOfPreviousRound`
- `ConfirmedIrreversibleBlockHeight`
- `ConfirmedIrreversibleBlockRoundNumber`
- `IsMinerListJustChanged`
- `RoundIdForValidation`

These fields are defined in the protobuf but excluded from the checkable round [8](#0-7) .

**Execution Path:**

When NextRound is called [9](#0-8) , it processes the input via `ProcessNextRound()` [10](#0-9)  which calls `input.ToRound()` at line 110 and adds the round to state via `AddRoundInformation()` at line 156.

### Impact Explanation

**Consensus Integrity Compromise:**

1. **LIB Manipulation**: `ConfirmedIrreversibleBlockHeight` is used in LIB calculation and affects `GetMaximumBlocksCount()` [11](#0-10) . Setting this incorrectly high could enable DoS by causing abnormal blockchain status detection.

2. **Unauthorized Mining Privileges**: `ExtraBlockProducerOfPreviousRound` determines which miner can produce tiny blocks at round start. A malicious miner could grant themselves unauthorized extra block production rights by setting this to their own pubkey.

3. **Cross-Chain Corruption**: For side chains, `MainChainMinersRoundNumber` tracks main chain consensus synchronization. Manipulation could corrupt cross-chain state validation and miner list updates.

4. **Secret Sharing Disruption**: `IsMinerListJustChanged` affects whether secret sharing occurs [12](#0-11) . Incorrect values could disrupt the random number generation mechanism.

**Severity:** HIGH - Direct consensus corruption affecting block production, finality, and cross-chain operations.

### Likelihood Explanation

**Attacker Capabilities:**
Any current block producer (miner) can execute this attack as they control both block header construction and transaction inclusion.

**Attack Complexity:**
1. Generate legitimate consensus extra data with valid `RoundNumber` (current + 1) and null `InValues`
2. Create `NextRoundInput` for transaction with same validated fields but manipulated excluded fields
3. Include transaction in block with the legitimate extra data
4. Before-execution validation passes (only checks `RoundNumber` and `InValues` from extra data)
5. Transaction executes, adding malicious Round to state
6. After-execution validation passes (hash comparison excludes manipulated fields)

**Feasibility:** HIGH - No special permissions beyond being a current miner are required. The attack is undetectable by current validation logic.

**Detection/Prevention:** None - No validation exists for these fields during NextRound transitions, and no monitoring would detect the manipulation until consensus corruption manifests.

### Recommendation

**Immediate Fix:**

1. Add comprehensive validation to `RoundTerminateValidationProvider.ValidationForNextRound()` to check all critical fields:

```csharp
// Add to RoundTerminateValidationProvider.ValidationForNextRound()
// Validate LIB fields don't regress
if (extraData.Round.ConfirmedIrreversibleBlockHeight != 0 &&
    validationContext.BaseRound.ConfirmedIrreversibleBlockHeight > extraData.Round.ConfirmedIrreversibleBlockHeight)
    return new ValidationResult { Message = "ConfirmedIrreversibleBlockHeight cannot decrease" };

// Validate ExtraBlockProducerOfPreviousRound matches actual extra block producer
var expectedProducer = validationContext.BaseRound.RealTimeMinersInformation.Values
    .FirstOrDefault(m => m.IsExtraBlockProducer)?.Pubkey;
if (expectedProducer != null && extraData.Round.ExtraBlockProducerOfPreviousRound != expectedProducer)
    return new ValidationResult { Message = "Invalid ExtraBlockProducerOfPreviousRound" };
```

2. Include all critical fields in `GetCheckableRound()` hash calculation, or add separate validation for excluded fields in `ValidateConsensusAfterExecution()`.

3. Add explicit transaction parameter validation in `ProcessNextRound()` before calling `ToRound()`:
```csharp
// Verify critical fields match expected values from current round
Assert(input.ConfirmedIrreversibleBlockHeight >= currentRound.ConfirmedIrreversibleBlockHeight,
    "Invalid ConfirmedIrreversibleBlockHeight");
```

**Test Cases:**

1. Test NextRound with manipulated `ConfirmedIrreversibleBlockHeight` - should fail validation
2. Test NextRound with incorrect `ExtraBlockProducerOfPreviousRound` - should fail validation  
3. Test NextRound with mismatched `MainChainMinersRoundNumber` - should fail validation
4. Test that hash comparison catches all field modifications

### Proof of Concept

**Initial State:**
- Current round number: N
- Current round has valid consensus state with specific `ConfirmedIrreversibleBlockHeight` = H

**Attack Steps:**

1. As current miner, generate NextRound consensus command for round N+1
2. Create block header extra data with:
   - `Round.RoundNumber = N + 1`
   - `Round.RealTimeMinersInformation` with all `InValue = null`
   - `Round.ConfirmedIrreversibleBlockHeight = H` (legitimate)
   
3. Create NextRound transaction with:
   - `NextRoundInput.RoundNumber = N + 1`
   - `NextRoundInput.RealTimeMinersInformation` with all `InValue = null`
   - `NextRoundInput.ConfirmedIrreversibleBlockHeight = H + 1000000` (malicious)
   - `NextRoundInput.ExtraBlockProducerOfPreviousRound = attacker_pubkey` (malicious)

4. Submit block with this extra data and transaction

**Expected Result:**
Validation should reject the block due to mismatched critical fields.

**Actual Result:**
- Before-execution validation passes (only checks RoundNumber and InValues from extra data)
- Transaction executes successfully
- After-execution validation passes (GetHash excludes manipulated fields)
- State now contains Round N+1 with corrupted `ConfirmedIrreversibleBlockHeight` and `ExtraBlockProducerOfPreviousRound`
- Attacker gains unauthorized mining privileges and LIB calculation is corrupted

**Success Condition:**
Query round N+1 state and observe `ConfirmedIrreversibleBlockHeight` and `ExtraBlockProducerOfPreviousRound` contain attacker-controlled values different from what should have been carried forward from round N.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-92)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** protobuf/aedpos_contract.proto (L243-264)
```text
message Round {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producersâ€™ expecting time (second).
    int64 round_id_for_validation = 10;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L107-115)
```csharp
        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```
