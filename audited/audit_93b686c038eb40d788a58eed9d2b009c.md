### Title
Vote Counting Inconsistency Enables Governance Manipulation via Member Removal After Voting

### Summary
The `CheckEnoughVoteAndApprovals` function in `Association_Helper.cs` contains a critical inconsistency where approval/rejection/abstention counts are filtered by current organization members, but the total vote threshold check counts all votes including those from removed members. This allows a majority coalition to manipulate governance by first allowing members to vote, then removing dissenting voters to change rejected proposals into passable ones, violating the fundamental invariant that proposal outcomes should be based on votes cast by current members at release time.

### Finding Description

The vulnerability exists in the vote counting logic across multiple functions in `Association_Helper.cs`: [1](#0-0) 

In `CheckEnoughVoteAndApprovals`, line 49 correctly filters approvals to count only current members using `.Count(organization.OrganizationMemberList.Contains)`. However, lines 56-57 count the total vote participation by concatenating all vote lists and calling `.Count()` WITHOUT filtering by current membership. [2](#0-1) 

Similarly, `IsProposalRejected` (line 37) and `IsProposalAbstained` (line 43) both filter their respective vote counts by current members only.

**Root Cause:** When members are removed from an organization via `RemoveMember`: [3](#0-2) 

The removal does NOT clean up or invalidate existing proposal votes. The removed member's address remains in the proposal's vote lists (Approvals, Rejections, or Abstentions), but is no longer in `organization.OrganizationMemberList`.

**Execution Path:**
1. Members vote on a proposal via `Approve`, `Reject`, or `Abstain` methods [4](#0-3) [5](#0-4) 

2. Members are removed through governance-approved `RemoveMember` calls
3. When checking `IsReleaseThresholdReached` for release: [6](#0-5) 

The inconsistency causes removed members' votes to:
- NOT count toward approval/rejection/abstention thresholds (filtered out)
- STILL count toward the MinimalVoteThreshold (not filtered)

### Impact Explanation

**Governance Manipulation:** A majority coalition can:
1. Allow all members to vote on a controversial proposal
2. If the proposal is rejected (e.g., 3 rejections exceed MaximalRejectionThreshold of 2), pass a separate proposal to remove the dissenting voters
3. After removal, the original proposal's rejection count drops below the threshold while the total vote count remains high
4. The previously rejected proposal becomes releasable, executing unauthorized actions

**Concrete Example:**
- Organization: 10 members, MinimalApprovalThreshold=5, MinimalVoteThreshold=8, MaximalRejectionThreshold=2
- Proposal A: 5 approve, 3 reject, 1 abstain → REJECTED (3 rejections > 2 threshold)
- Remove 2 of the 3 rejecting members → Organization now has 8 members
- Proposal A recheck: only 1 rejection (from remaining member) ≤ 2 threshold → NOW PASSABLE
- Total votes: still 9 (including removed members), satisfying MinimalVoteThreshold of 8

**Who is Affected:** All Association-based organizations are vulnerable. The integrity of multi-signature governance is compromised, allowing minority suppression and retroactive outcome manipulation.

**Severity Justification:** CRITICAL - This breaks the fundamental governance invariant that proposal outcomes must reflect the will of current members, enabling unauthorized execution of proposals that were legitimately rejected.

### Likelihood Explanation

**Attacker Capabilities:** Requires a majority coalition within the organization to:
1. Control enough votes to pass a member removal proposal
2. Execute the removal before the target proposal expires

**Attack Complexity:** MODERATE
- Requires coordination among majority members
- Needs two sequential proposals (removal, then release)
- Must execute within proposal expiration timeframes

**Feasibility Conditions:**
- Organization must be configured with thresholds that allow this manipulation (MinimalVoteThreshold allows member removal while maintaining validity) [7](#0-6) 
- Attacker coalition must have majority control
- Target proposal must not expire during the attack window

**Detection Constraints:** 
- All operations are legitimate governance actions visible on-chain
- However, the pattern (member removal followed by proposal release of previously rejected proposal) is detectable

**Probability:** MEDIUM-HIGH - While requiring majority control, this is a realistic attack vector in contentious governance scenarios where a slim majority wants to override strong minority opposition.

### Recommendation

**Code-Level Mitigation:**

Modify `CheckEnoughVoteAndApprovals` to filter the total vote count by current members, ensuring consistency:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter all vote counts by current members
    var currentMemberVoteCount = 
        proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
        proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
        proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
    
    var isVoteThresholdReached =
        currentMemberVoteCount >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

**Additional Safeguards:**

1. Add validation in `RemoveMember` to prevent removing members who have active votes on pending proposals:
```csharp
// Check if member has voted on any active proposals
foreach (var proposalId in activeProposals)
{
    var proposal = State.Proposals[proposalId];
    Assert(!proposal.Approvals.Contains(input) && 
           !proposal.Rejections.Contains(input) && 
           !proposal.Abstentions.Contains(input),
           "Cannot remove member with active votes");
}
```

2. Or alternatively, automatically clean up removed member's votes from all proposals when they're removed.

**Test Cases:**
1. Verify proposal rejection persists after rejecting members are removed
2. Test MinimalVoteThreshold counting only current members
3. Validate that proposal outcome cannot change solely due to member removal

### Proof of Concept

**Initial State:**
- Create Association organization with 10 members (M1-M10)
- Configure: MinimalApprovalThreshold=5, MinimalVoteThreshold=8, MaximalRejectionThreshold=2

**Transaction Sequence:**

1. **Create Proposal A** (controversial action)
   - Proposer: M1
   - Expected: Proposal created

2. **Vote on Proposal A:**
   - M1, M2, M3, M4, M5 call `Approve(proposalA_id)`
   - M6, M7, M8 call `Reject(proposalA_id)`
   - M9 calls `Abstain(proposalA_id)`
   - Total: 5 approvals, 3 rejections, 1 abstention

3. **Attempt Release:**
   - M1 calls `Release(proposalA_id)`
   - Expected: FAILS with "Not approved" - 3 rejections > 2 MaximalRejectionThreshold
   - Actual: Correctly rejected ✓

4. **Create Proposal B** to remove M6
   - M1, M2, M3, M4, M5 call `Approve(proposalB_id)`
   - M1 calls `Release(proposalB_id)`
   - Expected: Passes (5 approvals meet threshold)
   - Executes: `RemoveMember(M6)`

5. **Create Proposal C** to remove M7
   - M1, M2, M3, M4, M5 call `Approve(proposalC_id)`
   - M1 calls `Release(proposalC_id)`
   - Expected: Passes
   - Executes: `RemoveMember(M7)`

6. **Attempt Release Proposal A Again:**
   - Organization now has 8 members (M1-M5, M8-M10)
   - M1 calls `Release(proposalA_id)`
   - Expected (correct behavior): Should FAIL - proposal was rejected
   - **Actual (vulnerability)**: SUCCEEDS
     - rejectionMemberCount = 1 (only M8 still member) ≤ 2 threshold ✓
     - approvedMemberCount = 5 ≥ 5 threshold ✓
     - total vote count = 9 (includes removed M6, M7) ≥ 8 threshold ✓
     - Proposal A executes despite being legitimately rejected

**Success Condition:** Proposal A executes in step 6, demonstrating that a rejected proposal became executable by removing dissenting voters, proving the governance manipulation vulnerability.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-45)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L143-161)
```csharp
    public override Empty Reject(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Rejections.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Reject),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
