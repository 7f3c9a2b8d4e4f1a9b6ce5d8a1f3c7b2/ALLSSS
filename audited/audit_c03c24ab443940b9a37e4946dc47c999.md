### Title
Block Producer MEV Exploitation Through Predictable NFT Symbol Number Generation

### Summary
Block producers can predict and manipulate NFT protocol symbol numbers by reordering transactions or front-running users. The `GenerateSymbolNumber()` function uses deterministic inputs (previous block's VRF output + sender address) that are fully known to block producers before transaction ordering, allowing them to extract value by securing desirable symbol numbers (e.g., lower numbers, patterns) for themselves while denying them to regular users.

### Finding Description

The vulnerability exists in the `GenerateSymbolNumber()` function which generates unique identifier numbers for NFT protocol symbols. [1](#0-0) 

The function generates symbol numbers using two inputs:
1. Random bytes from the consensus contract based on `Context.CurrentHeight.Sub(1)` (previous block height)
2. The transaction sender's address via `Context.Sender` [2](#0-1) 

The random bytes come from the AEDPoS consensus contract's VRF-generated random hash for the previous block, which is already committed and publicly known: [3](#0-2) [4](#0-3) 

The number conversion is deterministic: [5](#0-4) 

**Root Cause:** Symbol number generation relies on inputs that are fully deterministic and known to block producers:
- The previous block's random hash is already committed when miners produce the current block
- Transaction sender addresses are visible in the mempool
- The hash combination and number conversion are deterministic operations

**Why Existing Protections Fail:**
- The VRF mechanism ensures miners cannot manipulate future random values, but it does NOT prevent exploitation of current/past values
- No commit-reveal scheme or additional entropy source at transaction execution time
- No protection against transaction reordering by block producers

### Impact Explanation

**Concrete Harm:**
Block producers can systematically capture desirable symbol numbers which have market value in NFT ecosystems:
- **Lower serial numbers** signal early adoption and prestige (e.g., "AR10000000" vs "AR95837264")
- **Pattern numbers** have collector value (e.g., "AR11111111", "AR12345678")
- **Round numbers** are more memorable and marketable (e.g., "AR20000000")

**Value Extraction Mechanism:**
1. Block producer monitors mempool for `Create()` transactions
2. Calculates exact symbol numbers each transaction would receive
3. When identifying a transaction that would get a desirable number, the producer can:
   - Front-run by submitting their own `Create()` transaction first
   - Reorder transactions to place their transaction before the victim's
   - Censor the victim's transaction entirely if it would get an extremely valuable number

**Who Is Affected:**
- Regular NFT protocol creators who lose access to desirable symbol numbers
- The protocol's fairness guarantees are violated
- Market efficiency is compromised as value extraction occurs at the consensus layer

**Severity Justification:**
High severity due to:
- Systematic exploitability by all block producers
- No detection mechanism for victims
- Undermines protocol fairness and user trust
- Real economic value at stake (desirable identifiers command premiums in NFT markets)

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be a block producer (miner) with ability to order transactions
- Access to mempool to view pending transactions
- Ability to submit transactions and calculate hashes

**Attack Complexity:**
Low complexity:
1. Monitor mempool for `Create()` calls
2. For each pending transaction, calculate: `Hash(Hash(sender) + Hash(GetRandomBytes(previousBlockHeight)))`
3. Convert hash to number using known algorithm
4. If number is desirable, inject own transaction or reorder

**Feasibility Conditions:**
- No special preconditions required
- Works on every block where NFT creation occurs
- Deterministic calculation allows perfect prediction
- No additional protocol violations needed

**Detection Constraints:**
- Difficult to detect as transaction ordering appears normal
- No on-chain evidence of manipulation
- Victims cannot prove they were front-run

**Probability:**
High probability of occurrence:
- Economically rational for block producers if desirable numbers have value
- Zero risk of detection or punishment
- Can be automated with simple monitoring script

### Recommendation

**Immediate Mitigation:**
Add block-time entropy by incorporating the current block's information:

```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    // Use CURRENT block hash + transaction hash for unpredictability
    var randomHash = HashHelper.ConcatAndCompute(
        Context.TransactionId,  // Transaction hash (unknown to miner at ordering time)
        HashHelper.ComputeFrom(Context.CurrentBlockTime),  // Block timestamp
        HashHelper.ComputeFrom(Context.Sender)
    );
    
    long randomNumber;
    do
    {
        randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        if (!State.IsCreatedMap[randomNumber]) break;
        // If collision, rehash
        randomHash = HashHelper.ComputeFrom(randomHash);
    } while (true);

    return randomNumber;
}
```

**Alternative Approach (More Robust):**
Implement commit-reveal scheme:
1. User commits to Create with hash of (secret + parameters)
2. After commitment is included and confirmed, user reveals secret
3. Symbol number generated using revealed secret + block hash

**Invariant Checks:**
- Symbol number generation must not be predictable at transaction submission time
- Transaction hash should be incorporated as entropy source

**Test Cases:**
- Verify same sender in different blocks gets different symbol numbers
- Verify different transactions in same block get different symbol numbers
- Test that reordering transactions produces different symbol assignments

### Proof of Concept

**Initial State:**
- NFT contract deployed and initialized
- Block N-1 has random hash: `0x1234...` (known)
- Current block N is being produced by malicious miner

**Attack Sequence:**

1. **Victim submits transaction:**
   - User Alice (address: `0xAAA...`) calls `Create(nftType: "Art", ...)`
   - Transaction enters mempool

2. **Miner calculation (off-chain):**
   ```
   previousRandomBytes = GetRandomBytes(blockN-1) = 0x1234...
   aliceHash = Hash(Hash(0xAAA...) + Hash(0x1234...))
   aliceSymbolNumber = ConvertHashToInt64(aliceHash) = 10000000  // Highly desirable low number
   ```

3. **Miner front-running:**
   - Miner (address: `0xMMM...`) submits own `Create()` transaction
   - Miner places their transaction BEFORE Alice's in block N
   - Miner's transaction executes first and claims symbol "AR10000000"

4. **Result:**
   - Miner gets: Symbol "AR10000000" (desirable)
   - Alice gets: Symbol "AR10000001" or must retry with different result
   - Miner successfully extracted MEV

**Expected vs Actual:**
- **Expected (fair):** Alice's earlier submission gets the desirable number
- **Actual (exploited):** Miner's later transaction gets the desirable number through privileged ordering control

**Success Condition:**
Miner obtains symbol number that user's transaction would have received, demonstrating ability to extract value through transaction reordering based on predictable randomness.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L124-129)
```csharp
    public override BytesValue GetRandomBytes(BytesValue input)
    {
        var height = new Int64Value();
        height.MergeFrom(input.Value);
        return GetRandomHash(height).ToBytesValue();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L173-177)
```csharp
        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
```
