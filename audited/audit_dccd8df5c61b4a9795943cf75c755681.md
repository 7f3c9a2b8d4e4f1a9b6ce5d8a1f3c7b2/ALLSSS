### Title
Insufficient Weight Validation Allows Connector Initialization with Impractical Values Causing Bancor Calculation DoS

### Summary
The TokenConverter contract's weight validation only checks that values are strictly between 0 and 1, without enforcing a practical minimum bound. Connectors initialized with extremely small weights (e.g., 0.0000001) cause arithmetic overflow in Bancor formula calculations, resulting in transaction reverts and permanent DoS of the affected connector's buy/sell functionality.

### Finding Description

The vulnerability exists in the weight validation logic at [1](#0-0) 

The `IsBetweenZeroAndOne` check only validates `number > decimal.Zero && number < decimal.One` without any practical minimum bound [2](#0-1) 

This validation is applied during:
1. Initial connector setup in `Initialize()` [3](#0-2) 
2. Connector updates via `UpdateConnector()` [4](#0-3) 
3. New connector pairs via `AddPairConnector()` [5](#0-4) 

When extremely small weights are used, the Bancor calculations fail catastrophically. In `GetAmountToPayFromReturn`, the ratio `y = wt / wf` becomes enormous [6](#0-5) 

For example, if `fromConnectorWeight = 0.0000001` and `toConnectorWeight = 0.5`, then `y = 5,000,000`. This massive ratio is then used in `Exp(y * Ln(x))` calculations [6](#0-5) 

The `Exp` function uses only a 20-term Taylor series approximation [7](#0-6)  which cannot handle such large exponents. The intermediate `Pow(y, iteration)` calculations overflow during the binary exponentiation algorithm [8](#0-7) 

Since AElf requires `CheckForOverflowUnderflow` to be enabled, arithmetic overflow throws `OverflowException`, causing all Buy and Sell transactions to revert [9](#0-8) 

### Impact Explanation

**Operational DoS**: Connectors initialized with extremely small weights become permanently unusable. All `Buy()` and `Sell()` operations fail with `OverflowException`, preventing any token conversions through that connector.

**Affected parties**: 
- Users cannot trade tokens through the broken connector
- Protocol loses conversion fee revenue
- Liquidity is effectively locked until contract redeployment

**Severity justification**: While not direct fund theft, this constitutes a critical operational failure. The connector becomes a permanent DoS until the entire TokenConverter contract is redeployed (if governance allows) or a workaround is implemented. Production code uses weights like 0.005 and 0.5 [10](#0-9) , but the validation accepts values orders of magnitude smaller.

### Likelihood Explanation

**Primary scenario - Misconfiguration**: An administrator could accidentally input an impractical weight value (e.g., typing "0.0000001" instead of "0.1"). The validation provides no guardrails, warnings, or documentation about safe minimum values. The test suite only uses reasonable values like 0.5 and 0.6 [11](#0-10) , failing to catch extreme edge cases.

**Secondary scenario - AddPairConnector**: New connectors can be added post-initialization via `AddPairConnector()` [12](#0-11) , which uses the same insufficient validation. While this requires connector controller authorization [13](#0-12) , misconfiguration remains realistic.

**Complexity**: LOW - Simply providing a decimal string like "0.0000001" triggers the issue.

**Detection**: The error only manifests when users attempt trades, potentially after connector activation, making debugging difficult.

### Recommendation

**Immediate fix**: Add a minimum weight threshold to prevent impractical values:

```csharp
private void AssertValidConnectorWeight(Connector connector)
{
    var weight = AssertedDecimal(connector.Weight);
    const decimal MinimumWeight = 0.001m; // 0.1% minimum
    Assert(weight >= MinimumWeight && weight < decimal.One, 
        $"Connector weight must be between {MinimumWeight} and 1.");
    connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
}
```

**Additional checks**:
1. Add validation in `UpdateConnector` and `AddPairConnector` for practical weight ranges
2. Validate weight ratios between paired connectors don't exceed reasonable bounds (e.g., 1000x)
3. Add documentation specifying safe weight ranges and the mathematical constraints

**Test cases to add**:
1. Test Initialize with weight = 0.0000001 (should fail)
2. Test Buy/Sell with weights = (0.0001, 0.9999) causing large ratios
3. Test AddPairConnector with extreme weight disparities

### Proof of Concept

**Initial state**: TokenConverter contract deployed but not initialized, or new connector being added.

**Attack/Misconfiguration sequence**:

1. Call `Initialize()` with connectors having extremely small weight:
```
InitializeInput {
    BaseTokenSymbol: "ELF",
    FeeRate: "0.005",
    Connectors: [{
        Symbol: "RESOURCE",
        Weight: "0.0000001",  // Passes IsBetweenZeroAndOne check
        RelatedSymbol: "NTRESOURCE",
        ...
    }, {
        Symbol: "NTRESOURCE", 
        Weight: "0.5",
        IsDepositAccount: true,
        ...
    }]
}
```

2. Enable the connector via `EnableConnector()` [14](#0-13) 

3. User attempts to buy RESOURCE tokens via `Buy()` [9](#0-8) 

**Expected result**: Transaction executes successfully, user receives tokens at correct price.

**Actual result**: 
- `BancorHelper.GetAmountToPayFromReturn()` calculates `y = 0.5 / 0.0000001 = 5,000,000`
- During `Exp(y * Ln(x))` computation, `Pow(y, iteration)` overflows
- Transaction reverts with `System.OverflowException`
- Buy operation fails completely
- All future Buy/Sell attempts for this connector fail permanently

**Success condition**: The connector is rendered unusable, constituting a DoS until contract redeployment.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L39-53)
```csharp
        foreach (var connector in input.Connectors)
        {
            if (connector.IsDepositAccount)
            {
                Assert(!string.IsNullOrEmpty(connector.Symbol), "Invalid connector symbol.");
                AssertValidConnectorWeight(connector);
            }
            else
            {
                Assert(IsValidSymbol(connector.Symbol), "Invalid symbol.");
                AssertValidConnectorWeight(connector);
            }

            State.Connectors[connector.Symbol] = connector;
        }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L65-69)
```csharp
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-110)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-159)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
        // Transfer bought token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });

        Context.Fire(new TokenBought
        {
            Symbol = input.Symbol,
            BoughtAmount = input.Amount,
            BaseAmount = amountToPay,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L354-357)
```csharp
    private static bool IsBetweenZeroAndOne(decimal number)
    {
        return number > decimal.Zero && number < decimal.One;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L98-165)
```csharp
    private const int _LOOPS = 20; // Max = 20

    private static readonly ReadOnlyCollection<long> Fact;

    // http://www.daimi.au.dk/~ivan/FastExpproject.pdf
    // Left to Right Binary Exponentiation
    public static decimal Pow(decimal x, uint y)
    {
        if (y == 1)
            return x;

        var A = 1m;
        var e = new BitArray(y.ToBytes(false));
        var t = e.Count;

        for (var i = t - 1; i >= 0; --i)
        {
            A *= A;
            if (e[i]) A *= x;
        }

        return A;
    }

    // http://stackoverflow.com/questions/429165/raising-a-decimal-to-a-power-of-decimal
    // natural logarithm series
    private static decimal Ln(decimal a)
    {
        /*
        ln(a) = log(1-x) = - x - x^2/2 - x^3/3 - ...   (where |x| < 1)
            x: a = 1-x    =>   x = 1-a = 1 - 1.004 = -.004
        */
        var x = 1 - a;
        if (Math.Abs(x) >= 1)
            throw new InvalidValueException("must be 0 < a < 2");

        decimal result = 0;
        uint iteration = _LOOPS;
        while (iteration > 0)
        {
            result -= Pow(x, iteration) / iteration;
            iteration--;
        }

        return result;
    }


    // http://stackoverflow.com/questions/429165/raising-a-decimal-to-a-power-of-decimal
    // power series
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L222-246)
```csharp
                Weight = "0.5",
                VirtualBalance = EconomicContractConstants.NativeTokenConnectorInitialVirtualBalance
            }
        };
        foreach (var resourceTokenSymbol in Context.Variables
                     .GetStringArray(EconomicContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(EconomicContractConstants.PayRentalSymbolListName)))
        {
            var resourceTokenConnector = new Connector
            {
                Symbol = resourceTokenSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.ResourceTokenInitialVirtualBalance,
                RelatedSymbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsDepositAccount = false
            };
            var nativeTokenConnector = new Connector
            {
                Symbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
```

**File:** test/AElf.Contracts.TokenConverter.Internal.Tests/BancorHelperTest.cs (L13-32)
```csharp
    public BancorHelperTest()
    {
        _writeConnector = new Connector
        {
            Symbol = "WRITE",
            VirtualBalance = 50_0000,
            Weight = "0.5",
            IsVirtualBalanceEnabled = false,
            IsPurchaseEnabled = true
        };

        _elfConnector = new Connector
        {
            Symbol = "ELF",
            VirtualBalance = 100_0000,
            Weight = "0.6",
            IsPurchaseEnabled = true,
            IsVirtualBalanceEnabled = false
        };
    }
```
