### Title
Symbol List State Change Causes Resource Path Mismatch Leading to Permanent MultiToken Contract Serialization

### Summary
The `AddPathForTransactionFeeFreeAllowance()` function reads the `TransactionFeeFreeAllowancesSymbolList` state during `GetResourceInfo()` execution to declare write paths, but the same state is re-read during actual transaction execution. When `ConfigTransactionFeeFreeAllowances` modifies this list in the same block as `Transfer`/`TransferFrom` transactions, those transactions write to undeclared state paths, triggering conflict detection that permanently marks the MultiToken contract as non-parallelizable. [1](#0-0) 

### Finding Description

**Root Cause:** Time-of-check to time-of-use (TOCTOU) race condition on `TransactionFeeFreeAllowancesSymbolList` state between resource path declaration and execution.

The vulnerability occurs through the following execution flow:

1. **Resource Path Declaration Phase:** `GetResourceInfo()` is called on all transactions before execution as part of the transaction grouping process. [2](#0-1) 

2. **Stale Symbol List Read:** `AddPathForTransactionFeeFreeAllowance()` reads `State.TransactionFeeFreeAllowancesSymbolList.Value?.Symbols` and declares `WritePaths` for each symbol in the list at that moment. [3](#0-2) 

3. **Symbol List Modification:** `ConfigTransactionFeeFreeAllowances` (marked as NonParallelizable in the default case) executes first and adds new symbols to `TransactionFeeFreeAllowancesSymbolList`. [4](#0-3) [5](#0-4) 

4. **Fresh Symbol List Re-Read During Execution:** When `Transfer`/`TransferFrom` execute, `SetOrRefreshTransactionFeeFreeAllowances()` re-reads the MODIFIED symbol list and writes to `TransactionFeeFreeAllowances` and `TransactionFeeFreeAllowancesLastRefreshTimes` for the NEW symbols. [6](#0-5) 

5. **Path Mismatch Detection:** `ConflictingTransactionIdentificationService` compares declared paths from step 2 against actual state accesses from step 4, detects paths for new symbols that were not declared, and identifies a mismatch. [7](#0-6) 

6. **Permanent Contract Serialization:** The handler marks the MultiToken contract's code hash as `NonparallelContractCode`, causing ALL future transactions to this contract to be executed serially. [8](#0-7) 

**Why Existing Protections Fail:** Adding `TransactionFeeFreeAllowancesSymbolList` to `ReadPaths` only ensures the list read is serialized with writes to it, but does NOT prevent the declared `WritePaths` from becoming stale when the list is modified within the same block before execution. [9](#0-8) 

### Impact Explanation

**Operational Denial of Service - Permanent Performance Degradation:**

Once triggered, the MultiToken contract is marked as non-parallelizable, forcing ALL subsequent `Transfer`, `TransferFrom`, and other token operations across the ENTIRE blockchain to execute serially instead of in parallel. [10](#0-9) 

**Quantified Impact:**
- **Scope:** Affects every user performing token operations chain-wide
- **Duration:** Permanent until contract upgrade/redeployment
- **Throughput:** Token transaction throughput reduced from parallel (potentially 100s-1000s TPS) to serial (10s TPS)
- **Economic:** Chain becomes unusable for DeFi applications requiring high-frequency token operations

**Severity Justification:** HIGH - This is a permanent operational DoS of the most critical contract (MultiToken) on the blockchain. Unlike temporary DoS, this persists across all future blocks and requires contract upgrade to fix. The trigger condition (adding fee-free allowance symbols) is a legitimate governance operation, making this a design flaw rather than an attack.

### Likelihood Explanation

**Likelihood: MEDIUM-HIGH** - While requiring governance action, this occurs during normal protocol operations.

**Trigger Conditions:**
1. Parliament governance proposes and approves adding a new symbol to transaction fee-free allowances via `ConfigTransactionFeeFreeAllowances` [11](#0-10) 
2. The configuration transaction and ANY `Transfer`/`TransferFrom` transactions are included in the same block
3. No special attacker capabilities required - this is expected behavior

**Feasibility:**
- **Attacker Capability:** None required - this occurs during legitimate governance operations
- **Preconditions:** Normal blockchain operation with concurrent transactions
- **Detection:** Easily detected after occurrence (contract marked non-parallelizable), but difficult to prevent proactively
- **Frequency:** Every time governance adds fee-free allowance symbols and users perform transfers concurrently

**Probability:** Given that blocks typically contain multiple token transfers and governance operations happen periodically, co-occurrence is LIKELY during fee-free allowance configuration updates.

### Recommendation

**Primary Fix:** Implement two-phase state reading in `AddPathForTransactionFeeFreeAllowance()`:

```
// In GetResourceInfo, conservatively declare paths for ALL possible future symbols
// or use a separate immutable symbol list snapshot
```

**Specific Code-Level Mitigations:**

1. **Option A - Conservative Path Declaration:** Declare write paths for a maximum set of symbols (e.g., all configured symbols + buffer) instead of reading current state. Add state validation during execution to ensure declared paths cover actual accesses.

2. **Option B - Symbol List Versioning:** Introduce versioned symbol lists where `GetResourceInfo` uses a block-height-specific snapshot, and execution uses the same snapshot. Store symbol list versions keyed by block height.

3. **Option C - Explicit Non-Parallelizable Marking:** Mark `Transfer`/`TransferFrom` as `NonParallelizable` when `TransactionFeeFreeAllowancesSymbolList` exists, accepting serial execution as trade-off for correctness.

**Invariant to Enforce:**
```
ASSERT: Set(declared_write_paths) âŠ‡ Set(actual_state_writes) 
```
Add runtime check in execution plugins to validate this invariant before completing transactions.

**Test Cases:**
1. Configure fee-free allowances with symbol "ELF" 
2. In same block: execute `ConfigTransactionFeeFreeAllowances` adding "BTC" + `Transfer` transaction
3. Verify: Transfer transaction either (a) does not write to BTC paths, or (b) declared BTC paths in `GetResourceInfo`
4. Verify: MultiToken contract remains parallelizable after block execution

### Proof of Concept

**Initial State:**
- `TransactionFeeFreeAllowancesSymbolList.Symbols = ["ELF", "USDT"]`
- MultiToken contract is parallelizable
- Alice has sufficient ELF balance for transfer

**Transaction Sequence (Same Block):**

**Transaction 1:** Parliament governance calls `ConfigTransactionFeeFreeAllowances` to add "BTC" to fee-free symbols
- Marked `NonParallelizable`, executes first in block
- Modifies: `TransactionFeeFreeAllowancesSymbolList.Symbols = ["ELF", "USDT", "BTC"]` [12](#0-11) 

**Transaction 2:** Alice calls `Transfer(to: Bob, symbol: "ELF", amount: 100)`
- `GetResourceInfo()` called BEFORE block execution, reads symbol list = ["ELF", "USDT"]
- Declares `WritePaths`: `[TransactionFeeFreeAllowances[Alice][ELF], TransactionFeeFreeAllowances[Alice][USDT], ...]`
- Executes AFTER Transaction 1
- `SetOrRefreshTransactionFeeFreeAllowances()` reads NEW list = ["ELF", "USDT", "BTC"] [13](#0-12) 
- Writes to: `TransactionFeeFreeAllowances[Alice][BTC]` (NOT in declared paths!)

**Expected Result:** Transaction 2 executes successfully, paths match declarations

**Actual Result:** 
- Transaction 2 writes to undeclared path `TransactionFeeFreeAllowances[Alice][BTC]`
- Conflict detection identifies path mismatch [14](#0-13) 
- MultiToken contract marked as `NonparallelContractCode` [15](#0-14) 
- ALL future token transfers execute serially

**Success Condition for Exploit:** After block execution, query `INonparallelContractCodeProvider` for MultiToken contract address - it returns a `NonparallelContractCode` entry, confirming permanent serialization.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L29-29)
```csharp
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L66-68)
```csharp
            default:
                return new ResourceInfo { NonParallelizable = true };
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L148-167)
```csharp
    private void AddPathForTransactionFeeFreeAllowance(ResourceInfo resourceInfo, Address from)
    {
        var symbols = State.TransactionFeeFreeAllowancesSymbolList.Value?.Symbols;
        if (symbols != null)
        {
            foreach (var symbol in symbols)
            {
                resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.TransactionFeeFreeAllowances),
                    from.ToBase58(), symbol));
                resourceInfo.WritePaths.Add(GetPath(
                    nameof(TokenContractState.TransactionFeeFreeAllowancesLastRefreshTimes), from.ToBase58(), symbol));

                var path = GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesConfigMap), symbol);
                if (!resourceInfo.ReadPaths.Contains(path))
                {
                    resourceInfo.ReadPaths.Add(path);
                }
            }
        }
    }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/TransactionGrouper.cs (L35-48)
```csharp
    public async Task<GroupedTransactions> GroupAsync(IChainContext chainContext, List<Transaction> transactions)
    {
        Logger.LogTrace("Entered GroupAsync");

        var toBeGrouped = GetTransactionsToBeGrouped(transactions, out var groupedTransactions);

        using (var cts = new CancellationTokenSource(_options.GroupingTimeOut))
        {
            var parallelizables = new List<TransactionWithResourceInfo>();

            Logger.LogTrace("Extracting resources for transactions.");
            var txsWithResources =
                await _resourceExtractionService.GetResourcesAsync(chainContext, toBeGrouped, cts.Token);
            Logger.LogTrace("Completed resource extraction.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L302-319)
```csharp
    private void SetOrRefreshTransactionFeeFreeAllowances(Address address)
    {
        var config = State.TransactionFeeFreeAllowancesSymbolList.Value;
        if (config == null) return;

        foreach (var symbol in config.Symbols)
        {
            if (State.Balances[address][symbol] <
                State.TransactionFeeFreeAllowancesConfigMap[symbol].Threshold) continue;
            var lastRefreshTime = State.TransactionFeeFreeAllowancesLastRefreshTimes[address][symbol];

            if (lastRefreshTime != null && State.TransactionFeeFreeAllowancesConfigMap[symbol].RefreshSeconds >
                (Context.CurrentBlockTime - lastRefreshTime).Seconds) continue;

            State.TransactionFeeFreeAllowancesLastRefreshTimes[address][symbol] = Context.CurrentBlockTime;
            State.TransactionFeeFreeAllowances[address][symbol] =
                State.TransactionFeeFreeAllowancesConfigMap[symbol].FreeAllowances.Clone();
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1224-1227)
```csharp
    public override Empty ConfigTransactionFeeFreeAllowances(ConfigTransactionFeeFreeAllowancesInput input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        Assert(input.Value != null && input.Value.Count > 0, "Invalid input");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1259-1262)
```csharp
            if (!State.TransactionFeeFreeAllowancesSymbolList.Value.Symbols.Contains(allowances.Symbol))
            {
                State.TransactionFeeFreeAllowancesSymbolList.Value.Symbols.Add(allowances.Symbol);
            }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/ConflictingTransactionIdentificationService.cs (L61-71)
```csharp
        foreach (var txnWithResource in txnWithResourceList)
        {
            var extracted = new HashSet<string>(txnWithResource.TransactionResourceInfo.WritePaths
                .Concat(txnWithResource.TransactionResourceInfo.ReadPaths).Select(p => p.ToStateKey()));
            extracted.ExceptWith(readOnlyKeys);
            var actual = GetKeys(returnSetLookup[txnWithResource.Transaction.GetHash()]);
            actual.ExceptWith(extracted);
            if (actual.Count == 0) continue;
            Logger.LogDebug($"Conflict keys:{string.Join(";", actual)}");
            wrongTxnWithResources.Add(txnWithResource);
        }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Application/ConflictingTransactionsFoundInParallelGroupsEventHandler.cs (L39-49)
```csharp
        var dic = wrongTxWithResources.GroupBy(t => t.Transaction.To)
            .ToDictionary(g => g.Key, g => new NonparallelContractCode
            {
                CodeHash = g.First().TransactionResourceInfo.ContractHash
            });

        await _nonparallelContractCodeProvider.SetNonparallelContractCodeAsync(new BlockIndex
        {
            BlockHash = eventData.BlockHeader.GetHash(),
            BlockHeight = eventData.BlockHeader.Height
        }, dic);
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/ResourceExtractionService.cs (L144-153)
```csharp
            var nonparallelContractCode =
                await _nonparallelContractCodeProvider.GetNonparallelContractCodeAsync(chainContext, address);
            if (nonparallelContractCode != null && nonparallelContractCode.CodeHash == executive.ContractHash)
                return new TransactionResourceInfo
                {
                    TransactionId = transaction.GetHash(),
                    ParallelType = ParallelType.NonParallelizable,
                    ContractHash = executive.ContractHash,
                    IsNonparallelContractCode = true
                };
```
