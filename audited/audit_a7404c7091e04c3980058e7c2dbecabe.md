# Audit Report

## Title
Missing Balance Validation Before Virtual Transfers in Profit Claiming Creates Permanent Fund Access DoS

## Summary
The `ProfitAllPeriods()` function in the Profit contract performs multiple virtual token transfers across periods without pre-validating balance availability. When any single inline transfer fails due to insufficient funds, the entire `ClaimProfits` transaction reverts, permanently blocking beneficiaries from accessing their legitimately earned profits from any period. This creates an inconsistent security pattern, as other parts of the same contract implement balance checks before virtual transfers.

## Finding Description

The vulnerability exists in the `ProfitAllPeriods()` function where it loops through multiple periods and queues virtual token transfers using `Context.SendVirtualInline()` without checking whether each period's virtual address has sufficient balance. [1](#0-0) 

The `SendVirtualInline()` method only queues inline transactions for later execution without providing immediate feedback on transfer success: [2](#0-1) 

When inline transactions execute sequentially, if any fails, the runtime immediately halts execution and skips remaining inline transactions: [3](#0-2) 

Token transfers fail when insufficient balance exists: [4](#0-3) 

The failure propagates up causing the entire parent transaction to be marked as failed: [5](#0-4) 

The `ClaimProfits` function provides no mechanism to claim specific periods or skip problematic ones - beneficiaries must claim all outstanding periods at once: [6](#0-5) 

**Critical Inconsistency**: Other parts of the same codebase DO implement balance checking before calling `SendVirtualInline()`, using the pattern of querying balance first and using `continue` to skip insufficient funds: [7](#0-6) 

This protective pattern in `BurnProfits` demonstrates that the developers were aware insufficient balance is a realistic scenario that requires defensive handling, yet this same pattern was not applied to `ProfitAllPeriods()`.

## Impact Explanation

**Direct Fund Impact**: Beneficiaries become permanently unable to withdraw their legitimately earned profits. Even if 99 periods have sufficient balance and 1 period has insufficient balance, the beneficiary cannot claim ANY profits from any period.

**State Lock**: The `lastProfitPeriod` field cannot be updated when the transaction fails: [8](#0-7) 

This creates a deadlock where profits remain inaccessible indefinitely - the beneficiary cannot skip the problematic period and cannot update their claim progress.

**Severity**: HIGH - This constitutes a direct Denial of Service of the critical fund withdrawal mechanism, violating the fundamental security guarantee that beneficiaries can access their earned profit distributions.

## Likelihood Explanation

**Entry Point**: Public method `ClaimProfits()` callable by any beneficiary without special privileges.

**Realistic Preconditions**: The existence of balance checking in `BurnProfits` proves the developers considered insufficient balance a realistic scenario. Insufficient balance can occur through:

1. **Calculation bugs**: Errors in complex multi-period, multi-symbol, multi-beneficiary distribution calculations
2. **Rounding accumulation**: The `SafeCalculateProfits` function uses integer division which can accumulate discrepancies over many periods
3. **Sub-scheme distributions**: Complex interactions between parent schemes and sub-schemes
4. **Edge cases**: Unexpected interactions in the distribution workflow [9](#0-8) 

**Evidence of Realistic Concern**: The fact that developers implemented defensive balance checking with `continue` in `BurnProfits` but omitted it in `ProfitAllPeriods` represents an inconsistent security pattern that creates vulnerability.

**Complexity**: LOW - No special privileges required, occurs naturally from edge cases in normal operation.

**Probability**: MEDIUM - While normal operation should work correctly, the developers' own defensive code elsewhere proves this is a realistic concern requiring protection.

## Recommendation

Apply the same defensive pattern used in `BurnProfits` to `ProfitAllPeriods`. Before calling `SendVirtualInline`, check the period virtual address balance and use `continue` to skip periods with insufficient funds:

```csharp
if (!isView)
{
    if (distributedProfitsInformation.IsReleased && amount > 0)
    {
        // Check balance before attempting transfer
        var periodVirtualAddress = GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period);
        var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
        {
            Owner = Context.ConvertVirtualAddressToContractAddress(periodVirtualAddress),
            Symbol = symbol
        }).Balance;
        
        if (balance < amount)
        {
            // Skip this period-symbol combination if insufficient balance
            Context.LogDebug(() => 
                $"Insufficient balance for {symbol} in period {period}. Required: {amount}, Available: {balance}");
            continue;
        }
        
        Context.SendVirtualInline(periodVirtualAddress, 
            State.TokenContract.Value,
            nameof(State.TokenContract.Transfer), 
            new TransferInput { ... });
    }
    lastProfitPeriod = period + 1;
}
```

This allows beneficiaries to claim from all periods with sufficient balance while gracefully skipping problematic ones, preventing permanent fund access denial.

## Proof of Concept

```csharp
[Fact]
public async Task ClaimProfits_InsufficientBalance_BlocksAllClaims()
{
    // Setup: Create scheme with beneficiary
    var schemeId = await CreateSchemeAsync();
    var beneficiary = Accounts[0];
    
    await Creators[0].AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare 
        { 
            Beneficiary = beneficiary.Address, 
            Shares = 100 
        }
    });
    
    // Distribute for period 1 with sufficient balance
    await ContributeAsync(schemeId, 1000);
    await Creators[0].DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1,
        AmountsMap = { { "ELF", 1000 } }
    });
    
    // Distribute for period 2 but manually drain the period virtual address
    await ContributeAsync(schemeId, 1000);
    await Creators[0].DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 2,
        AmountsMap = { { "ELF", 1000 } }
    });
    
    // Manually drain period 2's virtual address balance
    var period2VirtualAddress = GetDistributedPeriodProfitsVirtualAddress(schemeId, 2);
    // (Implementation detail: transfer tokens out of period 2 virtual address)
    
    // Attempt to claim profits - should fail entirely
    var result = await beneficiary.ClaimProfits.SendWithExceptionAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId
    });
    
    // Transaction fails with insufficient balance error
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Insufficient balance");
    
    // Beneficiary cannot access even period 1's valid profits
    var profits = await GetProfitsMap(schemeId, beneficiary.Address);
    profits["ELF"].ShouldBe(2000); // Still shows 2000 owed but inaccessible
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L530-552)
```csharp
            if (amount > 0)
            {
                var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = symbol
                });
                if (balanceOfToken.Balance < amount)
                    continue;
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = Context.Self,
                        Amount = amount,
                        Symbol = symbol
                    }.ToByteString());
                State.TokenContract.Burn.Send(new BurnInput
                {
                    Amount = amount,
                    Symbol = symbol
                });
                distributedProfitsInfo.AmountsMap.Add(symbol, -amount);
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L750-785)
```csharp
    public override Empty ClaimProfits(ClaimProfitsInput input)
    {
        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null) throw new AssertionException("Scheme not found.");
        var beneficiary = input.Beneficiary ?? Context.Sender;
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][beneficiary];
        if (profitDetails == null) throw new AssertionException("Profit details not found.");

        Context.LogDebug(
            () => $"{Context.Sender} is trying to profit from {input.SchemeId.ToHex()} for {beneficiary}.");

        // LastProfitPeriod is set as 0 at the very beginning, and be updated as current period every time when it is claimed.
        // What's more, LastProfitPeriod can also be +1 more than endPeroid, for it always points to the next period to claim.
        // So if LastProfitPeriod is 0, that means this profitDetail hasn't be claimed before, so just check whether it is a valid one;
        // And if a LastProfitPeriod is larger than EndPeriod, it should not be claimed, and should be removed later.
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
        var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();

        Context.LogDebug(() =>
            $"Profitable details: {profitableDetails.Aggregate("\n", (profit1, profit2) => profit1.ToString() + "\n" + profit2)}");

        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
        // Only can get profit from last profit period to actual last period (profit.CurrentPeriod - 1),
        // because current period not released yet.
        for (var i = 0; i < profitableDetailCount; i++)
        {
            var profitDetail = profitableDetails[i];
            if (profitDetail.LastProfitPeriod == 0)
                // This detail never performed profit before.
                profitDetail.LastProfitPeriod = profitDetail.StartPeriod;

            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L887-895)
```csharp
                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L908-920)
```csharp
                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }

            profitsMap.Add(symbol, totalAmount);
        }

        profitDetail.LastProfitPeriod = lastProfitPeriod;

        return profitsMap;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L239-249)
```csharp
    public void SendVirtualInline(Hash fromVirtualAddress, Address toAddress, string methodName,
        ByteString args)
    {
        TransactionContext.Trace.InlineTransactions.Add(new Transaction
        {
            From = ConvertVirtualAddressToContractAddress(fromVirtualAddress, Self),
            To = toAddress,
            MethodName = methodName,
            Params = args
        });
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L236-243)
```csharp
            var inlineTrace = await ExecuteOneAsync(singleTxExecutingDto, cancellationToken);

            if (inlineTrace == null)
                break;
            trace.InlineTraces.Add(inlineTrace);
            if (!inlineTrace.IsSuccessful())
                // Already failed, no need to execute remaining inline transactions
                break;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L116-125)
```csharp
    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```

**File:** src/AElf.Kernel.Core/Extensions/TransactionTraceExtensions.cs (L8-19)
```csharp
    public static bool IsSuccessful(this TransactionTrace txTrace)
    {
        if (txTrace.ExecutionStatus != ExecutionStatus.Executed) return false;

        if (txTrace.PreTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.InlineTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.PostTraces.Any(trace => !trace.IsSuccessful())) return false;

        return true;
    }
```
