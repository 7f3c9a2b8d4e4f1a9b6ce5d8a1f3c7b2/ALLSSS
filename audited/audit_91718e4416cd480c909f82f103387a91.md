### Title
Missing Authorization Contract Validation Allows Permanent Governance Bypass in Method Fee Controller

### Summary
The `CheckOrganizationExist` function in AEDPoS contract fails to verify that `authorityInfo.ContractAddress` is a legitimate authorization contract (Parliament/Association/Referendum) before making cross-contract calls. This allows an attacker controlling the current governance organization to permanently break the governance mechanism by substituting a malicious contract, enabling unauthorized control over method fee settings for consensus operations.

### Finding Description

The vulnerability exists in the `CheckOrganizationExist` function which blindly calls an arbitrary contract address without validation: [1](#0-0) 

This function is invoked during `ChangeMethodFeeController` to validate new authority information: [2](#0-1) 

**Root Cause**: The function accepts any contract address in `authorityInfo.ContractAddress` and calls its `ValidateOrganizationExist` method without verifying the contract is one of the three legitimate system authorization contracts (Parliament, Association, or Referendum).

**Why Existing Protections Fail**: 
- Line 28 only checks that the caller is the current controller's owner (via governance proposal execution)
- Line 29's `CheckOrganizationExist` validates organization existence according to the *target* contract, not the legitimacy of the contract itself
- No validation against known system contract addresses exists

The AElf codebase provides a mechanism to validate system contracts through the Genesis contract: [3](#0-2) 

However, `CheckOrganizationExist` does not utilize this validation mechanism. The legitimate authorization contracts are registered as system contracts: [4](#0-3) 

**Execution Path**: When a governance proposal is released, it calls the target contract method via virtual inline transaction: [5](#0-4) 

This sets `Context.Sender` to the organization address, passing the authorization check but allowing malicious `AuthorityInfo` parameters.

### Impact Explanation

**Concrete Harm**:
1. **Complete Governance Bypass**: Once the controller is changed to point to a malicious contract with an attacker-controlled `OwnerAddress`, the attacker can call `SetMethodFee` directly without any governance approval: [6](#0-5) 

2. **Consensus Operation Disruption**: The attacker can set arbitrary fees for critical consensus methods including `InitialAElfConsensusContract`, `FirstRound`, `UpdateValue`, `UpdateTinyBlockInformation`, `NextRound`, and `NextTerm`.

3. **Economic Attack Vectors**:
   - Set extremely high fees to DoS consensus operations
   - Set zero fees to break the fee economic model
   - Manipulate fee structures to benefit specific actors

4. **Permanent Damage**: The governance mechanism for method fees is permanently broken once the malicious controller is set, requiring contract upgrade to fix.

**Affected Parties**: All network participants, miners, and the consensus mechanism integrity.

**Severity Justification**: HIGH - This breaks a critical governance invariant with permanent, protocol-wide impact on consensus operations and fee economics.

### Likelihood Explanation

**Attacker Capabilities Required**:
- Control over current governance organization (Parliament/Association/Referendum)
- This is achievable through legitimate means (e.g., miners control Parliament default organization, token holders control Association/Referendum)
- Ability to deploy a malicious contract implementing `ValidateOrganizationExist`

**Attack Complexity**: MEDIUM
1. Attacker deploys a malicious contract with a `ValidateOrganizationExist` method that returns true
2. Creates governance proposal calling `ChangeMethodFeeController` with malicious `AuthorityInfo`
3. Gets proposal approved through legitimate governance process
4. Releases proposal to execute the change
5. Now has direct control over method fees without governance

**Feasibility Conditions**:
- Requires legitimate governance control as precondition
- No technical barriers once governance access obtained
- Attack is not detectable until execution (malicious contract appears normal)
- Single successful proposal permanently breaks governance

**Detection Constraints**: The malicious contract can be deployed and appear legitimate until the controller change is executed, making pre-detection difficult.

**Probability Assessment**: MEDIUM-HIGH for actors who already have legitimate governance control (miners, large stakeholders), as it requires only a single malicious proposal.

### Recommendation

**Code-Level Mitigation**:

Modify `CheckOrganizationExist` to validate the contract address before making the call:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a legitimate authorization contract
    var isParliament = authorityInfo.ContractAddress == Context.GetContractAddressByName(
        SmartContractConstants.ParliamentContractSystemName);
    var isAssociation = authorityInfo.ContractAddress == Context.GetContractAddressByName(
        SmartContractConstants.AssociationContractSystemName);
    var isReferendum = authorityInfo.ContractAddress == Context.GetContractAddressByName(
        SmartContractConstants.ReferendumContractSystemName);
    
    Assert(isParliament || isAssociation || isReferendum, 
        "Invalid authorization contract address.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Invariant Checks to Add**:
- MethodFeeController.ContractAddress must always be one of the three system authorization contracts
- Add validation in `ChangeMethodFeeController` before calling `CheckOrganizationExist`

**Test Cases to Prevent Regression**:
1. Test `ChangeMethodFeeController` with arbitrary contract address (should fail)
2. Test with legitimate Parliament/Association/Referendum addresses (should succeed)
3. Test with contract that implements `ValidateOrganizationExist` but isn't a system authorization contract (should fail)
4. Verify the same fix is applied to all contracts using this pattern (all ACS1 implementations)

**Note**: This vulnerability affects all 15 contracts that implement the ACS1 standard with identical `CheckOrganizationExist` implementations, as revealed by the codebase analysis. A systemic fix across all affected contracts is required.

### Proof of Concept

**Initial State**:
- MethodFeeController points to Parliament default organization
- Attacker controls Parliament organization (e.g., is a miner or majority of miners)

**Attack Steps**:

1. **Attacker deploys malicious contract**:
```csharp
public class MaliciousAuthContract : ContractBase {
    public override BoolValue ValidateOrganizationExist(Address input) {
        return new BoolValue { Value = true };  // Always returns true
    }
}
```

2. **Create governance proposal**:
   - Target: AEDPoS contract
   - Method: `ChangeMethodFeeController`
   - Parameters: `AuthorityInfo { ContractAddress = malicious_contract, OwnerAddress = attacker_address }`

3. **Proposal approval through legitimate Parliament process**:
   - Miners approve the proposal
   - Proposal reaches release threshold

4. **Release proposal**:
   - Calls `ChangeMethodFeeController` with `Context.Sender = parliament_organization`
   - Line 28 check passes (sender is current controller)
   - Line 29 calls malicious contract's `ValidateOrganizationExist`, returns true
   - Line 32 sets controller to malicious contract and attacker address

5. **Direct method fee manipulation** (no governance needed):
   - Attacker calls `SetMethodFee` with arbitrary fees
   - Line 19 check passes (sender equals attacker address = OwnerAddress)
   - Fees are set without any governance approval

**Expected vs Actual Result**:
- **Expected**: Controller change should fail due to invalid authorization contract
- **Actual**: Controller change succeeds, governance permanently bypassed

**Success Condition**: After step 4, `GetMethodFeeController` returns `AuthorityInfo` pointing to malicious contract, and attacker can call `SetMethodFee` directly without governance proposals.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L13-23)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L25-34)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L83-88)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L59-64)
```csharp
    public override Empty ValidateSystemContractAddress(ValidateSystemContractAddressInput input)
    {
        var actualAddress = GetContractAddressByName(input.SystemContractHashName);
        Assert(actualAddress == input.Address, "Address not expected.");
        return new Empty();
    }
```

**File:** src/AElf.Sdk.CSharp/SmartContractConstants.cs (L18-36)
```csharp
    public static readonly Hash ParliamentContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Parliament");

    public static readonly Hash VoteContractSystemHashName = HashHelper.ComputeFrom("AElf.ContractNames.Vote");
    public static readonly Hash ProfitContractSystemHashName = HashHelper.ComputeFrom("AElf.ContractNames.Profit");

    public static readonly Hash CrossChainContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.CrossChain");

    public static readonly Hash TokenConverterContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.TokenConverter");

    public static readonly Hash EconomicContractSystemHashName = HashHelper.ComputeFrom("AElf.ContractNames.Economic");

    public static readonly Hash ReferendumContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Referendum");

    public static readonly Hash AssociationContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Association");
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```
