### Title
State Update Pattern Violation in SetTransactionFeeDelegations Causes Empty Delegatee Entries to Persist

### Summary
The `SetTransactionFeeDelegations` function in `TokenContract_Delegation.cs` contains a state consistency bug where empty delegatees (delegatees with zero delegations) are not properly removed from storage. The function writes state with the empty delegatee at line 83, then attempts removal at line 91 using direct state modification without write-back, violating the established pattern used elsewhere in the contract. This causes empty delegatee entries to accumulate in state, eventually blocking users from adding new legitimate delegatees when the `DELEGATEE_MAX_COUNT` limit of 24 is reached.

### Finding Description

In the `SetTransactionFeeDelegations` function, when an existing delegatee's delegations are updated to remove all tokens, the code follows this sequence: [1](#0-0) 

The problematic flow:
1. Lines 68-80: The delegations map is modified, potentially removing all delegations for a delegatee
2. Line 83: State is written with `allDelegatees`, which still contains the delegatee entry even if it now has zero delegations
3. Line 86: Checks if `Count != 0` - if true (has delegations), returns; if false (no delegations), continues
4. Line 91: Attempts to remove the empty delegatee using `State.TransactionFeeDelegateesMap[input.DelegatorAddress].Delegatees.Remove(delegateeAddress)`

The bug is that line 91 uses direct state modification without the proper read-modify-write-back pattern. Every other removal operation in this file follows the correct pattern: [2](#0-1) [3](#0-2) 

Both `RemoveTransactionFeeDelegator` and `RemoveTransactionFeeDelegatee` follow the pattern: read state into variable → modify variable → write back. Line 91 violates this by directly calling `Remove()` on a state property without re-assignment, which likely does not persist the change in AElf's state management system.

Additionally, the state write at line 83 occurs BEFORE checking whether the delegatee should be removed, creating an inconsistent intermediate state where the empty delegatee is already persisted.

### Impact Explanation

The impact is concrete and operationally significant:

1. **Storage Pollution**: Empty delegatee entries accumulate in state over time as users update and remove delegations
2. **Delegatee Limit DoS**: The contract enforces a hard limit on delegatee count: [4](#0-3) [5](#0-4) 
   
   Users who have accumulated empty delegatees will hit this 24-delegatee limit and be unable to add new legitimate delegatees, even though their "active" delegatees are fewer than 24.

3. **Gas Inefficiency**: During fee charging, the system iterates through all delegatees including empty ones: [6](#0-5) 
   
   Empty delegatees waste gas during iteration even though they will fail delegation checks.

4. **User Experience Degradation**: Users cannot manage their delegation relationships effectively once the limit is reached with ghost entries.

### Likelihood Explanation

The likelihood of this bug manifesting is **HIGH**:

**Reachability**: The `SetTransactionFeeDelegations` function is a public method callable by any user to manage their delegations. No special privileges required.

**Trigger Conditions**: The bug triggers in the normal flow when:
- A user has an existing delegatee with delegations
- The user calls `SetTransactionFeeDelegations` to remove all delegations by setting values to 0 or negative
- This is a standard operation for cleaning up unwanted delegatees

**Frequency**: Over the protocol's lifetime, as users repeatedly add and remove delegations (e.g., changing delegation amounts, switching delegatees), empty entries will accumulate. Each user can hit this bug up to 24 times before being completely blocked.

**Attack Complexity**: No attack needed - this is a logic bug that occurs during normal operation. Any user managing their delegations will encounter it.

**Economic Cost**: No economic cost to trigger - just normal delegation management transactions.

**Detection**: The existing test suite doesn't catch this bug: [7](#0-6) 

The test only checks if `delegations.Count` is 0, not whether the delegatee entry itself was removed from the map. The query function returns an empty object whether the delegatee doesn't exist OR exists with empty delegations, masking the bug.

### Recommendation

**Fix the state update pattern** by ensuring proper write-back after removal:

```csharp
// Option 1: Remove before writing state (cleanest)
if (allDelegateesMap[delegateeAddress].Delegations.Count == 0)
{
    allDelegateesMap.Remove(delegateeAddress);
    Context.Fire(new TransactionFeeDelegationCancelled()
    {
        Caller = Context.Sender,
        Delegatee = Context.Sender,
        Delegator = input.DelegatorAddress
    });
}

// Set and Fire logEvent
State.TransactionFeeDelegateesMap[input.DelegatorAddress] = allDelegatees;
```

OR

```csharp
// Option 2: Use proper read-modify-write pattern
State.TransactionFeeDelegateesMap[input.DelegatorAddress] = allDelegatees;

if (allDelegateesMap[delegateeAddress].Delegations.Count == 0)
{
    allDelegatees.Delegatees.Remove(delegateeAddress);
    State.TransactionFeeDelegateesMap[input.DelegatorAddress] = allDelegatees;
    Context.Fire(new TransactionFeeDelegationCancelled()
    {
        Caller = Context.Sender,
        Delegatee = Context.Sender,
        Delegator = input.DelegatorAddress
    });
}
```

**Add test coverage** to verify delegatee entries are actually removed:
```csharp
// After removing all delegations, verify delegatee not in list
var delegatees = await TokenContractStub.GetTransactionFeeDelegatees.CallAsync(
    new GetTransactionFeeDelegateesInput { DelegatorAddress = User1Address });
delegatees.DelegateeAddresses.ShouldNotContain(DefaultAddress);
```

**Add cleanup function** for users with existing empty delegatees to clear their state without counting toward gas/operations.

### Proof of Concept

**Initial State**:
1. User1 (delegator) has DefaultAddress (delegatee) with delegations: `{ELF: 1000, BASIC: 500}`
2. Delegatee count for User1: 1

**Exploitation Steps**:
1. DefaultAddress calls `SetTransactionFeeDelegations` to remove all delegations:
   ```
   Input: {
     DelegatorAddress: User1,
     Delegations: {ELF: 0, BASIC: 0}
   }
   ```
2. Function executes:
   - Line 68-73: Removes all delegation entries
   - Line 83: Writes state with empty delegatee
   - Line 86: Checks Count == 0 (true), continues
   - Line 91: Attempts removal but doesn't persist
   - Line 92-97: Fires cancellation event

**Expected Result**: 
- User1's delegatees map should be empty
- Query `GetTransactionFeeDelegatees(User1)` should return 0 delegatees

**Actual Result**:
- User1's delegatees map still contains DefaultAddress entry with empty delegations
- Query returns DefaultAddress in the list
- This counts toward the 24 delegatee limit
- Repeat 24 times → User1 cannot add ANY new delegatees

**Verification**:
Query `GetTransactionFeeDelegationsOfADelegatee(User1, DefaultAddress)` returns empty delegations, but `GetTransactionFeeDelegatees(User1)` still includes DefaultAddress, confirming the dangling entry exists.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L30-37)
```csharp
            // If there has been already DELEGATEE_MAX_COUNT delegatees, and still try to add，fail.
            if (allDelegateesMap.Count() >= TokenContractConstants.DELEGATEE_MAX_COUNT)
            {
                return new SetTransactionFeeDelegationsOutput()
                {
                    Success = false
                };
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L66-98)
```csharp
        else // This delegatee exists, so update
        {
            var delegationsMap = allDelegateesMap[delegateeAddress].Delegations;
            foreach (var (key, value) in delegationsToInput)
            {
                if (value <= 0 && delegationsMap.ContainsKey(key))
                {
                    delegationsMap.Remove(key);
                }
                else if (value > 0)
                {
                    AssertValidToken(key, value);
                    delegationsMap[key] = value;
                }
            }

            // Set and Fire logEvent
            State.TransactionFeeDelegateesMap[input.DelegatorAddress] = allDelegatees;

            // If a delegatee has no delegations, remove it!
            if (allDelegateesMap[delegateeAddress].Delegations.Count != 0)
                return new SetTransactionFeeDelegationsOutput()
                {
                    Success = true
                };
            State.TransactionFeeDelegateesMap[input.DelegatorAddress].Delegatees.Remove(delegateeAddress);
            Context.Fire(new TransactionFeeDelegationCancelled()
            {
                Caller = Context.Sender,
                Delegatee = Context.Sender,
                Delegator = input.DelegatorAddress
            });
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L122-124)
```csharp
        var delegatees = State.TransactionFeeDelegateesMap[input.DelegatorAddress];
        delegatees.Delegatees.Remove(Context.Sender.ToBase58());
        State.TransactionFeeDelegateesMap[input.DelegatorAddress] = delegatees;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L151-153)
```csharp
        var delegatees = State.TransactionFeeDelegateesMap[Context.Sender];
        delegatees.Delegatees.Remove(input.DelegateeAddress.ToBase58());
        State.TransactionFeeDelegateesMap[Context.Sender] = delegatees;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L18-18)
```csharp
    public const int DELEGATEE_MAX_COUNT = 24;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L183-207)
```csharp
        foreach (var (delegatee, delegations) in delegationInfo)
        {
            // compare current block height with the block height when the delegatee added
            if (Context.Transaction.RefBlockNumber < delegations.BlockHeight) continue;

            var delegateeBill = new TransactionFeeBill();
            var delegateeAllowanceBill = new TransactionFreeFeeAllowanceBill();
            var delegateeAddress = Address.FromBase58(delegatee);
            var delegateeChargingResult = ChargeTransactionFeesToBill(input, delegateeAddress,
                ref delegateeBill, ref delegateeAllowanceBill, fee, isSizeFeeFree, delegations);

            if (!delegateeChargingResult) continue;

            bill = delegateeBill;
            allowanceBill = delegateeAllowanceBill;
            fromAddress = delegateeAddress;
            chargingResult = true;
            if (!delegations.IsUnlimitedDelegate)
            {
                ModifyDelegation(delegateeBill, delegateeAllowanceBill, fromAddress, input.ContractAddress,
                    input.MethodName, delegatorAddress);
            }

            break;
        }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenDelegationTest.cs (L51-76)
```csharp
    public async Task SetTokenDelegation_removeDelegatee_Test()
    {
        await SetTokenDelegation_Test();
        var delegations = new Dictionary<string, long>
        {
            [NativeToken] = 0,
            [BasicFeeSymbol] = 0,
            [SizeFeeSymbol] = 0
        };
        await TokenContractStub.SetTransactionFeeDelegations.SendAsync(new SetTransactionFeeDelegationsInput()
        {
            DelegatorAddress = User1Address,
            Delegations =
            {
                delegations
            }
        });

        var delegateAllowance = await TokenContractStub.GetTransactionFeeDelegationsOfADelegatee.CallAsync(
            new GetTransactionFeeDelegationsOfADelegateeInput()
            {
                DelegateeAddress = DefaultAddress,
                DelegatorAddress = User1Address
            });
        delegateAllowance.Delegations.Count().ShouldBe(0);
    }
```
