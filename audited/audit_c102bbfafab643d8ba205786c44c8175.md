### Title
CheckOrganizationExist False Positive Vulnerability Enables Governance Bypass via Malicious Contract Validation

### Summary
The `CheckOrganizationExist` function in TokenHolderContract (and all contracts implementing ACS1) does not validate that the `AuthorityInfo.ContractAddress` points to a legitimate authorization contract (Parliament, Association, or Referendum). An attacker controlling the method fee controller can set a malicious contract address that always returns true for `ValidateOrganizationExist`, creating a false positive that allows them to bypass governance and directly manipulate method fees without proposals.

### Finding Description

The vulnerability exists in the `CheckOrganizationExist` function: [1](#0-0) 

This function is called during `ChangeMethodFeeController`: [2](#0-1) 

**Root Cause:** The function blindly calls `ValidateOrganizationExist` on whatever contract address is provided in `authorityInfo.ContractAddress` without verifying it's a legitimate authorization contract. There is no whitelist check or validation that this address corresponds to Parliament, Association, or Referendum system contracts.

**Why Protections Fail:** 
- The `Context.Call` implementation always creates a new object instance and never returns null: [3](#0-2) 

- If a malicious contract implements a `ValidateOrganizationExist` method that always returns `BoolValue { Value = true }`, the check passes even though no real governance organization exists.

- The only authorization check is that the sender equals the current controller's OwnerAddress: [4](#0-3) 

**Execution Path:**
1. Attacker controls current method fee controller (either initially or via successful proposal)
2. Attacker deploys malicious contract with `ValidateOrganizationExist` method returning true
3. Attacker calls `ChangeMethodFeeController` with `AuthorityInfo { ContractAddress: malicious_contract, OwnerAddress: attacker_EOA }`
4. `CheckOrganizationExist` calls malicious contract, receives true (FALSE POSITIVE)
5. New controller is set with attacker's EOA as OwnerAddress
6. Attacker can now directly call `SetMethodFee` without proposals

### Impact Explanation

**Governance Bypass:** The design intent is that method fee controllers should be governance organizations (Parliament/Association/Referendum) requiring proposals for changes: [5](#0-4) 

By setting a controller with an EOA as OwnerAddress, the attacker can directly invoke SetMethodFee: [6](#0-5) 

**Concrete Harm:**
- **Fee Manipulation:** Attacker sets arbitrary method fees (zero fees enabling free transactions or excessive fees causing DoS)
- **Economic Impact:** Breaking fee economics by eliminating or inflating transaction costs
- **Governance Undermining:** All future fee changes bypass multi-signature approval/voting
- **System-Wide:** This pattern exists in multiple critical contracts (MultiToken, Parliament, Association, Referendum, Treasury, etc.)

**Affected Parties:** All users of affected contracts, protocol treasury, governance participants

**Severity:** HIGH - Breaks fundamental governance invariant that fee controller changes require organization-based authorization

### Likelihood Explanation

**Attacker Capabilities:** 
- Must control current method fee controller OR successfully pass a malicious proposal to change controller
- Can deploy arbitrary smart contracts
- Has EOA address for transaction submission

**Attack Complexity:** LOW
1. Deploy malicious contract (< 10 lines of code)
2. Single transaction to `ChangeMethodFeeController` 
3. Subsequent direct calls to `SetMethodFee`

**Feasibility:** HIGH
- No special privileges required beyond initial controller access
- Attack is deterministic and guaranteed to succeed
- No timing or race condition dependencies
- The malicious controller persists indefinitely once set

**Detection Constraints:** 
- Controller changes are observable on-chain
- However, distinguishing malicious contract from legitimate authorization contract requires off-chain validation
- No automated on-chain prevention mechanism

**Probability:** HIGH if attacker gains controller access through any vector (compromised governance, malicious proposal approval, or initial misconfiguration)

### Recommendation

**Code-Level Mitigation:**

Validate that `ContractAddress` is one of the three legitimate authorization contracts:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a legitimate authorization contract
    var isValidContract = 
        authorityInfo.ContractAddress == Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName) ||
        authorityInfo.ContractAddress == Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName) ||
        authorityInfo.ContractAddress == Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    Assert(isValidContract, "ContractAddress must be a valid authorization contract.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**System Contract Constants Reference:** [7](#0-6) 

**Apply Fix To All Affected Contracts:**
The same pattern exists in approximately 15+ contracts implementing ACS1. All instances of `CheckOrganizationExist` or similar validation helpers must be updated: [8](#0-7) 

**Test Cases:**
1. Test that `ChangeMethodFeeController` rejects AuthorityInfo with non-whitelisted ContractAddress
2. Test that only Parliament/Association/Referendum contracts are accepted
3. Test that malicious contract addresses are rejected even if they implement ValidateOrganizationExist

### Proof of Concept

**Initial State:**
- TokenHolder contract deployed with Parliament as default method fee controller
- Attacker controls a governance organization that is the current controller

**Attack Steps:**

1. **Deploy Malicious Contract:**
```csharp
public class MaliciousAuthContract : SmartContract
{
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = true }; // Always returns true
    }
}
```

2. **Create Proposal to Change Controller:**
    - Create proposal calling `ChangeMethodFeeController`
    - AuthorityInfo: `{ ContractAddress: MaliciousAuthContract, OwnerAddress: AttackerEOA }`

3. **Approve and Release Proposal:**
    - Proposal passes through current governance (attacker-controlled organization)
    - Release executes `ChangeMethodFeeController`

4. **Exploit Result:**
    - `CheckOrganizationExist` calls MaliciousAuthContract.ValidateOrganizationExist â†’ returns true
    - Assertion passes (FALSE POSITIVE)
    - Controller updated to `{ ContractAddress: MaliciousAuthContract, OwnerAddress: AttackerEOA }`

5. **Direct Fee Manipulation:**
    - Attacker directly calls `SetMethodFee` from AttackerEOA
    - Authorization check passes: `Context.Sender == State.MethodFeeController.Value.OwnerAddress`
    - Fees updated without any proposal/voting

**Expected vs Actual:**
- **Expected:** ChangeMethodFeeController should reject non-organization controllers
- **Actual:** Accepts any contract claiming to validate organizations, enabling governance bypass

**Success Condition:** Attacker can repeatedly call SetMethodFee directly without creating proposals, demonstrating complete governance bypass.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L199-226)
```csharp
    public T Call<T>(Address fromAddress, Address toAddress, string methodName, ByteString args)
        where T : IMessage<T>, new()
    {
        var trace = AsyncHelper.RunSync(async () =>
        {
            var chainContext = new ChainContext
            {
                BlockHash = TransactionContext.PreviousBlockHash,
                BlockHeight = TransactionContext.BlockHeight - 1,
                StateCache = CachedStateProvider.Cache
            };

            var tx = new Transaction
            {
                From = fromAddress,
                To = toAddress,
                MethodName = methodName,
                Params = args
            };
            return await _transactionReadOnlyExecutionService.ExecuteAsync(chainContext, tx, CurrentBlockTime);
        });

        if (!trace.IsSuccessful()) throw new ContractCallException(trace.Error);

        var obj = new T();
        obj.MergeFrom(trace.ReturnValue);
        return obj;
    }
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ACS1ImplTest.cs (L157-188)
```csharp
    public async Task SetMethodFee_Success_Test()
    {
        var tokenSymbol = "ELF";
        var methodName = "Test";
        var basicFee = 111;
        var methodFeeController = await ElectionContractStub.GetMethodFeeController.CallAsync(new Empty());
        const string proposalCreationMethodName = nameof(ElectionContractStub.SetMethodFee);
        var proposalId = await CreateProposalAsync(ElectionContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName, new MethodFees
            {
                MethodName = methodName,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = tokenSymbol,
                        BasicFee = basicFee
                    }
                }
            });
        await ApproveWithMinersAsync(proposalId);
        var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId);
        releaseResult.TransactionResult.Error.ShouldBeNullOrEmpty();
        releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        var getMethodFee = await ElectionContractStub.GetMethodFee.CallAsync(new StringValue
        {
            Value = methodName
        });
        getMethodFee.Fees.Count.ShouldBe(1);
        getMethodFee.Fees[0].Symbol.ShouldBe(tokenSymbol);
        getMethodFee.Fees[0].BasicFee.ShouldBe(basicFee);
    }
```

**File:** src/AElf.Sdk.CSharp/SmartContractConstants.cs (L30-60)
```csharp
    public static readonly Hash EconomicContractSystemHashName = HashHelper.ComputeFrom("AElf.ContractNames.Economic");

    public static readonly Hash ReferendumContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Referendum");

    public static readonly Hash AssociationContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Association");

    public static readonly Hash ConfigurationContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Configuration");

    public static readonly Hash TokenHolderContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.TokenHolder");

    public static readonly string ElectionContractSystemName = GetStringName(ElectionContractSystemHashName);
    public static readonly string TreasuryContractSystemName = GetStringName(TreasuryContractSystemHashName);
    public static readonly string ConsensusContractSystemName = GetStringName(ConsensusContractSystemHashName);
    public static readonly string TokenContractSystemName = GetStringName(TokenContractSystemHashName);
    public static readonly string ParliamentContractSystemName = GetStringName(ParliamentContractSystemHashName);
    public static readonly string VoteContractSystemName = GetStringName(VoteContractSystemHashName);
    public static readonly string ProfitContractSystemName = GetStringName(ProfitContractSystemHashName);
    public static readonly string CrossChainContractSystemName = GetStringName(CrossChainContractSystemHashName);

    public static readonly string TokenConverterContractSystemName =
        GetStringName(TokenConverterContractSystemHashName);

    public static readonly string EconomicContractSystemName = GetStringName(EconomicContractSystemHashName);
    public static readonly string ReferendumContractSystemName = GetStringName(ReferendumContractSystemHashName);
    public static readonly string AssociationContractSystemName = GetStringName(AssociationContractSystemHashName);
    public static readonly string ConfigurationContractSystemName = GetStringName(ConfigurationContractSystemHashName);
    public static readonly string TokenHolderContractSystemName = GetStringName(TokenHolderContractSystemHashName);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```
