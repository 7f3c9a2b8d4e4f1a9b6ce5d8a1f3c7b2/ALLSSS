# Audit Report

## Title
Malicious Miner Can Manipulate ExtraBlockProducerOfPreviousRound to Grant Unauthorized Mining Privileges

## Summary
A malicious block producer can manipulate the `ExtraBlockProducerOfPreviousRound` field in the `NextTermInput` transaction parameter to differ from the block header's consensus extra data, bypassing validation to grant unauthorized early mining privileges and extra block rewards to a controlled miner at the start of a new term.

## Finding Description

The vulnerability exists due to a critical validation gap in the AEDPoS consensus mechanism. The `GetCheckableRound` method explicitly excludes the `ExtraBlockProducerOfPreviousRound` field from hash computation, only including `RoundNumber`, `TermNumber`, `RealTimeMinersInformation`, and `BlockchainAge`. [1](#0-0) 

During NextTerm block validation, `ValidateConsensusAfterExecution` compares Round hashes from the header and state, but since the hash excludes `ExtraBlockProducerOfPreviousRound`, this field is never validated. [2](#0-1) 

The `RoundTerminateValidationProvider` used for NextTerm validation only checks round and term number increments, not the `ExtraBlockProducerOfPreviousRound` field. [3](#0-2) 

**Attack Execution:**

1. When generating a NextTerm block, `GetConsensusExtraDataForNextTerm` correctly sets `ExtraBlockProducerOfPreviousRound` to the sender's pubkey in the header. [4](#0-3) 

2. `GenerateTransactionListByExtraData` creates the NextTerm transaction using `NextTermInput.Create(round, randomNumber)` which copies the `ExtraBlockProducerOfPreviousRound` field. [5](#0-4) 

3. The malicious miner modifies the transaction's `ExtraBlockProducerOfPreviousRound` to point to an attacker-controlled miner before including it in the block.

4. `ProcessNextTerm` executes and converts the malicious `NextTermInput` to a Round object, updating state with the manipulated value. [6](#0-5) 

5. Validation passes because the Round hash comparison excludes this field.

## Impact Explanation

The `ExtraBlockProducerOfPreviousRound` field grants critical mining privileges. In `ConsensusBehaviourProviderBase`, miners with this privilege can produce tiny blocks **before the new round starts** when `CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey` and time is before the round start time. [7](#0-6) 

Additionally, they can produce **additional tiny blocks beyond normal limits** during their time slot because they have two time slots recorded in the current round. [8](#0-7) 

More block production leads to higher `ProducedBlocks` count, which directly impacts mining reward distribution. When `ProcessNextTerm` donates mining rewards to the Treasury, the amount is calculated based on `previousRound.GetMinedBlocks()`. [9](#0-8) 

**Impact:** Direct theft of mining rewards through privilege manipulation. The legitimate miner loses their earned privileges and rewards while the attacker-controlled miner gains unearned rewards.

## Likelihood Explanation

**Attacker Requirements:**
- Must be a miner capable of producing a NextTerm block
- Requires ability to modify node software to alter transaction parameters before block inclusion
- No special cryptographic material needed

**Attack Complexity:** Low to Medium
- The miner simply modifies the `NextTermInput.ExtraBlockProducerOfPreviousRound` field after generating the transaction but before block inclusion
- The header remains unchanged with the correct value
- Validation passes due to the hash exclusion

**Feasibility:** High
- Any miner producing a NextTerm block can execute this attack
- NextTerm blocks occur at every term transition (regular occurrence)
- Detection is difficult as the block header appears valid
- The discrepancy only becomes apparent by comparing transaction parameters with header data

**Economic Rationality:** High
- Cost: Standard block production cost
- Benefit: Additional mining rewards from extra block production
- Attack can be repeated at every term transition

## Recommendation

Add explicit validation of the `ExtraBlockProducerOfPreviousRound` field in the NextTerm validation flow. Specifically:

1. In `RoundTerminateValidationProvider.ValidationForNextTerm`, add a check that compares the `ExtraBlockProducerOfPreviousRound` from the consensus extra data (header) with the value from the transaction parameter:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Validate term number
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // NEW: Validate ExtraBlockProducerOfPreviousRound matches sender
    if (extraData.Round.ExtraBlockProducerOfPreviousRound != extraData.SenderPubkey.ToHex())
        return new ValidationResult { Message = "ExtraBlockProducerOfPreviousRound must match block producer." };
    
    return new ValidationResult { Success = true };
}
```

2. Alternatively, include `ExtraBlockProducerOfPreviousRound` in the `GetCheckableRound` hash computation, though this may have broader implications for the consensus mechanism.

## Proof of Concept

```csharp
[Fact]
public async Task ExtraBlockProducerManipulation_UnauthorizedPrivileges_Test()
{
    // Setup: Mine blocks to approach term transition
    await MineSeveralBlocksToReachTermTransition();
    
    // Attacker is a miner producing the NextTerm block
    var attackerKeyPair = InitialCoreDataCenterKeyPairs[0];
    var victimKeyPair = InitialCoreDataCenterKeyPairs[1];
    KeyPairProvider.SetKeyPair(attackerKeyPair);
    
    // Generate legitimate NextTerm header data
    var consensusCommand = await GetConsensusCommandForNextTerm();
    var trigger = GetTriggerForNextTerm(consensusCommand);
    var headerExtraData = await AEDPoSContractStub.GetConsensusExtraData.CallAsync(trigger);
    var headerInfo = headerExtraData.ToConsensusHeaderInformation();
    
    // Verify header has correct ExtraBlockProducerOfPreviousRound (attacker)
    headerInfo.Round.ExtraBlockProducerOfPreviousRound.ShouldBe(attackerKeyPair.PublicKey.ToHex());
    
    // Generate NextTerm transaction
    var transactionList = await AEDPoSContractStub.GenerateConsensusTransactions.CallAsync(trigger);
    var nextTermInput = NextTermInput.Parser.ParseFrom(transactionList.Transactions[0].Params);
    
    // ATTACK: Modify transaction parameter to point to victim
    nextTermInput.ExtraBlockProducerOfPreviousRound = victimKeyPair.PublicKey.ToHex();
    
    // Execute malicious NextTerm transaction
    var result = await AEDPoSContractStub.NextTerm.SendAsync(nextTermInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify state was updated with malicious value
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    currentRound.ExtraBlockProducerOfPreviousRound.ShouldBe(victimKeyPair.PublicKey.ToHex());
    
    // Victim now has unauthorized mining privileges
    // Can produce blocks before new round starts and beyond normal limits
}
```

## Notes

This vulnerability breaks the fundamental trust assumption that consensus extra data in the block header matches the transaction parameters that update state. The `ExtraBlockProducerOfPreviousRound` field is critical for fair mining reward distribution, and its manipulation allows direct theft of mining privileges and rewards from legitimate miners.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L254-254)
```csharp
        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-163)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L71-79)
```csharp
                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L118-121)
```csharp
        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });
```
