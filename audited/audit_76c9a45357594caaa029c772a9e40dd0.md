### Title
Null Reference Exception in ProfitDetails Retrieval Causes DoS of TokenHolder Contract Functions

### Summary
The `GetProfitDetails` view method returns null when querying a non-existent beneficiary, causing NullReferenceException in dependent contracts. [1](#0-0)  The TokenHolder contract's `AddBeneficiary` and `RemoveBeneficiary` methods access the `.Details` property without null checking, causing transaction failures. [2](#0-1) [3](#0-2) 

### Finding Description

The Profit contract's `GetProfitDetails` method directly returns `State.ProfitDetailsMap[input.SchemeId][input.Beneficiary]` without null handling. [1](#0-0)  When a beneficiary has never been registered in a profit scheme, the MappedState returns null.

The TokenHolder contract's `AddBeneficiary` method calls `GetProfitDetails` and immediately accesses `detail.Details.Any()` without checking if `detail` is null. [2](#0-1)  When adding a NEW beneficiary (the primary use case), this causes a NullReferenceException.

Similarly, `RemoveBeneficiary` chains `.Details.Single()` directly on the call result, which crashes if the beneficiary doesn't exist. [3](#0-2) 

The Election contract also accesses `profitDetails.Details` without null checking. [4](#0-3) 

Note: The private `GetAllProfitsMap` method correctly handles null by returning an empty result, [5](#0-4)  but the public `GetProfitDetails` method does not follow this pattern.

### Impact Explanation

**Operational Impact - DoS of Critical TokenHolder Functions:**
- `AddBeneficiary` becomes non-functional for adding new beneficiaries, breaking the primary use case for profit distribution
- `RemoveBeneficiary` fails when called with invalid beneficiary addresses, allowing accidental or malicious DoS
- Election contract methods that query profit details for voters may fail

**Affected Parties:**
- DApp operators cannot add new token holders to profit schemes
- Users cannot be registered for staking rewards
- Token holder dividend distribution system becomes unusable

**Severity Justification:**
Medium severity - While no funds are at risk, core functionality of the TokenHolder profit distribution system is broken, preventing legitimate protocol operations.

### Likelihood Explanation

**Reachable Entry Point:**
`TokenHolderContract.AddBeneficiary` and `RemoveBeneficiary` are public methods callable by scheme managers. [6](#0-5) [7](#0-6) 

**Attack Complexity:**
Trivial - Simply call `AddBeneficiary` for any new beneficiary address. No special setup or permissions required beyond being a scheme manager.

**Feasibility:**
The Profit contract's `AddBeneficiary` method explicitly handles null `currentProfitDetails` by creating a new instance, [8](#0-7)  confirming that null values are expected. The TokenHolder contract fails to handle this expected behavior.

**Probability:**
High - This occurs in normal operations when:
1. Adding the first beneficiary to a new scheme
2. Adding any new beneficiary who hasn't been registered before  
3. Accidentally calling RemoveBeneficiary with wrong address

### Recommendation

**Fix for GetProfitDetails:**
```csharp
public override ProfitDetails GetProfitDetails(GetProfitDetailsInput input)
{
    return State.ProfitDetailsMap[input.SchemeId][input.Beneficiary] ?? new ProfitDetails();
}
```

**Alternative Fix for TokenHolder callers:**
Add null checks before accessing `.Details`:
```csharp
var detail = State.ProfitContract.GetProfitDetails.Call(...);
if (detail != null && detail.Details.Any())
{
    // existing logic
}
```

**Test Cases:**
1. Call `AddBeneficiary` for a beneficiary that has never been registered - should succeed
2. Call `RemoveBeneficiary` for a non-existent beneficiary - should fail gracefully with assertion, not NullReferenceException
3. Verify `GetProfitDetails` returns empty ProfitDetails (not null) for non-existent beneficiaries

### Proof of Concept

**Initial State:**
- TokenHolder profit scheme created with no beneficiaries

**Attack Steps:**
1. Call `TokenHolderContract.AddBeneficiary` with:
   - `Beneficiary`: Any new address that has never been registered
   - `Shares`: 100

**Expected Result:**
Beneficiary is successfully added to the profit scheme with 100 shares.

**Actual Result:**
Transaction fails with NullReferenceException when executing line 46 of TokenHolderContract.cs: `if (detail.Details.Any())` because `detail` is null.

**Success Condition:**
The transaction reverts with a NullReferenceException, preventing the primary use case of adding new beneficiaries to profit schemes.

### Citations

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L46-49)
```csharp
    public override ProfitDetails GetProfitDetails(GetProfitDetailsInput input)
    {
        return State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L108-110)
```csharp
        var profitDetails = State.ProfitDetailsMap[schemeId][beneficiary];

        if (profitDetails == null) return new GetAllProfitsMapOutput();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-38)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L40-46)
```csharp
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-71)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L74-78)
```csharp
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L170-177)
```csharp
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-199)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
```
