### Title
Consensus Order Manipulation via Hash.Empty PreviousInValue Selection

### Summary
Miners can manipulate their block production order in subsequent rounds by strategically choosing whether to reveal their `previousInValue` or allow it to default to `Hash.Empty`. Since the signature used for order calculation is computed before secret sharing recovery and never recalculated, miners can pre-compute both scenarios and select the option yielding a more favorable position, breaking the unpredictability of consensus randomness and providing unfair economic advantages.

### Finding Description

The vulnerability exists in the `GetConsensusExtraDataToPublishOutValue` function where `previousInValue` is initialized to `Hash.Empty` [1](#0-0)  and can remain at this value if self-validation fails [2](#0-1) .

The signature calculation uses this `previousInValue` [3](#0-2) , which XORs it with all previous round signatures [4](#0-3) . This signature is then used in `ApplyNormalConsensusData` to determine the miner's order in the next round [5](#0-4) .

**Critical Failure Points:**

1. The validation layer explicitly permits `Hash.Empty` as a valid `previousInValue` [6](#0-5) 

2. The consensus processing acknowledges that miners are allowed to withhold their in values [7](#0-6) 

3. While secret sharing can later recover the actual `previousInValue` [8](#0-7) , the signature used for order calculation is already set and never recalculated [9](#0-8) 

**Execution Path:**
When a miner produces a block in Round N+1, they know their secret `previousInValue` X from Round N and all public signatures from Round N. They can calculate two possible signatures:
- `SignatureA = CalculateSignature(X)` → Order A
- `SignatureB = CalculateSignature(Hash.Empty)` → Order B

By choosing whether to reveal X or trigger the Hash.Empty fallback, they select their preferred order position for Round N+2.

### Impact Explanation

**Consensus Integrity Compromise:**
The vulnerability breaks the cryptographic randomness guarantee of the AEDPoS consensus mechanism. The order calculation is designed to be unpredictable based on secret values, but miners can now predict and choose their positions.

**Economic Advantage:**
Block production order directly correlates with mining opportunities and rewards. Miners who consistently manipulate their positions to earlier slots gain:
- More frequent block production
- First-mover advantage in transaction selection
- Higher cumulative rewards over time

**Cumulative Effect:**
This attack can be executed every round without detection, compounding the unfair advantage. A miner consistently choosing positions 1-3 instead of random positions 1-N gains approximately (N-2)/N × 100% more block production opportunities in a perfectly distributed system.

**Affected Parties:**
- Honest miners suffer reduced rewards due to unfair competition
- Network decentralization is undermined as manipulating miners gain disproportionate influence
- End users face potential censorship if manipulating miners control transaction ordering

### Likelihood Explanation

**Attacker Requirements:**
- Must be an active consensus miner (requires staking and election)
- Needs access to previous round state data (publicly available on-chain)
- Requires basic computational ability to calculate two hash values

**Attack Complexity:**
LOW - The attack requires only:
1. Reading public previous round signatures from contract state
2. Computing two XOR-based signatures locally
3. Comparing resulting order positions
4. Choosing whether to reveal or withhold `previousInValue` in block production

**Feasibility:**
HIGHLY FEASIBLE - All preconditions are met:
- Entry point is the standard `UpdateValue` public method [10](#0-9) 
- No special permissions beyond being a miner
- No economic cost (no penalty for using Hash.Empty)
- Undetectable since both choices appear valid

**Detection:**
The attack is virtually undetectable because:
- Hash.Empty is explicitly permitted by validation
- No on-chain evidence distinguishes intentional manipulation from legitimate cases (e.g., first round, new miner)
- Transaction structure remains identical

**Economic Rationality:**
Executing this attack is economically rational as it provides guaranteed positive expected value with zero cost or risk of penalty.

### Recommendation

**Immediate Mitigation:**
Modify the validation to reject `Hash.Empty` as `previousInValue` except in explicitly allowed scenarios (first round of new term, replacement miners):

```
In UpdateValueValidationProvider.ValidatePreviousInValue:
- Remove or restrict line 46 that unconditionally accepts Hash.Empty
- Add context-aware validation: allow Hash.Empty only if:
  * IsFirstRoundOfCurrentTerm() returns true, OR
  * Miner is not in previous round (new/replacement miner)
```

**Signature Recalculation:**
After secret sharing recovers the actual `previousInValue`, recalculate the signature to correct the order:

```
In UpdateLatestSecretPieces after line 152:
- When a revealedInValue updates a miner's PreviousInValue from Hash.Empty
- Recalculate: miner.Signature = previousRound.CalculateSignature(revealedInValue)
- Recalculate: miner.SupposedOrderOfNextRound and resolve conflicts
```

**Penalty Mechanism:**
Implement economic disincentives for withholding `previousInValue`:
- Reduce mining rewards proportionally for miners using Hash.Empty
- Track and penalize repeated offenders similar to missed time slots
- Increment a "secret_withholding_count" that affects reputation

**Invariant Enforcement:**
Add assertion in `ApplyNormalConsensusData` [11](#0-10) :
```
Assert that previousInValue != Hash.Empty unless miner is in first round or is a replacement
```

**Test Cases:**
1. Verify that miners with valid previous rounds cannot use Hash.Empty
2. Test that secret sharing recovery triggers signature recalculation
3. Confirm penalty application for repeated Hash.Empty usage
4. Validate that legitimate cases (new miners, first round) still function

### Proof of Concept

**Initial State:**
- Blockchain at Round N
- Miner M has produced block with InValue X, OutValue = Hash(X), recorded on-chain
- Round N has 21 miners with publicly visible signatures S1...S21

**Attack Execution:**

**Step 1 - Pre-calculation (Off-chain):**
```
minerPosition = Round N miner M's position
previousRoundXOR = XOR(S1, S2, ..., S21)

// Option A: Reveal actual previousInValue
signatureA = XorAndCompute(X, previousRoundXOR)
orderA = (signatureA.ToInt64() % 21) + 1

// Option B: Use Hash.Empty fallback  
signatureB = XorAndCompute(Hash.Empty, previousRoundXOR)
orderB = (signatureB.ToInt64() % 21) + 1

if orderB < orderA:
    chosenStrategy = WITHHOLD
else:
    chosenStrategy = REVEAL
```

**Step 2 - Block Production (Round N+1):**
```
If chosenStrategy == WITHHOLD:
    // Provide invalid or null previousInValue in trigger information
    // OR provide value that fails self-check (line 81-85)
    triggerInfo.PreviousInValue = Hash.Empty // or invalid value
    
    // System falls back to Hash.Empty (line 85)
    // Signature calculated with Hash.Empty (line 92)
    // Order set to favorable orderB (line 21 of ApplyNormalConsensusData)
```

**Expected vs Actual Result:**
- **Expected:** Order should be unpredictable based on secret X
- **Actual:** Miner M achieves pre-selected favorable order position

**Success Condition:**
In Round N+2, query `GetCurrentRoundInformation()` and verify:
```
M.Order == orderB (chosen position)
M.Order != orderA (natural position if X was revealed)
M.PreviousInValue == Hash.Empty (in processed round state)
// No penalty applied to M's rewards
```

This demonstrates a deterministic method to manipulate consensus order through strategic `previousInValue` disclosure, violating the randomness guarantee of the AEDPoS consensus mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L70-70)
```csharp
        var previousInValue = Hash.Empty; // Just initial previous in value.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L85-85)
```csharp
                    previousInValue = Hash.Empty;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-47)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
