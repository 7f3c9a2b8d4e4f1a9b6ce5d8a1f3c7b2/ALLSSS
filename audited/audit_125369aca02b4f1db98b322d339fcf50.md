### Title
Contract Ownership Theft via Expired Proposal State Overwrite

### Summary
The `SendUserContractProposal()` function allows overwriting expired proposal metadata after the expiration period passes, but before the approved governance proposal is executed. An attacker can exploit this by submitting an identical contract deployment request after expiration, replacing the legitimate author field with their own address. When the original approved proposal is subsequently released, the contract deploys with the attacker as the owner instead of the legitimate proposer.

### Finding Description

**Location**: [1](#0-0) 

**Root Cause**: The expiration check at line 315 permits state overwrite for expired proposals without verifying whether an approved governance proposal is still pending execution: [2](#0-1) 

When the condition `Context.CurrentBlockTime >= registered.ExpiredTime` evaluates to true, the function proceeds to completely overwrite the `ContractProposingInputMap` state entry: [3](#0-2) 

**Execution Path**:

1. User A calls `DeployUserSmartContract` with contract code C, creating proposal hash H and state entry with `Author = UserA`: [4](#0-3) 

2. The governance proposal is created and approved by miners, but not yet released before the expiration time passes.

3. After expiration, an attacker submits an identical `UserContractDeploymentInput` (same category, code, and salt), generating the same hash H. The expiration check passes and the state is overwritten with `Author = Attacker`: [5](#0-4) 

4. When miners release the original approved proposal via `ReleaseApprovedUserSmartContract`, it retrieves the overwritten state: [6](#0-5) 

5. The proposal release triggers `PerformDeployUserSmartContract`, which deploys the contract using the `Author` field from the corrupted state: [7](#0-6) 

The critical issue is that `contractProposingInput.Author` at line 502-503 comes from the overwritten state, not from the original proposal.

**Why Protection Fails**: The contract has no mechanism to prevent state overwrite when an approved governance proposal is still pending execution. The expiration check only validates the state mapping's expiration time, not the status of the associated governance proposal in the code check controller contract.

### Impact Explanation

**Harm**: Complete theft of contract ownership and authorship rights.

**Affected Parties**: Any user who deploys contracts via `DeployUserSmartContract` or updates contracts via `UpdateUserSmartContract` where the approval-to-release window exceeds the expiration period.

**Concrete Damage**:
- The attacker gains full control as the contract author, including the ability to update the contract via `UpdateUserSmartContract` (which validates `Context.Sender == info.Author`): [8](#0-7) 

- The legitimate proposer loses all authorship rights despite their proposal being legitimately approved through governance.

- The attacker can subsequently transfer authorship via `SetContractAuthor`: [9](#0-8) 

**Severity Justification**: HIGH - This violates the fundamental governance invariant that approved proposals must execute with the original proposer's parameters. The attacker effectively hijacks an approved proposal to gain unauthorized contract ownership.

### Likelihood Explanation

**Attacker Capabilities**: Any user can call `DeployUserSmartContract` with arbitrary inputs. No special permissions required beyond the standard user contract deployment checks: [10](#0-9) 

**Attack Complexity**: LOW
- Attacker monitors for user contract deployment proposals
- Waits for expiration period to elapse (default period can be queried)
- Submits identical input to overwrite state
- No need to compromise miners or governance

**Feasibility Conditions**:
- The window between proposal approval and release must exceed the expiration period configured in `CodeCheckProposalExpirationTimePeriod`: [11](#0-10) 

- This is realistic when miners are slow to release approved proposals, during network congestion, or if expiration periods are set too short

**Detection Constraints**: The attack leaves no obvious on-chain evidence distinguishing it from legitimate re-proposals. The `CodeCheckRequired` event fires normally, and the final `ContractDeployed` event shows the attacker as author, which appears valid: [12](#0-11) 

**Probability**: MEDIUM-HIGH - The attack succeeds whenever approved proposals remain unreleased past expiration, which can occur due to operational delays or deliberately short expiration periods.

### Recommendation

**Code-Level Mitigation**:

1. Prevent state overwrite when status indicates an approved but unreleased proposal:

```csharp
private void SendUserContractProposal(Hash proposingInputHash, string releaseMethodName, ByteString @params)
{
    var registered = State.ContractProposingInputMap[proposingInputHash];
    // Modified check: reject if proposal exists and is either not expired OR already approved
    Assert(
        registered == null || 
        (Context.CurrentBlockTime >= registered.ExpiredTime && 
         registered.Status == ContractProposingInputStatus.Proposed), // Only allow overwrite if still in initial status
        "Already proposed or pending execution.");
    
    // Rest of function unchanged...
}
```

2. Add similar protection to `RegisterContractProposingData`: [13](#0-12) 

3. Consider extending expiration periods or implementing a grace period after approval.

**Invariant Checks**:
- Assert that `Status == Proposed` (not `CodeCheckProposed` or `CodeChecked`) before allowing state overwrite
- Add a check in `PerformDeployUserSmartContract` to verify that the retrieved author matches the expected proposer from the governance proposal metadata

**Test Cases**:
- Test Case 1: Attempt to overwrite expired proposal with status `CodeCheckProposed` (should fail)
- Test Case 2: Attempt to overwrite expired proposal with status `CodeChecked` (should fail)  
- Test Case 3: Verify that approved proposals can be released after expiration without author corruption
- Test Case 4: Verify legitimate re-proposal after complete expiration and failed governance approval

### Proof of Concept

**Initial State**:
- Genesis contract initialized with code check controller
- Expiration period set to 86400 seconds (1 day)

**Transaction Steps**:

1. **T0 (Block 100)**: UserA calls `DeployUserSmartContract({category: 0, code: <ContractCode>, salt: null})`
   - Proposal hash H created
   - State: `ContractProposingInputMap[H] = {Proposer: GenesisContract, Status: CodeCheckProposed, ExpiredTime: T0+86400, Author: UserA}`
   - Governance proposal P1 created in code check controller

2. **T1 (Block 200)**: Miners approve proposal P1 through code check controller governance

3. **T2 (Block 10000, 1+ day later)**: Proposal expires in state mapping (`CurrentBlockTime > ExpiredTime`)

4. **T3 (Block 10001)**: Attacker calls `DeployUserSmartContract({category: 0, code: <SameContractCode>, salt: null})`
   - Same hash H computed
   - Expiration check at line 315 passes: `CurrentBlockTime >= registered.ExpiredTime` 
   - State overwritten: `ContractProposingInputMap[H] = {Proposer: GenesisContract, Status: CodeCheckProposed, ExpiredTime: T3+86400, Author: Attacker}`

5. **T4 (Block 10002)**: Miner calls `ReleaseApprovedUserSmartContract({ProposalId: P1, ProposedContractInputHash: H})`
   - Retrieves `ContractProposingInputMap[H]` → gets Attacker's data
   - Changes status to `CodeChecked`
   - Releases proposal P1

6. **T5 (Block 10003)**: Governance contract executes P1 → calls `PerformDeployUserSmartContract` with UserA's original input
   - Calculates hash H from input
   - Retrieves `ContractProposingInputMap[H]` → gets `{Author: Attacker}`
   - Deploys contract with `author = Attacker` instead of `author = UserA`

**Expected Result**: Contract deployed with author = UserA

**Actual Result**: Contract deployed with author = Attacker (ownership theft successful)

**Success Condition**: Query `GetContractInfo(deployedAddress)` shows `author = Attacker` while the approved governance proposal P1 was originally proposed by UserA.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L289-294)
```csharp
    private int GetCodeCheckProposalExpirationTimePeriod()
    {
        return State.CodeCheckProposalExpirationTimePeriod.Value == 0
            ? DefaultCodeCheckProposalExpirationTimePeriod
            : State.CodeCheckProposalExpirationTimePeriod.Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L312-342)
```csharp
    private void SendUserContractProposal(Hash proposingInputHash, string releaseMethodName, ByteString @params)
    {
        var registered = State.ContractProposingInputMap[proposingInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var proposedInfo = new ContractProposingInput
        {
            Proposer = Context.Self,
            Status = ContractProposingInputStatus.CodeCheckProposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod()),
            Author = Context.Sender
        };
        State.ContractProposingInputMap[proposingInputHash] = proposedInfo;

        var codeCheckController = State.CodeCheckController.Value;
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName = releaseMethodName,
                Params = @params,
                OrganizationAddress = codeCheckController.OwnerAddress,
                ExpiredTime = proposedInfo.ExpiredTime
            },
            OriginProposer = Context.Self
        };

        Context.SendInline(codeCheckController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L409-442)
```csharp
    public override DeployUserSmartContractOutput DeployUserSmartContract(UserContractDeploymentInput input)
    {
        AssertInlineDeployOrUpdateUserContract();
        AssertUserDeployContract();

        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        Context.LogDebug(() => "BasicContractZero - Deployment user contract hash: " + codeHash.ToHex());

        AssertContractNotExists(codeHash);

        if (input.Salt != null)
        {
            AssertContractAddressAvailable(Context.Sender, input.Salt);
        }

        var proposedContractInputHash = CalculateHashFromInput(input);
        SendUserContractProposal(proposedContractInputHash,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.PerformDeployUserSmartContract),
            input.ToByteString());

        // Fire event to trigger BPs checking contract code
        Context.Fire(new CodeCheckRequired
        {
            Code = input.Code,
            ProposedContractInputHash = proposedContractInputHash,
            Category = input.Category,
            IsSystemContract = false,
            IsUserContract = true
        });

        return new DeployUserSmartContractOutput
        {
            CodeHash = codeHash
        };
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L445-473)
```csharp
    public override Empty UpdateUserSmartContract(UserContractUpdateInput input)
    {
        AssertInlineDeployOrUpdateUserContract();

        var info = State.ContractInfos[input.Address];
        Assert(info != null, "Contract not found.");
        Assert(Context.Sender == info.Author, "No permission.");
        Assert(info.Deployer == null || info.Deployer == Context.Sender, "No permission to update.");
        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        Assert(info.CodeHash != codeHash, "Code is not changed.");
        AssertContractNotExists(codeHash);
        AssertContractVersion(info.ContractVersion, input.Code, info.Category);

        var proposedContractInputHash = CalculateHashFromInput(input);
        SendUserContractProposal(proposedContractInputHash,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.PerformUpdateUserSmartContract),
            input.ToByteString());

        // Fire event to trigger BPs checking contract code
        Context.Fire(new CodeCheckRequired
        {
            Code = input.Code,
            ProposedContractInputHash = proposedContractInputHash,
            Category = info.Category,
            IsSystemContract = false,
            IsUserContract = true
        });

        return new Empty();
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L476-492)
```csharp
    public override Empty ReleaseApprovedUserSmartContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];

        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.CodeCheckProposed &&
            contractProposingInput.Proposer == Context.Self, "Invalid contract proposing status.");

        AssertCurrentMiner();

        contractProposingInput.Status = ContractProposingInputStatus.CodeChecked;
        State.ContractProposingInputMap[input.ProposedContractInputHash] = contractProposingInput;
        var codeCheckController = State.CodeCheckController.Value;
        Context.SendInline(codeCheckController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release), input.ProposalId);
        return new Empty();
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L495-504)
```csharp
    public override Address PerformDeployUserSmartContract(UserContractDeploymentInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value.OwnerAddress);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address = DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
            contractProposingInput.Author, true, contractProposingInput.Author, input.Salt);
        return address;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L519-535)
```csharp
    public override Empty SetContractAuthor(SetContractAuthorInput input)
    {
        var info = State.ContractInfos[input.ContractAddress];
        Assert(info != null, "Contract not found.");
        var oldAuthor = info.Author;
        Assert(Context.Sender == info.Author, "No permission.");
        info.Author = input.NewAuthor;
        State.ContractInfos[input.ContractAddress] = info;
        Context.Fire(new AuthorUpdated()
        {
            Address = input.ContractAddress,
            OldAuthor = oldAuthor,
            NewAuthor = input.NewAuthor
        });

        return new Empty();
    }
```
