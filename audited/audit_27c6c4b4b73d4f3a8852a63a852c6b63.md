# Audit Report

## Title
Branch Count DoS in Association Contract via Large Organization Member Lists

## Summary
The Association contract contains a critical vulnerability where organizations with large member lists (5,000-10,000+ members) can be created successfully but become permanently non-functional once proposals receive multiple votes. The O(M×N) nested iteration complexity in threshold validation functions causes branch count limit exceptions, resulting in complete governance DoS.

## Finding Description

The vulnerability stems from inefficient threshold validation logic in the `IsReleaseThresholdReached` helper method and its dependent functions. [1](#0-0) 

Three critical functions perform nested iterations with O(M×N) complexity:

1. **IsProposalRejected** uses `Count()` with a predicate that calls `Contains()` for each rejection [2](#0-1) 

2. **IsProposalAbstained** performs the same pattern for abstentions [3](#0-2) 

3. **CheckEnoughVoteAndApprovals** repeats this for approvals [4](#0-3) 

The `OrganizationMemberList.Contains()` method performs a linear search through the `RepeatedField<Address>` [5](#0-4)  where `organization_members` is defined as a protobuf repeated field. [6](#0-5) 

Each iteration consumes branch counts tracked by AElf's ExecutionObserver. The branch count threshold is set to 15,000. [7](#0-6) 

**Attack Vector:**

The `GetProposal` view function calls `IsReleaseThresholdReached` [8](#0-7)  and the `Release` function does the same. [9](#0-8) 

With 10,000 organization members and just 2 votes, the nested iterations consume 20,000 branch counts (2 × 10,000), exceeding the 15,000 limit and causing a `RuntimeBranchThresholdExceededException`.

**Why Existing Protections Fail:**

Organization creation validation only checks for duplicates using `AnyDuplicate()` [10](#0-9)  which uses `GroupBy` with O(N) complexity. [11](#0-10) 

The transaction size limit is 5MB [12](#0-11)  allowing 10,000+ addresses (~340KB). No maximum member list size validation exists in the code.

## Impact Explanation

**HIGH SEVERITY - Complete Governance DoS**

Once triggered, this vulnerability causes:

1. **Permanent GetProposal Failure**: The view function becomes unusable for checking proposal status, breaking all UI/monitoring tools
2. **Permanent Release Failure**: Proposals cannot be executed even if approved, blocking all governance actions
3. **Organization Paralysis**: The organization becomes completely non-functional with no recovery mechanism

**Quantified Impact:**
- 10,000 members + 2 votes = 20,000 branches (33% over limit)
- 7,500 members + 2 votes = 15,000 branches (at limit)
- 5,000 members + 3 votes = 15,000 branches (at limit)

All members lose governance rights, and any protocols depending on the organization for critical operations (treasury management, parameter updates, contract upgrades) are frozen indefinitely.

## Likelihood Explanation

**HIGH LIKELIHOOD**

**Attacker Requirements:**
- Access to public `CreateOrganization` function (no special permissions required)
- Ability to generate 10,000 addresses (trivial with sequential key generation)
- Minimal transaction fees

**Attack Complexity: LOW**
1. Generate 10,000 addresses
2. Call `CreateOrganization` with large `OrganizationMemberList` (passes validation)
3. Wait for legitimate proposal activity (2-3 votes)
4. All subsequent `GetProposal` and `Release` calls fail permanently

**Feasibility Factors:**
- Transaction size easily accommodates 10,000+ addresses
- No maximum member list validation
- Attack works with organization's own legitimate voting activity
- Hard to detect during creation
- No mitigation path once triggered

The vulnerability can occur maliciously (attacker creates trap organizations) or accidentally (legitimate organizations with large membership).

## Recommendation

**Immediate Fix:**

1. **Add Maximum Member List Size**: Enforce a reasonable upper bound (e.g., 100-500 members) in the `Validate` method:
   - Check `organization.OrganizationMemberList.Count()` against a constant in `AssociationConstants.cs`
   - Reject organizations exceeding the limit during creation

2. **Optimize Threshold Checking**: Replace nested iterations with efficient membership tracking:
   - Use a HashSet-based lookup instead of repeated `Contains()` calls
   - Pre-filter votes to include only valid organization members once
   - Count valid votes in a single pass

3. **Add Member List Cache**: Store organization members in a state structure optimized for membership lookups (e.g., mapping)

## Proof of Concept

```csharp
[Fact]
public async Task BranchCountDoS_LargeMemberList_ExceedsLimit()
{
    // Setup: Create organization with 10,000 members
    var memberList = new OrganizationMemberList();
    for (int i = 0; i < 10000; i++)
    {
        memberList.OrganizationMembers.Add(Address.FromPublicKey(GenerateKeyPair(i).PublicKey));
    }
    
    var createInput = new CreateOrganizationInput
    {
        OrganizationMemberList = memberList,
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 2,
            MinimalVoteThreshold = 2,
            MaximalAbstentionThreshold = 9998,
            MaximalRejectionThreshold = 9998
        },
        ProposerWhiteList = new ProposerWhiteList 
        { 
            Proposers = { DefaultSender } 
        }
    };
    
    // Organization creation succeeds (uses ~10k branch counts)
    var orgAddress = await AssociationContractStub.CreateOrganization.SendAsync(createInput);
    
    // Create proposal
    var proposalInput = new CreateProposalInput
    {
        OrganizationAddress = orgAddress.Output,
        ContractMethodName = "TestMethod",
        ToAddress = DefaultAddress,
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
    };
    var proposalId = await AssociationContractStub.CreateProposal.SendAsync(proposalInput);
    
    // Two members approve
    await AssociationContractStub.Approve.SendAsync(proposalId.Output);
    var member2Stub = GetAssociationContractStub(GenerateKeyPair(1));
    await member2Stub.Approve.SendAsync(proposalId.Output);
    
    // GetProposal fails with RuntimeBranchThresholdExceededException
    // 2 votes × 10,000 members = 20,000 branch counts > 15,000 limit
    var exception = await Assert.ThrowsAsync<RuntimeBranchThresholdExceededException>(
        async () => await AssociationContractStub.GetProposal.CallAsync(proposalId.Output)
    );
    
    Assert.Contains("Branch count exceeded", exception.Message);
    
    // Release also fails
    var releaseException = await Assert.ThrowsAsync<RuntimeBranchThresholdExceededException>(
        async () => await AssociationContractStub.Release.SendAsync(proposalId.Output)
    );
    
    Assert.Contains("Branch count exceeded", releaseException.Message);
}
```

## Notes

This vulnerability affects the core governance functionality of the Association contract. The nested iteration pattern creates quadratic complexity that becomes fatal when combined with AElf's branch count limits. The issue is particularly severe because:

1. It passes all existing validations during organization creation
2. The DoS is triggered by normal voting activity, not malicious actions
3. Recovery is impossible without contract upgrade
4. It can affect multiple critical governance organizations simultaneously

The fix requires both input validation (maximum member list size) and algorithmic optimization (efficient membership checking) to ensure long-term security and scalability of Association-based governance.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-67)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```

**File:** protobuf/association_contract.proto (L105-108)
```text
message OrganizationMemberList {
    // The address of organization members.
    repeated aelf.Address organization_members = 1;
}
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-7)
```csharp
    public const int ExecutionCallThreshold = 15000;

    public const int ExecutionBranchThreshold = 15000;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L18-25)
```csharp
    public override ProposalOutput GetProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        if (proposal == null) return new ProposalOutput();

        var organization = State.Organizations[proposal.OrganizationAddress];
        var readyToRelease = IsReleaseThresholdReached(proposal, organization);

```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-189)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
```

**File:** contract/AElf.Contracts.Association/Association_Extensions.cs (L24-27)
```csharp
    public static bool AnyDuplicate(this OrganizationMemberList organizationMemberList)
    {
        return organizationMemberList.OrganizationMembers.GroupBy(m => m).Any(g => g.Count() > 1);
    }
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L5-5)
```csharp
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
```
