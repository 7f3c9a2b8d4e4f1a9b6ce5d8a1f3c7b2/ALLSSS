### Title
Missing Input Validation in AssertIsAuthorizedProposer Allows Authorization Bypass with Null/Empty Proposer Address

### Summary
The `AssertIsAuthorizedProposer()` function in Association_Helper.cs does not validate that the proposer address is non-null and non-empty before performing the `Contains()` check against the organization's ProposerWhiteList. This allows unauthorized proposal creation if an organization is created with an empty address in its whitelist and a system contract calls `CreateProposalBySystemContract` with an empty `OriginProposer`.

### Finding Description
The vulnerability exists in the `AssertIsAuthorizedProposer()` function [1](#0-0)  which directly calls `Contains()` on the ProposerWhiteList without first validating that the `proposer` parameter has a non-null, non-empty value.

This function is invoked from two locations in the Association contract:
1. `CreateProposal` uses `Context.Sender` as the proposer (always valid) [2](#0-1) 
2. `CreateProposalBySystemContract` uses `input.OriginProposer` (user-controlled input) [3](#0-2) 

The root cause is compounded by insufficient validation during organization creation. The `Validate(Organization)` method [4](#0-3)  checks that the ProposerWhiteList is not empty and has no duplicates, but does NOT validate that individual addresses within the list have non-empty values. This contrasts with the pattern established elsewhere in the codebase where addresses are validated using `!address.Value.IsNullOrEmpty()` [5](#0-4) .

When `CreateProposalBySystemContract` is called [6](#0-5) , it only verifies that the caller is a system contract, but does not validate the `OriginProposer` address before passing it to `AssertIsAuthorizedProposer`.

### Impact Explanation
If successfully exploited, this vulnerability allows unauthorized proposal creation, bypassing the organization's proposer whitelist authorization mechanism. An attacker could:

1. Create an organization with an empty/default Address in the ProposerWhiteList (not prevented by current validation)
2. Leverage a system contract (either through a bug in that contract or by exploiting a vulnerability there) to call `CreateProposalBySystemContract` with an empty `OriginProposer`
3. The authorization check would pass because `Contains()` would match the empty addresses, returning true
4. Unauthorized proposals could then be created, voted on, and potentially executed

This impacts the integrity of the governance system by allowing circumvention of the proposer whitelist control. While not resulting in direct fund theft, it undermines the fundamental authorization model of the Association governance contract. The severity is **Medium** because it requires specific preconditions (empty address in whitelist and system contract involvement) but has significant governance impact.

### Likelihood Explanation
The attack requires two preconditions:

**Precondition 1 - Feasible:** Creating an organization with an empty address in ProposerWhiteList is possible because the validation logic does not prevent it. The `Validate()` method only checks the list is non-empty and has no duplicates, not that individual addresses are valid.

**Precondition 2 - Conditional:** A system contract must call `CreateProposalBySystemContract` with an empty `OriginProposer`. While system contracts are trusted components, this represents a defense-in-depth failure. If any system contract has a bug where it doesn't properly validate the `OriginProposer` parameter before forwarding it, or if the field is unintentionally left with its default value in the protobuf message, this vulnerability becomes exploitable.

The attack complexity is moderate. An attacker would need to:
1. Identify or create an organization with the flawed whitelist configuration
2. Find a way to trigger a system contract to call the function with empty `OriginProposer`

The likelihood is reduced by the system contract requirement, but the vulnerability violates defense-in-depth principles. Input validation should occur at each boundary, not rely solely on upstream validation. This is especially critical for governance functions where authorization controls are paramount.

### Recommendation
Add explicit validation in `AssertIsAuthorizedProposer()` to check that the proposer address is not null and has a non-empty value before performing the Contains() check:

```csharp
private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
{
    Assert(proposer != null && !proposer.Value.IsNullOrEmpty(), "Invalid proposer address.");
    var organization = State.Organizations[organizationAddress];
    Assert(organization != null, "No registered organization.");
    Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
}
```

Additionally, enhance the `Validate(Organization)` method to check that all addresses in the ProposerWhiteList and OrganizationMemberList have non-empty values:

```csharp
private bool Validate(Organization organization)
{
    if (organization.ProposerWhiteList.Empty() ||
        organization.ProposerWhiteList.AnyDuplicate() ||
        organization.OrganizationMemberList.Empty() ||
        organization.OrganizationMemberList.AnyDuplicate())
        return false;
    
    // Add validation for individual addresses
    if (organization.ProposerWhiteList.Proposers.Any(p => p == null || p.Value.IsNullOrEmpty()))
        return false;
    if (organization.OrganizationMemberList.OrganizationMembers.Any(m => m == null || m.Value.IsNullOrEmpty()))
        return false;
        
    if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
        return false;
    // ... rest of validation
}
```

Add test cases to verify:
1. Creating an organization with empty addresses in ProposerWhiteList fails
2. Calling `CreateProposalBySystemContract` with empty `OriginProposer` fails
3. Calling `AssertIsAuthorizedProposer` with null/empty proposer fails

### Proof of Concept
**Initial State:**
1. Deploy Association contract
2. System contract is registered in the system

**Attack Steps:**
1. Create an organization with ProposerWhiteList containing `new Address() { Value = ByteString.Empty }`:
   - Call `CreateOrganization` with a CreateOrganizationInput where ProposerWhiteList.Proposers includes an empty Address
   - This passes validation because `Validate()` only checks the list is non-empty, not individual addresses

2. From a system contract, call `CreateProposalBySystemContract`:
   - Set `OriginProposer` to `new Address() { Value = ByteString.Empty }` (default/empty address)
   - Set `ProposalInput` with valid proposal parameters for the organization created in step 1

**Expected Result:**
Transaction should fail with "Invalid proposer address" error

**Actual Result:**
Transaction succeeds because `AssertIsAuthorizedProposer` calls `Contains()` which matches the empty address in the whitelist, bypassing authorization and allowing unauthorized proposal creation

**Success Condition:**
Proposal is created with ID returned, and `GetProposal` shows the proposal exists with the empty address as proposer, demonstrating successful authorization bypass

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L109-109)
```csharp
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L114-121)
```csharp
    public override Hash CreateProposalBySystemContract(CreateProposalBySystemContractInput input)
    {
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Not authorized to propose.");
        AssertIsAuthorizedProposer(input.ProposalInput.OrganizationAddress, input.OriginProposer);
        var proposalId = CreateNewProposal(input.ProposalInput);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```
