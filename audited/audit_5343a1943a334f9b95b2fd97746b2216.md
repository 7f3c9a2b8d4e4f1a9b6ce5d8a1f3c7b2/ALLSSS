# Audit Report

## Title
VoteId Collision Causing Permanent Token Lock Due to Insufficient Uniqueness in ID Generation

## Summary
The Vote contract generates VoteId using only the current voting result's VotesAmount, omitting the VotingItemId from the hash. When a contract calls Vote twice in one transaction on different voting items with identical VotesAmount values (commonly 0 for newly created items), the collision causes the second VotingRecord to overwrite the first while both Lock operations succeed and accumulate tokens at the same virtual address. This results in permanent loss of the overwritten vote's locked tokens.

## Finding Description

**Root Cause - Insufficient VoteId Uniqueness:**

The Vote contract generates VoteId using an incomplete formula that excludes the VotingItemId: [1](#0-0) 

The underlying `GenerateId` implementation uses OriginTransactionId, which remains constant across inline calls: [2](#0-1) 

This generates: `Hash(OriginTransactionId + VoteContractAddress + VotesAmount)`. Since VotesAmount is independent per voting item, two different voting items can have identical VotesAmount values (commonly 0 for newly registered items), resulting in VoteId collision when voted within the same transaction.

**Missing Collision Protection:**

The Vote contract directly overwrites VotingRecords without checking for existing entries: [3](#0-2) 

In contrast, the Election contract implements explicit collision protection: [4](#0-3) 

**Token Lock Accumulation:**

When Lock is called multiple times with the same LockId, tokens accumulate at the same virtual address: [5](#0-4) 

The virtual address is deterministically computed from `Context.Sender + input.Address + input.LockId`. Identical LockIds (VoteIds) result in the same destination where tokens accumulate through successive transfers.

**Unlock Limited by Overwritten Record:**

During withdrawal, the Unlock operation retrieves the amount from the VotingRecord, which reflects only the last vote after overwrite: [6](#0-5) 

**Attack Execution Path:**

1. Attacker contract calls `VoteContract.Vote(votingItemId1, amount=100)` where votingResult1.VotesAmount=0
   - VoteId = Hash(OriginTxId + VoteContract + 0)
   - Lock transfers 100 tokens to virtualAddress = Hash(VoteContract + voter + VoteId)
   - VotingRecords[VoteId] = {amount: 100, itemId: item1}

2. Same contract calls `VoteContract.Vote(votingItemId2, amount=200)` where votingResult2.VotesAmount=0
   - VoteId = Hash(OriginTxId + VoteContract + 0) — **COLLISION**
   - Lock transfers 200 tokens to **same virtualAddress** (now holds 300 total)
   - VotingRecords[VoteId] = {amount: 200, itemId: item2} — **OVERWRITES**

3. Withdrawal attempt:
   - Withdraw(VoteId) retrieves overwritten record showing amount=200
   - Unlock returns only 200 tokens
   - **100 tokens remain permanently locked** in virtual address

## Impact Explanation

**Direct Fund Loss:**
- Permanent, irreversible token lock in virtual address with no recovery mechanism
- Example: Vote1 locks 100 tokens, Vote2 locks 200 tokens with colliding VoteId → Virtual address contains 300 tokens but only 200 withdrawable → 100 tokens permanently lost

**Affected Parties:**
- Batch voting contracts (governance automation, voting aggregators)
- Users depositing tokens into such contracts
- Protocol token supply integrity (accumulation of permanently locked tokens)

**Invariant Violation:**
- Breaks critical locking invariant: `sum(Lock amounts) == sum(Unlock amounts)`
- Violates assumption that every Lock has corresponding recoverable Unlock
- Corrupts VotingRecord integrity (one record representing multiple locks)

**Severity Justification:**
HIGH severity because:
1. Permanent, irreversible fund loss
2. No privileged role requirements
3. Violation of core token locking mechanism
4. Realistic attack vector affecting legitimate use cases

## Likelihood Explanation

**Attack Complexity: MEDIUM**

Prerequisites:
1. Deploy contract with inline call capability (standard AElf functionality)
2. Identify two voting items with matching VotesAmount (trivial: new items start at 0)
3. Execute both votes in single transaction

**Feasible Preconditions:**
- Vote contract is system contract (default configuration), enabling Lock whitelist bypass
- Voting items configured with `IsLockToken=true` (standard governance configuration)
- No special timing or race conditions required

**Execution Practicality:**
- Standard contract deployment and execution
- Newly registered voting items guarantee VotesAmount=0, ensuring collision
- Attack succeeds deterministically without external dependencies

**Real-World Scenarios:**
- Governance bots voting on multiple proposals simultaneously
- Voting aggregator services batching votes for efficiency
- Multi-signature contracts executing batch governance operations
- Any legitimate contract implementing parallel voting functionality

**Detection Difficulty:**
- Collision not visible in transaction logs (appears as normal voting)
- Discovered only during withdrawal attempts or forensic balance analysis
- No alerts or events indicate the state corruption

## Recommendation

**Solution 1: Include VotingItemId in VoteId Generation (Preferred)**

Modify the VoteId generation to include the VotingItemId:

```csharp
input.VoteId = Context.GenerateId(Context.Self, 
    HashHelper.ConcatAndCompute(
        votingItem.VotingItemId, 
        HashHelper.ComputeFrom(votingResult.VotesAmount)
    ).ToByteArray());
```

This ensures each voting item generates unique VoteIds regardless of VotesAmount values.

**Solution 2: Add Collision Check**

Add explicit collision protection similar to Election contract:

```csharp
Assert(State.VotingRecords[input.VoteId] == null, "Vote already exists.");
State.VotingRecords[input.VoteId] = votingRecord;
```

This prevents overwriting existing records, causing the transaction to revert on collision.

**Solution 3: Include Sender and Timestamp**

Enhance uniqueness by including voter address and timestamp:

```csharp
input.VoteId = Context.GenerateId(Context.Self,
    HashHelper.ConcatAndCompute(
        votingItem.VotingItemId,
        HashHelper.ComputeFrom(input.Voter),
        HashHelper.ComputeFrom(Context.CurrentBlockTime)
    ).ToByteArray());
```

**Recommended Approach:**
Implement Solution 1 (include VotingItemId) as it directly addresses the root cause while maintaining backward compatibility for single votes per transaction. Additionally, implement Solution 2 (collision check) as defense-in-depth.

## Proof of Concept

```csharp
// Test demonstrating VoteId collision and permanent token lock
public async Task VoteId_Collision_Causes_Permanent_Token_Lock()
{
    // Setup: Create two voting items with same VotesAmount (0)
    var votingItem1 = await CreateVotingItem("Item1", acceptedCurrency: "ELF", isLockToken: true);
    var votingItem2 = await CreateVotingItem("Item2", acceptedCurrency: "ELF", isLockToken: true);
    
    // Deploy attacker contract that votes twice in same transaction
    var attackerContract = await DeployBatchVotingContract();
    
    // Fund attacker contract with 300 tokens
    await TransferToContract(attackerContract, "ELF", 300);
    await ApproveToVoteContract(attackerContract, "ELF", 300);
    
    // Execute attack: batch vote on both items
    await attackerContract.BatchVote(new[] {
        new VoteInput { VotingItemId = votingItem1, Amount = 100, Option = "Yes" },
        new VoteInput { VotingItemId = votingItem2, Amount = 200, Option = "Yes" }
    });
    
    // Verify collision: both votes generated same VoteId
    var voteId = GenerateExpectedVoteId(votingAmount: 0);
    var record = await VoteContractStub.GetVotingRecord.CallAsync(voteId);
    record.Amount.ShouldBe(200); // Overwritten with second vote
    record.VotingItemId.ShouldBe(votingItem2); // Only second item recorded
    
    // Verify virtual address holds accumulated tokens
    var virtualAddress = ComputeVirtualAddress(VoteContract, attackerContract, voteId);
    var lockedBalance = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = virtualAddress, Symbol = "ELF" });
    lockedBalance.Balance.ShouldBe(300); // 100 + 200 accumulated
    
    // Attempt withdrawal
    await VoteContractStub.Withdraw.SendAsync(new WithdrawInput { VoteId = voteId });
    
    // Verify permanent loss
    var remainingLocked = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = virtualAddress, Symbol = "ELF" });
    remainingLocked.Balance.ShouldBe(100); // 100 tokens permanently locked
    
    // Assert: locked_amount != withdrawable_amount (invariant violated)
    var totalLocked = 300;
    var totalWithdrawable = 200;
    (totalLocked == totalWithdrawable).ShouldBeFalse(); // Invariant broken
}
```

## Notes

This vulnerability represents a critical flaw in the Vote contract's ID generation mechanism. The omission of VotingItemId from the hash formula, combined with the lack of collision protection, creates a deterministic path to permanent fund loss. While the attack requires a malicious contract, the same vulnerability affects legitimate batch voting implementations, making this a systemic risk to any protocol integrating with the Vote contract for governance operations.

The Election contract's explicit collision check demonstrates that the AElf team recognized this risk in other contexts but did not apply the same protection to the Vote contract, suggesting an oversight rather than a design decision.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L225-231)
```csharp
            State.TokenContract.Unlock.Send(new UnlockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                Amount = votingRecord.Amount,
                LockId = input.VoteId
            });
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L397-397)
```csharp
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L139-145)
```csharp
    public Hash GenerateId(Address contractAddress, IEnumerable<byte> bytes)
    {
        var contactedBytes = OriginTransactionId.Value.Concat(contractAddress.Value);
        var enumerable = bytes as byte[] ?? bytes?.ToArray();
        if (enumerable != null)
            contactedBytes = contactedBytes.Concat(enumerable);
        return HashHelper.ComputeFrom(contactedBytes.ToArray());
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L433-433)
```csharp
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-212)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
```
