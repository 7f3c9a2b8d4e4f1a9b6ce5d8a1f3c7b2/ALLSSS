# Audit Report

## Title
Unvalidated TuneOrderInformation Allows Injection of Negative Order Values Leading to Consensus Disruption

## Summary
A malicious miner can inject negative `FinalOrderOfNextRound` values through the unvalidated `TuneOrderInformation` field in `UpdateValueInput`, causing miners to be assigned negative `Order` values and past `ExpectedMiningTime` timestamps in the next round, breaking critical consensus invariants.

## Finding Description

The AEDPoS consensus mechanism allows miners to propose order adjustments for the next round through the `TuneOrderInformation` field when calling `UpdateValue`. However, this field lacks any validation, allowing negative values to be injected.

**Attack Flow:**

1. A malicious miner crafts an `UpdateValueInput` with `TuneOrderInformation` containing negative values (e.g., `{targetMinerPubkey: -100}`) [1](#0-0) 

2. The miner calls the public `UpdateValue` method [2](#0-1) 

3. The `UpdateValueValidationProvider` validates only `OutValue`, `Signature`, and `PreviousInValue`, completely ignoring `TuneOrderInformation` [3](#0-2) 

4. `ProcessUpdateValue` directly applies the malicious values without bounds checking [4](#0-3) 

5. When generating the next round, miners are ordered by their `FinalOrderOfNextRound` values, with negative values sorting first [5](#0-4) 

6. The negative order is directly assigned as the miner's `Order`, and `ExpectedMiningTime` is calculated as `currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order))`, creating a timestamp in the past [6](#0-5) 

7. The `NextRoundMiningOrderValidationProvider` fails to catch this because it validates the newly generated round where all `FinalOrderOfNextRound` values default to 0, making both counts equal to 0 and passing validation [7](#0-6) 

## Impact Explanation

**Consensus Invariant Violations:**
- Breaks the invariant that miner `Order` values must be in range [1, minersCount]
- Creates miners with past `ExpectedMiningTime` timestamps, corrupting the deterministic mining schedule
- Disrupts the time slot allocation mechanism that consensus relies upon

**Operational Impact:**
- Miners with negative orders and past time slots cause timing conflicts
- Time slot validation logic may behave unpredictably with historical timestamps
- Block production schedule becomes non-deterministic
- The corrupted round state persists and affects subsequent round transitions

This is a Medium severity issue because while it doesn't enable direct fund theft, it breaks critical consensus protocol invariants and can cause operational disruption to the blockchain's block production mechanism.

## Likelihood Explanation

**Attack Feasibility:**
The attack is highly feasible with low complexity:
- Requires only being an active miner in the current round (achievable through normal election)
- The `UpdateValue` method is publicly accessible to all miners [2](#0-1) 
- No cryptographic sophistication needed - just construct malicious input data
- Can be executed in a single block during the attacker's time slot

**Economic Considerations:**
While a miner attacking their own network seems irrational, scenarios include:
- Strategic disruption during contentious governance decisions
- Competitive advantage by disrupting rival miners' time slots
- External incentives to harm the network (e.g., shorting positions)

## Recommendation

Add validation in `ProcessUpdateValue` to ensure all `TuneOrderInformation` values are within valid bounds:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    
    // ... existing code ...
    
    // Validate TuneOrderInformation before applying
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        Assert(tuneOrder.Value > 0 && tuneOrder.Value <= minersCount, 
            $"Invalid order value: {tuneOrder.Value}. Must be in range [1, {minersCount}]");
        Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key),
            $"Unknown miner pubkey: {tuneOrder.Key}");
        currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
    }
    
    // ... rest of the method ...
}
```

Additionally, strengthen `NextRoundMiningOrderValidationProvider` to validate the CURRENT round's `FinalOrderOfNextRound` values before next round generation, not the newly generated round's values.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_InjectsNegativeOrder_CorruptsNextRound()
{
    // Setup: Initialize consensus with multiple miners
    var miners = await InitializeConsensusWithMiners(5);
    var maliciousMiner = miners[0];
    
    // Malicious miner crafts UpdateValueInput with negative order for another miner
    var updateValueInput = new UpdateValueInput
    {
        OutValue = GenerateOutValue(),
        Signature = GenerateSignature(),
        SupposedOrderOfNextRound = 1,
        TuneOrderInformation = 
        {
            { miners[1].PublicKey.ToHex(), -100 } // Inject negative order
        }
    };
    
    // Execute malicious UpdateValue
    await maliciousMiner.UpdateValue(updateValueInput);
    
    // Verify: Next round generation uses corrupted order
    var currentRound = await GetCurrentRoundInformation();
    var victimMiner = currentRound.RealTimeMinersInformation[miners[1].PublicKey.ToHex()];
    
    // Assert negative FinalOrderOfNextRound was applied
    Assert.Equal(-100, victimMiner.FinalOrderOfNextRound);
    
    // Generate next round
    var nextRound = currentRound.GenerateNextRoundInformation(
        Context.CurrentBlockTime, 
        BlockchainStartTimestamp);
    
    // Verify: Victim miner has negative Order and past ExpectedMiningTime
    var victimInNextRound = nextRound.RealTimeMinersInformation[miners[1].PublicKey.ToHex()];
    Assert.Equal(-100, victimInNextRound.Order);
    Assert.True(victimInNextRound.ExpectedMiningTime < Context.CurrentBlockTime);
    
    // Consensus invariant broken: Order should be in [1, minersCount]
}
```

### Citations

**File:** protobuf/aedpos_contract.proto (L208-208)
```text
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-26)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L28-36)
```csharp
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```
