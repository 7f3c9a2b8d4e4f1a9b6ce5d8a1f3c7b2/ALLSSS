# Audit Report

## Title
Bidirectional RelatedSymbol Invariant Violation in TokenConverter Causes Inconsistent View Function Results

## Summary
The `MigrateConnectorTokens` function lacks access control and fails to maintain the bidirectional `RelatedSymbol` invariant by leaving orphaned old deposit connectors in state after migration. This causes `GetPairConnector` to return inconsistent connector pairs and allows any user to trigger unauthorized state changes.

## Finding Description

The `MigrateConnectorTokens` function violates critical security guarantees by breaking the bidirectional connector relationship invariant without proper authorization controls. [1](#0-0) 

**Root Cause Analysis:**

The function updates resource connectors to point to new deposit connector symbols (line 329) and copies old deposit connectors to new locations (lines 333-335), but critically fails to:
1. Remove or disable the old connector from `State.Connectors[oldConnectorTokenSymbol]`
2. Validate bidirectional relationship integrity after migration
3. Implement any access control checks

After migration, three connectors exist with broken relationships:
- Resource connector (CPU) → New deposit connector ((NT)CPU) ✓
- New deposit connector ((NT)CPU) → Resource connector (CPU) ✓
- **Orphaned old deposit connector (ntCPU) → Resource connector (CPU)** ✗ (CPU no longer points back)

**Missing Access Control:**

Unlike all other state-modifying connector methods, `MigrateConnectorTokens` has NO authorization check: [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

All these methods call `AssertPerformedByConnectorController()` to enforce governance, but `MigrateConnectorTokens` does not.

**Impact on View Functions:** [6](#0-5) 

The `GetPairConnector` function assumes bidirectional relationships when retrieving related connectors (line 42). With orphaned connectors, querying different symbols returns inconsistent pairs:
- Query "CPU" or "(NT)CPU" → Returns correct pair {CPU, (NT)CPU}
- Query "ntCPU" → Returns orphaned pair {CPU, ntCPU} where CPU doesn't recognize ntCPU [7](#0-6) 

The `IsSymbolAbleToSell` function returns misleading results for orphaned connectors, indicating they are tradeable when they should be deprecated.

## Impact Explanation

**Severity: Medium**

This vulnerability has multiple impact dimensions:

1. **State Integrity Violation**: The core bidirectional invariant that `Connector[A].RelatedSymbol = B ⟺ Connector[B].RelatedSymbol = A` is permanently broken after migration, corrupting contract state.

2. **Authorization Bypass**: Any user can trigger system-level migration operations that should require governance approval, as evidenced by all other connector management functions requiring `AssertPerformedByConnectorController()`.

3. **Ecosystem Integration Impact**: Off-chain systems (price oracles, DEX aggregators, blockchain indexers) querying `GetPairConnector` receive different connector pair information depending on which symbol they query, leading to:
   - Incorrect pricing data propagation
   - Failed trade routing
   - Inconsistent market data feeds

4. **User Experience Degradation**: `IsSymbolAbleToSell` returns true for deprecated orphaned connectors, misleading users about tradeable symbols.

While this does not enable direct fund theft (transactions with orphaned symbols would fail at token transfer validation), the permanent state corruption and missing access control represent a significant protocol integrity issue.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly likely to be triggered due to:

1. **No Access Control**: The function is publicly callable with no authorization requirements, unlike all other connector management functions. [8](#0-7) 

2. **Trivial Exploitation**: Requires only a single function call with empty input - no complex setup or preconditions beyond normal system state.

3. **Realistic Preconditions**: 
   - Connectors must exist (normal operational state)
   - Connectors not previously migrated (one-time operation per connector)
   - No special privileges required

4. **Permanent Effect**: The migration is a one-time operation that permanently breaks the invariant with no recovery mechanism, as confirmed by existing tests. [9](#0-8) 

The test verifies migration cannot be repeated but does not validate orphaned connector cleanup or bidirectionality maintenance.

## Recommendation

Implement three critical fixes:

1. **Add Access Control**: Protect the migration function with governance authorization:
```csharp
public override Empty MigrateConnectorTokens(Empty input)
{
    AssertPerformedByConnectorController(); // Add this line
    // ... rest of implementation
}
```

2. **Remove Orphaned Connectors**: After copying to new location, remove the old connector:
```csharp
State.Connectors[newConnectorTokenSymbol] = connector;
State.Connectors.Remove(oldConnectorTokenSymbol); // Add this line
```

3. **Migrate Deposit Balance Reference**: Update the balance mapping to remove old references:
```csharp
State.DepositBalance[newConnectorTokenSymbol] = State.DepositBalance[oldConnectorTokenSymbol];
State.DepositBalance.Remove(oldConnectorTokenSymbol); // Add this line
```

4. **Add Validation**: Include post-migration validation to ensure bidirectionality:
```csharp
// After migration, verify invariant
Assert(
    State.Connectors[newConnectorTokenSymbol].RelatedSymbol == resourceTokenSymbol &&
    State.Connectors[resourceTokenSymbol].RelatedSymbol == newConnectorTokenSymbol,
    "Bidirectional invariant violated"
);
```

## Proof of Concept

```csharp
[Fact]
public async Task OrphanedConnectorBreaksBidirectionalInvariant()
{
    // Setup: Create and enable a connector pair
    await CreateWriteToken();
    await InitializeTreasuryContractAsync();
    await InitializeTokenConverterContract();
    await PrepareToBuyAndSell();
    
    // Get connector pair before migration
    var beforeMigration = await DefaultStub.GetPairConnector.CallAsync(new TokenSymbol 
    { 
        Symbol = WriteConnector.Symbol 
    });
    var oldDepositSymbol = beforeMigration.DepositConnector.Symbol; // "ntWRITE"
    
    // Execute migration (any user can call - no access control)
    await DefaultStub.MigrateConnectorTokens.SendAsync(new Empty());
    
    // Query with resource token symbol - returns new pair
    var resourceQuery = await DefaultStub.GetPairConnector.CallAsync(new TokenSymbol 
    { 
        Symbol = WriteConnector.Symbol 
    });
    var newDepositSymbol = resourceQuery.DepositConnector.Symbol; // "(NT)WRITE"
    
    // Query with NEW deposit symbol - returns correct pair
    var newDepositQuery = await DefaultStub.GetPairConnector.CallAsync(new TokenSymbol 
    { 
        Symbol = newDepositSymbol 
    });
    
    // Query with OLD deposit symbol - returns INCONSISTENT pair (orphaned)
    var oldDepositQuery = await DefaultStub.GetPairConnector.CallAsync(new TokenSymbol 
    { 
        Symbol = oldDepositSymbol 
    });
    
    // VULNERABILITY DEMONSTRATED:
    // 1. Old connector still exists in state
    oldDepositQuery.DepositConnector.ShouldNotBeNull();
    
    // 2. Old connector still points to resource token
    oldDepositQuery.ResourceConnector.Symbol.ShouldBe(WriteConnector.Symbol);
    
    // 3. But resource token no longer points back to old connector
    resourceQuery.DepositConnector.Symbol.ShouldNotBe(oldDepositSymbol);
    
    // 4. Bidirectional invariant is BROKEN:
    //    oldDepositConnector.RelatedSymbol = "WRITE"
    //    BUT "WRITE".RelatedSymbol = "(NT)WRITE" (not "ntWRITE")
    
    // 5. IsSymbolAbleToSell returns true for orphaned connector if it was enabled
    var canSellOrphaned = await DefaultStub.IsSymbolAbleToSell.CallAsync(new StringValue 
    { 
        Value = oldDepositSymbol 
    });
    // This misleadingly returns true for a deprecated connector
    
    // 6. Different queries return different connector pairs - INCONSISTENT STATE
    (resourceQuery.DepositConnector.Symbol != oldDepositQuery.DepositConnector.Symbol)
        .ShouldBeTrue(); // Proves inconsistency
}
```

This test demonstrates the bidirectional invariant violation by showing that querying different symbols after migration returns inconsistent connector pairs, proving the orphaned connector problem and lack of access control.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-110)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L260-267)
```csharp
    public override Empty SetFeeRate(StringValue input)
    {
        AssertPerformedByConnectorController();
        var feeRate = AssertedDecimal(input.Value);
        Assert(IsBetweenZeroAndOne(feeRate), "Fee rate has to be a decimal between 0 and 1.");
        State.FeeRate.Value = feeRate.ToString(CultureInfo.InvariantCulture);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L303-309)
```csharp
    public override Empty ChangeConnectorController(AuthorityInfo input)
    {
        AssertPerformedByConnectorController();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.ConnectorController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L311-342)
```csharp
    public override Empty MigrateConnectorTokens(Empty input)
    {
        foreach (var resourceTokenSymbol in Context.Variables.GetStringArray(PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(PayRentalSymbolListName)))
        {
            var newConnectorTokenSymbol = NewNtTokenPrefix.Append(resourceTokenSymbol);

            if (State.Connectors[resourceTokenSymbol] == null)
            {
                continue;
            }

            var oldConnectorTokenSymbol = State.Connectors[resourceTokenSymbol].RelatedSymbol;

            Assert(!oldConnectorTokenSymbol.StartsWith(NewNtTokenPrefix), "Already migrated.");

            // Migrate

            State.Connectors[resourceTokenSymbol].RelatedSymbol = newConnectorTokenSymbol;

            if (State.Connectors[oldConnectorTokenSymbol] != null)
            {
                var connector = State.Connectors[oldConnectorTokenSymbol];
                connector.Symbol = newConnectorTokenSymbol;
                State.Connectors[newConnectorTokenSymbol] = connector;
            }

            State.DepositBalance[newConnectorTokenSymbol] = State.DepositBalance[oldConnectorTokenSymbol];
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L37-54)
```csharp
    public override PairConnector GetPairConnector(TokenSymbol input)
    {
        var targetConnector = State.Connectors[input.Symbol];
        Connector relatedConnector = null;
        if (targetConnector != null)
            relatedConnector = State.Connectors[targetConnector.RelatedSymbol];
        if (targetConnector != null && targetConnector.IsDepositAccount)
            return new PairConnector
            {
                ResourceConnector = relatedConnector,
                DepositConnector = targetConnector
            };
        return new PairConnector
        {
            ResourceConnector = targetConnector,
            DepositConnector = relatedConnector
        };
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L104-108)
```csharp
    public override BoolValue IsSymbolAbleToSell(StringValue input)
    {
        var depositConnector = GetPairConnector(new TokenSymbol { Symbol = input.Value }).DepositConnector;
        return new BoolValue { Value = depositConnector != null && depositConnector.IsPurchaseEnabled };
    }
```

**File:** protobuf/token_converter_contract.proto (L55-56)
```text
    rpc MigrateConnectorTokens (google.protobuf.Empty) returns (google.protobuf.Empty) {
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/ConnectorTokenMigrateTest.cs (L143-153)
```csharp
    public async Task MigrateTwiceTest()
    {
        await CreateWriteToken();
        await InitializeTreasuryContractAsync();
        await InitializeTokenConverterContract();
        await PrepareToBuyAndSell();

        await DefaultStub.MigrateConnectorTokens.SendAsync(new Empty());
        var result = await DefaultStub.MigrateConnectorTokens.SendWithExceptionAsync(new Empty());
        result.TransactionResult.Error.ShouldContain("Already migrated.");
    }
```
