# Audit Report

## Title
NFT Type Namespace Collision Allows Conflicting Bidirectional Mappings

## Summary
The `AddNFTType()` function contains incomplete validation logic that fails to prevent namespace collisions between short names and full names in the NFT type system. This allows a single string to exist simultaneously as both a short name (mapping to one full name) and as a full name (mapped from a different short name), corrupting the bidirectional mapping invariant and causing incorrect symbol generation and type categorization.

## Finding Description

The NFT contract maintains two bidirectional state mappings to link 2-character short names with their full names: [1](#0-0) 

These mappings are initialized with default types like "AR" ↔ "Art", "MU" ↔ "Music", etc.: [2](#0-1) 

The vulnerability exists in the `AddNFTType()` validation logic: [3](#0-2) 

**Root Cause:**

Line 137 validates that `input.ShortName` doesn't already exist as a key in `NFTTypeFullNameMap` (i.e., isn't already used as a short name).

Line 138 validates that `input.FullName` doesn't already exist as a key in `NFTTypeShortNameMap` (i.e., isn't already used as a full name).

**The Missing Check:** The code never validates whether `input.FullName` already exists as a **key** in `NFTTypeFullNameMap` (i.e., is already used as a short name in the opposite direction).

**Exploit Scenario:**

Given initial state after `InitialNFTTypeNameMap()`:
- `NFTTypeFullNameMap["AR"] = "Art"`
- `NFTTypeShortNameMap["Art"] = "AR"`

Parliament approves: `AddNFTType(shortName="MX", fullName="AR")`

The validation checks pass because:
- Line 137: `NFTTypeFullNameMap["MX"]` is null ✓
- Line 138: `NFTTypeShortNameMap["AR"]` is null ✓ (since "AR" is a key in the OTHER map, not this one)

Result after execution:
- `NFTTypeFullNameMap["AR"] = "Art"` (old - unchanged)
- `NFTTypeFullNameMap["MX"] = "AR"` (new)
- `NFTTypeShortNameMap["Art"] = "AR"` (old - unchanged)  
- `NFTTypeShortNameMap["AR"] = "MX"` (new)

Now "AR" serves dual roles: as a short name (for "Art") AND as a full name (for "MX").

## Impact Explanation

**Severity: Medium** - The vulnerability corrupts a critical system invariant without causing direct fund loss.

**Concrete Operational Impacts:**

1. **Incorrect Symbol Generation:** When creating an NFT protocol with `nftType="AR"`, the `GetSymbol()` function performs: [4](#0-3) 

This looks up `NFTTypeShortNameMap["AR"]` and returns "MX", generating symbols like "MX123456" instead of the expected "AR123456" prefix. The stored `NFTProtocolInfo.NftType` will be "AR" but the symbol prefix will be "MX", breaking the type-to-symbol correspondence.

2. **Cross-Chain Type Resolution Confusion:** When `CrossChainCreate()` processes symbols: [5](#0-4) 

For symbols starting with "MX", it retrieves `NFTTypeFullNameMap["MX"]` which returns "AR", treating "AR" as a full name when it was originally a short name.

3. **Type Categorization Inconsistency:** NFT protocols lose reliable type-based categorization, affecting marketplaces, explorers, and applications that filter or organize NFTs by type.

**Affected Parties:**
- NFT protocol creators expecting consistent type mappings
- Cross-chain operations relying on symbol-to-type resolution
- NFT applications and marketplaces using type-based filtering

## Likelihood Explanation

**Likelihood: Medium** - Realistic governance error scenario with no malicious intent required.

**Preconditions:**
- Requires Parliament default address authorization [6](#0-5) 

**Feasibility:**
- **Not a Trust Assumption Violation:** This is a validation gap, not a compromised key scenario
- **Accidental Misconfiguration:** Parliament members may approve `AddNFTType(shortName="MX", fullName="AR")` without realizing "AR" is already used as a short name in the existing mappings
- **False Security Confidence:** The existing line 138 check gives false confidence that all namespace collisions are prevented
- **No Attack Complexity:** Once Parliament approves the proposal, execution is straightforward with no additional manipulation needed

**Detection Difficulty:**
The contract provides no warnings or helper functions to detect existing short name usage when validating a proposed full name, making it easy for governance to miss this collision during proposal review.

## Recommendation

Add an additional validation check to ensure the proposed full name doesn't already exist as a short name:

```csharp
public override Empty AddNFTType(AddNFTTypeInput input)
{
    AssertSenderIsParliamentDefaultAddress();
    InitialNFTTypeNameMap();
    var fullName = input.FullName;
    Assert(input.ShortName.Length == 2, "Incorrect short name.");
    Assert(State.NFTTypeFullNameMap[input.ShortName] == null, $"Short name {input.ShortName} already exists.");
    Assert(State.NFTTypeShortNameMap[fullName] == null, $"Full name {fullName} already exists.");
    // ADD THIS CHECK:
    Assert(State.NFTTypeFullNameMap[fullName] == null, $"String {fullName} is already used as a short name.");
    
    State.NFTTypeFullNameMap[input.ShortName] = fullName;
    State.NFTTypeShortNameMap[fullName] = input.ShortName;
    // ... rest of function
}
```

This ensures that the full name and short name namespaces remain completely distinct, preserving the bidirectional mapping invariant.

## Proof of Concept

```csharp
[Fact]
public async Task AddNFTType_NamespaceCollision_Test()
{
    // Initialize default mappings (AR -> Art)
    var nftTypes = await NFTContractStub.GetNFTTypes.CallAsync(new Empty());
    nftTypes.Value.ShouldContainKey("AR"); // "AR" exists as short name
    
    // Create Parliament proposal to add new type with fullName="AR" (which is already a short name)
    var defaultParliament = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
    var proposalId = await CreateProposalAsync(
        NFTContractAddress,
        defaultParliament,
        nameof(NFTContractStub.AddNFTType),
        new AddNFTTypeInput
        {
            ShortName = "MX",
            FullName = "AR" // Collision: "AR" is already used as short name for "Art"
        }
    );
    
    await ApproveWithMinersAsync(proposalId);
    var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify namespace collision occurred
    var shortNameMap = await NFTContractStub.GetNFTTypes.CallAsync(new Empty());
    
    // "AR" now exists in BOTH directions:
    // 1. As short name mapping to "Art" (original)
    // 2. As full name mapping from "MX" (new)
    
    // Create protocol with nftType="AR" - will generate symbol with "MX" prefix instead of "AR"
    var createResult = await NFTContractStub.Create.SendAsync(new CreateInput
    {
        NftType = "AR", // Expecting "AR" prefix in symbol
        ProtocolName = "Test Protocol",
        TotalSupply = 1000,
        IsBurnable = true,
        IssueChainId = ChainHelper.ConvertBase58ToChainId("AELF")
    });
    
    var symbol = createResult.Output.Value;
    // BUG: Symbol starts with "MX" instead of "AR" because NFTTypeShortNameMap["AR"] returns "MX"
    symbol.Substring(0, 2).ShouldBe("MX"); // Should be "AR" but is "MX"
}
```

**Notes:**
This vulnerability demonstrates a validation gap that allows namespace pollution in the NFT type system. While it requires Parliament governance approval, it can realistically occur through accidental misconfiguration during proposal review, as the existing validation checks provide false confidence that all collisions are prevented. The impact corrupts the NFT type categorization system used throughout the protocol and by external applications.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L35-36)
```csharp
    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L44-60)
```csharp
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;

        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L89-93)
```csharp
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L131-150)
```csharp
    public override Empty AddNFTType(AddNFTTypeInput input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        var fullName = input.FullName;
        Assert(input.ShortName.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.ShortName] == null, $"Short name {input.ShortName} already exists.");
        Assert(State.NFTTypeShortNameMap[fullName] == null, $"Full name {fullName} already exists.");
        State.NFTTypeFullNameMap[input.ShortName] = fullName;
        State.NFTTypeShortNameMap[fullName] = input.ShortName;
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Add(input.ShortName, fullName);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeAdded
        {
            ShortName = input.ShortName,
            FullName = input.FullName
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L171-182)
```csharp
    private void AssertSenderIsParliamentDefaultAddress()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        if (State.ParliamentDefaultAddress.Value == null)
            State.ParliamentDefaultAddress.Value =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());

        Assert(Context.Sender == State.ParliamentDefaultAddress.Value, "No permission.");
    }
```
