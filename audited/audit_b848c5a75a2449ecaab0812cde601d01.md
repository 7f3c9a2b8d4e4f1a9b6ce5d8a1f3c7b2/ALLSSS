### Title
Missing Round ID Validation in UpdateValue Allows Consensus State Corruption via Stale Data Application

### Summary
The `UpdateValueInput.RoundId` field is never validated against the current round's ID, despite protobuf documentation stating it should "ensure the values to update will be apply to correct round by comparing round id." This allows a malicious miner to craft blocks with headers from the current round but transaction payloads from stale rounds, corrupting consensus state by mixing data across round boundaries.

### Finding Description

**Root Cause:**

The `ExtractInformationToUpdateConsensus` method sets `RoundId = RoundIdForValidation` at line 40 [1](#0-0) , but this field is **never validated** during transaction processing.

The protobuf specification explicitly documents this field's purpose: "To ensure the values to update will be apply to correct round by comparing round id" [2](#0-1) . However, grep searches confirm zero usages of `updateValueInput.RoundId` for validation in the entire codebase.

**Processing Without Validation:**

When `ProcessUpdateValue` executes, it directly applies `UpdateValueInput` fields to the current round without any round ID verification [3](#0-2) . The method retrieves the current round at line 240 and immediately applies updates from lines 242-264 without checking if `updateValueInput.RoundId` matches the current round's `RoundId`.

**Why Existing Validations Fail:**

1. **TimeSlotValidationProvider** only validates the `ProvidedRound` structure in the block header [4](#0-3) , not the `UpdateValueInput` in the transaction payload.

2. **UpdateValueValidationProvider** only checks that `OutValue` and `Signature` are filled [5](#0-4) , not their round origin.

3. **No validation links the transaction payload to the header content** - searches confirm no checks comparing `UpdateValueInput` fields to `ExtraData` fields.

**Attack Path:**

A malicious miner can craft a block with:
- **Header**: Contains `ProvidedRound` from current round N+1 (passes `TimeSlotValidationProvider`)
- **Transaction**: Contains `UpdateValueInput` from stale round N (with `RoundId` from round N)
- **Result**: `ProcessUpdateValue` applies round N's cryptographic values (`OutValue`, `Signature`, `PreviousInValue`) and ordering data (`SupposedOrderOfNextRound`, `TuneOrderInformation`) to round N+1's state.

### Impact Explanation

**Consensus State Corruption:**

When stale `UpdateValueInput` from round N is applied to round N+1, the following critical data becomes corrupted:

1. **Cryptographic Signature Chain**: Lines 244-245 set `Signature` and `OutValue` from the stale round [6](#0-5) , breaking the signature verification chain used for random number generation.

2. **Random Number Generation**: The random hash calculation at lines 76-81 relies on correct signatures [7](#0-6) . Corrupted signatures produce incorrect randomness affecting future block production order.

3. **Next Round Mining Order**: Lines 246-247 and 259-260 set `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` [8](#0-7) [9](#0-8)  based on stale data, causing incorrect miner scheduling in round N+2.

4. **LIB Calculation**: Line 268-279 calculate the last irreversible block height [10](#0-9)  using potentially corrupted `ImpliedIrreversibleBlockHeight` values.

**Severity: HIGH** - Affects fundamental consensus integrity including randomness, block scheduling, and finality guarantees. All validators and users are impacted by corrupted consensus state.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an active miner in both round N and round N+1 (verified by `PreCheck` at lines 316-331 [11](#0-10) )
- Must have ability to produce blocks and craft consensus transactions

**Attack Complexity:**
- **MODERATE**: Attacker must:
  1. Generate or save `UpdateValueInput` from round N during normal operation
  2. Wait for round transition to N+1
  3. Craft a block with header from N+1 but transaction payload from N
  4. The block header and transaction are separate structures, allowing this mismatch

**Feasibility Conditions:**
- Block header contains merkle root of transactions, but doesn't prevent crafting both header and body together with mismatched round data
- No cryptographic binding between `ProvidedRound` (header) and `UpdateValueInput.RoundId` (transaction)
- Normal block production flow generates both consistently [12](#0-11) , but malicious miners can deviate

**Detection Constraints:**
- Difficult to detect: corrupted data appears valid (proper signatures/values, just from wrong round)
- `ValidateConsensusAfterExecution` hash check occurs AFTER state corruption [13](#0-12) 
- The unused `RoundId` field indicates this validation was intended but never implemented

**Likelihood: MEDIUM** - Requires miner status and intentional malicious behavior, but technically feasible with moderate effort.

### Recommendation

**Immediate Fix:**

Add round ID validation in `ProcessUpdateValue` before applying any updates:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // ADD THIS CHECK:
    Assert(updateValueInput.RoundId == currentRound.RoundId, 
        $"Update value round ID mismatch. Expected: {currentRound.RoundId}, Got: {updateValueInput.RoundId}");
    
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    // ... rest of method
}
```

Location: After line 240 in `AEDPoSContract_ProcessConsensusInformation.cs` [14](#0-13) 

**Additional Validation:**

Similarly add validation for `TinyBlockInput.RoundId` in `ProcessTinyBlock` at line 299 [15](#0-14) , which has the same issue.

**Test Cases:**

Add regression tests that:
1. Attempt to submit `UpdateValue` with `RoundId` from previous round → should fail
2. Attempt to submit `UpdateValue` with fabricated future `RoundId` → should fail
3. Verify only current round's `RoundId` is accepted

### Proof of Concept

**Initial State:**
- Current round N with `RoundId = 12345` (sum of expected mining times)
- Miner A scheduled in round N
- Miners: A, B, C

**Attack Steps:**

1. **T1 - Generate stale UpdateValueInput:**
   - Miner A calls `GetConsensusCommand` during round N
   - Generates `UpdateValueInput` with:
     - `RoundId = 12345`
     - `OutValue`, `Signature`, `PreviousInValue` calculated for round N
     - `SupposedOrderOfNextRound` based on round N state
   - Save this `UpdateValueInput`

2. **T2 - Trigger round transition:**
   - Miner B produces extra block triggering `NextRound` [16](#0-15) 
   - State transitions from round N to round N+1
   - Round N+1 has `RoundId = 67890` (different sum)

3. **T3 - Craft malicious block:**
   - Miner A creates block with:
     - **Header**: Call `GetConsensusBlockExtraData` with current round N+1 [17](#0-16) 
     - **Transaction**: Use saved `UpdateValueInput` with `RoundId = 12345` from round N

4. **T4 - Block validation passes:**
   - `ValidateBeforeExecution`: `TimeSlotValidationProvider` checks header Round (from N+1) → PASS [18](#0-17) 
   - `UpdateValueValidationProvider`: Checks `OutValue` and `Signature` exist → PASS [19](#0-18) 
   - **No check of `updateValueInput.RoundId`** → Attack proceeds

5. **T5 - State corruption occurs:**
   - `ProcessUpdateValue` executes [3](#0-2) 
   - Gets current round N+1 from state
   - Applies round N's values to round N+1:
     - Wrong `OutValue`/`Signature` (from round N cryptographic chain)
     - Wrong `SupposedOrderOfNextRound` (based on round N miner list)
     - Wrong `TuneOrderInformation` (affecting all miners' order)

**Expected Result:**
Transaction rejected with "Round ID mismatch" error.

**Actual Result:**
Transaction succeeds, corrupting round N+1 state with round N consensus data. Subsequent random number generation and mining order calculations use incorrect values.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L40-40)
```csharp
            RoundId = RoundIdForValidation,
```

**File:** protobuf/aedpos_contract.proto (L199-200)
```text
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L76-81)
```csharp
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-127)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L144-146)
```csharp
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L13-53)
```csharp
    private BytesValue GetConsensusBlockExtraData(BytesValue input, bool isGeneratingTransactions = false)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);

        Assert(triggerInformation.Pubkey.Any(), "Invalid pubkey.");

        TryToGetCurrentRoundInformation(out var currentRound);

        var publicKeyBytes = triggerInformation.Pubkey;
        var pubkey = publicKeyBytes.ToHex();

        var information = new AElfConsensusHeaderInformation();
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
        }

        if (!isGeneratingTransactions) information.Round.DeleteSecretSharingInformation();

        return information.ToBytesValue();
    }
```
