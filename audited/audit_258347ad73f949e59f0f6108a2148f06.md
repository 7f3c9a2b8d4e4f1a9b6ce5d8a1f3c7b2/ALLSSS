# Audit Report

## Title
Voluntary Key Rotation Bypasses Performance Penalties in Miner Reward Distribution

## Summary
The `UpdateBasicMinerRewardWeights` function in the Treasury contract incorrectly gives miners with the `IsReplacedEvilMiner` flag their full `ProducedBlocks` count as reward shares, bypassing the quadratic performance penalty in `CalculateShares`. This flag is exclusively set during voluntary key rotations (via `ReplaceCandidatePubkey`), NOT for actual evil miner replacements. Underperforming miners can exploit this by rotating their key before term end to receive 100-150% more rewards than deserved.

## Finding Description

The Treasury contract implements a performance-based reward system where miners producing fewer blocks than average receive reduced shares through `CalculateShares`. [1](#0-0)  However, miners with the `IsReplacedEvilMiner` flag bypass this penalty entirely and receive their raw `ProducedBlocks` count as shares. [2](#0-1) 

Despite its misleading name, `IsReplacedEvilMiner` is ONLY set when `RecordMinerReplacement` is called, [3](#0-2)  which occurs exclusively during voluntary key rotations via `RecordCandidateReplacement` in the AEDPoS contract. [4](#0-3) 

When a candidate admin voluntarily rotates their key using `ReplaceCandidatePubkey`, [5](#0-4)  the AEDPoS contract transfers the ENTIRE `MinerInRound` object (including `ProducedBlocks`) to the new pubkey. [6](#0-5) 

In stark contrast, when evil miners are automatically replaced during round generation, the system creates a fresh `MinerInRound` object with default values (ProducedBlocks = 0) and NEVER calls `RecordMinerReplacement`. [7](#0-6)  Therefore, actual evil miner replacements do NOT receive the penalty bypass.

## Impact Explanation

This vulnerability directly violates the economic invariant that miners must maintain reliable block production to receive proportional rewards. The penalty calculation imposes quadratic penalties on miners producing 50-80% of average blocks. [8](#0-7) 

**Concrete Impact:**
- A miner producing 200 blocks (average 400) normally receives 100 shares via the penalty formula
- After key rotation, they receive 200 shares directly (100% excess reward)
- A miner producing 160 blocks (average 400) normally receives 64 shares
- After rotation, they receive 160 shares (150% excess reward)

This misallocates Treasury funds, dilutes rewards for honest miners, and undermines consensus incentives. Over multiple terms, underperforming miners can strategically rotate keys to maintain reward levels intended only for reliable block producers, causing cumulative fund loss to the protocol.

## Likelihood Explanation

**Attacker Profile:** Any candidate with admin access to their election account can execute this attack. The admin is set during candidate announcement and is typically an organization controlled by the candidate.

**Attack Prerequisites:**
1. Candidate is an active miner producing below-average blocks
2. Candidate admin has authority to call `ReplaceCandidatePubkey` [9](#0-8) 
3. No timing restrictions exist—rotation can occur at any point before term end

**Execution Complexity:** Single transaction with no special conditions. The `ReplaceCandidatePubkey` method only checks that the sender is the candidate admin—no performance thresholds, cooldown periods, or rate limits exist.

**Economic Incentive:** Zero cost beyond gas fees, with guaranteed profit equal to the bypassed penalty. For a miner at 50% performance, this doubles their reward with no risk. The key rotation appears legitimate (standard key management practice), making malicious intent indistinguishable from operational needs.

**Detection:** Blockchain observers cannot differentiate between security-motivated key rotations and exploit attempts without analyzing off-chain miner performance patterns.

## Recommendation

Fix the semantic mismatch between the flag name and its actual usage. Since `IsReplacedEvilMiner` is only set for voluntary replacements, the penalty bypass should be removed or the flag should be set correctly for actual evil miner replacements.

**Option 1 (Recommended):** Remove the penalty bypass for voluntary replacements, as they should not inherit performance metrics from the old key:

```csharp
// In UpdateBasicMinerRewardWeights
long shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
// Remove the IsReplacedEvilMiner check entirely
```

**Option 2:** If the penalty bypass is intentional for evil miner replacements, modify `GenerateNextRoundInformation` to call `RecordMinerReplacement` with `IsOldPubkeyEvil = true` when replacing detected evil miners, and ensure voluntary replacements do NOT set the flag.

**Option 3:** Prevent `ProducedBlocks` transfer during voluntary key rotations in `RecordCandidateReplacement` by resetting it to zero for the new pubkey.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task VoluntaryKeyRotation_BypassesPenalty_Test()
{
    // Setup: Miner produces 200 blocks when average is 400
    var oldPubkey = "old_miner_key";
    var newPubkey = "new_miner_key";
    
    // Simulate underperformance during term
    var currentRound = new Round();
    currentRound.RealTimeMinersInformation[oldPubkey] = new MinerInRound {
        Pubkey = oldPubkey,
        ProducedBlocks = 200 // Underperforming (50% of average)
    };
    
    // Execute voluntary key rotation
    await ElectionStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput {
        OldPubkey = oldPubkey,
        NewPubkey = newPubkey
    });
    
    // Verify ProducedBlocks transferred to new key
    var round = await AEDPoSStub.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.Equal(200, round.RealTimeMinersInformation[newPubkey].ProducedBlocks);
    
    // Trigger reward distribution at term end
    await TreasuryStub.UpdateBasicMinerRewardWeights.SendAsync(previousTermInformation);
    
    // Verify bypass: newPubkey gets 200 shares instead of penalized 100 shares
    var beneficiaries = await ProfitStub.GetBeneficiaries.CallAsync(new GetBeneficiariesInput {
        SchemeId = basicRewardHash
    });
    
    var newKeyShares = beneficiaries.Beneficiaries.First(b => b.Pubkey == newPubkey).Shares;
    Assert.Equal(200, newKeyShares); // Should be 100 with penalty, but bypass gives 200
}
```

## Notes

The flag name `IsReplacedEvilMiner` is semantically incorrect—it actually tracks voluntary replacements, not evil miner replacements. The comment on line 804 of TreasuryContract.cs states "The new miner may have more shares than his actually contributes, but it's ok" suggesting the bypass may have been intentional for a different use case, but this creates an exploitable inconsistency in the reward distribution logic.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L596-596)
```csharp
        State.IsReplacedEvilMiner[input.NewPubkey] = true;
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L802-808)
```csharp
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L140-143)
```csharp
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L149-154)
```csharp
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L328-338)
```csharp
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
```
