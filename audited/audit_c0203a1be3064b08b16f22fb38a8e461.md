### Title
Case-Sensitive Miner Pubkey Comparison Allows Valid Miners to Be Rejected After Replacement

### Summary
The `MiningPermissionValidationProvider` performs a case-sensitive string comparison between `SenderPubkey` (always lowercase from `ToHex()`) and keys in `RealTimeMinersInformation`. When a miner is replaced via `RecordCandidateReplacement`, if the admin provides a `NewPubkey` with uppercase hex characters, the miner will be unable to produce blocks because the lowercase `SenderPubkey` won't match the uppercase key in the dictionary, causing legitimate block production attempts to be rejected with "Sender is not a miner."

### Finding Description

The vulnerability exists in the interaction between three components:

1. **SenderPubkey Generation (Always Lowercase):** The `ConsensusValidationContext.SenderPubkey` property converts the block producer's public key to hex format using `ToHex()`, which always produces lowercase hex strings ('a'-'f', not 'A'-'F'). [1](#0-0) [2](#0-1) 

2. **Case-Sensitive Mining Permission Check:** The `MiningPermissionValidationProvider` validates that a block producer is authorized by checking if their `SenderPubkey` exists in `BaseRound.RealTimeMinersInformation.Keys` using a case-sensitive `Contains()` check. [3](#0-2) 

3. **No Case Normalization in Miner Replacement:** When a candidate's public key is replaced via the `RecordCandidateReplacement` method, the `NewPubkey` string is used directly without any case normalization. The string is passed from the Election contract and stored as-is in `RealTimeMinersInformation`. [4](#0-3) [5](#0-4) 

**Root Cause:** The `ReplaceCandidatePubkey` method accepts pubkey strings without normalizing their case, and these strings are propagated to `RealTimeMinersInformation` as dictionary keys. Since C# `Dictionary<string, T>` uses case-sensitive comparison by default, if an admin passes "04ABC..." while the actual bytes would convert to "04abc..." via `ToHex()`, the `Contains()` check will fail.

**Why Existing Protections Fail:** 
- Initial round generation uses `ToHex()` consistently, so all initial keys are lowercase. [6](#0-5) [7](#0-6) 

- Evil miner replacement also uses `ToHex()` for alternative candidates from election results and initial miners, maintaining lowercase consistency. [8](#0-7) [9](#0-8) 

- However, manual replacement via `RecordCandidateReplacement` bypasses this normalization, creating the inconsistency.

### Impact Explanation

**Harm:** A legitimately replaced miner becomes unable to produce blocks. When they attempt to produce a block with their new key, the validation check fails because:
- Their `SenderPubkey` is converted to lowercase: "04abc..."
- But `RealTimeMinersInformation` contains the key with uppercase: "04ABC..."
- The case-sensitive `Contains()` returns false
- Block production is rejected

**Protocol Damage:**
- The affected miner's time slot is missed, reducing block production efficiency
- If the miner is scheduled as the extra block producer, round transitions could be delayed
- Consensus liveness is degraded proportional to how many miners are affected
- The miner continues to be scheduled but cannot fulfill their duties

**Who Is Affected:**
- Miners whose public keys were replaced via `ReplaceCandidatePubkey` where the admin provided a `NewPubkey` string with uppercase hex characters
- The blockchain network suffers from reduced block production capacity
- Transaction finality is delayed

**Severity Justification (Low):**
While the impact on consensus is significant when triggered, the likelihood is limited because:
- Most cryptographic libraries output lowercase hex by default
- The test suite uses `.ToHex()` which produces lowercase, so this wouldn't be caught
- Requires specific admin action (passing uppercase hex string)
- Can be remediated by replacing again with correct casing

### Likelihood Explanation

**Attacker Capabilities Required:** 
This is not a malicious attack but rather an operational error. A candidate admin with legitimate replacement authority could trigger this by providing uppercase hex characters in the `NewPubkey` field.

**Attack Complexity:**
Simple - just requires passing an uppercase hex string to `ReplaceCandidatePubkey`: [10](#0-9) 

**Feasibility Conditions:**
- Admin must call `ReplaceCandidatePubkey` (legitimate operation)
- `NewPubkey` parameter contains uppercase hex characters (A-F instead of a-f)
- This could happen if:
  - Admin manually constructs the transaction and uses uppercase
  - A tool or library outputs uppercase hex (less common but possible)
  - Copy-paste from documentation or logs that use uppercase formatting

**Detection/Operational Constraints:**
- The issue manifests immediately when the miner tries to produce their first block
- Error message would be: "Sender {pubkey} is not a miner"
- Could be mistakenly attributed to other issues
- Remediation is straightforward: replace again with lowercase pubkey

**Probability:** Moderate-to-Low. Most tools default to lowercase hex, but the possibility exists in real-world usage where admins interact with the contract through various interfaces.

### Recommendation

**Code-Level Mitigation:**
Normalize all pubkey strings to lowercase when storing them in `RealTimeMinersInformation`. Modify `RecordCandidateReplacement` to normalize the input:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");
    
    // Normalize pubkey strings to lowercase
    var oldPubkey = input.OldPubkey?.ToLower();
    var newPubkey = input.NewPubkey?.ToLower();

    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(oldPubkey)) return new Empty();

    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[oldPubkey];
    realTimeMinerInformation.Pubkey = newPubkey;
    currentRound.RealTimeMinersInformation.Remove(oldPubkey);
    currentRound.RealTimeMinersInformation.Add(newPubkey, realTimeMinerInformation);
    // ... rest of method
}
```

Alternatively, normalize in the Election contract before sending: [11](#0-10) 

**Invariant Check:**
Add assertion that pubkey strings are lowercase before adding to `RealTimeMinersInformation`:
```csharp
Assert(newPubkey == newPubkey.ToLower(), "Pubkey must be lowercase hex");
```

**Test Cases:**
Add test case in `ReplaceCandidateTests.cs` that:
1. Replaces a candidate with uppercase hex in `NewPubkey`
2. Attempts to produce a block with the replaced miner
3. Verifies the block is accepted (after fix) or rejected (before fix)

### Proof of Concept

**Initial State:**
- Miner with pubkey bytes [0x04, 0xAB, 0xC1, 0x23, ...] is in current round
- Hex representation via `ToHex()`: "04abc123..." (lowercase)
- `RealTimeMinersInformation["04abc123..."]` contains their miner information

**Transaction Steps:**

1. **Candidate Admin Replaces Pubkey:**
```
ElectionContract.ReplaceCandidatePubkey({
  OldPubkey: "04abc123...",
  NewPubkey: "04ABC123..."  // Same bytes, uppercase hex
})
```

2. **Election Contract Notifies Consensus:** [5](#0-4) 

3. **Consensus Contract Updates Round:**
    - Removes `RealTimeMinersInformation["04abc123..."]`
    - Adds `RealTimeMinersInformation["04ABC123..."]` with miner info [12](#0-11) 

4. **Miner Produces Block:**
    - Block header contains pubkey bytes [0x04, 0xAB, 0xC1, 0x23, ...]
    - `SenderPubkey = ExtraData.SenderPubkey.ToHex()` = "04abc123..." (lowercase) [1](#0-0) 

5. **Validation Fails:**
    - `MiningPermissionValidationProvider` checks: `RealTimeMinersInformation.Keys.Contains("04abc123...")`
    - Dictionary contains key "04ABC123..." (uppercase)
    - `Contains()` returns `false` (case-sensitive comparison)
    - Validation returns: "Sender 04abc123... is not a miner" [3](#0-2) 

**Expected Result:** Block should be accepted (miner is legitimate)

**Actual Result:** Block is rejected with "Sender is not a miner" error

**Success Condition:** Miner cannot produce blocks until pubkey is replaced again with lowercase hex string.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L17-17)
```csharp
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();
```

**File:** src/AElf.Types/Extensions/ByteStringExtensions.cs (L24-28)
```csharp
                b = (byte)(bytes[bx] >> 4);
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L141-143)
```csharp
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L280-302)
```csharp
    private void PerformReplacement(string oldPubkey, string newPubkey)
    {
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;

        // Notify Consensus Contract to update replacement information. (Update from old record.)
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L475-475)
```csharp
            snapshot.ElectionResult.Add(pubkey.ToHex(), validObtainedVotesAmount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L16-17)
```csharp
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L37-37)
```csharp
            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L387-391)
```csharp
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```

**File:** protobuf/election_contract.proto (L504-507)
```text
message ReplaceCandidatePubkeyInput {
    string old_pubkey = 1;
    string new_pubkey = 2;
}
```
