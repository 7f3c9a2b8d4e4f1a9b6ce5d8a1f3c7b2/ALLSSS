# Audit Report

## Title
State Persistence Failure in RemoveBeneficiary Causes Share Accounting Loss in Delayed Distribution Schemes

## Summary
The `RemoveBeneficiary` function contains a critical state persistence bug where modifications to `CachedDelayTotalShares` are made to a local variable but never written back to contract state. This causes future profit distributions to use inflated share totals that include removed beneficiaries, resulting in permanent dilution of profits for all remaining legitimate beneficiaries in schemes with delayed distribution periods.

## Finding Description

The vulnerability exists in the `RemoveBeneficiary` function where state persistence is incomplete. The function reads the scheme from state, modifies the local `scheme.CachedDelayTotalShares` map to subtract removed shares, but only persists the `TotalShares` field without writing back the entire modified scheme object. [1](#0-0) 

The execution path shows the bug:
1. Line 229: Reads scheme from state into local variable
2. Line 241: Calls `RemoveProfitDetails` which returns removed share amounts by period
3. Lines 243-258: Correctly modifies local `scheme.CachedDelayTotalShares` to subtract removed shares from cached delay periods
4. **Line 260 - CRITICAL BUG**: Only updates `TotalShares` via direct state property access: `State.SchemeInfos[input.SchemeId].TotalShares = ...`
5. Returns without persisting the `CachedDelayTotalShares` modifications made in the local variable

This violates the consistent pattern used throughout the codebase. Every other function that modifies scheme state writes back the entire object. For comparison, `AddBeneficiary` correctly writes back the full scheme: [2](#0-1) 

Similarly, `RemoveSubScheme` also writes back the entire scheme object after modification: [3](#0-2) 

The `ClaimProfits` function also correctly updates `CachedDelayTotalShares` and persists the entire scheme: [4](#0-3) 

The `CachedDelayTotalShares` mechanism is critical for delayed distribution. When profits are distributed, the system caches current total shares for future periods and uses these cached values instead of current totals when those periods arrive: [5](#0-4) 

The Scheme protobuf definition confirms `cached_delay_total_shares` is a mutable map field that must be persisted: [6](#0-5) 

A test case explicitly expects this functionality to work correctly, validating that `CachedDelayTotalShares` is properly adjusted after removal: [7](#0-6) 

## Impact Explanation

**Direct Fund Impact**: When a beneficiary is removed from a scheme with `DelayDistributePeriodCount > 0`, their shares remain counted in the cached totals for future distribution periods. This causes:

- Future profit distributions at line 469 use inflated `totalShares` values from `CachedDelayTotalShares` that incorrectly include removed beneficiaries
- The profit calculation functions at lines 490-492 distribute based on this inflated total
- Each remaining beneficiary receives: `beneficiary_amount = total_amount * shares / inflated_total` instead of the correct `beneficiary_amount = total_amount * shares / actual_total`
- The "missing" allocation corresponding to removed shares is effectively lost, as no active beneficiary can claim it and it remains locked in the period's virtual address
- If 20% of shares are removed but cached values aren't updated, remaining beneficiaries lose approximately 20% of their rightful profits in affected cached periods

**Who is affected**: All legitimate beneficiaries in schemes with delayed distribution lose a portion of their entitled profits whenever any beneficiary is removed. This particularly impacts staking reward systems and validator compensation schemes that commonly use delayed distribution.

**Severity**: HIGH - This causes direct, permanent loss of funds through mathematically incorrect profit distribution calculations, violating the critical invariant of accurate dividend distribution and settlement. The funds are not stolen but become permanently unclaimable, effectively burning a portion of rewards.

## Likelihood Explanation

**Reachable Entry Point**: `RemoveBeneficiary` is a public method callable by the scheme manager or TokenHolder contract, as validated by the authorization checks at lines 237-239.

**Feasible Preconditions**: 
- Scheme must have `DelayDistributePeriodCount > 0` (a legitimate and common configuration for staking rewards and validator compensation)
- Scheme manager removes beneficiaries (normal governance operation, not malicious)
- Profits have been distributed in prior periods, creating cached entries in `CachedDelayTotalShares`
- No special attacker capabilities needed - this is a bug triggered by legitimate operations

**Execution Practicality**: The bug triggers automatically in normal operations:
1. Create scheme with delay distribution (e.g., 3-period delay for validator rewards)
2. Add beneficiaries and distribute profits over several periods (this populates `CachedDelayTotalShares` for future periods)
3. Remove any beneficiary via legitimate governance action
4. Continue distributing profits - the cached totals incorrectly include the removed beneficiary's shares
5. Remaining beneficiaries receive diluted profits

**Detection Constraints**: The bug is silent - transactions succeed without revert, but profit calculations are quietly incorrect. There's no error or event to alert users that share accounting is wrong. The discrepancy only becomes apparent through careful analysis of distributed amounts versus expected amounts.

**Probability**: VERY HIGH - This occurs on every `RemoveBeneficiary` call for schemes with `DelayDistributePeriodCount > 0`, which are commonly used in staking and reward distribution systems throughout the AElf ecosystem.

## Recommendation

Add the missing state persistence by writing back the entire scheme object after modifying `CachedDelayTotalShares`. Change line 260 from:

```csharp
State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());
```

To:

```csharp
scheme.TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());
State.SchemeInfos[input.SchemeId] = scheme;
```

This follows the same pattern used in `AddBeneficiary`, `RemoveSubScheme`, `DistributeProfits`, and `ClaimProfits`, ensuring all scheme modifications are properly persisted to state.

## Proof of Concept

The existing test at lines 267-273 of `SchemeTests.cs` demonstrates the expected behavior. This test creates a scheme with 3-period delay distribution, adds beneficiaries, distributes profits (which caches shares for future periods), removes a beneficiary, then validates that `CachedDelayTotalShares` should contain the updated values (12 shares after removal). [8](#0-7) 

The test expects `scheme.CachedDelayTotalShares.Values.ShouldAllBe(v => v == 12)` after removal, confirming that the cached delay shares should be updated. However, due to the bug at line 260 of `ProfitContract.cs`, these modifications are lost when only `TotalShares` is written back instead of the entire scheme object.

To reproduce the vulnerability:
1. Run the `ProfitContract_DelayDistribution_Test` 
2. Observe that after `RemoveBeneficiaryAsync` at line 269, the cached delay shares remain at their pre-removal values instead of being decremented
3. Subsequent distributions use these inflated cached totals, causing profit dilution for remaining beneficiaries

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L131-156)
```csharp
    public override Empty RemoveSubScheme(RemoveSubSchemeInput input)
    {
        Assert(input.SchemeId != input.SubSchemeId, "Two schemes cannot be same.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only manager can remove sub-scheme.");

        var shares = scheme.SubSchemes.SingleOrDefault(d => d.SchemeId == input.SubSchemeId);
        if (shares == null) return new Empty();

        var subSchemeId = input.SubSchemeId;
        var subScheme = State.SchemeInfos[subSchemeId];
        Assert(subScheme != null, "Sub scheme not found.");

        var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
        // Remove profit details
        State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
        scheme.SubSchemes.Remove(shares);
        scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L158-184)
```csharp
    public override Empty AddBeneficiary(AddBeneficiaryInput input)
    {
        AssertValidInput(input);
        if (input.EndPeriod == 0)
            // Which means this profit Beneficiary will never expired unless removed.
            input.EndPeriod = long.MaxValue;

        var schemeId = input.SchemeId;
        var scheme = State.SchemeInfos[schemeId];

        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");

        Context.LogDebug(() =>
            $"{input.SchemeId}.\n End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);

        State.SchemeInfos[schemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-263)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);

        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }

        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L462-496)
```csharp
        var totalShares = scheme.TotalShares;

        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }

        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");

        var profitsReceivingVirtualAddress =
            GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, releasingPeriod);

        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);

        Context.LogDebug(() => $"Receiving virtual address: {profitsReceivingVirtualAddress}");

        UpdateDistributedProfits(profitsMap, profitsReceivingVirtualAddress, totalShares);

        PerformDistributeProfits(profitsMap, scheme, totalShares, profitsReceivingVirtualAddress);

        scheme.CurrentPeriod = input.Period.Add(1);

        State.SchemeInfos[input.SchemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-799)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;
```

**File:** protobuf/profit_contract.proto (L135-160)
```text
message Scheme {
    // The virtual address of the scheme.
    aelf.Address virtual_address = 1;
    // The total weight of the scheme.
    int64 total_shares = 2;
    // The manager of the scheme.
    aelf.Address manager = 3;
    // The current period.
    int64 current_period = 4;
    // Sub schemes information.
    repeated SchemeBeneficiaryShare sub_schemes = 5;
    // Whether you can directly remove the beneficiary.
    bool can_remove_beneficiary_directly = 6;
    // Period of profit distribution.
    int64 profit_receiving_due_period_count = 7;
    // Whether all the schemes balance will be distributed during distribution each period.
    bool is_release_all_balance_every_time_by_default = 8;
    // The is of the scheme.
    aelf.Hash scheme_id = 9;
    // Delay distribute period.
    int32 delay_distribute_period_count = 10;
    // Record the scheme's current total share for deferred distribution of benefits, period -> total shares.
    map<int64, int64> cached_delay_total_shares = 11;
    // The received token symbols.
    repeated string received_token_symbols = 12;
}
```

**File:** test/AElf.Contracts.Profit.Tests/BVT/SchemeTests.cs (L165-287)
```csharp
    public async Task ProfitContract_DelayDistribution_Test()
    {
        const int delayDistributePeriodCount = 3;
        const int contributeAmountEachTime = 100_000;
        var creator = Creators[0];
        var creatorAddress = Address.FromPublicKey(CreatorKeyPair[0].PublicKey);

        await creator.CreateScheme.SendAsync(new CreateSchemeInput
        {
            IsReleaseAllBalanceEveryTimeByDefault = true,
            ProfitReceivingDuePeriodCount = 100,
            DelayDistributePeriodCount = delayDistributePeriodCount,
            CanRemoveBeneficiaryDirectly = true
        });

        var createdSchemeIds = (await creator.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
        {
            Manager = creatorAddress
        })).SchemeIds;

        _schemeId = createdSchemeIds.First();

        var periodToTotalShares = new Dictionary<long, long>();
        var currentShares = 0L;

        // Distribute 3 times.
        for (var period = 1; period <= 3; period++)
        {
            currentShares += await AddBeneficiariesAsync(creator);
            periodToTotalShares.Add(period, currentShares);

            await ContributeAndDistribute(creator, contributeAmountEachTime, period);

            // Check distributed information.
            var distributedInformation = await creator.GetDistributedProfitsInfo.CallAsync(new SchemePeriod
            {
                Period = period,
                SchemeId = _schemeId
            });
            distributedInformation.IsReleased.ShouldBeTrue();
            distributedInformation.TotalShares.ShouldBe(0);
            distributedInformation.AmountsMap[ProfitContractTestConstants.NativeTokenSymbol]
                .ShouldBe(-contributeAmountEachTime);
        }

        // Distribution of period 4 will use the total shares of period 1.
        {
            await ContributeAndDistribute(creator, contributeAmountEachTime, 4);
            // Check distributed information.
            var distributedInformation = await creator.GetDistributedProfitsInfo.CallAsync(new SchemePeriod
            {
                Period = 4,
                SchemeId = _schemeId
            });
            distributedInformation.IsReleased.ShouldBeTrue();
            distributedInformation.TotalShares.ShouldBe(periodToTotalShares[1]);
            distributedInformation.AmountsMap[ProfitContractTestConstants.NativeTokenSymbol]
                .ShouldBe(contributeAmountEachTime);
        }

        // Distribution of period 5 will use the total shares of period 2.
        {
            await ContributeAndDistribute(creator, contributeAmountEachTime, 5);
            // Check distributed information.
            var distributedInformation = await creator.GetDistributedProfitsInfo.CallAsync(new SchemePeriod
            {
                Period = 5,
                SchemeId = _schemeId
            });
            distributedInformation.TotalShares.ShouldBe(periodToTotalShares[2]);
            distributedInformation.AmountsMap[ProfitContractTestConstants.NativeTokenSymbol]
                .ShouldBe(contributeAmountEachTime);
        }

        // Distribution of period 6 will use the total shares of period 3.
        {
            await ContributeAndDistribute(creator, contributeAmountEachTime, 6);
            // Check distributed information.
            var distributedInformation = await creator.GetDistributedProfitsInfo.CallAsync(new SchemePeriod
            {
                Period = 6,
                SchemeId = _schemeId
            });
            distributedInformation.TotalShares.ShouldBe(periodToTotalShares[3]);
            distributedInformation.AmountsMap[ProfitContractTestConstants.NativeTokenSymbol]
                .ShouldBe(contributeAmountEachTime);
        }

        // Distribution of period 7 will use the total shares of period 4 (same with period 3).
        {
            await ContributeAndDistribute(creator, contributeAmountEachTime, 7);
            // Check distributed information.
            var distributedInformation = await creator.GetDistributedProfitsInfo.CallAsync(new SchemePeriod
            {
                Period = 7,
                SchemeId = _schemeId
            });
            distributedInformation.TotalShares.ShouldBe(periodToTotalShares[3]);
            distributedInformation.AmountsMap[ProfitContractTestConstants.NativeTokenSymbol]
                .ShouldBe(contributeAmountEachTime);
        }

        {
            await ContributeAndDistribute(creator, contributeAmountEachTime, 8);
            await RemoveBeneficiaryAsync(creator, Accounts[11].Address);
            var scheme = await creator.GetScheme.CallAsync(_schemeId);
            scheme.CachedDelayTotalShares.Values.ShouldAllBe(v => v == 12);
            scheme.TotalShares.ShouldBe(12);
        }
        
        {
            await ContributeAndDistribute(creator, contributeAmountEachTime, 9);
            // Check distributed information.
            var distributedInformation = await creator.GetDistributedProfitsInfo.CallAsync(new SchemePeriod
            {
                Period = 9,
                SchemeId = _schemeId
            });
            distributedInformation.TotalShares.ShouldBe(12);
            distributedInformation.AmountsMap[ProfitContractTestConstants.NativeTokenSymbol]
                .ShouldBe(contributeAmountEachTime);
        }
    }
```
