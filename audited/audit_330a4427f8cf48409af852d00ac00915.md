### Title
LIB Freeze Attack via Byzantine Miner Non-Participation Halting Cross-Chain Operations

### Summary
An attacker controlling or influencing more than 1/3 of miners to abstain from mining causes the Last Irreversible Block (LIB) height calculation to return 0, freezing block finalization. This prevents new blocks from becoming irreversible and halts cross-chain indexing operations that depend on advancing LIB height, effectively blocking cross-chain withdrawals, deposits, and other finality-dependent operations.

### Finding Description

The vulnerability exists in the `LastIrreversibleBlockHeightCalculator.Deconstruct()` method where LIB height is calculated based on miner participation. [1](#0-0) 

The calculation logic:
1. Retrieves miners who actually mined in the current round via `GetMinedMiners()`
2. Gets their implied irreversible block heights from the previous round
3. If the count of these heights is less than `MinersCountOfConsent`, sets `libHeight = 0` and returns
4. Otherwise calculates LIB using the Byzantine fault-tolerant formula [2](#0-1) 

The threshold `MinersCountOfConsent = N × 2 ÷ 3 + 1` requires more than 2/3 of total miners to participate. If more than 1/3 abstain, the count falls below this threshold. [3](#0-2) 

Miners who mine are identified by having `SupposedOrderOfNextRound ≠ 0`. Absent miners simply don't appear in this list.

The LIB update check only fires `IrreversibleBlockFound` when the new `libHeight` exceeds the previous value: [4](#0-3) 

When `libHeight = 0`, the condition `currentRound.ConfirmedIrreversibleBlockHeight < 0` is false, preventing the event from firing and freezing the LIB at its current height.

Cross-chain operations depend on advancing LIB: [5](#0-4) 

This method returns `null` for any height greater than `LastIrreversibleBlockHeight`, effectively blocking cross-chain indexing of new blocks.

### Impact Explanation

**Operational DoS Impact:**
- New blocks continue to be produced but never become irreversible
- Cross-chain indexing cannot retrieve blocks at heights beyond the frozen LIB
- Cross-chain withdrawals requiring finality of new blocks are blocked
- Cross-chain deposits and merkle proof verification for new data halt
- Any operation dependent on block finality (state finality, cross-chain transfers) cannot proceed for new blocks

**Affected Parties:**
- Users attempting cross-chain operations
- Parent/side chain synchronization processes
- DApps and services requiring transaction finality guarantees

**Severity Justification:** 
This is a consensus-level DoS attack that compromises a critical invariant: LIB must advance as blocks are produced. The freeze duration can be sustained for at least 3 days (until evil miner detection triggers), potentially longer if attackers can recruit replacement miners.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires control or influence over >1/3 of active miners (~34% of mining power)
- Can be achieved through: direct ownership, bribes, coordinated DDoS attacks, or social engineering
- In a 17-miner network (default `SupposedMinersCount`), needs 6+ miners to abstain [6](#0-5) 

**Attack Complexity:**
- Simple execution: targeted miners simply stop producing blocks
- No complex transaction crafting or exploit chains required
- Attack is immediately effective once threshold is reached

**Detection Constraints:**
- Attack is publicly visible (miners missing time slots)
- Evil miner detection activates after 4,320 missed slots (~3 days)
- Non-participating miners are eventually removed, but damage occurs during the window [7](#0-6) 

**Economic Rationality:**
- Attack cost: bribes to miners + their lost mining rewards during the attack period
- Attack benefit: blocking specific high-value cross-chain operations (e.g., preventing a large withdrawal or causing service disruption)
- For targeted attacks (e.g., blocking a competitor's cross-chain transaction), the cost may be justified

**Probability Assessment:**
Within the Byzantine threat model assumptions (up to 1/3 malicious actors), this attack is feasible and practical. The 2/3 threshold is standard for BFT consensus but creates a sharp failure mode rather than graceful degradation.

### Recommendation

**Immediate Mitigation:**
1. Implement graceful LIB degradation instead of complete freeze when participation drops:
```
// In Deconstruct() method
if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
{
    // Use degraded LIB calculation with available miners
    if (impliedIrreversibleHeights.Count > 0)
    {
        // Calculate with available data, apply penalty factor
        var degradedIndex = Math.Max(0, impliedIrreversibleHeights.Count - 1 - 
            (_currentRound.MinersCountOfConsent - impliedIrreversibleHeights.Count));
        libHeight = impliedIrreversibleHeights[degradedIndex];
    }
    else
    {
        libHeight = 0;
    }
    return;
}
```

2. Add minimum participation threshold check and halt consensus if repeatedly breached:
```
// Track consecutive rounds with insufficient participation
if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
{
    State.ConsecutiveInsufficientRounds.Value++;
    Assert(State.ConsecutiveInsufficientRounds.Value < 10, 
        "Network under attack: insufficient miner participation");
}
else
{
    State.ConsecutiveInsufficientRounds.Value = 0;
}
```

3. Reduce evil miner detection threshold from 3 days to 1 day for critical participation failures

**Long-term Improvements:**
1. Implement adaptive consensus that can tolerate temporary participation drops
2. Add emergency governance mechanism to quickly remove non-participating miners
3. Introduce participation bond slashing for extended absence
4. Add LIB advancement monitoring and automated alerts

**Test Cases:**
1. Test with exactly 2/3 miner participation - verify graceful behavior
2. Test with gradually decreasing participation - verify detection and response
3. Test recovery after participation resumes - verify LIB catches up correctly
4. Test cross-chain operations during degraded LIB mode

### Proof of Concept

**Initial State:**
- Network with N = 7 miners
- MinersCountOfConsent = 7 × 2 ÷ 3 + 1 = 5
- Current LIB height = 1000
- All miners actively participating

**Attack Steps:**
1. Attacker bribes or controls 3 miners (>1/3) to stop mining
2. In subsequent rounds, only 4 miners produce blocks
3. When `ProcessUpdateValue` is called by any miner:
   - `GetMinedMiners()` returns 4 miners
   - `GetSortedImpliedIrreversibleBlockHeights(4 miners)` returns 4 heights
   - Check: `4 < 5` → TRUE
   - Result: `libHeight = 0`
4. LIB update check: `1000 < 0` → FALSE
5. No `IrreversibleBlockFound` event fired
6. Chain LIB remains at 1000

**Expected vs Actual Result:**
- Expected: LIB continues advancing (perhaps at reduced rate) as blocks are produced
- Actual: LIB frozen at height 1000, new blocks never become irreversible

**Success Condition:**
Cross-chain operation attempting to index a block at height 1001+ receives `null` from `GetIrreversibleBlockByHeightAsync`, demonstrating the operational DoS. This state persists for minimum 3 days until non-participating miners are removed.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** src/AElf.CrossChain.Core/Extensions/LocalLibExtensions.cs (L10-18)
```csharp
    public static async Task<Block> GetIrreversibleBlockByHeightAsync(this IBlockchainService blockchainService,
        long height)
    {
        var chain = await blockchainService.GetChainAsync();
        if (chain.LastIrreversibleBlockHeight < height + CrossChainConstants.LibHeightOffsetForCrossChainIndex)
            return null;
        var blockHash = await blockchainService.GetBlockHashByHeightAsync(chain, height, chain.BestChainHash);
        return await blockchainService.GetBlockByHashAsync(blockHash);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-11)
```csharp
    public const int SupposedMinersCount = 17;
    public const int KeepRounds = 40960;
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```
