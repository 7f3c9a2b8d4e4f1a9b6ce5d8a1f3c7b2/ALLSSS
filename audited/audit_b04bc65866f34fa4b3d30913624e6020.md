### Title
Ineffective Duplicate Mining Order Validation Allows Consensus Corruption

### Summary
The `ValidateHeaderInformation()` method in `NextRoundMiningOrderValidationProvider` uses `Distinct()` on entire `MinerInRound` objects instead of validating that `FinalOrderOfNextRound` values are unique. This allows multiple miners to have identical mining order values, which corrupts the next round generation logic and breaks the deterministic mining schedule, potentially halting consensus.

### Finding Description

The validation logic incorrectly checks for duplicate mining orders: [1](#0-0) 

The `Distinct()` method operates on entire `MinerInRound` objects, which are protobuf-generated classes with 17 fields including `pubkey`, `order`, `in_value`, `out_value`, `signature`, `expected_mining_time`, and more: [2](#0-1) 

Since protobuf equality compares ALL fields, two `MinerInRound` objects with the same `FinalOrderOfNextRound` but different `pubkey` values (which they must have, being different miners) are considered distinct. The validation therefore counts them as separate, failing to detect the duplicate order values.

The next round generation logic critically depends on all `FinalOrderOfNextRound` values being unique: [3](#0-2) [4](#0-3) 

When duplicate `FinalOrderOfNextRound` values exist:
1. Ordering by `FinalOrderOfNextRound` produces ambiguous results
2. The duplicate order value is assigned to multiple miners as their `Order` in the next round
3. The "occupied orders" collection only counts each duplicate once
4. Available order calculation incorrectly thinks duplicate orders are available
5. Result: Next round has multiple miners assigned to the same time slot

This validator is invoked during `NextRound` behavior validation: [5](#0-4) 

The conflict resolution logic in `ApplyNormalConsensusData` is designed to prevent duplicates during normal UpdateValue processing: [6](#0-5) 

However, this validation is the last defense against maliciously crafted or buggy `NextRoundInput` data submitted directly to the `NextRound` method: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Violation**: When duplicate `FinalOrderOfNextRound` values pass validation, the generated next round contains multiple miners with identical `Order` values. This breaks the fundamental invariant that each miner must have a unique time slot.

**Concrete Harm**:
- Multiple miners believe they should produce blocks at the same time
- Deterministic mining schedule becomes non-deterministic
- Conflicting blocks produced simultaneously
- Consensus validation failures when miners with duplicate orders attempt to mine
- Potential chain halt or permanent fork

**Affected Parties**: All network participants—validators cannot reach consensus, transactions cannot be confirmed, chain operation halts.

**Severity**: CRITICAL - This breaks a core consensus invariant that ensures proper round transitions and mining order integrity.

### Likelihood Explanation

**Attacker Capabilities**: Any current miner can exploit this. Miners have permission to call `NextRound` during their assigned time slots.

**Attack Complexity**: Low. Attacker constructs a `NextRoundInput` with duplicate `FinalOrderOfNextRound` values across multiple `MinerInRound` entries, then submits it via the `NextRound` transaction.

**Feasibility Conditions**:
- Attacker must be an active miner in current round
- Must be attacker's turn to produce a block and trigger round transition
- No additional preconditions required

**Detection Constraints**: The validation fails silently—it doesn't detect the duplicates. The corruption only becomes apparent when the next round begins and multiple miners attempt to mine simultaneously.

**Probability**: High. The exploit is straightforward, requires minimal resources, and the validation gap is systematic. The only protection is the conflict resolution in `ApplyNormalConsensusData`, but that doesn't apply to directly crafted `NextRoundInput` data.

### Recommendation

**Code-Level Mitigation**: Replace the object-level distinctness check with a value-level check. The project targets .NET 8.0: [8](#0-7) 

Use either approach:

**Option 1** (using `DistinctBy` available in .NET 6+):
```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .DistinctBy(m => m.FinalOrderOfNextRound)
    .Count();
```

**Option 2** (explicitly select values first):
```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
```

**Invariant Check**: Add explicit validation that all `FinalOrderOfNextRound` values form a contiguous sequence from 1 to N, ensuring not just uniqueness but also completeness.

**Test Cases**:
1. Test with two miners having identical `FinalOrderOfNextRound` but different `pubkey`—should fail validation
2. Test with valid unique orders—should pass validation
3. Test with gaps in order sequence (e.g., orders 1, 2, 4 with 3 missing)—should fail if contiguous check added

### Proof of Concept

**Initial State**:
- Current round has 3 active miners: Alice, Bob, Carol
- All three mined blocks (all have `OutValue != null`)
- It's Alice's turn to trigger `NextRound`

**Attack Sequence**:

1. Alice constructs malicious `NextRoundInput` where:
   - Alice: `FinalOrderOfNextRound = 1`
   - Bob: `FinalOrderOfNextRound = 2`
   - Carol: `FinalOrderOfNextRound = 2` (duplicate!)

2. Alice submits transaction calling `NextRound(maliciousInput)`

3. Validation executes:
   ```
   Where(m => m.FinalOrderOfNextRound > 0) → returns [Alice, Bob, Carol]
   Distinct() → returns [Alice, Bob, Carol] (3 distinct objects)
   Count() → returns 3
   
   Count(m => m.OutValue != null) → returns 3
   
   3 == 3 → Validation PASSES (incorrect!)
   ```

4. `ProcessNextRound` accepts the corrupted data and stores it

5. Next round generation uses corrupted orders:
   - Bob gets `Order = 2`
   - Carol gets `Order = 2` (duplicate!)
   - Both miners scheduled for same time slot

**Expected Result**: Validation should FAIL detecting duplicate order value 2

**Actual Result**: Validation PASSES, next round is corrupted with duplicate orders, consensus breaks when Bob and Carol both attempt to mine at the same time

**Success Condition**: Chain reaches the next round with two miners having identical `Order` values, breaking the mining schedule and causing consensus failure.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-86)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L23-40)
```csharp
        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-165)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElf.Contracts.Consensus.AEDPoS.csproj (L5-5)
```text
        <TargetFramework>net8.0</TargetFramework>
```
