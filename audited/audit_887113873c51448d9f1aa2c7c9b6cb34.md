### Title
Insufficient Order Validation Allows Duplicate Mining Orders to Break Secret Sharing Reconstruction

### Summary
The consensus mechanism lacks proper validation to prevent duplicate `FinalOrderOfNextRound` values, allowing a malicious miner to manipulate `TuneOrderInformation` and create duplicate `Order` values in subsequent rounds. When `RevealSharedInValues` processes these duplicate orders, the Lagrange interpolation in `DecodeSecret` produces incorrect results, causing miners' `PreviousInValue` to be set to wrong hashes and breaking the consensus secret sharing verification mechanism.

### Finding Description

The vulnerability exists due to three interconnected validation failures:

**Root Cause #1 - Flawed Duplicate Detection:**
The `NextRoundMiningOrderValidationProvider` attempts to validate that mining orders are unique, but the implementation is incorrect. [1](#0-0) 

The `Distinct()` method operates on `MinerInRound` objects rather than the `FinalOrderOfNextRound` values themselves. Since each miner has a unique `MinerInRound` instance, the check always passes regardless of whether the actual order values are duplicates. The validation should extract the order values before checking distinctness.

**Root Cause #2 - Unvalidated TuneOrderInformation:**
When processing `UpdateValue`, the contract blindly applies whatever `TuneOrderInformation` is provided in the input without validating uniqueness or range. [2](#0-1) 

A malicious miner can set multiple miners to have identical `FinalOrderOfNextRound` values through crafted `TuneOrderInformation`. The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`, but does not validate `TuneOrderInformation` content. [3](#0-2) 

**Root Cause #3 - Missing Input Validation in DecodeSecret:**
The `RevealSharedInValues` function extracts order values from the previous round's miner information and passes them to `DecodeSecret` without validation. [4](#0-3) 

The `DecodeSecret` function performs Shamir's Secret Sharing reconstruction using Lagrange interpolation but does not validate that the `orders` parameter contains unique values. [5](#0-4) 

When duplicate orders exist (e.g., `orders[j] == orders[i]` for `j != i`), the denominator calculation `orders[j] - orders[i]` becomes zero. [6](#0-5) 

In `MultiplyRational`, when `denominatorRhs` is zero, the resulting denominator becomes zero. [7](#0-6) 

Subsequently, `RationalToWhole` calls `Inverse(0)`, which returns zero through the Extended Euclidean Algorithm. [8](#0-7) [9](#0-8) 

This causes the Lagrange basis polynomial term to evaluate to zero instead of the correct value, resulting in incorrect secret reconstruction. The computed `revealedInValue` is thus incorrect, compromising the secret sharing verification mechanism.

### Impact Explanation

**Consensus Integrity Compromise:**
- The secret sharing mechanism is designed to reconstruct and verify miners' `PreviousInValue` through Lagrange interpolation, ensuring miners cannot cheat on their random value commitments
- When `DecodeSecret` produces incorrect results due to duplicate orders, miners' `PreviousInValue` is set to wrong hashes in the current round
- This breaks the cryptographic integrity of the random number generation and consensus validation chain
- Subsequent rounds may fail validation or accept invalid consensus states, potentially leading to chain halts or consensus failures

**Affected Parties:**
- All consensus participants are affected as the secret sharing verification becomes unreliable
- The entire network's consensus security is degraded when this mechanism fails
- Honest miners may be falsely flagged or malicious behavior may go undetected

**Severity: Medium**
- Does not directly result in fund theft or unauthorized minting
- Compromises consensus integrity and random number generation security
- Could enable secondary attacks by breaking miner behavior verification
- May cause consensus disruption requiring manual intervention

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an active miner in the consensus set
- No special privileges beyond normal miner capabilities required
- Can craft malicious `UpdateValueInput` with duplicate `TuneOrderInformation` values

**Attack Complexity:**
- Low complexity: Simply requires modifying the `TuneOrderInformation` field when calling `UpdateValue`
- No sophisticated cryptographic attacks or timing manipulation needed
- Can be executed in a single transaction during the attacker's mining slot

**Feasibility Conditions:**
- Requires the attacker to be selected as a miner through the election process
- Secret sharing must be enabled (checked via configuration contract) [10](#0-9) 
- The malicious round must successfully transition through `NextRound` to propagate duplicate orders
- Effects manifest two rounds later when `RevealSharedInValues` is called

**Detection Constraints:**
- The incorrect `PreviousInValue` values would be detectable through off-chain monitoring
- However, the flawed validation allows the attack to succeed on-chain
- May cause observable consensus anomalies that alert network operators

**Likelihood: Medium**
- Requires compromised miner position but miners are elected through governance
- Easy to execute once in position with low technical barriers
- Detectable but may cause temporary disruption before remediation

### Recommendation

**Immediate Fix #1 - Correct Duplicate Detection:**
In `NextRoundMiningOrderValidationProvider`, fix the distinctness check to validate actual order values:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
```

Location: [1](#0-0) 

**Immediate Fix #2 - Validate TuneOrderInformation:**
Add validation in `ProcessUpdateValue` or `UpdateValueValidationProvider` to ensure `TuneOrderInformation` values are unique, positive, and within valid range (1 to miner count):

```csharp
// After line 259, add validation:
var allOrdersAfterTuning = currentRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
Assert(allOrdersAfterTuning.Count == allOrdersAfterTuning.Distinct().Count(), 
    "Duplicate FinalOrderOfNextRound detected");
Assert(allOrdersAfterTuning.All(o => o > 0 && o <= minersCount), 
    "FinalOrderOfNextRound out of valid range");
```

Location: [2](#0-1) 

**Immediate Fix #3 - Add Input Validation to DecodeSecret:**
Add validation at the start of `DecodeSecret` to ensure orders are unique and positive:

```csharp
// After line 45, add:
Assert(orders.Count == orders.Distinct().Count(), "Orders must be unique");
Assert(orders.All(o => o > 0), "Orders must be positive");
```

Location: [11](#0-10) 

**Regression Prevention:**
Add unit tests covering:
1. Attempt to set duplicate `TuneOrderInformation` values - should fail
2. Attempt to call `NextRound` with duplicate `FinalOrderOfNextRound` - should fail  
3. Call `DecodeSecret` with duplicate orders - should fail with clear error
4. End-to-end test simulating the full attack path to ensure all validations work together

### Proof of Concept

**Initial State:**
- Round R with miners M1, M2, M3, M4 in consensus set
- Secret sharing is enabled
- M1 is a malicious miner preparing to produce block

**Attack Steps:**

1. **M1 produces block in Round R with malicious UpdateValue:**
   - M1 calls `UpdateValue` with crafted input
   - Sets `TuneOrderInformation = { M2.pubkey: 5, M3.pubkey: 5 }`
   - Both M2 and M3 now have `FinalOrderOfNextRound = 5`
   - No validation fails due to flawed `Distinct()` check on objects

2. **Round R transitions to Round R+1 via NextRound:**
   - `NextRound` is called, using `FinalOrderOfNextRound` values from Round R
   - Round R+1 is generated with M2.Order = 5 and M3.Order = 5 (duplicates) [12](#0-11) 
   - Flawed validation in `NextRoundMiningOrderValidationProvider` passes

3. **Round R+1 completes, Round R+2 begins:**
   - During Round R+2 block production, `RevealSharedInValues` is called
   - Function processes miners from Round R+1 (the previous round)
   - Extracts orders from `DecryptedPieces` for miners in Round R+1
   - Orders list contains: [1, 5, 5, 4] (duplicate 5s from M2 and M3)

4. **Secret reconstruction fails:**
   - `DecodeSecret` is called with duplicate orders [1, 5, 5, 4]
   - During Lagrange interpolation for M2's term (i=1, order=5):
     - Inner loop reaches M3 (j=2, order=5)
     - Computes `orders[j] - orders[i] = 5 - 5 = 0`
     - `MultiplyRational` produces denominator = 0
     - `Inverse(0)` returns 0
     - Lagrange term evaluates to 0 instead of correct value
   - Reconstructed secret is incorrect
   - `revealedInValue` is computed from wrong secret
   - M2's `PreviousInValue` is set to incorrect hash

**Expected vs Actual Result:**

*Expected (Secure):* 
- Validation should reject M1's `UpdateValue` with duplicate `TuneOrderInformation`
- Or `NextRound` validation should reject duplicate `FinalOrderOfNextRound` values
- Secret reconstruction should only proceed with valid, unique orders

*Actual (Vulnerable):*
- M1's malicious `UpdateValue` succeeds
- Round R+1 is created with duplicate Order values
- `DecodeSecret` produces incorrect results
- Consensus secret sharing verification is compromised

**Success Condition:**
The attack succeeds when M2's `PreviousInValue` in Round R+2 differs from the correct hash that should have been reconstructed from the secret shares, demonstrating broken secret sharing integrity.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-50)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L93-96)
```csharp
        private static BigInteger Inverse(BigInteger integer)
        {
            return GetGreatestCommonDivisor2(SecretSharingConsts.FieldPrime, integer).invB.Abs();
        }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L98-106)
```csharp
        private static (BigInteger numerator, BigInteger denominator) MultiplyRational(
            BigInteger numeratorLhs, BigInteger denominatorLhs,
            BigInteger numeratorRhs, BigInteger denominatorRhs)
        {
            var numerator = numeratorLhs * numeratorRhs % SecretSharingConsts.FieldPrime;
            var denominator = denominatorLhs * denominatorRhs % SecretSharingConsts.FieldPrime;
            var gcd = GetGreatestCommonDivisor(numerator, denominator);
            return (numerator / gcd, denominator / gcd);
        }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSaring.cs (L67-70)
```csharp

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L28-32)
```csharp
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
```
