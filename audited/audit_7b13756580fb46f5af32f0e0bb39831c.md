### Title
Rewards Permanently Lost When Candidate Uses Invalid Public Key Without Setting Custom Profits Receiver

### Summary
The `GetProfitsReceiver` function falls back to deriving an address from an unvalidated public key when no custom profits receiver is set. Since `AnnounceElectionFor` accepts any hex string as a public key without ECDSA validation, rewards (Welcome Reward, Subsidy, Basic Reward) can be distributed to addresses derived from invalid public keys that no one controls, resulting in permanent fund loss. [1](#0-0) 

### Finding Description

The vulnerability exists in the interaction between three components:

**1. Unvalidated Public Key Registration**

The `AnnounceElectionFor` method allows anyone to register a candidate with an arbitrary hex string as the public key, with no validation that it represents a valid ECDSA public key: [2](#0-1) 

**2. Fallback Address Derivation**

When rewards are distributed, `GetProfitsReceiver` checks if a custom profits receiver is set in `ProfitsReceiverMap`. If null, it falls back to `Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey))`: [1](#0-0) 

**3. Address.FromPublicKey Always Succeeds**

The `Address.FromPublicKey` method performs double-SHA256 hashing on any input and always returns a valid address, even for invalid or malformed public key data: [3](#0-2) 

The address derivation cannot fail because `ComputeHash` accepts any byte array: [4](#0-3) 

**4. Multiple Reward Distribution Paths**

Rewards are distributed to the derived address in multiple locations:

- **Welcome Reward** for newly elected miners: [5](#0-4) 

- **Basic Reward** for block producers: [6](#0-5) 

- **Subsidy** for candidates: [7](#0-6) 

### Impact Explanation

**Direct Fund Loss**: Mining rewards and subsidies are minted treasury funds. When distributed to addresses derived from invalid public keys, these funds become permanently inaccessible because:
- No one possesses the private key corresponding to the invalid public key
- The derived address is deterministic but uncontrollable
- There is no recovery mechanism for misdirected rewards

**Affected Parties**:
- The protocol loses minted rewards (Welcome Reward, Subsidy, Basic Reward)
- Legitimate candidates/voters lose expected reward distribution
- The treasury efficiency is reduced

**Quantified Impact**: Each newly elected miner receives Welcome Reward shares, and candidates receive Subsidy shares. For a single invalid candidate elected, the loss equals their proportional share of the reward pool for that term.

**Severity Justification**: HIGH impact due to permanent, unrecoverable fund loss from the treasury reward distribution system.

### Likelihood Explanation

**Attack Scenarios**:

1. **Honest Mistake**: A legitimate user calls `AnnounceElectionFor` with a typo or incorrectly formatted public key, doesn't realize the error, gets elected, and never sets a custom profits receiver. This results in unintentional fund loss.

2. **Grief Attack**: A malicious actor deliberately registers with an invalid public key and doesn't set a profits receiver to cause protocol fund loss, though they don't directly benefit.

**Preconditions**:
- Attacker/user must lock tokens (economic cost): [8](#0-7) 

- Candidate must get elected (requires votes or low competition)
- Candidate admin must not call `SetProfitsReceiver` to set a custom receiver

**Mitigation Factor**: The candidate admin can set a custom profits receiver to prevent loss: [9](#0-8) 

**Likelihood Assessment**: LOW-MEDIUM
- Entry point is public and reachable
- Execution is straightforward
- Economic rationality is weak (admin can set receiver to themselves)
- Most likely through honest mistakes rather than deliberate attacks
- Detection is possible (invalid candidate won't produce blocks)

### Recommendation

**1. Add ECDSA Public Key Validation**

Validate that the public key is a valid ECDSA public key before accepting candidate registration:

```csharp
private void ValidatePublicKey(byte[] pubkeyBytes)
{
    // Validate that pubkey is 33 or 65 bytes (compressed or uncompressed ECDSA)
    Assert(pubkeyBytes.Length == 33 || pubkeyBytes.Length == 65, 
        "Invalid public key length");
    
    // Attempt to derive address and verify it's a valid operation
    // Consider adding ECDSA point validation if available
    try
    {
        var address = Address.FromPublicKey(pubkeyBytes);
        Assert(address != null && address.Value.Length == 32, 
            "Invalid address derivation from public key");
    }
    catch
    {
        Assert(false, "Public key validation failed");
    }
}
```

Add this validation in `AnnounceElectionFor` before accepting the candidate: [10](#0-9) 

**2. Enforce Custom Profits Receiver**

Require that a custom profits receiver be set during candidate registration for `AnnounceElectionFor`:

```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    Assert(input.ProfitsReceiver != null && input.ProfitsReceiver.Value.Any(), 
        "Profits receiver must be specified for AnnounceElectionFor");
    // ... rest of logic
}
```

**3. Add Fallback Safety Check**

In `GetProfitsReceiver`, validate the derived address or require explicit receiver:

```csharp
private Address GetProfitsReceiver(string pubkey)
{
    var receiver = State.ProfitsReceiverMap[pubkey];
    Assert(receiver != null, 
        $"Profits receiver not set for candidate {pubkey}. Please call SetProfitsReceiver.");
    return receiver;
}
```

### Proof of Concept

**Initial State**:
- Attacker has sufficient tokens to lock for candidate registration
- Election system is active with open candidate slots

**Attack Sequence**:

1. **Register Invalid Candidate**
   - Call `AnnounceElectionFor` with invalid public key (e.g., "0000000000000000000000000000000000000000000000000000000000000000")
   - Lock required tokens
   - Candidate is registered with invalid pubkey

2. **Get Elected**
   - Use own votes or social engineering to get elected
   - Invalid candidate appears in next term's miner list

3. **Reward Distribution**
   - Treasury `Release` is called for new term
   - `UpdateWelcomeRewardWeights` is invoked for newly elected miners
   - `GetProfitsReceiver("0000...0000")` is called
   - `ProfitsReceiverMap["0000...0000"]` returns null
   - Falls back to `Address.FromPublicKey(HexStringToByteArray("0000...0000"))`
   - Derived address: deterministic hash output with no known private key

4. **Result**
   - Welcome Reward shares are allocated to uncontrollable address
   - Profit distribution sends tokens to this address
   - Funds are permanently inaccessible

**Expected**: Rewards distributed to valid, controllable addresses
**Actual**: Rewards sent to address derived from invalid pubkey, permanently lost
**Success Condition**: Reward balance at uncontrollable address > 0, with no way to recover

### Notes

While the candidate admin can call `SetProfitsReceiver` to mitigate this issue, the lack of public key validation creates unnecessary risk. The vulnerability is most likely to manifest through honest mistakes (typos, incorrect formatting) rather than deliberate attacks, but the impact is severe regardless of intent. The recommended validation ensures that only valid ECDSA public keys can be registered as candidates, preventing any scenario where rewards are distributed to uncontrollable addresses.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L601-629)
```csharp
    public override Empty SetProfitsReceiver(SetProfitsReceiverInput input)
    {
        if (State.ElectionContract.Value == null)
            State.ElectionContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName);
        var pubkey = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.Pubkey));
        
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
        
        var candidateList = State.ElectionContract.GetCandidates.Call(new Empty());
        Assert(candidateList.Value.Contains(pubkey),"Pubkey is not a candidate.");

        var previousProfitsReceiver = State.ProfitsReceiverMap[input.Pubkey];
        //Set same profits receiver address.
        if (input.ProfitsReceiverAddress == previousProfitsReceiver)
        {
            return new Empty();
        }
        State.ProfitsReceiverMap[input.Pubkey] = input.ProfitsReceiverAddress;
        State.ElectionContract.SetProfitsReceiver.Send(new AElf.Contracts.Election.SetProfitsReceiverInput
        {
            CandidatePubkey = input.Pubkey,
            ReceiverAddress = input.ProfitsReceiverAddress,
            PreviousReceiverAddress = previousProfitsReceiver ?? new Address()
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L651-655)
```csharp
    private Address GetProfitsReceiver(string pubkey)
    {
        return State.ProfitsReceiverMap[pubkey] ??
               Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey));
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L814-818)
```csharp
                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L872-877)
```csharp
            foreach (var minerAddress in newElectedMiners.Select(GetProfitsReceiver))
                newBeneficiaries.BeneficiaryShares.Add(new BeneficiaryShare
                {
                    Beneficiary = minerAddress,
                    Shares = 1
                });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** src/AElf.Types/Types/Address.cs (L37-41)
```csharp
        public static Address FromPublicKey(byte[] bytes)
        {
            var hash = bytes.ComputeHash().ComputeHash();
            return new Address(hash);
        }
```

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L64-70)
```csharp
        public static byte[] ComputeHash(this byte[] bytes)
        {
            using (var sha256 = SHA256.Create())
            {
                return sha256.ComputeHash(bytes);
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L809-816)
```csharp
    private Address GetBeneficiaryAddress(string candidatePubkey, Address profitsReceiver = null)
    {
        profitsReceiver = profitsReceiver == null ? GetProfitsReceiverOrDefault(candidatePubkey) : profitsReceiver;
        var beneficiaryAddress = profitsReceiver.Value.Any()
            ? profitsReceiver
            : Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(candidatePubkey));
        return beneficiaryAddress;
    }
```
