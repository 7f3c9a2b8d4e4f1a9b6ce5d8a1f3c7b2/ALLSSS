### Title
Case-Sensitive Token Symbol Tracking Causes Duplicate Entries and Profit Distribution DoS

### Summary
The `ReceivedTokenSymbols` field in profit schemes uses case-sensitive string comparison when checking for duplicate symbols, allowing the same underlying token to be tracked multiple times through case variants or aliases. When `IsReleaseAllBalanceEveryTimeByDefault` is enabled, this causes transaction failures during profit distribution as the system attempts to transfer the same token balance multiple times, resulting in insufficient balance errors and denial-of-service.

### Finding Description

The Profit contract maintains a `ReceivedTokenSymbols` list in each scheme to track which token symbols have received contributions. [1](#0-0) 

When profits are contributed, the contract checks if the symbol already exists using a case-sensitive `Contains()` method before adding it to the list. [2](#0-1) 

The same case-sensitive check occurs when distributing profits to sub-schemes. [3](#0-2) 

In C#, the protobuf `RepeatedField<string>.Contains()` method uses ordinal (case-sensitive) string comparison by default. This means "ELF", "eLF", and "elf" are treated as distinct entries even though they may refer to the same underlying token through the alias system.

The MultiToken contract supports token aliases, particularly for NFT items, where a shorter alias can reference the full symbol. [4](#0-3) 

When aliases are resolved during balance queries, they map to the same underlying token. [5](#0-4) 

During profit distribution with `IsReleaseAllBalanceEveryTimeByDefault` enabled, the system iterates through all symbols in `ReceivedTokenSymbols` and queries the balance for each. [6](#0-5) 

If duplicate case variants exist, the system will query the same token balance multiple times, add duplicate entries to `profitsMap`, and then attempt to transfer the same balance repeatedly in `PerformDistributeProfits`. [7](#0-6) 

### Impact Explanation

**Operational Impact - Denial of Service:**
- Profit distribution transactions fail with "Insufficient balance" errors when attempting to transfer the same token balance multiple times
- Schemes with `IsReleaseAllBalanceEveryTimeByDefault = true` become unable to distribute profits automatically
- Affects TokenHolder contract schemes which set this flag to true [8](#0-7) 

**State Corruption:**
- `ReceivedTokenSymbols` lists become polluted with duplicate case-variant entries representing the same token
- Sub-schemes inherit these duplicates through the distribution mechanism, propagating the issue throughout the scheme hierarchy
- Incorrect accounting of which unique tokens have been received

**Severity Justification:**
Medium severity due to denial-of-service impact on critical profit distribution functionality and state corruption, though it requires specific preconditions (token aliases) and doesn't directly result in fund loss.

### Likelihood Explanation

**Reachable Entry Point:**
The vulnerability is triggered through the public `ContributeProfits` method which validates that the caller has sufficient balance but imposes no restrictions on who can contribute. [9](#0-8) 

**Feasible Preconditions:**
- Token aliases must exist in the system (NFT aliases are a legitimate feature designed for user convenience)
- Users must contribute profits using different case variants of the same underlying token (via symbol and alias)
- Schemes must have `IsReleaseAllBalanceEveryTimeByDefault` enabled (common for TokenHolder schemes)

**Execution Practicality:**
The attack requires only standard token contributions with different case variants. Token existence is validated via `AssertTokenExists`, which accepts both symbols and their aliases. [10](#0-9) 

**Detection Constraints:**
The issue may occur accidentally through legitimate usage patterns when users unknowingly use different case variants or aliases of the same token.

**Probability Assessment:**
Medium likelihood - requires NFT aliases to exist but exploitation is straightforward once preconditions are met. The impact is deterministic once duplicate entries are created.

### Recommendation

**Code-Level Mitigation:**

1. Normalize token symbols before the duplicate check by converting to uppercase or using the actual resolved symbol:

```csharp
// In ContributeProfits method (line 716)
var actualSymbol = GetActualTokenSymbol(input.Symbol).ToUpper();
if (!scheme.ReceivedTokenSymbols.Contains(actualSymbol)) 
    scheme.ReceivedTokenSymbols.Add(actualSymbol);

// In DistributeProfitsForSubSchemes (line 641)
var actualSymbol = GetActualTokenSymbol(symbol).ToUpper();
if (!subScheme.ReceivedTokenSymbols.Contains(actualSymbol))
{
    subScheme.ReceivedTokenSymbols.Add(actualSymbol);
    State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
}
```

2. Add a helper method to resolve and normalize token symbols:

```csharp
private string GetNormalizedTokenSymbol(string symbol)
{
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput { Symbol = symbol });
    return tokenInfo?.Symbol?.ToUpper() ?? symbol.ToUpper();
}
```

**Invariant Checks:**
- Ensure `ReceivedTokenSymbols` contains only unique normalized symbols (no case-variant duplicates)
- Validate that balance queries during distribution will not exceed available balances

**Test Cases:**
- Create scheme with NFT token that has an alias
- Contribute profits using base symbol
- Contribute profits using alias with different casing
- Verify `ReceivedTokenSymbols` contains only one normalized entry
- Verify profit distribution succeeds without balance errors
- Test sub-scheme propagation with normalized symbols

### Proof of Concept

**Initial State:**
1. NFT Collection "TEST-0" exists with symbol "TEST-1" (an NFT item)
2. Alias "test" is set for "TEST-1" [11](#0-10) 
3. A profit scheme exists with `IsReleaseAllBalanceEveryTimeByDefault = true`
4. Scheme virtual address holds 1000 tokens of "TEST-1"

**Exploitation Steps:**

1. **First Contribution:**
   - Call `ContributeProfits(schemeId, amount=100, symbol="TEST-1")`
   - `ReceivedTokenSymbols.Contains("TEST-1")` returns false
   - Result: `ReceivedTokenSymbols = ["TEST-1"]`

2. **Second Contribution:**
   - Call `ContributeProfits(schemeId, amount=100, symbol="test")` (using alias)
   - Token validation passes (alias resolves to "TEST-1")
   - `ReceivedTokenSymbols.Contains("test")` returns false (case-sensitive)
   - Result: `ReceivedTokenSymbols = ["TEST-1", "test"]`

3. **Attempt Distribution:**
   - Call `DistributeProfits(schemeId, period=currentPeriod, amountsMap={})`
   - Loop iteration 1: Query balance for "TEST-1" = 1000, transfer 1000 tokens
   - Loop iteration 2: Query balance for "test" = 0 (already transferred), attempt transfer
   - **Result: Transaction fails with insufficient balance error**

**Expected vs Actual:**
- **Expected:** Single entry in `ReceivedTokenSymbols` for the normalized symbol, successful distribution
- **Actual:** Duplicate entries for case variants, profit distribution DoS, scheme becomes non-operational

**Success Condition:**
The vulnerability is confirmed if `ReceivedTokenSymbols` contains multiple case-variant entries for the same underlying token and subsequent profit distribution transactions fail.

### Citations

**File:** protobuf/profit_contract.proto (L159-159)
```text
    repeated string received_token_symbols = 12;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L449-459)
```csharp
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L501-508)
```csharp
    private void AssertTokenExists(string symbol)
    {
        if (string.IsNullOrEmpty(State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput { Symbol = symbol })
                .TokenName))
        {
            throw new AssertionException($"Token {symbol} not exists.");
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L585-603)
```csharp
    private void PerformDistributeProfits(Dictionary<string, long> profitsMap, Scheme scheme, long totalShares,
        Address profitsReceivingVirtualAddress)
    {
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var remainAmount = DistributeProfitsForSubSchemes(symbol, amount, scheme, totalShares);
            Context.LogDebug(() => $"Distributing {remainAmount} {symbol} tokens.");
            // Transfer remain amount to individuals' receiving profits address.
            if (remainAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L641-645)
```csharp
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-721)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }

        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null)
        {
            throw new AssertionException("Scheme not found.");
        }
        // ReSharper disable once PossibleNullReferenceException
        var virtualAddress = scheme.VirtualAddress;

        if (input.Period == 0)
        {

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = virtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount,
                Memo = $"Add {input.Amount} dividends."
            });
        }
        else
        {
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);

            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
        }

        // If someone directly use virtual address to do the contribution, won't sense the token symbol he was using.
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);

        State.SchemeInfos[scheme.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L748-779)
```csharp

        // For now, token alias can only be set once.
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");

        CheckTokenAlias(input.Alias, collectionSymbol);

        var collectionTokenInfo = GetTokenInfo(collectionSymbol);
        if (collectionTokenInfo == null)
        {
            throw new AssertionException($"NFT Collection {collectionSymbol} not found.");
        }

        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");

        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);

        State.SymbolAliasMap[input.Alias] = input.Symbol;

        Context.LogDebug(() => $"Token alias added: {input.Symbol} -> {input.Alias}");

        Context.Fire(new SymbolAliasAdded
        {
            Symbol = input.Symbol,
            Alias = input.Alias
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L286-294)
```csharp
    private string GetActualTokenSymbol(string aliasOrSymbol)
    {
        if (State.TokenInfos[aliasOrSymbol] == null)
        {
            return State.SymbolAliasMap[aliasOrSymbol] ?? aliasOrSymbol;
        }

        return aliasOrSymbol;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L79-79)
```csharp
        var lockedAmount = detail.Shares;
```
