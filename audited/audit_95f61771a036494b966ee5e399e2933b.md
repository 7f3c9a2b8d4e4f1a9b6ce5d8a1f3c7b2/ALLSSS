### Title
NFT Collection Creation Bypass Allows Non-Zero Decimals Through Direct TokenContract Call

### Summary
The NFT contract hardcodes `Decimals = 0` when creating NFT protocols, but this invariant can be bypassed by calling `TokenContract.Create` directly with NFT collection symbols (e.g., "ABC-0") and non-zero decimals. The TokenContract only validates that decimals are within the range [0, 18] for NFT collections, not that they equal zero, allowing attackers to create divisible "NFTs" that violate the fundamental NFT indivisibility invariant.

### Finding Description

The NFT contract's `Create` method properly hardcodes `Decimals = 0` when creating NFT protocols: [1](#0-0) 

However, the `TokenContract.Create` method can be called directly by any user with a valid SEED NFT. The method routes token creation based on symbol pattern through `GetSymbolType`: [2](#0-1) 

The symbol type classification is purely pattern-based - symbols ending with "-0" are classified as `NftCollection`: [3](#0-2) 

For NFT collections, `CreateNFTCollection` simply delegates to `CreateToken`: [4](#0-3) 

The `CreateToken` method validates decimals only through `AssertValidCreateInput`, which permits any value between 0 and `MaxDecimals` (typically 18): [5](#0-4) 

Only SEED tokens have explicit `Decimals == 0` validation: [6](#0-5) 

Regular NFT collections created via direct `TokenContract.Create` calls bypass the NFT contract entirely and inherit no decimals enforcement beyond the [0, 18] range check.

### Impact Explanation

**Protocol Invariant Violation**: NFTs are fundamentally defined as non-fungible, indivisible tokens. Creating NFT collections with `Decimals > 0` breaks this core invariant, allowing fractional NFT amounts (e.g., 0.5 of an NFT with `Decimals = 8` would be represented as 50000000 in smallest units).

**Ecosystem Confusion**: dApps, wallets, and NFT marketplaces that rely on symbol patterns (symbols ending in "-0" for collections, "ABC-1" for items) to identify and handle NFTs will incorrectly treat these divisible tokens as proper NFTs. This creates:
- Incorrect display/accounting in NFT galleries and marketplaces
- Failed assumptions in smart contracts that interact with NFTs expecting indivisible units
- User deception when purchasing what appears to be an NFT but is actually divisible

**Operational Impact**: Once created through `TokenContract.Create`, these malformed NFT collections can be issued and transferred in fractional amounts via standard token operations: [7](#0-6) 

The issue affects the "Token Supply & Fees" critical invariant category, specifically "NFT uniqueness and ownership checks."

### Likelihood Explanation

**Reachable Entry Point**: `TokenContract.Create` is a public method callable by any user who possesses a valid SEED NFT for their desired symbol.

**Feasible Preconditions**: 
- Attacker must obtain a SEED NFT for the target symbol (available through normal SEED NFT acquisition mechanisms)
- No special privileges required beyond standard SEED NFT ownership [8](#0-7) 

**Execution Steps**:
1. Acquire SEED NFT for symbol "ABC"
2. Call `TokenContract.Create` with:
   - `Symbol = "ABC-0"` (NFT collection format)
   - `Decimals = 8` (or any value 1-18)
   - Valid `TotalSupply`, `Issuer`, other parameters
3. System validates SEED NFT and burns it
4. Token created with non-zero decimals
5. Attacker can now issue/transfer fractional amounts

**Economic Rationality**: SEED NFT acquisition costs are reasonable, and the ability to create confusing NFT-like tokens could enable various deceptive schemes in secondary markets.

### Recommendation

**Immediate Fix**: Add explicit decimals validation for NFT collections and NFT items in `CreateNFTCollection` and `CreateNFTInfo`:

```csharp
private Empty CreateNFTCollection(CreateInput input)
{
    Assert(input.Decimals == 0, "NFT collections must have Decimals = 0.");
    return CreateToken(input, SymbolType.NftCollection);
}

private Empty CreateNFTInfo(CreateInput input)
{
    Assert(input.Decimals == 0, "NFT items must have Decimals = 0.");
    // ... existing validation code
}
```

**Test Case**: Add test verifying that direct `TokenContract.Create` calls with NFT collection symbols and non-zero decimals are rejected:

```csharp
[Fact]
public async Task CreateNFTCollection_WithNonZeroDecimals_ShouldFail()
{
    var result = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "TEST-0",
        Decimals = 8, // Should fail
        TokenName = "Test NFT Collection",
        TotalSupply = 10000,
        Issuer = DefaultSender,
        Owner = DefaultSender
    });
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("NFT collections must have Decimals = 0");
}
```

### Proof of Concept

**Initial State**:
- User possesses a valid SEED NFT for symbol "EXPLOIT" (e.g., "SEED-123" with OwnedSymbol="EXPLOIT")
- SEED NFT has not expired

**Attack Sequence**:

1. **Call TokenContract.Create directly** (bypassing NFT contract):
   ```
   TokenContract.Create({
       Symbol: "EXPLOIT-0",
       Decimals: 8,
       TokenName: "Exploit NFT Collection",
       TotalSupply: 10000,
       Issuer: AttackerAddress,
       Owner: AttackerAddress,
       IssueChainId: CurrentChainId
   })
   ```

2. **Validation passes**:
   - `GetSymbolType("EXPLOIT-0")` returns `SymbolType.NftCollection`
   - Routes to `CreateNFTCollection` → `CreateToken`
   - `AssertValidCreateInput` validates `0 <= 8 <= MaxDecimals` ✓
   - SEED NFT "SEED-123" is burned
   - Token created with `Decimals = 8`

3. **Issue fractional amounts**:
   ```
   TokenContract.Issue({
       Symbol: "EXPLOIT-0",
       Amount: 12345678,  // Represents 0.12345678 units
       To: VictimAddress
   })
   ```

4. **Transfer fractional amounts**:
   ```
   TokenContract.Transfer({
       Symbol: "EXPLOIT-0",
       Amount: 50000000,  // Represents 0.5 units
       To: AnotherAddress
   })
   ```

**Expected Result**: NFT collection creation should fail with "NFT collections must have Decimals = 0"

**Actual Result**: NFT collection "EXPLOIT-0" created with `Decimals = 8`, allowing fractional issuance and transfers, violating the NFT indivisibility invariant.

**Success Condition**: Query `TokenContract.GetTokenInfo("EXPLOIT-0")` returns `TokenInfo` with `Decimals = 8` instead of the required `Decimals = 0`.

### Notes

While SEED tokens receive explicit protection through the assertion at line 39 of `TokenContract_NFT_Actions.cs`, this protection does not extend to regular NFT collections or individual NFT items. The vulnerability exploits the assumption that all NFT creation flows through the NFT contract, which enforces `Decimals = 0`, but the TokenContract's public `Create` method provides an alternative path lacking this critical validation.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L23-34)
```csharp
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L48-66)
```csharp
    private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
    {
        AssertValidCreateInput(input, symbolType);
        if (symbolType == SymbolType.Token || symbolType == SymbolType.NftCollection)
        {
            // can not call create on side chain
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L154-178)
```csharp
    public override Empty Issue(IssueInput input)
    {
        Assert(input.To != null, "To address not filled.");
        AssertValidMemo(input.Memo);
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");

        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(input.To, input.Symbol, input.Amount);

        Context.Fire(new Issued
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = input.To,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L10-13)
```csharp
    private Empty CreateNFTCollection(CreateInput input)
    {
        return CreateToken(input, SymbolType.NftCollection);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L37-39)
```csharp
        if (nftCollectionInfo.Symbol == TokenContractConstants.SeedCollectionSymbol)
        {
            Assert(input.Decimals == 0 && input.TotalSupply == 1, "SEED must be unique.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```
