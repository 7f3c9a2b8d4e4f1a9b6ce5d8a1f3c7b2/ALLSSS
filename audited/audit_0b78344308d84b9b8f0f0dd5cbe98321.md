### Title
Parliament Governance Bypass Through Empty Miner List Mathematical Flaw

### Summary
The Parliament contract's threshold validation logic in `IsProposalRejected()`, `IsProposalAbstained()`, `CheckEnoughVoteAndApprovals()`, and `IsVoteThresholdReached()` performs multiplications with `parliamentMembers.Count` that mathematically pass all checks when the count is zero (0 >= 0 = true), allowing any proposal to be released without approval. While not a division by zero error, this mathematical flaw combined with a bug in the Election contract's `GetVictories()` method creates a path where parliament membership can become empty, bypassing all governance controls.

### Finding Description

**Location 1 - Threshold Check Flaw:** [1](#0-0) 

**Location 2 - Similar Flaw in Abstention Check:** [2](#0-1) 

**Location 3 - Approval Check Passes with Zero Members:** [3](#0-2) 

**Location 4 - Vote Threshold Check:** [4](#0-3) 

**Root Cause:**
When `parliamentMembers.Count` equals zero, the comparison operations evaluate as follows:
- `IsProposalRejected`: `0 * 10000 > MaximalRejectionThreshold * 0` → `0 > 0` = **false** (not rejected)
- `IsProposalAbstained`: `0 * 10000 > MaximalAbstentionThreshold * 0` → `0 > 0` = **false** (not abstained)
- `CheckEnoughVoteAndApprovals`: `0 * 10000 >= MinimalApprovalThreshold * 0` → `0 >= 0` = **true** (passes)
- `IsVoteThresholdReached`: `0 * 10000 >= MinimalVoteThreshold * 0` → `0 >= 0` = **true** (passes)

Result: `IsReleaseThresholdReached()` returns true, allowing proposal release.

**Path to Empty Parliament:**
Parliament members are retrieved from consensus: [5](#0-4) 

The consensus contract can return an empty MinerList: [6](#0-5) 

**Critical Bug in Election Victory Selection:**
During term transitions, the Election contract's `GetVictories()` method has a flaw where it uses `currentMiners.Count` instead of `backups.Count`: [7](#0-6) 

At line 72, `Math.Min(diff, currentMiners.Count)` prevents backup miners from being selected when `currentMiners` is empty, even if `InitialMiners` contains valid backups. This can result in an empty victories list, leading to zero miners in the new term.

**No Validation Against Empty List:**
There are no assertions preventing `parliamentMembers.Count` from being zero in any of the threshold calculation functions, and no validation that `GetCurrentMinerList()` returns a non-empty result.

### Impact Explanation

**Governance Bypass:**
- Any proposal to any Parliament organization can be released without legitimate approval when parliament membership is empty
- Includes the default Parliament organization which controls critical system parameters

**Concrete Damages:**
- Unauthorized execution of system configuration changes
- Malicious contract upgrades without approval
- Treasury fund drainage through unauthorized proposals
- Modification of consensus parameters, token economics, or cross-chain settings
- Complete circumvention of the Parliament governance model

**Affected Parties:**
- All Parliament-governed operations and organizations
- System contracts relying on Parliament authorization
- Token holders whose funds depend on Parliament-protected configurations

**Severity:**
Critical - Complete bypass of the primary governance mechanism, enabling unauthorized execution of arbitrary proposals.

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Manipulate election to have no valid candidates with votes (requires significant vote influence or candidate invalidation)
2. Trigger term transition during this state
3. Time proposal release during empty parliament window

**Attack Complexity:**
Medium-High. While the mathematical flaw is deterministic, achieving an empty parliament requires:
- Election manipulation (difficult but possible through vote management or marking candidates as evil)
- Successful term transition with the GetVictories bug (exists in code)
- Operational window where blocks are produced despite empty parliament (challenging but possible during state inconsistencies)

**Feasibility Conditions:**
- The `GetVictories()` bug at line 72 creates a concrete path: when `currentMiners` is empty, `Math.Min(diff, 0)` takes zero backups even if they exist
- No defensive checks prevent empty miner lists from being set
- Consensus state inconsistencies or transition edge cases could trigger the condition

**Detection Constraints:**
- Difficult to monitor for election manipulation preceding term transitions
- No alarms for empty parliament detection
- Proposal execution would appear normal in transaction logs

**Probability Assessment:**
Medium-Low in production but defensively unacceptable. The lack of validation against a mathematically broken state (empty parliament) represents a critical defensive programming failure, even if operational conditions make it difficult to trigger intentionally.

### Recommendation

**Immediate Fix 1 - Add Empty Parliament Guard:**
In `Parliament_Helper.cs`, add validation at the beginning of `IsReleaseThresholdReached()`:
```csharp
private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
{
    var parliamentMembers = GetCurrentMinerList();
    Assert(parliamentMembers.Count > 0, "Parliament has no members.");
    // ... rest of function
}
```

**Immediate Fix 2 - Fix Election GetVictories Bug:**
In `contract/AElf.Contracts.Election/ViewMethods.cs` line 72, change:
```csharp
.Take(Math.Min(diff, backups.Count))  // NOT currentMiners.Count
```

**Additional Validation:**
Add assertion in consensus `SetMinerList()`: [8](#0-7) 

Add check: `Assert(minerList.Pubkeys.Count > 0, "Cannot set empty miner list.");`

**Test Cases:**
1. Unit test: Verify `IsReleaseThresholdReached()` reverts when `GetCurrentMinerList()` returns empty
2. Integration test: Verify term transition rejects empty victories list
3. Fuzz test: Test threshold calculations with parliamentMembers.Count = 0, 1, 2

### Proof of Concept

**Required Initial State:**
1. Blockchain with Parliament contract initialized
2. Election contract with no valid candidates (all invalidated or zero votes)
3. Current parliament with zero or minimal miners
4. Existing proposal in any Parliament organization

**Attack Sequence:**

**Step 1:** Ensure no valid election candidates
- Mark existing candidates as evil nodes OR
- Ensure all candidates have zero active voted votes

**Step 2:** Trigger term transition
- Call `NextTerm()` which invokes `GetVictories()`
- Due to bug at line 72, with empty currentMiners: `Math.Min(diff, 0)` = 0
- Even if InitialMiners has backups, zero are selected
- New term miner list becomes empty

**Step 3:** Verify empty parliament
- Call `GetCurrentMinerList()` → returns empty MinerList
- `parliamentMembers.Count` = 0

**Step 4:** Release malicious proposal
- Call `Release(proposalId)` for any proposal
- `IsReleaseThresholdReached()` is evaluated:
  - `IsProposalRejected()`: 0 > 0 = false
  - `IsProposalAbstained()`: 0 > 0 = false
  - `CheckEnoughVoteAndApprovals()`: 0 >= 0 = **true**
  - `IsVoteThresholdReached()`: 0 >= 0 = **true**
- Returns true, proposal executes

**Expected Result:**
Assertion failure "Not approved."

**Actual Result:**
Proposal executes successfully without any legitimate approval votes, bypassing Parliament governance.

**Success Condition:**
Arbitrary proposal execution with `parliamentMembers.Count` = 0 and zero approval votes recorded.

### Notes

The question originally asked about "division by zero" but the actual vulnerability is a **mathematical bypass through zero multiplication**. No division occurs in the code, but the multiplication-based threshold comparisons mathematically reduce to `0 >= 0` (true) when parliament is empty, bypassing all governance checks. This is exacerbated by the `GetVictories()` bug that can actually create empty miner lists even when backups exist.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L13-20)
```csharp
    private List<Address> GetCurrentMinerList()
    {
        RequireConsensusContractStateSet();
        var miner = State.ConsensusContract.GetCurrentMinerList.Call(new Empty());
        var members = miner.Pubkeys.Select(publicKey =>
            Address.FromPublicKey(publicKey.ToByteArray())).ToList();
        return members;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-70)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L72-78)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(parliamentMembers.Contains);
        return abstentionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L94-102)
```csharp
    private bool IsVoteThresholdReached(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
                .Count(parliamentMembers.Contains) * AbstractVoteTotal >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold * parliamentMembers.Count;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L31-42)
```csharp
    public override MinerList GetCurrentMinerList(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var round)
            ? new MinerList
            {
                Pubkeys =
                {
                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))
                }
            }
            : new MinerList();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```
