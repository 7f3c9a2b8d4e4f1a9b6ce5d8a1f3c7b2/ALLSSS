### Title
Hash Input Collision Vulnerability in NFT Token Hash Calculation

### Summary
The `CalculateTokenHash()` function concatenates symbol and tokenId without a delimiter before hashing, allowing different (symbol, tokenId) pairs to produce identical tokenHash values. While `HashHelper.ComputeFrom` uses the cryptographically secure SHA-256 algorithm, the ambiguous input construction enables cross-protocol NFT collisions, leading to denial of service during minting and potential state corruption when `IsTokenIdReuse` is enabled.

### Finding Description

**Hash Algorithm Security**: `HashHelper.ComputeFrom` uses SHA-256, which is cryptographically secure and resistant to collision attacks. [1](#0-0) 

**Root Cause**: The vulnerability lies in the `CalculateTokenHash` implementation, which creates hash inputs by directly concatenating symbol and tokenId strings without any delimiter: [2](#0-1) 

**Collision Mechanism**: NFT protocol symbols follow the format `{2-char-prefix}{9+-digit-number}` (e.g., "AR123456789"). [3](#0-2) [4](#0-3) 

Without a delimiter, different (symbol, tokenId) pairs can produce identical concatenated strings:
- Protocol A: symbol="AR123456789", tokenId=12 → input="AR12345678912"
- Protocol B: symbol="AR1234567891", tokenId=2 → input="AR12345678912"

Both produce the same tokenHash, causing them to share the same state mappings (NftInfoMap, BalanceMap, AllowanceMap).

**Failed Protections**: The uniqueness check in `PerformMint` only prevents collisions when `IsTokenIdReuse=false`: [5](#0-4) 

However, this check operates on tokenHash level and cannot distinguish between:
1. Same tokenId within same protocol (intended to block)
2. Colliding tokenHash from different protocols (unintended, also blocks)

When `IsTokenIdReuse=true`, the check is bypassed entirely, and the code updates existing nftInfo regardless of protocol origin: [6](#0-5) 

### Impact Explanation

**Scenario 1 - Denial of Service** (IsTokenIdReuse=false):
When a collision occurs, the second protocol's mint attempt fails with "Token id already exists" error, even though it's a different protocol. This permanently blocks that (symbol, tokenId) combination from being minted in the second protocol, causing operational disruption.

**Scenario 2 - Cross-Protocol State Corruption** (IsTokenIdReuse=true):
- The attacker's mint updates the victim's NFT info, adding their address to the minters list
- Balance mappings are shared: `State.BalanceMap[tokenHash]` becomes corrupted across protocols
- NFT quantity counts are incorrectly aggregated across different protocols
- Allowances become confused between unrelated NFTs
- This violates the "NFT uniqueness and ownership checks" critical invariant

**Affected Parties**: All NFT protocols and their users, particularly those with `IsTokenIdReuse=true` enabled.

### Likelihood Explanation

**Attacker Capabilities**: Any user who can call the `Create` method to create NFT protocols. [7](#0-6) 

**Attack Complexity**: 
- Moderate: Random number generation is pseudorandom but deterministic based on block height and sender
- Attacker can create multiple protocols to increase collision probability
- Symbol space: 10 NFT types × 10^9+ random numbers = large but finite
- As more protocols are created, collision probability increases naturally

**Feasibility**: Symbol generation uses consensus-derived randomness [8](#0-7) , but attackers can:
1. Monitor existing NFTs and their (symbol, tokenId) combinations
2. Create protocols until obtaining a favorable symbol (costs resources but feasible)
3. Mint NFTs with carefully chosen tokenIds to force collisions

**Economic Rationality**: Cost includes protocol creation fees. Benefit includes DoS attacks on competitors or state manipulation when IsTokenIdReuse=true.

### Recommendation

**Code-Level Mitigation**: Modify `CalculateTokenHash` to include an unambiguous delimiter:
```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}-{tokenId}");
}
```

Alternatively, use structured hashing:
```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    var symbolHash = HashHelper.ComputeFrom(symbol);
    var tokenIdHash = HashHelper.ComputeFrom(tokenId);
    return HashHelper.ConcatAndCompute(symbolHash, tokenIdHash);
}
```

**Invariant Check**: Add validation during minting to verify the nftInfo symbol matches the input symbol when nftInfo already exists.

**Test Cases**: Add collision tests verifying that different (symbol, tokenId) pairs produce different tokenHash values, and test cross-protocol minting scenarios.

### Proof of Concept

**Initial State**:
- Victim creates Protocol A with symbol "AR123456789" (via random generation)
- Victim mints NFT with tokenId=12, owner=VictimAddress, quantity=100
- tokenHash = hash("AR12345678912")
- State.NftInfoMap[tokenHash] = {Symbol:"AR123456789", TokenId:12, Quantity:100}
- State.BalanceMap[tokenHash][VictimAddress] = 100

**Attack Steps** (assuming IsTokenIdReuse=true for simplicity):
1. Attacker creates Protocol B, attempting to get symbol "AR1234567891"
2. If unsuccessful, repeat protocol creation (costs resources but feasible)
3. Once obtained, attacker mints NFT with tokenId=2, quantity=50
4. tokenHash = hash("AR12345678912") - SAME as victim's!

**Expected vs Actual**:
- Expected: New separate NFT info created for Protocol B
- Actual: Victim's NFT info is updated:
  - Quantity becomes 150 (100+50)
  - Attacker added to minters list
  - State.BalanceMap[tokenHash][AttackerAddress] = 50 (shares mapping with victim)
  - Cross-protocol state corruption achieved

**Success Condition**: Attacker successfully corrupts victim's NFT state or blocks legitimate minting operations through hash collision.

### Notes

While SHA-256 itself is cryptographically secure and collision-resistant, this vulnerability arises from ambiguous input encoding prior to hashing. The lack of delimiter between symbol and tokenId creates semantically different data structures that encode to identical byte sequences, bypassing the security guarantees of the underlying hash algorithm.

### Citations

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L64-70)
```csharp
        public static byte[] ComputeHash(this byte[] bytes)
        {
            using (var sha256 = SHA256.Create())
            {
                return sha256.ComputeHash(bytes);
            }
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L433-441)
```csharp
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }

        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-34)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);
```
