### Title
Insufficient Validation in SetMinerIncreaseInterval Allows Negative Values Leading to Complete Consensus Halt

### Summary
The `SetMinerIncreaseInterval()` function lacks proper validation to prevent negative or unreasonably small values. An attacker with governance authority can set `MinerIncreaseInterval` to a negative value (e.g., -1), causing `GetAutoIncreasedMinersCount()` to compute a large negative miner count. This negative value propagates through the consensus system, resulting in zero miners being selected for new rounds and permanently halting the blockchain.

### Finding Description

**Root Cause:** The validation in `SetMinerIncreaseInterval()` only checks that the new value is less than or equal to the current value, without enforcing a positive lower bound. [1](#0-0) 

The assertion at line 61 only validates `input.Value <= State.MinerIncreaseInterval.Value`, allowing negative values to be set since the check passes for any value below the current setting (default: 31,536,000 seconds).

**Vulnerable Calculation:** When `GetAutoIncreasedMinersCount()` executes with a negative `MinerIncreaseInterval`: [2](#0-1) 

The calculation at lines 92-94 performs: `SupposedMinersCount (17) + (int)((blockchainAge / MinerIncreaseInterval) * 2)`. With `MinerIncreaseInterval = -1` and any positive blockchain age, this produces a large negative result (e.g., if blockchain is 100,000 seconds old: 17 + (100,000 / -1 * 2) = 17 + (-200,000) = -199,983).

**Propagation Through System:** This negative miner count is returned by both `GetMaximumMinersCount()` and `GetMinersCount()` since `Math.Min(negativeValue, int.MaxValue)` returns the negative value. [3](#0-2) 

The negative count is sent to the Election contract without validation: [4](#0-3) 

**Consensus Breakdown:** When `GetVictories()` attempts to select miners using the stored negative count: [5](#0-4) 

The LINQ `.Take(State.MinersCount.Value)` operation with a negative argument returns an empty sequence. This empty miner list is then used to generate the next consensus round: [6](#0-5) 

With zero miners in the list (`sortedMiners.Count = 0`), the for loop never executes, creating a round with no miners. Consensus completely halts as no miners can produce blocks.

### Impact Explanation

**Consensus Destruction:** The entire blockchain permanently halts with zero active miners. No blocks can be produced, making the network completely non-functional.

**Governance Paralysis:** Even if governance attempts recovery, consensus is required to execute governance proposals. The system enters an unrecoverable state unless emergency intervention at the node level is possible.

**Network-Wide DOS:** All users, validators, and applications depending on the blockchain are affected. Token transfers, contract calls, and all blockchain operations cease immediately after the malicious miner count takes effect (typically at the next term transition).

**Severity Justification:** This is a CRITICAL severity issue as it achieves complete and potentially permanent network shutdown, affecting all participants with no built-in recovery mechanism.

### Likelihood Explanation

**Attacker Requirements:** The attacker must control the `MaximumMinersCountController` authority, which defaults to the Parliament contract's default organization. This requires either:
1. Compromising governance through a malicious proposal that passes Parliament approval
2. Social engineering Parliament members to approve what appears to be a routine configuration change
3. Exploiting a separate governance vulnerability

**Attack Complexity:** Once governance authority is obtained, the attack is trivial:
- Single function call: `SetMinerIncreaseInterval(-1)`
- No complex transaction sequencing required
- Immediate effect on next miner count calculation

**Feasibility:** The validation weakness is non-obvious. A malicious proposal to "adjust miner growth rate" could pass review if presented as optimization. The lack of lower bound checking would not be immediately apparent to governance reviewers unfamiliar with the implementation details.

**Detection:** The negative value would be stored on-chain but might not trigger immediate alerts. The actual failure occurs at the next term transition when `GetAutoIncreasedMinersCount()` is called, potentially hours or days after the malicious parameter is set.

**Economic Rationality:** For a motivated attacker (competitor blockchain, nation-state, disgruntled stakeholder), the cost of influencing governance could be justified by the total network disruption achieved.

### Recommendation

**Immediate Fix:** Add comprehensive validation to `SetMinerIncreaseInterval()`:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Miner increase interval must be positive.");
    Assert(input.Value >= MinimumAllowedMinerIncreaseInterval, 
        "Miner increase interval below minimum threshold.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

Where `MinimumAllowedMinerIncreaseInterval` should be a constant (e.g., 86,400 seconds = 1 day) to prevent both negative values and unreasonably small intervals.

**Additional Safeguards:**
1. Add overflow protection in `GetAutoIncreasedMinersCount()` by checking if the calculation would exceed `int.MaxValue` before casting
2. Add validation in `UpdateMinersCount()` in the Election contract to reject non-positive miner counts
3. Cap the auto-increased value with a reasonable maximum before applying `Math.Min` with `MaximumMinersCount`

**Test Cases:**
1. Attempt to set `MinerIncreaseInterval` to -1, 0, and values below minimum threshold (should all fail)
2. Verify that with blockchain age approaching integer overflow boundaries, `GetAutoIncreasedMinersCount()` doesn't produce invalid results
3. Test that `UpdateMinersCount()` rejects negative values
4. Regression test ensuring existing valid interval adjustments still work

### Proof of Concept

**Initial State:**
- Blockchain is initialized with default `MinerIncreaseInterval = 31,536,000` seconds
- Blockchain has been running for at least 100,000 seconds
- Attacker has obtained Parliament governance authority

**Attack Sequence:**

1. **Attacker creates governance proposal:**
   - Target: `AEDPoSContract.SetMinerIncreaseInterval`
   - Parameter: `Int64Value { Value = -1 }`
   - Justification (social engineering): "Optimize miner growth calculation for better performance"

2. **Proposal passes Parliament approval** (assumed compromised or deceived governance)

3. **SetMinerIncreaseInterval executes:**
   - Validation at line 61 passes: `-1 <= 31,536,000` âœ“
   - `State.MinerIncreaseInterval.Value = -1`

4. **Next term transition occurs:**
   - `GenerateFirstRoundOfNextTerm()` calls `TryToGetVictories()`
   - Election contract's `GetVictories()` calls `State.MinersCount.Value`
   - AEDPoS contract had previously called `UpdateMinersCount()` with value from `GetMinersCount()`
   - `GetMinersCount()` computes via `GetAutoIncreasedMinersCount()`:
     - Calculation: `17 + (int)((100,000 / -1) * 2) = 17 + (-200,000) = -199,983`
   - `Math.Min(-199,983, int.MaxValue) = -199,983`
   - Stored as `MinersCount.Value = -199,983`

5. **GetVictories() executes:**
   - `.Take(-199,983)` returns empty list
   - `victories = []` (zero miners)

6. **Consensus halts:**
   - `GenerateFirstRoundOfNewTerm(minerList)` receives empty list
   - For loop at line 23 of MinerList.cs executes 0 times
   - Round created with zero miners
   - No miner can produce blocks
   - **Blockchain permanently halted**

**Expected Result:** Transaction should fail with "Miner increase interval must be positive."

**Actual Result:** Transaction succeeds, negative interval is stored, and consensus fails at next term transition with zero miners.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L72-78)
```csharp
    public override Int32Value GetMaximumMinersCount(Empty input)
    {
        return new Int32Value
        {
            Value = Math.Min(GetAutoIncreasedMinersCount(), State.MaximumMinersCount.Value)
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-83)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L23-38)
```csharp
        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }
```
