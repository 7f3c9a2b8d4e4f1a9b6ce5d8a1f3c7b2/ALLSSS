### Title
Missing Validation of DecryptedPieces Content Allows Corruption of Secret Sharing Reconstruction

### Summary
The `RevealSharedInValues` function only validates the count of `DecryptedPieces` but not their content, allowing malicious miners to provide empty byte arrays that pass count validation. When these empty pieces are used in Shamir's Secret Sharing reconstruction via `SecretSharingHelper.DecodeSecret`, they become `BigInteger(0)` values, corrupting the Lagrange interpolation and producing incorrect `PreviousInValue` hashes that break consensus randomness accountability.

### Finding Description

**Root Cause:** The validation in `RevealSharedInValues` only checks the count of decrypted pieces but not whether individual byte arrays are non-empty. [1](#0-0) 

This count-only check is insufficient because when miners submit `UpdateValueInput`, the `PerformSecretSharing` method blindly accepts any byte array values and adds them to other miners' `DecryptedPieces` collections without validation: [2](#0-1) 

**Why Existing Protections Fail:** The `UpdateValueValidationProvider` does not validate `DecryptedPieces` content at all: [3](#0-2) 

**Execution Path:** When `SecretSharingHelper.DecodeSecret` processes the pieces, empty byte arrays are converted to `BigInteger(0)`: [4](#0-3) 

In the Lagrange interpolation at line 50, `new BigInteger(sharedParts[i])` with an empty byte array produces zero. Since multiplication by zero yields zero, these corrupted shares contribute nothing to the reconstruction, producing an incorrect secret that gets set as `PreviousInValue`: [5](#0-4) 

### Impact Explanation

**Consensus Integrity Breach:** The corrupted `PreviousInValue` breaks the InValueâ†’OutValue verification chain that is central to AEDPoS randomness. The `CalculateSignature` method XORs `PreviousInValue` with all miners' signatures to generate consensus randomness: [6](#0-5) 

Incorrect `PreviousInValue` values corrupt this calculation, undermining the VRF (Verifiable Random Function) properties of the consensus mechanism.

**Accountability Failure:** Secret sharing serves as a fallback mechanism to reveal miners' `InValues` when they fail to self-disclose. With corrupted reconstruction, miners who don't reveal their true `InValues` escape accountability, as the fallback produces wrong values. This breaks the cryptographic commitment scheme where `OutValue = Hash(InValue)` must be verifiable.

**Who Is Affected:** All honest miners whose `InValues` are reconstructed via secret sharing when they don't self-reveal, and the overall consensus randomness quality affecting all network participants.

**Severity: Medium** - Requires coordination of malicious miners (realistic under Byzantine assumptions) but doesn't directly steal funds. However, it fundamentally breaks a critical consensus security property.

### Likelihood Explanation

**Attacker Capabilities:** Any miner participating in consensus can submit `UpdateValueInput` with arbitrary `DecryptedPieces` content. Multiple miners can collude to amplify the attack.

**Attack Complexity:** Low - simply provide `DecryptedPieces` with correct count but empty `ByteString` values. No complex cryptographic manipulation required.

**Feasibility:** The threshold for Shamir's Secret Sharing is `minimumCount = (2 * minersCount) / 3`: [7](#0-6) 

If colluding miners provide empty pieces, the reconstruction uses corrupted shares. Even if enough pieces exist by count, wrong values corrupt the mathematical reconstruction. The attack is practical when miners coordinate to inject empty bytes.

**Detection:** Difficult to detect as the count validation passes, and the system is designed to be "permissive" about missing `InValues`: [8](#0-7) 

This permissiveness masks the corruption until randomness manipulation or accountability failures manifest.

### Recommendation

**Immediate Fix:** Add validation in `PerformSecretSharing` to reject empty byte arrays:

```csharp
foreach (var decryptedPreviousInValue in input.DecryptedPieces)
{
    Assert(decryptedPreviousInValue.Value != null && 
           decryptedPreviousInValue.Value.Length > 0, 
           "DecryptedPieces values must not be empty.");
    round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
        .Add(publicKey, decryptedPreviousInValue.Value);
}
```

**Additional Protection:** Add content validation in `RevealSharedInValues` before reconstruction:

```csharp
var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
    .Select(s => s.ToByteArray()).ToList();

// Validate no empty pieces before reconstruction
foreach (var part in sharedParts.Take(minimumCount))
{
    if (part == null || part.Length == 0)
    {
        Context.LogDebug(() => $"Skipping reconstruction for {publicKeyOfAnotherMiner} due to invalid pieces.");
        continue; // Skip this miner's reconstruction
    }
}
```

**Test Cases:**
1. Submit `UpdateValueInput` with `DecryptedPieces.Count == minersCount` but all values empty - should reject
2. Submit with mix of valid and empty pieces - should reject any empty
3. Verify secret reconstruction only proceeds with all non-empty pieces
4. Test that validation error messages are clear for debugging

### Proof of Concept

**Initial State:**
- Network with N=10 miners
- Secret sharing enabled
- Miners in round R with valid `EncryptedPieces` submitted

**Attack Steps:**

1. **Malicious Miner A prepares attack in Round R:**
   - Generates valid `OutValue` and `Signature`
   - Creates `DecryptedPieces` map with 10 entries (minersCount)
   - Sets all or several values to `ByteString.Empty` (empty byte array)
   - Example: `DecryptedPieces = {MinerB: empty, MinerC: empty, MinerD: empty, ...}`

2. **Miner A submits UpdateValue transaction:**
   - `UpdateValueInput` passes `UpdateValueValidationProvider` (no DecryptedPieces validation)
   - `PerformSecretSharing` accepts empty bytes without validation
   - Empty pieces added to other miners' `DecryptedPieces` collections

3. **In Round R+1, Extra Block Producer triggers NextRound:**
   - `GetConsensusExtraDataForNextRound` calls `RevealSharedInValues`
   - For each miner (e.g., MinerB) in previous round:
     - Count check passes: `MinerB.DecryptedPieces.Count = 10 >= minersCount`
     - Extracts pieces including Miner A's empty bytes
     - Calls `SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount=7)`
     - Empty byte arrays become `BigInteger(0)` in Lagrange interpolation
     - Result: incorrect hash computed and set as `MinerB.PreviousInValue`

4. **Subsequent rounds use corrupted PreviousInValue:**
   - `CalculateSignature` uses wrong `PreviousInValue`, corrupting randomness
   - Miners who didn't self-reveal have incorrect fallback values
   - Accountability mechanism broken

**Expected Result:** Transaction rejected with "DecryptedPieces values must not be empty"

**Actual Result:** Empty pieces accepted, secret reconstruction corrupted, incorrect `PreviousInValue` set, consensus randomness compromised

**Success Condition:** Monitor state after Round R+1 - if `RevealedInValues` contain incorrect hashes that don't match `Hash(originalInValue)`, attack succeeded.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
