# Audit Report

## Title
Secret Sharing Validation Bypass Allows Mining Order Manipulation in AEDPoS Consensus

## Summary
The AEDPoS consensus contract fails to validate that reconstructed InValues from secret sharing match previously published OutValues. A malicious miner can publish OutValue = Hash(InValue_A) while providing encrypted pieces of InValue_B, where InValue_B ≠ InValue_A. This allows manipulation of signature calculations used for mining order determination, undermining the consensus protocol's randomness guarantees.

## Finding Description

The vulnerability exists in the secret sharing revelation mechanism where InValues are reconstructed from encrypted/decrypted pieces without cryptographic validation.

**Root Cause - Missing Validation in RevealSharedInValues:**

When `RevealSharedInValues` is invoked during round transitions, it reconstructs InValues from decrypted secret sharing pieces and directly assigns them to miners' `PreviousInValue` fields without any validation. [1](#0-0) 

The reconstructed InValue is computed via `SecretSharingHelper.DecodeSecret()` and immediately assigned. There is no check verifying that `Hash(reconstructed_InValue) == published_OutValue` from the previous round.

**Why Existing Protections Fail:**

The `UpdateValueValidationProvider` only validates PreviousInValues that miners explicitly provide in their UpdateValue transactions: [2](#0-1) 

This validation has early returns for null/empty values and critically, it only validates values in the transaction context (`extraData.Round`), not values set by the `RevealSharedInValues` mechanism during round transitions.

**Attack Execution Path:**

1. **Malicious UpdateValue Submission:** During `ProcessUpdateValue`, encrypted pieces are added without validation: [3](#0-2) 

The attacker submits `OutValue = Hash(InValue_A)` but provides `EncryptedPieces(InValue_B)` where InValue_B ≠ InValue_A.

2. **NextRound Revelation:** When `NextRound` is called, `RevealSharedInValues` is invoked: [4](#0-3) 

This reconstructs the fraudulent InValue_B and sets it as PreviousInValue without validation.

3. **Signature Calculation Impact:** The revealed PreviousInValue is used for signature calculation when filling missing miner information: [5](#0-4) 

The fraudulent InValue_B is used to calculate signatures instead of the legitimate InValue_A.

4. **Mining Order Determination:** These signatures directly affect mining order calculations: [6](#0-5) 

The `SupposedOrderOfNextRound` is computed from the signature, giving the attacker control over their mining position. [7](#0-6) 

Signatures also determine extra block producer selection.

## Impact Explanation

**Severity: HIGH - Consensus Integrity Violation**

This vulnerability directly compromises the consensus protocol's core security guarantees:

1. **Mining Order Manipulation:** Attackers can influence their `SupposedOrderOfNextRound` by controlling the InValue used in signature calculations, potentially securing earlier time slots or favorable positions in the mining schedule.

2. **Randomness Degradation:** The AEDPoS protocol relies on the unpredictability of XOR-combined signatures for randomness. If miners can inject arbitrary InValues through fraudulent secret sharing, this randomness becomes manipulable.

3. **Extra Block Producer Control:** The extra block producer selection algorithm uses signature values. Fraudulent InValues can influence which miner becomes the extra block producer, providing strategic advantages.

4. **Protocol Trust Breakdown:** If multiple miners exploit this, the fundamental assumption that InValues are bound to their OutValues through hash commitment breaks down, degrading the entire consensus mechanism.

While this doesn't immediately enable fund theft, it violates critical consensus invariants that ensure fair block production and network security.

## Likelihood Explanation

**Probability: HIGH**

**Attacker Prerequisites:**
- Must be an active miner in the consensus round (normal operational requirement)
- Ability to call `UpdateValue` (standard miner capability)
- No special permissions or administrative access required

**Attack Complexity: LOW**
1. Generate legitimate InValue_A and compute OutValue = Hash(InValue_A)
2. Create a different InValue_B
3. Use secret sharing to generate encrypted pieces of InValue_B
4. Submit UpdateValue with OutValue but encrypted pieces of InValue_B
5. Wait for round transition when pieces are revealed without validation

**Feasibility Conditions:**
- Works whenever secret sharing is enabled: [8](#0-7) 

**Detection Difficulty: HARD**
The encrypted pieces are cryptographically valid and properly formatted. Only the semantic relationship between the revealed InValue and the published OutValue is incorrect, which cannot be detected by on-chain validation and requires off-chain monitoring of both values.

## Recommendation

Add validation in `RevealSharedInValues` to verify that reconstructed InValues match their published OutValues:

```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    // ... existing code ...
    
    foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
    {
        // ... existing validation code ...
        
        var revealedInValue =
            HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
        
        // ADD VALIDATION: Verify revealed InValue matches published OutValue
        var publishedOutValue = anotherMinerInPreviousRound.OutValue;
        if (publishedOutValue != null && publishedOutValue != Hash.Empty)
        {
            if (HashHelper.ComputeFrom(revealedInValue) != publishedOutValue)
            {
                Context.LogDebug(() => 
                    $"Revealed InValue does not match OutValue for {publicKeyOfAnotherMiner}");
                continue; // Skip setting invalid revealed InValue
            }
        }
        
        currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
    }
}
```

Additionally, validate `miners_previous_in_values` in `PerformSecretSharing` against OutValues from the previous round.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a test consensus round with secret sharing enabled
2. Having a malicious miner call `UpdateValue` with:
   - `out_value = Hash(InValue_A)` 
   - `encrypted_pieces = Encrypt(InValue_B)` where `InValue_B ≠ InValue_A`
3. Advancing to the next round and calling `NextRound`
4. Observing that `RevealSharedInValues` sets `PreviousInValue = InValue_B` without validation
5. Verifying that `Hash(InValue_B) ≠ out_value`, proving the invariant violation
6. Demonstrating that this affects signature calculation in `SupplyCurrentRoundInformation`

The core issue is the missing validation at the revelation point, allowing arbitrary InValues to be injected into consensus state despite not matching their cryptographic commitments (OutValues).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L186-199)
```csharp
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```
