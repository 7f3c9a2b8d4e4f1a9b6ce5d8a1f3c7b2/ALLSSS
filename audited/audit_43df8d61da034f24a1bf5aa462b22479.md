### Title
Vote Record Overwrite Enables Double-Counting in Delegated Voting

### Summary
In delegated voting scenarios (IsLockToken=false), the Vote contract allows sponsors to call Vote() multiple times with the same VoteId but different voters. Each call overwrites the previous voting record while still incrementing the vote totals, causing permanent inflation of vote counts that persists even after withdrawal.

### Finding Description

The vulnerability exists in the `Vote()` function where voting records are unconditionally overwritten without checking for existing records or adjusting previous vote counts. [1](#0-0) 

When `IsLockToken=false` (delegated voting), the sponsor explicitly provides both the `Voter` and `VoteId` parameters, which are accepted without uniqueness validation: [2](#0-1) 

Each call to Vote() triggers `UpdateVotingResult()` which unconditionally adds to the vote tallies without checking if the VoteId already exists: [3](#0-2) 

The root cause is that line 177-179 always increment the vote counts (Results[option], VotersCount, VotesAmount) regardless of whether this is a new vote or an overwrite of an existing vote with the same VoteId.

The `UpdateVotedItems()` function adds the VoteId to each voter's ActiveVotes list without preventing duplicates across different voters: [4](#0-3) 

For regular voting (IsLockToken=true), VoteIds are auto-generated using the transaction's unique OriginTransactionId, preventing collisions: [5](#0-4) 

However, this protection does not apply to delegated voting where VoteIds are sponsor-provided.

### Impact Explanation

**Vote Integrity Compromise**: A malicious sponsor can artificially inflate vote totals by reusing VoteIds with different voters. Each reuse adds to the vote count while only keeping the last record, creating phantom votes.

**Permanent State Corruption**: When the duplicate VoteId is withdrawn, only the last voter's amount is subtracted from results, leaving the previously counted votes permanently inflated: [6](#0-5) 

**Orphaned Vote Tracking**: Previous voters retain the VoteId in their ActiveVotes list but cannot withdraw it since the record shows a different voter, creating irrecoverable inconsistencies.

**Governance Impact**: The Election contract uses delegated voting for candidate elections, meaning inflated vote counts could manipulate validator selection and reward distribution: [7](#0-6) 

This directly affects consensus security and economic incentives across the entire chain.

### Likelihood Explanation

**Attack Feasibility**: The exploit requires only that a sponsor create a delegated voting item and call the public `Vote()` method multiple times with the same VoteId. No special permissions beyond being a sponsor are needed.

**Attacker Profile**: Any user can create a delegated voting item by calling `Register()` with `IsLockToken=false`. The sponsor is the only one who can vote in this mode: [2](#0-1) 

**Detection Difficulty**: The attack leaves no obvious traces since the VotingRecords map only shows the final state. Off-chain monitoring would need to track all Vote() transactions and compare against final records to detect discrepancies.

**Economic Constraints**: Delegated voting scenarios are intended for trusted sponsors (like the Election contract), but there's no enforcement preventing malicious actors from creating their own delegated voting items and exploiting this vulnerability.

**Real-World Context**: The Election contract itself implements protections (checking for duplicate VoteIds), but custom voting items created by other contracts or users would be vulnerable.

### Recommendation

**Immediate Fix**: Add a check in the `Vote()` function to prevent reusing VoteIds:

```csharp
public override Empty Vote(VoteInput input)
{
    var votingItem = AssertValidVoteInput(input);
    
    // Add this check before line 93
    var existingRecord = State.VotingRecords[input.VoteId];
    Assert(existingRecord == null || existingRecord.IsWithdrawn, 
           "VoteId already in use. Cannot overwrite active vote.");
    
    // ... rest of function
}
```

**Alternative for Vote Changes**: If vote changes are intended (as suggested by the `IsChangeTarget` field), implement proper vote update logic:

1. When overwriting an existing non-withdrawn vote, subtract the old amount from results before adding the new amount
2. Update the voter tracking to move VoteId from old voter to new voter
3. Document this behavior clearly

**Invariant Checks**: Add assertions in `UpdateVotingResult()` to ensure vote counts never decrease unexpectedly and match the actual records.

**Test Cases**: 
- Test that voting twice with the same VoteId in delegated mode fails
- Test that withdrawn VoteIds can be reused (if intended)
- Verify vote count consistency after withdrawals

### Proof of Concept

**Initial Setup**:
- Sponsor creates delegated voting item: `Register({IsLockToken: false, ...})`
- Initial state: `VotingResult = {Option["A"]: 0, VotesAmount: 0, VotersCount: 0}`

**Exploit Sequence**:

1. Sponsor calls `Vote({VoteId: H, Voter: Alice, Amount: 100, Option: "A"})`
   - Record created: `VotingRecords[H] = {Voter: Alice, Amount: 100}`
   - Results updated: `{Option["A"]: 100, VotesAmount: 100, VotersCount: 1}`
   - Alice.ActiveVotes: `[H]`

2. Sponsor calls `Vote({VoteId: H, Voter: Bob, Amount: 200, Option: "A"})`
   - Record overwritten: `VotingRecords[H] = {Voter: Bob, Amount: 200}`
   - Results updated: `{Option["A"]: 300, VotesAmount: 300, VotersCount: 2}`
   - Bob.ActiveVotes: `[H]`
   - Alice.ActiveVotes: `[H]` (orphaned)

3. Sponsor calls `Withdraw({VoteId: H})`
   - Record shows Bob with 200, so 200 is subtracted
   - Final results: `{Option["A"]: 100, VotesAmount: 100, VotersCount: 1}`

**Expected Result**: After withdrawal, vote counts should be zero.

**Actual Result**: 100 phantom votes remain, attributed to no valid record. Alice's ActiveVotes still contains H but she cannot withdraw it.

**Success Condition**: Query `GetVotingResult()` shows inflated counts that don't match the actual voting records, and Alice has an orphaned VoteId that cannot be withdrawn.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L146-161)
```csharp
    private void UpdateVotedItems(Hash voteId, Address voter, VotingItem votingItem)
    {
        var votedItems = State.VotedItemsMap[voter] ?? new VotedItems();
        var voterItemIndex = votingItem.VotingItemId.ToHex();
        if (votedItems.VotedItemVoteIds.ContainsKey(voterItemIndex))
            votedItems.VotedItemVoteIds[voterItemIndex].ActiveVotes.Add(voteId);
        else
            votedItems.VotedItemVoteIds[voterItemIndex] =
                new VotedIds
                {
                    ActiveVotes = { voteId }
                };

        votedItems.VotedItemVoteIds[voterItemIndex].WithdrawnVotes.Remove(voteId);
        State.VotedItemsMap[voter] = votedItems;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L214-222)
```csharp
        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L139-146)
```csharp
    public Hash GenerateId(Address contractAddress, IEnumerable<byte> bytes)
    {
        var contactedBytes = OriginTransactionId.Value.Concat(contractAddress.Value);
        var enumerable = bytes as byte[] ?? bytes?.ToArray();
        if (enumerable != null)
            contactedBytes = contactedBytes.Concat(enumerable);
        return HashHelper.ComputeFrom(contactedBytes.ToArray());
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L60-68)
```csharp
        var votingRegisterInput = new VotingRegisterInput
        {
            IsLockToken = false,
            AcceptedCurrency = Context.Variables.NativeSymbol,
            TotalSnapshotNumber = long.MaxValue,
            StartTimestamp = TimestampHelper.MinValue,
            EndTimestamp = TimestampHelper.MaxValue
        };
        State.VoteContract.Register.Send(votingRegisterInput);
```
