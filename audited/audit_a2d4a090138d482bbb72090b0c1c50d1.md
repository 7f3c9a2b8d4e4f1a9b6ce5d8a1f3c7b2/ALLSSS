### Title
State Bloat via Uncleaned Expired Referendum Proposals

### Summary
The Referendum contract lacks automatic cleanup of expired proposals, relying instead on manual intervention through `ClearProposal()`. Whitelisted attackers can create numerous proposals that never reach voting thresholds, causing permanent state bloat as there is no incentive mechanism for users to clear expired proposals. Each proposal stores significant data (up to 10,455+ characters), leading to unbounded state growth and increased operational costs for node operators.

### Finding Description

Proposals in the Referendum contract are only removed through two methods: `Release()` when the voting threshold is reached, or `ClearProposal()` for expired proposals. [1](#0-0) [2](#0-1) 

The `ClearProposal()` method allows anyone to remove expired proposals, but this requires explicit manual invocation per proposal. There is no automatic cleanup mechanism, and critically, no incentive for users to spend gas clearing other users' expired proposals.

Proposal creation is gated only by the proposer whitelist check, with no rate limiting or deposit requirement beyond standard transaction fees: [3](#0-2) [4](#0-3) 

Each proposal stores substantial data including title (255 char max), description (10,200 char max), and URL (255 char max): [5](#0-4) 

Proposals are stored in the state mapping and remain there indefinitely unless explicitly removed: [6](#0-5) 

**Root Cause**: The contract assumes altruistic actors will manually clear expired proposals, but provides no economic incentive to do so. While `ClearProposal()` is permissionless, calling it costs transaction fees with no compensation, making it economically irrational for users to clear proposals they didn't create.

### Impact Explanation

**Operational Impact - State Bloat**: A malicious whitelisted proposer can create an unlimited number of proposals (constrained only by transaction fees and block gas limits). Each proposal that never reaches voting thresholds will expire but remain in contract state permanently unless manually cleared. With proposals storing up to 10,710 characters of data plus additional fields (addresses, timestamps, counters), this leads to:

1. **Unbounded State Growth**: 1,000 maximum-size proposals would store over 10 MB of data on-chain
2. **Increased Node Costs**: Node operators must store and index this bloated state indefinitely
3. **Performance Degradation**: Larger state sizes impact node synchronization and query performance
4. **Economic Burden**: Blockchain state storage costs are borne by all node operators, not the attacker

This affects the entire network's operational efficiency and imposes ongoing costs on all participants. The vulnerability is particularly concerning because the cleanup mechanism exists but is impractical at scale.

### Likelihood Explanation

**Likelihood: Moderate**

**Attacker Capabilities Required**:
- Must be included in the `ProposerWhiteList` of a Referendum organization
- Must have sufficient funds to pay transaction fees for proposal creation

**Attack Complexity**: Low - Once whitelisted, the attack requires only repeated calls to `CreateProposal()` with unique token values or parameters to generate distinct proposal IDs.

**Feasibility Conditions**:
- Proposer whitelist membership is the primary gate, which could be obtained through:
  - Legitimate participation in an open organization
  - Compromise of a whitelisted address
  - Creation of a malicious organization with the attacker as proposer
- Transaction fees are the only per-proposal cost (no deposit or penalty)
- No rate limiting exists on proposal creation frequency

**Economic Rationality**: The attack is economically viable if transaction fees are low or if method fees for `CreateProposal()` are not set to prohibitive levels. The attacker externalizes the storage costs to node operators while only paying transaction fees themselves.

**Detection Constraints**: The attack appears as legitimate governance activity until the pattern of many expired, uncleared proposals becomes apparent. By then, state bloat has already occurred.

### Recommendation

**Immediate Mitigations**:

1. **Add Proposal Deposit Requirement**: Require proposers to lock a refundable deposit when creating proposals, forfeited if the proposal expires without reaching threshold. This creates economic disincentive for spam proposals.

```csharp
// In CreateNewProposal, add deposit requirement
private Hash CreateNewProposal(CreateProposalInput input)
{
    CheckCreateProposalInput(input);
    var organization = State.Organizations[input.OrganizationAddress];
    
    // Add: Require proposal deposit
    if (organization.ProposalDepositAmount > 0)
    {
        RequireTokenContractStateSet();
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.Self,
            Symbol = organization.TokenSymbol,
            Amount = organization.ProposalDepositAmount
        });
        // Store deposit info for refund on successful release
    }
    
    // ... rest of existing logic
}
```

2. **Implement Incentivized Cleanup**: Reward users who clear expired proposals with a portion of the forfeited deposit:

```csharp
public override Empty ClearProposal(Hash input)
{
    var proposal = State.Proposals[input];
    Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, 
           "Proposal clear failed");
    
    // Add: Transfer cleanup reward to caller
    var deposit = State.ProposalDeposits[input];
    if (deposit != null && deposit.Amount > 0)
    {
        var cleanupReward = deposit.Amount.Mul(10).Div(100); // 10% reward
        State.TokenContract.Transfer.Send(new TransferInput
        {
            To = Context.Sender,
            Symbol = deposit.Symbol,
            Amount = cleanupReward
        });
    }
    
    State.Proposals.Remove(input);
    State.ProposalDeposits.Remove(input);
    return new Empty();
}
```

3. **Add Automatic Cleanup Hook**: Clear expired proposals automatically during other operations (e.g., in `CreateProposal()`, opportunistically clear one expired proposal).

4. **Set Method Fees**: Configure governance to set meaningful transaction fees for `CreateProposal()` to increase the cost of spam attacks.

**Invariant to Enforce**: The number of active (non-expired) proposals per organization should be bounded and monitored.

### Proof of Concept

**Initial State**:
- Attacker is included in `ProposerWhiteList` of a Referendum organization
- Organization has `MinimalApprovalThreshold` set to a high value (e.g., 1,000,000 tokens)
- Attacker has minimal token balance for transaction fees

**Attack Sequence**:

1. **Create Proposal #1**:
   - Call `CreateProposal()` with `ExpiredTime` = current time + 1 day
   - Fill `Description` field with 10,200 characters
   - Provide unique `Token` to generate unique proposal ID
   - Transaction succeeds, proposal stored in state

2. **Repeat Step 1 for N proposals** (e.g., N=1,000):
   - Each with unique token/parameters to generate distinct proposal IDs
   - Each with maximum allowed description length
   - Total cost: N × transaction_fee (e.g., 1,000 × 0.01 ELF = 10 ELF)

3. **Wait for proposals to expire** (1 day passes)

4. **Observe State**:
   - All 1,000 proposals are expired but remain in `State.Proposals` mapping
   - Calling `GetProposal()` on each ID returns the full proposal data
   - Total state bloat: ~10 MB of permanent storage
   - No user has incentive to call `ClearProposal()` 1,000 times at their own expense

**Expected Result**: Proposals should be automatically cleaned up or have economic barriers preventing spam creation.

**Actual Result**: Proposals remain in state indefinitely, causing permanent state bloat that persists until manual intervention occurs. The attacker has successfully imposed storage costs on all node operators at minimal personal cost.

**Success Condition**: Query `GetProposal()` for each created proposal ID after expiration - all return non-empty results, confirming state bloat.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L154-161)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L159-187)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ToAddress = input.ToAddress,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            OrganizationAddress = input.OrganizationAddress,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId, 
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/ReferendumConstants.cs (L3-8)
```csharp
public static class ReferendumConstants
{
    public const int MaxLengthForTitle = 255;
    public const int MaxLengthForDescription = 10200;
    public const int MaxLengthForProposalDescriptionUrl = 255;
}
```

**File:** contract/AElf.Contracts.Referendum/ReferendumState.cs (L17-17)
```csharp
    public MappedState<Hash, ProposalInfo> Proposals { get; set; }
```
