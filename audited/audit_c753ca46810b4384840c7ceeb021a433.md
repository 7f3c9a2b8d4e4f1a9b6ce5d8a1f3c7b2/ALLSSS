### Title
NFT Type Removal Breaks Cross-Chain Protocol Creation Without Validation

### Summary
The `RemoveNFTType()` method allows parliament to remove NFT type mappings without validating whether existing NFT protocols use those types. When a type is removed, the `CrossChainCreate()` method fails for all protocols with that type prefix, permanently breaking cross-chain NFT mirroring functionality for those protocols.

### Finding Description

After `State.NFTTypes.Value` is initialized at line 54, there are two methods that modify it: `AddNFTType()` and `RemoveNFTType()`. [1](#0-0) 

The `RemoveNFTType()` method removes type mappings from all three state variables but lacks validation to check if existing protocols use the type being removed: [2](#0-1) 

When NFT protocols are created via the `Create()` method, they store the NFT type in `NFTProtocolInfo.NftType` and generate symbols with the type's short name prefix (e.g., "AR" for Art): [3](#0-2) 

The critical failure occurs in `CrossChainCreate()`, which is used to mirror NFT protocols from mainchain to sidechains. It extracts the 2-character type prefix from the symbol and looks it up in `State.NFTTypeFullNameMap`: [4](#0-3) 

If parliament removes a type (e.g., "AR") after protocols using that type are created on mainchain, the lookup at line 90 returns null, causing the assertion at lines 91-93 to fail. This permanently blocks cross-chain creation for all protocols with that type prefix, even though they exist validly on the mainchain.

The root cause is that `RemoveNFTType()` only validates the type exists but never checks if `State.NftProtocolMap` contains any protocols using that type.

### Impact Explanation

**Cross-Chain Integrity Breakdown:** This vulnerability breaks the cross-chain NFT protocol mirroring mechanism, a critical component of AElf's multi-chain architecture. Once a type is removed, all existing mainchain NFT protocols with that type prefix become impossible to mirror to sidechains.

**Operational DoS:** Users cannot use their NFTs on sidechains if the protocol cannot be created there. This affects all holders of NFTs under protocols using the removed type.

**Permanent Damage:** There is no recovery path - even if the type is re-added via `AddNFTType()`, the historical inconsistency remains. The mainchain protocols reference a type that was temporarily non-existent in the mappings.

**Affected Parties:**
- NFT protocol creators whose protocols become incompatible with cross-chain operations
- NFT holders who cannot transfer or use their assets on sidechains
- dApp developers building cross-chain NFT functionality

**Severity:** High - while requiring parliament governance, this causes permanent operational failure of cross-chain NFT functionality, violating the cross-chain integrity invariant.

### Likelihood Explanation

**Reachable Entry Point:** `RemoveNFTType()` is a public method callable by parliament default address. [5](#0-4) 

**Feasible Preconditions:** 
- Parliament approval required (high bar but realistic for governance operations)
- Parliament may legitimately want to deprecate an NFT type category
- No visibility into which types are actively used by existing protocols
- Parliament members may not realize protocols already use the type

**Execution Practicality:** Straightforward single transaction execution - parliament calls `RemoveNFTType(StringValue { Value = "AR" })`.

**Detection Constraints:** The impact is not immediately visible on mainchain. The break only manifests when cross-chain operations are attempted, potentially much later.

**Economic Rationality:** No economic cost to parliament. The cost is borne by NFT users and protocol creators who lose cross-chain functionality.

**Probability Assessment:** Medium - parliament governance makes this less likely than direct exploits, but the lack of usage validation makes accidental removal realistic during legitimate type management operations.

### Recommendation

**Code-Level Mitigation:**

Add validation in `RemoveNFTType()` to prevent removing types that are in use:

```csharp
public override Empty RemoveNFTType(StringValue input)
{
    AssertSenderIsParliamentDefaultAddress();
    InitialNFTTypeNameMap();
    Assert(input.Value.Length == 2, "Incorrect short name.");
    Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
    
    var fullName = State.NFTTypeFullNameMap[input.Value];
    
    // NEW VALIDATION: Check if any protocol uses this type
    // Note: This requires iterating through NftProtocolMap or maintaining a usage counter
    Assert(!IsNFTTypeInUse(fullName), 
        $"Cannot remove NFT type {fullName} - it is used by existing protocols.");
    
    State.NFTTypeFullNameMap.Remove(input.Value);
    State.NFTTypeShortNameMap.Remove(fullName);
    var nftTypes = State.NFTTypes.Value;
    nftTypes.Value.Remove(input.Value);
    State.NFTTypes.Value = nftTypes;
    Context.Fire(new NFTTypeRemoved
    {
        ShortName = input.Value
    });
    return new Empty();
}
```

**Alternative Approach:** Instead of preventing removal, allow removal but add a "deprecated" flag mechanism. Update `CrossChainCreate()` to accept deprecated types but emit a warning event.

**Invariant Checks:**
1. Add a usage counter state variable that tracks how many protocols use each type
2. Increment counter in `Create()` and decrement only when a protocol is permanently removed
3. Assert counter is zero before allowing type removal

**Test Cases:**
1. Create an NFT protocol with type "Art" (prefix "AR")
2. Attempt to remove type "AR" via `RemoveNFTType()`
3. Verify transaction reverts with appropriate error message
4. Verify `CrossChainCreate()` still works for the protocol
5. Test that types with zero usage can still be removed

### Proof of Concept

**Initial State:**
- NFT contract initialized with default types including "AR" -> "Art"
- Parliament governance contract configured

**Exploitation Steps:**

1. **Mainchain - Create NFT Protocol:**
   - User calls `Create()` with `NftType = "Art"`
   - Protocol created with symbol "AR1234"
   - `State.NftProtocolMap["AR1234"]` stores `NFTProtocolInfo` with `NftType = "Art"`

2. **Mainchain - Parliament Removes Type:**
   - Parliament calls `RemoveNFTType(StringValue { Value = "AR" })`
   - `State.NFTTypeFullNameMap["AR"]` deleted
   - `State.NFTTypeShortNameMap["Art"]` deleted
   - `State.NFTTypes.Value` no longer contains "AR" -> "Art" mapping
   - Transaction succeeds with no errors

3. **Sidechain - Attempt Cross-Chain Creation:**
   - User calls `CrossChainCreate(CrossChainCreateInput { Symbol = "AR1234" })`
   - Method extracts `nftTypeShortName = "AR"` (line 89)
   - Looks up `State.NFTTypeFullNameMap["AR"]` which returns null (line 90)
   - Assertion fails at lines 91-93: "Full name of AR not found. Use AddNFTType to add this new pair."
   - Transaction reverts

**Expected Result:** `CrossChainCreate()` should succeed, creating the protocol mirror on sidechain.

**Actual Result:** `CrossChainCreate()` fails permanently for all protocols with "AR" prefix.

**Success Condition:** The cross-chain protocol creation is permanently blocked, preventing NFT functionality on sidechains for affected protocols.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L54-54)
```csharp
        State.NFTTypes.Value = nftTypes;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-73)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);

        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;

        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
            ProtocolName = tokenCreateInput.TokenName,
            IsTokenIdReuse = input.IsTokenIdReuse,
            IssueChainId = tokenCreateInput.IssueChainId,
            IsBurnable = tokenCreateInput.IsBurnable,
            NftType = input.NftType
        };
        State.NftProtocolMap[symbol] = protocolInfo;

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = tokenCreateInput.Symbol,
            Creator = tokenCreateInput.Issuer,
            IsBurnable = tokenCreateInput.IsBurnable,
            IssueChainId = tokenCreateInput.IssueChainId,
            ProtocolName = tokenCreateInput.TokenName,
            TotalSupply = tokenCreateInput.TotalSupply,
            Metadata = protocolInfo.Metadata,
            BaseUri = protocolInfo.BaseUri,
            IsTokenIdReuse = protocolInfo.IsTokenIdReuse,
            NftType = protocolInfo.NftType
        });

        return new StringValue
        {
            Value = symbol
        };
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L89-93)
```csharp
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L152-169)
```csharp
    public override Empty RemoveNFTType(StringValue input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        Assert(input.Value.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
        var fullName = State.NFTTypeFullNameMap[input.Value];
        State.NFTTypeFullNameMap.Remove(input.Value);
        State.NFTTypeShortNameMap.Remove(fullName);
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Remove(input.Value);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeRemoved
        {
            ShortName = input.Value
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L171-182)
```csharp
    private void AssertSenderIsParliamentDefaultAddress()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        if (State.ParliamentDefaultAddress.Value == null)
            State.ParliamentDefaultAddress.Value =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());

        Assert(Context.Sender == State.ParliamentDefaultAddress.Value, "No permission.");
    }
```
