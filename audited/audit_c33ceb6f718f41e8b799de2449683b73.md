# Audit Report

## Title
Case-Sensitive Miner Pubkey Comparison Allows Valid Miners to Be Rejected After Replacement

## Summary
The consensus validation system performs case-sensitive string comparison between the block producer's public key (always lowercase from `ToHex()`) and miner keys stored in `RealTimeMinersInformation`. When an admin replaces a miner's public key via `ReplaceCandidatePubkey` with uppercase hex characters, the replaced miner becomes unable to produce blocks because the validation check fails on case mismatch, causing "Sender is not a miner" errors and degrading consensus liveness.

## Finding Description

The vulnerability arises from inconsistent hex string case handling across three components:

**1. Lowercase SenderPubkey Generation:**
The `ConsensusValidationContext.SenderPubkey` property converts the block producer's public key to hex using `ToHex()`, which always produces lowercase hex strings ('a'-'f'). [1](#0-0) 

The `ToHex()` implementation uses the formula `b + 0x37 + 0x20` for hex digits A-F, which produces lowercase characters (0x37=55 for 'A'-10, 0x20=32 for lowercase offset). [2](#0-1) 

**2. Case-Sensitive Mining Permission Validation:**
The `MiningPermissionValidationProvider` checks if the `SenderPubkey` exists in the `RealTimeMinersInformation` dictionary using a case-sensitive `Contains()` operation. [3](#0-2) 

Since `RealTimeMinersInformation` is a protobuf `map<string, MinerInRound>` which compiles to a C# `Dictionary<string, T>` with case-sensitive comparison by default, "04ABC..." and "04abc..." are treated as different keys. [4](#0-3) 

**3. No Case Normalization in Replacement:**
When `RecordCandidateReplacement` is called, the `input.NewPubkey` string is added directly to `RealTimeMinersInformation` without any case normalization. [5](#0-4) 

This string originates from the `ReplaceCandidatePubkey` method in the Election contract, which accepts raw string input without validation or normalization. [6](#0-5) 

**Why Existing Protections Fail:**

Initial round generation consistently uses `ToHex()`, ensuring all keys are lowercase: [7](#0-6) 

Evil miner replacement also uses `ToHex()` when selecting alternative candidates from initial miners: [8](#0-7) 

And election snapshot keys are stored using `ToHex()`: [9](#0-8) 

However, manual replacement via `ReplaceCandidatePubkey` bypasses this normalization, creating the inconsistency.

## Impact Explanation

When a miner's public key is replaced with an uppercase hex string, they become unable to produce blocks:

- Their actual `SenderPubkey` (from block production) converts to lowercase via `ToHex()`: "04abc..."
- The dictionary key in `RealTimeMinersInformation` contains uppercase: "04ABC..."  
- The case-sensitive `Contains()` check fails
- Block production is rejected with "Sender {pubkey} is not a miner"

This causes:
- **Immediate block production failure** for the affected miner
- **Missed time slots**, reducing consensus efficiency
- **Potential round delays** if the affected miner is the extra block producer
- **Degraded consensus liveness** proportional to affected miners
- **Transaction finality delays** due to reduced block production capacity

The impact is **Medium severity** because while consensus is disrupted, the issue:
- Affects only miners replaced with uppercase hex (not all miners)
- Can be remediated by replacing again with lowercase
- Doesn't cause fund loss or permanent state corruption
- Is an operational error rather than a malicious exploit

## Likelihood Explanation

**Trigger Requirements:**
- Admin must call `ReplaceCandidatePubkey` with a `NewPubkey` containing uppercase hex characters (A-F instead of a-f)
- The replaced candidate must be an active miner in the current round

**Likelihood Factors:**

*In favor of occurrence:*
- No input validation prevents uppercase hex strings
- Admins may manually construct transactions with uppercase
- Some tools/documentation may display hex in uppercase
- Copy-paste errors could introduce uppercase

*Against occurrence:*
- Most cryptographic libraries output lowercase hex by default
- The test suite uses `ToHex()` consistently (lowercase only)
- The issue manifests immediately, allowing quick detection
- Straightforward remediation (replace again with lowercase)

**Overall Assessment:** **Low-to-Moderate likelihood**. While most tools default to lowercase, the lack of validation means an admin could easily trigger this through manual input or certain tooling, making it a realistic operational risk.

## Recommendation

Add case normalization when storing miner public keys in `RecordCandidateReplacement`:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");

    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
    
    // Normalize new pubkey to lowercase
    var normalizedNewPubkey = input.NewPubkey.ToLower();
    
    realTimeMinerInformation.Pubkey = normalizedNewPubkey;
    currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
    currentRound.RealTimeMinersInformation.Add(normalizedNewPubkey, realTimeMinerInformation);
    
    if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
        currentRound.ExtraBlockProducerOfPreviousRound = normalizedNewPubkey;
    
    State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

    State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
    {
        OldPubkey = input.OldPubkey,
        NewPubkey = normalizedNewPubkey,
        CurrentTermNumber = State.CurrentTermNumber.Value
    });

    return new Empty();
}
```

Alternatively, add validation in `ReplaceCandidatePubkey` to reject uppercase hex strings or normalize before passing to the consensus contract.

## Proof of Concept

```csharp
[Fact]
public async Task ReplaceCandidatePubkey_UppercaseHex_CausesMiningPermissionFailure()
{
    // Setup: Announce candidate and make them a miner
    var originalKeyPair = ValidationDataCenterKeyPairs.First();
    var candidateAdmin = ValidationDataCenterKeyPairs.Last();
    var candidateAdminAddress = Address.FromPublicKey(candidateAdmin.PublicKey);
    await AnnounceElectionAsync(originalKeyPair, candidateAdminAddress);
    
    // Make the candidate a miner in the current round
    await BootMinerChangeRoundAsync();
    
    // Replace with UPPERCASE hex string
    var adminStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, candidateAdmin);
    var newKeyPair = ValidationDataCenterKeyPairs.Skip(1).First();
    var uppercaseHex = newKeyPair.PublicKey.ToHex().ToUpper(); // Force uppercase
    
    await adminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = originalKeyPair.PublicKey.ToHex(),
        NewPubkey = uppercaseHex  // Uppercase hex
    });
    
    // Verify the miner cannot produce blocks
    var consensusStub = GetTester<AEDPoSContractImplContainer.AEDPoSContractImplStub>(
        ConsensusContractAddress, newKeyPair);
    
    // Attempt to validate mining permission with lowercase SenderPubkey (as ToHex() would produce)
    var currentRound = await consensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var lowercasePubkey = newKeyPair.PublicKey.ToHex(); // This is lowercase
    
    // This should fail because dictionary key is uppercase but lookup is lowercase
    currentRound.RealTimeMinersInformation.Keys.Contains(lowercasePubkey).ShouldBeFalse();
    currentRound.RealTimeMinersInformation.Keys.Contains(uppercaseHex).ShouldBeTrue();
    
    // Mining permission validation would fail
}
```

## Notes

This vulnerability demonstrates a subtle case-sensitivity issue in the consensus system. While `ByteArrayHelper.HexStringToByteArray()` is case-insensitive when converting hex strings to bytes (allowing both "FF" and "ff"), the string keys themselves are stored and compared in a case-sensitive manner in the `RealTimeMinersInformation` dictionary. This creates a mismatch between the lowercase output of `ToHex()` used during block production validation and any uppercase keys that might be stored through the replacement mechanism.

The fix should ensure consistent lowercase normalization across all code paths that add entries to `RealTimeMinersInformation`, or alternatively implement case-insensitive dictionary comparison (though the former is simpler and maintains consistency with existing behavior).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L17-17)
```csharp
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();
```

**File:** src/AElf.Types/Extensions/ByteStringExtensions.cs (L24-28)
```csharp
                b = (byte)(bytes[bx] >> 4);
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-20)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
```

**File:** protobuf/aedpos_contract.proto (L247-247)
```text
    map<string, MinerInRound> real_time_miners_information = 2;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L141-143)
```csharp
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L475-475)
```csharp
            snapshot.ElectionResult.Add(pubkey.ToHex(), validObtainedVotesAmount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L17-17)
```csharp
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L388-388)
```csharp
                .Select(k => k.ToHex())
```
