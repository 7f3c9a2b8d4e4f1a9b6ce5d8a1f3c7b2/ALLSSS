### Title
Large ByteString DoS via Unconstrained OutValue and Signature Fields in Consensus Validation

### Summary
The `NewConsensusInformationFilled` validation method only checks that `OutValue` and `Signature` ByteStrings are non-empty using `.Any()`, but does not enforce the expected 32-byte hash size. A malicious miner can produce blocks with arbitrarily large ByteStrings (up to network limits of 100MB) that pass validation but cause memory exhaustion and CPU waste during protobuf deserialization and processing across all validating nodes.

### Finding Description

**Location**: [1](#0-0) 

**Root Cause**: The validation only checks if the ByteString contains at least one byte, not that it is exactly 32 bytes as expected for a SHA256 hash.

**Why Protections Fail**:
1. The `Hash` protobuf type is defined as `message Hash { bytes value = 1; }` with no size constraint [2](#0-1) 

2. While `Hash.LoadFromByteArray()` enforces 32-byte validation [3](#0-2) , this method is never called during consensus validation. The validation directly accesses `.Value.Any()` on the ByteString.

3. Legitimate values are always 32-byte SHA256 hashes generated via `HashHelper.ComputeFrom` [4](#0-3) , but the validation doesn't enforce this constraint.

**Execution Path**:
1. Entry point: `ValidateConsensusBeforeExecution` parses block consensus data [5](#0-4) 

2. Validation calls `UpdateValueValidationProvider` which uses the insufficient `.Any()` check [6](#0-5) 

3. If validation passes, `RecoverFromUpdateValue` assigns the oversized values [7](#0-6) 

4. Values are then stored in state [8](#0-7) 

### Impact Explanation

**Operational DoS Impact**:
- **Memory Exhaustion**: Protobuf parsing allocates memory for arbitrarily large ByteStrings. A malicious miner could embed 10-20MB in each field (within the 100MB gRPC limit [9](#0-8) ).

- **CPU Waste**: Expensive deserialization and manipulation of oversized Round objects during validation and recovery operations.

- **Network Amplification**: The malicious block propagates to all validators, each independently parsing and processing the same oversized data, multiplying the impact across the network.

- **State Bloat**: If the block somehow passes all validation stages, oversized values are persisted to state storage [10](#0-9) .

**Severity**: Medium - Can disrupt consensus validation and waste resources across all nodes, though requires miner compromise and doesn't directly steal funds.

### Likelihood Explanation

**Attacker Capabilities**: Requires a compromised or malicious miner with block production authority. Miners are authorized participants in the consensus mechanism [11](#0-10) .

**Attack Complexity**: Low once miner access is achieved. The attacker simply:
1. Generates legitimate consensus trigger information
2. Modifies `OutValue.Value` and `Signature.Value` ByteStrings to be oversized (e.g., 10MB each)
3. Signs and propagates the block

**Feasibility**: The `.Any()` check will pass for any non-empty ByteString, regardless of size. Network layer accepts messages up to 100MB, providing ample room for attack.

**Detection**: The block may eventually fail `ValidateConsensusAfterExecution` due to hash mismatch [12](#0-11) , but damage (resource consumption) occurs before rejection.

**Probability**: Medium - Requires miner compromise but attack execution is straightforward.

### Recommendation

**Code-Level Mitigation**: Add explicit size validation in `NewConsensusInformationFilled`:

```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    var minerInRound = 
        validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    
    // Validate OutValue and Signature exist and are non-empty
    if (minerInRound.OutValue == null || minerInRound.Signature == null ||
        !minerInRound.OutValue.Value.Any() || !minerInRound.Signature.Value.Any())
        return false;
    
    // Validate OutValue and Signature are exactly 32 bytes (SHA256 hash size)
    if (minerInRound.OutValue.Value.Length != AElfConstants.HashByteArrayLength ||
        minerInRound.Signature.Value.Length != AElfConstants.HashByteArrayLength)
        return false;
    
    return true;
}
```

**Invariant Checks**: 
- Enforce that all `Hash` values in consensus data are exactly 32 bytes [13](#0-12) 
- Consider adding size validation at the protobuf parsing layer before passing to validators

**Test Cases**:
1. Test with OutValue.Value = 1MB ByteString → should fail validation
2. Test with Signature.Value = 10MB ByteString → should fail validation  
3. Test with legitimate 32-byte values → should pass validation
4. Test memory consumption with oversized values to quantify DoS impact

### Proof of Concept

**Initial State**: 
- Attacker controls a miner account with block production authority
- Other honest validators are running and validating blocks

**Attack Steps**:
1. Attacker generates legitimate consensus trigger information with valid InValue
2. Attacker computes legitimate 32-byte OutValue = `HashHelper.ComputeFrom(InValue)`
3. Attacker creates malicious Round object where:
   - `OutValue.Value` = ByteString of 10,000,000 bytes (10MB)
   - `Signature.Value` = ByteString of 10,000,000 bytes (10MB)
4. Attacker includes this in `AElfConsensusHeaderInformation` with `Behaviour = UpdateValue`
5. Attacker signs block header and propagates to network

**Expected Result (Current)**: 
- Validators parse 20MB+ consensus extra data
- `NewConsensusInformationFilled` returns `true` (both fields pass `.Any()` check)
- Each validator allocates 20MB+ memory and wastes CPU cycles
- Block eventually fails validation in `ValidateConsensusAfterExecution` but damage done

**Expected Result (After Fix)**: 
- `NewConsensusInformationFilled` returns `false` due to size constraint violation
- Block rejected early with minimal resource consumption
- Error message: "Incorrect new Out Value."

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** protobuf/aelf/core.proto (L140-143)
```text
message Hash
{
    bytes value = 1;
}
```

**File:** src/AElf.Types/Types/Hash.cs (L49-58)
```csharp
        public static Hash LoadFromByteArray(byte[] bytes)
        {
            if (bytes.Length != AElfConstants.HashByteArrayLength)
                throw new ArgumentException("Invalid bytes.", nameof(bytes));

            return new Hash
            {
                Value = ByteString.CopyFrom(bytes)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L67-69)
```csharp
        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-80)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L16-17)
```csharp
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-245)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** src/AElf.OS.Network.Grpc/GrpcConstants.cs (L28-29)
```csharp
    public const int DefaultMaxReceiveMessageLength = 100 * 1024 * 1024;
    public const int DefaultMaxSendMessageLength = 100 * 1024 * 1024;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L26-26)
```csharp
    public MappedState<long, Round> Rounds { get; set; }
```

**File:** src/AElf.Types/AElfConstants.cs (L7-7)
```csharp
        public const int HashByteArrayLength = 32;
```
