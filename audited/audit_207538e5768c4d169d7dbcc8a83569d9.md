### Title
Missing Input Validation in Secret Sharing Allows Self-Inflicted UpdateValue DoS

### Summary
The `PerformSecretSharing` function lacks validation when accessing `DecryptedPieces` keys in `RealTimeMinersInformation`, allowing miners to cause their own `UpdateValue` transactions to fail. While `RevealSharedInValues` also lacks validation and would throw on invalid keys, this path is unreachable because invalid keys cannot be stored due to the earlier failure in `PerformSecretSharing`.

### Finding Description

**Primary Issue - PerformSecretSharing (Line 292)**: [1](#0-0) 

The function directly accesses `round.RealTimeMinersInformation[decryptedPreviousInValue.Key]` without checking if the key exists. If a miner submits `UpdateValueInput` with `DecryptedPieces` containing pubkeys not in the current round, this throws `KeyNotFoundException`, causing the transaction to fail.

**Secondary Issue - RevealSharedInValues (Lines 40-44)**: [2](#0-1) 

The function uses `.First()` to find miners by pubkey match without validation. If `DecryptedPieces` contained invalid keys, this would throw `InvalidOperationException`. However, this code path is protected by the earlier failure in `PerformSecretSharing`.

**Comparison with Protected Path**: [3](#0-2) 

The `UpdateLatestSecretPieces` function properly validates with `ContainsKey` before accessing the dictionary, demonstrating the correct pattern.

**Authorization Context**: [4](#0-3) 

Only current or previous round miners can call `UpdateValue`, but they can still provide malicious `DecryptedPieces` input.

### Impact Explanation

**Actual Impact (LOW-MEDIUM)**:
- A malicious miner can cause their own `UpdateValue` transactions to fail repeatedly
- The attacker primarily harms themselves by wasting gas and failing to update their consensus information
- No impact on other miners or the consensus protocol's integrity
- No funds at risk or unauthorized state changes

**Theoretical Impact (Not Reachable)**:
- If invalid keys reached `RevealSharedInValues`, the `NextRound` transition would fail (HIGH severity)
- However, this cannot occur because `PerformSecretSharing` prevents invalid keys from being stored

### Likelihood Explanation

**PerformSecretSharing DoS**:
- Attack Complexity: Trivial - any authorized miner can submit invalid `DecryptedPieces`
- Preconditions: Attacker must be a current or previous round miner
- Economic Rationality: Poor - attacker mainly harms themselves
- Detection: Transaction failures would be immediately visible

**RevealSharedInValues DoS**:
- Likelihood: Negligible - unreachable due to `PerformSecretSharing` validation failure
- Invalid keys cannot be persisted to state, so this code path cannot execute with bad data

### Recommendation

Add defensive validation in both functions:

**For PerformSecretSharing**:
```csharp
foreach (var decryptedPreviousInValue in input.DecryptedPieces)
    if (round.RealTimeMinersInformation.ContainsKey(decryptedPreviousInValue.Key))
        round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
            .Add(publicKey, decryptedPreviousInValue.Value);
```

**For RevealSharedInValues**:
```csharp
var orders = anotherMinerInPreviousRound.DecryptedPieces
    .Where(kv => previousRound.RealTimeMinersInformation.Values.Any(m => m.Pubkey == kv.Key))
    .Select((t, i) => previousRound.RealTimeMinersInformation.Values
        .First(m => m.Pubkey == anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
    .ToList();
```

**Test Cases**:
1. Submit `UpdateValue` with non-existent miner pubkeys in `DecryptedPieces`
2. Submit `UpdateValue` with removed/replaced miner pubkeys
3. Verify transactions handle invalid input gracefully without state corruption

### Proof of Concept

**Initial State**:
- Round N with miners [A, B, C] (pubkeys in hex format)
- Miner A is authorized to call `UpdateValue`

**Attack Steps**:
1. Miner A constructs `UpdateValueInput` with:
   - `DecryptedPieces = {"InvalidPubkey123": bytes_value}`
2. Miner A calls `UpdateValue(input)`
3. Transaction reaches `ProcessUpdateValue` â†’ `PerformSecretSharing`
4. At line 292: `round.RealTimeMinersInformation["InvalidPubkey123"]` throws `KeyNotFoundException`
5. Transaction fails and reverts

**Expected Result**: 
- With proper validation: Invalid keys silently skipped, transaction succeeds
- Actual Result: Transaction fails with `KeyNotFoundException`

**Success Condition**: 
Demonstrate that a miner can repeatedly cause their own transactions to fail, though with limited protocol impact since only self-inflicted.

### Notes

This finding has **limited severity** because:
1. The exploit is self-inflicted - the attacker's own transaction fails
2. No other miners or consensus operations are affected  
3. `RevealSharedInValues` DoS is theoretical only - unreachable due to earlier validation failure
4. No funds at risk or unauthorized access granted

While the missing validation represents a defensive programming weakness, it does not meet the threshold for a HIGH severity vulnerability as originally classified in the audit question.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-44)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-146)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;
```
