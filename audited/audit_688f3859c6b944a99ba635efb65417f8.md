# Audit Report

## Title
Unbounded Scheme Creation Leading to State Bloat and DoS in TokenHolder Contract

## Summary
The `CreateScheme` function in TokenHolderContract allows any caller to repeatedly create unlimited profit schemes without checking if a scheme already exists. Each invocation creates a new `Scheme` object in ProfitContract with permanent storage, causing unbounded state growth and enabling state bloat attacks that degrade node performance.

## Finding Description

The `CreateScheme` method in TokenHolderContract lacks validation to prevent duplicate scheme creation. [1](#0-0) 

Each invocation unconditionally calls `State.ProfitContract.CreateScheme.Send()`, which creates a new scheme in the underlying ProfitContract. The ProfitContract generates unique scheme IDs using a count-based mechanism. [2](#0-1) 

When `Token` is null (as provided by TokenHolderContract), the scheme ID is generated as `Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false))` where `createdSchemeCount` increments with each call. This ensures each invocation creates a distinct scheme rather than updating an existing one.

Each created scheme is permanently stored in state. [3](#0-2) 

The scheme is stored in `State.SchemeInfos[schemeId]` and the scheme ID is appended to `State.ManagingSchemeIds[manager].SchemeIds`, causing unbounded array growth with no cleanup mechanism.

Test evidence confirms this pattern is executable - a single manager can create multiple schemes successfully. [4](#0-3) 

## Impact Explanation

**State Database Bloat**: Each scheme creates a `Scheme` object containing virtual address, manager, scheme ID, current period, total shares, and other fields. [5](#0-4) 

Additionally, each scheme ID is permanently appended to the `ManagingSchemeIds` array, causing linear growth with no upper bound. [6](#0-5) 

**DoS of Query Operations**: The `GetManagingSchemeIds` view method returns the complete array of scheme IDs for a manager. [7](#0-6) 

As schemes accumulate, this query returns increasingly large arrays, degrading node performance and potentially causing timeouts or memory issues.

**Severity**: Medium - While transaction fees provide economic barriers, the lack of any hard limit or duplicate check allows determined attackers to cause significant operational degradation through sustained state bloat attacks.

## Likelihood Explanation

**No Authorization Required**: The `CreateScheme` method is publicly accessible with no authorization checks. [8](#0-7) 

Any address can invoke this method repeatedly, limited only by transaction fees and block gas constraints. The attack can be executed across multiple blocks to bypass per-block limits.

**Economic Feasibility**: Transaction fees (if configured via ACS1) provide the primary cost barrier. However, if fees are set low or an attacker has sufficient funds, they can create hundreds or thousands of schemes. The test suite demonstrates creating multiple schemes is a supported pattern, confirming the execution path is valid.

**Probability**: Medium - Simple to execute but requires sustained transaction fee expenditure proportional to the number of schemes created.

## Recommendation

Add a validation check in `TokenHolderContract.CreateScheme` to prevent duplicate scheme creation:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Check if scheme already exists
    var existingScheme = State.TokenHolderProfitSchemes[Context.Sender];
    Assert(existingScheme == null || existingScheme.SchemeId == null, 
        "Scheme already exists for this address. Cannot create duplicate schemes.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, consider implementing a maximum limit on schemes per address at the ProfitContract level, or adding a governance-controlled cleanup mechanism for orphaned schemes.

## Proof of Concept

```csharp
[Fact]
public async Task CreateScheme_StateBlot_Attack_Test()
{
    // Attacker repeatedly calls CreateScheme
    for (int i = 0; i < 100; i++)
    {
        await TokenHolderContractStub.CreateScheme.SendAsync(
            new CreateTokenHolderProfitSchemeInput
            {
                Symbol = "APP"
            });
    }
    
    // Verify 100 schemes were created in ProfitContract
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput
        {
            Manager = Starter
        });
    
    // State bloat: 100 schemes stored permanently
    schemeIds.SchemeIds.Count.ShouldBe(100);
    
    // Each scheme consumes storage that cannot be reclaimed
    // GetManagingSchemeIds query becomes increasingly expensive
}
```

## Notes

The vulnerability exploits the lack of idempotency in `CreateScheme`. While the ProfitContract correctly prevents duplicate scheme IDs (ensuring uniqueness), the TokenHolderContract provides no mechanism to prevent the same address from creating multiple schemes. The count-based ID generation in `GenerateSchemeId` guarantees each call produces a unique scheme, making the accumulation unbounded.

The UpdateTokenHolderProfitScheme helper uses `FirstOrDefault()` to retrieve the scheme ID, which means it always references the first scheme created, not the most recent. [9](#0-8)  This creates additional confusion as the TokenHolderProfitScheme data (Symbol, MinimumLockMinutes) is overwritten with each CreateScheme call, potentially causing inconsistencies between the stored scheme parameters and the actual scheme being used.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L56-72)
```csharp
        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
        State.SchemeInfos[schemeId] = scheme;

        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;

```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L938-954)
```csharp
    private Scheme GetNewScheme(CreateSchemeInput input, Hash schemeId, Address manager)
    {
        var scheme = new Scheme
        {
            SchemeId = schemeId,
            // The address of general ledger for current profit scheme.
            VirtualAddress = Context.ConvertVirtualAddressToContractAddress(schemeId),
            Manager = manager,
            ProfitReceivingDuePeriodCount = input.ProfitReceivingDuePeriodCount,
            CurrentPeriod = 1,
            IsReleaseAllBalanceEveryTimeByDefault = input.IsReleaseAllBalanceEveryTimeByDefault,
            DelayDistributePeriodCount = input.DelayDistributePeriodCount,
            CanRemoveBeneficiaryDirectly = input.CanRemoveBeneficiaryDirectly
        };

        return scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```

**File:** test/AElf.Contracts.Profit.Tests/ProfitTests.cs (L1563-1574)
```csharp
    public async Task GetManagingSchemeIds_Test()
    {
        var schemeId1 = await CreateSchemeAsync();
        var schemeId2 = await CreateSchemeAsync(1);
        var managerSchemes = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
        {
            Manager = Address.FromPublicKey(CreatorKeyPair[0].PublicKey)
        });
        managerSchemes.SchemeIds.Count.ShouldBe(2);
        managerSchemes.SchemeIds.Contains(schemeId1).ShouldBeTrue();
        managerSchemes.SchemeIds.Contains(schemeId2).ShouldBeTrue();
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L12-15)
```csharp
    public override CreatedSchemeIds GetManagingSchemeIds(GetManagingSchemeIdsInput input)
    {
        return State.ManagingSchemeIds[input.Manager];
    }
```
