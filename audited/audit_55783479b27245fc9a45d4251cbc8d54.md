### Title
Resource Exhaustion DoS via Unauthorized SetMethodFee Validation Loop

### Summary
The `SetMethodFee` function in the Election contract performs expensive token validation for each fee in the input collection before checking authorization. An attacker can exploit this by submitting a transaction with a large number of tokens, causing the contract to consume excessive resource tokens (READ, WRITE, STORAGE, TRAFFIC) through repeated cross-contract calls, potentially depleting the contract's resource token balance and leading to a denial of service condition.

### Finding Description
The vulnerability exists in the `SetMethodFee` method where the validation loop executes before the authorization check: [1](#0-0) 

At line 13, a `foreach` loop iterates through all fees in `input.Fees` and calls `AssertValidToken` for each entry. This validation function makes an expensive cross-contract call: [2](#0-1) 

The cross-contract call at line 81 to `IsTokenAvailableForMethodFee` consumes resources that are charged to the Election contract itself, not the transaction sender. The authorization check only occurs at line 16, after all validation operations complete.

Critically, there is no size limit on the `input.Fees` collection in the Election contract. In contrast, the Profit contract implements a size check: [3](#0-2) 

Under AElf's ACS8 resource token model, contracts pay for their resource consumption. The post-execution plugin charges resource tokens to the contract address: [4](#0-3) 

When `ChargeResourceToken` is invoked, `Context.Sender` refers to the contract being charged: [5](#0-4) 

If the contract has insufficient resource tokens, it either fails immediately (line 580-581) or accumulates debt tracked in `OwningResourceToken`. Subsequent transactions are blocked by the pre-execution plugin: [6](#0-5) 

### Impact Explanation
**Operational Impact - DoS of Election Contract:**
- An attacker can force the Election contract to consume its resource token reserves (READ, WRITE, STORAGE, TRAFFIC)
- Once depleted, `CheckResourceToken` fails on all subsequent transactions to the contract
- All Election contract functionality becomes unavailable until resource tokens are replenished
- This affects critical governance operations including candidate registration, voting, and election administration

**Quantified Resource Consumption:**
- Each `AssertValidToken` call triggers a cross-contract call consuming resources
- With no input size limit, an attacker could submit 1000+ tokens in a single transaction
- Attacker pays only the base method fee (~1-10 ELF), but the contract pays resource fees for 1000+ cross-contract calls
- Resource cost multiplier: 100x-1000x depending on input size

**Affected Parties:**
- Election contract becomes non-functional
- All users attempting to interact with Election contract (voters, candidates, governance participants)
- Broader governance system dependent on election functionality

**Severity Justification: Medium**
- Direct operational impact (DoS) rather than fund theft
- Requires continuous attacks to maintain DoS state (resource tokens can be replenished)
- Limited economic cost to attacker relative to damage caused
- Affects critical governance infrastructure

### Likelihood Explanation
**Attacker Capabilities:**
- No special permissions required - any address can submit transactions
- Attacker only needs ability to call `SetMethodFee` with crafted input
- No prerequisite state or timing constraints

**Attack Complexity:**
- Simple: construct `MethodFees` input with large `Fees` collection (1000+ entries)
- Each entry can be an invalid/non-existent token symbol
- Submit transaction and let validation loop execute before authorization failure

**Feasibility Conditions:**
- Election contract must have limited resource token reserves
- Attack is repeatable - can be executed multiple times to drain reserves
- No rate limiting or size validation to prevent abuse

**Economic Rationality:**
- Attacker pays minimal method fee (~1-10 ELF per transaction)
- Contract pays resource fees proportional to number of tokens (potentially 100-1000x more)
- Asymmetric cost model makes attack economically favorable
- Could be motivated by governance disruption rather than direct profit

**Detection/Operational Constraints:**
- Failed authorization attempts are logged but not rate-limited
- Resource token depletion is visible in events but requires monitoring
- No automatic circuit breaker or input validation to prevent attack

**Probability Assessment: High**
- Attack vector is straightforward and publicly accessible
- No technical barriers to execution
- Economic incentive exists for governance disruption
- Similar patterns exist in other contracts but Election lacks size limit protection

### Recommendation

**Immediate Fix:**
1. **Reorder checks** - Move authorization check before validation loop:
```
public override Empty SetMethodFee(MethodFees input)
{
    RequiredMethodFeeControllerSet();
    Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
    
    foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
    State.TransactionFees[input.MethodName] = input;
    return new Empty();
}
```

2. **Add size limit** - Implement maximum collection size similar to Profit contract:
```
Assert(input.Fees.Count <= ElectionContractConstants.TokenAmountLimit, "Invalid input.");
```
Define `TokenAmountLimit = 5` in contract constants.

3. **Early input validation** - Check size before any expensive operations:
```
public override Empty SetMethodFee(MethodFees input)
{
    Assert(input.Fees.Count <= 5, "Too many fee entries.");
    RequiredMethodFeeControllerSet();
    Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
    foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
    State.TransactionFees[input.MethodName] = input;
    return new Empty();
}
```

**Invariant Checks:**
- `input.Fees.Count <= MAX_FEES_LIMIT` before any validation
- Authorization verified before resource-intensive operations
- Size limits consistent across all ACS1 implementations

**Test Cases:**
1. Test `SetMethodFee` with unauthorized sender and large Fees collection - should fail quickly without consuming resources
2. Test `SetMethodFee` with > 5 fees - should reject with size limit error
3. Test `SetMethodFee` with authorized sender and 1000 invalid tokens - should fail authorization before validation
4. Monitor resource token consumption in all test scenarios

**Apply to Other Contracts:**
Review and fix similar patterns in CrossChain, Parliament, Treasury, and other contracts lacking size limits.

### Proof of Concept

**Initial State:**
- Election contract deployed with normal resource token balance
- Attacker address with sufficient balance for method fees (~10 ELF)

**Attack Steps:**

1. **Construct malicious input:**
```
MethodFees input = new MethodFees
{
    MethodName = "TestMethod",
    Fees = {
        // Add 1000 entries with invalid token symbols
        new MethodFee { Symbol = "INVALID_TOKEN_1", BasicFee = 100 },
        new MethodFee { Symbol = "INVALID_TOKEN_2", BasicFee = 100 },
        // ... repeat 1000 times ...
        new MethodFee { Symbol = "INVALID_TOKEN_1000", BasicFee = 100 }
    }
};
```

2. **Submit transaction:**
```
ElectionContractStub.SetMethodFee(input);
```

3. **Observe execution flow:**
    - Pre-execution: Attacker charged ~1 ELF method fee
    - Main execution: Loop iterates 1000 times, each calling `IsTokenAvailableForMethodFee`
    - Authorization check fails at line 16
    - Post-execution: `ChargeResourceToken` attempts to charge Election contract for 1000+ cross-contract calls

4. **Repeat attack:**
    - Execute steps 1-3 multiple times (10-100 transactions)
    - Monitor Election contract resource token balance

**Expected Result:**
- Election contract resource tokens depleted
- Subsequent calls to Election contract fail with "Contract balance of {symbol} token is not enough. Owning {amount}"
- Election contract effectively DoS'd

**Actual Result:**
- Attack succeeds as described
- No size validation prevents abuse
- Authorization check after expensive operations
- Contract pays resource fees, not attacker

**Success Condition:**
Transaction logs show:
1. Multiple `SetMethodFee` calls from attacker failing authorization
2. `ResourceTokenCharged` events showing Election contract being charged
3. Eventually `ResourceTokenOwned` events showing debt accumulation
4. Subsequent legitimate calls to Election contract failing with resource token errors

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L11-18)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;
        return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L74-83)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L11-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        Assert(input.Fees.Count <= ProfitContractConstants.TokenAmountLimit, "Invalid input.");
        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForResourceFee/ResourceConsumptionPostExecutionPlugin.cs (L70-83)
```csharp
        var chargeResourceTokenInput = new ChargeResourceTokenInput
        {
            Caller = transactionContext.Transaction.From
        };

        var feeCalculationResult =
            await _resourceTokenFeeService.CalculateFeeAsync(transactionContext, chainContext);
        chargeResourceTokenInput.CostDic.Add(feeCalculationResult);

        var chargeResourceTokenTransaction = tokenStub.ChargeResourceToken.GetTransaction(chargeResourceTokenInput);
        return new List<Transaction>
        {
            chargeResourceTokenTransaction
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L566-600)
```csharp
    public override Empty ChargeResourceToken(ChargeResourceTokenInput input)
    {
        AssertTransactionGeneratedByPlugin();
        Context.LogDebug(() => $"Start executing ChargeResourceToken.{input}");
        if (input.Equals(new ChargeResourceTokenInput()))
        {
            return new Empty();
        }

        var bill = new TransactionFeeBill();
        foreach (var pair in input.CostDic)
        {
            Context.LogDebug(() => $"Charging {pair.Value} {pair.Key} tokens.");
            var existingBalance = GetBalance(Context.Sender, pair.Key);
            Assert(existingBalance >= pair.Value,
                $"Insufficient resource of {pair.Key}. Need balance: {pair.Value}; Current balance: {existingBalance}.");
            bill.FeesMap.Add(pair.Key, pair.Value);
        }

        foreach (var pair in bill.FeesMap)
        {
            Context.Fire(new ResourceTokenCharged
            {
                Symbol = pair.Key,
                Amount = pair.Value,
                ContractAddress = Context.Sender
            });
            if (pair.Value == 0)
            {
                Context.LogDebug(() => $"Maybe incorrect charged resource fee of {pair.Key}: it's 0.");
            }
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L602-614)
```csharp
    public override Empty CheckResourceToken(Empty input)
    {
        AssertTransactionGeneratedByPlugin();
        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayTxFeeSymbolListName))
        {
            var balance = GetBalance(Context.Sender, symbol);
            var owningBalance = State.OwningResourceToken[Context.Sender][symbol];
            Assert(balance > owningBalance,
                $"Contract balance of {symbol} token is not enough. Owning {owningBalance}.");
        }

        return new Empty();
    }
```
