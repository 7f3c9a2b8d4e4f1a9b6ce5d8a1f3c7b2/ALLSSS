### Title
Broken Quadratic Voting Mechanism Allows Vote Manipulation with Minimal Token Cost

### Summary
The quadratic voting implementation in VoteContract is fundamentally broken due to unique VoteId generation per transaction, causing the quadratic cost mechanism to fail completely. For token-locked voting, each vote costs only the fixed TicketCost instead of quadratically increasing costs, and for delegated voting, votes are completely free. Combined with no minimum TicketCost validation, an attacker can register voting items with TicketCost=1 and manipulate voting results with minimal or zero cost.

### Finding Description

The vulnerability exists in the interaction between vote registration and execution logic:

**Root Cause 1: Broken Quadratic Cost Calculation for IsLockToken=true**

In the Register() function, TicketCost is stored without any minimum value validation: [1](#0-0) 

When voting with IsLockToken=true, the VoteId is auto-generated uniquely for each transaction: [2](#0-1) 

This causes the QuadraticVotesCountMap to always start at 0 for each new vote: [3](#0-2) 

Since each vote transaction generates a new unique VoteId (based on changing VotesAmount), the `currentVotesCount` is always 1, making `amount = TicketCost * 1 = TicketCost` for every vote. This completely defeats the quadratic voting mechanism where subsequent votes should cost exponentially more.

**Root Cause 2: Zero-Cost Voting for IsLockToken=false**

For delegated voting (IsLockToken=false), the token locking is skipped entirely: [4](#0-3) 

The sponsor can vote unlimited times on behalf of others without locking any tokens, regardless of TicketCost value.

**Why Existing Protections Fail**

The Register() function only validates timestamp ordering and token whitelist, but never validates TicketCost: [5](#0-4) 

No minimum TicketCost check exists anywhere in the registration or voting flow.

### Impact Explanation

**Direct Governance Manipulation:**
- An attacker can register a quadratic voting item with TicketCost=1 token
- For IsLockToken=true: Accumulate 100 votes by locking only 100 tokens (instead of 5,050 tokens under true quadratic voting: 1+2+3+...+100)
- For IsLockToken=false: Accumulate unlimited votes at zero token cost
- Win any vote with 98% cost savings compared to legitimate quadratic voting

**Quantified Impact:**
- With TicketCost=1 and 1000 votes needed to win:
  - Legitimate quadratic cost: 500,500 tokens (sum 1 to 1000)
  - Actual cost under this bug: 1,000 tokens (IsLockToken=true) or 0 tokens (IsLockToken=false)
  - 99.8% cost reduction enables cheap vote manipulation

**Who Is Affected:**
- Any governance system relying on Vote contract's quadratic voting
- Legitimate voters who pay fair costs under correct quadratic assumptions
- Protocol governance integrity

**Severity Justification:**
- HIGH severity due to direct governance compromise
- Enables unfair voting outcomes with minimal economic barrier
- Breaks fundamental security assumption of quadratic voting (Sybil resistance)

### Likelihood Explanation

**Attacker Capabilities:**
- Any user can call the public Register() function with arbitrary TicketCost value
- Any user can call Vote() multiple times on their own voting item
- No special privileges required

**Attack Complexity:**
- Trivial: Single Register() call with TicketCost=1, followed by multiple Vote() calls
- No complex state manipulation or timing requirements needed

**Feasibility Conditions:**
- Attacker needs minimal tokens (as low as 1 token per vote for IsLockToken=true, or 0 for IsLockToken=false)
- No dependency on external conditions or trusted role compromise
- Works immediately after contract deployment

**Detection/Operational Constraints:**
- Attack appears as normal voting activity in event logs
- No obvious on-chain indicators to distinguish malicious from legitimate low-cost voting
- Difficult to detect without analyzing TicketCost values and vote patterns

**Probability:**
- VERY HIGH: Attack is economically rational (cheap manipulation), technically simple, and immediately exploitable

### Recommendation

**1. Add Minimum TicketCost Validation in Register():**

In the `Register()` function, add validation after line 34:

```csharp
if (input.IsQuadratic) {
    Assert(input.TicketCost >= VoteContractConstants.MinimumQuadraticTicketCost, 
           "TicketCost must be above minimum threshold for quadratic voting");
}
```

Define a reasonable minimum (e.g., 1000 tokens) in VoteContractConstants to ensure economic barrier.

**2. Fix Quadratic Voting Cost Calculation:**

The fundamental issue is that VoteId is unique per transaction. To properly implement quadratic voting, track vote count per (Voter, VotingItemId) pair instead:

```csharp
// In VoteContractState.cs, add:
public MappedState<Hash, long> VoterItemVotesCount { get; set; }

// In Vote() function, replace lines 100-102:
var voterItemKey = HashHelper.ConcatAndCompute(
    HashHelper.ComputeFrom(input.Voter), 
    votingItem.VotingItemId);
var currentVotesCount = State.VoterItemVotesCount[voterItemKey].Add(1);
State.VoterItemVotesCount[voterItemKey] = currentVotesCount;
amount = votingItem.TicketCost.Mul(currentVotesCount);
```

**3. Add Invariant Checks:**

- Ensure locked token amount always equals sum of all active voting records for IsLockToken=true
- Validate that voting results match total locked tokens (accounting for quadratic formula)

**4. Test Cases:**

- Test that multiple votes by same user have increasing costs (1x, 2x, 3x TicketCost)
- Test that TicketCost below minimum is rejected
- Test that delegated voting (IsLockToken=false) properly handles cost calculations
- Regression test to ensure QuadraticVotesCountMap persists across transactions

### Proof of Concept

**Required Initial State:**
- VoteContract deployed and initialized
- Attacker has minimal token balance (e.g., 100 tokens)
- Token is in Vote contract whitelist

**Attack Sequence:**

1. **Register malicious quadratic voting item:**
   ```
   Call VoteContract.Register() with:
   - IsQuadratic = true
   - TicketCost = 1
   - IsLockToken = true
   - AcceptedCurrency = "ELF"
   - StartTimestamp = now
   - EndTimestamp = now + 30 days
   - Options = ["OptionA", "OptionB"]
   ```

2. **Vote multiple times cheaply:**
   ```
   Loop 100 times:
     Call VoteContract.Vote() with:
     - VotingItemId = <from step 1>
     - Option = "OptionA"
     - (VoteId auto-generated uniquely each time)
   ```

3. **Verify Results:**
   ```
   Call GetVotingResult():
   - Results["OptionA"] = 100 votes
   - Total tokens locked = 100 (not 5,050 as expected in quadratic voting)
   ```

**Expected vs Actual:**
- **Expected (true quadratic):** First vote costs 1, second costs 2, third costs 3, etc. Total for 100 votes = 5,050 tokens
- **Actual (broken):** Each vote costs 1 token. Total for 100 votes = 100 tokens
- **Success Condition:** Attacker accumulates 100 votes while locking only 100 tokens, achieving 98% cost reduction and unfair voting advantage

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L51-51)
```csharp
            TicketCost = input.TicketCost
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L100-102)
```csharp
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L122-130)
```csharp
        if (votingItem.IsLockToken)
            // Lock voted token.
            State.TokenContract.Lock.Send(new LockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                LockId = input.VoteId,
                Amount = amount
            });
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L397-397)
```csharp
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
```
