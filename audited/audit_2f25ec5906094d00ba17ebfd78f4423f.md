### Title
Permanent Governance Capture via Immediate Controller Transfer Without Time Lock

### Summary
The `ChangeMaximumMinersCountController()` function lacks time lock protection, allowing an attacker who gains temporary control of the Parliament organization to immediately create and release a proposal that permanently transfers the controller to their own organization. Once captured, legitimate governance cannot reverse the change even after regaining Parliament control, resulting in permanent loss of control over critical consensus parameters.

### Finding Description

The vulnerability exists in the `ChangeMaximumMinersCountController` function which only performs three checks: [1](#0-0) 

The authorization check at line 48 validates that `Context.Sender` equals the current controller's `OwnerAddress`. When a Parliament proposal is released, the execution uses `Context.SendVirtualInlineBySystemContract`, which sets the Parliament organization's virtual address as `Context.Sender`: [2](#0-1) 

The critical flaw is that Parliament proposals have **no minimum delay or time lock** before release. Once the approval threshold is reached, the proposer can immediately call `Release`: [3](#0-2) 

The validation only checks that the proposal has not expired (upper bound), not that any minimum time has passed (lower bound). The `ExpiredTime` is set by the proposer during creation: [4](#0-3) 

### Impact Explanation

**Critical Severity - Permanent Governance Capture**

1. **Permanent Loss of Control**: The attacker gains permanent control over the `MaximumMinersCountController`, which governs critical consensus parameters. Even if legitimate governance regains control of Parliament, they cannot reverse the controller change.

2. **Consensus Manipulation**: Control over the maximum miners count allows the attacker to:
   - Manipulate the miner list size via `SetMaximumMinersCount`
   - Control miner increase intervals via `SetMinerIncreaseInterval`
   - Affect consensus security by controlling the number of validators [5](#0-4) 

3. **Systemic Risk**: This pattern affects all controller change functions across the codebase (Genesis contract deployment/code check controllers, method fee controllers), creating multiple attack vectors with the same vulnerability. [6](#0-5) 

### Likelihood Explanation

**High Likelihood - Immediately Exploitable**

The attack is feasible because:

1. **Reachable Entry Point**: `ChangeMaximumMinersCountController` is a public method callable via Parliament proposals.

2. **No Time Lock Defense**: The absence of any delay mechanism means an attacker can act within a single block or round:
   - Create proposal with attacker's organization as new controller
   - Get approval from compromised miners (who vote dynamically based on current miner list)
   - Immediately release the proposal
   - Controller is permanently changed [7](#0-6) 

3. **Temporary Control Becomes Permanent**: The attack only requires temporary control (e.g., one round where enough miners are compromised or collude), but the result is permanent capture.

4. **Economic Rationality**: The cost of temporarily compromising miners (via bribes, exploits, or social engineering) can be far less than the long-term value of controlling consensus parameters.

### Recommendation

**Implement Multi-Layer Time Lock Protection**:

1. **Add Minimum Proposal Lifetime**: Enforce a minimum delay (e.g., 24-72 hours) between proposal creation and release to allow legitimate governance to detect and respond:

```csharp
public override Empty ChangeMaximumMinersCountController(AuthorityInfo input)
{
    RequiredMaximumMinersCountControllerSet();
    AssertSenderAddressWith(State.MaximumMinersCountController.Value.OwnerAddress);
    
    // Add minimum proposal age check
    var proposalInfo = GetProposalForCurrentCall();
    var minimumDelay = 259200; // 3 days in seconds
    Assert(Context.CurrentBlockTime >= proposalInfo.CreationTime.AddSeconds(minimumDelay),
        "Proposal must wait minimum delay period before execution.");
    
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    State.MaximumMinersCountController.Value = input;
    return new Empty();
}
```

2. **Add Two-Step Controller Change**: Require a pending state with timelock:

```csharp
// First transaction proposes the change
public override Empty ProposeMaximumMinersCountControllerChange(AuthorityInfo input)
{
    // ... authorization checks ...
    State.PendingMaximumMinersCountController.Value = new PendingControllerChange 
    {
        NewController = input,
        EffectiveTime = Context.CurrentBlockTime.AddSeconds(259200)
    };
}

// Second transaction finalizes after timelock
public override Empty FinalizeMaximumMinersCountControllerChange(Empty input)
{
    var pending = State.PendingMaximumMinersCountController.Value;
    Assert(pending != null, "No pending controller change.");
    Assert(Context.CurrentBlockTime >= pending.EffectiveTime, "Timelock not expired.");
    State.MaximumMinersCountController.Value = pending.NewController;
    State.PendingMaximumMinersCountController.Value = null;
}
```

3. **Add Organization Type Validation**: Restrict controller changes to specific governance types with minimum thresholds to prevent attacker-controlled organizations.

4. **Apply Same Fixes to All Controller Change Functions**: This vulnerability pattern exists in Genesis, MultiToken, and all ACS1 implementations.

### Proof of Concept

**Initial State**:
- MaximumMinersCountController = Parliament Default Organization (address P)
- Current miners: M1, M2, M3, ..., M7 (7 miners)
- Parliament approval threshold: 5/7 (71%)

**Attack Sequence**:

1. **Attacker Gains Temporary Control** (Block N):
   - Attacker compromises or colludes with 5 miners (M1-M5)
   - Attacker creates malicious organization A (Parliament/Association with attacker-controlled members)

2. **Attacker Creates Proposal** (Block N):
   - Call `Parliament.CreateProposal`:
     - `OrganizationAddress`: P (Parliament default)
     - `ToAddress`: AEDPoS contract
     - `ContractMethodName`: "ChangeMaximumMinersCountController"
     - `Params`: AuthorityInfo(OwnerAddress: A, ContractAddress: Parliament)
     - `ExpiredTime`: CurrentBlockTime + 1 hour (minimal expiration)
   - Proposal ID returned: H1

3. **Attacker Approves Proposal** (Block N or N+1):
   - Compromised miners M1-M5 each call `Parliament.Approve(H1)`
   - Approval count: 5/7 = 71% ≥ threshold ✓

4. **Attacker Releases Immediately** (Block N+1):
   - Attacker calls `Parliament.Release(H1)`
   - Check: `Context.Sender == proposer` ✓
   - Check: `IsReleaseThresholdReached(H1, P)` ✓ (5/7 ≥ 71%)
   - Executes inline call: `AEDPoS.ChangeMaximumMinersCountController(A)`
   - `Context.Sender` during inline call = P (Parliament org address)
   - Authorization check passes: `Context.Sender == P` ✓
   - Organization exists check: `ValidateOrganizationExist(A)` ✓
   - **Controller permanently changed to A**

5. **Permanent Capture Achieved** (Block N+2+):
   - Legitimate governance regains Parliament control
   - Attempts to change controller back fail: requires authorization from organization A (attacker-controlled)
   - Attacker maintains permanent control over maximum miners count settings

**Expected vs Actual Result**:
- **Expected**: Controller changes should require extended deliberation period, allowing legitimate governance to detect and prevent malicious changes
- **Actual**: Controller can be changed within 1-2 blocks with no opportunity for intervention, making temporary control permanent

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L45-54)
```csharp
    public override Empty ChangeMaximumMinersCountController(AuthorityInfo input)
    {
        RequiredMaximumMinersCountControllerSet();
        AssertSenderAddressWith(State.MaximumMinersCountController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MaximumMinersCountController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L13-20)
```csharp
    private List<Address> GetCurrentMinerList()
    {
        RequireConsensusContractStateSet();
        var miner = State.ConsensusContract.GetCurrentMinerList.Call(new Empty());
        var members = miner.Pubkeys.Select(publicKey =>
            Address.FromPublicKey(publicKey.ToByteArray())).ToList();
        return members;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L157-166)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = CheckProposalNotExpired(proposal);
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L225-253)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId, 
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L366-382)
```csharp
    public override Empty ChangeContractDeploymentController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.ContractDeploymentController.Value = input;
        return new Empty();
    }

    public override Empty ChangeCodeCheckController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.CodeCheckController.Value.OwnerAddress);
        Assert(CheckOrganizationExist(input),
            "Invalid authority input.");
        State.CodeCheckController.Value = input;
        return new Empty();
    }
```
