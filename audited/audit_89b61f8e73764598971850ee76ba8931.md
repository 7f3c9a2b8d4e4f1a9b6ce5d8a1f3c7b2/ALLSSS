### Title
Missing Miner List Validation in NextTerm Allows Sybil Attack to Bypass Solitary Miner Detection

### Summary
The `NextTerm` function accepts arbitrary miner lists from the caller without validating against the Election contract's legitimate miner list. An attacker in the current miner list can inject fake miner entries with manipulated `supposed_order_of_next_round` values, causing `SolitaryMinerDetection` to incorrectly believe multiple miners are active, thereby disabling the safety mechanism that prevents a single miner from monopolizing block production.

### Finding Description

**Root Cause:** The `ProcessNextTerm` function accepts the `NextTermInput` directly and extracts the miner list from `input.RealTimeMinersInformation` without any validation that this list matches the Election contract's `GetVictories()` result. [1](#0-0) 

At lines 163 and 188-190, the function converts the input to a Round and directly extracts miners from the unvalidated `RealTimeMinersInformation` dictionary. Compare this to `GenerateFirstRoundOfNextTerm`, which correctly calls `TryToGetVictories()` to obtain the legitimate miner list from the Election contract: [2](#0-1) 

**Missing Validation:** The `RoundTerminateValidationProvider`, which validates NextTerm blocks, only checks round/term number increments and that InValues are null. It does NOT validate the miner list composition or field values: [3](#0-2) 

**Exploitation Mechanism:** The `SolitaryMinerDetection` function relies on `RealTimeMinersInformation.Count > 2` as a gate (line 70) and then calls `GetMinedMiners()` to determine if only one miner has been active: [4](#0-3) 

`GetMinedMiners()` identifies active miners by checking if `supposed_order_of_next_round != 0`: [5](#0-4) 

An attacker can set `supposed_order_of_next_round` to non-zero values in fake `MinerInRound` entries within their malicious `NextTermInput`. ProcessNextTerm only resets `MissedTimeSlots` and `ProducedBlocks` but does NOT sanitize `supposed_order_of_next_round`: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Breach:** The solitary miner detection is a critical safety mechanism designed to prevent a single miner from monopolizing block production when other miners are offline or unreachable. By bypassing this detection, an attacker can:

1. **Maintain Exclusive Mining Power:** Continue producing all blocks indefinitely without the system halting their mining authority
2. **Manipulate Governance:** With exclusive block production, the attacker controls transaction inclusion, potentially censoring governance proposals or other critical transactions
3. **Undermine Decentralization:** The fundamental assumption of the AEDPoS consensus is that multiple independent miners secure the network; this attack allows centralization to persist undetected

**Who is Affected:** All network participants who rely on the consensus mechanism's decentralization guarantees and the Election contract's authority over miner selection.

**Severity Justification:** HIGH - This directly violates the consensus integrity invariant that "miner schedule integrity" must be maintained. It allows a single malicious miner to bypass a critical safety check designed to preserve network liveness and decentralization.

### Likelihood Explanation

**Attacker Capabilities Required:** 
- Must be part of the current miner list (achievable through legitimate election process initially)
- Must have ability to produce a NextTerm block at the appropriate time (inherent to being a current miner)
- No special privileges beyond normal miner permissions required

**Attack Complexity:** MEDIUM
- The attacker needs to construct a `NextTermInput` with fake miner entries
- Set `supposed_order_of_next_round` to non-zero for fake entries
- Ensure fake public keys don't collide with real ones
- Time the attack for the NextTerm transition

**Feasibility Conditions:**
- PreCheck validation only requires attacker to be in current or previous miner list, which they legitimately are: [7](#0-6) 

**Detection Constraints:** 
- The attack may be detected through off-chain monitoring that compares on-chain miner lists with Election contract state
- However, on-chain there is no automatic detection or prevention

**Economic Rationality:** The cost is minimal (just transaction fees for NextTerm), while the benefit is complete control over block production and transaction ordering.

### Recommendation

**Primary Fix:** Validate that the miner list in `NextTermInput` matches the Election contract's authoritative source:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // ADD VALIDATION: Verify miner list matches Election contract
    if (State.IsMainChain.Value)
    {
        var expectedMinerList = State.ElectionContract.GetVictories.Call(new Empty());
        var inputMinerKeys = nextRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        var expectedMinerKeys = expectedMinerList.Value.Select(pk => pk.ToHex()).OrderBy(k => k).ToList();
        
        Assert(inputMinerKeys.SequenceEqual(expectedMinerKeys), 
               "Miner list does not match Election contract victories.");
    }
    
    // Continue with existing logic...
}
```

**Secondary Fix:** Sanitize `MinerInRound` entries to reset `supposed_order_of_next_round` at term start:

```csharp
// Reset some fields of first round of next term.
foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
{
    minerInRound.MissedTimeSlots = 0;
    minerInRound.ProducedBlocks = 0;
    minerInRound.SupposedOrderOfNextRound = 0;  // ADD THIS
    minerInRound.FinalOrderOfNextRound = 0;     // ADD THIS
}
```

**Test Cases:**
1. Test that NextTerm with miner list not matching Election contract is rejected
2. Test that fake entries with non-zero `supposed_order_of_next_round` are sanitized
3. Test that solitary miner detection properly triggers with legitimate miner lists
4. Test that attacker with single real miner + fake entries cannot bypass detection

### Proof of Concept

**Required Initial State:**
- Attacker is elected as one of the legitimate miners for term N
- Network reaches the term transition point
- Attacker has ability to produce the NextTerm block

**Attack Steps:**

1. **Construct Malicious NextTermInput:**
   - Include attacker's real public key
   - Add 2+ fake public keys (e.g., randomly generated keys attacker doesn't control)
   - For each fake entry, set `supposed_order_of_next_round = 1` (or any non-zero value)
   - Set other required fields (order, expected_mining_time, etc.)

2. **Submit NextTerm Transaction:**
   - Call `NextTerm(maliciousInput)` 
   - Transaction passes PreCheck (attacker is in current miner list)
   - Validation only checks round/term numbers and InValues, not miner list
   - ProcessNextTerm accepts and stores the fake miner list

3. **Exploit Solitary Detection Bypass:**
   - In subsequent rounds, only attacker's real key produces blocks
   - When `SolitaryMinerDetection` is called:
     - Line 70: `RealTimeMinersInformation.Count > 2` âœ“ (passes due to fake entries)
     - Line 74: `GetMinedMiners()` returns fake entries (they have `supposed_order_of_next_round != 0`)
     - Line 75: `minedMinersOfCurrentRound.Count != 0` (not alone)
     - Function returns `false` - detection does not trigger
   - Attacker continues mining without interruption

**Expected vs Actual Result:**
- **Expected:** NextTerm should validate miner list against Election contract and reject fake entries; solitary detection should trigger when only one real miner is active
- **Actual:** Fake miner list is accepted; solitary detection is bypassed; attacker maintains exclusive mining control

**Success Condition:** Attacker can produce blocks continuously across multiple rounds while GetMinedMiners() reports multiple active miners due to manipulated `supposed_order_of_next_round` values, even though attacker controls the only real mining key.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L66-96)
```csharp
    private bool SolitaryMinerDetection(Round currentRound, string pubkey)
    {
        var isAlone = false;
        // Skip this detection until 4th round.
        if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
        {
            // Not single node.

            var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
            isAlone = minedMinersOfCurrentRound.Count == 0;

            // If only this node mined during previous round, stop mining.
            if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
            {
                var minedMiners = previousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }

            // check one further round.
            if (isAlone && TryToGetRoundInformation(previousRound.RoundNumber.Sub(1),
                    out var previousPreviousRound))
            {
                var minedMiners = previousPreviousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }
        }

        return isAlone;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```
