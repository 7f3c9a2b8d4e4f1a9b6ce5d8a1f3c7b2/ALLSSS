### Title
Double Removal Vulnerability Allows Profit Share Inflation Through IsWeightRemoved Check Bypass

### Summary
When `RemoveBeneficiary` is called twice with the same `profitDetailId`, the `RemoveProfitDetails` function re-adds an already-removed detail (marked with `IsWeightRemoved = true`) back to the removal list, causing double-counting of removed shares. This incorrectly reduces `TotalShares` twice, inflating the profit share of remaining beneficiaries and enabling them to claim more profits than they deserve.

### Finding Description

The vulnerability exists in `RemoveProfitDetails` function in `ProfitContract.cs`. The root cause is at lines 334-338 where the code adds a detail back to `detailsCanBeRemoved` without checking if it's already been marked as removed. [1](#0-0) 

The vulnerability flow:

1. Lines 321-324 correctly filter out details where `IsWeightRemoved = true` when building `detailsCanBeRemoved`. [2](#0-1) 

2. However, at line 334, the check `profitDetails.Details.Any(d => d.Id == profitDetailId)` searches ALL details WITHOUT filtering by `IsWeightRemoved`, allowing already-removed details to be re-added. [1](#0-0) 

3. When a detail has `LastProfitPeriod < CurrentPeriod`, it's NOT removed from `profitDetails.Details` at line 349, only marked with `IsWeightRemoved = true` and shortened at line 355. [3](#0-2) 

4. On the second `RemoveBeneficiary` call with the same `profitDetailId`, the detail is re-added at line 337 even though `IsWeightRemoved = true`, and `TryAdd` is called again at line 358, double-counting the removal. [4](#0-3) 

5. The `TryAdd` implementation correctly accumulates values for the same period key. [5](#0-4) 

6. This causes `TotalShares` to be reduced twice at line 260 of `RemoveBeneficiary`. [6](#0-5) 

### Impact Explanation

This causes direct fund theft through profit share manipulation. The `TotalShares` denominator used in profit calculations is incorrectly reduced multiple times for the same removal. [7](#0-6) 

**Concrete Example:**
- Initial state: Beneficiary A (1,000 shares), B (1,000 shares), C (8,000 shares), Total = 10,000 shares
- Profit pool: 10,000 tokens to distribute
- Beneficiary A is removed twice with same profitDetailId
- **Expected:** TotalShares = 9,000; B gets (1,000/9,000) × 10,000 = 1,111 tokens; C gets 8,889 tokens
- **Actual:** TotalShares = 8,000; B gets (1,000/8,000) × 10,000 = 1,250 tokens; C gets 8,750 tokens
- **Theft:** B and C steal 139 and 861 tokens respectively (1,000 tokens total excess)

All remaining beneficiaries receive inflated profit shares proportional to their holdings, directly stealing from the profit pool. This violates the critical invariant of "dividend distribution and settlement accuracy" and causes "reward misallocation."

### Likelihood Explanation

**Reachable Entry Point:** `RemoveBeneficiary` is callable by `scheme.Manager` or `TokenHolder` contract. [8](#0-7) 

**Feasible Preconditions:**
1. Scheme has `CanRemoveBeneficiaryDirectly = true` (default for TokenHolder schemes) [9](#0-8) 
2. Beneficiary has a `ProfitDetail` with an `Id` set (common for vote-based schemes)
3. Detail has `LastProfitPeriod < CurrentPeriod` (common case where beneficiary has claimed profits)

**Exploitation Scenarios:**
- **Intentional:** Malicious manager calls `RemoveBeneficiary` twice with same `profitDetailId` to inflate their own or allied beneficiaries' shares
- **Unintentional:** Manager or TokenHolder contract bug causes accidental double-call (e.g., retry logic, state confusion)

**Probability:** HIGH
- Manager authorization is required but managers are often automated contracts (TokenHolder) that could have bugs
- The exploit is trivial to execute (just call the function twice)
- The benefit is immediate and substantial (proportional profit inflation)
- Detection is difficult as the state changes appear valid (`IsWeightRemoved = true` is set)

### Recommendation

**Primary Fix:** At line 334 in `ProfitContract.cs`, add an `IsWeightRemoved` check to prevent re-adding already-removed details:

```csharp
if (profitDetailId != null && 
    profitDetails.Details.Any(d => d.Id == profitDetailId && !d.IsWeightRemoved) &&
    detailsCanBeRemoved.All(d => d.Id != profitDetailId))
{
    detailsCanBeRemoved.Add(profitDetails.Details.Single(d => d.Id == profitDetailId && !d.IsWeightRemoved));
}
```

**Additional Safeguards:**
1. Add assertion in `RemoveBeneficiary` to verify `removedDetails` values don't exceed available shares before reducing `TotalShares`
2. Consider immediately removing details from `profitDetails.Details` after marking `IsWeightRemoved = true` to prevent any re-processing
3. Add comprehensive test case: Call `RemoveBeneficiary` twice consecutively with same `profitDetailId` and verify `TotalShares` is only reduced once

### Proof of Concept

**Initial State:**
- Profit scheme with `CanRemoveBeneficiaryDirectly = true`, `CurrentPeriod = 10`
- Alice: `ProfitDetail(Id=Hash("vote1"), Shares=1000, LastProfitPeriod=5, IsWeightRemoved=false)`
- Bob: `ProfitDetail(Shares=1000)`
- `Scheme.TotalShares = 2000`

**Transaction 1:** Manager calls `RemoveBeneficiary(SchemeId, Alice, profitDetailId=Hash("vote1"))`
- `RemoveProfitDetails` processes Alice's detail
- Line 345: `IsWeightRemoved` set to `true`
- Line 355: `EndPeriod` shortened to 9
- Line 358: `removedDetails.TryAdd(10, 1000)` → `removedDetails[10] = 1000`
- Line 260: `TotalShares = 2000 - 1000 = 1000` ✓

**Transaction 2:** Manager calls `RemoveBeneficiary(SchemeId, Alice, profitDetailId=Hash("vote1"))` **again**
- Lines 321-324: Alice's detail FILTERED OUT (has `IsWeightRemoved = true`)
- `detailsCanBeRemoved` is now **empty**
- Line 334: `profitDetails.Details.Any(d => d.Id == Hash("vote1"))` = **TRUE** (detail still exists in storage!)
- Line 335: `detailsCanBeRemoved.All(d => d.Id != Hash("vote1"))` = **TRUE** (empty list, vacuous truth)
- Line 337: Alice's detail **RE-ADDED** to `detailsCanBeRemoved`
- Line 358: `removedDetails.TryAdd(10, 1000)` → `removedDetails[10] = 2000` (accumulated!)
- Line 260: `TotalShares = 1000 - 2000 = -1000` or `TotalShares = 1000 - 1000 = 0` ✗

**Expected Result:** `TotalShares = 1000`, Bob gets `(1000/1000) × 10000 = 10000` tokens
**Actual Result:** `TotalShares = 0` or negative, Bob gets inflated share (division by zero or using incorrect cached denominator)

**Success Condition:** `TotalShares` reduced twice for single beneficiary removal, enabling remaining beneficiaries to claim inflated profit shares.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L237-239)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L260-260)
```csharp
        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L334-338)
```csharp
        if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
            detailsCanBeRemoved.All(d => d.Id != profitDetailId))
        {
            detailsCanBeRemoved.Add(profitDetails.Details.Single(d => d.Id == profitDetailId));
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L346-356)
```csharp
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L358-358)
```csharp
                removedDetails.TryAdd(scheme.CurrentPeriod, profitDetail.Shares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Profit/Models/RemovedDetails.cs (L8-18)
```csharp
        public void TryAdd(long key, long value)
        {
            if (ContainsKey(key))
            {
                this[key] = this[key].Add(value);
            }
            else
            {
                this[key] = value;
            }
        }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L24-24)
```csharp
            CanRemoveBeneficiaryDirectly = true
```
