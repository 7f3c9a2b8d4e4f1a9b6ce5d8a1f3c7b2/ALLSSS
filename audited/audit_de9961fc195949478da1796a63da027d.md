# Audit Report

## Title 
Side Chain Fails to Validate Incoming Parent Chain Miner List Size Leading to DoS and Storage Exhaustion

## Summary
The `UpdateInformationFromCrossChain()` function on side chains accepts unbounded parent chain miner lists without validating against the side chain's own `MaximumMinersCount` limit. This creates a defensive validation gap that exposes side chains to DoS and storage exhaustion when parent chains have excessively large miner lists due to misconfiguration or bugs.

## Finding Description

The vulnerability exists in the cross-chain consensus information update mechanism. When a side chain indexes parent chain blocks, it extracts and stores the parent chain's miner list without any size validation. [1](#0-0) 

The function unconditionally stores all miner public keys from `consensusInformation.Round.RealTimeMinersInformation.Keys` into `State.MainChainCurrentMinerList.Value` without checking the count against the side chain's own `State.MaximumMinersCount.Value`.

This triggers two critical issues:

**1. Unbounded Token Distribution DoS:**
Before updating the miner list, the function calls `DistributeResourceTokensToPreviousMiners()`: [2](#0-1) 

This performs O(miners × symbols) token transfer operations. With thousands of miners, this could exceed block gas limits or cause transaction timeouts, effectively blocking the consensus update mechanism on the side chain.

**2. Side Chain Consensus Corruption:**
More critically, the `MainChainCurrentMinerList` is used to generate the side chain's own consensus rounds when the parent chain miner list changes: [3](#0-2) 

If the parent chain sends 5,000 miners, the side chain will attempt to generate a consensus round with 5,000 time slots, rendering side chain block production non-functional.

**Root Cause - Missing Upper Bound:**
The parent chain's `SetMaximumMinersCount` method has no upper bound validation: [4](#0-3) 

The only validation is `input.Value > 0`, allowing values up to Int32.MaxValue. While the parent chain manages its own limits, the side chain has no defense when receiving this data.

**Cross-Chain Entry Point:**
The vulnerability is triggered through the normal cross-chain indexing flow: [5](#0-4) 

## Impact Explanation

**Critical Consensus Disruption:**
When a side chain receives an oversized parent chain miner list (e.g., 5,000 miners), `GenerateFirstRoundOfNewTerm` creates a round with 5,000 miner entries: [6](#0-5) 

This loop creates a `MinerInRound` entry for every miner without any cap. The side chain's consensus becomes non-functional as it expects 5,000 miners to participate in block production, each with their own time slot.

**Operational DoS:**
- Token distribution iterates miners × symbols times, potentially exceeding gas limits
- Storage grows proportionally to miner count without bounds
- Cross-chain consensus updates become blocked

**Affected Parties:**
- Side chain cannot produce blocks normally
- Side chain users experience complete service disruption  
- Resource token distribution mechanism fails

## Likelihood Explanation

**Trigger Scenarios:**

1. **Parent Chain Misconfiguration:** Parent chain governance (parliament) can legitimately set `MaximumMinersCount` to any positive integer value. An operational error setting this to 5,000+ would immediately affect all side chains.

2. **Parent Chain Bug:** A bug in parent chain's consensus logic that bypasses `MaximumMinersCount` validation would propagate to all side chains with no defense.

**Feasibility:**
- No cryptographic breaks required
- No consensus manipulation required  
- Triggered through normal cross-chain indexing operations
- Side chains trust parent chain data without defensive validation

**Architectural Gap:**
Side chains have their own `MaximumMinersCount` state variable managed by their own governance: [7](#0-6) 

However, this value is never checked against incoming parent chain data, creating an inconsistency where side chains have limits but don't enforce them for parent chain miners.

**Probability Assessment:**
While parent chain operators are expected to maintain reasonable limits (typical value: 17 miners), the lack of defensive validation means side chains cannot protect themselves from parent chain operational errors or bugs. This represents a realistic operational risk in a multi-chain architecture.

## Recommendation

Add defensive validation in `UpdateInformationFromCrossChain` to enforce the side chain's own `MaximumMinersCount`:

```csharp
public override Empty UpdateInformationFromCrossChain(BytesValue input)
{
    Assert(
        Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
        "Only Cross Chain Contract can call this method.");

    Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

    if (input == null || input.Value.IsEmpty) return new Empty();

    var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

    if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
        return new Empty();
    
    // ADD THIS VALIDATION
    var incomingMinersCount = consensusInformation.Round.RealTimeMinersInformation.Count;
    var sideChainMaxMiners = State.MaximumMinersCount.Value;
    Assert(incomingMinersCount <= sideChainMaxMiners, 
        $"Parent chain miner list size ({incomingMinersCount}) exceeds side chain maximum ({sideChainMaxMiners})");

    DistributeResourceTokensToPreviousMiners();

    State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

    var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
    State.MainChainCurrentMinerList.Value = new MinerList
    {
        Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
    };

    return new Empty();
}
```

This ensures the side chain's governance-controlled limit is enforced against incoming parent chain data, providing defense-in-depth protection.

## Proof of Concept

```csharp
[Fact]
public async Task UpdateInformationFromCrossChain_ExcessiveMinersCount_CausesDoS()
{
    SetToSideChain();
    InitialContracts();
    
    // Set side chain MaximumMinersCount to reasonable value (e.g., 100)
    await ConsensusStub.SetMaximumMinersCount.SendAsync(new Int32Value { Value = 100 });
    
    // Create parent chain consensus data with 5000 miners
    var excessiveMiners = new Dictionary<string, MinerInRound>();
    for (int i = 0; i < 5000; i++)
    {
        var keyPair = CryptoHelper.GenerateKeyPair();
        excessiveMiners.Add(keyPair.PublicKey.ToHex(), new MinerInRound());
    }
    
    var headerInformation = new AElfConsensusHeaderInformation
    {
        Round = new Round
        {
            RoundNumber = 2,
            RealTimeMinersInformation = { excessiveMiners }
        }
    };
    
    // Mock cross chain contract call
    var mockedCrossChain = SampleAccount.Accounts.Last();
    var mockedCrossChainStub = GetTester<AEDPoSContractImplContainer.AEDPoSContractImplStub>(
        ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        mockedCrossChain.KeyPair);
    
    // This should validate but currently accepts 5000 miners without bounds checking
    await mockedCrossChainStub.UpdateInformationFromCrossChain.SendAsync(new BytesValue
    {
        Value = headerInformation.ToByteString()
    });
    
    // Verify side chain accepted oversized miner list
    var minerList = await ConsensusStub.GetMainChainCurrentMinerList.CallAsync(new Empty());
    minerList.Pubkeys.Count.ShouldBe(5000); // Side chain accepted 5000 miners despite its own 100 limit
    
    // This demonstrates the side chain has no defense against excessive parent chain data
}
```

## Notes

This vulnerability represents a defensive validation gap rather than a direct attack vector. The issue arises from the architectural assumption that parent chains will always provide reasonable data. However:

1. **Separate Governance Domains:** Side chains have their own governance and limits, distinct from parent chains
2. **Operational Reality:** Configuration errors and bugs do occur in production systems  
3. **No Recovery Path:** Once a side chain accepts an oversized miner list, its consensus becomes non-functional with no automatic recovery mechanism
4. **Defense-in-Depth Principle:** Even trusted data sources should be validated against local constraints

The side chain's possession of its own `MaximumMinersCount` value suggests it should enforce independent limits. The current implementation creates an inconsistency where this limit exists but is never checked against parent chain data.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L57-61)
```csharp
        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L66-96)
```csharp
    private void DistributeResourceTokensToPreviousMiners()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
        foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
            var amount = balance.Div(minerList.Count);
            Context.LogDebug(() => $"Consensus Contract {symbol} balance: {balance}. Every miner can get {amount}");
            if (amount <= 0) continue;
            foreach (var pubkey in minerList)
            {
                var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
                Context.LogDebug(() => $"Will send {amount} {symbol}s to {pubkey}");
                State.TokenContract.Transfer.Send(new TransferInput
                {
                    To = address,
                    Amount = amount,
                    Symbol = symbol
                });
            }
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L285-295)
```csharp
    private void GenerateNextRoundInformation(Round currentRound, Timestamp currentBlockTime, out Round nextRound)
    {
        TryToGetPreviousRoundInformation(out var previousRound);
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L72-78)
```csharp
    public override Int32Value GetMaximumMinersCount(Empty input)
    {
        return new Int32Value
        {
            Value = Math.Min(GetAutoIncreasedMinersCount(), State.MaximumMinersCount.Value)
        };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L783-787)
```csharp
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L23-38)
```csharp
        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }
```
